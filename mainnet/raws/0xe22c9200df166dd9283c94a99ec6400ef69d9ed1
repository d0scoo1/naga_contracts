{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BigBuyComp/bbc.sol\": {\r\n      \"content\": \"/**\\r\\n    Big Buy Comp ($BBC) has arrived for all degens in the ETH space.\\r\\n    Do you want to claim the title of the Master of the $BBC?\\r\\n    Make the biggest buy within a 10 minutes cycle, become the Master of the $BBC and be rewarded with the $BBC pot collected within that cycle.\\r\\n    The game resets every 10 minutes, so keep flexing your assets away!\\r\\n\\r\\n    Rules of $BBC:\\r\\n\\r\\n    1. Each cycle is 10 minutes\\r\\n    2. Biggest buy within the cycle is rewarded with 4% of tokenomics\\r\\n    3. If the *master of the $Token\u201d sells any amount within the cycle, the game ends and starts again\\r\\n    4. There is a cooldown of 2 cycles for a former master to become a master in a next Game\\r\\n    5. Anyone that makes a bigger purchase than the current master, will steal the title and the timer will reset.\\r\\n    \\r\\n    TG: https://t.me/bbcportal\\r\\n**/\\r\\n\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\npragma solidity ^0.8.12;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function getOwner() external view returns (address);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    function allowance(address _owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\ninterface IDEXFactory {\\r\\n    function createPair(address tokenA, address tokenB)\\r\\n        external\\r\\n        returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IDEXRouter {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function getAmountsIn(uint256 amountOut, address[] memory path)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory amounts);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 amountA,\\r\\n            uint256 amountB,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountETH,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n}\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _setOwner(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _setOwner(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _setOwner(newOwner);\\r\\n    }\\r\\n\\r\\n    function _setOwner(address newOwner) private {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract ERC20Interface {\\r\\n    function balanceOf(address whom) public view virtual returns (uint256);\\r\\n}\\r\\n\\r\\ncontract BigBuyComp is IERC20, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    string constant _name = \\\"Big Buy Comp\\\";\\r\\n    string constant _symbol = \\\"BBC\\\";\\r\\n    uint8 constant _decimals = 18;\\r\\n\\r\\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\\r\\n    address ZERO = 0x0000000000000000000000000000000000000000;\\r\\n    address routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\r\\n\\r\\n    uint256 _totalSupply = 1e6 * (10**_decimals);\\r\\n    uint256 public biggestBuy = 0;\\r\\n    uint256 public lastWhaleChange = 0;\\r\\n    uint256 public resetPeriod = 10 minutes;\\r\\n    mapping(address => uint256) _balances;\\r\\n    mapping(address => mapping(address => uint256)) _allowances;\\r\\n    mapping(address => uint256) public _lastWhaleTimer;\\r\\n    mapping(address => uint256) public _payOut;\\r\\n    mapping(address => bool) public previousWhaleHolder;\\r\\n    mapping(address => bool) public isFeeExempt;\\r\\n    mapping(address => bool) public isTxLimitExempt;\\r\\n    mapping(address => bool) private _isBlackedlisted;\\r\\n\\r\\n    uint256 private constant MAX = ~uint256(0);\\r\\n\\r\\n    uint256 public buyLiquidityFee = 2;\\r\\n    uint256 public buyMarketingFee = 3;\\r\\n    uint256 public buyWhaleFee = 3;\\r\\n    uint256 private buyTotalFee;\\r\\n    \\r\\n\\r\\n    uint256 public sellLiquidityFee = 4;\\r\\n    uint256 public sellMarketingFee = 4;\\r\\n    uint256 public sellWhaleFee = 4;\\r\\n    uint256 private sellTotalFee;\\r\\n\\r\\n    address public autoLiquidityReceiver;\\r\\n    address public marketingWallet;\\r\\n    address public Whale;\\r\\n    address public _payOutAddress;\\r\\n\\r\\n    bool public _isLaunched = false;\\r\\n    uint256 _launchTime;\\r\\n\\r\\n    IDEXRouter public router;\\r\\n    address public pair;\\r\\n\\r\\n    bool inSwapAndLiquify;\\r\\n    bool public swapAndLiquifyEnabled = true;\\r\\n    uint256 public _maxTxAmount = 5e3 * (10**_decimals);\\r\\n    uint256 public _maxWalletAmount = 1e4 * (10**_decimals);\\r\\n    uint256 public swapThreshold = 5e2 * (10**_decimals);\\r\\n\\r\\n    modifier lockTheSwap() {\\r\\n        inSwapAndLiquify = true;\\r\\n        _;\\r\\n        inSwapAndLiquify = false;\\r\\n    }\\r\\n    event AutoLiquify(uint256 amountETH, uint256 amountToken);\\r\\n    event NewWhale(address whale, uint256 buyAmount);\\r\\n    event WhalePayout(address whale, uint256 amountETH);\\r\\n    event WhaleSold(address whale, uint256 amountETH);\\r\\n\\r\\n    constructor()  {\\r\\n        router = IDEXRouter(routerAddress);\\r\\n        pair = IDEXFactory(router.factory()).createPair(router.WETH(), address(this));\\r\\n        _allowances[address(this)][address(router)] = MAX;\\r\\n        isFeeExempt[DEAD] = true;\\r\\n        isFeeExempt[msg.sender] = true;\\r\\n        isFeeExempt[address(this)] = true;\\r\\n        isTxLimitExempt[DEAD] = true;\\r\\n        isTxLimitExempt[msg.sender] = true;\\r\\n        isTxLimitExempt[pair] = true;\\r\\n        autoLiquidityReceiver = msg.sender;\\r\\n        marketingWallet = msg.sender;\\r\\n        Whale = msg.sender;\\r\\n        buyTotalFee = buyLiquidityFee.add(buyMarketingFee).add(buyWhaleFee);\\r\\n        sellTotalFee = sellLiquidityFee.add(sellMarketingFee).add(sellWhaleFee);\\r\\n        _balances[msg.sender] = _totalSupply;\\r\\n        emit Transfer(address(0), msg.sender, _totalSupply);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() external pure override returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function getOwner() external view override returns (address) {\\r\\n        return owner();\\r\\n    }\\r\\n\\r\\n    function totalSupply() external view override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function getCirculatingSupply() public view returns (uint256) {\\r\\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function removeLimitsAndFees() public onlyOwner() {\\r\\n        swapAndLiquifyEnabled=false;\\r\\n        _maxTxAmount=MAX;\\r\\n        _maxWalletAmount=MAX;\\r\\n        buyMarketingFee=0;\\r\\n        buyWhaleFee=0;\\r\\n        buyLiquidityFee=0;\\r\\n        sellLiquidityFee = 0;\\r\\n        sellMarketingFee = 0;\\r\\n        sellWhaleFee = 0;\\r\\n        buyTotalFee = 0;\\r\\n        sellTotalFee = 0;\\r\\n    }\\r\\n\\r\\n    function setBuyFees(uint256 newBuyLiquidityFee, uint256 newBuyMarketingFee, uint256 newBuyWhaleFee) external onlyOwner {\\r\\n        require(newBuyLiquidityFee <= 10, \\\"Invalid fee\\\");\\r\\n        require(newBuyMarketingFee <= 10, \\\"Invalid fee\\\");\\r\\n        require(newBuyWhaleFee <= 10, \\\"Invalid fee\\\");\\r\\n\\r\\n        buyLiquidityFee = newBuyLiquidityFee;\\r\\n        buyMarketingFee = newBuyMarketingFee;\\r\\n        buyWhaleFee = newBuyWhaleFee;\\r\\n        buyTotalFee = buyLiquidityFee.add(buyMarketingFee).add(buyWhaleFee);\\r\\n    }\\r\\n\\r\\n    function setSellFees(uint256 newSellLiquidityFee, uint256 newSellMarketingFee, uint256 newSellWhaleFee) external onlyOwner {\\r\\n        require(newSellLiquidityFee <= 10, \\\"Invalid fee\\\");\\r\\n        require(newSellMarketingFee <= 10, \\\"Invalid fee\\\");\\r\\n        require(newSellWhaleFee <= 10, \\\"Invalid fee\\\");\\r\\n\\r\\n        sellLiquidityFee = newSellLiquidityFee;\\r\\n        sellMarketingFee = newSellMarketingFee;\\r\\n        sellWhaleFee = newSellWhaleFee;\\r\\n        sellTotalFee = sellLiquidityFee.add(sellMarketingFee).add(sellWhaleFee);\\r\\n    }\\r\\n\\r\\n    function allowance(address holder, address spender) external view override returns (uint256) {\\r\\n        return _allowances[holder][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\r\\n        _allowances[msg.sender][spender] = amount;\\r\\n        emit Approval(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approveMax(address spender) external returns (bool) {\\r\\n        return approve(spender, MAX);\\r\\n    }\\r\\n\\r\\n    function setIsFeeExempt(address[] memory accounts, bool exempt) external onlyOwner {\\r\\n        for (uint i = 0; i < accounts.length; i++) {\\r\\n            isFeeExempt[accounts[i]] = exempt;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setIsTxLimitExempt(address[] memory accounts, bool exempt) external onlyOwner {\\r\\n        for (uint i = 0; i < accounts.length; i++) {\\r\\n            isTxLimitExempt[accounts[i]] = exempt;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function setBlacklist(address[] memory accounts, bool exempt) external onlyOwner {\\r\\n        for (uint i = 0; i < accounts.length; i++) {\\r\\n            _isBlackedlisted[accounts[i]] = exempt;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isBlacklisted(address account) external view returns (bool) {\\r\\n        return _isBlackedlisted[account];\\r\\n    }\\r\\n\\r\\n    function autoBlacklist(address addr) private {\\r\\n        _isBlackedlisted[addr]=true;\\r\\n    }\\r\\n\\r\\n    function setSwapThreshold(uint256 threshold) external onlyOwner {\\r\\n        swapThreshold = threshold;\\r\\n    }\\r\\n\\r\\n    function setFeeReceivers(address newLiquidityReceiver, address newMarketingWallet) external onlyOwner {\\r\\n        autoLiquidityReceiver = newLiquidityReceiver;\\r\\n        marketingWallet = newMarketingWallet;\\r\\n    }\\r\\n\\r\\n    function setResetPeriodInSeconds(uint256 newResetPeriod) external onlyOwner {\\r\\n        resetPeriod = newResetPeriod;\\r\\n    }\\r\\n\\r\\n    function _reset() internal {\\r\\n        Whale = marketingWallet;\\r\\n        biggestBuy = 0;\\r\\n        lastWhaleChange = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function epochReset() external view returns (uint256) {\\r\\n        return lastWhaleChange + resetPeriod;\\r\\n    }\\r\\n\\r\\n    function letsGo() external onlyOwner {\\r\\n        require (_isLaunched == false, \\\"Already launched\\\");\\r\\n        _isLaunched = true;\\r\\n        _launchTime = block.timestamp;\\r\\n        Whale = marketingWallet;\\r\\n        biggestBuy = 0;\\r\\n        lastWhaleChange = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function setMaxWalletSize(uint256 amount) external onlyOwner {\\r\\n        require(amount >= 1e3 * (10**_decimals), \\\"Max wallet size is too low\\\");\\r\\n        _maxWalletAmount = amount;\\r\\n\\r\\n    }\\r\\n\\r\\n    function setMaxTransactionSize(uint256 amount) external onlyOwner {\\r\\n        require(amount >= 1e3 * (10**_decimals), \\\"Max transaction size is too low\\\");\\r\\n        _maxTxAmount = amount;\\r\\n\\r\\n    }\\r\\n\\r\\n    function _checkTxLimit(address sender, address recipient, uint256 amount) internal {\\r\\n        if (block.timestamp - lastWhaleChange > resetPeriod) {\\r\\n            _reset();\\r\\n        }\\r\\n\\r\\n        if (sender != owner() && recipient != owner() && !isTxLimitExempt[recipient] && recipient != ZERO && recipient != DEAD && recipient != pair && recipient != address(this)) {\\r\\n            require(amount <= _maxTxAmount, \\\"Transaction exceeds limit.\\\");\\r\\n            uint256 contractBalanceRecipient = balanceOf(recipient);\\r\\n            require(contractBalanceRecipient + amount <= _maxWalletAmount, \\\"Exceeds maximum wallet token amount\\\");\\r\\n\\r\\n            address[] memory path = new address[](2);\\r\\n            path[0] = router.WETH();\\r\\n            path[1] = address(this);\\r\\n            uint256 usedEth = router.getAmountsIn(amount, path)[0];\\r\\n\\r\\n            if (previousWhaleHolder[recipient] && _lastWhaleTimer[recipient] + 1 hours < block.timestamp && usedEth > biggestBuy) {\\r\\n                Whale = recipient;\\r\\n                biggestBuy = usedEth;\\r\\n                lastWhaleChange = block.timestamp;\\r\\n                emit NewWhale(Whale, biggestBuy);\\r\\n            } else if (!previousWhaleHolder[recipient]  && usedEth > biggestBuy) {\\r\\n                Whale = recipient;\\r\\n                biggestBuy = usedEth;\\r\\n                lastWhaleChange = block.timestamp;\\r\\n                emit NewWhale(Whale, biggestBuy);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (sender != owner() && recipient != owner() && !isTxLimitExempt[sender] && sender != pair && recipient != address(this)) {\\r\\n            require(amount <= _maxTxAmount, \\\"Transaction exceeds limit.\\\");\\r\\n            if (Whale == sender) {\\r\\n                emit WhaleSold(Whale, biggestBuy);\\r\\n                _reset();\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setSwapBackSettings(bool enableSwapBack, uint256 newSwapBackLimit) external onlyOwner {\\r\\n        swapAndLiquifyEnabled = enableSwapBack;\\r\\n        swapThreshold = newSwapBackLimit;\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\r\\n        return _transferFrom(msg.sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function transferFrom( address sender, address recipient, uint256 amount) external override returns (bool) {\\r\\n        if (_allowances[sender][msg.sender] != MAX) {\\r\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \\\"Insufficient Allowance\\\");\\r\\n        }\\r\\n        _transferFrom(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\\r\\n        require(_isBlackedlisted[sender]!=true && _isBlackedlisted[recipient]!=true, \\\"You're blacklisted.\\\");\\r\\n        if (inSwapAndLiquify) {\\r\\n            return _basicTransfer(sender, recipient, amount);\\r\\n        }\\r\\n\\r\\n        if (msg.sender != pair && !inSwapAndLiquify && swapAndLiquifyEnabled && _balances[address(this)] >= swapThreshold) {\\r\\n            swapBack(recipient);\\r\\n        }\\r\\n\\r\\n        require(!isWalletToWallet(sender, recipient), \\\"Don't cheat\\\");\\r\\n        _checkTxLimit(sender, recipient, amount);\\r\\n\\r\\n        uint256 amountReceived = !isFeeExempt[sender] && !isFeeExempt[recipient] ? takeFee(sender, recipient, amount) : amount;\\r\\n\\r\\n        if (!_isLaunched && recipient != pair && sender != owner() && recipient != owner()) {                       \\r\\n            autoBlacklist(recipient);\\r\\n        }\\r\\n\\r\\n        _balances[recipient] = _balances[recipient].add(amountReceived);\\r\\n        _balances[sender] = _balances[sender].sub(amount);\\r\\n\\r\\n        emit Transfer(msg.sender, recipient, amountReceived);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"Insufficient Balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function takeFee(address sender, address recipient, uint256 amount) internal returns (uint256) {\\r\\n        uint256 totalFee;\\r\\n        if (recipient == pair) {\\r\\n            totalFee = sellTotalFee;\\r\\n        } else {\\r\\n            totalFee = buyTotalFee;\\r\\n        }\\r\\n        uint256 feeAmount = amount.mul(totalFee).div(100);\\r\\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\\r\\n        emit Transfer(sender, address(this), feeAmount);\\r\\n        return amount.sub(feeAmount);\\r\\n    }\\r\\n\\r\\n    function isWalletToWallet(address sender, address recipient) internal view returns (bool) {\\r\\n        if (isFeeExempt[sender] || isFeeExempt[recipient]) {\\r\\n            return false;\\r\\n        }\\r\\n        if (sender == pair || recipient == pair) {\\r\\n            return false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function swapBack(address recipient) internal lockTheSwap {\\r\\n        uint256 totalFee;\\r\\n        uint256 liquidityFee;\\r\\n        uint256 marketingFee;\\r\\n        uint256 whaleFee;\\r\\n        uint256 tokensToLiquify = swapThreshold;\\r\\n\\r\\n        if (recipient == pair) {\\r\\n            totalFee = sellTotalFee;\\r\\n            liquidityFee = sellLiquidityFee;\\r\\n            marketingFee = sellMarketingFee;\\r\\n            whaleFee = sellWhaleFee;\\r\\n        } else {\\r\\n            totalFee = buyTotalFee;\\r\\n            liquidityFee = buyLiquidityFee;\\r\\n            marketingFee = buyMarketingFee;\\r\\n            whaleFee = buyWhaleFee;\\r\\n        }\\r\\n\\r\\n        uint256 amountToLiquify = tokensToLiquify.mul(liquidityFee).div(totalFee).div(2);\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = router.WETH();\\r\\n\\r\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokensToLiquify.sub(amountToLiquify), \\r\\n            0, \\r\\n            path, \\r\\n            address(this), \\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        uint256 amountETH = address(this).balance;\\r\\n        uint256 totalETHFee = totalFee.sub(liquidityFee.div(2));\\r\\n        uint256 amountETHMarketing = amountETH.mul(marketingFee).div(totalETHFee);\\r\\n        uint256 amountETHWhale = amountETH.mul(whaleFee).div(totalETHFee);\\r\\n        uint256 amountETHLiquidity = amountETH.mul(liquidityFee).div(totalETHFee).div(2);\\r\\n\\r\\n        (bool tmpSuccess, ) = payable(marketingWallet).call{value: amountETHMarketing, gas: 30000}(\\\"\\\");\\r\\n        (bool tmpSuccess2, ) = payable(Whale).call{value: amountETHWhale, gas: 30000}(\\\"\\\");\\r\\n\\r\\n        _payOut[Whale]=amountETHWhale;\\r\\n        previousWhaleHolder[Whale]=true;\\r\\n        _lastWhaleTimer[Whale] = block.timestamp;\\r\\n        emit WhalePayout(Whale, amountETHWhale);\\r\\n\\r\\n        tmpSuccess = false;\\r\\n        tmpSuccess2 = false;\\r\\n\\r\\n        if (amountToLiquify > 0) {\\r\\n            router.addLiquidityETH{value: amountETHLiquidity}(\\r\\n                address(this),\\r\\n                amountToLiquify,\\r\\n                0,\\r\\n                0,\\r\\n                autoLiquidityReceiver,\\r\\n                block.timestamp\\r\\n            );\\r\\n            emit AutoLiquify(amountETHLiquidity, amountToLiquify);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function recoverLostETH() external onlyOwner {\\r\\n        payable(msg.sender).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function recoverLostTokens(address _token, uint256 _amount) external onlyOwner {\\r\\n        IERC20(_token).transfer(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n    function manualSwap() public onlyOwner() {\\r\\n        uint256 contractBalance = balanceOf(address(this));\\r\\n        swapTokensForEth(contractBalance);\\r\\n    }\\r\\n    \\r\\n    function manualSend() public onlyOwner() {\\r\\n        uint256 contractETHBalance = address(this).balance;\\r\\n        sendETHToFee(contractETHBalance);\\r\\n    }\\r\\n\\r\\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = router.WETH();\\r\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function sendETHToFee(uint256 amount) private {\\r\\n        payable(marketingWallet).transfer(amount);\\r\\n    }\\r\\n\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"whale\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"}],\"name\":\"NewWhale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"whale\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"WhalePayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"whale\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"WhaleSold\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Whale\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_isLaunched\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_lastWhaleTimer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_payOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_payOutAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"biggestBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyMarketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyWhaleFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochReset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTxLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastWhaleChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"letsGo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"previousWhaleHolder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverLostETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"recoverLostTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimitsAndFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellMarketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellWhaleFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBuyLiquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newBuyMarketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newBuyWhaleFee\",\"type\":\"uint256\"}],\"name\":\"setBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLiquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newMarketingWallet\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxTransactionSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newResetPeriod\",\"type\":\"uint256\"}],\"name\":\"setResetPeriodInSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSellLiquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSellMarketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSellWhaleFee\",\"type\":\"uint256\"}],\"name\":\"setSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enableSwapBack\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"newSwapBackLimit\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"setSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BigBuyComp", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}