{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/0.4.24/oracle/LidoOracle.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\n/* See contracts/COMPILERS.md */\\npragma solidity 0.4.24;\\n\\nimport \\\"@aragon/os/contracts/apps/AragonApp.sol\\\";\\nimport \\\"@aragon/os/contracts/lib/math/SafeMath.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/introspection/ERC165Checker.sol\\\";\\n\\nimport \\\"../interfaces/IBeaconReportReceiver.sol\\\";\\nimport \\\"../interfaces/ILido.sol\\\";\\nimport \\\"../interfaces/ILidoOracle.sol\\\";\\n\\nimport \\\"./ReportUtils.sol\\\";\\n\\n\\n/**\\n * @title Implementation of an ETH 2.0 -> ETH oracle\\n *\\n * The goal of the oracle is to inform other parts of the system about balances controlled by the\\n * DAO on the ETH 2.0 side. The balances can go up because of reward accumulation and can go down\\n * because of slashing.\\n *\\n * The timeline is divided into consecutive frames. Every oracle member may push its report once\\n * per frame. When the equal reports reach the configurable 'quorum' value, this frame is\\n * considered finalized and the resulting report is pushed to Lido.\\n *\\n * Not all frames may come to a quorum. Oracles may report only to the first epoch of the frame and\\n * only if no quorum is reached for this epoch yet.\\n */\\ncontract LidoOracle is ILidoOracle, AragonApp {\\n    using SafeMath for uint256;\\n    using ReportUtils for uint256;\\n    using ERC165Checker for address;\\n\\n    struct BeaconSpec {\\n        uint64 epochsPerFrame;\\n        uint64 slotsPerEpoch;\\n        uint64 secondsPerSlot;\\n        uint64 genesisTime;\\n    }\\n\\n    /// ACL\\n    bytes32 constant public MANAGE_MEMBERS =\\n        0xbf6336045918ae0015f4cdb3441a2fdbfaa4bcde6558c8692aac7f56c69fb067; // keccak256(\\\"MANAGE_MEMBERS\\\")\\n    bytes32 constant public MANAGE_QUORUM =\\n        0xa5ffa9f45fa52c446078e834e1914561bd9c2ab1e833572d62af775da092ccbc; // keccak256(\\\"MANAGE_QUORUM\\\")\\n    bytes32 constant public SET_BEACON_SPEC =\\n        0x16a273d48baf8111397316e6d961e6836913acb23b181e6c5fb35ec0bd2648fc; // keccak256(\\\"SET_BEACON_SPEC\\\")\\n    bytes32 constant public SET_REPORT_BOUNDARIES =\\n        0x44adaee26c92733e57241cb0b26ffaa2d182ed7120ba3ecd7e0dce3635c01dc1; // keccak256(\\\"SET_REPORT_BOUNDARIES\\\")\\n    bytes32 constant public SET_BEACON_REPORT_RECEIVER =\\n        0xe22a455f1bfbaf705ac3e891a64e156da92cb0b42cfc389158e6e82bd57f37be; // keccak256(\\\"SET_BEACON_REPORT_RECEIVER\\\")\\n\\n    /// Maximum number of oracle committee members\\n    uint256 public constant MAX_MEMBERS = 256;\\n\\n    /// Eth1 denomination is 18 digits, while Eth2 has 9 digits. Because we work with Eth2\\n    /// balances and to support old interfaces expecting eth1 format, we multiply by this\\n    /// coefficient.\\n    uint128 internal constant DENOMINATION_OFFSET = 1e9;\\n\\n    uint256 internal constant MEMBER_NOT_FOUND = uint256(-1);\\n\\n    /// Number of exactly the same reports needed to finalize the epoch\\n    bytes32 internal constant QUORUM_POSITION =\\n        0xd43b42c1ba05a1ab3c178623a49b2cdb55f000ec70b9ccdba5740b3339a7589e; // keccak256(\\\"lido.LidoOracle.quorum\\\")\\n\\n    /// Address of the Lido contract\\n    bytes32 internal constant LIDO_POSITION =\\n        0xf6978a4f7e200f6d3a24d82d44c48bddabce399a3b8ec42a480ea8a2d5fe6ec5; // keccak256(\\\"lido.LidoOracle.lido\\\")\\n\\n    /// Storage for the actual beacon chain specification\\n    bytes32 internal constant BEACON_SPEC_POSITION =\\n        0x805e82d53a51be3dfde7cfed901f1f96f5dad18e874708b082adb8841e8ca909; // keccak256(\\\"lido.LidoOracle.beaconSpec\\\")\\n\\n    /// Version of the initialized contract data\\n    /// NB: Contract versioning starts from 1.\\n    /// The version stored in CONTRACT_VERSION_POSITION equals to\\n    /// - 0 right after deployment when no initializer is invoked yet\\n    /// - N after calling initialize() during deployment from scratch, where N is the current contract version\\n    /// - N after upgrading contract from the previous version (after calling finalize_vN())\\n    bytes32 internal constant CONTRACT_VERSION_POSITION =\\n        0x75be19a3f314d89bd1f84d30a6c84e2f1cd7afc7b6ca21876564c265113bb7e4; // keccak256(\\\"lido.LidoOracle.contractVersion\\\")\\n\\n    /// Epoch that we currently collect reports\\n    bytes32 internal constant EXPECTED_EPOCH_ID_POSITION =\\n        0x65f1a0ee358a8a4000a59c2815dc768eb87d24146ca1ac5555cb6eb871aee915; // keccak256(\\\"lido.LidoOracle.expectedEpochId\\\")\\n\\n    /// The bitmask of the oracle members that pushed their reports\\n    bytes32 internal constant REPORTS_BITMASK_POSITION =\\n        0xea6fa022365e4737a3bb52facb00ddc693a656fb51ffb2b4bd24fb85bdc888be; // keccak256(\\\"lido.LidoOracle.reportsBitMask\\\")\\n\\n    /// Historic data about 2 last completed reports and their times\\n    bytes32 internal constant POST_COMPLETED_TOTAL_POOLED_ETHER_POSITION =\\n        0xaa8433b13d2b111d4f84f6f374bc7acbe20794944308876aa250fa9a73dc7f53; // keccak256(\\\"lido.LidoOracle.postCompletedTotalPooledEther\\\")\\n    bytes32 internal constant PRE_COMPLETED_TOTAL_POOLED_ETHER_POSITION =\\n        0x1043177539af09a67d747435df3ff1155a64cd93a347daaac9132a591442d43e; // keccak256(\\\"lido.LidoOracle.preCompletedTotalPooledEther\\\")\\n    bytes32 internal constant LAST_COMPLETED_EPOCH_ID_POSITION =\\n        0xdad15c0beecd15610092d84427258e369d2582df22869138b4c5265f049f574c; // keccak256(\\\"lido.LidoOracle.lastCompletedEpochId\\\")\\n    bytes32 internal constant TIME_ELAPSED_POSITION =\\n        0x8fe323f4ecd3bf0497252a90142003855cc5125cee76a5b5ba5d508c7ec28c3a; // keccak256(\\\"lido.LidoOracle.timeElapsed\\\")\\n\\n    /// Receiver address to be called when the report is pushed to Lido\\n    bytes32 internal constant BEACON_REPORT_RECEIVER_POSITION =\\n        0xb59039ed37776bc23c5d272e10b525a957a1dfad97f5006c84394b6b512c1564; // keccak256(\\\"lido.LidoOracle.beaconReportReceiver\\\")\\n\\n    /// Upper bound of the reported balance possible increase in APR, controlled by the governance\\n    bytes32 internal constant ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION =\\n        0x613075ab597bed8ce2e18342385ce127d3e5298bc7a84e3db68dc64abd4811ac; // keccak256(\\\"lido.LidoOracle.allowedBeaconBalanceAnnualRelativeIncrease\\\")\\n\\n    /// Lower bound of the reported balance possible decrease, controlled by the governance\\n    ///\\n    /// @notice When slashing happens, the balance may decrease at a much faster pace. Slashing are\\n    /// one-time events that decrease the balance a fair amount - a few percent at a time in a\\n    /// realistic scenario. Thus, instead of sanity check for an APR, we check if the plain relative\\n    /// decrease is within bounds.  Note that it's not annual value, its just one-jump value.\\n    bytes32 internal constant ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION =\\n        0x92ba7776ed6c5d13cf023555a94e70b823a4aebd56ed522a77345ff5cd8a9109; // keccak256(\\\"lido.LidoOracle.allowedBeaconBalanceDecrease\\\")\\n\\n    /// This is a dead variable: it was used only in v1 and in upgrade v1 --> v2\\n    /// Just keep in mind that storage at this position is occupied but with no actual usage\\n    bytes32 internal constant V1_LAST_REPORTED_EPOCH_ID_POSITION =\\n        0xfe0250ed0c5d8af6526c6d133fccb8e5a55dd6b1aa6696ed0c327f8e517b5a94; // keccak256(\\\"lido.LidoOracle.lastReportedEpochId\\\")\\n\\n    /// Contract structured storage\\n    address[] private members;                /// slot 0: oracle committee members\\n    uint256[] private currentReportVariants;  /// slot 1: reporting storage\\n\\n\\n    /**\\n     * @notice Return the Lido contract address\\n     */\\n    function getLido() public view returns (ILido) {\\n        return ILido(LIDO_POSITION.getStorageAddress());\\n    }\\n\\n    /**\\n     * @notice Return the number of exactly the same reports needed to finalize the epoch\\n     */\\n    function getQuorum() public view returns (uint256) {\\n        return QUORUM_POSITION.getStorageUint256();\\n    }\\n\\n    /**\\n     * @notice Return the upper bound of the reported balance possible increase in APR\\n     */\\n    function getAllowedBeaconBalanceAnnualRelativeIncrease() external view returns (uint256) {\\n        return ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION.getStorageUint256();\\n    }\\n\\n    /**\\n     * @notice Return the lower bound of the reported balance possible decrease\\n     */\\n    function getAllowedBeaconBalanceRelativeDecrease() external view returns (uint256) {\\n        return ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION.getStorageUint256();\\n    }\\n\\n    /**\\n     * @notice Set the upper bound of the reported balance possible increase in APR to `_value`\\n     */\\n    function setAllowedBeaconBalanceAnnualRelativeIncrease(uint256 _value) external auth(SET_REPORT_BOUNDARIES) {\\n        ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION.setStorageUint256(_value);\\n        emit AllowedBeaconBalanceAnnualRelativeIncreaseSet(_value);\\n    }\\n\\n    /**\\n     * @notice Set the lower bound of the reported balance possible decrease to `_value`\\n     */\\n    function setAllowedBeaconBalanceRelativeDecrease(uint256 _value) external auth(SET_REPORT_BOUNDARIES) {\\n        ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION.setStorageUint256(_value);\\n        emit AllowedBeaconBalanceRelativeDecreaseSet(_value);\\n    }\\n\\n    /**\\n     * @notice Return the receiver contract address to be called when the report is pushed to Lido\\n     */\\n    function getBeaconReportReceiver() external view returns (address) {\\n        return address(BEACON_REPORT_RECEIVER_POSITION.getStorageUint256());\\n    }\\n\\n    /**\\n     * @notice Set the receiver contract address to `_addr` to be called when the report is pushed\\n     * @dev Specify 0 to disable this functionality\\n     */\\n    function setBeaconReportReceiver(address _addr) external auth(SET_BEACON_REPORT_RECEIVER) {\\n        if(_addr != address(0)) {\\n            IBeaconReportReceiver iBeacon;\\n            require(\\n                _addr._supportsInterface(iBeacon.processLidoOracleReport.selector),\\n                \\\"BAD_BEACON_REPORT_RECEIVER\\\"\\n            );\\n        }\\n\\n        BEACON_REPORT_RECEIVER_POSITION.setStorageUint256(uint256(_addr));\\n        emit BeaconReportReceiverSet(_addr);\\n    }\\n\\n    /**\\n     * @notice Return the current reporting bitmap, representing oracles who have already pushed\\n     * their version of report during the expected epoch\\n     * @dev Every oracle bit corresponds to the index of the oracle in the current members list\\n     */\\n    function getCurrentOraclesReportStatus() external view returns (uint256) {\\n        return REPORTS_BITMASK_POSITION.getStorageUint256();\\n    }\\n\\n    /**\\n     * @notice Return the current reporting variants array size\\n     */\\n    function getCurrentReportVariantsSize() external view returns (uint256) {\\n        return currentReportVariants.length;\\n    }\\n\\n    /**\\n     * @notice Return the current reporting array element with index `_index`\\n     */\\n    function getCurrentReportVariant(uint256 _index)\\n        external\\n        view\\n        returns (\\n            uint64 beaconBalance,\\n            uint32 beaconValidators,\\n            uint16 count\\n        )\\n    {\\n        return currentReportVariants[_index].decodeWithCount();\\n    }\\n\\n    /**\\n     * @notice Returns epoch that can be reported by oracles\\n     */\\n    function getExpectedEpochId() external view returns (uint256) {\\n        return EXPECTED_EPOCH_ID_POSITION.getStorageUint256();\\n    }\\n\\n    /**\\n     * @notice Return the current oracle member committee list\\n     */\\n    function getOracleMembers() external view returns (address[]) {\\n        return members;\\n    }\\n\\n    /**\\n     * @notice Return the initialized version of this contract starting from 0\\n     */\\n    function getVersion() external view returns (uint256) {\\n        return CONTRACT_VERSION_POSITION.getStorageUint256();\\n    }\\n\\n    /**\\n     * @notice Return beacon specification data\\n     */\\n    function getBeaconSpec()\\n        external\\n        view\\n        returns (\\n            uint64 epochsPerFrame,\\n            uint64 slotsPerEpoch,\\n            uint64 secondsPerSlot,\\n            uint64 genesisTime\\n        )\\n    {\\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\\n        return (\\n            beaconSpec.epochsPerFrame,\\n            beaconSpec.slotsPerEpoch,\\n            beaconSpec.secondsPerSlot,\\n            beaconSpec.genesisTime\\n        );\\n    }\\n\\n    /**\\n     * @notice Update beacon specification data\\n     */\\n    function setBeaconSpec(\\n        uint64 _epochsPerFrame,\\n        uint64 _slotsPerEpoch,\\n        uint64 _secondsPerSlot,\\n        uint64 _genesisTime\\n    )\\n        external\\n        auth(SET_BEACON_SPEC)\\n    {\\n        _setBeaconSpec(\\n            _epochsPerFrame,\\n            _slotsPerEpoch,\\n            _secondsPerSlot,\\n            _genesisTime\\n        );\\n    }\\n\\n    /**\\n     * @notice Return the epoch calculated from current timestamp\\n     */\\n    function getCurrentEpochId() external view returns (uint256) {\\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\\n        return _getCurrentEpochId(beaconSpec);\\n    }\\n\\n    /**\\n     * @notice Return currently reportable epoch (the first epoch of the current frame) as well as\\n     * its start and end times in seconds\\n     */\\n    function getCurrentFrame()\\n        external\\n        view\\n        returns (\\n            uint256 frameEpochId,\\n            uint256 frameStartTime,\\n            uint256 frameEndTime\\n        )\\n    {\\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\\n        uint64 genesisTime = beaconSpec.genesisTime;\\n        uint64 secondsPerEpoch = beaconSpec.secondsPerSlot * beaconSpec.slotsPerEpoch;\\n\\n        frameEpochId = _getFrameFirstEpochId(_getCurrentEpochId(beaconSpec), beaconSpec);\\n        frameStartTime = frameEpochId * secondsPerEpoch + genesisTime;\\n        frameEndTime = (frameEpochId + beaconSpec.epochsPerFrame) * secondsPerEpoch + genesisTime - 1;\\n    }\\n\\n    /**\\n     * @notice Return last completed epoch\\n     */\\n    function getLastCompletedEpochId() external view returns (uint256) {\\n        return LAST_COMPLETED_EPOCH_ID_POSITION.getStorageUint256();\\n    }\\n\\n    /**\\n     * @notice Report beacon balance and its change during the last frame\\n     */\\n    function getLastCompletedReportDelta()\\n        external\\n        view\\n        returns (\\n            uint256 postTotalPooledEther,\\n            uint256 preTotalPooledEther,\\n            uint256 timeElapsed\\n        )\\n    {\\n        postTotalPooledEther = POST_COMPLETED_TOTAL_POOLED_ETHER_POSITION.getStorageUint256();\\n        preTotalPooledEther = PRE_COMPLETED_TOTAL_POOLED_ETHER_POSITION.getStorageUint256();\\n        timeElapsed = TIME_ELAPSED_POSITION.getStorageUint256();\\n    }\\n\\n    /**\\n     * @notice Initialize the contract (version 3 for now) from scratch\\n     * @dev For details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\\n     * @param _lido Address of Lido contract\\n     * @param _epochsPerFrame Number of epochs per frame\\n     * @param _slotsPerEpoch Number of slots per epoch\\n     * @param _secondsPerSlot Number of seconds per slot\\n     * @param _genesisTime Genesis time\\n     * @param _allowedBeaconBalanceAnnualRelativeIncrease Allowed beacon balance annual relative increase (e.g. 1000 means 10% increase)\\n     * @param _allowedBeaconBalanceRelativeDecrease Allowed beacon balance instantaneous decrease (e.g. 500 means 5% decrease)\\n     */\\n    function initialize(\\n        address _lido,\\n        uint64 _epochsPerFrame,\\n        uint64 _slotsPerEpoch,\\n        uint64 _secondsPerSlot,\\n        uint64 _genesisTime,\\n        uint256 _allowedBeaconBalanceAnnualRelativeIncrease,\\n        uint256 _allowedBeaconBalanceRelativeDecrease\\n    )\\n        external onlyInit\\n    {\\n        assert(1 == ((1 << (MAX_MEMBERS - 1)) >> (MAX_MEMBERS - 1)));  // static assert\\n\\n        // We consider storage state right after deployment (no initialize() called yet) as version 0\\n\\n        // Initializations for v0 --> v1\\n        require(CONTRACT_VERSION_POSITION.getStorageUint256() == 0, \\\"BASE_VERSION_MUST_BE_ZERO\\\");\\n\\n        _setBeaconSpec(\\n            _epochsPerFrame,\\n            _slotsPerEpoch,\\n            _secondsPerSlot,\\n            _genesisTime\\n        );\\n\\n        LIDO_POSITION.setStorageAddress(_lido);\\n\\n        QUORUM_POSITION.setStorageUint256(1);\\n        emit QuorumChanged(1);\\n\\n        // Initializations for v1 --> v2\\n        ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION\\n            .setStorageUint256(_allowedBeaconBalanceAnnualRelativeIncrease);\\n        emit AllowedBeaconBalanceAnnualRelativeIncreaseSet(_allowedBeaconBalanceAnnualRelativeIncrease);\\n\\n        ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION\\n            .setStorageUint256(_allowedBeaconBalanceRelativeDecrease);\\n        emit AllowedBeaconBalanceRelativeDecreaseSet(_allowedBeaconBalanceRelativeDecrease);\\n\\n        // set expected epoch to the first epoch for the next frame\\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\\n        uint256 expectedEpoch = _getFrameFirstEpochId(0, beaconSpec) + beaconSpec.epochsPerFrame;\\n        EXPECTED_EPOCH_ID_POSITION.setStorageUint256(expectedEpoch);\\n        emit ExpectedEpochIdUpdated(expectedEpoch);\\n\\n        // Initializations for v2 --> v3\\n        _initialize_v3();\\n\\n        // Needed to finish the Aragon part of initialization (otherwise auth() modifiers will fail)\\n        initialized();\\n    }\\n\\n    /**\\n     * @notice A function to finalize upgrade to v3 (from v1). Can be called only once\\n     * @dev Value 2 in CONTRACT_VERSION_POSITION is skipped due to change in numbering\\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\\n     */\\n    function finalizeUpgrade_v3() external {\\n        require(CONTRACT_VERSION_POSITION.getStorageUint256() == 1, \\\"WRONG_BASE_VERSION\\\");\\n\\n        _initialize_v3();\\n    }\\n\\n    /**\\n     * @notice A dummy incremental v1/v2 --> v3 initialize function. Just corrects version number in storage\\n     * @dev This function is introduced just to set in correspondence version number in storage,\\n     * semantic version of the contract and number N used in naming of _initialize_nN/finalizeUpgrade_vN.\\n     * NB, that thus version 2 is skipped\\n     */\\n    function _initialize_v3() internal {\\n        CONTRACT_VERSION_POSITION.setStorageUint256(3);\\n        emit ContractVersionSet(3);\\n    }\\n\\n    /**\\n     * @notice Add `_member` to the oracle member committee list\\n     */\\n    function addOracleMember(address _member) external auth(MANAGE_MEMBERS) {\\n        require(address(0) != _member, \\\"BAD_ARGUMENT\\\");\\n        require(MEMBER_NOT_FOUND == _getMemberId(_member), \\\"MEMBER_EXISTS\\\");\\n        require(members.length < MAX_MEMBERS, \\\"TOO_MANY_MEMBERS\\\");\\n\\n        members.push(_member);\\n\\n        emit MemberAdded(_member);\\n    }\\n\\n    /**\\n     * @notice Remove '_member` from the oracle member committee list\\n     */\\n    function removeOracleMember(address _member) external auth(MANAGE_MEMBERS) {\\n        uint256 index = _getMemberId(_member);\\n        require(index != MEMBER_NOT_FOUND, \\\"MEMBER_NOT_FOUND\\\");\\n        uint256 last = members.length - 1;\\n        if (index != last) members[index] = members[last];\\n        members.length--;\\n        emit MemberRemoved(_member);\\n\\n        // delete the data for the last epoch, let remained oracles report it again\\n        REPORTS_BITMASK_POSITION.setStorageUint256(0);\\n        delete currentReportVariants;\\n    }\\n\\n    /**\\n     * @notice Set the number of exactly the same reports needed to finalize the epoch to `_quorum`\\n     */\\n    function setQuorum(uint256 _quorum) external auth(MANAGE_QUORUM) {\\n        require(0 != _quorum, \\\"QUORUM_WONT_BE_MADE\\\");\\n        uint256 oldQuorum = QUORUM_POSITION.getStorageUint256();\\n        QUORUM_POSITION.setStorageUint256(_quorum);\\n        emit QuorumChanged(_quorum);\\n\\n        // If the quorum value lowered, check existing reports whether it is time to push\\n        if (oldQuorum > _quorum) {\\n            (bool isQuorum, uint256 report) = _getQuorumReport(_quorum);\\n            if (isQuorum) {\\n                (uint64 beaconBalance, uint32 beaconValidators) = report.decode();\\n                _push(\\n                     EXPECTED_EPOCH_ID_POSITION.getStorageUint256(),\\n                     DENOMINATION_OFFSET * uint128(beaconBalance),\\n                     beaconValidators,\\n                     _getBeaconSpec()\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Accept oracle committee member reports from the ETH 2.0 side\\n     * @param _epochId Beacon chain epoch\\n     * @param _beaconBalance Balance in gwei on the ETH 2.0 side (9-digit denomination)\\n     * @param _beaconValidators Number of validators visible in this epoch\\n     */\\n    function reportBeacon(uint256 _epochId, uint64 _beaconBalance, uint32 _beaconValidators) external {\\n        BeaconSpec memory beaconSpec = _getBeaconSpec();\\n        uint256 expectedEpoch = EXPECTED_EPOCH_ID_POSITION.getStorageUint256();\\n        require(_epochId >= expectedEpoch, \\\"EPOCH_IS_TOO_OLD\\\");\\n\\n        // if expected epoch has advanced, check that this is the first epoch of the current frame\\n        // and clear the last unsuccessful reporting\\n        if (_epochId > expectedEpoch) {\\n            require(_epochId == _getFrameFirstEpochId(_getCurrentEpochId(beaconSpec), beaconSpec), \\\"UNEXPECTED_EPOCH\\\");\\n            _clearReportingAndAdvanceTo(_epochId);\\n        }\\n\\n        uint128 beaconBalanceEth1 = DENOMINATION_OFFSET * uint128(_beaconBalance);\\n        emit BeaconReported(_epochId, beaconBalanceEth1, _beaconValidators, msg.sender);\\n\\n        // make sure the oracle is from members list and has not yet voted\\n        uint256 index = _getMemberId(msg.sender);\\n        require(index != MEMBER_NOT_FOUND, \\\"MEMBER_NOT_FOUND\\\");\\n        uint256 bitMask = REPORTS_BITMASK_POSITION.getStorageUint256();\\n        uint256 mask = 1 << index;\\n        require(bitMask & mask == 0, \\\"ALREADY_SUBMITTED\\\");\\n        REPORTS_BITMASK_POSITION.setStorageUint256(bitMask | mask);\\n\\n        // push this report to the matching kind\\n        uint256 report = ReportUtils.encode(_beaconBalance, _beaconValidators);\\n        uint256 quorum = getQuorum();\\n        uint256 i = 0;\\n\\n        // iterate on all report variants we already have, limited by the oracle members maximum\\n        while (i < currentReportVariants.length && currentReportVariants[i].isDifferent(report)) ++i;\\n        if (i < currentReportVariants.length) {\\n            if (currentReportVariants[i].getCount() + 1 >= quorum) {\\n                _push(_epochId, beaconBalanceEth1, _beaconValidators, beaconSpec);\\n            } else {\\n                ++currentReportVariants[i]; // increment report counter, see ReportUtils for details\\n            }\\n        } else {\\n            if (quorum == 1) {\\n                _push(_epochId, beaconBalanceEth1, _beaconValidators, beaconSpec);\\n            } else {\\n                currentReportVariants.push(report + 1);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Return beacon specification data\\n     */\\n    function _getBeaconSpec()\\n        internal\\n        view\\n        returns (BeaconSpec memory beaconSpec)\\n    {\\n        uint256 data = BEACON_SPEC_POSITION.getStorageUint256();\\n        beaconSpec.epochsPerFrame = uint64(data >> 192);\\n        beaconSpec.slotsPerEpoch = uint64(data >> 128);\\n        beaconSpec.secondsPerSlot = uint64(data >> 64);\\n        beaconSpec.genesisTime = uint64(data);\\n        return beaconSpec;\\n    }\\n\\n    /**\\n     * @notice Return whether the `_quorum` is reached and the final report\\n     */\\n    function _getQuorumReport(uint256 _quorum) internal view returns (bool isQuorum, uint256 report) {\\n        // check most frequent cases first: all reports are the same or no reports yet\\n        if (currentReportVariants.length == 1) {\\n            return (currentReportVariants[0].getCount() >= _quorum, currentReportVariants[0]);\\n        } else if (currentReportVariants.length == 0) {\\n            return (false, 0);\\n        }\\n\\n        // if more than 2 kind of reports exist, choose the most frequent\\n        uint256 maxind = 0;\\n        uint256 repeat = 0;\\n        uint16 maxval = 0;\\n        uint16 cur = 0;\\n        for (uint256 i = 0; i < currentReportVariants.length; ++i) {\\n            cur = currentReportVariants[i].getCount();\\n            if (cur >= maxval) {\\n                if (cur == maxval) {\\n                    ++repeat;\\n                } else {\\n                    maxind = i;\\n                    maxval = cur;\\n                    repeat = 0;\\n                }\\n            }\\n        }\\n        return (maxval >= _quorum && repeat == 0, currentReportVariants[maxind]);\\n    }\\n\\n    /**\\n     * @notice Set beacon specification data\\n     */\\n    function _setBeaconSpec(\\n        uint64 _epochsPerFrame,\\n        uint64 _slotsPerEpoch,\\n        uint64 _secondsPerSlot,\\n        uint64 _genesisTime\\n    )\\n        internal\\n    {\\n        require(_epochsPerFrame > 0, \\\"BAD_EPOCHS_PER_FRAME\\\");\\n        require(_slotsPerEpoch > 0, \\\"BAD_SLOTS_PER_EPOCH\\\");\\n        require(_secondsPerSlot > 0, \\\"BAD_SECONDS_PER_SLOT\\\");\\n        require(_genesisTime > 0, \\\"BAD_GENESIS_TIME\\\");\\n\\n        uint256 data = (\\n            uint256(_epochsPerFrame) << 192 |\\n            uint256(_slotsPerEpoch) << 128 |\\n            uint256(_secondsPerSlot) << 64 |\\n            uint256(_genesisTime)\\n        );\\n        BEACON_SPEC_POSITION.setStorageUint256(data);\\n        emit BeaconSpecSet(\\n            _epochsPerFrame,\\n            _slotsPerEpoch,\\n            _secondsPerSlot,\\n            _genesisTime);\\n    }\\n\\n    /**\\n     * @notice Push the given report to Lido and performs accompanying accounting\\n     * @param _epochId Beacon chain epoch, proven to be >= expected epoch and <= current epoch\\n     * @param _beaconBalanceEth1 Validators balance in eth1 (18-digit denomination)\\n     * @param _beaconSpec current beacon specification data\\n     */\\n    function _push(\\n        uint256 _epochId,\\n        uint128 _beaconBalanceEth1,\\n        uint128 _beaconValidators,\\n        BeaconSpec memory _beaconSpec\\n    )\\n        internal\\n    {\\n        emit Completed(_epochId, _beaconBalanceEth1, _beaconValidators);\\n\\n        // now this frame is completed, so the expected epoch should be advanced to the first epoch\\n        // of the next frame\\n        _clearReportingAndAdvanceTo(_epochId + _beaconSpec.epochsPerFrame);\\n\\n        // report to the Lido and collect stats\\n        ILido lido = getLido();\\n        uint256 prevTotalPooledEther = lido.totalSupply();\\n        lido.handleOracleReport(_beaconValidators, _beaconBalanceEth1);\\n        uint256 postTotalPooledEther = lido.totalSupply();\\n\\n        PRE_COMPLETED_TOTAL_POOLED_ETHER_POSITION.setStorageUint256(prevTotalPooledEther);\\n        POST_COMPLETED_TOTAL_POOLED_ETHER_POSITION.setStorageUint256(postTotalPooledEther);\\n        uint256 timeElapsed = (_epochId - LAST_COMPLETED_EPOCH_ID_POSITION.getStorageUint256()) *\\n            _beaconSpec.slotsPerEpoch * _beaconSpec.secondsPerSlot;\\n        TIME_ELAPSED_POSITION.setStorageUint256(timeElapsed);\\n        LAST_COMPLETED_EPOCH_ID_POSITION.setStorageUint256(_epochId);\\n\\n        // rollback on boundaries violation\\n        _reportSanityChecks(postTotalPooledEther, prevTotalPooledEther, timeElapsed);\\n\\n        // emit detailed statistics and call the quorum delegate with this data\\n        emit PostTotalShares(postTotalPooledEther, prevTotalPooledEther, timeElapsed, lido.getTotalShares());\\n        IBeaconReportReceiver receiver = IBeaconReportReceiver(BEACON_REPORT_RECEIVER_POSITION.getStorageUint256());\\n        if (address(receiver) != address(0)) {\\n            receiver.processLidoOracleReport(postTotalPooledEther, prevTotalPooledEther, timeElapsed);\\n        }\\n    }\\n\\n    /**\\n     * @notice Remove the current reporting progress and advances to accept the later epoch `_epochId`\\n     */\\n    function _clearReportingAndAdvanceTo(uint256 _epochId) internal {\\n        REPORTS_BITMASK_POSITION.setStorageUint256(0);\\n        EXPECTED_EPOCH_ID_POSITION.setStorageUint256(_epochId);\\n        delete currentReportVariants;\\n        emit ExpectedEpochIdUpdated(_epochId);\\n    }\\n\\n    /**\\n     * @notice Performs logical consistency check of the Lido changes as the result of reports push\\n     * @dev To make oracles less dangerous, we limit rewards report by 10% _annual_ increase and 5%\\n     * _instant_ decrease in stake, with both values configurable by the governance in case of\\n     * extremely unusual circumstances.\\n     **/\\n    function _reportSanityChecks(\\n        uint256 _postTotalPooledEther,\\n        uint256 _preTotalPooledEther,\\n        uint256 _timeElapsed)\\n        internal\\n        view\\n    {\\n        if (_postTotalPooledEther >= _preTotalPooledEther) {\\n            // increase                 = _postTotalPooledEther - _preTotalPooledEther,\\n            // relativeIncrease         = increase / _preTotalPooledEther,\\n            // annualRelativeIncrease   = relativeIncrease / (timeElapsed / 365 days),\\n            // annualRelativeIncreaseBp = annualRelativeIncrease * 10000, in basis points 0.01% (1e-4)\\n            uint256 allowedAnnualRelativeIncreaseBp =\\n                ALLOWED_BEACON_BALANCE_ANNUAL_RELATIVE_INCREASE_POSITION.getStorageUint256();\\n            // check that annualRelativeIncreaseBp <= allowedAnnualRelativeIncreaseBp\\n            require(uint256(10000 * 365 days).mul(_postTotalPooledEther - _preTotalPooledEther) <=\\n                    allowedAnnualRelativeIncreaseBp.mul(_preTotalPooledEther).mul(_timeElapsed),\\n                    \\\"ALLOWED_BEACON_BALANCE_INCREASE\\\");\\n        } else {\\n            // decrease           = _preTotalPooledEther - _postTotalPooledEther\\n            // relativeDecrease   = decrease / _preTotalPooledEther\\n            // relativeDecreaseBp = relativeDecrease * 10000, in basis points 0.01% (1e-4)\\n            uint256 allowedRelativeDecreaseBp =\\n                ALLOWED_BEACON_BALANCE_RELATIVE_DECREASE_POSITION.getStorageUint256();\\n            // check that relativeDecreaseBp <= allowedRelativeDecreaseBp\\n            require(uint256(10000).mul(_preTotalPooledEther - _postTotalPooledEther) <=\\n                    allowedRelativeDecreaseBp.mul(_preTotalPooledEther),\\n                    \\\"ALLOWED_BEACON_BALANCE_DECREASE\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Return `_member` index in the members list or MEMBER_NOT_FOUND\\n     */\\n    function _getMemberId(address _member) internal view returns (uint256) {\\n        uint256 length = members.length;\\n        for (uint256 i = 0; i < length; ++i) {\\n            if (members[i] == _member) {\\n                return i;\\n            }\\n        }\\n        return MEMBER_NOT_FOUND;\\n    }\\n\\n    /**\\n     * @notice Return the epoch calculated from current timestamp\\n     */\\n    function _getCurrentEpochId(BeaconSpec memory _beaconSpec) internal view returns (uint256) {\\n        return (_getTime() - _beaconSpec.genesisTime) / (_beaconSpec.slotsPerEpoch * _beaconSpec.secondsPerSlot);\\n    }\\n\\n    /**\\n     * @notice Return the first epoch of the frame that `_epochId` belongs to\\n     */\\n    function _getFrameFirstEpochId(uint256 _epochId, BeaconSpec memory _beaconSpec) internal view returns (uint256) {\\n        return _epochId / _beaconSpec.epochsPerFrame * _beaconSpec.epochsPerFrame;\\n    }\\n\\n    /**\\n     * @notice Return the current timestamp\\n     */\\n    function _getTime() internal view returns (uint256) {\\n        return block.timestamp; // solhint-disable-line not-rely-on-time\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/apps/AragonApp.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./AppStorage.sol\\\";\\nimport \\\"../acl/ACLSyntaxSugar.sol\\\";\\nimport \\\"../common/Autopetrified.sol\\\";\\nimport \\\"../common/ConversionHelpers.sol\\\";\\nimport \\\"../common/ReentrancyGuard.sol\\\";\\nimport \\\"../common/VaultRecoverable.sol\\\";\\nimport \\\"../evmscript/EVMScriptRunner.sol\\\";\\n\\n\\n// Contracts inheriting from AragonApp are, by default, immediately petrified upon deployment so\\n// that they can never be initialized.\\n// Unless overriden, this behaviour enforces those contracts to be usable only behind an AppProxy.\\n// ReentrancyGuard, EVMScriptRunner, and ACLSyntaxSugar are not directly used by this contract, but\\n// are included so that they are automatically usable by subclassing contracts\\ncontract AragonApp is AppStorage, Autopetrified, VaultRecoverable, ReentrancyGuard, EVMScriptRunner, ACLSyntaxSugar {\\n    string private constant ERROR_AUTH_FAILED = \\\"APP_AUTH_FAILED\\\";\\n\\n    modifier auth(bytes32 _role) {\\n        require(canPerform(msg.sender, _role, new uint256[](0)), ERROR_AUTH_FAILED);\\n        _;\\n    }\\n\\n    modifier authP(bytes32 _role, uint256[] _params) {\\n        require(canPerform(msg.sender, _role, _params), ERROR_AUTH_FAILED);\\n        _;\\n    }\\n\\n    /**\\n    * @dev Check whether an action can be performed by a sender for a particular role on this app\\n    * @param _sender Sender of the call\\n    * @param _role Role on this app\\n    * @param _params Permission params for the role\\n    * @return Boolean indicating whether the sender has the permissions to perform the action.\\n    *         Always returns false if the app hasn't been initialized yet.\\n    */\\n    function canPerform(address _sender, bytes32 _role, uint256[] _params) public view returns (bool) {\\n        if (!hasInitialized()) {\\n            return false;\\n        }\\n\\n        IKernel linkedKernel = kernel();\\n        if (address(linkedKernel) == address(0)) {\\n            return false;\\n        }\\n\\n        return linkedKernel.hasPermission(\\n            _sender,\\n            address(this),\\n            _role,\\n            ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)\\n        );\\n    }\\n\\n    /**\\n    * @dev Get the recovery vault for the app\\n    * @return Recovery vault address for the app\\n    */\\n    function getRecoveryVault() public view returns (address) {\\n        // Funds recovery via a vault is only available when used with a kernel\\n        return kernel().getRecoveryVault(); // if kernel is not set, it will revert\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/lib/math/SafeMath.sol\": {\r\n      \"content\": \"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d51e38758e1d985661534534d5c61e27bece5042/contracts/math/SafeMath.sol\\n// Adapted to use pragma ^0.4.24 and satisfy our linter rules\\n\\npragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    string private constant ERROR_ADD_OVERFLOW = \\\"MATH_ADD_OVERFLOW\\\";\\n    string private constant ERROR_SUB_UNDERFLOW = \\\"MATH_SUB_UNDERFLOW\\\";\\n    string private constant ERROR_MUL_OVERFLOW = \\\"MATH_MUL_OVERFLOW\\\";\\n    string private constant ERROR_DIV_ZERO = \\\"MATH_DIV_ZERO\\\";\\n\\n    /**\\n    * @dev Multiplies two numbers, reverts on overflow.\\n    */\\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (_a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = _a * _b;\\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n    */\\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\\n        uint256 c = _a / _b;\\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\\n        uint256 c = _a - _b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, reverts on overflow.\\n    */\\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        uint256 c = _a + _b;\\n        require(c >= _a, ERROR_ADD_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n    * reverts when dividing by zero.\\n    */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, ERROR_DIV_ZERO);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title ERC165Checker\\n * @dev Use `using ERC165Checker for address`; to include this library\\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\\n */\\nlibrary ERC165Checker {\\n  // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n  bytes4 private constant _InterfaceId_Invalid = 0xffffffff;\\n\\n  bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\\n  /**\\n   * 0x01ffc9a7 ===\\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\\n   */\\n\\n  /**\\n   * @notice Query if a contract supports ERC165\\n   * @param account The address of the contract to query for support of ERC165\\n   * @return true if the contract at account implements ERC165\\n   */\\n  function _supportsERC165(address account)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    // Any contract that implements ERC165 must explicitly indicate support of\\n    // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n    return _supportsERC165Interface(account, _InterfaceId_ERC165) &&\\n      !_supportsERC165Interface(account, _InterfaceId_Invalid);\\n  }\\n\\n  /**\\n   * @notice Query if a contract implements an interface, also checks support of ERC165\\n   * @param account The address of the contract to query for support of an interface\\n   * @param interfaceId The interface identifier, as specified in ERC-165\\n   * @return true if the contract at account indicates support of the interface with\\n   * identifier interfaceId, false otherwise\\n   * @dev Interface identification is specified in ERC-165.\\n   */\\n  function _supportsInterface(address account, bytes4 interfaceId)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    // query support of both ERC165 as per the spec and support of _interfaceId\\n    return _supportsERC165(account) &&\\n      _supportsERC165Interface(account, interfaceId);\\n  }\\n\\n  /**\\n   * @notice Query if a contract implements interfaces, also checks support of ERC165\\n   * @param account The address of the contract to query for support of an interface\\n   * @param interfaceIds A list of interface identifiers, as specified in ERC-165\\n   * @return true if the contract at account indicates support all interfaces in the\\n   * interfaceIds list, false otherwise\\n   * @dev Interface identification is specified in ERC-165.\\n   */\\n  function _supportsAllInterfaces(address account, bytes4[] interfaceIds)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    // query support of ERC165 itself\\n    if (!_supportsERC165(account)) {\\n      return false;\\n    }\\n\\n    // query support of each interface in _interfaceIds\\n    for (uint256 i = 0; i < interfaceIds.length; i++) {\\n      if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n        return false;\\n      }\\n    }\\n\\n    // all interfaces supported\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Query if a contract implements an interface, does not check ERC165 support\\n   * @param account The address of the contract to query for support of an interface\\n   * @param interfaceId The interface identifier, as specified in ERC-165\\n   * @return true if the contract at account indicates support of the interface with\\n   * identifier interfaceId, false otherwise\\n   * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n   * the behavior of this method is undefined. This precondition can be checked\\n   * with the `supportsERC165` method in this library.\\n   * Interface identification is specified in ERC-165.\\n   */\\n  function _supportsERC165Interface(address account, bytes4 interfaceId)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    // success determines whether the staticcall succeeded and result determines\\n    // whether the contract at account indicates support of _interfaceId\\n    (bool success, bool result) = _callERC165SupportsInterface(\\n      account, interfaceId);\\n\\n    return (success && result);\\n  }\\n\\n  /**\\n   * @notice Calls the function with selector 0x01ffc9a7 (ERC165) and suppresses throw\\n   * @param account The address of the contract to query for support of an interface\\n   * @param interfaceId The interface identifier, as specified in ERC-165\\n   * @return success true if the STATICCALL succeeded, false otherwise\\n   * @return result true if the STATICCALL succeeded and the contract at account\\n   * indicates support of the interface with identifier interfaceId, false otherwise\\n   */\\n  function _callERC165SupportsInterface(\\n    address account,\\n    bytes4 interfaceId\\n  )\\n    private\\n    view\\n    returns (bool success, bool result)\\n  {\\n    bytes memory encodedParams = abi.encodeWithSelector(\\n      _InterfaceId_ERC165,\\n      interfaceId\\n    );\\n\\n    // solium-disable-next-line security/no-inline-assembly\\n    assembly {\\n      let encodedParams_data := add(0x20, encodedParams)\\n      let encodedParams_size := mload(encodedParams)\\n\\n      let output := mload(0x40)  // Find empty storage location using \\\"free memory pointer\\\"\\n      mstore(output, 0x0)\\n\\n      success := staticcall(\\n        30000,                 // 30k gas\\n        account,              // To addr\\n        encodedParams_data,\\n        encodedParams_size,\\n        output,\\n        0x20                   // Outputs are 32 bytes long\\n      )\\n\\n      result := mload(output)  // Load the result\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/0.4.24/interfaces/IBeaconReportReceiver.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.4.24;\\n\\n\\n/**\\n  * @title Interface defining a callback that the quorum will call on every quorum reached\\n  */\\ninterface IBeaconReportReceiver {\\n    /**\\n      * @notice Callback to be called by the oracle contract upon the quorum is reached\\n      * @param _postTotalPooledEther total pooled ether on Lido right after the quorum value was reported\\n      * @param _preTotalPooledEther total pooled ether on Lido right before the quorum value was reported\\n      * @param _timeElapsed time elapsed in seconds between the last and the previous quorum\\n      */\\n    function processLidoOracleReport(uint256 _postTotalPooledEther,\\n                                     uint256 _preTotalPooledEther,\\n                                     uint256 _timeElapsed) external;\\n}\\n\"\r\n    },\r\n    \"contracts/0.4.24/interfaces/ILido.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.4.24;\\n\\n\\n/**\\n  * @title Liquid staking pool\\n  *\\n  * For the high-level description of the pool operation please refer to the paper.\\n  * Pool manages withdrawal keys and fees. It receives ether submitted by users on the ETH 1 side\\n  * and stakes it via the deposit_contract.sol contract. It doesn't hold ether on it's balance,\\n  * only a small portion (buffer) of it.\\n  * It also mints new tokens for rewards generated at the ETH 2.0 side.\\n  *\\n  * At the moment withdrawals are not possible in the beacon chain and there's no workaround.\\n  * Pool will be upgraded to an actual implementation when withdrawals are enabled\\n  * (Phase 1.5 or 2 of Eth2 launch, likely late 2022 or 2023).\\n  */\\ninterface ILido {\\n    function totalSupply() external view returns (uint256);\\n    function getTotalShares() external view returns (uint256);\\n\\n    /**\\n      * @notice Stop pool routine operations\\n      */\\n    function stop() external;\\n\\n    /**\\n      * @notice Resume pool routine operations\\n      */\\n    function resume() external;\\n\\n    /**\\n      * @notice Stops accepting new Ether to the protocol\\n      *\\n      * @dev While accepting new Ether is stopped, calls to the `submit` function,\\n      * as well as to the default payable function, will revert.\\n      *\\n      * Emits `StakingPaused` event.\\n      */\\n    function pauseStaking() external;\\n\\n    /**\\n      * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\\n      * NB: Staking could be rate-limited by imposing a limit on the stake amount\\n      * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\\n      *\\n      * @dev Preserves staking limit if it was set previously\\n      *\\n      * Emits `StakingResumed` event\\n      */\\n    function resumeStaking() external;\\n\\n    /**\\n      * @notice Sets the staking rate limit\\n      *\\n      * @dev Reverts if:\\n      * - `_maxStakeLimit` == 0\\n      * - `_maxStakeLimit` >= 2^96\\n      * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\\n      * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\\n      *\\n      * Emits `StakingLimitSet` event\\n      *\\n      * @param _maxStakeLimit max stake limit value\\n      * @param _stakeLimitIncreasePerBlock stake limit increase per single block\\n      */\\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external;\\n\\n    /**\\n      * @notice Removes the staking rate limit\\n      *\\n      * Emits `StakingLimitRemoved` event\\n      */\\n    function removeStakingLimit() external;\\n\\n    /**\\n      * @notice Check staking state: whether it's paused or not\\n      */\\n    function isStakingPaused() external view returns (bool);\\n\\n    /**\\n      * @notice Returns how much Ether can be staked in the current block\\n      * @dev Special return values:\\n      * - 2^256 - 1 if staking is unlimited;\\n      * - 0 if staking is paused or if limit is exhausted.\\n      */\\n    function getCurrentStakeLimit() external view returns (uint256);\\n\\n    /**\\n      * @notice Returns full info about current stake limit params and state\\n      * @dev Might be used for the advanced integration requests.\\n      * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\\n      * @return isStakingLimitSet whether the stake limit is set\\n      * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\\n      * @return maxStakeLimit max stake limit\\n      * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\\n      * @return prevStakeLimit previously reached stake limit\\n      * @return prevStakeBlockNumber previously seen block number\\n      */\\n    function getStakeLimitFullInfo() external view returns (\\n        bool isStakingPaused,\\n        bool isStakingLimitSet,\\n        uint256 currentStakeLimit,\\n        uint256 maxStakeLimit,\\n        uint256 maxStakeLimitGrowthBlocks,\\n        uint256 prevStakeLimit,\\n        uint256 prevStakeBlockNumber\\n    );\\n\\n    event Stopped();\\n    event Resumed();\\n\\n    event StakingPaused();\\n    event StakingResumed();\\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\\n    event StakingLimitRemoved();\\n\\n    /**\\n      * @notice Set Lido protocol contracts (oracle, treasury, insurance fund).\\n      * @param _oracle oracle contract\\n      * @param _treasury treasury contract\\n      * @param _insuranceFund insurance fund contract\\n      */\\n    function setProtocolContracts(\\n        address _oracle,\\n        address _treasury,\\n        address _insuranceFund\\n    ) external;\\n\\n    event ProtocolContactsSet(address oracle, address treasury, address insuranceFund);\\n\\n    /**\\n      * @notice Set fee rate to `_feeBasisPoints` basis points.\\n      * The fees are accrued when:\\n      * - oracles report staking results (beacon chain balance increase)\\n      * - validators gain execution layer rewards (priority fees and MEV)\\n      * @param _feeBasisPoints Fee rate, in basis points\\n      */\\n    function setFee(uint16 _feeBasisPoints) external;\\n\\n    /**\\n      * @notice Set fee distribution\\n      * @param _treasuryFeeBasisPoints basis points go to the treasury,\\n      * @param _insuranceFeeBasisPoints basis points go to the insurance fund,\\n      * @param _operatorsFeeBasisPoints basis points go to node operators.\\n      * @dev The sum has to be 10 000.\\n      */\\n    function setFeeDistribution(\\n        uint16 _treasuryFeeBasisPoints,\\n        uint16 _insuranceFeeBasisPoints,\\n        uint16 _operatorsFeeBasisPoints\\n    ) external;\\n\\n    /**\\n      * @notice Returns staking rewards fee rate\\n      */\\n    function getFee() external view returns (uint16 feeBasisPoints);\\n\\n    /**\\n      * @notice Returns fee distribution proportion\\n      */\\n    function getFeeDistribution() external view returns (\\n        uint16 treasuryFeeBasisPoints,\\n        uint16 insuranceFeeBasisPoints,\\n        uint16 operatorsFeeBasisPoints\\n    );\\n\\n    event FeeSet(uint16 feeBasisPoints);\\n\\n    event FeeDistributionSet(uint16 treasuryFeeBasisPoints, uint16 insuranceFeeBasisPoints, uint16 operatorsFeeBasisPoints);\\n\\n    /**\\n      * @notice A payable function supposed to be called only by LidoExecutionLayerRewardsVault contract\\n      * @dev We need a dedicated function because funds received by the default payable function\\n      * are treated as a user deposit\\n      */\\n    function receiveELRewards() external payable;\\n\\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault contract to Lido contract\\n    event ELRewardsReceived(uint256 amount);\\n\\n    /**\\n      * @dev Sets limit on amount of ETH to withdraw from execution layer rewards vault per LidoOracle report\\n      * @param _limitPoints limit in basis points to amount of ETH to withdraw per LidoOracle report\\n      */\\n    function setELRewardsWithdrawalLimit(uint16 _limitPoints) external;\\n\\n    // Percent in basis points of total pooled ether allowed to withdraw from LidoExecutionLayerRewardsVault per LidoOracle report\\n    event ELRewardsWithdrawalLimitSet(uint256 limitPoints);\\n\\n    /**\\n      * @notice Set credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched to `_withdrawalCredentials`\\n      * @dev Note that setWithdrawalCredentials discards all unused signing keys as the signatures are invalidated.\\n      * @param _withdrawalCredentials withdrawal credentials field as defined in the Ethereum PoS consensus specs\\n      */\\n    function setWithdrawalCredentials(bytes32 _withdrawalCredentials) external;\\n\\n    /**\\n      * @notice Returns current credentials to withdraw ETH on ETH 2.0 side after the phase 2 is launched\\n      */\\n    function getWithdrawalCredentials() external view returns (bytes);\\n\\n    event WithdrawalCredentialsSet(bytes32 withdrawalCredentials);\\n\\n    /**\\n      * @dev Sets the address of LidoExecutionLayerRewardsVault contract\\n      * @param _executionLayerRewardsVault Execution layer rewards vault contract address\\n      */\\n    function setELRewardsVault(address _executionLayerRewardsVault) external;\\n\\n    // The `executionLayerRewardsVault` was set as the execution layer rewards vault for Lido\\n    event ELRewardsVaultSet(address executionLayerRewardsVault);\\n\\n    /**\\n      * @notice Ether on the ETH 2.0 side reported by the oracle\\n      * @param _epoch Epoch id\\n      * @param _eth2balance Balance in wei on the ETH 2.0 side\\n      */\\n    function handleOracleReport(uint256 _epoch, uint256 _eth2balance) external;\\n\\n\\n    // User functions\\n\\n    /**\\n      * @notice Adds eth to the pool\\n      * @return StETH Amount of StETH generated\\n      */\\n    function submit(address _referral) external payable returns (uint256 StETH);\\n\\n    // Records a deposit made by a user\\n    event Submitted(address indexed sender, uint256 amount, address referral);\\n\\n    // The `amount` of ether was sent to the deposit_contract.deposit function\\n    event Unbuffered(uint256 amount);\\n\\n    // Requested withdrawal of `etherAmount` to `pubkeyHash` on the ETH 2.0 side, `tokenAmount` burned by `sender`,\\n    // `sentFromBuffer` was sent on the current Ethereum side.\\n    event Withdrawal(address indexed sender, uint256 tokenAmount, uint256 sentFromBuffer,\\n                     bytes32 indexed pubkeyHash, uint256 etherAmount);\\n\\n\\n    // Info functions\\n\\n    /**\\n      * @notice Gets the amount of Ether controlled by the system\\n      */\\n    function getTotalPooledEther() external view returns (uint256);\\n\\n    /**\\n      * @notice Gets the amount of Ether temporary buffered on this contract balance\\n      */\\n    function getBufferedEther() external view returns (uint256);\\n\\n    /**\\n      * @notice Returns the key values related to Beacon-side\\n      * @return depositedValidators - number of deposited validators\\n      * @return beaconValidators - number of Lido's validators visible in the Beacon state, reported by oracles\\n      * @return beaconBalance - total amount of Beacon-side Ether (sum of all the balances of Lido validators)\\n      */\\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance);\\n}\\n\"\r\n    },\r\n    \"contracts/0.4.24/interfaces/ILidoOracle.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.4.24;\\n\\nimport \\\"../interfaces/ILido.sol\\\";\\n\\n\\n/**\\n * @title ETH 2.0 -> ETH oracle\\n *\\n * The goal of the oracle is to inform other parts of the system about balances controlled by the\\n * DAO on the ETH 2.0 side. The balances can go up because of reward accumulation and can go down\\n * because of slashing.\\n */\\ninterface ILidoOracle {\\n    event AllowedBeaconBalanceAnnualRelativeIncreaseSet(uint256 value);\\n    event AllowedBeaconBalanceRelativeDecreaseSet(uint256 value);\\n    event BeaconReportReceiverSet(address callback);\\n    event MemberAdded(address member);\\n    event MemberRemoved(address member);\\n    event QuorumChanged(uint256 quorum);\\n    event ExpectedEpochIdUpdated(uint256 epochId);\\n    event BeaconSpecSet(\\n        uint64 epochsPerFrame,\\n        uint64 slotsPerEpoch,\\n        uint64 secondsPerSlot,\\n        uint64 genesisTime\\n    );\\n    event BeaconReported(\\n        uint256 epochId,\\n        uint128 beaconBalance,\\n        uint128 beaconValidators,\\n        address caller\\n    );\\n    event Completed(\\n        uint256 epochId,\\n        uint128 beaconBalance,\\n        uint128 beaconValidators\\n    );\\n    event PostTotalShares(\\n         uint256 postTotalPooledEther,\\n         uint256 preTotalPooledEther,\\n         uint256 timeElapsed,\\n         uint256 totalShares);\\n    event ContractVersionSet(uint256 version);\\n\\n    /**\\n     * @notice Return the Lido contract address\\n     */\\n    function getLido() public view returns (ILido);\\n\\n    /**\\n     * @notice Return the number of exactly the same reports needed to finalize the epoch\\n     */\\n    function getQuorum() public view returns (uint256);\\n\\n    /**\\n     * @notice Return the upper bound of the reported balance possible increase in APR\\n     */\\n    function getAllowedBeaconBalanceAnnualRelativeIncrease() external view returns (uint256);\\n\\n    /**\\n     * @notice Return the lower bound of the reported balance possible decrease\\n     */\\n    function getAllowedBeaconBalanceRelativeDecrease() external view returns (uint256);\\n\\n    /**\\n     * @notice Set the upper bound of the reported balance possible increase in APR to `_value`\\n     */\\n    function setAllowedBeaconBalanceAnnualRelativeIncrease(uint256 _value) external;\\n\\n    /**\\n     * @notice Set the lower bound of the reported balance possible decrease to `_value`\\n     */\\n    function setAllowedBeaconBalanceRelativeDecrease(uint256 _value) external;\\n\\n    /**\\n     * @notice Return the receiver contract address to be called when the report is pushed to Lido\\n     */\\n    function getBeaconReportReceiver() external view returns (address);\\n\\n    /**\\n     * @notice Set the receiver contract address to be called when the report is pushed to Lido\\n     */\\n    function setBeaconReportReceiver(address _addr) external;\\n\\n    /**\\n     * @notice Return the current reporting bitmap, representing oracles who have already pushed\\n     * their version of report during the expected epoch\\n     */\\n    function getCurrentOraclesReportStatus() external view returns (uint256);\\n\\n    /**\\n     * @notice Return the current reporting array size\\n     */\\n    function getCurrentReportVariantsSize() external view returns (uint256);\\n\\n    /**\\n     * @notice Return the current reporting array element with the given index\\n     */\\n    function getCurrentReportVariant(uint256 _index)\\n        external\\n        view\\n        returns (\\n            uint64 beaconBalance,\\n            uint32 beaconValidators,\\n            uint16 count\\n        );\\n\\n    /**\\n     * @notice Return epoch that can be reported by oracles\\n     */\\n    function getExpectedEpochId() external view returns (uint256);\\n\\n    /**\\n     * @notice Return the current oracle member committee list\\n     */\\n    function getOracleMembers() external view returns (address[]);\\n\\n    /**\\n     * @notice Return the initialized version of this contract starting from 0\\n     */\\n    function getVersion() external view returns (uint256);\\n\\n    /**\\n     * @notice Return beacon specification data\\n     */\\n    function getBeaconSpec()\\n        external\\n        view\\n        returns (\\n            uint64 epochsPerFrame,\\n            uint64 slotsPerEpoch,\\n            uint64 secondsPerSlot,\\n            uint64 genesisTime\\n        );\\n\\n    /**\\n     * Updates beacon specification data\\n     */\\n    function setBeaconSpec(\\n        uint64 _epochsPerFrame,\\n        uint64 _slotsPerEpoch,\\n        uint64 _secondsPerSlot,\\n        uint64 _genesisTime\\n    )\\n        external;\\n\\n    /**\\n     * Returns the epoch calculated from current timestamp\\n     */\\n    function getCurrentEpochId() external view returns (uint256);\\n\\n    /**\\n     * @notice Return currently reportable epoch (the first epoch of the current frame) as well as\\n     * its start and end times in seconds\\n     */\\n    function getCurrentFrame()\\n        external\\n        view\\n        returns (\\n            uint256 frameEpochId,\\n            uint256 frameStartTime,\\n            uint256 frameEndTime\\n        );\\n\\n    /**\\n     * @notice Return last completed epoch\\n     */\\n    function getLastCompletedEpochId() external view returns (uint256);\\n\\n    /**\\n     * @notice Report beacon balance and its change during the last frame\\n     */\\n    function getLastCompletedReportDelta()\\n        external\\n        view\\n        returns (\\n            uint256 postTotalPooledEther,\\n            uint256 preTotalPooledEther,\\n            uint256 timeElapsed\\n        );\\n\\n    \\n    /**\\n     * @notice Initialize the contract (version 3 for now) from scratch\\n     * @dev For details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\\n     * @param _lido Address of Lido contract\\n     * @param _epochsPerFrame Number of epochs per frame\\n     * @param _slotsPerEpoch Number of slots per epoch\\n     * @param _secondsPerSlot Number of seconds per slot\\n     * @param _genesisTime Genesis time\\n     * @param _allowedBeaconBalanceAnnualRelativeIncrease Allowed beacon balance annual relative increase (e.g. 1000 means 10% yearly increase)\\n     * @param _allowedBeaconBalanceRelativeDecrease Allowed beacon balance moment descreat (e.g. 500 means 5% moment decrease)\\n     */\\n    function initialize(\\n        address _lido,\\n        uint64 _epochsPerFrame,\\n        uint64 _slotsPerEpoch,\\n        uint64 _secondsPerSlot,\\n        uint64 _genesisTime,\\n        uint256 _allowedBeaconBalanceAnnualRelativeIncrease,\\n        uint256 _allowedBeaconBalanceRelativeDecrease\\n    ) external;\\n\\n    /**\\n     * @notice A function to finalize upgrade to v3 (from v1). Can be called only once\\n     * @dev For more details see _initialize_v3()\\n     */\\n    function finalizeUpgrade_v3() external;\\n\\n    /**\\n     * @notice Add `_member` to the oracle member committee list\\n     */\\n    function addOracleMember(address _member) external;\\n\\n    /**\\n     * @notice Remove '_member` from the oracle member committee list\\n     */\\n    function removeOracleMember(address _member) external;\\n\\n    /**\\n     * @notice Set the number of exactly the same reports needed to finalize the epoch to `_quorum`\\n     */\\n    function setQuorum(uint256 _quorum) external;\\n\\n    /**\\n     * @notice Accept oracle committee member reports from the ETH 2.0 side\\n     * @param _epochId Beacon chain epoch\\n     * @param _beaconBalance Balance in gwei on the ETH 2.0 side (9-digit denomination)\\n     * @param _beaconValidators Number of validators visible in this epoch\\n     */\\n    function reportBeacon(uint256 _epochId, uint64 _beaconBalance, uint32 _beaconValidators) external;\\n}\\n\"\r\n    },\r\n    \"contracts/0.4.24/oracle/ReportUtils.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.4.24;\\n\\n/**\\n * Utility functions for effectively storing reports within a single storage slot\\n *\\n * +00 | uint16 | count            | 0..256  | number of reports received exactly like this\\n * +16 | uint32 | beaconValidators | 0..1e9  | number of Lido's validators in beacon chain\\n * +48 | uint64 | beaconBalance    | 0..1e18 | total amout of their balance\\n *\\n * Note that the 'count' is the leftmost field here. Thus it is possible to apply addition\\n * operations to it when it is encoded, provided that you watch for the overflow.\\n */\\nlibrary ReportUtils {\\n    uint256 constant internal COUNT_OUTMASK = 0xFFFFFFFFFFFFFFFFFFFFFFFF0000;\\n\\n    function encode(uint64 beaconBalance, uint32 beaconValidators) internal pure returns (uint256) {\\n        return uint256(beaconBalance) << 48 | uint256(beaconValidators) << 16;\\n    }\\n\\n    function decode(uint256 value) internal pure returns (uint64 beaconBalance, uint32 beaconValidators) {\\n        beaconBalance = uint64(value >> 48);\\n        beaconValidators = uint32(value >> 16);\\n    }\\n\\n    function decodeWithCount(uint256 value)\\n        internal pure\\n        returns (\\n            uint64 beaconBalance,\\n            uint32 beaconValidators,\\n            uint16 count\\n        ) {\\n        beaconBalance = uint64(value >> 48);\\n        beaconValidators = uint32(value >> 16);\\n        count = uint16(value);\\n    }\\n\\n    /// @notice Check if the given reports are different, not considering the counter of the first\\n    function isDifferent(uint256 value, uint256 that) internal pure returns(bool) {\\n        return (value & COUNT_OUTMASK) != that;\\n    }\\n\\n    function getCount(uint256 value) internal pure returns(uint16) {\\n        return uint16(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/apps/AppStorage.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../common/UnstructuredStorage.sol\\\";\\nimport \\\"../kernel/IKernel.sol\\\";\\n\\n\\ncontract AppStorage {\\n    using UnstructuredStorage for bytes32;\\n\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant KERNEL_POSITION = keccak256(\\\"aragonOS.appStorage.kernel\\\");\\n    bytes32 internal constant APP_ID_POSITION = keccak256(\\\"aragonOS.appStorage.appId\\\");\\n    */\\n    bytes32 internal constant KERNEL_POSITION = 0x4172f0f7d2289153072b0a6ca36959e0cbe2efc3afe50fc81636caa96338137b;\\n    bytes32 internal constant APP_ID_POSITION = 0xd625496217aa6a3453eecb9c3489dc5a53e6c67b444329ea2b2cbc9ff547639b;\\n\\n    function kernel() public view returns (IKernel) {\\n        return IKernel(KERNEL_POSITION.getStorageAddress());\\n    }\\n\\n    function appId() public view returns (bytes32) {\\n        return APP_ID_POSITION.getStorageBytes32();\\n    }\\n\\n    function setKernel(IKernel _kernel) internal {\\n        KERNEL_POSITION.setStorageAddress(address(_kernel));\\n    }\\n\\n    function setAppId(bytes32 _appId) internal {\\n        APP_ID_POSITION.setStorageBytes32(_appId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/acl/ACLSyntaxSugar.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ncontract ACLSyntaxSugar {\\n    function arr() internal pure returns (uint256[]) {\\n        return new uint256[](0);\\n    }\\n\\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a));\\n    }\\n\\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b));\\n    }\\n\\n    function arr(address _a) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a));\\n    }\\n\\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b));\\n    }\\n\\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), _b, _c);\\n    }\\n\\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), _b, _c, _d);\\n    }\\n\\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b));\\n    }\\n\\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\\n    }\\n\\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b), uint256(_c));\\n    }\\n\\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\\n        return arr(uint256(_a), uint256(_b), uint256(_c));\\n    }\\n\\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\\n        r = new uint256[](1);\\n        r[0] = _a;\\n    }\\n\\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\\n        r = new uint256[](2);\\n        r[0] = _a;\\n        r[1] = _b;\\n    }\\n\\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\\n        r = new uint256[](3);\\n        r[0] = _a;\\n        r[1] = _b;\\n        r[2] = _c;\\n    }\\n\\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\\n        r = new uint256[](4);\\n        r[0] = _a;\\n        r[1] = _b;\\n        r[2] = _c;\\n        r[3] = _d;\\n    }\\n\\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\\n        r = new uint256[](5);\\n        r[0] = _a;\\n        r[1] = _b;\\n        r[2] = _c;\\n        r[3] = _d;\\n        r[4] = _e;\\n    }\\n}\\n\\n\\ncontract ACLHelpers {\\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\\n        return uint8(_x >> (8 * 30));\\n    }\\n\\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\\n        return uint8(_x >> (8 * 31));\\n    }\\n\\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\\n        a = uint32(_x);\\n        b = uint32(_x >> (8 * 4));\\n        c = uint32(_x >> (8 * 8));\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/Autopetrified.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./Petrifiable.sol\\\";\\n\\n\\ncontract Autopetrified is Petrifiable {\\n    constructor() public {\\n        // Immediately petrify base (non-proxy) instances of inherited contracts on deploy.\\n        // This renders them uninitializable (and unusable without a proxy).\\n        petrify();\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/ConversionHelpers.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n\\nlibrary ConversionHelpers {\\n    string private constant ERROR_IMPROPER_LENGTH = \\\"CONVERSION_IMPROPER_LENGTH\\\";\\n\\n    function dangerouslyCastUintArrayToBytes(uint256[] memory _input) internal pure returns (bytes memory output) {\\n        // Force cast the uint256[] into a bytes array, by overwriting its length\\n        // Note that the bytes array doesn't need to be initialized as we immediately overwrite it\\n        // with the input and a new length. The input becomes invalid from this point forward.\\n        uint256 byteLength = _input.length * 32;\\n        assembly {\\n            output := _input\\n            mstore(output, byteLength)\\n        }\\n    }\\n\\n    function dangerouslyCastBytesToUintArray(bytes memory _input) internal pure returns (uint256[] memory output) {\\n        // Force cast the bytes array into a uint256[], by overwriting its length\\n        // Note that the uint256[] doesn't need to be initialized as we immediately overwrite it\\n        // with the input and a new length. The input becomes invalid from this point forward.\\n        uint256 intsLength = _input.length / 32;\\n        require(_input.length == intsLength * 32, ERROR_IMPROPER_LENGTH);\\n\\n        assembly {\\n            output := _input\\n            mstore(output, intsLength)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/ReentrancyGuard.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../common/UnstructuredStorage.sol\\\";\\n\\n\\ncontract ReentrancyGuard {\\n    using UnstructuredStorage for bytes32;\\n\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant REENTRANCY_MUTEX_POSITION = keccak256(\\\"aragonOS.reentrancyGuard.mutex\\\");\\n    */\\n    bytes32 private constant REENTRANCY_MUTEX_POSITION = 0xe855346402235fdd185c890e68d2c4ecad599b88587635ee285bce2fda58dacb;\\n\\n    string private constant ERROR_REENTRANT = \\\"REENTRANCY_REENTRANT_CALL\\\";\\n\\n    modifier nonReentrant() {\\n        // Ensure mutex is unlocked\\n        require(!REENTRANCY_MUTEX_POSITION.getStorageBool(), ERROR_REENTRANT);\\n\\n        // Lock mutex before function call\\n        REENTRANCY_MUTEX_POSITION.setStorageBool(true);\\n\\n        // Perform function call\\n        _;\\n\\n        // Unlock mutex after function call\\n        REENTRANCY_MUTEX_POSITION.setStorageBool(false);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/VaultRecoverable.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../lib/token/ERC20.sol\\\";\\nimport \\\"./EtherTokenConstant.sol\\\";\\nimport \\\"./IsContract.sol\\\";\\nimport \\\"./IVaultRecoverable.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\n\\ncontract VaultRecoverable is IVaultRecoverable, EtherTokenConstant, IsContract {\\n    using SafeERC20 for ERC20;\\n\\n    string private constant ERROR_DISALLOWED = \\\"RECOVER_DISALLOWED\\\";\\n    string private constant ERROR_VAULT_NOT_CONTRACT = \\\"RECOVER_VAULT_NOT_CONTRACT\\\";\\n    string private constant ERROR_TOKEN_TRANSFER_FAILED = \\\"RECOVER_TOKEN_TRANSFER_FAILED\\\";\\n\\n    /**\\n     * @notice Send funds to recovery Vault. This contract should never receive funds,\\n     *         but in case it does, this function allows one to recover them.\\n     * @param _token Token balance to be sent to recovery vault.\\n     */\\n    function transferToVault(address _token) external {\\n        require(allowRecoverability(_token), ERROR_DISALLOWED);\\n        address vault = getRecoveryVault();\\n        require(isContract(vault), ERROR_VAULT_NOT_CONTRACT);\\n\\n        uint256 balance;\\n        if (_token == ETH) {\\n            balance = address(this).balance;\\n            vault.transfer(balance);\\n        } else {\\n            ERC20 token = ERC20(_token);\\n            balance = token.staticBalanceOf(this);\\n            require(token.safeTransfer(vault, balance), ERROR_TOKEN_TRANSFER_FAILED);\\n        }\\n\\n        emit RecoverToVault(vault, _token, balance);\\n    }\\n\\n    /**\\n    * @dev By default deriving from AragonApp makes it recoverable\\n    * @param token Token address that would be recovered\\n    * @return bool whether the app allows the recovery\\n    */\\n    function allowRecoverability(address token) public view returns (bool) {\\n        return true;\\n    }\\n\\n    // Cast non-implemented interface to be public so we can use it internally\\n    function getRecoveryVault() public view returns (address);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/evmscript/EVMScriptRunner.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./IEVMScriptExecutor.sol\\\";\\nimport \\\"./IEVMScriptRegistry.sol\\\";\\n\\nimport \\\"../apps/AppStorage.sol\\\";\\nimport \\\"../kernel/KernelConstants.sol\\\";\\nimport \\\"../common/Initializable.sol\\\";\\n\\n\\ncontract EVMScriptRunner is AppStorage, Initializable, EVMScriptRegistryConstants, KernelNamespaceConstants {\\n    string private constant ERROR_EXECUTOR_UNAVAILABLE = \\\"EVMRUN_EXECUTOR_UNAVAILABLE\\\";\\n    string private constant ERROR_PROTECTED_STATE_MODIFIED = \\\"EVMRUN_PROTECTED_STATE_MODIFIED\\\";\\n\\n    /* This is manually crafted in assembly\\n    string private constant ERROR_EXECUTOR_INVALID_RETURN = \\\"EVMRUN_EXECUTOR_INVALID_RETURN\\\";\\n    */\\n\\n    event ScriptResult(address indexed executor, bytes script, bytes input, bytes returnData);\\n\\n    function getEVMScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\\n        return IEVMScriptExecutor(getEVMScriptRegistry().getScriptExecutor(_script));\\n    }\\n\\n    function getEVMScriptRegistry() public view returns (IEVMScriptRegistry) {\\n        address registryAddr = kernel().getApp(KERNEL_APP_ADDR_NAMESPACE, EVMSCRIPT_REGISTRY_APP_ID);\\n        return IEVMScriptRegistry(registryAddr);\\n    }\\n\\n    function runScript(bytes _script, bytes _input, address[] _blacklist)\\n        internal\\n        isInitialized\\n        protectState\\n        returns (bytes)\\n    {\\n        IEVMScriptExecutor executor = getEVMScriptExecutor(_script);\\n        require(address(executor) != address(0), ERROR_EXECUTOR_UNAVAILABLE);\\n\\n        bytes4 sig = executor.execScript.selector;\\n        bytes memory data = abi.encodeWithSelector(sig, _script, _input, _blacklist);\\n\\n        bytes memory output;\\n        assembly {\\n            let success := delegatecall(\\n                gas,                // forward all gas\\n                executor,           // address\\n                add(data, 0x20),    // calldata start\\n                mload(data),        // calldata length\\n                0,                  // don't write output (we'll handle this ourselves)\\n                0                   // don't write output\\n            )\\n\\n            output := mload(0x40) // free mem ptr get\\n\\n            switch success\\n            case 0 {\\n                // If the call errored, forward its full error data\\n                returndatacopy(output, 0, returndatasize)\\n                revert(output, returndatasize)\\n            }\\n            default {\\n                switch gt(returndatasize, 0x3f)\\n                case 0 {\\n                    // Need at least 0x40 bytes returned for properly ABI-encoded bytes values,\\n                    // revert with \\\"EVMRUN_EXECUTOR_INVALID_RETURN\\\"\\n                    // See remix: doing a `revert(\\\"EVMRUN_EXECUTOR_INVALID_RETURN\\\")` always results in\\n                    // this memory layout\\n                    mstore(output, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\\n                    mstore(add(output, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\\n                    mstore(add(output, 0x24), 0x000000000000000000000000000000000000000000000000000000000000001e) // reason length\\n                    mstore(add(output, 0x44), 0x45564d52554e5f4558454355544f525f494e56414c49445f52455455524e0000) // reason\\n\\n                    revert(output, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\\n                }\\n                default {\\n                    // Copy result\\n                    //\\n                    // Needs to perform an ABI decode for the expected `bytes` return type of\\n                    // `executor.execScript()` as solidity will automatically ABI encode the returned bytes as:\\n                    //    [ position of the first dynamic length return value = 0x20 (32 bytes) ]\\n                    //    [ output length (32 bytes) ]\\n                    //    [ output content (N bytes) ]\\n                    //\\n                    // Perform the ABI decode by ignoring the first 32 bytes of the return data\\n                    let copysize := sub(returndatasize, 0x20)\\n                    returndatacopy(output, 0x20, copysize)\\n\\n                    mstore(0x40, add(output, copysize)) // free mem ptr set\\n                }\\n            }\\n        }\\n\\n        emit ScriptResult(address(executor), _script, _input, output);\\n\\n        return output;\\n    }\\n\\n    modifier protectState {\\n        address preKernel = address(kernel());\\n        bytes32 preAppId = appId();\\n        _; // exec\\n        require(address(kernel()) == preKernel, ERROR_PROTECTED_STATE_MODIFIED);\\n        require(appId() == preAppId, ERROR_PROTECTED_STATE_MODIFIED);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/UnstructuredStorage.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\nlibrary UnstructuredStorage {\\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\\n        assembly { data := sload(position) }\\n    }\\n\\n    function setStorageBool(bytes32 position, bool data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n\\n    function setStorageAddress(bytes32 position, address data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n\\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n\\n    function setStorageUint256(bytes32 position, uint256 data) internal {\\n        assembly { sstore(position, data) }\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/kernel/IKernel.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../acl/IACL.sol\\\";\\nimport \\\"../common/IVaultRecoverable.sol\\\";\\n\\n\\ninterface IKernelEvents {\\n    event SetApp(bytes32 indexed namespace, bytes32 indexed appId, address app);\\n}\\n\\n\\n// This should be an interface, but interfaces can't inherit yet :(\\ncontract IKernel is IKernelEvents, IVaultRecoverable {\\n    function acl() public view returns (IACL);\\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\\n\\n    function setApp(bytes32 namespace, bytes32 appId, address app) public;\\n    function getApp(bytes32 namespace, bytes32 appId) public view returns (address);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/acl/IACL.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ninterface IACL {\\n    function initialize(address permissionsCreator) external;\\n\\n    // TODO: this should be external\\n    // See https://github.com/ethereum/solidity/issues/4832\\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/IVaultRecoverable.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ninterface IVaultRecoverable {\\n    event RecoverToVault(address indexed vault, address indexed token, uint256 amount);\\n\\n    function transferToVault(address token) external;\\n\\n    function allowRecoverability(address token) external view returns (bool);\\n    function getRecoveryVault() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/Petrifiable.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./Initializable.sol\\\";\\n\\n\\ncontract Petrifiable is Initializable {\\n    // Use block UINT256_MAX (which should be never) as the initializable date\\n    uint256 internal constant PETRIFIED_BLOCK = uint256(-1);\\n\\n    function isPetrified() public view returns (bool) {\\n        return getInitializationBlock() == PETRIFIED_BLOCK;\\n    }\\n\\n    /**\\n    * @dev Function to be called by top level contract to prevent being initialized.\\n    *      Useful for freezing base contracts when they're used behind proxies.\\n    */\\n    function petrify() internal onlyInit {\\n        initializedAt(PETRIFIED_BLOCK);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/Initializable.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./TimeHelpers.sol\\\";\\nimport \\\"./UnstructuredStorage.sol\\\";\\n\\n\\ncontract Initializable is TimeHelpers {\\n    using UnstructuredStorage for bytes32;\\n\\n    // keccak256(\\\"aragonOS.initializable.initializationBlock\\\")\\n    bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;\\n\\n    string private constant ERROR_ALREADY_INITIALIZED = \\\"INIT_ALREADY_INITIALIZED\\\";\\n    string private constant ERROR_NOT_INITIALIZED = \\\"INIT_NOT_INITIALIZED\\\";\\n\\n    modifier onlyInit {\\n        require(getInitializationBlock() == 0, ERROR_ALREADY_INITIALIZED);\\n        _;\\n    }\\n\\n    modifier isInitialized {\\n        require(hasInitialized(), ERROR_NOT_INITIALIZED);\\n        _;\\n    }\\n\\n    /**\\n    * @return Block number in which the contract was initialized\\n    */\\n    function getInitializationBlock() public view returns (uint256) {\\n        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\\n    }\\n\\n    /**\\n    * @return Whether the contract has been initialized by the time of the current block\\n    */\\n    function hasInitialized() public view returns (bool) {\\n        uint256 initializationBlock = getInitializationBlock();\\n        return initializationBlock != 0 && getBlockNumber() >= initializationBlock;\\n    }\\n\\n    /**\\n    * @dev Function to be called by top level contract after initialization has finished.\\n    */\\n    function initialized() internal onlyInit {\\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\\n    }\\n\\n    /**\\n    * @dev Function to be called by top level contract after initialization to enable the contract\\n    *      at a future block number rather than immediately.\\n    */\\n    function initializedAt(uint256 _blockNumber) internal onlyInit {\\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/TimeHelpers.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./Uint256Helpers.sol\\\";\\n\\n\\ncontract TimeHelpers {\\n    using Uint256Helpers for uint256;\\n\\n    /**\\n    * @dev Returns the current block number.\\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\\n    *      tests.\\n    */\\n    function getBlockNumber() internal view returns (uint256) {\\n        return block.number;\\n    }\\n\\n    /**\\n    * @dev Returns the current block number, converted to uint64.\\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\\n    *      tests.\\n    */\\n    function getBlockNumber64() internal view returns (uint64) {\\n        return getBlockNumber().toUint64();\\n    }\\n\\n    /**\\n    * @dev Returns the current timestamp.\\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\\n    *      tests.\\n    */\\n    function getTimestamp() internal view returns (uint256) {\\n        return block.timestamp; // solium-disable-line security/no-block-members\\n    }\\n\\n    /**\\n    * @dev Returns the current timestamp, converted to uint64.\\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\\n    *      tests.\\n    */\\n    function getTimestamp64() internal view returns (uint64) {\\n        return getTimestamp().toUint64();\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/Uint256Helpers.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n\\nlibrary Uint256Helpers {\\n    uint256 private constant MAX_UINT64 = uint64(-1);\\n\\n    string private constant ERROR_NUMBER_TOO_BIG = \\\"UINT64_NUMBER_TOO_BIG\\\";\\n\\n    function toUint64(uint256 a) internal pure returns (uint64) {\\n        require(a <= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\\n        return uint64(a);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/lib/token/ERC20.sol\": {\r\n      \"content\": \"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a9f910d34f0ab33a1ae5e714f69f9596a02b4d91/contracts/token/ERC20/ERC20.sol\\n\\npragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ncontract ERC20 {\\n    function totalSupply() public view returns (uint256);\\n\\n    function balanceOf(address _who) public view returns (uint256);\\n\\n    function allowance(address _owner, address _spender)\\n        public view returns (uint256);\\n\\n    function transfer(address _to, uint256 _value) public returns (bool);\\n\\n    function approve(address _spender, uint256 _value)\\n        public returns (bool);\\n\\n    function transferFrom(address _from, address _to, uint256 _value)\\n        public returns (bool);\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/EtherTokenConstant.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\n// aragonOS and aragon-apps rely on address(0) to denote native ETH, in\\n// contracts where both tokens and ETH are accepted\\ncontract EtherTokenConstant {\\n    address internal constant ETH = address(0);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/IsContract.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ncontract IsContract {\\n    /*\\n    * NOTE: this should NEVER be used for authentication\\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\\n    *\\n    * This is only intended to be used as a sanity check that an address is actually a contract,\\n    * RATHER THAN an address not being a contract.\\n    */\\n    function isContract(address _target) internal view returns (bool) {\\n        if (_target == address(0)) {\\n            return false;\\n        }\\n\\n        uint256 size;\\n        assembly { size := extcodesize(_target) }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/common/SafeERC20.sol\": {\r\n      \"content\": \"// Inspired by AdEx (https://github.com/AdExNetwork/adex-protocol-eth/blob/b9df617829661a7518ee10f4cb6c4108659dd6d5/contracts/libs/SafeERC20.sol)\\n// and 0x (https://github.com/0xProject/0x-monorepo/blob/737d1dc54d72872e24abce5a1dbe1b66d35fa21a/contracts/protocol/contracts/protocol/AssetProxy/ERC20Proxy.sol#L143)\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"../lib/token/ERC20.sol\\\";\\n\\n\\nlibrary SafeERC20 {\\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\\n    // https://github.com/ethereum/solidity/issues/3544\\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\\n\\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = \\\"SAFE_ERC_20_BALANCE_REVERTED\\\";\\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = \\\"SAFE_ERC_20_ALLOWANCE_REVERTED\\\";\\n\\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\\n        private\\n        returns (bool)\\n    {\\n        bool ret;\\n        assembly {\\n            let ptr := mload(0x40)    // free memory pointer\\n\\n            let success := call(\\n                gas,                  // forward all gas\\n                _addr,                // address\\n                0,                    // no value\\n                add(_calldata, 0x20), // calldata start\\n                mload(_calldata),     // calldata length\\n                ptr,                  // write output over free memory\\n                0x20                  // uint256 return\\n            )\\n\\n            if gt(success, 0) {\\n                // Check number of bytes returned from last function call\\n                switch returndatasize\\n\\n                // No bytes returned: assume success\\n                case 0 {\\n                    ret := 1\\n                }\\n\\n                // 32 bytes returned: check if non-zero\\n                case 0x20 {\\n                    // Only return success if returned data was true\\n                    // Already have output in ptr\\n                    ret := eq(mload(ptr), 1)\\n                }\\n\\n                // Not sure what was returned: don't mark as success\\n                default { }\\n            }\\n        }\\n        return ret;\\n    }\\n\\n    function staticInvoke(address _addr, bytes memory _calldata)\\n        private\\n        view\\n        returns (bool, uint256)\\n    {\\n        bool success;\\n        uint256 ret;\\n        assembly {\\n            let ptr := mload(0x40)    // free memory pointer\\n\\n            success := staticcall(\\n                gas,                  // forward all gas\\n                _addr,                // address\\n                add(_calldata, 0x20), // calldata start\\n                mload(_calldata),     // calldata length\\n                ptr,                  // write output over free memory\\n                0x20                  // uint256 return\\n            )\\n\\n            if gt(success, 0) {\\n                ret := mload(ptr)\\n            }\\n        }\\n        return (success, ret);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\\n        bytes memory transferCallData = abi.encodeWithSelector(\\n            TRANSFER_SELECTOR,\\n            _to,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(_token, transferCallData);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\\n        bytes memory transferFromCallData = abi.encodeWithSelector(\\n            _token.transferFrom.selector,\\n            _from,\\n            _to,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(_token, transferFromCallData);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\\n        bytes memory approveCallData = abi.encodeWithSelector(\\n            _token.approve.selector,\\n            _spender,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(_token, approveCallData);\\n    }\\n\\n    /**\\n    * @dev Static call into ERC20.balanceOf().\\n    * Reverts if the call fails for some reason (should never fail).\\n    */\\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\\n            _token.balanceOf.selector,\\n            _owner\\n        );\\n\\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\\n\\n        return tokenBalance;\\n    }\\n\\n    /**\\n    * @dev Static call into ERC20.allowance().\\n    * Reverts if the call fails for some reason (should never fail).\\n    */\\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\\n        bytes memory allowanceCallData = abi.encodeWithSelector(\\n            _token.allowance.selector,\\n            _owner,\\n            _spender\\n        );\\n\\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\\n\\n        return allowance;\\n    }\\n\\n    /**\\n    * @dev Static call into ERC20.totalSupply().\\n    * Reverts if the call fails for some reason (should never fail).\\n    */\\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\\n\\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\\n\\n        return totalSupply;\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ninterface IEVMScriptExecutor {\\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\\n    function executorType() external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./IEVMScriptExecutor.sol\\\";\\n\\n\\ncontract EVMScriptRegistryConstants {\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = apmNamehash(\\\"evmreg\\\");\\n    */\\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = 0xddbcfd564f642ab5627cf68b9b7d374fb4f8a36e941a75d89c87998cef03bd61;\\n}\\n\\n\\ninterface IEVMScriptRegistry {\\n    function addScriptExecutor(IEVMScriptExecutor executor) external returns (uint id);\\n    function disableScriptExecutor(uint256 executorId) external;\\n\\n    // TODO: this should be external\\n    // See https://github.com/ethereum/solidity/issues/4832\\n    function getScriptExecutor(bytes script) public view returns (IEVMScriptExecutor);\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/kernel/KernelConstants.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.4.24;\\n\\n\\ncontract KernelAppIds {\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant KERNEL_CORE_APP_ID = apmNamehash(\\\"kernel\\\");\\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = apmNamehash(\\\"acl\\\");\\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = apmNamehash(\\\"vault\\\");\\n    */\\n    bytes32 internal constant KERNEL_CORE_APP_ID = 0x3b4bf6bf3ad5000ecf0f989d5befde585c6860fea3e574a4fab4c49d1c177d9c;\\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = 0xe3262375f45a6e2026b7e7b18c2b807434f2508fe1a2a3dfb493c7df8f4aad6a;\\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = 0x7e852e0fcfce6551c13800f1e7476f982525c2b5277ba14b24339c68416336d1;\\n}\\n\\n\\ncontract KernelNamespaceConstants {\\n    /* Hardcoded constants to save gas\\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = keccak256(\\\"core\\\");\\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = keccak256(\\\"base\\\");\\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = keccak256(\\\"app\\\");\\n    */\\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = 0xc681a85306374a5ab27f0bbc385296a54bcd314a1948b6cf61c4ea1bc44bb9f8;\\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = 0xf1f3eb40f5bc1ad1344716ced8b8a0431d840b5783aea1fd01786bc26f35ac0f;\\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"constantinople\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentOraclesReportStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setAllowedBeaconBalanceAnnualRelativeIncrease\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_script\",\"type\":\"bytes\"}],\"name\":\"getEVMScriptExecutor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MANAGE_QUORUM\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_epochId\",\"type\":\"uint256\"},{\"name\":\"_beaconBalance\",\"type\":\"uint64\"},{\"name\":\"_beaconValidators\",\"type\":\"uint32\"}],\"name\":\"reportBeacon\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRecoveryVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllowedBeaconBalanceAnnualRelativeIncrease\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllowedBeaconBalanceRelativeDecrease\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExpectedEpochId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastCompletedReportDelta\",\"outputs\":[{\"name\":\"postTotalPooledEther\",\"type\":\"uint256\"},{\"name\":\"preTotalPooledEther\",\"type\":\"uint256\"},{\"name\":\"timeElapsed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lido\",\"type\":\"address\"},{\"name\":\"_epochsPerFrame\",\"type\":\"uint64\"},{\"name\":\"_slotsPerEpoch\",\"type\":\"uint64\"},{\"name\":\"_secondsPerSlot\",\"type\":\"uint64\"},{\"name\":\"_genesisTime\",\"type\":\"uint64\"},{\"name\":\"_allowedBeaconBalanceAnnualRelativeIncrease\",\"type\":\"uint256\"},{\"name\":\"_allowedBeaconBalanceRelativeDecrease\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLido\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_BEACON_REPORT_RECEIVER\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeUpgrade_v3\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MANAGE_MEMBERS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentFrame\",\"outputs\":[{\"name\":\"frameEpochId\",\"type\":\"uint256\"},{\"name\":\"frameStartTime\",\"type\":\"uint256\"},{\"name\":\"frameEndTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"allowRecoverability\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getCurrentReportVariant\",\"outputs\":[{\"name\":\"beaconBalance\",\"type\":\"uint64\"},{\"name\":\"beaconValidators\",\"type\":\"uint32\"},{\"name\":\"count\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"appId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastCompletedEpochId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitializationBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setBeaconReportReceiver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"transferToVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_BEACON_SPEC\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"bytes32\"},{\"name\":\"_params\",\"type\":\"uint256[]\"}],\"name\":\"canPerform\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentEpochId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEVMScriptRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"addOracleMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBeaconReportReceiver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SET_REPORT_BOUNDARIES\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_quorum\",\"type\":\"uint256\"}],\"name\":\"setQuorum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getQuorum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kernel\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOracleMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPetrified\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setAllowedBeaconBalanceRelativeDecrease\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBeaconSpec\",\"outputs\":[{\"name\":\"epochsPerFrame\",\"type\":\"uint64\"},{\"name\":\"slotsPerEpoch\",\"type\":\"uint64\"},{\"name\":\"secondsPerSlot\",\"type\":\"uint64\"},{\"name\":\"genesisTime\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_epochsPerFrame\",\"type\":\"uint64\"},{\"name\":\"_slotsPerEpoch\",\"type\":\"uint64\"},{\"name\":\"_secondsPerSlot\",\"type\":\"uint64\"},{\"name\":\"_genesisTime\",\"type\":\"uint64\"}],\"name\":\"setBeaconSpec\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_MEMBERS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentReportVariantsSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"removeOracleMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"script\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"input\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"ScriptResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RecoverToVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AllowedBeaconBalanceAnnualRelativeIncreaseSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"AllowedBeaconBalanceRelativeDecreaseSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"callback\",\"type\":\"address\"}],\"name\":\"BeaconReportReceiverSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"member\",\"type\":\"address\"}],\"name\":\"MemberRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"quorum\",\"type\":\"uint256\"}],\"name\":\"QuorumChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"epochId\",\"type\":\"uint256\"}],\"name\":\"ExpectedEpochIdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"epochsPerFrame\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"slotsPerEpoch\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"secondsPerSlot\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"genesisTime\",\"type\":\"uint64\"}],\"name\":\"BeaconSpecSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"epochId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"beaconBalance\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"beaconValidators\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"BeaconReported\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"epochId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"beaconBalance\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"beaconValidators\",\"type\":\"uint128\"}],\"name\":\"Completed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"postTotalPooledEther\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"preTotalPooledEther\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeElapsed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalShares\",\"type\":\"uint256\"}],\"name\":\"PostTotalShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"ContractVersionSet\",\"type\":\"event\"}]", "ContractName": "LidoOracle", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "constantinople", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}