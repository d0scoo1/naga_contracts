{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DAONFT.sol\": {\r\n      \"content\": \"/**\\n *Submitted for verification at Etherscan.io on 2021-03-08\\n*/\\n\\n// File: openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\\n\\npragma solidity ^0.5.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * > Note: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\n// File: contracts/DAONFT.sol\\n\\npragma solidity ^0.5.16;\\n\\n\\n/**\\n * @title Custom NFT contract based off ERC721 but restricted by access control.\\n * @dev made for https://sips.synthetix.io/sips/sip-93\\n */\\ncontract DAONFT is Ownable {\\n    // Event that is emitted when a new token is minted\\n    event Mint(uint256 indexed tokenId, address to);\\n    // Event that is emitted when an existing token is burned\\n    event Burn(uint256 indexed tokenId);\\n    // Event that is emitted when an existing token is Transferred\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    // Event that is emitted when an existing token uri is altered\\n    event TokenURISet(uint256 tokenId, string tokenURI);\\n\\n    // Array of token ids\\n    uint256[] public tokens;\\n    // Map between an owner and their tokens\\n    mapping(address => uint256) public tokenOwned;\\n    // Maps a token to the owner address\\n    mapping(uint256 => address) public ownerOf;\\n    // Optional mapping for token URIs\\n    mapping(uint256 => string) private tokenURIs;\\n    // Token name\\n    string public name;\\n    // Token symbol\\n    string public symbol;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     * @param _name the name of the token\\n     * @param _symbol the symbol of the token\\n     */\\n    constructor(string memory _name, string memory _symbol) public {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /**\\n     * @dev Modifier to check that an address is not the \\\"0\\\" address\\n     * @param to address the address to check\\n     */\\n    modifier isValidAddress(address to) {\\n        require(to != address(0), \\\"Method called with the zero address\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Function to retrieve whether an address owns a token\\n     * @param owner address the address to check the balance of\\n     */\\n    function balanceOf(address owner) public view isValidAddress(owner) returns (uint256) {\\n        return tokenOwned[owner] > 0 ? 1 : 0;\\n    }\\n\\n    /**\\n     * @dev Transfer function to assign a token to another address\\n     * Reverts if the address already owns a token\\n     * @param from address the address that currently owns the token\\n     * @param to address the address to assign the token to\\n     * @param tokenId uint256 ID of the token to transfer\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public isValidAddress(to) isValidAddress(from) onlyOwner {\\n        require(tokenOwned[to] == 0, \\\"Destination address already owns a token\\\");\\n        require(ownerOf[tokenId] == from, \\\"From address does not own token\\\");\\n\\n        tokenOwned[from] = 0;\\n        tokenOwned[to] = tokenId;\\n\\n        ownerOf[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Mint function to mint a new token given a tokenId and assign it to an address\\n     * Reverts if the tokenId is 0 or the token already exist\\n     * @param to address the address to assign the token to\\n     * @param tokenId uint256 ID of the token to mint\\n     */\\n    function mint(address to, uint256 tokenId) public onlyOwner isValidAddress(to) {\\n        _mint(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Mint function to mint a new token given a tokenId and assign it to an address\\n     * Reverts if the tokenId is 0 or the token already exist\\n     * @param to address the address to assign the token to\\n     * @param tokenId uint256 ID of the token to mint\\n     */\\n    function mintWithTokenURI(\\n        address to,\\n        uint256 tokenId,\\n        string memory uri\\n    ) public onlyOwner isValidAddress(to) {\\n        require(bytes(uri).length > 0, \\\"URI must be supplied\\\");\\n\\n        _mint(to, tokenId);\\n\\n        tokenURIs[tokenId] = uri;\\n        emit TokenURISet(tokenId, uri);\\n    }\\n\\n    function _mint(address to, uint256 tokenId) private {\\n        require(tokenOwned[to] == 0, \\\"Destination address already owns a token\\\");\\n        require(ownerOf[tokenId] == address(0), \\\"ERC721: token already minted\\\");\\n        require(tokenId != 0, \\\"Token ID must be greater than 0\\\");\\n\\n        tokens.push(tokenId);\\n        tokenOwned[to] = tokenId;\\n        ownerOf[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n        emit Mint(tokenId, to);\\n    }\\n\\n    /**\\n     * @dev Burn function to remove a given tokenId\\n     * Reverts if the token ID does not exist.\\n     * @param tokenId uint256 ID of the token to burn\\n     */\\n    function burn(uint256 tokenId) public onlyOwner {\\n        address previousOwner = ownerOf[tokenId];\\n        require(previousOwner != address(0), \\\"ERC721: token does not exist\\\");\\n\\n        delete tokenOwned[previousOwner];\\n        delete ownerOf[tokenId];\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            if (tokens[i] == tokenId) {\\n                tokens[i] = tokens[tokens.length - 1];\\n                break;\\n            }\\n        }\\n\\n        tokens.pop();\\n\\n        if (bytes(tokenURIs[tokenId]).length != 0) {\\n            delete tokenURIs[tokenId];\\n        }\\n\\n        emit Burn(tokenId);\\n    }\\n\\n    /**\\n     * @dev Function to get the total supply of tokens currently available\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return tokens.length;\\n    }\\n\\n    /**\\n     * @dev Function to get the token URI for a given token.\\n     * Reverts if the token ID does not exist.\\n     * @param tokenId uint256 ID of the token to retrieve the uri for\\n     */\\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\\n        require(ownerOf[tokenId] != address(0), \\\"ERC721: token does not exist\\\");\\n        string memory _tokenURI = tokenURIs[tokenId];\\n        return _tokenURI;\\n    }\\n\\n    /**\\n     * @dev Function to set the token URI for a given token.\\n     * Reverts if the token ID does not exist.\\n     * @param tokenId uint256 ID of the token to set its URI\\n     * @param uri string URI to assign\\n     */\\n    function setTokenURI(uint256 tokenId, string memory uri) public onlyOwner {\\n        require(ownerOf[tokenId] != address(0), \\\"ERC721: token does not exist\\\");\\n        tokenURIs[tokenId] = uri;\\n        emit TokenURISet(tokenId, uri);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenURI\",\"type\":\"string\"}],\"name\":\"TokenURISet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"mintWithTokenURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenOwned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DAONFT", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000001a436f726520436f6e7472696275746f7220436f6d6d697474656500000000000000000000000000000000000000000000000000000000000000000000000000074343432d4e465400000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}