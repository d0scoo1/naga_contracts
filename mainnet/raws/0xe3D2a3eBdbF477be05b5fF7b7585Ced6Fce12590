{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TellorModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport \\\"@gnosis.pm/zodiac/contracts/core/Module.sol\\\";\\nimport \\\"usingtellor/contracts/UsingTellor.sol\\\";\\n\\ncontract TellorModule is Module, UsingTellor {\\n    // Events\\n    event ProposalAdded(bytes32 indexed queryId, string indexed proposalId);\\n    event TellorModuleSetup(\\n        address indexed initiator,\\n        address indexed avatar,\\n        address target\\n    );\\n    // Storage\\n    bool private _initialized;\\n    uint32 public resultExpiration;\\n    bytes32 public constant DOMAIN_SEPARATOR_TYPEHASH =\\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\\n    // keccak256(\\n    //     \\\"EIP712Domain(uint256 chainId,address verifyingContract)\\\"\\n    // );\\n    // Mapping of proposalHash to transactionHash to execution state\\n    mapping(bytes32 => mapping(bytes32 => bool))\\n        public executedProposalTransactions;\\n    bytes32 public constant INVALIDATED =\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint32 public cooldown;\\n    // Mapping of proposal hash to proposal id. Special case: INVALIDATED for proposal hashes that have been invalidated\\n    mapping(bytes32 => bytes32) public queryIds;\\n    bytes32 public constant TRANSACTION_TYPEHASH =\\n        0x72e9670a7ee00f5fbf1049b8c38e3f22fab7e9b85029e85cf9412f17fdd5c2ad;\\n\\n    // keccak256(\\n    //     \\\"Transaction(address to,uint256 value,bytes data,uint8 operation,uint256 nonce)\\\"\\n    // );\\n    /*Functions*/\\n    /**\\n     * @param _avatar Address of the avatar (e.g. a Safe)\\n     * @param _target Address of the contract that will call exec function\\n     * @param _tellorAddress Address of the Tellor oracle contract\\n     * @param _cooldown Cooldown in seconds that should be required after a oracle provided result\\n     * @param _expiration Duration that a positive result of the oracle is valid in seconds (or 0 if valid forever)\\n     * @notice There need to be at least 60 seconds between end of cooldown and expiration\\n     */\\n    constructor(\\n        address _avatar,\\n        address _target,\\n        address payable _tellorAddress,\\n        uint32 _cooldown,\\n        uint32 _expiration\\n    ) UsingTellor(_tellorAddress) {\\n        bytes memory initParams = abi.encode(\\n            _avatar,\\n            _target,\\n            _cooldown,\\n            _expiration\\n        );\\n        setUp(initParams);\\n    }\\n\\n    /**\\n     * @dev Function to add a proposal that should be considered for execution\\n     * @param _proposalId Id that should identify the proposal uniquely\\n     * @param _txHashes EIP-712 hashes of the transactions that should be executed\\n     */\\n    function addProposal(string memory _proposalId, bytes32[] memory _txHashes)\\n        public\\n    {\\n        // We generate the proposal string used for the oracle\\n        string memory _proposal = buildProposal(_proposalId, _txHashes);\\n        bytes32 _proposalHash = keccak256(bytes(_proposal));\\n        require(\\n            queryIds[_proposalHash] == bytes32(0),\\n            \\\"Proposal has already been submitted\\\"\\n        );\\n        bytes32 _queryId = getQueryId(_proposalId);\\n        // Set the proposal hash for this query id\\n        queryIds[_proposalHash] = _queryId;\\n        emit ProposalAdded(_queryId, _proposalId);\\n    }\\n\\n    /**\\n     * @dev Build the proposal by combining the proposalId and the hex string of the hash of the txHashes\\n     * @param _proposalId Id of the proposal that proposes to execute the transactions represented by the txHashes\\n     * @param _txHashes EIP-712 Hashes of the transactions that should be executed\\n     */\\n    function buildProposal(\\n        string memory _proposalId,\\n        bytes32[] memory _txHashes\\n    ) public pure returns (string memory) {\\n        string memory _txsHash = _bytes32ToAsciiString(\\n            keccak256(abi.encodePacked(_txHashes))\\n        );\\n        return\\n            string(abi.encodePacked(_proposalId, bytes3(0xe2909f), _txsHash));\\n    }\\n\\n    /**\\n     * @dev Executes the transactions of a proposal via the target if accepted\\n     * @param _proposalId Id that should identify the proposal uniquely\\n     * @param _txHashes EIP-712 hashes of the transactions that should be executed\\n     * @param _to Target of the transaction that should be executed\\n     * @param _value Wei value of the transaction that should be executed\\n     * @param _data Data of the transaction that should be executed\\n     * @param _operation Operation (Call or Delegatecall) of the transaction that should be executed\\n     * @notice The txIndex used by this function is always 0\\n     */\\n    function executeProposal(\\n        string memory _proposalId,\\n        bytes32[] memory _txHashes,\\n        address _to,\\n        uint256 _value,\\n        bytes memory _data,\\n        Enum.Operation _operation\\n    ) public {\\n        executeProposalWithIndex(\\n            _proposalId,\\n            _txHashes,\\n            _to,\\n            _value,\\n            _data,\\n            _operation,\\n            0\\n        );\\n    }\\n\\n    /**\\n     * @dev Executes the transactions of a proposal via the target if accepted\\n     * @param _proposalId Id that should identify the proposal uniquely\\n     * @param _txHashes EIP-712 hashes of the transactions that should be executed\\n     * @param _to Target of the transaction that should be executed\\n     * @param _value Wei value of the transaction that should be executed\\n     * @param _data Data of the transaction that should be executed\\n     * @param _operation Operation (Call or Delegatecall) of the transaction that should be executed\\n     * @param _txIndex Index of the transaction hash in txHashes. This is used as the nonce for the transaction, to make the tx hash unique\\n     */\\n    function executeProposalWithIndex(\\n        string memory _proposalId,\\n        bytes32[] memory _txHashes,\\n        address _to,\\n        uint256 _value,\\n        bytes memory _data,\\n        Enum.Operation _operation,\\n        uint256 _txIndex\\n    ) public {\\n        // We use the hash of the proposal to check the execution state, as the other parameters might change, but the proposal not\\n        bytes32 _proposalHash = keccak256(\\n            bytes(buildProposal(_proposalId, _txHashes))\\n        );\\n        // Lookup query id for this proposal\\n        bytes32 _queryId = queryIds[_proposalHash];\\n        // Proposal hash needs to set to be eligible for execution\\n        require(\\n            _queryId != bytes32(0),\\n            \\\"No query id set for provided proposal\\\"\\n        );\\n        require(_queryId != INVALIDATED, \\\"Proposal has been invalidated\\\");\\n        bytes32 _txHash = getTransactionHash(\\n            _to,\\n            _value,\\n            _data,\\n            _operation,\\n            _txIndex\\n        );\\n        require(_txHashes[_txIndex] == _txHash, \\\"Unexpected transaction hash\\\");\\n        (\\n            bool _ifRetrieve,\\n            bytes memory _valueRetrieved,\\n            uint256 _timestampReceived\\n        ) = getDataBefore(_queryId, block.timestamp);\\n        require(_ifRetrieve, \\\"Data not retrieved\\\");\\n        // The result is valid in the time after the cooldown and before the expiration time (if set).\\n        require(\\n            _timestampReceived + uint256(cooldown) < block.timestamp,\\n            \\\"Wait for additional cooldown\\\"\\n        );\\n        bool _didPass = abi.decode(_valueRetrieved, (bool));\\n        require(_didPass, \\\"Transaction was not approved\\\");\\n        uint32 _expiration = resultExpiration;\\n        require(\\n            _expiration == 0 ||\\n                _timestampReceived + uint256(_expiration) >= block.timestamp,\\n            \\\"Result has expired\\\"\\n        );\\n        // Check this is either the first transaction in the list or that the previous proposal was already approved\\n        require(\\n            _txIndex == 0 ||\\n                executedProposalTransactions[_proposalHash][\\n                    _txHashes[_txIndex - 1]\\n                ],\\n            \\\"Previous transaction not executed yet\\\"\\n        );\\n        // Check that this proposal was not executed yet\\n        require(\\n            !executedProposalTransactions[_proposalHash][_txHash],\\n            \\\"Cannot execute transaction again\\\"\\n        );\\n        // Mark transaction as executed\\n        executedProposalTransactions[_proposalHash][_txHash] = true;\\n        // Execute the transaction via the target.\\n        require(\\n            exec(_to, _value, _data, _operation),\\n            \\\"Module transaction failed\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Generate the query id.\\n     * @param _proposalId Id that should identify the proposal uniquely\\n     * @notice It is required that this is the same as for the oracle implementation used.\\n     */\\n    function getQueryId(string memory _proposalId)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes32 _queryId = keccak256(\\n            abi.encode(\\\"Snapshot\\\", abi.encode(_proposalId))\\n        );\\n        return _queryId;\\n    }\\n\\n    /**\\n     * @dev Returns the chain id used by this contract.\\n     */\\n    function getChainId() public view returns (uint256) {\\n        uint256 _id;\\n        // solium-disable-next-line security/no-inline-assembly\\n        assembly {\\n            _id := chainid()\\n        }\\n        return _id;\\n    }\\n\\n    /**\\n     * @dev Generates the data for the module transaction hash (required for signing)\\n     * @param _to Target of the transaction that should be executed\\n     * @param _value Wei value of the transaction that should be executed\\n     * @param _data Data of the transaction that should be executed\\n     * @param _operation Operation (Call or Delegatecall) of the transaction that should be executed\\n     * @param _nonce Nonce of the transaction that should be executed\\n     */\\n    function generateTransactionHashData(\\n        address _to,\\n        uint256 _value,\\n        bytes memory _data,\\n        Enum.Operation _operation,\\n        uint256 _nonce\\n    ) internal view returns (bytes memory) {\\n        uint256 _chainId = getChainId();\\n        bytes32 _domainSeparator = keccak256(\\n            abi.encode(DOMAIN_SEPARATOR_TYPEHASH, _chainId, this)\\n        );\\n        bytes32 _transactionHash = keccak256(\\n            abi.encode(\\n                TRANSACTION_TYPEHASH,\\n                _to,\\n                _value,\\n                keccak256(_data),\\n                _operation,\\n                _nonce\\n            )\\n        );\\n        return\\n            abi.encodePacked(\\n                bytes1(0x19),\\n                bytes1(0x01),\\n                _domainSeparator,\\n                _transactionHash\\n            );\\n    }\\n\\n    /**\\n     * @dev Generates the hash for the module transaction\\n     * @param _to Target of the transaction\\n     * @param _value Wei value of the transaction\\n     * @param _data Data of the transaction\\n     * @param _operation Operation (Call or Delegatecall) of the transaction\\n     * @param _nonce Nonce of the transaction\\n     */\\n    function getTransactionHash(\\n        address _to,\\n        uint256 _value,\\n        bytes memory _data,\\n        Enum.Operation _operation,\\n        uint256 _nonce\\n    ) public view returns (bytes32) {\\n        return\\n            keccak256(\\n                generateTransactionHashData(\\n                    _to,\\n                    _value,\\n                    _data,\\n                    _operation,\\n                    _nonce\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Marks a proposal with an expired result as invalid, preventing execution of the connected transactions\\n     * @param _proposalHash Proposal hash calculated based on the proposal id and txHashes\\n     */\\n    function markProposalWithExpiredResultAsInvalid(bytes32 _proposalHash)\\n        public\\n    {\\n        uint32 _expirationDuration = resultExpiration;\\n        require(_expirationDuration > 0, \\\"Results are valid forever\\\");\\n        bytes32 _queryId = queryIds[_proposalHash];\\n        require(_queryId != INVALIDATED, \\\"Proposal is already invalidated\\\");\\n        require(\\n            _queryId != bytes32(0),\\n            \\\"No query id set for provided proposal\\\"\\n        );\\n        (\\n            bool _ifRetrieve,\\n            bytes memory _valueRetrieved,\\n            uint256 _timestampRetrieved\\n        ) = getDataBefore(_queryId, block.timestamp);\\n        require(_ifRetrieve, \\\"Data not retrieved\\\");\\n        bool _didPass = abi.decode(_valueRetrieved, (bool));\\n        require(_didPass, \\\"Transaction was not approved\\\");\\n        require(\\n            _timestampRetrieved + uint256(_expirationDuration) <\\n                block.timestamp,\\n            \\\"Result has not expired yet\\\"\\n        );\\n        queryIds[_proposalHash] = INVALIDATED;\\n    }\\n\\n    /**\\n    //  * @dev Initializes the contract with the given parameters.\\n    //  * @param _initParams Initialization parameters for the contract\\n    //  */\\n    function setUp(bytes memory _initParams) public override {\\n        (\\n            address _avatar,\\n            address _target,\\n            uint32 _cooldown,\\n            uint32 _expiration\\n        ) = abi.decode(_initParams, (address, address, uint32, uint32));\\n        require(\\n            !_initialized,\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = true;\\n\\n        require(_avatar != address(0), \\\"Avatar can not be zero address\\\");\\n        require(_target != address(0), \\\"Target can not be zero address\\\");\\n        require(\\n            _expiration == 0 || _expiration - _cooldown >= 60,\\n            \\\"There need to be at least 60s between end of cooldown and expiration\\\"\\n        );\\n        avatar = _avatar;\\n        target = _target;\\n        resultExpiration = _expiration;\\n        cooldown = _cooldown;\\n        emit TellorModuleSetup(msg.sender, _avatar, _target);\\n    }\\n\\n    /**\\n     * @dev converts bytes32 to string\\n     * @param _bytes bytes32 to be converted\\n     */\\n    function _bytes32ToAsciiString(bytes32 _bytes)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes memory s = new bytes(64);\\n        for (uint256 i = 0; i < 32; i++) {\\n            uint8 b = uint8(bytes1(_bytes << (i * 8)));\\n            uint8 hi = uint8(b) / 16;\\n            uint8 lo = uint8(b) % 16;\\n            s[2 * i] = _char(hi);\\n            s[2 * i + 1] = _char(lo);\\n        }\\n        return string(s);\\n    }\\n\\n    /**\\n     * @dev converts uint8 to char\\n     * @param _b uint8 to be converted\\n     */\\n    function _char(uint8 _b) internal pure returns (bytes1 c) {\\n        if (_b < 10) return bytes1(_b + 0x30);\\n        else return bytes1(_b + 0x57);\\n    }\\n}\\n\"\r\n    },\r\n    \"@gnosis.pm/zodiac/contracts/core/Module.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n\\n/// @title Module Interface - A contract that can pass messages to a Module Manager contract if enabled by that contract.\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport \\\"../interfaces/IAvatar.sol\\\";\\nimport \\\"../factory/FactoryFriendly.sol\\\";\\nimport \\\"../guard/Guardable.sol\\\";\\n\\nabstract contract Module is FactoryFriendly, Guardable {\\n    /// @dev Emitted each time the avatar is set.\\n    event AvatarSet(address indexed previousAvatar, address indexed newAvatar);\\n    /// @dev Emitted each time the Target is set.\\n    event TargetSet(address indexed previousTarget, address indexed newTarget);\\n\\n    /// @dev Address that will ultimately execute function calls.\\n    address public avatar;\\n    /// @dev Address that this module will pass transactions to.\\n    address public target;\\n\\n    /// @dev Sets the avatar to a new avatar (`newAvatar`).\\n    /// @notice Can only be called by the current owner.\\n    function setAvatar(address _avatar) public onlyOwner {\\n        address previousAvatar = avatar;\\n        avatar = _avatar;\\n        emit AvatarSet(previousAvatar, _avatar);\\n    }\\n\\n    /// @dev Sets the target to a new target (`newTarget`).\\n    /// @notice Can only be called by the current owner.\\n    function setTarget(address _target) public onlyOwner {\\n        address previousTarget = target;\\n        target = _target;\\n        emit TargetSet(previousTarget, _target);\\n    }\\n\\n    /// @dev Passes a transaction to be executed by the avatar.\\n    /// @notice Can only be called by this contract.\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\\n    function exec(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation\\n    ) internal returns (bool success) {\\n        /// check if a transactioon guard is enabled.\\n        if (guard != address(0)) {\\n            IGuard(guard).checkTransaction(\\n                /// Transaction info used by module transactions\\n                to,\\n                value,\\n                data,\\n                operation,\\n                /// Zero out the redundant transaction information only used for Safe multisig transctions\\n                0,\\n                0,\\n                0,\\n                address(0),\\n                payable(0),\\n                bytes(\\\"0x\\\"),\\n                address(0)\\n            );\\n        }\\n        success = IAvatar(target).execTransactionFromModule(\\n            to,\\n            value,\\n            data,\\n            operation\\n        );\\n        if (guard != address(0)) {\\n            IGuard(guard).checkAfterExecution(bytes32(\\\"0x\\\"), success);\\n        }\\n        return success;\\n    }\\n\\n    /// @dev Passes a transaction to be executed by the target and returns data.\\n    /// @notice Can only be called by this contract.\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\\n    function execAndReturnData(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation\\n    ) internal returns (bool success, bytes memory returnData) {\\n        /// check if a transactioon guard is enabled.\\n        if (guard != address(0)) {\\n            IGuard(guard).checkTransaction(\\n                /// Transaction info used by module transactions\\n                to,\\n                value,\\n                data,\\n                operation,\\n                /// Zero out the redundant transaction information only used for Safe multisig transctions\\n                0,\\n                0,\\n                0,\\n                address(0),\\n                payable(0),\\n                bytes(\\\"0x\\\"),\\n                address(0)\\n            );\\n        }\\n        (success, returnData) = IAvatar(target)\\n            .execTransactionFromModuleReturnData(to, value, data, operation);\\n        if (guard != address(0)) {\\n            IGuard(guard).checkAfterExecution(bytes32(\\\"0x\\\"), success);\\n        }\\n        return (success, returnData);\\n    }\\n}\\n\"\r\n    },\r\n    \"usingtellor/contracts/UsingTellor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"./interface/ITellor.sol\\\";\\n\\n/**\\n * @title UserContract\\n * This contract allows for easy integration with the Tellor System\\n * by helping smart contracts to read data from Tellor\\n */\\ncontract UsingTellor {\\n    ITellor public tellor;\\n\\n    /*Constructor*/\\n    /**\\n     * @dev the constructor sets the tellor address in storage\\n     * @param _tellor is the TellorMaster address\\n     */\\n    constructor(address payable _tellor) {\\n        tellor = ITellor(_tellor);\\n    }\\n\\n    /*Getters*/\\n    /**\\n     * @dev Allows the user to get the latest value for the queryId specified\\n     * @param _queryId is the id to look up the value for\\n     * @return _ifRetrieve bool true if non-zero value successfully retrieved\\n     * @return _value the value retrieved\\n     * @return _timestampRetrieved the retrieved value's timestamp\\n     */\\n    function getCurrentValue(bytes32 _queryId)\\n        public\\n        view\\n        returns (\\n            bool _ifRetrieve,\\n            bytes memory _value,\\n            uint256 _timestampRetrieved\\n        )\\n    {\\n        uint256 _count = getNewValueCountbyQueryId(_queryId);\\n\\n        if (_count == 0) {\\n            return (false, bytes(\\\"\\\"), 0);\\n        }\\n        uint256 _time = getTimestampbyQueryIdandIndex(_queryId, _count - 1);\\n        _value = retrieveData(_queryId, _time);\\n        if (keccak256(_value) != keccak256(bytes(\\\"\\\")))\\n            return (true, _value, _time);\\n        return (false, bytes(\\\"\\\"), _time);\\n    }\\n\\n    /**\\n     * @dev Retrieves the latest value for the queryId before the specified timestamp\\n     * @param _queryId is the queryId to look up the value for\\n     * @param _timestamp before which to search for latest value\\n     * @return _ifRetrieve bool true if able to retrieve a non-zero value\\n     * @return _value the value retrieved\\n     * @return _timestampRetrieved the value's timestamp\\n     */\\n    function getDataBefore(bytes32 _queryId, uint256 _timestamp)\\n        public\\n        view\\n        returns (\\n            bool _ifRetrieve,\\n            bytes memory _value,\\n            uint256 _timestampRetrieved\\n        )\\n    {\\n        (bool _found, uint256 _index) = getIndexForDataBefore(\\n            _queryId,\\n            _timestamp\\n        );\\n        if (!_found) return (false, bytes(\\\"\\\"), 0);\\n        uint256 _time = getTimestampbyQueryIdandIndex(_queryId, _index);\\n        _value = retrieveData(_queryId, _time);\\n        if (keccak256(_value) != keccak256(bytes(\\\"\\\")))\\n            return (true, _value, _time);\\n        return (false, bytes(\\\"\\\"), 0);\\n    }\\n\\n    /**\\n     * @dev Retrieves latest array index of data before the specified timestamp for the queryId\\n     * @param _queryId is the queryId to look up the index for\\n     * @param _timestamp is the timestamp before which to search for the latest index\\n     * @return _found whether the index was found\\n     * @return _index the latest index found before the specified timestamp\\n     */\\n    // slither-disable-next-line calls-loop\\n    function getIndexForDataBefore(bytes32 _queryId, uint256 _timestamp)\\n        public\\n        view\\n        returns (bool _found, uint256 _index)\\n    {\\n        uint256 _count = getNewValueCountbyQueryId(_queryId);\\n\\n        if (_count > 0) {\\n            uint256 middle;\\n            uint256 start = 0;\\n            uint256 end = _count - 1;\\n            uint256 _time;\\n\\n            //Checking Boundaries to short-circuit the algorithm\\n            _time = getTimestampbyQueryIdandIndex(_queryId, start);\\n            if (_time >= _timestamp) return (false, 0);\\n            _time = getTimestampbyQueryIdandIndex(_queryId, end);\\n            if (_time < _timestamp) return (true, end);\\n\\n            //Since the value is within our boundaries, do a binary search\\n            while (true) {\\n                middle = (end - start) / 2 + 1 + start;\\n                _time = getTimestampbyQueryIdandIndex(_queryId, middle);\\n                if (_time < _timestamp) {\\n                    //get immediate next value\\n                    uint256 _nextTime = getTimestampbyQueryIdandIndex(\\n                        _queryId,\\n                        middle + 1\\n                    );\\n                    if (_nextTime >= _timestamp) {\\n                        //_time is correct\\n                        return (true, middle);\\n                    } else {\\n                        //look from middle + 1(next value) to end\\n                        start = middle + 1;\\n                    }\\n                } else {\\n                    uint256 _prevTime = getTimestampbyQueryIdandIndex(\\n                        _queryId,\\n                        middle - 1\\n                    );\\n                    if (_prevTime < _timestamp) {\\n                        // _prevtime is correct\\n                        return (true, middle - 1);\\n                    } else {\\n                        //look from start to middle -1(prev value)\\n                        end = middle - 1;\\n                    }\\n                }\\n                //We couldn't find a value\\n                //if(middle - 1 == start || middle == _count) return (false, 0);\\n            }\\n        }\\n        return (false, 0);\\n    }\\n\\n    /**\\n     * @dev Counts the number of values that have been submitted for the queryId\\n     * @param _queryId the id to look up\\n     * @return uint256 count of the number of values received for the queryId\\n     */\\n    function getNewValueCountbyQueryId(bytes32 _queryId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        //tellorx check rinkeby/ethereum\\n        if (\\n            tellor == ITellor(0x18431fd88adF138e8b979A7246eb58EA7126ea16) ||\\n            tellor == ITellor(0xe8218cACb0a5421BC6409e498d9f8CC8869945ea)\\n        ) {\\n            return tellor.getTimestampCountById(_queryId);\\n        } else {\\n            return tellor.getNewValueCountbyQueryId(_queryId);\\n        }\\n    }\\n\\n    // /**\\n    //  * @dev Gets the timestamp for the value based on their index\\n    //  * @param _queryId is the id to look up\\n    //  * @param _index is the value index to look up\\n    //  * @return uint256 timestamp\\n    //  */\\n    function getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        //tellorx check rinkeby/ethereum\\n        if (\\n            tellor == ITellor(0x18431fd88adF138e8b979A7246eb58EA7126ea16) ||\\n            tellor == ITellor(0xe8218cACb0a5421BC6409e498d9f8CC8869945ea)\\n        ) {\\n            return tellor.getReportTimestampByIndex(_queryId, _index);\\n        } else {\\n            return tellor.getTimestampbyQueryIdandIndex(_queryId, _index);\\n        }\\n    }\\n\\n    /**\\n     * @dev Determines whether a value with a given queryId and timestamp has been disputed\\n     * @param _queryId is the value id to look up\\n     * @param _timestamp is the timestamp of the value to look up\\n     * @return bool true if queryId/timestamp is under dispute\\n     */\\n    function isInDispute(bytes32 _queryId, uint256 _timestamp)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        ITellor _governance;\\n        //tellorx check rinkeby/ethereum\\n        if (\\n            tellor == ITellor(0x18431fd88adF138e8b979A7246eb58EA7126ea16) ||\\n            tellor == ITellor(0xe8218cACb0a5421BC6409e498d9f8CC8869945ea)\\n        ) {\\n            ITellor _newTellor = ITellor(\\n                0x88dF592F8eb5D7Bd38bFeF7dEb0fBc02cf3778a0\\n            );\\n            _governance = ITellor(\\n                _newTellor.addresses(\\n                    0xefa19baa864049f50491093580c5433e97e8d5e41f8db1a61108b4fa44cacd93\\n                )\\n            );\\n        } else {\\n            _governance = ITellor(tellor.governance());\\n        }\\n        return\\n            _governance\\n                .getVoteRounds(\\n                    keccak256(abi.encodePacked(_queryId, _timestamp))\\n                )\\n                .length > 0;\\n    }\\n\\n    /**\\n     * @dev Retrieve value from oracle based on queryId/timestamp\\n     * @param _queryId being requested\\n     * @param _timestamp to retrieve data/value from\\n     * @return bytes value for query/timestamp submitted\\n     */\\n    function retrieveData(bytes32 _queryId, uint256 _timestamp)\\n        public\\n        view\\n        returns (bytes memory)\\n    {\\n        //tellorx check rinkeby/ethereum\\n        if (\\n            tellor == ITellor(0x18431fd88adF138e8b979A7246eb58EA7126ea16) ||\\n            tellor == ITellor(0xe8218cACb0a5421BC6409e498d9f8CC8869945ea)\\n        ) {\\n            return tellor.getValueByTimestamp(_queryId, _timestamp);\\n        } else {\\n            return tellor.retrieveData(_queryId, _timestamp);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@gnosis.pm/zodiac/contracts/interfaces/IAvatar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n\\n/// @title Zodiac Avatar - A contract that manages modules that can execute transactions via this contract.\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport \\\"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\\\";\\n\\ninterface IAvatar {\\n    /// @dev Enables a module on the avatar.\\n    /// @notice Can only be called by the avatar.\\n    /// @notice Modules should be stored as a linked list.\\n    /// @notice Must emit EnabledModule(address module) if successful.\\n    /// @param module Module to be enabled.\\n    function enableModule(address module) external;\\n\\n    /// @dev Disables a module on the avatar.\\n    /// @notice Can only be called by the avatar.\\n    /// @notice Must emit DisabledModule(address module) if successful.\\n    /// @param prevModule Address that pointed to the module to be removed in the linked list\\n    /// @param module Module to be removed.\\n    function disableModule(address prevModule, address module) external;\\n\\n    /// @dev Allows a Module to execute a transaction.\\n    /// @notice Can only be called by an enabled module.\\n    /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\\n    /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\\n    function execTransactionFromModule(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation\\n    ) external returns (bool success);\\n\\n    /// @dev Allows a Module to execute a transaction and return data\\n    /// @notice Can only be called by an enabled module.\\n    /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\\n    /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\\n    function execTransactionFromModuleReturnData(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    /// @dev Returns if an module is enabled\\n    /// @return True if the module is enabled\\n    function isModuleEnabled(address module) external view returns (bool);\\n\\n    /// @dev Returns array of modules.\\n    /// @param start Start of the page.\\n    /// @param pageSize Maximum number of modules that should be returned.\\n    /// @return array Array of modules.\\n    /// @return next Start of the next page.\\n    function getModulesPaginated(address start, uint256 pageSize)\\n        external\\n        view\\n        returns (address[] memory array, address next);\\n}\\n\"\r\n    },\r\n    \"@gnosis.pm/zodiac/contracts/factory/FactoryFriendly.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n\\n/// @title Zodiac FactoryFriendly - A contract that allows other contracts to be initializable and pass bytes as arguments to define contract state\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\nabstract contract FactoryFriendly is OwnableUpgradeable {\\n    function setUp(bytes memory initializeParams) public virtual;\\n}\\n\"\r\n    },\r\n    \"@gnosis.pm/zodiac/contracts/guard/Guardable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport \\\"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@gnosis.pm/safe-contracts/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"./BaseGuard.sol\\\";\\n\\n/// @title Guardable - A contract that manages fallback calls made to this contract\\ncontract Guardable is OwnableUpgradeable {\\n    event ChangedGuard(address guard);\\n\\n    address public guard;\\n\\n    /// @dev Set a guard that checks transactions before execution\\n    /// @param _guard The address of the guard to be used or the 0 address to disable the guard\\n    function setGuard(address _guard) external onlyOwner {\\n        if (_guard != address(0)) {\\n            require(\\n                BaseGuard(_guard).supportsInterface(type(IGuard).interfaceId),\\n                \\\"Guard does not implement IERC165\\\"\\n            );\\n        }\\n        guard = _guard;\\n        emit ChangedGuard(guard);\\n    }\\n\\n    function getGuard() external view returns (address _guard) {\\n        return guard;\\n    }\\n}\\n\"\r\n    },\r\n    \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/// @title Enum - Collection of enums\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract Enum {\\n    enum Operation {Call, DelegateCall}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@gnosis.pm/safe-contracts/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/// @notice More details at https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@gnosis.pm/zodiac/contracts/guard/BaseGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport \\\"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\\\";\\nimport \\\"@gnosis.pm/safe-contracts/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"../interfaces/IGuard.sol\\\";\\n\\nabstract contract BaseGuard is IERC165 {\\n    function supportsInterface(bytes4 interfaceId)\\n        external\\n        pure\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IGuard).interfaceId || // 0xe6d7a83a\\n            interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\\n    }\\n\\n    /// Module transactions only use the first four parameters: to, value, data, and operation.\\n    /// Module.sol hardcodes the remaining parameters as 0 since they are not used for module transactions.\\n    /// This interface is used to maintain compatibilty with Gnosis Safe transaction guards.\\n    function checkTransaction(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address payable refundReceiver,\\n        bytes memory signatures,\\n        address msgSender\\n    ) external virtual;\\n\\n    function checkAfterExecution(bytes32 txHash, bool success) external virtual;\\n}\\n\"\r\n    },\r\n    \"@gnosis.pm/zodiac/contracts/interfaces/IGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport \\\"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\\\";\\n\\ninterface IGuard {\\n    function checkTransaction(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address payable refundReceiver,\\n        bytes memory signatures,\\n        address msgSender\\n    ) external;\\n\\n    function checkAfterExecution(bytes32 txHash, bool success) external;\\n}\\n\"\r\n    },\r\n    \"usingtellor/contracts/interface/ITellor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface ITellor{\\n    //Controller\\n    function addresses(bytes32) external view returns(address);\\n    function uints(bytes32) external view returns(uint256);\\n    function burn(uint256 _amount) external;\\n    function changeDeity(address _newDeity) external;\\n    function changeOwner(address _newOwner) external;\\n    function changeTellorContract(address _tContract) external;\\n    function changeControllerContract(address _newController) external;\\n    function changeGovernanceContract(address _newGovernance) external;\\n    function changeOracleContract(address _newOracle) external;\\n    function changeTreasuryContract(address _newTreasury) external;\\n    function changeUint(bytes32 _target, uint256 _amount) external;\\n    function migrate() external;\\n    function mint(address _reciever, uint256 _amount) external;\\n    function init() external;\\n    function getAllDisputeVars(uint256 _disputeId) external view returns (bytes32,bool,bool,bool,address,address,address,uint256[9] memory,int256);\\n    function getDisputeIdByDisputeHash(bytes32 _hash) external view returns (uint256);\\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data) external view returns(uint256);\\n    function getLastNewValueById(uint256 _requestId) external view returns (uint256, bool);\\n    function retrieveData(uint256 _requestId, uint256 _timestamp) external view returns (uint256);\\n    function getNewValueCountbyRequestId(uint256 _requestId) external view returns (uint256);\\n    function getAddressVars(bytes32 _data) external view returns (address);\\n    function getUintVar(bytes32 _data) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function isMigrated(address _addy) external view returns (bool);\\n    function allowance(address _user, address _spender) external view  returns (uint256);\\n    function allowedToTrade(address _user, uint256 _amount) external view returns (bool);\\n    function approve(address _spender, uint256 _amount) external returns (bool);\\n    function approveAndTransferFrom(address _from, address _to, uint256 _amount) external returns(bool);\\n    function balanceOf(address _user) external view returns (uint256);\\n    function balanceOfAt(address _user, uint256 _blockNumber)external view returns (uint256);\\n    function transfer(address _to, uint256 _amount)external returns (bool success);\\n    function transferFrom(address _from,address _to,uint256 _amount) external returns (bool success) ;\\n    function depositStake() external;\\n    function requestStakingWithdraw() external;\\n    function withdrawStake() external;\\n    function changeStakingStatus(address _reporter, uint _status) external;\\n    function slashReporter(address _reporter, address _disputer) external;\\n    function getStakerInfo(address _staker) external view returns (uint256, uint256);\\n    function getTimestampbyRequestIDandIndex(uint256 _requestId, uint256 _index) external view returns (uint256);\\n    function getNewCurrentVariables()external view returns (bytes32 _c,uint256[5] memory _r,uint256 _d,uint256 _t);\\n    function getNewValueCountbyQueryId(bytes32 _queryId) external view returns(uint256);\\n    function getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index) external view returns(uint256);\\n    function retrieveData(bytes32 _queryId, uint256 _timestamp) external view returns(bytes memory);\\n    //Governance\\n    enum VoteResult {FAILED,PASSED,INVALID}\\n    function setApprovedFunction(bytes4 _func, bool _val) external;\\n    function beginDispute(bytes32 _queryId,uint256 _timestamp) external;\\n    function delegate(address _delegate) external;\\n    function delegateOfAt(address _user, uint256 _blockNumber) external view returns (address);\\n    function executeVote(uint256 _disputeId) external;\\n    function proposeVote(address _contract,bytes4 _function, bytes calldata _data, uint256 _timestamp) external;\\n    function tallyVotes(uint256 _disputeId) external;\\n    function governance() external view returns (address);\\n    function updateMinDisputeFee() external;\\n    function verify() external pure returns(uint);\\n    function vote(uint256 _disputeId, bool _supports, bool _invalidQuery) external;\\n    function voteFor(address[] calldata _addys,uint256 _disputeId, bool _supports, bool _invalidQuery) external;\\n    function getDelegateInfo(address _holder) external view returns(address,uint);\\n    function isFunctionApproved(bytes4 _func) external view returns(bool);\\n    function isApprovedGovernanceContract(address _contract) external returns (bool);\\n    function getVoteRounds(bytes32 _hash) external view returns(uint256[] memory);\\n    function getVoteCount() external view returns(uint256);\\n    function getVoteInfo(uint256 _disputeId) external view returns(bytes32,uint256[9] memory,bool[2] memory,VoteResult,bytes memory,bytes4,address[2] memory);\\n    function getDisputeInfo(uint256 _disputeId) external view returns(uint256,uint256,bytes memory, address);\\n    function getOpenDisputesOnId(bytes32 _queryId) external view returns(uint256);\\n    function didVote(uint256 _disputeId, address _voter) external view returns(bool);\\n    //Oracle\\n    function getReportTimestampByIndex(bytes32 _queryId, uint256 _index) external view returns(uint256);\\n    function getValueByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(bytes memory);\\n    function getBlockNumberByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(uint256);\\n    function getReportingLock() external view returns(uint256);\\n    function getReporterByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(address);\\n    function reportingLock() external view returns(uint256);\\n    function removeValue(bytes32 _queryId, uint256 _timestamp) external;\\n    function getReportsSubmittedByAddress(address _reporter) external view returns(uint256);\\n    function getTipsByUser(address _user) external view returns(uint256);\\n    function tipQuery(bytes32 _queryId, uint256 _tip, bytes memory _queryData) external;\\n    function submitValue(bytes32 _queryId, bytes calldata _value, uint256 _nonce, bytes memory _queryData) external;\\n    function burnTips() external;\\n    function changeReportingLock(uint256 _newReportingLock) external;\\n    function changeTimeBasedReward(uint256 _newTimeBasedReward) external;\\n    function getReporterLastTimestamp(address _reporter) external view returns(uint256);\\n    function getTipsById(bytes32 _queryId) external view returns(uint256);\\n    function getTimeBasedReward() external view returns(uint256);\\n    function getTimestampCountById(bytes32 _queryId) external view returns(uint256);\\n    function getTimestampIndexByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(uint256);\\n    function getCurrentReward(bytes32 _queryId) external view returns(uint256, uint256);\\n    function getCurrentValue(bytes32 _queryId) external view returns(bytes memory);\\n    function getTimeOfLastNewValue() external view returns(uint256);\\n    //Treasury\\n    function issueTreasury(uint256 _maxAmount, uint256 _rate, uint256 _duration) external;\\n    function payTreasury(address _investor,uint256 _id) external;\\n    function buyTreasury(uint256 _id,uint256 _amount) external;\\n    function getTreasuryDetails(uint256 _id) external view returns(uint256,uint256,uint256,uint256);\\n    function getTreasuryFundsByUser(address _user) external view returns(uint256);\\n    function getTreasuryAccount(uint256 _id, address _investor) external view returns(uint256,uint256,bool);\\n    function getTreasuryCount() external view returns(uint256);\\n    function getTreasuryOwners(uint256 _id) external view returns(address[] memory);\\n    function wasPaid(uint256 _id, address _investor) external view returns(bool);\\n    //Test functions\\n    function changeAddressVar(bytes32 _id, address _addy) external;\\n\\n    //parachute functions\\n    function killContract() external;\\n    function migrateFor(address _destination,uint256 _amount) external;\\n    function rescue51PercentAttack(address _tokenHolder) external;\\n    function rescueBrokenDataReporting() external;\\n    function rescueFailedUpdate() external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_avatar\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_tellorAddress\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_cooldown\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_expiration\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousAvatar\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAvatar\",\"type\":\"address\"}],\"name\":\"AvatarSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"guard\",\"type\":\"address\"}],\"name\":\"ChangedGuard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"queryId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"proposalId\",\"type\":\"string\"}],\"name\":\"ProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousTarget\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTarget\",\"type\":\"address\"}],\"name\":\"TargetSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"avatar\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"TellorModuleSetup\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INVALIDATED\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSACTION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_proposalId\",\"type\":\"string\"},{\"internalType\":\"bytes32[]\",\"name\":\"_txHashes\",\"type\":\"bytes32[]\"}],\"name\":\"addProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avatar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_proposalId\",\"type\":\"string\"},{\"internalType\":\"bytes32[]\",\"name\":\"_txHashes\",\"type\":\"bytes32[]\"}],\"name\":\"buildProposal\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldown\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_proposalId\",\"type\":\"string\"},{\"internalType\":\"bytes32[]\",\"name\":\"_txHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"_operation\",\"type\":\"uint8\"}],\"name\":\"executeProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_proposalId\",\"type\":\"string\"},{\"internalType\":\"bytes32[]\",\"name\":\"_txHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"_operation\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_txIndex\",\"type\":\"uint256\"}],\"name\":\"executeProposalWithIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"executedProposalTransactions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"}],\"name\":\"getCurrentValue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_ifRetrieve\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_value\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_timestampRetrieved\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getDataBefore\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_ifRetrieve\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_value\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_timestampRetrieved\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGuard\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_guard\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getIndexForDataBefore\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_found\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"}],\"name\":\"getNewValueCountbyQueryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_proposalId\",\"type\":\"string\"}],\"name\":\"getQueryId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTimestampbyQueryIdandIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"enum Enum.Operation\",\"name\":\"_operation\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getTransactionHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guard\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"isInDispute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proposalHash\",\"type\":\"bytes32\"}],\"name\":\"markProposalWithExpiredResultAsInvalid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"queryIds\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resultExpiration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"retrieveData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_avatar\",\"type\":\"address\"}],\"name\":\"setAvatar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_guard\",\"type\":\"address\"}],\"name\":\"setGuard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"setTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_initParams\",\"type\":\"bytes\"}],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tellor\",\"outputs\":[{\"internalType\":\"contract ITellor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TellorModule", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000039e419ba25196794b595b2a595ea8e527ddc985600000000000000000000000039e419ba25196794b595b2a595ea8e527ddc9856000000000000000000000000e8218cacb0a5421bc6409e498d9f8cc8869945ea00000000000000000000000000000000000000000000000000000000000000170000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}