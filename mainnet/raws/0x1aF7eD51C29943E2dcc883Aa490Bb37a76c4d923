{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DroppingNowMarketplace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.2;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\r\\nimport \\\"./interfaces/ITokenManagerSelector.sol\\\";\\r\\nimport \\\"./interfaces/IPriceCalculatorManager.sol\\\";\\r\\nimport \\\"./interfaces/ITokenManager.sol\\\";\\r\\nimport \\\"./interfaces/IPriceCalculator.sol\\\";\\r\\nimport \\\"./interfaces/ICollectionsRegistry.sol\\\";\\r\\nimport \\\"./interfaces/IDroppingNowToken.sol\\\";\\r\\nimport \\\"./interfaces/IDropperToken.sol\\\";\\r\\nimport \\\"./libraries/HashHelper.sol\\\";\\r\\n\\r\\ncontract DroppingNowMarketplace is Ownable, Pausable {\\r\\n    bytes32 public immutable DOMAIN_SEPARATOR;\\r\\n    \\r\\n    ITokenManagerSelector public tokenManagerSelector;\\r\\n    IPriceCalculatorManager public priceCalculatorManager;\\r\\n    IDroppingNowToken public droppingNowToken;\\r\\n    IDropperToken public dropperToken;\\r\\n    ICollectionsRegistry public collectionsRegistry;\\r\\n    address public saleRewardRecipient;\\r\\n    address public dropRewardRecipient;\\r\\n    address public dropRewardEscrowRecipient;\\r\\n    uint256 public dropperFee;\\r\\n    uint256 public marketplaceFee;\\r\\n    uint256 public minItemPriceForDN;\\r\\n\\r\\n    mapping (bytes32 => bool) private _auctions;\\r\\n\\r\\n    event NewTokenManagerSelector(address indexed tokenManagerSelector);\\r\\n    event NewPriceCalculatorManager(address indexed priceCalculatorManager);\\r\\n    event NewDroppingNowToken(address indexed droppingNowToken);\\r\\n    event NewDropperToken(address indexed dropperToken);\\r\\n    event NewSaleRewardRecepient(address indexed saleRewardRecepient);\\r\\n    event NewDropRewardRecepient(address indexed dropRewardRecepient);\\r\\n    event NewDropRewardEscrowRecepient(address indexed dropRewardEscrowRecepient);\\r\\n    event NewDropperFee(uint256 dropperFee);\\r\\n    event NewMarketplaceFee(uint256 marketplaceFee);\\r\\n    event NewMinItemPriceForDN(uint256 minItemPriceForDN);\\r\\n\\r\\n    event SingleAuctionCreated(\\r\\n        bytes32 indexed auctionHash,\\r\\n        address indexed tokenAddress,\\r\\n        uint256 indexed tokenId,\\r\\n        uint256 amount,\\r\\n        address seller,\\r\\n        uint256 listOn,\\r\\n        uint256 startingPrice,\\r\\n        address priceCalculator,\\r\\n        string description\\r\\n    );\\r\\n\\r\\n    event BundleAuctionCreated(\\r\\n        bytes32 indexed auctionHash,\\r\\n        address indexed tokenAddress,\\r\\n        uint256[] tokenIds,\\r\\n        uint256[] amounts,\\r\\n        address seller,\\r\\n        uint256 listOn,\\r\\n        uint256 startingPrice,\\r\\n        address priceCalculator,\\r\\n        string name,\\r\\n        string description\\r\\n    );\\r\\n\\r\\n    event SingleSale(\\r\\n        bytes32 indexed auctionHash,\\r\\n        address indexed tokenAddress,\\r\\n        uint256 indexed tokenId,\\r\\n        uint256 amount,\\r\\n        address seller,\\r\\n        address buyer,\\r\\n        address priceCalculator,\\r\\n        uint256 price\\r\\n    );\\r\\n\\r\\n    event BundleSale(\\r\\n        bytes32 indexed auctionHash,\\r\\n        address indexed tokenAddress,\\r\\n        uint256[] tokenIds,\\r\\n        uint256[] amounts,\\r\\n        address seller,\\r\\n        address buyer,\\r\\n        address priceCalculator,\\r\\n        uint256 price\\r\\n    );\\r\\n\\r\\n    event SingleAuctionCanceled(\\r\\n        bytes32 indexed auctionHash,\\r\\n        address indexed tokenAddress,\\r\\n        uint256 indexed tokenId,\\r\\n        uint256 amount,\\r\\n        address seller,\\r\\n        address priceCalculator\\r\\n    );\\r\\n\\r\\n    event BundleAuctionCanceled(\\r\\n        bytes32 indexed auctionHash,\\r\\n        address indexed tokenAddress,\\r\\n        uint256[] tokenIds,\\r\\n        uint256[] amounts,\\r\\n        address seller,\\r\\n        address priceCalculator\\r\\n    );\\r\\n\\r\\n    constructor(\\r\\n        address tokenManagerSelectorAddress,\\r\\n        address priceCalculatorManagerAddress,\\r\\n        address droppingNowTokenAddress,\\r\\n        address dropperTokenAddress,\\r\\n        address collectionsRegistryAddress,\\r\\n        address saleRewardRecipientAddress,\\r\\n        address dropRewardRecipientAddress,\\r\\n        address dropRewardEscrowRecipientAddress,\\r\\n        uint256 dropperFeeValue,\\r\\n        uint256 marketplaceFeeValue,\\r\\n        uint256 minItemPriceForDNValue\\r\\n    ) {\\r\\n        DOMAIN_SEPARATOR = keccak256(\\r\\n            abi.encode(\\r\\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, // keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")\\r\\n                0xc94add498610ef8f6b104cb561856491569d6e3bb6f1dd4762b8f7a04dc69952, // keccak256(\\\"DroppingNowMarketplace\\\")\\r\\n                0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, // keccak256(bytes(\\\"1\\\")) for versionId = 1\\r\\n                block.chainid,\\r\\n                address(this)\\r\\n            )\\r\\n        );\\r\\n\\r\\n        tokenManagerSelector = ITokenManagerSelector(tokenManagerSelectorAddress);\\r\\n        priceCalculatorManager = IPriceCalculatorManager(priceCalculatorManagerAddress);\\r\\n        droppingNowToken = IDroppingNowToken(droppingNowTokenAddress);\\r\\n        dropperToken = IDropperToken(dropperTokenAddress);\\r\\n        collectionsRegistry = ICollectionsRegistry(collectionsRegistryAddress);\\r\\n        saleRewardRecipient = saleRewardRecipientAddress;\\r\\n        dropRewardRecipient = dropRewardRecipientAddress;\\r\\n        dropRewardEscrowRecipient = dropRewardEscrowRecipientAddress;\\r\\n        dropperFee = dropperFeeValue;\\r\\n        marketplaceFee = marketplaceFeeValue;\\r\\n        minItemPriceForDN = minItemPriceForDNValue;\\r\\n    }\\r\\n\\r\\n    function pause() external onlyOwner {\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    function unpause() external onlyOwner {\\r\\n        _unpause();\\r\\n    }\\r\\n\\r\\n    function createSingleAuction(\\r\\n        address tokenAddress,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount,\\r\\n        uint256 listOn,\\r\\n        uint256 startingPrice,\\r\\n        address priceCalculator,\\r\\n        string calldata description\\r\\n    ) external whenNotPaused {\\r\\n        _createSingleAuction(\\r\\n            tokenAddress,\\r\\n            tokenId,\\r\\n            amount,\\r\\n            listOn,\\r\\n            startingPrice,\\r\\n            priceCalculator,\\r\\n            description);\\r\\n    }\\r\\n\\r\\n    function createMultipleSingleAuctions(\\r\\n        address[] calldata tokenAddresses,\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint256[] calldata amounts,\\r\\n        uint256[] calldata listOns,\\r\\n        uint256[] memory startingPrices,\\r\\n        address[] memory priceCalculators,\\r\\n        string[] calldata descriptions\\r\\n    ) external whenNotPaused {\\r\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\r\\n            _createSingleAuction(\\r\\n                tokenAddresses[i],\\r\\n                tokenIds[i],\\r\\n                amounts[i],\\r\\n                listOns[i],\\r\\n                startingPrices[i],\\r\\n                priceCalculators[i],\\r\\n                descriptions[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function createBundleAuction(\\r\\n        address tokenAddress,\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint256[] calldata amounts,\\r\\n        uint256 listOn,\\r\\n        uint256 startingPrice,\\r\\n        address priceCalculator,\\r\\n        string memory name,\\r\\n        string memory description\\r\\n    ) external whenNotPaused {\\r\\n        if (listOn < block.timestamp) {\\r\\n            listOn = block.timestamp;\\r\\n        }\\r\\n\\r\\n        require(tokenIds.length > 1, \\\"DroppingNowMarketplace: bundle auction cannot be created with single token\\\");\\r\\n        require(amounts.length == tokenIds.length, \\\"DroppingNowMarketplace: count of amounts must be same as tokens count\\\");\\r\\n        require(listOn < (block.timestamp + 30 days), \\\"DroppingNowMarketplace: cannot be listed later than 30 days\\\");\\r\\n        require(priceCalculatorManager.isCalculatorAllowed(priceCalculator), \\\"DroppingNowMarketplace: calculator is not allowed\\\");\\r\\n        require(IPriceCalculator(priceCalculator).isPriceAllowed(startingPrice), \\\"DroppingNowMarketplace: price is not allowed\\\");\\r\\n\\r\\n        uint256[] memory amountsEscrow = new uint256[](tokenIds.length);\\r\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\r\\n            uint256 amount = _escrowToken(msg.sender, tokenAddress, tokenIds[i], amounts[i]);\\r\\n            amountsEscrow[i] = amount;\\r\\n        }\\r\\n\\r\\n        bytes32 auctionHash = HashHelper.bundleAuctionHash(\\r\\n            tokenAddress,\\r\\n            tokenIds,\\r\\n            amountsEscrow,\\r\\n            listOn,\\r\\n            startingPrice,\\r\\n            priceCalculator,\\r\\n            msg.sender,\\r\\n            DOMAIN_SEPARATOR);\\r\\n\\r\\n        _auctions[auctionHash] = true;\\r\\n        emit BundleAuctionCreated(\\r\\n            auctionHash,\\r\\n            tokenAddress,\\r\\n            tokenIds,\\r\\n            amountsEscrow,\\r\\n            msg.sender,\\r\\n            listOn,\\r\\n            startingPrice,\\r\\n            priceCalculator,\\r\\n            name,\\r\\n            description);\\r\\n    }\\r\\n\\r\\n    function buySingleAuction(\\r\\n        address tokenAddress,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount,\\r\\n        uint256 listOn,\\r\\n        uint256 startingPrice,\\r\\n        address priceCalculator,\\r\\n        address payable seller\\r\\n    ) external payable whenNotPaused {\\r\\n        require(listOn <= block.timestamp, \\\"DroppingNowMarketplace: auction is not started\\\");\\r\\n\\r\\n        // validate\\r\\n        bytes32 auctionHash = HashHelper.singleAuctionHash(\\r\\n            tokenAddress,\\r\\n            tokenId,\\r\\n            amount,\\r\\n            listOn,\\r\\n            startingPrice,\\r\\n            priceCalculator,\\r\\n            seller,\\r\\n            DOMAIN_SEPARATOR);\\r\\n        require(_auctions[auctionHash] == true, \\\"DroppingNowMarketplace: is not on auction\\\");\\r\\n\\r\\n        uint256 totalPrice = IPriceCalculator(priceCalculator).calculateCurrentPrice(startingPrice, listOn);\\r\\n        require(msg.value >= totalPrice, \\\"DroppingNowMarketplace: insufficient money sent\\\");\\r\\n\\r\\n        _auctions[auctionHash] = false;\\r\\n\\r\\n        uint256 sellerValue = totalPrice;\\r\\n\\r\\n        {\\r\\n            // 1. calculate, transfer and reward dropper fee\\r\\n            uint256 dropperFeePayed = _payDropperFee(tokenAddress, amount, totalPrice);\\r\\n            _dropReward(seller, tokenAddress, tokenId, amount);\\r\\n            sellerValue = sellerValue - dropperFeePayed;\\r\\n        }\\r\\n\\r\\n        {\\r\\n            // 2. calculate, transfer and reward marketplace fee\\r\\n            uint256 marketplaceFeePayed = _payMarketplaceFee(totalPrice);\\r\\n            _saleReward(seller, tokenAddress, 1, totalPrice);\\r\\n            sellerValue = sellerValue - marketplaceFeePayed;\\r\\n        }\\r\\n\\r\\n        // 3. transfer tokens from manager to buyer\\r\\n        _withdrawToken(msg.sender, tokenAddress, tokenId, amount);\\r\\n\\r\\n        // 4. transfer money to seller\\r\\n        seller.transfer(sellerValue);\\r\\n\\r\\n        // 5. return bid excess\\r\\n        if (msg.value > totalPrice) {\\r\\n            uint256 excess = msg.value - totalPrice;\\r\\n            payable(msg.sender).transfer(excess);\\r\\n        }\\r\\n\\r\\n        emit SingleSale(auctionHash, tokenAddress, tokenId, amount, seller, msg.sender, priceCalculator, totalPrice);\\r\\n    }\\r\\n\\r\\n    function buyBundleAuction(\\r\\n        address tokenAddress,\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint256[] calldata amounts,\\r\\n        uint256 listOn,\\r\\n        uint256 startingPrice,\\r\\n        address priceCalculator,\\r\\n        address payable seller\\r\\n    ) external payable whenNotPaused {\\r\\n        require(listOn <= block.timestamp, \\\"DroppingNowMarketplace: auction is not started\\\");\\r\\n\\r\\n        // validate\\r\\n        bytes32 auctionHash = HashHelper.bundleAuctionHash(\\r\\n            tokenAddress,\\r\\n            tokenIds,\\r\\n            amounts,\\r\\n            listOn,\\r\\n            startingPrice,\\r\\n            priceCalculator,\\r\\n            seller,\\r\\n            DOMAIN_SEPARATOR);\\r\\n        require(_auctions[auctionHash] == true, \\\"DroppingNowMarketplace: is not on auction\\\");\\r\\n\\r\\n        uint256 totalPrice = IPriceCalculator(priceCalculator).calculateCurrentPrice(startingPrice, listOn);\\r\\n        require(msg.value >= totalPrice, \\\"DroppingNowMarketplace: insufficient money sent\\\");\\r\\n\\r\\n        _auctions[auctionHash] = false;\\r\\n\\r\\n        uint256 sellerValue = totalPrice;\\r\\n\\r\\n        {\\r\\n            // 1. calculate, transfer and reward dropper fee\\r\\n            uint256 dropperFeePayed = _payDropperFee(tokenAddress, amounts[0], totalPrice);\\r\\n            _dropRewardBundle(seller, tokenAddress, tokenIds, amounts[0]);\\r\\n            sellerValue = sellerValue - dropperFeePayed;\\r\\n        }\\r\\n        \\r\\n        {\\r\\n            // 2. calculate, transfer and reward marketplace fee\\r\\n            uint256 marketplaceFeePayed = _payMarketplaceFee(totalPrice);\\r\\n            _saleReward(seller, tokenAddress, tokenIds.length, totalPrice);\\r\\n            sellerValue = sellerValue - marketplaceFeePayed;\\r\\n        }\\r\\n\\r\\n        // 3. transfer tokens from manager to buyer\\r\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\r\\n            _withdrawToken(msg.sender, tokenAddress, tokenIds[i], amounts[i]);\\r\\n        }\\r\\n\\r\\n        // 4. transfer money to seller\\r\\n        seller.transfer(sellerValue);\\r\\n\\r\\n        // 5. return bid excess\\r\\n        if (msg.value > totalPrice) {\\r\\n            uint256 excess = msg.value - totalPrice;\\r\\n            payable(msg.sender).transfer(excess);\\r\\n        }\\r\\n\\r\\n        emit BundleSale(auctionHash, tokenAddress, tokenIds, amounts, seller, msg.sender, priceCalculator, totalPrice);\\r\\n    }\\r\\n\\r\\n    function cancelSingleAuction(\\r\\n        address tokenAddress,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount,\\r\\n        uint256 listOn,\\r\\n        uint256 startingPrice,\\r\\n        address priceCalculator,\\r\\n        address payable seller\\r\\n    ) external whenPaused {\\r\\n        require(msg.sender == seller, \\\"DroppingNowMarketplace: only auction seller can cancel\\\");\\r\\n\\r\\n        _cancelSingleAuction(tokenAddress, tokenId, amount, listOn, startingPrice, priceCalculator, seller);\\r\\n    }\\r\\n\\r\\n    function ownerCancelSingleAuction(\\r\\n        address tokenAddress,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount,\\r\\n        uint256 listOn,\\r\\n        uint256 startingPrice,\\r\\n        address priceCalculator,\\r\\n        address payable seller\\r\\n    ) external onlyOwner {\\r\\n        _cancelSingleAuction(tokenAddress, tokenId, amount, listOn, startingPrice, priceCalculator, seller);\\r\\n    }\\r\\n\\r\\n    function cancelBundleAuction(\\r\\n        address tokenAddress,\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint256[] calldata amounts,\\r\\n        uint256 listOn,\\r\\n        uint256 startingPrice,\\r\\n        address priceCalculator,\\r\\n        address payable seller\\r\\n    ) external whenPaused {\\r\\n        require(msg.sender == seller, \\\"DroppingNowMarketplace: only auction seller can cancel\\\");\\r\\n\\r\\n        _cancelBundleAuction(tokenAddress, tokenIds, amounts, listOn, startingPrice, priceCalculator, seller);\\r\\n    }\\r\\n\\r\\n    function ownerCancelBundleAuction(\\r\\n        address tokenAddress,\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint256[] calldata amounts,\\r\\n        uint256 listOn,\\r\\n        uint256 startingPrice,\\r\\n        address priceCalculator,\\r\\n        address payable seller\\r\\n    ) external onlyOwner {\\r\\n        _cancelBundleAuction(tokenAddress, tokenIds, amounts, listOn, startingPrice, priceCalculator, seller);\\r\\n    }\\r\\n\\r\\n    function setTokenManagerSelector(address newTokenManagerSelector) external onlyOwner {\\r\\n        require(newTokenManagerSelector != address(0), \\\"DroppingNowMarketplace: address cannot be null\\\");\\r\\n        tokenManagerSelector = ITokenManagerSelector(newTokenManagerSelector);\\r\\n        emit NewTokenManagerSelector(newTokenManagerSelector);\\r\\n    }\\r\\n\\r\\n    function setPriceCalculatorManager(address newPriceCalculatorManager) external onlyOwner {\\r\\n        require(newPriceCalculatorManager != address(0), \\\"DroppingNowMarketplace: address cannot be null\\\");\\r\\n        priceCalculatorManager = IPriceCalculatorManager(newPriceCalculatorManager);\\r\\n        emit NewPriceCalculatorManager(newPriceCalculatorManager);\\r\\n    }\\r\\n\\r\\n    function setDroppingNowToken(address newDroppingNowToken) external onlyOwner {\\r\\n        require(newDroppingNowToken != address(0), \\\"DroppingNowMarketplace: address cannot be null\\\");\\r\\n        droppingNowToken = IDroppingNowToken(newDroppingNowToken);\\r\\n        emit NewDroppingNowToken(newDroppingNowToken);\\r\\n    }\\r\\n\\r\\n    function setDropperToken(address newDropperToken) external onlyOwner {\\r\\n        require(newDropperToken != address(0), \\\"DroppingNowMarketplace: address cannot be null\\\");\\r\\n        dropperToken = IDropperToken(newDropperToken);\\r\\n        emit NewDropperToken(newDropperToken);\\r\\n    }\\r\\n\\r\\n    function setSaleRewardRecipient(address newSaleRewardRecipient) external onlyOwner {\\r\\n        require(newSaleRewardRecipient != address(0), \\\"DroppingNowMarketplace: address cannot be null\\\");\\r\\n        saleRewardRecipient = newSaleRewardRecipient;\\r\\n        emit NewSaleRewardRecepient(newSaleRewardRecipient);\\r\\n    }\\r\\n\\r\\n    function setDropRewardRecipient(address newDropRewardRecipient) external onlyOwner {\\r\\n        require(newDropRewardRecipient != address(0), \\\"DroppingNowMarketplace: address cannot be null\\\");\\r\\n        dropRewardRecipient = newDropRewardRecipient;\\r\\n        emit NewDropRewardRecepient(newDropRewardRecipient);\\r\\n    }\\r\\n\\r\\n    function setDropRewardEscrowRecipient(address newDropRewardEscrowRecipient) external onlyOwner {\\r\\n        require(newDropRewardEscrowRecipient != address(0), \\\"DroppingNowMarketplace: address cannot be null\\\");\\r\\n        dropRewardEscrowRecipient = newDropRewardEscrowRecipient;\\r\\n        emit NewDropRewardEscrowRecepient(newDropRewardEscrowRecipient);\\r\\n    }\\r\\n    \\r\\n    function setDropperFee(uint256 newDropperFee) external onlyOwner {\\r\\n        require(newDropperFee >= 0 && newDropperFee <= 10000, \\\"DroppingNowMarketplace: fee must be between 0 and 10000\\\");\\r\\n        dropperFee = newDropperFee;\\r\\n        emit NewDropperFee(newDropperFee);\\r\\n    }\\r\\n\\r\\n    function setMarketplaceFee(uint256 newMarketplaceFee) external onlyOwner {\\r\\n        require(newMarketplaceFee >= 0 && newMarketplaceFee <= 10000, \\\"DroppingNowMarketplace: fee must be between 0 and 10000\\\");\\r\\n        marketplaceFee = newMarketplaceFee;\\r\\n        emit NewMarketplaceFee(newMarketplaceFee);\\r\\n    }\\r\\n\\r\\n    function setMinItemPriceForDN(uint256 newMinItemPriceForDN) external onlyOwner {\\r\\n        minItemPriceForDN = newMinItemPriceForDN;\\r\\n        emit NewMinItemPriceForDN(newMinItemPriceForDN);\\r\\n    }\\r\\n\\r\\n    function isAuctionAvailable(bytes32 auctionHash) external view returns (bool) {\\r\\n        return _auctions[auctionHash];\\r\\n    }\\r\\n\\r\\n    function _createSingleAuction(\\r\\n        address tokenAddress,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount,\\r\\n        uint256 listOn,\\r\\n        uint256 startingPrice,\\r\\n        address priceCalculator,\\r\\n        string calldata description\\r\\n    ) internal {\\r\\n        if (listOn < block.timestamp) {\\r\\n            listOn = block.timestamp;\\r\\n        }\\r\\n\\r\\n        require(listOn < (block.timestamp + 30 days), \\\"DroppingNowMarketplace: cannot be listed later than 30 days\\\");\\r\\n        require(priceCalculatorManager.isCalculatorAllowed(priceCalculator), \\\"DroppingNowMarketplace: calculator is not allowed\\\");\\r\\n        require(IPriceCalculator(priceCalculator).isPriceAllowed(startingPrice), \\\"DroppingNowMarketplace: price is not allowed\\\");\\r\\n\\r\\n        uint256 amountEscrow = _escrowToken(msg.sender, tokenAddress, tokenId, amount);\\r\\n\\r\\n        bytes32 auctionHash = HashHelper.singleAuctionHash(\\r\\n            tokenAddress,\\r\\n            tokenId,\\r\\n            amountEscrow, \\r\\n            listOn,\\r\\n            startingPrice,\\r\\n            priceCalculator,\\r\\n            msg.sender,\\r\\n            DOMAIN_SEPARATOR);\\r\\n        _auctions[auctionHash] = true;\\r\\n\\r\\n        emit SingleAuctionCreated(\\r\\n            auctionHash,\\r\\n            tokenAddress,\\r\\n            tokenId,\\r\\n            amountEscrow,\\r\\n            msg.sender,\\r\\n            listOn,\\r\\n            startingPrice,\\r\\n            priceCalculator,\\r\\n            description);\\r\\n    }\\r\\n\\r\\n    function _cancelSingleAuction(\\r\\n        address tokenAddress,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount,\\r\\n        uint256 listOn,\\r\\n        uint256 startingPrice,\\r\\n        address priceCalculator,\\r\\n        address payable seller\\r\\n    ) internal {\\r\\n        bytes32 auctionHash = HashHelper.singleAuctionHash(\\r\\n            tokenAddress,\\r\\n            tokenId,\\r\\n            amount,\\r\\n            listOn,\\r\\n            startingPrice, \\r\\n            priceCalculator,\\r\\n            seller,\\r\\n            DOMAIN_SEPARATOR);\\r\\n        require(_auctions[auctionHash] == true, \\\"DroppingNowMarketplace: is not on auction\\\");\\r\\n\\r\\n        _auctions[auctionHash] = false;\\r\\n\\r\\n        _withdrawToken(seller, tokenAddress, tokenId, amount);\\r\\n\\r\\n        emit SingleAuctionCanceled(auctionHash, tokenAddress, tokenId, amount, seller, priceCalculator);\\r\\n    }\\r\\n\\r\\n    function _cancelBundleAuction(\\r\\n        address tokenAddress,\\r\\n        uint256[] calldata tokenIds,\\r\\n        uint256[] calldata amounts,\\r\\n        uint256 listOn,\\r\\n        uint256 startingPrice,\\r\\n        address priceCalculator,\\r\\n        address payable seller\\r\\n    ) internal {\\r\\n        bytes32 auctionHash = HashHelper.bundleAuctionHash(\\r\\n            tokenAddress,\\r\\n            tokenIds,\\r\\n            amounts,\\r\\n            listOn,\\r\\n            startingPrice,\\r\\n            priceCalculator,\\r\\n            seller,\\r\\n            DOMAIN_SEPARATOR);\\r\\n        require(_auctions[auctionHash] == true, \\\"DroppingNowMarketplace: is not on auction\\\");\\r\\n\\r\\n        _auctions[auctionHash] = false;\\r\\n\\r\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\r\\n            _withdrawToken(seller, tokenAddress, tokenIds[i], amounts[i]);\\r\\n        }\\r\\n\\r\\n        emit BundleAuctionCanceled(auctionHash, tokenAddress, tokenIds, amounts, seller, priceCalculator);\\r\\n    }\\r\\n\\r\\n    function _escrowToken(\\r\\n        address seller, \\r\\n        address tokenAddress, \\r\\n        uint256 tokenId, \\r\\n        uint256 amount\\r\\n    ) internal returns (uint256) {\\r\\n        address tokenManager = _getTokenManager(tokenAddress);\\r\\n        uint256 amountDeposit = ITokenManager(tokenManager).deposit(seller, tokenAddress, tokenId, amount);\\r\\n        return amountDeposit;\\r\\n    }\\r\\n\\r\\n    function _withdrawToken(\\r\\n        address buyer, \\r\\n        address tokenAddress, \\r\\n        uint256 tokenId, \\r\\n        uint256 amount\\r\\n    ) internal returns (uint256) {\\r\\n        address tokenManager = _getTokenManager(tokenAddress);\\r\\n        uint256 amountWithdraw = ITokenManager(tokenManager).withdraw(buyer, tokenAddress, tokenId, amount);\\r\\n        return amountWithdraw;\\r\\n    }\\r\\n\\r\\n    function _getTokenManager(address tokenAddress) internal view returns (address) {\\r\\n        address tokenManager = tokenManagerSelector.getManagerAddress(tokenAddress);\\r\\n        require(tokenManager != address(0), \\\"DroppingNowMarketplace: no token manager available\\\");\\r\\n        return tokenManager;\\r\\n    }\\r\\n\\r\\n    function _payDropperFee(\\r\\n        address tokenAddress,\\r\\n        uint256 amount,\\r\\n        uint256 totalPrice\\r\\n    ) internal returns(uint256) {\\r\\n        if (amount != 0) {\\r\\n            // ERC-1155 is not a subject for dropper fees\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 dropperFeeValue = totalPrice * dropperFee / 10000;\\r\\n        try dropperToken.addReward{value: dropperFeeValue}(tokenAddress) {\\r\\n            return dropperFeeValue;\\r\\n        } catch {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _dropReward (\\r\\n        address seller,\\r\\n        address tokenAddress,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        if (amount != 0) {\\r\\n            // ERC-1155 is not a subject for dropper rewards\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        address[] memory recipients = _getDropRewardRecipients(seller, tokenAddress);\\r\\n        uint256[] memory amounts = _getDropRewardAmounts();\\r\\n        dropperToken.tryAddMintable(recipients, amounts, tokenAddress, tokenId);\\r\\n    }\\r\\n\\r\\n    function _dropRewardBundle (\\r\\n        address seller,\\r\\n        address tokenAddress,\\r\\n        uint256[] memory tokenIds,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        if (amount != 0) {\\r\\n            // ERC-1155 is not a subject for dropper rewards\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        address[] memory recipients = _getDropRewardRecipients(seller, tokenAddress);\\r\\n        uint256[] memory amounts = _getDropRewardAmounts();\\r\\n        dropperToken.tryAddMintableBatch(recipients, amounts, tokenAddress, tokenIds);\\r\\n    }\\r\\n\\r\\n    function _payMarketplaceFee(\\r\\n        uint256 totalPrice\\r\\n    ) internal returns(uint256) {\\r\\n        uint256 marketplaceFeeValue = totalPrice * marketplaceFee / 10000;\\r\\n        try droppingNowToken.addReward{value: marketplaceFeeValue}() {\\r\\n            return marketplaceFeeValue;\\r\\n        } catch {\\r\\n            return 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _saleReward (address seller, address tokenAddress, uint256 tokensLength, uint256 totalPrice) internal {\\r\\n        uint256 rewardableTokensLength = totalPrice / minItemPriceForDN;\\r\\n        if (rewardableTokensLength > tokensLength) {\\r\\n            rewardableTokensLength = tokensLength;\\r\\n        }\\r\\n\\r\\n        if (rewardableTokensLength == 0) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        bool isApproved = collectionsRegistry.isCollectionApproved(tokenAddress);\\r\\n        address owner;\\r\\n        bool ownerHasCorrectAddressAndApproved;\\r\\n        if (isApproved) {\\r\\n            owner = Ownable(tokenAddress).owner();\\r\\n            ownerHasCorrectAddressAndApproved = isApproved && owner != address(0);\\r\\n        }\\r\\n\\r\\n        uint256 arraySize = 2;\\r\\n        if (ownerHasCorrectAddressAndApproved) {\\r\\n            arraySize = 3;\\r\\n        }\\r\\n\\r\\n        address[] memory recipients = new address[](arraySize);\\r\\n        recipients[0] = seller;\\r\\n        recipients[1] = saleRewardRecipient;\\r\\n\\r\\n        uint256[] memory amounts = new uint256[](arraySize);\\r\\n        amounts[0] = 10 * rewardableTokensLength;\\r\\n        amounts[1] = 10 * rewardableTokensLength;\\r\\n        \\r\\n        if (ownerHasCorrectAddressAndApproved) {\\r\\n            recipients[2] = owner;\\r\\n            amounts[1] = 5 * rewardableTokensLength;\\r\\n            amounts[2] = 5 * rewardableTokensLength;\\r\\n        }\\r\\n        \\r\\n        droppingNowToken.addMintable(recipients, amounts);\\r\\n    }\\r\\n\\r\\n    function _getDropRewardRecipients (\\r\\n        address seller,\\r\\n        address tokenAddress\\r\\n    ) internal view returns (address[] memory) {\\r\\n        address[] memory recipients = new address[](3);\\r\\n        recipients[0] = seller;\\r\\n        recipients[1] = dropRewardRecipient;\\r\\n        recipients[2] = dropRewardEscrowRecipient;\\r\\n\\r\\n        if (collectionsRegistry.isCollectionApproved(tokenAddress)) {\\r\\n            address owner = Ownable(tokenAddress).owner();\\r\\n            if (owner != address(0)) {\\r\\n                recipients[2] = owner;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return recipients;\\r\\n    }\\r\\n\\r\\n    function _getDropRewardAmounts() internal pure returns (uint256[] memory) {\\r\\n        uint256[] memory amounts = new uint256[](3);\\r\\n        amounts[0] = 2;\\r\\n        amounts[1] = 1;\\r\\n        amounts[2] = 1;\\r\\n\\r\\n        return amounts;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenManagerSelector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.2;\\r\\n\\r\\ninterface ITokenManagerSelector {\\r\\n    function getManagerAddress(address tokenAddress) external view returns (address);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPriceCalculatorManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.2;\\r\\n\\r\\ninterface IPriceCalculatorManager {\\r\\n    function addCalculator(address calculator) external;\\r\\n\\r\\n    function removeCalculator(address calculator) external;\\r\\n\\r\\n    function isCalculatorAllowed(address calculator) external view returns (bool);\\r\\n\\r\\n    function viewAllowedCalculators(uint256 cursor, uint256 size) external view returns (address[] memory, uint256);\\r\\n\\r\\n    function viewCountAllowedCalculators() external view returns (uint256);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITokenManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.2;\\r\\n\\r\\ninterface ITokenManager {\\r\\n    function deposit(\\r\\n        address from,\\r\\n        address tokenAddress,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function withdraw(\\r\\n        address to,\\r\\n        address tokenAddress,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount\\r\\n    ) external returns (uint256);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPriceCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.2;\\r\\n\\r\\ninterface IPriceCalculator {\\r\\n    function calculatePrice(\\r\\n        uint256 startingPrice,\\r\\n        uint256 listedOn,\\r\\n        uint256 time\\r\\n    ) external pure returns (uint256);\\r\\n\\r\\n    function calculateCurrentPrice(\\r\\n        uint256 startingPrice,\\r\\n        uint256 listedOn\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function isPriceAllowed(\\r\\n        uint256 startingPrice\\r\\n    ) external pure returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/ICollectionsRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.2;\\n\\ninterface ICollectionsRegistry {\\n    function isCollectionApproved(address collectionAddress) external view returns(bool);\\n\\n    function approveCollection(address tokenAddress) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDroppingNowToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.2;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IDroppingNowToken is IERC20 {\\r\\n    function addMintable(address[] memory to, uint256[] memory amounts) external;\\r\\n\\r\\n    function addReward() external payable;\\r\\n\\r\\n    function claimReward() external;\\r\\n\\r\\n    function claimTokens() external;\\r\\n\\r\\n    function rewardBalanceOf(address owner) external view returns (uint256);\\r\\n\\r\\n    function mintableBalanceOf(address owner) external view returns (uint256);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDropperToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.2;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\r\\n\\r\\ninterface IDropperToken is IERC1155 {\\r\\n    function tryAddMintable(address[] memory to, uint256[] memory amounts, address tokenAddress, uint256 tokenId) external;\\r\\n\\r\\n    function tryAddMintableBatch(address[] memory to, uint256[] memory amounts, address tokenAddress, uint256[] memory tokenIds) external;\\r\\n\\r\\n    function addReward(address tokenAddress) external payable;\\r\\n\\r\\n    function claimRewardBatch(uint256[] calldata ids) external;\\r\\n\\r\\n    function claimTokens(uint256 id) external;\\r\\n\\r\\n    function claimTokensBatch(uint256[] calldata ids) external;\\r\\n\\r\\n    function getId(address tokenAddress) external view returns (uint256);\\r\\n\\r\\n    function mintableBalanceOf(address owner, uint256 id) external view returns (uint256);\\r\\n}\"\r\n    },\r\n    \"contracts/libraries/HashHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.2;\\r\\n\\r\\nlibrary HashHelper {\\r\\n    // keccak256(\\\"SingleItemAuction(address tokenAddress,uint256 tokenId,uint256 amount,uint256 listOn,uint256 startingPrice,address priceCalculator,address seller)\\\")\\r\\n    bytes32 internal constant SINGLE_ITEM_AUCTION_HASH = 0x690efce55f6873cc2cf4903c21f626dea40a056811d11e48e991e5e2c7b2e1f4;\\r\\n\\r\\n    // keccak256(\\\"BundleAuction(address tokenAddress,uint256[] tokenIds,uint256[] amounts,uint256 listOn,uint256 startingPrice,address priceCalculator,address seller)\\\")\\r\\n    bytes32 internal constant BUNDLE_AUCTION_HASH = 0x4a8431ddb4840ad14978d81bf98f5b14f5bc0f9306fab2c4c72c2e01593ad2db;\\r\\n\\r\\n    function singleAuctionHash(\\r\\n        address tokenAddress,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount,\\r\\n        uint256 listOn,\\r\\n        uint256 startingPrice,\\r\\n        address priceCalculator,\\r\\n        address seller,\\r\\n        bytes32 domain) internal pure returns (bytes32) {\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encode(\\r\\n                    domain,\\r\\n                    SINGLE_ITEM_AUCTION_HASH,\\r\\n                    tokenAddress,\\r\\n                    tokenId,\\r\\n                    amount,\\r\\n                    listOn,\\r\\n                    startingPrice,\\r\\n                    priceCalculator,\\r\\n                    seller\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function bundleAuctionHash(\\r\\n        address tokenAddress,\\r\\n        uint256[] memory tokenIds,\\r\\n        uint256[] memory amounts,\\r\\n        uint256 listOn,\\r\\n        uint256 startingPrice,\\r\\n        address priceCalculator,\\r\\n        address seller,\\r\\n        bytes32 domain) internal pure returns (bytes32) {\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encode(\\r\\n                    domain,\\r\\n                    BUNDLE_AUCTION_HASH,\\r\\n                    tokenAddress,\\r\\n                    tokenIds,\\r\\n                    amounts,\\r\\n                    listOn,\\r\\n                    startingPrice,\\r\\n                    priceCalculator,\\r\\n                    seller\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenManagerSelectorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"priceCalculatorManagerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"droppingNowTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dropperTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collectionsRegistryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"saleRewardRecipientAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dropRewardRecipientAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dropRewardEscrowRecipientAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dropperFeeValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketplaceFeeValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minItemPriceForDNValue\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"auctionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"priceCalculator\",\"type\":\"address\"}],\"name\":\"BundleAuctionCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"auctionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listOn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"priceCalculator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"BundleAuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"auctionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"priceCalculator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"BundleSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dropRewardEscrowRecepient\",\"type\":\"address\"}],\"name\":\"NewDropRewardEscrowRecepient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dropRewardRecepient\",\"type\":\"address\"}],\"name\":\"NewDropRewardRecepient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dropperFee\",\"type\":\"uint256\"}],\"name\":\"NewDropperFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dropperToken\",\"type\":\"address\"}],\"name\":\"NewDropperToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"droppingNowToken\",\"type\":\"address\"}],\"name\":\"NewDroppingNowToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketplaceFee\",\"type\":\"uint256\"}],\"name\":\"NewMarketplaceFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minItemPriceForDN\",\"type\":\"uint256\"}],\"name\":\"NewMinItemPriceForDN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"priceCalculatorManager\",\"type\":\"address\"}],\"name\":\"NewPriceCalculatorManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"saleRewardRecepient\",\"type\":\"address\"}],\"name\":\"NewSaleRewardRecepient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenManagerSelector\",\"type\":\"address\"}],\"name\":\"NewTokenManagerSelector\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"auctionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"priceCalculator\",\"type\":\"address\"}],\"name\":\"SingleAuctionCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"auctionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listOn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"priceCalculator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"SingleAuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"auctionHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"priceCalculator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"SingleSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"listOn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"priceCalculator\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"buyBundleAuction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listOn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"priceCalculator\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"buySingleAuction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"listOn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"priceCalculator\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"cancelBundleAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listOn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"priceCalculator\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"cancelSingleAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectionsRegistry\",\"outputs\":[{\"internalType\":\"contract ICollectionsRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"listOn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"priceCalculator\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"createBundleAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"listOns\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"startingPrices\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"priceCalculators\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"descriptions\",\"type\":\"string[]\"}],\"name\":\"createMultipleSingleAuctions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listOn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"priceCalculator\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"createSingleAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropRewardEscrowRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropRewardRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropperFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropperToken\",\"outputs\":[{\"internalType\":\"contract IDropperToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"droppingNowToken\",\"outputs\":[{\"internalType\":\"contract IDroppingNowToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"auctionHash\",\"type\":\"bytes32\"}],\"name\":\"isAuctionAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketplaceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minItemPriceForDN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"listOn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"priceCalculator\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"ownerCancelBundleAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listOn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"priceCalculator\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"ownerCancelSingleAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceCalculatorManager\",\"outputs\":[{\"internalType\":\"contract IPriceCalculatorManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleRewardRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDropRewardEscrowRecipient\",\"type\":\"address\"}],\"name\":\"setDropRewardEscrowRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDropRewardRecipient\",\"type\":\"address\"}],\"name\":\"setDropRewardRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDropperFee\",\"type\":\"uint256\"}],\"name\":\"setDropperFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDropperToken\",\"type\":\"address\"}],\"name\":\"setDropperToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDroppingNowToken\",\"type\":\"address\"}],\"name\":\"setDroppingNowToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMarketplaceFee\",\"type\":\"uint256\"}],\"name\":\"setMarketplaceFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinItemPriceForDN\",\"type\":\"uint256\"}],\"name\":\"setMinItemPriceForDN\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPriceCalculatorManager\",\"type\":\"address\"}],\"name\":\"setPriceCalculatorManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSaleRewardRecipient\",\"type\":\"address\"}],\"name\":\"setSaleRewardRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTokenManagerSelector\",\"type\":\"address\"}],\"name\":\"setTokenManagerSelector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenManagerSelector\",\"outputs\":[{\"internalType\":\"contract ITokenManagerSelector\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DroppingNowMarketplace", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000002066d53f87071eae184610b4b355d14589abe8f400000000000000000000000024f48d281b3a906d94c878abfdeacdfd693a76dc0000000000000000000000004e17f9b784bc23c1364612ee94537902d6b8a4a50000000000000000000000006cca5f4f85bd9eb79189c15b87ca480d57e27490000000000000000000000000181f3ef73a7cc30ea7de412b1350a17368e549ed000000000000000000000000c41e6f19eb7751345cd2ec2d1e8884e82cefb8b5000000000000000000000000c41e6f19eb7751345cd2ec2d1e8884e82cefb8b500000000000000000000000016e5f1fba1bde80d35f40d419466bf25dd372a5600000000000000000000000000000000000000000000000000000000000000fa00000000000000000000000000000000000000000000000000000000000000fa000000000000000000000000000000000000000000000000006a94d74f430000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}