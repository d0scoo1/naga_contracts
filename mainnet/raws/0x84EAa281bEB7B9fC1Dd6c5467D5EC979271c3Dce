{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/verifier/TurboVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Bn254Crypto} from './cryptography/Bn254Crypto.sol';\\nimport {PolynomialEval} from './cryptography/PolynomialEval.sol';\\nimport {Types} from './cryptography/Types.sol';\\nimport {VerificationKeys} from './keys/VerificationKeys.sol';\\nimport {Transcript} from './cryptography/Transcript.sol';\\nimport {IVerifier} from '../interfaces/IVerifier.sol';\\n\\n/**\\n * @title Turbo Plonk proof verification contract\\n * @dev Top level Plonk proof verification contract, which allows Plonk proof to be verified\\n *\\n * Copyright 2020 Spilsbury Holdings Ltd\\n *\\n * Licensed under the GNU General Public License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n *\\n * This program is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n * GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n */\\ncontract TurboVerifier is IVerifier {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n    using Transcript for Transcript.TranscriptData;\\n\\n    /**\\n     * @dev Verify a Plonk proof\\n     * @param - array of serialized proof data\\n     * @param rollup_size - number of transactions in the rollup\\n     */\\n    function verify(bytes calldata, uint256 rollup_size) external override {\\n        // extract the correct rollup verification key\\n        Types.VerificationKey memory vk = VerificationKeys.getKeyById(rollup_size);\\n        uint256 num_public_inputs = vk.num_inputs;\\n\\n        // parse the input calldata and construct a Proof object\\n        Types.Proof memory decoded_proof = deserialize_proof(num_public_inputs, vk);\\n\\n        Transcript.TranscriptData memory transcript;\\n        transcript.generate_initial_challenge(vk.circuit_size, vk.num_inputs);\\n\\n        // reconstruct the beta, gamma, alpha and zeta challenges\\n        Types.ChallengeTranscript memory challenges;\\n        transcript.generate_beta_gamma_challenges(challenges, vk.num_inputs);\\n        transcript.generate_alpha_challenge(challenges, decoded_proof.Z);\\n        transcript.generate_zeta_challenge(challenges, decoded_proof.T1, decoded_proof.T2, decoded_proof.T3, decoded_proof.T4);\\n\\n        /**\\n         * Compute all inverses that will be needed throughout the program here.\\n         *\\n         * This is an efficiency improvement - it allows us to make use of the batch inversion Montgomery trick,\\n         * which allows all inversions to be replaced with one inversion operation, at the expense of a few\\n         * additional multiplications\\n         **/\\n        (uint256 quotient_eval, uint256 L1) = evalaute_field_operations(decoded_proof, vk, challenges);\\n        decoded_proof.quotient_polynomial_eval = quotient_eval;\\n\\n        // reconstruct the nu and u challenges\\n        transcript.generate_nu_challenges(challenges, decoded_proof.quotient_polynomial_eval, vk.num_inputs);\\n        transcript.generate_separator_challenge(challenges, decoded_proof.PI_Z, decoded_proof.PI_Z_OMEGA);\\n\\n        //reset 'alpha base'\\n        challenges.alpha_base = challenges.alpha;\\n\\n        Types.G1Point memory linearised_contribution = PolynomialEval.compute_linearised_opening_terms(\\n            challenges,\\n            L1,\\n            vk,\\n            decoded_proof\\n        );\\n\\n        Types.G1Point memory batch_opening_commitment = PolynomialEval.compute_batch_opening_commitment(\\n            challenges,\\n            vk,\\n            linearised_contribution,\\n            decoded_proof\\n        );\\n\\n        uint256 batch_evaluation_g1_scalar = PolynomialEval.compute_batch_evaluation_scalar_multiplier(\\n            decoded_proof,\\n            challenges\\n        );\\n\\n        bool result = perform_pairing(\\n            batch_opening_commitment,\\n            batch_evaluation_g1_scalar,\\n            challenges,\\n            decoded_proof,\\n            vk\\n        );\\n        require(result, 'Proof failed');\\n    }\\n\\n\\n    /**\\n     * @dev Compute partial state of the verifier, specifically: public input delta evaluation, zero polynomial\\n     * evaluation, the lagrange evaluations and the quotient polynomial evaluations\\n     *\\n     * Note: This uses the batch inversion Montgomery trick to reduce the number of\\n     * inversions, and therefore the number of calls to the bn128 modular exponentiation\\n     * precompile.\\n     *\\n     * Specifically, each function call: compute_public_input_delta() etc. at some point needs to invert a\\n     * value to calculate a denominator in a fraction. Instead of performing this inversion as it is needed, we\\n     * instead 'save up' the denominator calculations. The inputs to this are returned from the various functions\\n     * and then we perform all necessary inversions in one go at the end of `evalaute_field_operations()`. This\\n     * gives us the various variables that need to be returned.\\n     *\\n     * @param decoded_proof - deserialised proof\\n     * @param vk - verification key\\n     * @param challenges - all challenges (alpha, beta, gamma, zeta, nu[NUM_NU_CHALLENGES], u) stored in\\n     * ChallengeTranscript struct form\\n     * @return quotient polynomial evaluation (field element) and lagrange 1 evaluation (field element)\\n     */\\n    function evalaute_field_operations(\\n        Types.Proof memory decoded_proof,\\n        Types.VerificationKey memory vk,\\n        Types.ChallengeTranscript memory challenges\\n    ) internal view returns (uint256, uint256) {\\n        uint256 public_input_delta;\\n        uint256 zero_polynomial_eval;\\n        uint256 l_start;\\n        uint256 l_end;\\n        {\\n            (uint256 public_input_numerator, uint256 public_input_denominator) = PolynomialEval.compute_public_input_delta(\\n                challenges,\\n                vk\\n            );\\n\\n            (\\n                uint256 vanishing_numerator,\\n                uint256 vanishing_denominator,\\n                uint256 lagrange_numerator,\\n                uint256 l_start_denominator,\\n                uint256 l_end_denominator\\n            ) = PolynomialEval.compute_lagrange_and_vanishing_fractions(vk, challenges.zeta);\\n\\n\\n            (zero_polynomial_eval, public_input_delta, l_start, l_end) = PolynomialEval.compute_batch_inversions(\\n                public_input_numerator,\\n                public_input_denominator,\\n                vanishing_numerator,\\n                vanishing_denominator,\\n                lagrange_numerator,\\n                l_start_denominator,\\n                l_end_denominator\\n            );\\n        }\\n\\n        uint256 quotient_eval = PolynomialEval.compute_quotient_polynomial(\\n            zero_polynomial_eval,\\n            public_input_delta,\\n            challenges,\\n            l_start,\\n            l_end,\\n            decoded_proof\\n        );\\n\\n        return (quotient_eval, l_start);\\n    }\\n\\n\\n    /**\\n     * @dev Perform the pairing check\\n     * @param batch_opening_commitment - G1 point representing the calculated batch opening commitment\\n     * @param batch_evaluation_g1_scalar - uint256 representing the batch evaluation scalar multiplier to be applied to the G1 generator point\\n     * @param challenges - all challenges (alpha, beta, gamma, zeta, nu[NUM_NU_CHALLENGES], u) stored in\\n     * ChallengeTranscript struct form\\n     * @param vk - verification key\\n     * @param decoded_proof - deserialised proof\\n     * @return bool specifying whether the pairing check was successful\\n     */\\n    function perform_pairing(\\n        Types.G1Point memory batch_opening_commitment,\\n        uint256 batch_evaluation_g1_scalar,\\n        Types.ChallengeTranscript memory challenges,\\n        Types.Proof memory decoded_proof,\\n        Types.VerificationKey memory vk\\n    ) internal view returns (bool) {\\n\\n        uint256 u = challenges.u;\\n        bool success;\\n        uint256 p = Bn254Crypto.r_mod;\\n        Types.G1Point memory rhs;     \\n        Types.G1Point memory PI_Z_OMEGA = decoded_proof.PI_Z_OMEGA;\\n        Types.G1Point memory PI_Z = decoded_proof.PI_Z;\\n        PI_Z.validateG1Point();\\n        PI_Z_OMEGA.validateG1Point();\\n    \\n        // rhs = zeta.[PI_Z] + u.zeta.omega.[PI_Z_OMEGA] + [batch_opening_commitment] - batch_evaluation_g1_scalar.[1]\\n        // scope this block to prevent stack depth errors\\n        {\\n            uint256 zeta = challenges.zeta;\\n            uint256 pi_z_omega_scalar = vk.work_root;\\n            assembly {\\n                pi_z_omega_scalar := mulmod(pi_z_omega_scalar, zeta, p)\\n                pi_z_omega_scalar := mulmod(pi_z_omega_scalar, u, p)\\n                batch_evaluation_g1_scalar := sub(p, batch_evaluation_g1_scalar)\\n\\n                // store accumulator point at mptr\\n                let mPtr := mload(0x40)\\n\\n                // set accumulator = batch_opening_commitment\\n                mstore(mPtr, mload(batch_opening_commitment))\\n                mstore(add(mPtr, 0x20), mload(add(batch_opening_commitment, 0x20)))\\n\\n                // compute zeta.[PI_Z] and add into accumulator\\n                mstore(add(mPtr, 0x40), mload(PI_Z))\\n                mstore(add(mPtr, 0x60), mload(add(PI_Z, 0x20)))\\n                mstore(add(mPtr, 0x80), zeta)\\n                success := staticcall(gas(), 7, add(mPtr, 0x40), 0x60, add(mPtr, 0x40), 0x40)\\n                success := and(success, staticcall(gas(), 6, mPtr, 0x80, mPtr, 0x40))\\n\\n                // compute u.zeta.omega.[PI_Z_OMEGA] and add into accumulator\\n                mstore(add(mPtr, 0x40), mload(PI_Z_OMEGA))\\n                mstore(add(mPtr, 0x60), mload(add(PI_Z_OMEGA, 0x20)))\\n                mstore(add(mPtr, 0x80), pi_z_omega_scalar)\\n                success := and(success, staticcall(gas(), 7, add(mPtr, 0x40), 0x60, add(mPtr, 0x40), 0x40))\\n                success := and(success, staticcall(gas(), 6, mPtr, 0x80, mPtr, 0x40))\\n\\n                // compute -batch_evaluation_g1_scalar.[1]\\n                mstore(add(mPtr, 0x40), 0x01) // hardcoded generator point (1, 2)\\n                mstore(add(mPtr, 0x60), 0x02)\\n                mstore(add(mPtr, 0x80), batch_evaluation_g1_scalar)\\n                success := and(success, staticcall(gas(), 7, add(mPtr, 0x40), 0x60, add(mPtr, 0x40), 0x40))\\n\\n                // add -batch_evaluation_g1_scalar.[1] and the accumulator point, write result into rhs\\n                success := and(success, staticcall(gas(), 6, mPtr, 0x80, rhs, 0x40))\\n            }\\n        }\\n\\n        Types.G1Point memory lhs;   \\n        assembly {\\n            // store accumulator point at mptr\\n            let mPtr := mload(0x40)\\n\\n            // copy [PI_Z] into mPtr\\n            mstore(mPtr, mload(PI_Z))\\n            mstore(add(mPtr, 0x20), mload(add(PI_Z, 0x20)))\\n\\n            // compute u.[PI_Z_OMEGA] and write to (mPtr + 0x40)\\n            mstore(add(mPtr, 0x40), mload(PI_Z_OMEGA))\\n            mstore(add(mPtr, 0x60), mload(add(PI_Z_OMEGA, 0x20)))\\n            mstore(add(mPtr, 0x80), u)\\n            success := and(success, staticcall(gas(), 7, add(mPtr, 0x40), 0x60, add(mPtr, 0x40), 0x40))\\n            \\n            // add [PI_Z] + u.[PI_Z_OMEGA] and write result into lhs\\n            success := and(success, staticcall(gas(), 6, mPtr, 0x80, lhs, 0x40))\\n        }\\n\\n        // negate lhs y-coordinate\\n        uint256 q = Bn254Crypto.p_mod;\\n        assembly {\\n            mstore(add(lhs, 0x20), sub(q, mload(add(lhs, 0x20))))\\n        }\\n\\n        if (vk.contains_recursive_proof)\\n        {\\n            // If the proof itself contains an accumulated proof,\\n            // we will have extracted two G1 elements `recursive_P1`, `recursive_p2` from the public inputs\\n\\n            // We need to evaluate that e(recursive_P1, [x]_2) == e(recursive_P2, [1]_2) to finish verifying the inner proof\\n            // We do this by creating a random linear combination between (lhs, recursive_P1) and (rhs, recursivee_P2)\\n            // That way we still only need to evaluate one pairing product\\n\\n            // We use `challenge.u * challenge.u` as the randomness to create a linear combination\\n            // challenge.u is produced by hashing the entire transcript, which contains the public inputs (and by extension the recursive proof)\\n\\n            // i.e. [lhs] = [lhs] + u.u.[recursive_P1]\\n            //      [rhs] = [rhs] + u.u.[recursive_P2]\\n            Types.G1Point memory recursive_P1 = decoded_proof.recursive_P1;\\n            Types.G1Point memory recursive_P2 = decoded_proof.recursive_P2;\\n            recursive_P1.validateG1Point();\\n            recursive_P2.validateG1Point();\\n            assembly {\\n                let mPtr := mload(0x40)\\n\\n                // compute u.u.[recursive_P1]\\n                mstore(mPtr, mload(recursive_P1))\\n                mstore(add(mPtr, 0x20), mload(add(recursive_P1, 0x20)))\\n                mstore(add(mPtr, 0x40), mulmod(u, u, p)) // separator_challenge = u * u\\n                success := and(success, staticcall(gas(), 7, mPtr, 0x60, add(mPtr, 0x60), 0x40))\\n\\n                // compute u.u.[recursive_P2] (u*u is still in memory at (mPtr + 0x40), no need to re-write it)\\n                mstore(mPtr, mload(recursive_P2))\\n                mstore(add(mPtr, 0x20), mload(add(recursive_P2, 0x20)))\\n                success := and(success, staticcall(gas(), 7, mPtr, 0x60, mPtr, 0x40))\\n\\n                // compute u.u.[recursiveP2] + rhs and write into rhs\\n                mstore(add(mPtr, 0xa0), mload(rhs))\\n                mstore(add(mPtr, 0xc0), mload(add(rhs, 0x20)))\\n                success := and(success, staticcall(gas(), 6, add(mPtr, 0x60), 0x80, rhs, 0x40))\\n\\n                // compute u.u.[recursiveP1] + lhs and write into lhs\\n                mstore(add(mPtr, 0x40), mload(lhs))\\n                mstore(add(mPtr, 0x60), mload(add(lhs, 0x20)))\\n                success := and(success, staticcall(gas(), 6, mPtr, 0x80, lhs, 0x40))\\n            }\\n        }\\n\\n        require(success, \\\"perform_pairing G1 operations preamble fail\\\");\\n\\n        return Bn254Crypto.pairingProd2(rhs, Bn254Crypto.P2(), lhs, vk.g2_x);\\n    }\\n\\n    /**\\n     * @dev Deserialize a proof into a Proof struct\\n     * @param num_public_inputs - number of public inputs in the proof. Taken from verification key\\n     * @return proof - proof deserialized into the proof struct\\n     */\\n    function deserialize_proof(uint256 num_public_inputs, Types.VerificationKey memory vk)\\n        internal\\n        pure\\n        returns (Types.Proof memory proof)\\n    {\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 q = Bn254Crypto.p_mod;\\n        uint256 data_ptr;\\n        uint256 proof_ptr;\\n        // first 32 bytes of bytes array contains length, skip it\\n        assembly {\\n            data_ptr := add(calldataload(0x04), 0x24)\\n            proof_ptr := proof\\n        }\\n\\n        if (vk.contains_recursive_proof) {\\n            uint256 index_counter = vk.recursive_proof_indices * 32;\\n            uint256 x0 = 0;\\n            uint256 y0 = 0;\\n            uint256 x1 = 0;\\n            uint256 y1 = 0;\\n            assembly {\\n                index_counter := add(index_counter, data_ptr)\\n                x0 := calldataload(index_counter)\\n                x0 := add(x0, shl(68, calldataload(add(index_counter, 0x20))))\\n                x0 := add(x0, shl(136, calldataload(add(index_counter, 0x40))))\\n                x0 := add(x0, shl(204, calldataload(add(index_counter, 0x60))))\\n                y0 := calldataload(add(index_counter, 0x80))\\n                y0 := add(y0, shl(68, calldataload(add(index_counter, 0xa0))))\\n                y0 := add(y0, shl(136, calldataload(add(index_counter, 0xc0))))\\n                y0 := add(y0, shl(204, calldataload(add(index_counter, 0xe0))))\\n                x1 := calldataload(add(index_counter, 0x100))\\n                x1 := add(x1, shl(68, calldataload(add(index_counter, 0x120))))\\n                x1 := add(x1, shl(136, calldataload(add(index_counter, 0x140))))\\n                x1 := add(x1, shl(204, calldataload(add(index_counter, 0x160))))\\n                y1 := calldataload(add(index_counter, 0x180))\\n                y1 := add(y1, shl(68, calldataload(add(index_counter, 0x1a0))))\\n                y1 := add(y1, shl(136, calldataload(add(index_counter, 0x1c0))))\\n                y1 := add(y1, shl(204, calldataload(add(index_counter, 0x1e0))))\\n            }\\n\\n            proof.recursive_P1 = Bn254Crypto.new_g1(x0, y0);\\n            proof.recursive_P2 = Bn254Crypto.new_g1(x1, y1);\\n        }\\n\\n        assembly {\\n            let public_input_byte_length := mul(num_public_inputs, 0x20)\\n            data_ptr := add(data_ptr, public_input_byte_length)\\n  \\n            // proof.W1\\n            mstore(mload(proof_ptr), mod(calldataload(add(data_ptr, 0x20)), q))\\n            mstore(add(mload(proof_ptr), 0x20), mod(calldataload(data_ptr), q))\\n\\n            // proof.W2\\n            mstore(mload(add(proof_ptr, 0x20)), mod(calldataload(add(data_ptr, 0x60)), q))\\n            mstore(add(mload(add(proof_ptr, 0x20)), 0x20), mod(calldataload(add(data_ptr, 0x40)), q))\\n \\n            // proof.W3\\n            mstore(mload(add(proof_ptr, 0x40)), mod(calldataload(add(data_ptr, 0xa0)), q))\\n            mstore(add(mload(add(proof_ptr, 0x40)), 0x20), mod(calldataload(add(data_ptr, 0x80)), q))\\n\\n            // proof.W4\\n            mstore(mload(add(proof_ptr, 0x60)), mod(calldataload(add(data_ptr, 0xe0)), q))\\n            mstore(add(mload(add(proof_ptr, 0x60)), 0x20), mod(calldataload(add(data_ptr, 0xc0)), q))\\n  \\n            // proof.Z\\n            mstore(mload(add(proof_ptr, 0x80)), mod(calldataload(add(data_ptr, 0x120)), q))\\n            mstore(add(mload(add(proof_ptr, 0x80)), 0x20), mod(calldataload(add(data_ptr, 0x100)), q))\\n  \\n            // proof.T1\\n            mstore(mload(add(proof_ptr, 0xa0)), mod(calldataload(add(data_ptr, 0x160)), q))\\n            mstore(add(mload(add(proof_ptr, 0xa0)), 0x20), mod(calldataload(add(data_ptr, 0x140)), q))\\n\\n            // proof.T2\\n            mstore(mload(add(proof_ptr, 0xc0)), mod(calldataload(add(data_ptr, 0x1a0)), q))\\n            mstore(add(mload(add(proof_ptr, 0xc0)), 0x20), mod(calldataload(add(data_ptr, 0x180)), q))\\n\\n            // proof.T3\\n            mstore(mload(add(proof_ptr, 0xe0)), mod(calldataload(add(data_ptr, 0x1e0)), q))\\n            mstore(add(mload(add(proof_ptr, 0xe0)), 0x20), mod(calldataload(add(data_ptr, 0x1c0)), q))\\n\\n            // proof.T4\\n            mstore(mload(add(proof_ptr, 0x100)), mod(calldataload(add(data_ptr, 0x220)), q))\\n            mstore(add(mload(add(proof_ptr, 0x100)), 0x20), mod(calldataload(add(data_ptr, 0x200)), q))\\n  \\n            // proof.w1 to proof.w4\\n            mstore(add(proof_ptr, 0x120), mod(calldataload(add(data_ptr, 0x240)), p))\\n            mstore(add(proof_ptr, 0x140), mod(calldataload(add(data_ptr, 0x260)), p))\\n            mstore(add(proof_ptr, 0x160), mod(calldataload(add(data_ptr, 0x280)), p))\\n            mstore(add(proof_ptr, 0x180), mod(calldataload(add(data_ptr, 0x2a0)), p))\\n \\n            // proof.sigma1\\n            mstore(add(proof_ptr, 0x1a0), mod(calldataload(add(data_ptr, 0x2c0)), p))\\n\\n            // proof.sigma2\\n            mstore(add(proof_ptr, 0x1c0), mod(calldataload(add(data_ptr, 0x2e0)), p))\\n\\n            // proof.sigma3\\n            mstore(add(proof_ptr, 0x1e0), mod(calldataload(add(data_ptr, 0x300)), p))\\n\\n            // proof.q_arith\\n            mstore(add(proof_ptr, 0x200), mod(calldataload(add(data_ptr, 0x320)), p))\\n\\n            // proof.q_ecc\\n            mstore(add(proof_ptr, 0x220), mod(calldataload(add(data_ptr, 0x340)), p))\\n\\n            // proof.q_c\\n            mstore(add(proof_ptr, 0x240), mod(calldataload(add(data_ptr, 0x360)), p))\\n \\n            // proof.linearization_polynomial\\n            mstore(add(proof_ptr, 0x260), mod(calldataload(add(data_ptr, 0x380)), p))\\n\\n            // proof.grand_product_at_z_omega\\n            mstore(add(proof_ptr, 0x280), mod(calldataload(add(data_ptr, 0x3a0)), p))\\n\\n            // proof.w1_omega to proof.w4_omega\\n            mstore(add(proof_ptr, 0x2a0), mod(calldataload(add(data_ptr, 0x3c0)), p))\\n            mstore(add(proof_ptr, 0x2c0), mod(calldataload(add(data_ptr, 0x3e0)), p))\\n            mstore(add(proof_ptr, 0x2e0), mod(calldataload(add(data_ptr, 0x400)), p))\\n            mstore(add(proof_ptr, 0x300), mod(calldataload(add(data_ptr, 0x420)), p))\\n  \\n            // proof.PI_Z\\n            mstore(mload(add(proof_ptr, 0x320)), mod(calldataload(add(data_ptr, 0x460)), q))\\n            mstore(add(mload(add(proof_ptr, 0x320)), 0x20), mod(calldataload(add(data_ptr, 0x440)), q))\\n\\n            // proof.PI_Z_OMEGA\\n            mstore(mload(add(proof_ptr, 0x340)), mod(calldataload(add(data_ptr, 0x4a0)), q))\\n            mstore(add(mload(add(proof_ptr, 0x340)), 0x20), mod(calldataload(add(data_ptr, 0x480)), q))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/cryptography/Bn254Crypto.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from \\\"./Types.sol\\\";\\n\\n/**\\n * @title Bn254 elliptic curve crypto\\n * @dev Provides some basic methods to compute bilinear pairings, construct group elements and misc numerical methods\\n */\\nlibrary Bn254Crypto {\\n    uint256 constant p_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n    // Perform a modular exponentiation. This method is ideal for small exponents (~64 bits or less), as\\n    // it is cheaper than using the pow precompile\\n    function pow_small(\\n        uint256 base,\\n        uint256 exponent,\\n        uint256 modulus\\n    ) internal pure returns (uint256) {\\n        uint256 result = 1;\\n        uint256 input = base;\\n        uint256 count = 1;\\n\\n        assembly {\\n            let endpoint := add(exponent, 0x01)\\n            for {} lt(count, endpoint) { count := add(count, count) }\\n            {\\n                if and(exponent, count) {\\n                    result := mulmod(result, input, modulus)\\n                }\\n                input := mulmod(input, input, modulus)\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    function invert(uint256 fr) internal view returns (uint256)\\n    {\\n        uint256 output;\\n        bool success;\\n        uint256 p = r_mod;\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, 0x20)\\n            mstore(add(mPtr, 0x20), 0x20)\\n            mstore(add(mPtr, 0x40), 0x20)\\n            mstore(add(mPtr, 0x60), fr)\\n            mstore(add(mPtr, 0x80), sub(p, 2))\\n            mstore(add(mPtr, 0xa0), p)\\n            success := staticcall(gas(), 0x05, mPtr, 0xc0, 0x00, 0x20)\\n            output := mload(0x00)\\n        }\\n        require(success, \\\"pow precompile call failed!\\\");\\n        return output;\\n    }\\n\\n    function new_g1(uint256 x, uint256 y)\\n        internal\\n        pure\\n        returns (Types.G1Point memory)\\n    {\\n        uint256 xValue;\\n        uint256 yValue;\\n        assembly {\\n            xValue := mod(x, r_mod)\\n            yValue := mod(y, r_mod)\\n        }\\n        return Types.G1Point(xValue, yValue);\\n    }\\n\\n    function new_g2(uint256 x0, uint256 x1, uint256 y0, uint256 y1)\\n        internal\\n        pure\\n        returns (Types.G2Point memory)\\n    {\\n        return Types.G2Point(x0, x1, y0, y1);\\n    }\\n\\n    function P1() internal pure returns (Types.G1Point memory) {\\n        return Types.G1Point(1, 2);\\n    }\\n\\n    function P2() internal pure returns (Types.G2Point memory) {\\n        return Types.G2Point({\\n            x0: 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\\n            x1: 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed,\\n            y0: 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\\n            y1: 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\\n        });\\n    }\\n\\n\\n    /// Evaluate the following pairing product:\\n    /// e(a1, a2).e(-b1, b2) == 1\\n    function pairingProd2(\\n        Types.G1Point memory a1,\\n        Types.G2Point memory a2,\\n        Types.G1Point memory b1,\\n        Types.G2Point memory b2\\n    ) internal view returns (bool) {\\n        validateG1Point(a1);\\n        validateG1Point(b1);\\n        bool success;\\n        uint256 out;\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, mload(a1))\\n            mstore(add(mPtr, 0x20), mload(add(a1, 0x20)))\\n            mstore(add(mPtr, 0x40), mload(a2))\\n            mstore(add(mPtr, 0x60), mload(add(a2, 0x20)))\\n            mstore(add(mPtr, 0x80), mload(add(a2, 0x40)))\\n            mstore(add(mPtr, 0xa0), mload(add(a2, 0x60)))\\n\\n            mstore(add(mPtr, 0xc0), mload(b1))\\n            mstore(add(mPtr, 0xe0), mload(add(b1, 0x20)))\\n            mstore(add(mPtr, 0x100), mload(b2))\\n            mstore(add(mPtr, 0x120), mload(add(b2, 0x20)))\\n            mstore(add(mPtr, 0x140), mload(add(b2, 0x40)))\\n            mstore(add(mPtr, 0x160), mload(add(b2, 0x60)))\\n            success := staticcall(\\n                gas(),\\n                8,\\n                mPtr,\\n                0x180,\\n                0x00,\\n                0x20\\n            )\\n            out := mload(0x00)\\n        }\\n        require(success, \\\"Pairing check failed!\\\");\\n        return (out != 0);\\n    }\\n\\n    /**\\n    * validate the following:\\n    *   x != 0\\n    *   y != 0\\n    *   x < p\\n    *   y < p\\n    *   y^2 = x^3 + 3 mod p\\n    */\\n    function validateG1Point(Types.G1Point memory point) internal pure {\\n        bool is_well_formed;\\n        uint256 p = p_mod;\\n        assembly {\\n            let x := mload(point)\\n            let y := mload(add(point, 0x20))\\n\\n            is_well_formed := and(\\n                and(\\n                    and(lt(x, p), lt(y, p)),\\n                    not(or(iszero(x), iszero(y)))\\n                ),\\n                eq(mulmod(y, y, p), addmod(mulmod(x, mulmod(x, x, p), p), 3, p))\\n            )\\n        }\\n        require(is_well_formed, \\\"Bn254: G1 point not on curve, or is malformed\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/verifier/cryptography/PolynomialEval.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Bn254Crypto} from './Bn254Crypto.sol';\\nimport {Types} from './Types.sol';\\n\\n/**\\n * @title Turbo Plonk polynomial evaluation\\n * @dev Implementation of Turbo Plonk's polynomial evaluation algorithms\\n *\\n * Expected to be inherited by `TurboPlonk.sol`\\n *\\n * Copyright 2020 Spilsbury Holdings Ltd\\n *\\n * Licensed under the GNU General Public License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n *\\n * This program is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n * GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n */\\nlibrary PolynomialEval {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n\\n    /**\\n     * @dev Use batch inversion (so called Montgomery's trick). Circuit size is the domain\\n     * Allows multiple inversions to be performed in one inversion, at the expense of additional multiplications\\n     *\\n     * Returns a struct containing the inverted elements\\n     */\\n    function compute_batch_inversions(\\n        uint256 public_input_delta_numerator,\\n        uint256 public_input_delta_denominator,\\n        uint256 vanishing_numerator,\\n        uint256 vanishing_denominator,\\n        uint256 lagrange_numerator,\\n        uint256 l_start_denominator,\\n        uint256 l_end_denominator\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 zero_polynomial_eval,\\n            uint256 public_input_delta,\\n            uint256 l_start,\\n            uint256 l_end\\n        )\\n    {\\n        uint256 mPtr;\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 accumulator = 1;\\n        assembly {\\n            mPtr := mload(0x40)\\n            mstore(0x40, add(mPtr, 0x200))\\n        }\\n    \\n        // store denominators in mPtr -> mPtr + 0x80\\n        assembly {\\n            mstore(mPtr, public_input_delta_denominator) // store denominator\\n            mstore(add(mPtr, 0x20), vanishing_numerator) // store numerator, because we want the inverse of the zero poly\\n            mstore(add(mPtr, 0x40), l_start_denominator) // store denominator\\n            mstore(add(mPtr, 0x60), l_end_denominator) // store denominator\\n\\n            // store temporary product terms at mPtr + 0x80 -> mPtr + 0x100\\n            mstore(add(mPtr, 0x80), accumulator)\\n            accumulator := mulmod(accumulator, mload(mPtr), p)\\n            mstore(add(mPtr, 0xa0), accumulator)\\n            accumulator := mulmod(accumulator, mload(add(mPtr, 0x20)), p)\\n            mstore(add(mPtr, 0xc0), accumulator)\\n            accumulator := mulmod(accumulator, mload(add(mPtr, 0x40)), p)\\n            mstore(add(mPtr, 0xe0), accumulator)\\n            accumulator := mulmod(accumulator, mload(add(mPtr, 0x60)), p)\\n        }\\n\\n        accumulator = Bn254Crypto.invert(accumulator);\\n        assembly {\\n            let intermediate := mulmod(accumulator, mload(add(mPtr, 0xe0)), p)\\n            accumulator := mulmod(accumulator, mload(add(mPtr, 0x60)), p)\\n            mstore(add(mPtr, 0x60), intermediate)\\n\\n            intermediate := mulmod(accumulator, mload(add(mPtr, 0xc0)), p)\\n            accumulator := mulmod(accumulator, mload(add(mPtr, 0x40)), p)\\n            mstore(add(mPtr, 0x40), intermediate)\\n\\n            intermediate := mulmod(accumulator, mload(add(mPtr, 0xa0)), p)\\n            accumulator := mulmod(accumulator, mload(add(mPtr, 0x20)), p)\\n            mstore(add(mPtr, 0x20), intermediate)\\n\\n            intermediate := mulmod(accumulator, mload(add(mPtr, 0x80)), p)\\n            accumulator := mulmod(accumulator, mload(mPtr), p)\\n            mstore(mPtr, intermediate)\\n\\n            public_input_delta := mulmod(public_input_delta_numerator, mload(mPtr), p)\\n\\n            zero_polynomial_eval := mulmod(vanishing_denominator, mload(add(mPtr, 0x20)), p)\\n    \\n            l_start := mulmod(lagrange_numerator, mload(add(mPtr, 0x40)), p)\\n\\n            l_end := mulmod(lagrange_numerator, mload(add(mPtr, 0x60)), p)\\n        }\\n    }\\n\\n    function compute_public_input_delta(\\n        Types.ChallengeTranscript memory challenges,\\n        Types.VerificationKey memory vk\\n    ) internal pure returns (uint256, uint256) {\\n        uint256 gamma = challenges.gamma;\\n        uint256 work_root = vk.work_root;\\n\\n        uint256 endpoint = (vk.num_inputs * 0x20) - 0x20;\\n        uint256 public_inputs;\\n        uint256 root_1 = challenges.beta;\\n        uint256 root_2 = challenges.beta;\\n        uint256 numerator_value = 1;\\n        uint256 denominator_value = 1;\\n\\n        // we multiply length by 0x20 because our loop step size is 0x20 not 0x01\\n        // we subtract 0x20 because our loop is unrolled 2 times an we don't want to overshoot\\n\\n        // perform this computation in assembly to improve efficiency. We are sensitive to the cost of this loop as\\n        // it scales with the number of public inputs\\n        uint256 p = Bn254Crypto.r_mod;\\n        bool valid = true;\\n        assembly {\\n            root_1 := mulmod(root_1, 0x05, p)\\n            root_2 := mulmod(root_2, 0x07, p)\\n            public_inputs := add(calldataload(0x04), 0x24)\\n\\n            // get public inputs from calldata. N.B. If Contract ABI Changes this code will need to be updated!\\n            endpoint := add(endpoint, public_inputs)\\n            // Do some loop unrolling to reduce number of conditional jump operations\\n            for {} lt(public_inputs, endpoint) {}\\n            {\\n                let input0 := calldataload(public_inputs)\\n                let N0 := add(root_1, add(input0, gamma))\\n                let D0 := add(root_2, N0) // 4x overloaded\\n\\n                root_1 := mulmod(root_1, work_root, p)\\n                root_2 := mulmod(root_2, work_root, p)\\n\\n                let input1 := calldataload(add(public_inputs, 0x20))\\n                let N1 := add(root_1, add(input1, gamma))\\n\\n                denominator_value := mulmod(mulmod(D0, denominator_value, p), add(N1, root_2), p)\\n                numerator_value := mulmod(mulmod(N1, N0, p), numerator_value, p)\\n\\n                root_1 := mulmod(root_1, work_root, p)\\n                root_2 := mulmod(root_2, work_root, p)\\n\\n                valid := and(valid, and(lt(input0, p), lt(input1, p)))\\n                public_inputs := add(public_inputs, 0x40)\\n            }\\n\\n            endpoint := add(endpoint, 0x20)\\n            for {} lt(public_inputs, endpoint) { public_inputs := add(public_inputs, 0x20) }\\n            {\\n                let input0 := calldataload(public_inputs)\\n                valid := and(valid, lt(input0, p))\\n                let T0 := addmod(input0, gamma, p)\\n                numerator_value := mulmod(\\n                    numerator_value,\\n                    add(root_1, T0), // 0x05 = coset_generator0\\n                    p\\n                )\\n                denominator_value := mulmod(\\n                    denominator_value,\\n                    add(add(root_1, root_2), T0), // 0x0c = coset_generator7\\n                    p\\n                )\\n                root_1 := mulmod(root_1, work_root, p)\\n                root_2 := mulmod(root_2, work_root, p)\\n            }\\n        }\\n        require(valid, \\\"public inputs are greater than circuit modulus\\\");\\n        return (numerator_value, denominator_value);\\n    }\\n\\n    /**\\n     * @dev Computes the vanishing polynoimal and lagrange evaluations L1 and Ln.\\n     * @return Returns fractions as numerators and denominators. We combine with the public input fraction and compute inverses as a batch\\n     */\\n    function compute_lagrange_and_vanishing_fractions(Types.VerificationKey memory vk, uint256 zeta\\n    ) internal pure returns (uint256, uint256, uint256, uint256, uint256) {\\n\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 vanishing_numerator = Bn254Crypto.pow_small(zeta, vk.circuit_size, p);\\n        vk.zeta_pow_n = vanishing_numerator;\\n        assembly {\\n            vanishing_numerator := addmod(vanishing_numerator, sub(p, 1), p)\\n        }\\n\\n        uint256 accumulating_root = vk.work_root_inverse;\\n        uint256 work_root = vk.work_root_inverse;\\n        uint256 vanishing_denominator;\\n        uint256 domain_inverse = vk.domain_inverse;\\n        uint256 l_start_denominator;\\n        uint256 l_end_denominator;\\n        uint256 z = zeta; // copy input var to prevent stack depth errors\\n        assembly {\\n\\n            // vanishing_denominator = (z - w^{n-1})(z - w^{n-2})(z - w^{n-3})(z - w^{n-4})\\n            // we need to cut 4 roots of unity out of the vanishing poly, the last 4 constraints are not satisfied due to randomness\\n            // added to ensure the proving system is zero-knowledge\\n            vanishing_denominator := addmod(z, sub(p, work_root), p)\\n            work_root := mulmod(work_root, accumulating_root, p)\\n            vanishing_denominator := mulmod(vanishing_denominator, addmod(z, sub(p, work_root), p), p)\\n            work_root := mulmod(work_root, accumulating_root, p)\\n            vanishing_denominator := mulmod(vanishing_denominator, addmod(z, sub(p, work_root), p), p)\\n            work_root := mulmod(work_root, accumulating_root, p)\\n            vanishing_denominator := mulmod(vanishing_denominator, addmod(z, sub(p, work_root), p), p)\\n        }\\n        \\n        work_root = vk.work_root;\\n        uint256 lagrange_numerator;\\n        assembly {\\n            lagrange_numerator := mulmod(vanishing_numerator, domain_inverse, p)\\n            // l_start_denominator = z - 1\\n            // l_end_denominator = z * \\\\omega^5 - 1\\n            l_start_denominator := addmod(z, sub(p, 1), p)\\n\\n            accumulating_root := mulmod(work_root, work_root, p)\\n            accumulating_root := mulmod(accumulating_root, accumulating_root, p)\\n            accumulating_root := mulmod(accumulating_root, work_root, p)\\n\\n            l_end_denominator := addmod(mulmod(accumulating_root, z, p), sub(p, 1), p)\\n        }\\n\\n        return (vanishing_numerator, vanishing_denominator, lagrange_numerator, l_start_denominator, l_end_denominator);\\n    }\\n\\n    function compute_arithmetic_gate_quotient_contribution(\\n        Types.ChallengeTranscript memory challenges,\\n        Types.Proof memory proof\\n    ) internal pure returns (uint256) {\\n\\n        uint256 q_arith = proof.q_arith;\\n        uint256 wire3 = proof.w3;\\n        uint256 wire4 = proof.w4;\\n        uint256 alpha_base = challenges.alpha_base;\\n        uint256 alpha = challenges.alpha;\\n        uint256 t1;\\n        uint256 p = Bn254Crypto.r_mod;\\n        assembly {\\n            t1 := addmod(mulmod(q_arith, q_arith, p), sub(p, q_arith), p)\\n\\n            let t2 := addmod(sub(p, mulmod(wire4, 0x04, p)), wire3, p)\\n\\n            let t3 := mulmod(mulmod(t2, t2, p), 0x02, p)\\n\\n            let t4 := mulmod(t2, 0x09, p)\\n            t4 := addmod(t4, addmod(sub(p, t3), sub(p, 0x07), p), p)\\n\\n            t2 := mulmod(t2, t4, p)\\n\\n            t1 := mulmod(mulmod(t1, t2, p), alpha_base, p)\\n\\n\\n            alpha_base := mulmod(alpha_base, alpha, p)\\n            alpha_base := mulmod(alpha_base, alpha, p)\\n        }\\n\\n        challenges.alpha_base = alpha_base;\\n\\n        return t1;\\n    }\\n\\n    function compute_pedersen_gate_quotient_contribution(\\n        Types.ChallengeTranscript memory challenges,\\n        Types.Proof memory proof\\n    ) internal pure returns (uint256) {\\n\\n\\n        uint256 alpha = challenges.alpha;\\n        uint256 gate_id = 0;\\n        uint256 alpha_base = challenges.alpha_base;\\n\\n        {\\n            uint256 p = Bn254Crypto.r_mod;\\n            uint256 delta = 0;\\n\\n            uint256 wire_t0 = proof.w4; // w4\\n            uint256 wire_t1 = proof.w4_omega; // w4_omega\\n            uint256 wire_t2 = proof.w3_omega; // w3_omega\\n            assembly {\\n                let wire4_neg := sub(p, wire_t0)\\n                delta := addmod(wire_t1, mulmod(wire4_neg, 0x04, p), p)\\n\\n                gate_id :=\\n                mulmod(\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(\\n                                add(delta, 0x01),\\n                                add(delta, 0x03),\\n                                p\\n                            ),\\n                            add(delta, sub(p, 0x01)),\\n                            p\\n                        ),\\n                        add(delta, sub(p, 0x03)),\\n                        p\\n                    ),\\n                    alpha_base,\\n                    p\\n                )\\n                alpha_base := mulmod(alpha_base, alpha, p)\\n        \\n                gate_id := addmod(gate_id, sub(p, mulmod(wire_t2, alpha_base, p)), p)\\n\\n                alpha_base := mulmod(alpha_base, alpha, p)\\n            }\\n\\n            uint256 selector_value = proof.q_ecc;\\n\\n            wire_t0 = proof.w1; // w1\\n            wire_t1 = proof.w1_omega; // w1_omega\\n            wire_t2 = proof.w2; // w2\\n            uint256 wire_t3 = proof.w3_omega; // w3_omega\\n            uint256 t0;\\n            uint256 t1;\\n            uint256 t2;\\n            assembly {\\n                t0 := addmod(wire_t1, addmod(wire_t0, wire_t3, p), p)\\n\\n                t1 := addmod(wire_t3, sub(p, wire_t0), p)\\n                t1 := mulmod(t1, t1, p)\\n\\n                t0 := mulmod(t0, t1, p)\\n\\n                t1 := mulmod(wire_t3, mulmod(wire_t3, wire_t3, p), p)\\n\\n                t2 := mulmod(wire_t2, wire_t2, p)\\n\\n                t1 := sub(p, addmod(addmod(t1, t2, p), sub(p, 17), p))\\n\\n                t2 := mulmod(mulmod(delta, wire_t2, p), selector_value, p)\\n                t2 := addmod(t2, t2, p)\\n\\n                t0 := \\n                    mulmod(\\n                        addmod(t0, addmod(t1, t2, p), p),\\n                        alpha_base,\\n                        p\\n                    )\\n                gate_id := addmod(gate_id, t0, p)\\n\\n                alpha_base := mulmod(alpha_base, alpha, p)\\n            }\\n\\n            wire_t0 = proof.w1; // w1\\n            wire_t1 = proof.w2_omega; // w2_omega\\n            wire_t2 = proof.w2; // w2\\n            wire_t3 = proof.w3_omega; // w3_omega\\n            uint256 wire_t4 = proof.w1_omega; // w1_omega\\n            assembly {\\n                t0 := mulmod(\\n                    addmod(wire_t1, wire_t2, p),\\n                    addmod(wire_t3, sub(p, wire_t0), p),\\n                    p\\n                )\\n\\n                t1 := addmod(wire_t0, sub(p, wire_t4), p)\\n\\n                t2 := addmod(\\n                        sub(p, mulmod(selector_value, delta, p)),\\n                        wire_t2,\\n                        p\\n                )\\n\\n                gate_id := addmod(gate_id, mulmod(add(t0, mulmod(t1, t2, p)), alpha_base, p), p)\\n\\n                alpha_base := mulmod(alpha_base, alpha, p)\\n            }\\n\\n            selector_value = proof.q_c;\\n        \\n            wire_t1 = proof.w4; // w4\\n            wire_t2 = proof.w3; // w3\\n            assembly {\\n                let acc_init_id := addmod(wire_t1, sub(p, 0x01), p)\\n\\n                t1 := addmod(acc_init_id, sub(p, wire_t2), p)\\n\\n                acc_init_id := mulmod(acc_init_id, mulmod(t1, alpha_base, p), p)\\n                acc_init_id := mulmod(acc_init_id, selector_value, p)\\n\\n                gate_id := addmod(gate_id, acc_init_id, p)\\n\\n                alpha_base := mulmod(alpha_base, alpha, p)\\n            }\\n        \\n            assembly {\\n                let x_init_id := sub(p, mulmod(mulmod(wire_t0, selector_value, p), mulmod(wire_t2, alpha_base, p), p))\\n\\n                gate_id := addmod(gate_id, x_init_id, p)\\n\\n                alpha_base := mulmod(alpha_base, alpha, p)\\n            }\\n\\n            wire_t0 = proof.w2; // w2\\n            wire_t1 = proof.w3; // w3\\n            wire_t2 = proof.w4; // w4\\n            assembly {\\n                let y_init_id := mulmod(add(0x01, sub(p, wire_t2)), selector_value, p)\\n\\n                t1 := sub(p, mulmod(wire_t0, wire_t1, p))\\n\\n                y_init_id := mulmod(add(y_init_id, t1), mulmod(alpha_base, selector_value, p), p)\\n\\n                gate_id := addmod(gate_id, y_init_id, p)\\n\\n                alpha_base := mulmod(alpha_base, alpha, p)\\n\\n            }\\n            selector_value = proof.q_ecc;\\n            assembly {\\n                gate_id := mulmod(gate_id, selector_value, p)\\n            }\\n        }\\n        challenges.alpha_base = alpha_base;\\n        return gate_id;\\n    }\\n\\n    function compute_permutation_quotient_contribution(\\n        uint256 public_input_delta,\\n        Types.ChallengeTranscript memory challenges,\\n        uint256 lagrange_start,\\n        uint256 lagrange_end,\\n        Types.Proof memory proof\\n    ) internal pure returns (uint256) {\\n\\n        uint256 numerator_collector;\\n        uint256 alpha = challenges.alpha;\\n        uint256 beta = challenges.beta;\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 grand_product = proof.grand_product_at_z_omega;\\n        {\\n            uint256 gamma = challenges.gamma;\\n            uint256 wire1 = proof.w1;\\n            uint256 wire2 = proof.w2;\\n            uint256 wire3 = proof.w3;\\n            uint256 wire4 = proof.w4;\\n            uint256 sigma1 = proof.sigma1;\\n            uint256 sigma2 = proof.sigma2;\\n            uint256 sigma3 = proof.sigma3;\\n            assembly {\\n\\n                let t0 := add(\\n                    add(wire1, gamma),\\n                    mulmod(beta, sigma1, p)\\n                )\\n\\n                let t1 := add(\\n                    add(wire2, gamma),\\n                    mulmod(beta, sigma2, p)\\n                )\\n\\n                let t2 := add(\\n                    add(wire3, gamma),\\n                    mulmod(beta, sigma3, p)\\n                )\\n\\n                t0 := mulmod(t0, mulmod(t1, t2, p), p)\\n\\n                t0 := mulmod(\\n                    t0,\\n                    add(wire4, gamma),\\n                    p\\n                )\\n\\n                t0 := mulmod(\\n                    t0,\\n                    grand_product,\\n                    p\\n                )\\n\\n                t0 := mulmod(\\n                    t0,\\n                    alpha,\\n                    p\\n                )\\n\\n                numerator_collector := sub(p, t0)\\n            }\\n        }\\n\\n\\n        uint256 alpha_base = challenges.alpha_base;\\n        {\\n            uint256 lstart = lagrange_start;\\n            uint256 lend = lagrange_end;\\n            uint256 public_delta = public_input_delta;\\n            uint256 linearization_poly = proof.linearization_polynomial;\\n            assembly {\\n                let alpha_squared := mulmod(alpha, alpha, p)\\n                let alpha_cubed := mulmod(alpha, alpha_squared, p)\\n\\n                let t0 := mulmod(lstart, alpha_cubed, p)\\n                let t1 := mulmod(lend, alpha_squared, p)\\n                let t2 := addmod(grand_product, sub(p, public_delta), p)\\n                t1 := mulmod(t1, t2, p)\\n\\n                numerator_collector := addmod(numerator_collector, sub(p, t0), p)\\n                numerator_collector := addmod(numerator_collector, t1, p)\\n                numerator_collector := addmod(numerator_collector, linearization_poly, p)\\n                alpha_base := mulmod(alpha_base, alpha_cubed, p)\\n            }\\n        }\\n\\n        challenges.alpha_base = alpha_base;\\n\\n        return numerator_collector;\\n    }\\n\\n    function compute_quotient_polynomial(\\n        uint256 zero_poly_inverse,\\n        uint256 public_input_delta,\\n        Types.ChallengeTranscript memory challenges,\\n        uint256 lagrange_start,\\n        uint256 lagrange_end,\\n        Types.Proof memory proof\\n    ) internal pure returns (uint256) {\\n        uint256 t0 = compute_permutation_quotient_contribution(\\n            public_input_delta,\\n            challenges,\\n            lagrange_start,\\n            lagrange_end,\\n            proof\\n        );\\n\\n        uint256 t1 = compute_arithmetic_gate_quotient_contribution(challenges, proof);\\n\\n        uint256 t2 = compute_pedersen_gate_quotient_contribution(challenges, proof);\\n\\n        uint256 quotient_eval;\\n        uint256 p = Bn254Crypto.r_mod;\\n        assembly {\\n            quotient_eval := addmod(t0, addmod(t1, t2, p), p)\\n            quotient_eval := mulmod(quotient_eval, zero_poly_inverse, p)\\n        }\\n        return quotient_eval;\\n    }\\n\\n    function compute_linearised_opening_terms(\\n        Types.ChallengeTranscript memory challenges,\\n        uint256 L1_fr,\\n        Types.VerificationKey memory vk,\\n        Types.Proof memory proof\\n    ) internal view returns (Types.G1Point memory) {\\n        Types.G1Point memory accumulator = compute_grand_product_opening_group_element(proof, vk, challenges, L1_fr);\\n        Types.G1Point memory arithmetic_term = compute_arithmetic_selector_opening_group_element(proof, vk, challenges);\\n        uint256 range_multiplier = compute_range_gate_opening_scalar(proof, challenges);\\n        uint256 logic_multiplier = compute_logic_gate_opening_scalar(proof, challenges);\\n\\n        Types.G1Point memory QRANGE = vk.QRANGE;\\n        Types.G1Point memory QLOGIC = vk.QLOGIC;\\n        QRANGE.validateG1Point();\\n        QLOGIC.validateG1Point();\\n\\n        // compute range_multiplier.[QRANGE] + logic_multiplier.[QLOGIC] + [accumulator] + [grand_product_term]\\n        bool success;\\n        assembly {\\n            let mPtr := mload(0x40)\\n\\n            // range_multiplier.[QRANGE]\\n            mstore(mPtr, mload(QRANGE))\\n            mstore(add(mPtr, 0x20), mload(add(QRANGE, 0x20)))\\n            mstore(add(mPtr, 0x40), range_multiplier)\\n            success := staticcall(gas(), 7, mPtr, 0x60, mPtr, 0x40)\\n\\n            // add scalar mul output into accumulator\\n            // we use mPtr to store accumulated point\\n            mstore(add(mPtr, 0x40), mload(accumulator))\\n            mstore(add(mPtr, 0x60), mload(add(accumulator, 0x20)))\\n            success := and(success, staticcall(gas(), 6, mPtr, 0x80, mPtr, 0x40))\\n\\n            // logic_multiplier.[QLOGIC]\\n            mstore(add(mPtr, 0x40), mload(QLOGIC))\\n            mstore(add(mPtr, 0x60), mload(add(QLOGIC, 0x20)))\\n            mstore(add(mPtr, 0x80), logic_multiplier)\\n            success := and(success, staticcall(gas(), 7, add(mPtr, 0x40), 0x60, add(mPtr, 0x40), 0x40))\\n\\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, mPtr, 0x80, mPtr, 0x40))\\n\\n            // add arithmetic into accumulator\\n            mstore(add(mPtr, 0x40), mload(arithmetic_term))\\n            mstore(add(mPtr, 0x60), mload(add(arithmetic_term, 0x20)))\\n            success := and(success, staticcall(gas(), 6, mPtr, 0x80, accumulator, 0x40))\\n        }\\n        require(success, \\\"compute_linearised_opening_terms group operations fail\\\");\\n    \\n        return accumulator;\\n    }\\n\\n    function compute_batch_opening_commitment(\\n        Types.ChallengeTranscript memory challenges,\\n        Types.VerificationKey memory vk,\\n        Types.G1Point memory partial_opening_commitment,\\n        Types.Proof memory proof\\n    ) internal view returns (Types.G1Point memory) {\\n        // Computes the Kate opening proof group operations, for commitments that are not linearised\\n        bool success;\\n        // Reserve 0xa0 bytes of memory to perform group operations\\n        uint256 accumulator_ptr;\\n        uint256 p = Bn254Crypto.r_mod;\\n        assembly {\\n            accumulator_ptr := mload(0x40)\\n            mstore(0x40, add(accumulator_ptr, 0xa0))\\n        }\\n\\n        // first term\\n        Types.G1Point memory work_point = proof.T1;\\n        work_point.validateG1Point();\\n        assembly {\\n            mstore(accumulator_ptr, mload(work_point))\\n            mstore(add(accumulator_ptr, 0x20), mload(add(work_point, 0x20)))\\n        }\\n\\n        // second term\\n        uint256 scalar_multiplier = vk.zeta_pow_n; // zeta_pow_n is computed in compute_lagrange_and_vanishing_fractions\\n        uint256 zeta_n = scalar_multiplier;\\n        work_point = proof.T2;\\n        work_point.validateG1Point();\\n        assembly {\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute zeta_n.[T2]\\n            success := staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40)\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        // third term\\n        work_point = proof.T3;\\n        work_point.validateG1Point();\\n        assembly {\\n            scalar_multiplier := mulmod(scalar_multiplier, scalar_multiplier, p)\\n\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute zeta_n^2.[T3]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n\\n        }\\n\\n        // fourth term\\n        work_point = proof.T4;\\n        work_point.validateG1Point();\\n        assembly {\\n            scalar_multiplier := mulmod(scalar_multiplier, zeta_n, p)\\n\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute zeta_n^3.[T4]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        // fifth term\\n        work_point = partial_opening_commitment;\\n        work_point.validateG1Point();\\n        assembly {            \\n            // add partial opening commitment into accumulator\\n            mstore(add(accumulator_ptr, 0x40), mload(partial_opening_commitment))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(partial_opening_commitment, 0x20)))\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        uint256 u_plus_one = challenges.u;\\n        uint256 v_challenge = challenges.v0;\\n\\n        // W1\\n        work_point = proof.W1;\\n        work_point.validateG1Point();\\n        assembly {\\n            u_plus_one := addmod(u_plus_one, 0x01, p)\\n\\n            scalar_multiplier := mulmod(v_challenge, u_plus_one, p)\\n\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v0(u + 1).[W1]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        // W2\\n        v_challenge = challenges.v1;\\n        work_point = proof.W2;\\n        work_point.validateG1Point();\\n        assembly {\\n            scalar_multiplier := mulmod(v_challenge, u_plus_one, p)\\n\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v1(u + 1).[W2]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        // W3\\n        v_challenge = challenges.v2;\\n        work_point = proof.W3;\\n        work_point.validateG1Point();\\n        assembly {\\n            scalar_multiplier := mulmod(v_challenge, u_plus_one, p)\\n\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v2(u + 1).[W3]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n\\n        // W4\\n        v_challenge = challenges.v3;\\n        work_point = proof.W4;\\n        work_point.validateG1Point();\\n        assembly {\\n            scalar_multiplier := mulmod(v_challenge, u_plus_one, p)\\n\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v3(u + 1).[W4]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        // SIGMA1\\n        scalar_multiplier = challenges.v4;\\n        work_point = vk.SIGMA1;\\n        work_point.validateG1Point();\\n        assembly {\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v4.[SIGMA1]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        // SIGMA2\\n        scalar_multiplier = challenges.v5;\\n        work_point = vk.SIGMA2;\\n        work_point.validateG1Point();\\n        assembly {\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v5.[SIGMA2]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        // SIGMA3\\n        scalar_multiplier = challenges.v6;\\n        work_point = vk.SIGMA3;\\n        work_point.validateG1Point();\\n        assembly {\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v6.[SIGMA3]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        // QARITH\\n        scalar_multiplier = challenges.v7;\\n        work_point = vk.QARITH;\\n        work_point.validateG1Point();\\n        assembly {\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v7.[QARITH]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        Types.G1Point memory output;\\n        // QECC\\n        scalar_multiplier = challenges.v8;\\n        work_point = vk.QECC;\\n        work_point.validateG1Point();\\n        assembly {\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v8.[QECC]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into output point\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, output, 0x40))\\n        }\\n        \\n        require(success, \\\"compute_batch_opening_commitment group operations error\\\");\\n\\n        return output;\\n    }\\n\\n    function compute_batch_evaluation_scalar_multiplier(Types.Proof memory proof, Types.ChallengeTranscript memory challenges)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 opening_scalar;\\n        uint256 lhs;\\n        uint256 rhs;\\n\\n        lhs = challenges.v0;\\n        rhs = proof.w1;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v1;\\n        rhs = proof.w2;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v2;\\n        rhs = proof.w3;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v3;\\n        rhs = proof.w4;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v4;\\n        rhs = proof.sigma1;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v5;\\n        rhs = proof.sigma2;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v6;\\n        rhs = proof.sigma3;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v7;\\n        rhs = proof.q_arith;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v8;\\n        rhs = proof.q_ecc;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v9;\\n        rhs = proof.q_c;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n    \\n        lhs = challenges.v10;\\n        rhs = proof.linearization_polynomial;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n    \\n        lhs = proof.quotient_polynomial_eval;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, lhs, p)\\n        }\\n\\n        lhs = challenges.v0;\\n        rhs = proof.w1_omega;\\n        uint256 shifted_opening_scalar;\\n        assembly {\\n            shifted_opening_scalar := mulmod(lhs, rhs, p)\\n        }\\n    \\n        lhs = challenges.v1;\\n        rhs = proof.w2_omega;\\n        assembly {\\n            shifted_opening_scalar := addmod(shifted_opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v2;\\n        rhs = proof.w3_omega;\\n        assembly {\\n            shifted_opening_scalar := addmod(shifted_opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v3;\\n        rhs = proof.w4_omega;\\n        assembly {\\n            shifted_opening_scalar := addmod(shifted_opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = proof.grand_product_at_z_omega;\\n        assembly {\\n            shifted_opening_scalar := addmod(shifted_opening_scalar, lhs, p)\\n        }\\n\\n        lhs = challenges.u;\\n        assembly {\\n            shifted_opening_scalar := mulmod(shifted_opening_scalar, lhs, p)\\n\\n            opening_scalar := addmod(opening_scalar, shifted_opening_scalar, p)\\n        }\\n\\n        return opening_scalar;\\n    }\\n\\n    // Compute kate opening scalar for arithmetic gate selectors and pedersen gate selectors\\n    // (both the arithmetic gate and pedersen hash gate reuse the same selectors)\\n    function compute_arithmetic_selector_opening_group_element(\\n        Types.Proof memory proof,\\n        Types.VerificationKey memory vk,\\n        Types.ChallengeTranscript memory challenges\\n    ) internal view returns (Types.G1Point memory) {\\n\\n        uint256 q_arith = proof.q_arith;\\n        uint256 q_ecc = proof.q_ecc;\\n        uint256 linear_challenge = challenges.v10;\\n        uint256 alpha_base = challenges.alpha_base;\\n        uint256 scaling_alpha = challenges.alpha_base;\\n        uint256 alpha = challenges.alpha;\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 scalar_multiplier;\\n        uint256 accumulator_ptr; // reserve 0xa0 bytes of memory to multiply and add points\\n        assembly {\\n            accumulator_ptr := mload(0x40)\\n            mstore(0x40, add(accumulator_ptr, 0xa0))\\n        }\\n        {\\n            uint256 delta;\\n            // Q1 Selector\\n            {\\n                {\\n                    uint256 w4 = proof.w4;\\n                    uint256 w4_omega = proof.w4_omega;\\n                    assembly {\\n                        delta := addmod(w4_omega, sub(p, mulmod(w4, 0x04, p)), p)\\n                    }\\n                }\\n                uint256 w1 = proof.w1;\\n\\n                assembly {\\n                    scalar_multiplier := mulmod(w1, linear_challenge, p)\\n                    scalar_multiplier := mulmod(scalar_multiplier, alpha_base, p)\\n                    scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\\n\\n                    scaling_alpha := mulmod(scaling_alpha, alpha, p)\\n                    scaling_alpha := mulmod(scaling_alpha, alpha, p)\\n                    scaling_alpha := mulmod(scaling_alpha, alpha, p)\\n                    let t0 := mulmod(delta, delta, p)\\n                    t0 := mulmod(t0, q_ecc, p)\\n                    t0 := mulmod(t0, scaling_alpha, p)\\n\\n                    scalar_multiplier := addmod(scalar_multiplier, mulmod(t0, linear_challenge, p), p)\\n                }\\n                Types.G1Point memory Q1 = vk.Q1;\\n                Q1.validateG1Point();\\n                bool success;\\n                assembly {\\n                    let mPtr := mload(0x40)\\n                    mstore(mPtr, mload(Q1))\\n                    mstore(add(mPtr, 0x20), mload(add(Q1, 0x20)))\\n                    mstore(add(mPtr, 0x40), scalar_multiplier)\\n                    success := staticcall(gas(), 7, mPtr, 0x60, accumulator_ptr, 0x40)\\n                }\\n                require(success, \\\"G1 point multiplication failed!\\\");\\n            }\\n\\n            // Q2 Selector\\n            {\\n                uint256 w2 = proof.w2;\\n                assembly {\\n                    scalar_multiplier := mulmod(w2, linear_challenge, p)\\n                    scalar_multiplier := mulmod(scalar_multiplier, alpha_base, p)\\n                    scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\\n\\n                    let t0 := mulmod(scaling_alpha, q_ecc, p)\\n                    scalar_multiplier := addmod(scalar_multiplier, mulmod(t0, linear_challenge, p), p)\\n                }\\n\\n                Types.G1Point memory Q2 = vk.Q2;\\n                Q2.validateG1Point();\\n                bool success;\\n                assembly {\\n                    let mPtr := mload(0x40)\\n                    mstore(mPtr, mload(Q2))\\n                    mstore(add(mPtr, 0x20), mload(add(Q2, 0x20)))\\n                    mstore(add(mPtr, 0x40), scalar_multiplier)\\n\\n                    // write scalar mul output 0x40 bytes ahead of accumulator\\n                    success := staticcall(gas(), 7, mPtr, 0x60, add(accumulator_ptr, 0x40), 0x40)\\n\\n                    // add scalar mul output into accumulator\\n                    success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n                }\\n                require(success, \\\"G1 point multiplication failed!\\\");\\n            }\\n\\n            // Q3 Selector\\n            {\\n                {\\n                    uint256 w3 = proof.w3;\\n                    assembly {\\n                        scalar_multiplier := mulmod(w3, linear_challenge, p)\\n                        scalar_multiplier := mulmod(scalar_multiplier, alpha_base, p)\\n                        scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\\n                    }\\n                }\\n                {\\n                    uint256 t1;\\n                    {\\n                        uint256 w3_omega = proof.w3_omega;\\n                        assembly {\\n                            t1 := mulmod(delta, w3_omega, p)\\n                        }\\n                    }\\n                    {\\n                        uint256 w2 = proof.w2;\\n                        assembly {\\n                            scaling_alpha := mulmod(scaling_alpha, alpha, p)\\n\\n                            t1 := mulmod(t1, w2, p)\\n                            t1 := mulmod(t1, scaling_alpha, p)\\n                            t1 := addmod(t1, t1, p)\\n                            t1 := mulmod(t1, q_ecc, p)\\n\\n                        scalar_multiplier := addmod(scalar_multiplier, mulmod(t1, linear_challenge, p), p)\\n                        }\\n                    }\\n                }\\n                uint256 t0 = proof.w1_omega;\\n                {\\n                    uint256 w1 = proof.w1;\\n                    assembly {\\n                        scaling_alpha := mulmod(scaling_alpha, alpha, p)\\n                        t0 := addmod(t0, sub(p, w1), p)\\n                        t0 := mulmod(t0, delta, p)\\n                    }\\n                }\\n                uint256 w3_omega = proof.w3_omega;\\n                assembly {\\n\\n                    t0 := mulmod(t0, w3_omega, p)\\n                    t0 := mulmod(t0, scaling_alpha, p)\\n\\n                    t0 := mulmod(t0, q_ecc, p)\\n\\n                    scalar_multiplier := addmod(scalar_multiplier, mulmod(t0, linear_challenge, p), p)\\n                }\\n            }\\n\\n            Types.G1Point memory Q3 = vk.Q3;\\n            Q3.validateG1Point();\\n            bool success;\\n            assembly {\\n                let mPtr := mload(0x40)\\n                mstore(mPtr, mload(Q3))\\n                mstore(add(mPtr, 0x20), mload(add(Q3, 0x20)))\\n                mstore(add(mPtr, 0x40), scalar_multiplier)\\n\\n                // write scalar mul output 0x40 bytes ahead of accumulator\\n                success := staticcall(gas(), 7, mPtr, 0x60, add(accumulator_ptr, 0x40), 0x40)\\n\\n                // add scalar mul output into accumulator\\n                success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n            }\\n            require(success, \\\"G1 point multiplication failed!\\\");\\n        }\\n\\n        // Q4 Selector\\n        {\\n            uint256 w3 = proof.w3;\\n            uint256 w4 = proof.w4;\\n            uint256 q_c = proof.q_c;\\n            assembly {\\n                scalar_multiplier := mulmod(w4, linear_challenge, p)\\n                scalar_multiplier := mulmod(scalar_multiplier, alpha_base, p)\\n                scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\\n\\n                scaling_alpha := mulmod(scaling_alpha, mulmod(alpha, alpha, p), p)\\n                let t0 := mulmod(w3, q_ecc, p)\\n                t0 := mulmod(t0, q_c, p)\\n                t0 := mulmod(t0, scaling_alpha, p)\\n\\n                scalar_multiplier := addmod(scalar_multiplier, mulmod(t0, linear_challenge, p), p)\\n            }\\n\\n            Types.G1Point memory Q4 = vk.Q4;\\n            Q4.validateG1Point();\\n            bool success;\\n            assembly {\\n                let mPtr := mload(0x40)\\n                mstore(mPtr, mload(Q4))\\n                mstore(add(mPtr, 0x20), mload(add(Q4, 0x20)))\\n                mstore(add(mPtr, 0x40), scalar_multiplier)\\n\\n                // write scalar mul output 0x40 bytes ahead of accumulator\\n                success := staticcall(gas(), 7, mPtr, 0x60, add(accumulator_ptr, 0x40), 0x40)\\n\\n                // add scalar mul output into accumulator\\n                success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n            }\\n            require(success, \\\"G1 point multiplication failed!\\\");\\n        }\\n\\n        // Q5 Selector\\n        {\\n            uint256 w4 = proof.w4;\\n            uint256 q_c = proof.q_c;\\n            assembly {\\n                let neg_w4 := sub(p, w4)\\n                scalar_multiplier := mulmod(w4, w4, p)\\n                scalar_multiplier := addmod(scalar_multiplier, neg_w4, p)\\n                scalar_multiplier := mulmod(scalar_multiplier, addmod(w4, sub(p, 2), p), p)\\n                scalar_multiplier := mulmod(scalar_multiplier, alpha_base, p)\\n                scalar_multiplier := mulmod(scalar_multiplier, alpha, p)\\n                scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\\n                scalar_multiplier := mulmod(scalar_multiplier, linear_challenge, p)\\n\\n                let t0 := addmod(0x01, neg_w4, p)\\n                t0 := mulmod(t0, q_ecc, p)\\n                t0 := mulmod(t0, q_c, p)\\n                t0 := mulmod(t0, scaling_alpha, p)\\n\\n                scalar_multiplier := addmod(scalar_multiplier, mulmod(t0, linear_challenge, p), p)\\n            }\\n\\n            Types.G1Point memory Q5 = vk.Q5;\\n            Q5.validateG1Point();\\n            bool success;\\n            assembly {\\n                let mPtr := mload(0x40)\\n                mstore(mPtr, mload(Q5))\\n                mstore(add(mPtr, 0x20), mload(add(Q5, 0x20)))\\n                mstore(add(mPtr, 0x40), scalar_multiplier)\\n\\n                // write scalar mul output 0x40 bytes ahead of accumulator\\n                success := staticcall(gas(), 7, mPtr, 0x60, add(accumulator_ptr, 0x40), 0x40)\\n\\n                // add scalar mul output into accumulator\\n                success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n            }\\n            require(success, \\\"G1 point multiplication failed!\\\");\\n        }\\n    \\n        // QM Selector\\n        {\\n            {\\n                uint256 w1 = proof.w1;\\n                uint256 w2 = proof.w2;\\n\\n                assembly {\\n                    scalar_multiplier := mulmod(w1, w2, p)\\n                    scalar_multiplier := mulmod(scalar_multiplier, linear_challenge, p)\\n                    scalar_multiplier := mulmod(scalar_multiplier, alpha_base, p)\\n                    scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\\n                }\\n            }\\n            uint256 w3 = proof.w3;\\n            uint256 q_c = proof.q_c;\\n            assembly {\\n\\n                scaling_alpha := mulmod(scaling_alpha, alpha, p)\\n                let t0 := mulmod(w3, q_ecc, p)\\n                t0 := mulmod(t0, q_c, p)\\n                t0 := mulmod(t0, scaling_alpha, p)\\n\\n                scalar_multiplier := addmod(scalar_multiplier, mulmod(t0, linear_challenge, p), p)\\n            }\\n\\n            Types.G1Point memory QM = vk.QM;\\n            QM.validateG1Point();\\n            bool success;\\n            assembly {\\n                let mPtr := mload(0x40)\\n                mstore(mPtr, mload(QM))\\n                mstore(add(mPtr, 0x20), mload(add(QM, 0x20)))\\n                mstore(add(mPtr, 0x40), scalar_multiplier)\\n\\n                // write scalar mul output 0x40 bytes ahead of accumulator\\n                success := staticcall(gas(), 7, mPtr, 0x60, add(accumulator_ptr, 0x40), 0x40)\\n\\n                // add scalar mul output into accumulator\\n                success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n            }\\n            require(success, \\\"G1 point multiplication failed!\\\");\\n        }\\n\\n        Types.G1Point memory output;\\n        // QC Selector\\n        {\\n            uint256 q_c_challenge = challenges.v9;\\n            assembly {\\n                scalar_multiplier := mulmod(linear_challenge, alpha_base, p)\\n                scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\\n\\n                // TurboPlonk requires an explicit evaluation of q_c\\n                scalar_multiplier := addmod(scalar_multiplier, q_c_challenge, p)\\n\\n                alpha_base := mulmod(scaling_alpha, alpha, p)\\n            }\\n\\n            Types.G1Point memory QC = vk.QC;\\n            QC.validateG1Point();\\n            bool success;\\n            assembly {\\n                let mPtr := mload(0x40)\\n                mstore(mPtr, mload(QC))\\n                mstore(add(mPtr, 0x20), mload(add(QC, 0x20)))\\n                mstore(add(mPtr, 0x40), scalar_multiplier)\\n\\n                // write scalar mul output 0x40 bytes ahead of accumulator\\n                success := staticcall(gas(), 7, mPtr, 0x60, add(accumulator_ptr, 0x40), 0x40)\\n\\n                // add scalar mul output into output point\\n                success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, output, 0x40))\\n            }\\n            require(success, \\\"G1 point multiplication failed!\\\");\\n\\n        }\\n        challenges.alpha_base = alpha_base;\\n\\n        return output;\\n    }\\n\\n\\n    // Compute kate opening scalar for logic gate opening scalars\\n    // This method evalautes the polynomial identity used to evaluate either\\n    // a 2-bit AND or XOR operation in a single constraint\\n    function compute_logic_gate_opening_scalar(\\n        Types.Proof memory proof,\\n        Types.ChallengeTranscript memory challenges\\n    ) internal pure returns (uint256) {\\n        uint256 identity = 0;\\n        uint256 p = Bn254Crypto.r_mod;\\n        {\\n            uint256 delta_sum = 0;\\n            uint256 delta_squared_sum = 0;\\n            uint256 t0 = 0;\\n            uint256 t1 = 0;\\n            uint256 t2 = 0;\\n            uint256 t3 = 0;\\n            {\\n                uint256 wire1_omega = proof.w1_omega;\\n                uint256 wire1 = proof.w1;\\n                assembly {\\n                    t0 := addmod(wire1_omega, sub(p, mulmod(wire1, 0x04, p)), p)\\n                }\\n            }\\n\\n            {\\n                uint256 wire2_omega = proof.w2_omega;\\n                uint256 wire2 = proof.w2;\\n                assembly {\\n                    t1 := addmod(wire2_omega, sub(p, mulmod(wire2, 0x04, p)), p)\\n\\n                    delta_sum := addmod(t0, t1, p)\\n                    t2 := mulmod(t0, t0, p)\\n                    t3 := mulmod(t1, t1, p)\\n                    delta_squared_sum := addmod(t2, t3, p)\\n                    identity := mulmod(delta_sum, delta_sum, p)\\n                    identity := addmod(identity, sub(p, delta_squared_sum), p)\\n                }\\n            }\\n\\n            uint256 t4 = 0;\\n            uint256 alpha = challenges.alpha;\\n\\n            {\\n                uint256 wire3 = proof.w3;\\n                assembly{\\n                    t4 := mulmod(wire3, 0x02, p)\\n                    identity := addmod(identity, sub(p, t4), p)\\n                    identity := mulmod(identity, alpha, p)\\n                }\\n            }\\n\\n            assembly {\\n                t4 := addmod(t4, t4, p)\\n                t2 := addmod(t2, sub(p, t0), p)\\n                t0 := mulmod(t0, 0x04, p)\\n                t0 := addmod(t2, sub(p, t0), p)\\n                t0 := addmod(t0, 0x06, p)\\n\\n                t0 := mulmod(t0, t2, p)\\n                identity := addmod(identity, t0, p)\\n                identity := mulmod(identity, alpha, p)\\n\\n                t3 := addmod(t3, sub(p, t1), p)\\n                t1 := mulmod(t1, 0x04, p)\\n                t1 := addmod(t3, sub(p, t1), p)\\n                t1 := addmod(t1, 0x06, p)\\n\\n                t1 := mulmod(t1, t3, p)\\n                identity := addmod(identity, t1, p)\\n                identity := mulmod(identity, alpha, p)\\n\\n                t0 := mulmod(delta_sum, 0x03, p)\\n\\n                t1 := mulmod(t0, 0x03, p)\\n\\n                delta_sum := addmod(t1, t1, p)\\n\\n                t2 := mulmod(delta_sum, 0x04, p)\\n                t1 := addmod(t1, t2, p)\\n\\n                t2 := mulmod(delta_squared_sum, 0x03, p)\\n\\n                delta_squared_sum := mulmod(t2, 0x06, p)\\n\\n                delta_sum := addmod(t4, sub(p, delta_sum), p)\\n                delta_sum := addmod(delta_sum, 81, p)\\n\\n                t1 := addmod(delta_squared_sum, sub(p, t1), p)\\n                t1 := addmod(t1, 83, p)\\n            }\\n\\n            {\\n                uint256 wire3 = proof.w3;\\n                assembly {\\n                    delta_sum := mulmod(delta_sum, wire3, p)\\n\\n                    delta_sum := addmod(delta_sum, t1, p)\\n                    delta_sum := mulmod(delta_sum, wire3, p)\\n                }\\n            }\\n            {\\n                uint256 wire4 = proof.w4;\\n                assembly {\\n                    t2 := mulmod(wire4, 0x04, p)\\n                }\\n            }\\n            {\\n                uint256 wire4_omega = proof.w4_omega;\\n                assembly {\\n                    t2 := addmod(wire4_omega, sub(p, t2), p)\\n                }\\n            }\\n            {\\n                uint256 q_c = proof.q_c;\\n                assembly {\\n                    t3 := addmod(t2, t2, p)\\n                    t2 := addmod(t2, t3, p)\\n\\n                    t3 := addmod(t2, t2, p)\\n                    t3 := addmod(t3, t2, p)\\n\\n                    t3 := addmod(t3, sub(p, t0), p)\\n                    t3 := mulmod(t3, q_c, p)\\n\\n                    t2 := addmod(t2, t0, p)\\n                    delta_sum := addmod(delta_sum, delta_sum, p)\\n                    t2 := addmod(t2, sub(p, delta_sum), p)\\n\\n                    t2 := addmod(t2, t3, p)\\n\\n                    identity := addmod(identity, t2, p)\\n                }\\n            }\\n            uint256 linear_nu = challenges.v10;\\n            uint256 alpha_base = challenges.alpha_base;\\n\\n            assembly {\\n                identity := mulmod(identity, alpha_base, p)\\n                identity := mulmod(identity, linear_nu, p)\\n            }\\n        }\\n        // update alpha\\n        uint256 alpha_base = challenges.alpha_base;\\n        uint256 alpha = challenges.alpha;\\n        assembly {\\n            alpha := mulmod(alpha, alpha, p)\\n            alpha := mulmod(alpha, alpha, p)\\n            alpha_base := mulmod(alpha_base, alpha, p) \\n        }\\n        challenges.alpha_base = alpha_base;\\n\\n        return identity;\\n    }\\n\\n    // Compute kate opening scalar for arithmetic gate selectors\\n    function compute_range_gate_opening_scalar(\\n        Types.Proof memory proof,\\n        Types.ChallengeTranscript memory challenges\\n    ) internal pure returns (uint256) {\\n        uint256 wire1 = proof.w1;\\n        uint256 wire2 = proof.w2;\\n        uint256 wire3 = proof.w3;\\n        uint256 wire4 = proof.w4;\\n        uint256 wire4_omega = proof.w4_omega;\\n        uint256 alpha = challenges.alpha;\\n        uint256 alpha_base = challenges.alpha_base;\\n        uint256 range_acc;\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 linear_challenge = challenges.v10;\\n        assembly {\\n            let delta_1 := addmod(wire3, sub(p, mulmod(wire4, 0x04, p)), p)\\n            let delta_2 := addmod(wire2, sub(p, mulmod(wire3, 0x04, p)), p)\\n            let delta_3 := addmod(wire1, sub(p, mulmod(wire2, 0x04, p)), p)\\n            let delta_4 := addmod(wire4_omega, sub(p, mulmod(wire1, 0x04, p)), p)\\n\\n\\n            let t0 := mulmod(delta_1, delta_1, p)\\n            t0 := addmod(t0, sub(p, delta_1), p)\\n            let t1 := addmod(delta_1, sub(p, 2), p)\\n            t0 := mulmod(t0, t1, p)\\n            t1 := addmod(delta_1, sub(p, 3), p)\\n            t0 := mulmod(t0, t1, p)\\n            t0 := mulmod(t0, alpha_base, p)\\n\\n            range_acc := t0\\n            alpha_base := mulmod(alpha_base, alpha, p)\\n\\n            t0 := mulmod(delta_2, delta_2, p)\\n            t0 := addmod(t0, sub(p, delta_2), p)\\n            t1 := addmod(delta_2, sub(p, 2), p)\\n            t0 := mulmod(t0, t1, p)\\n            t1 := addmod(delta_2, sub(p, 3), p)\\n            t0 := mulmod(t0, t1, p)\\n            t0 := mulmod(t0, alpha_base, p)\\n            range_acc := addmod(range_acc, t0, p)\\n            alpha_base := mulmod(alpha_base, alpha, p)\\n\\n            t0 := mulmod(delta_3, delta_3, p)\\n            t0 := addmod(t0, sub(p, delta_3), p)\\n            t1 := addmod(delta_3, sub(p, 2), p)\\n            t0 := mulmod(t0, t1, p)\\n            t1 := addmod(delta_3, sub(p, 3), p)\\n            t0 := mulmod(t0, t1, p)\\n            t0 := mulmod(t0, alpha_base, p)\\n            range_acc := addmod(range_acc, t0, p)\\n            alpha_base := mulmod(alpha_base, alpha, p)\\n\\n            t0 := mulmod(delta_4, delta_4, p)\\n            t0 := addmod(t0, sub(p, delta_4), p)\\n            t1 := addmod(delta_4, sub(p, 2), p)\\n            t0 := mulmod(t0, t1, p)\\n            t1 := addmod(delta_4, sub(p, 3), p)\\n            t0 := mulmod(t0, t1, p)\\n            t0 := mulmod(t0, alpha_base, p)\\n            range_acc := addmod(range_acc, t0, p)\\n            alpha_base := mulmod(alpha_base, alpha, p)\\n\\n            range_acc := mulmod(range_acc, linear_challenge, p)\\n        }\\n\\n        challenges.alpha_base = alpha_base;\\n        return range_acc;\\n    }\\n\\n    // Compute grand product opening scalar and perform kate verification scalar multiplication\\n    function compute_grand_product_opening_group_element(\\n        Types.Proof memory proof,\\n        Types.VerificationKey memory vk,\\n        Types.ChallengeTranscript memory challenges,\\n        uint256 L1_fr\\n    ) internal view returns (Types.G1Point memory) {\\n        uint256 beta = challenges.beta;\\n        uint256 zeta = challenges.zeta;\\n        uint256 gamma = challenges.gamma;\\n        uint256 p = Bn254Crypto.r_mod;\\n        \\n        uint256 partial_grand_product;\\n        uint256 sigma_multiplier;\\n\\n        {\\n            uint256 w1 = proof.w1;\\n            uint256 sigma1 = proof.sigma1;\\n            assembly {\\n                let witness_term := addmod(w1, gamma, p)\\n                partial_grand_product := addmod(mulmod(beta, zeta, p), witness_term, p)\\n                sigma_multiplier := addmod(mulmod(sigma1, beta, p), witness_term, p)\\n            }\\n        }\\n        {\\n            uint256 w2 = proof.w2;\\n            uint256 sigma2 = proof.sigma2;\\n            assembly {\\n                let witness_term := addmod(w2, gamma, p)\\n                partial_grand_product := mulmod(partial_grand_product, addmod(mulmod(mulmod(zeta, 0x05, p), beta, p), witness_term, p), p)\\n                sigma_multiplier := mulmod(sigma_multiplier, addmod(mulmod(sigma2, beta, p), witness_term, p), p)\\n            }\\n        }\\n        {\\n            uint256 w3 = proof.w3;\\n            uint256 sigma3 = proof.sigma3;\\n            assembly {\\n                let witness_term := addmod(w3, gamma, p)\\n                partial_grand_product := mulmod(partial_grand_product, addmod(mulmod(mulmod(zeta, 0x06, p), beta, p), witness_term, p), p)\\n\\n                sigma_multiplier := mulmod(sigma_multiplier, addmod(mulmod(sigma3, beta, p), witness_term, p), p)\\n            }\\n        }\\n        {\\n            uint256 w4 = proof.w4;\\n            assembly {\\n                partial_grand_product := mulmod(partial_grand_product, addmod(addmod(mulmod(mulmod(zeta, 0x07, p), beta, p), gamma, p), w4, p), p)\\n            }\\n        }\\n        {\\n            uint256 linear_challenge = challenges.v10;\\n            uint256 alpha_base = challenges.alpha_base;\\n            uint256 alpha = challenges.alpha;\\n            uint256 separator_challenge = challenges.u;\\n            uint256 grand_product_at_z_omega = proof.grand_product_at_z_omega;\\n            uint256 l_start = L1_fr;\\n            assembly {\\n                partial_grand_product := mulmod(partial_grand_product, alpha_base, p)\\n\\n                sigma_multiplier := mulmod(mulmod(sub(p, mulmod(mulmod(sigma_multiplier, grand_product_at_z_omega, p), alpha_base, p)), beta, p), linear_challenge, p)\\n\\n                alpha_base := mulmod(mulmod(alpha_base, alpha, p), alpha, p)\\n\\n                partial_grand_product := addmod(mulmod(addmod(partial_grand_product, mulmod(l_start, alpha_base, p), p), linear_challenge, p), separator_challenge, p)\\n\\n                alpha_base := mulmod(alpha_base, alpha, p)\\n            }\\n            challenges.alpha_base = alpha_base;\\n        }\\n\\n        Types.G1Point memory Z = proof.Z;\\n        Types.G1Point memory SIGMA4 = vk.SIGMA4;\\n        Types.G1Point memory accumulator;\\n        Z.validateG1Point();\\n        SIGMA4.validateG1Point();\\n        bool success;\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, mload(Z))\\n            mstore(add(mPtr, 0x20), mload(add(Z, 0x20)))\\n            mstore(add(mPtr, 0x40), partial_grand_product)\\n            success := staticcall(gas(), 7, mPtr, 0x60, mPtr, 0x40)\\n\\n            mstore(add(mPtr, 0x40), mload(SIGMA4))\\n            mstore(add(mPtr, 0x60), mload(add(SIGMA4, 0x20)))\\n            mstore(add(mPtr, 0x80), sigma_multiplier)\\n            success := and(success, staticcall(gas(), 7, add(mPtr, 0x40), 0x60, add(mPtr, 0x40), 0x40))\\n            \\n            success := and(success, staticcall(gas(), 6, mPtr, 0x80, accumulator, 0x40))\\n        }\\n\\n        require(success, \\\"compute_grand_product_opening_scalar group operations failure\\\");\\n        return accumulator;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/cryptography/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Bn254Crypto library used for the fr, g1 and g2 point types\\n * @dev Used to manipulate fr, g1, g2 types, perform modular arithmetic on them and call\\n * the precompiles add, scalar mul and pairing\\n *\\n * Notes on optimisations\\n * 1) Perform addmod, mulmod etc. in assembly - removes the check that Solidity performs to confirm that\\n * the supplied modulus is not 0. This is safe as the modulus's used (r_mod, q_mod) are hard coded\\n * inside the contract and not supplied by the user\\n */\\nlibrary Types {\\n    uint256 constant PROGRAM_WIDTH = 4;\\n    uint256 constant NUM_NU_CHALLENGES = 11;\\n\\n    uint256 constant coset_generator0 = 0x0000000000000000000000000000000000000000000000000000000000000005;\\n    uint256 constant coset_generator1 = 0x0000000000000000000000000000000000000000000000000000000000000006;\\n    uint256 constant coset_generator2 = 0x0000000000000000000000000000000000000000000000000000000000000007;\\n\\n    // TODO: add external_coset_generator() method to compute this\\n    uint256 constant coset_generator7 = 0x000000000000000000000000000000000000000000000000000000000000000c;\\n\\n    struct G1Point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    // G2 group element where x \\\\in Fq2 = x0 * z + x1\\n    struct G2Point {\\n        uint256 x0;\\n        uint256 x1;\\n        uint256 y0;\\n        uint256 y1;\\n    }\\n\\n    // N>B. Do not re-order these fields! They must appear in the same order as they\\n    // appear in the proof data\\n    struct Proof {\\n        G1Point W1;\\n        G1Point W2;\\n        G1Point W3;\\n        G1Point W4;\\n        G1Point Z;\\n        G1Point T1;\\n        G1Point T2;\\n        G1Point T3;\\n        G1Point T4;\\n        uint256 w1;\\n        uint256 w2;\\n        uint256 w3;\\n        uint256 w4;\\n        uint256 sigma1;\\n        uint256 sigma2;\\n        uint256 sigma3;\\n        uint256 q_arith;\\n        uint256 q_ecc;\\n        uint256 q_c;\\n        uint256 linearization_polynomial;\\n        uint256 grand_product_at_z_omega;\\n        uint256 w1_omega;\\n        uint256 w2_omega;\\n        uint256 w3_omega;\\n        uint256 w4_omega;\\n        G1Point PI_Z;\\n        G1Point PI_Z_OMEGA;\\n        G1Point recursive_P1;\\n        G1Point recursive_P2;\\n        uint256 quotient_polynomial_eval;\\n    }\\n\\n    struct ChallengeTranscript {\\n        uint256 alpha_base;\\n        uint256 alpha;\\n        uint256 zeta;\\n        uint256 beta;\\n        uint256 gamma;\\n        uint256 u;\\n        uint256 v0;\\n        uint256 v1;\\n        uint256 v2;\\n        uint256 v3;\\n        uint256 v4;\\n        uint256 v5;\\n        uint256 v6;\\n        uint256 v7;\\n        uint256 v8;\\n        uint256 v9;\\n        uint256 v10;\\n    }\\n\\n    struct VerificationKey {\\n        uint256 circuit_size;\\n        uint256 num_inputs;\\n        uint256 work_root;\\n        uint256 domain_inverse;\\n        uint256 work_root_inverse;\\n        G1Point Q1;\\n        G1Point Q2;\\n        G1Point Q3;\\n        G1Point Q4;\\n        G1Point Q5;\\n        G1Point QM;\\n        G1Point QC;\\n        G1Point QARITH;\\n        G1Point QECC;\\n        G1Point QRANGE;\\n        G1Point QLOGIC;\\n        G1Point SIGMA1;\\n        G1Point SIGMA2;\\n        G1Point SIGMA3;\\n        G1Point SIGMA4;\\n        bool contains_recursive_proof;\\n        uint256 recursive_proof_indices;\\n        G2Point g2_x;\\n\\n        // zeta challenge raised to the power of the circuit size.\\n        // Not actually part of the verification key, but we put it here to prevent stack depth errors\\n        uint256 zeta_pow_n;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/VerificationKeys.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from '../cryptography/Types.sol';\\n\\nimport {Rollup1x1Vk} from '../keys/Rollup1x1Vk.sol';\\nimport {Rollup1x2Vk} from '../keys/Rollup1x2Vk.sol';\\nimport {Rollup1x4Vk} from '../keys/Rollup1x4Vk.sol';\\n\\nimport {Rollup28x1Vk} from '../keys/Rollup28x1Vk.sol';\\nimport {Rollup28x2Vk} from '../keys/Rollup28x2Vk.sol';\\nimport {Rollup28x4Vk} from '../keys/Rollup28x4Vk.sol';\\n// import {Rollup28x8Vk} from '../keys/Rollup28x8Vk.sol';\\n// import {Rollup28x16Vk} from '../keys/Rollup28x16Vk.sol';\\n// import {Rollup28x32Vk} from '../keys/Rollup28x32Vk.sol';\\n\\nimport {EscapeHatchVk} from '../keys/EscapeHatchVk.sol';\\n\\n/**\\n * @title Verification keys library\\n * @dev Used to select the appropriate verification key for the proof in question\\n */\\nlibrary VerificationKeys {\\n    /**\\n     * @param _keyId - verification key identifier used to select the appropriate proof's key\\n     * @return Verification key\\n     */\\n    function getKeyById(uint256 _keyId) external pure returns (Types.VerificationKey memory) {\\n        // added in order: qL, qR, qO, qC, qM. x coord first, followed by y coord\\n        Types.VerificationKey memory vk;\\n\\n        if (_keyId == 0) {\\n            vk = EscapeHatchVk.get_verification_key();\\n        } else if (_keyId == 1) {\\n            vk = Rollup1x1Vk.get_verification_key();\\n        } else if (_keyId == 2) {\\n            vk = Rollup1x2Vk.get_verification_key();\\n        } else if (_keyId == 4) {\\n            vk = Rollup1x4Vk.get_verification_key();\\n        } else if (_keyId == 32) {\\n            vk = Rollup28x1Vk.get_verification_key();\\n        } else if (_keyId == 64) {\\n            vk = Rollup28x2Vk.get_verification_key();\\n        } else if (_keyId == 128) {\\n            vk = Rollup28x4Vk.get_verification_key();\\n            // } else if (_keyId == 256) {\\n            //     vk = Rollup28x8Vk.get_verification_key();\\n            // } else if (_keyId == 512) {\\n            //     vk = Rollup28x16Vk.get_verification_key();\\n            // } else if (_keyId == 1024) {\\n            //     vk = Rollup28x32Vk.get_verification_key();\\n        } else {\\n            require(false, 'UNKNOWN_KEY_ID');\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/cryptography/Transcript.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from './Types.sol';\\nimport {Bn254Crypto} from './Bn254Crypto.sol';\\n\\n/**\\n * @title Transcript library\\n * @dev Generates Plonk random challenges\\n */\\nlibrary Transcript {\\n\\n    struct TranscriptData {\\n        bytes32 current_challenge;\\n    }\\n    \\n    /**\\n     * Compute keccak256 hash of 2 4-byte variables (circuit_size, num_public_inputs)\\n     */\\n    function generate_initial_challenge(\\n                TranscriptData memory self,\\n                uint256 circuit_size,\\n                uint256 num_public_inputs\\n    ) internal pure {\\n        bytes32 challenge;\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore8(add(mPtr, 0x20), shr(24, circuit_size))\\n            mstore8(add(mPtr, 0x21), shr(16, circuit_size))\\n            mstore8(add(mPtr, 0x22), shr(8, circuit_size))\\n            mstore8(add(mPtr, 0x23), circuit_size)           \\n            mstore8(add(mPtr, 0x24), shr(24, num_public_inputs))\\n            mstore8(add(mPtr, 0x25), shr(16, num_public_inputs))\\n            mstore8(add(mPtr, 0x26), shr(8, num_public_inputs))\\n            mstore8(add(mPtr, 0x27), num_public_inputs)\\n            challenge := keccak256(add(mPtr, 0x20), 0x08)\\n        }\\n        self.current_challenge = challenge;\\n    }\\n\\n    /**\\n     * We treat the beta challenge as a special case, because it includes the public inputs.\\n     * The number of public inputs can be extremely large for rollups and we want to minimize mem consumption.\\n     * => we directly allocate memory to hash the public inputs, in order to prevent the global memory pointer from increasing\\n     */\\n    function generate_beta_gamma_challenges(\\n        TranscriptData memory self,\\n        Types.ChallengeTranscript memory challenges,\\n        uint256 num_public_inputs\\n    ) internal pure  {\\n        bytes32 challenge;\\n        bytes32 old_challenge = self.current_challenge;\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 reduced_challenge;\\n        assembly {\\n            let m_ptr := mload(0x40)\\n            // N.B. If the calldata ABI changes this code will need to change!\\n            // We can copy all of the public inputs, followed by the wire commitments, into memory\\n            // using calldatacopy\\n            mstore(m_ptr, old_challenge)\\n            m_ptr := add(m_ptr, 0x20)\\n            let inputs_start := add(calldataload(0x04), 0x24)\\n            // num_calldata_bytes = public input size + 256 bytes for the 4 wire commitments\\n            let num_calldata_bytes := add(0x100, mul(num_public_inputs, 0x20))\\n            calldatacopy(m_ptr, inputs_start, num_calldata_bytes)\\n\\n            let start := mload(0x40)\\n            let length := add(num_calldata_bytes, 0x20)\\n\\n            challenge := keccak256(start, length)\\n            reduced_challenge := mod(challenge, p)\\n        }\\n        challenges.beta = reduced_challenge;\\n\\n        // get gamma challenge by appending 1 to the beta challenge and hash\\n        assembly {\\n            mstore(0x00, challenge)\\n            mstore8(0x20, 0x01)\\n            challenge := keccak256(0, 0x21)\\n            reduced_challenge := mod(challenge, p)\\n        }\\n        challenges.gamma = reduced_challenge;\\n        self.current_challenge = challenge;\\n    }\\n\\n    function generate_alpha_challenge(\\n        TranscriptData memory self,\\n        Types.ChallengeTranscript memory challenges,\\n        Types.G1Point memory Z\\n    ) internal pure  {\\n        bytes32 challenge;\\n        bytes32 old_challenge = self.current_challenge;\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 reduced_challenge;\\n        assembly {\\n            let m_ptr := mload(0x40)\\n            mstore(m_ptr, old_challenge)\\n            mstore(add(m_ptr, 0x20), mload(add(Z, 0x20)))\\n            mstore(add(m_ptr, 0x40), mload(Z))\\n            challenge := keccak256(m_ptr, 0x60)\\n            reduced_challenge := mod(challenge, p)\\n        }\\n        challenges.alpha = reduced_challenge;\\n        challenges.alpha_base = reduced_challenge;\\n        self.current_challenge = challenge;\\n    }\\n\\n    function generate_zeta_challenge(\\n        TranscriptData memory self,\\n        Types.ChallengeTranscript memory challenges,\\n        Types.G1Point memory T1,\\n        Types.G1Point memory T2,\\n        Types.G1Point memory T3,\\n        Types.G1Point memory T4\\n    ) internal pure  {\\n        bytes32 challenge;\\n        bytes32 old_challenge = self.current_challenge;\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 reduced_challenge;\\n        assembly {\\n            let m_ptr := mload(0x40)\\n            mstore(m_ptr, old_challenge)\\n            mstore(add(m_ptr, 0x20), mload(add(T1, 0x20)))\\n            mstore(add(m_ptr, 0x40), mload(T1))\\n            mstore(add(m_ptr, 0x60), mload(add(T2, 0x20)))\\n            mstore(add(m_ptr, 0x80), mload(T2))\\n            mstore(add(m_ptr, 0xa0), mload(add(T3, 0x20)))\\n            mstore(add(m_ptr, 0xc0), mload(T3))\\n            mstore(add(m_ptr, 0xe0), mload(add(T4, 0x20)))\\n            mstore(add(m_ptr, 0x100), mload(T4))\\n            challenge := keccak256(m_ptr, 0x120)\\n            reduced_challenge := mod(challenge, p)\\n        }\\n        challenges.zeta = reduced_challenge;\\n        self.current_challenge = challenge;\\n    }\\n\\n    /**\\n     * We compute our initial nu challenge by hashing the following proof elements (with the current challenge):\\n     *\\n     * w1, w2, w3, w4, sigma1, sigma2, sigma3, q_arith, q_ecc, q_c, linearization_poly, grand_product_at_z_omega,\\n     * w1_omega, w2_omega, w3_omega, w4_omega\\n     *\\n     * These values are placed linearly in the proofData, we can extract them with a calldatacopy call\\n     *\\n     */\\n    function generate_nu_challenges(TranscriptData memory self, Types.ChallengeTranscript memory challenges, uint256 quotient_poly_eval, uint256 num_public_inputs) internal pure\\n    {\\n        uint256 p = Bn254Crypto.r_mod;\\n        bytes32 current_challenge = self.current_challenge;\\n        uint256 base_v_challenge;\\n        uint256 updated_v;\\n\\n        // We want to copy SIXTEEN field elements from calldata into memory to hash\\n        // But we start by adding the quotient poly evaluation to the hash transcript\\n        assembly {\\n            // get a calldata pointer that points to the start of the data we want to copy\\n            let calldata_ptr := add(calldataload(0x04), 0x24)\\n            // skip over the public inputs\\n            calldata_ptr := add(calldata_ptr, mul(num_public_inputs, 0x20))\\n            // There are NINE G1 group elements added into the transcript in the `beta` round, that we need to skip over\\n            calldata_ptr := add(calldata_ptr, 0x240) // 9 * 0x40 = 0x240\\n\\n            let m_ptr := mload(0x40)\\n            mstore(m_ptr, current_challenge)\\n            mstore(add(m_ptr, 0x20), quotient_poly_eval)\\n            calldatacopy(add(m_ptr, 0x40), calldata_ptr, 0x200) // 16 * 0x20 = 0x200\\n            base_v_challenge := keccak256(m_ptr, 0x240) // hash length = 0x240, we include the previous challenge in the hash\\n            updated_v := mod(base_v_challenge, p)\\n        }\\n\\n        // assign the first challenge value\\n        challenges.v0 = updated_v;\\n\\n        // for subsequent challenges we iterate 10 times.\\n        // At each iteration i \\\\in [1, 10] we compute challenges.vi = keccak256(base_v_challenge, byte(i))\\n        assembly {\\n            mstore(0x00, base_v_challenge)\\n            mstore8(0x20, 0x01)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v1 = updated_v;\\n        assembly {\\n            mstore8(0x20, 0x02)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v2 = updated_v;\\n        assembly {\\n            mstore8(0x20, 0x03)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v3 = updated_v;\\n        assembly {\\n            mstore8(0x20, 0x04)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v4 = updated_v;\\n        assembly {\\n            mstore8(0x20, 0x05)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v5 = updated_v;\\n        assembly {\\n            mstore8(0x20, 0x06)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v6 = updated_v;\\n        assembly {\\n            mstore8(0x20, 0x07)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v7 = updated_v;\\n        assembly {\\n            mstore8(0x20, 0x08)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v8 = updated_v;\\n        assembly {\\n            mstore8(0x20, 0x09)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v9 = updated_v;\\n\\n        // update the current challenge when computing the final nu challenge\\n        bytes32 challenge;\\n        assembly {\\n            mstore8(0x20, 0x0a)\\n            challenge := keccak256(0x00, 0x21)\\n            updated_v := mod(challenge, p)\\n        }\\n        challenges.v10 = updated_v;\\n\\n        self.current_challenge = challenge;\\n    }\\n\\n    function generate_separator_challenge(\\n        TranscriptData memory self,\\n        Types.ChallengeTranscript memory challenges,\\n        Types.G1Point memory PI_Z,\\n        Types.G1Point memory PI_Z_OMEGA\\n    ) internal pure  {\\n        bytes32 challenge;\\n        bytes32 old_challenge = self.current_challenge;\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 reduced_challenge;\\n        assembly {\\n            let m_ptr := mload(0x40)\\n            mstore(m_ptr, old_challenge)\\n            mstore(add(m_ptr, 0x20), mload(add(PI_Z, 0x20)))\\n            mstore(add(m_ptr, 0x40), mload(PI_Z))\\n            mstore(add(m_ptr, 0x60), mload(add(PI_Z_OMEGA, 0x20)))\\n            mstore(add(m_ptr, 0x80), mload(PI_Z_OMEGA))\\n            challenge := keccak256(m_ptr, 0xa0)\\n            reduced_challenge := mod(challenge, p)\\n        }\\n        challenges.u = reduced_challenge;\\n        self.current_challenge = challenge;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface IVerifier {\\n    function verify(bytes memory serialized_proof, uint256 _keyId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/Rollup1x1Vk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from '../cryptography/Types.sol';\\nimport {Bn254Crypto} from '../cryptography/Bn254Crypto.sol';\\n\\nlibrary Rollup1x1Vk {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n\\n    function get_verification_key() internal pure returns (Types.VerificationKey memory) {\\n        Types.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 1048576) // vk.circuit_size\\n            mstore(add(vk, 0x20), 42) // vk.num_inputs\\n            mstore(add(vk, 0x40),0x26125da10a0ed06327508aba06d1e303ac616632dbed349f53422da953337857) // vk.work_root\\n            mstore(add(vk, 0x60),0x30644b6c9c4a72169e4daa317d25f04512ae15c53b34e8f5acd8e155d0a6c101) // vk.domain_inverse\\n            mstore(add(vk, 0x80),0x100c332d2100895fab6473bc2c51bfca521f45cb3baca6260852a8fde26c91f3) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x1804131c3d59730a878c2c90bf7a8e92dcbc8818cad7fa05ce59c6e003622cbd)//vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x29633c3ccc2672f96b91f267038cc21954796db70a00be8fa2e1a7fd928897e6)\\n            mstore(mload(add(vk, 0xc0)), 0x23adc38a1ae3b72f247d19af6d25246eb318ec240e9758f3def26a22ce96f78c)//vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x029a3ac4859d4daefd31ace1e4d4e8be42bac8bec59072c7237981f6a51119ad)\\n            mstore(mload(add(vk, 0xe0)), 0x182c598275a8bef5cdfe13e33f6f78ee77ed1dd2dd922b891b75ff26fe534ad9)//vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x1802d768f37d7433a3274c7bf3e0a5e3d444b270518d3657fc1797cd993561fd)\\n            mstore(mload(add(vk, 0x100)), 0x0c16e10a13db828f1a6137846d9420cc11bdcd19edff05f39b9e47b3bf953cc4)//vk.Q4\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x20bea7e7fe545095d527471ad4126b7e29825b9f793b7346e9f305af5da2eb23)\\n            mstore(mload(add(vk, 0x120)), 0x21a24f3a3e29898912ae459fa0ab70956ba72568f6342d253418e782b698a889)//vk.Q5\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x14ed25ebfac646df91a7680393ba7a8e676432cea41b0e7369bb8e015e482768)\\n            mstore(mload(add(vk, 0x140)), 0x15015be7c1b812fbc9ece949280a3ec00609a804dfc7daa900c521d8c064e741)//vk.QM\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x0255d44470e7e772c2c4040ef570209ab2146363892e29e33b4504e4d0efedec)\\n            mstore(mload(add(vk, 0x160)), 0x2aefe20fdb7b5707bdce750a898c22f98162781259a79af988a08dfc0a7bf460)//vk.QC\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x15588c8c150fdc0a0b7f33f4f947e4a8bee341d818be831ef70f1de63781b0fd)\\n            mstore(mload(add(vk, 0x180)), 0x2358a82f2b4ac8dca370633aec9b9a197298cdd9cb3e17a621af87b32ee93757)//vk.QARITH\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x2cf113fadcd3e7e063e6578ec0f56d5c46eef945110fd8f2177c8b975fc4cf31)\\n            mstore(mload(add(vk, 0x1a0)), 0x2464fe0f03bc3bf549ea6ea21682df575c8eee941862d3d902f5bef0c6c5073d)//vk.QECC\\n            mstore(add(mload(add(vk, 0x1a0)), 0x20), 0x16b24942e04cb035a4f3700678045982dfb410130368fc79640e3bf81f3d1695)\\n            mstore(mload(add(vk, 0x1c0)), 0x22636011e2ce575ead19c67228b4365423e88020d07fcedaa69831bcfa518546)//vk.QRANGE\\n            mstore(add(mload(add(vk, 0x1c0)), 0x20), 0x0dff1aad3f8761befdc296e8dd700858986ebf6a5672d03625ff285fd8dd5baf)\\n            mstore(mload(add(vk, 0x1e0)), 0x20735c1704fee325f652a4a61b3fe620130f9c868d6430f9ace2a782e4cd474e)//vk.QLOGIC\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x217a0dc7aa32d5ec9f686718931304a9673229626cbfa0d9e30501e546331f4b)\\n            mstore(mload(add(vk, 0x200)), 0x1b876e58c3e492d958a50dc55cd34dd803e2d65c20ceab7583bd03075f941271)//vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x200)), 0x20), 0x064157f081aacc17e9f9302b0ac04d57b894d246c6bd9c1a35909f7aec32396e)\\n            mstore(mload(add(vk, 0x220)), 0x2b07921e484eb516fbcd9dbd7f240e7303b9dee2e0dc94af6e452b6e77043535)//vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x220)), 0x20), 0x0dd1e0de46643e1026db67650cd6da0f3f2da26de14b0f40524f148bfe5baa1e)\\n            mstore(mload(add(vk, 0x240)), 0x2b4255c35cd84d61f1d08d057f08960fa2fe9360926e2dd2a59e550b28528026)//vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x240)), 0x20), 0x0d926587501dc3da56736d6298f39216b1f32ae30245909f321205f936001605)\\n            mstore(mload(add(vk, 0x260)), 0x09add5431f947970c0f4e3d3caf27431f09469810218091b0d244d858d9a89b9)//vk.SIGMA4\\n            mstore(add(mload(add(vk, 0x260)), 0x20), 0x295e44c62bc6face1c3c7fde15e6af5fe7930ac6de83b9635ace5395c1c47c4e)\\n            mstore(add(vk, 0x280), 0x01) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x2a0), 26) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x2c0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x2c0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/Rollup1x2Vk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from '../cryptography/Types.sol';\\nimport {Bn254Crypto} from '../cryptography/Bn254Crypto.sol';\\n\\nlibrary Rollup1x2Vk {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n\\n    function get_verification_key() internal pure returns (Types.VerificationKey memory) {\\n        Types.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 2097152) // vk.circuit_size\\n            mstore(add(vk, 0x20), 54) // vk.num_inputs\\n            mstore(add(vk, 0x40),0x1ded8980ae2bdd1a4222150e8598fc8c58f50577ca5a5ce3b2c87885fcd0b523) // vk.work_root\\n            mstore(add(vk, 0x60),0x30644cefbebe09202b4ef7f3ff53a4511d70ff06da772cc3785d6b74e0536081) // vk.domain_inverse\\n            mstore(add(vk, 0x80),0x19c6dfb841091b14ab14ecc1145f527850fd246e940797d3f5fac783a376d0f0) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x2687ed9b44aec736bc99172ed962a6183cc72976ea02c71335d829d3ad64b084)//vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x1f4ec5c8450f7734d16efdf432cda63197e8f2f2b298f93023ba3ae4e1363f0d)\\n            mstore(mload(add(vk, 0xc0)), 0x1b752efd914bbceb7b25c5117478db6d4390f3b47612f83c8a96f4780926b06f)//vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x1974a9d6db2c8da463af3c6eba886c6e6e1e27d6b199ac80a783d790f29d38ff)\\n            mstore(mload(add(vk, 0xe0)), 0x1ef5a0a59b3b6bafee6555671817a74b831e56ab6fe10affd486ce8b17d41585)//vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x0c56d219136bb97fc64ac4d21a81f3375e68c30bc19100b6e91bbcbcb5a1c81a)\\n            mstore(mload(add(vk, 0x100)), 0x1f27d0f27790b9b54089b6d4cf6753665c8e4fcd7d5332ed68a11c24297aa8a5)//vk.Q4\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x012543acb47293aa56293e9795aad4f0723217954f05ec91b3024de0bc630351)\\n            mstore(mload(add(vk, 0x120)), 0x04072b0a6b300b05d31e16ecc4c4c5d24cc325d90728ed15305d1a804233f94f)//vk.Q5\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x1b286071b0a083bdb26af1584fdf83c465745404ce1cf2b8b349154cc2e0580a)\\n            mstore(mload(add(vk, 0x140)), 0x24e87dc9bd6343226fe885af9f30da07c22d23c35a93dcd6cf3258e08c3fb435)//vk.QM\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x0ceed4102b3a4e272c30c9098ba676518ea4cef6c469a8c3dbaec2e0df17339b)\\n            mstore(mload(add(vk, 0x160)), 0x24367bab720c963fd48c02b9284db8f8c7171514c143c8c7282557ab94091c91)//vk.QC\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x181d6c7211dec885d0ee3e81de3e6c43a77dbcb0cad88a3c3988572f621120f3)\\n            mstore(mload(add(vk, 0x180)), 0x2f50fd42e3b7d84db82e7252791073d4622cd1d3993d657deacf0879edf7e8ab)//vk.QARITH\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x0d891e8d949a242b3430e33247bb95636bde08c062150f61408685e17ec61838)\\n            mstore(mload(add(vk, 0x1a0)), 0x0aad547972b3b99db5233ada23dfa01701d0d50bb2cd2d8919174e6e3551d5c3)//vk.QECC\\n            mstore(add(mload(add(vk, 0x1a0)), 0x20), 0x2fa67d69cb906af7ef46bafcde68f97a80f002bb52bf573341e577c55a428a36)\\n            mstore(mload(add(vk, 0x1c0)), 0x035bb3d3ea11cee216b5fbcb0654c7abdf976d53196bb24f6414b9ccce34b857)//vk.QRANGE\\n            mstore(add(mload(add(vk, 0x1c0)), 0x20), 0x1cd877aed87b33e713def94b9e913a7f60a07109d32c3aef18097bb802e6a6b7)\\n            mstore(mload(add(vk, 0x1e0)), 0x2956cd5126b44362be7d9d9bc63ac056d6da0f952aa17cfcf9c79929b95477a1)//vk.QLOGIC\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x19fe15891be1421df2599a8b0bd3f0e0b852abc71fdc7b0ccecfe42a5b7f7198)\\n            mstore(mload(add(vk, 0x200)), 0x0d2920f8b4371da02f7bdd75b02d8d228c93b3c2f625d2471aab68b20d05f505)//vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x200)), 0x20), 0x0a01f6841b6a7eff29a6bf75ea4678730aa46ea3d5022848592e646bb7519fb5)\\n            mstore(mload(add(vk, 0x220)), 0x156e51d3f6a9da2cc16546dd19885209c4bfa877c31740f20a8fadb18cc10de4)//vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x220)), 0x20), 0x27ad9a3d5128ddac2f0a622b79b0a794e57467bc58915f7b6fc1079cb903bea2)\\n            mstore(mload(add(vk, 0x240)), 0x0644e778608ead638cfa9f80121db8625f32bdde00b3c8b69fe8b47eb835cf8b)//vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x240)), 0x20), 0x1a01d5e3ea31cfb33a101a23d5334b60ab133a971ec915a2324ec36326a80d4c)\\n            mstore(mload(add(vk, 0x260)), 0x02f9fa9352324ead3f37993f25eb36adbe46ed924969de68ae29bd1d20bb2e8a)//vk.SIGMA4\\n            mstore(add(mload(add(vk, 0x260)), 0x20), 0x1291ebfd5412132209c8da19817f4663de67cace2a5cd49aeac51f4c53be946f)\\n            mstore(add(vk, 0x280), 0x01) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x2a0), 38) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x2c0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x2c0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/Rollup1x4Vk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from '../cryptography/Types.sol';\\nimport {Bn254Crypto} from '../cryptography/Bn254Crypto.sol';\\n\\nlibrary Rollup1x4Vk {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n\\n    function get_verification_key() internal pure returns (Types.VerificationKey memory) {\\n        Types.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 4194304) // vk.circuit_size\\n            mstore(add(vk, 0x20), 78) // vk.num_inputs\\n            mstore(add(vk, 0x40),0x1ad92f46b1f8d9a7cda0ceb68be08215ec1a1f05359eebbba76dde56a219447e) // vk.work_root\\n            mstore(add(vk, 0x60),0x30644db14ff7d4a4f1cf9ed5406a7e5722d273a7aa184eaa5e1fb0846829b041) // vk.domain_inverse\\n            mstore(add(vk, 0x80),0x2eb584390c74a876ecc11e9c6d3c38c3d437be9d4beced2343dc52e27faa1396) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x2434f5ca53c70c4d5f17108dd67714fa33fade52f81d51efd48705e9e55241cd)//vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x006251f85cf12be169e9a085007637c5bdf9a52400f744f898f8684af4cbc78e)\\n            mstore(mload(add(vk, 0xc0)), 0x0ab632649004dc62f030fe0f31ace69ae575554fc4d11bee7cf941f16d6943de)//vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x02268c44dfb0b47c69108bd8b5edfaa53df4980a35f9546152730c41c06c0e44)\\n            mstore(mload(add(vk, 0xe0)), 0x16ad086667ae816423cf12a52d68415601ba583d6f13766f4fc36010422a70f4)//vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x0187c575705895a4a3642d6859d36afb838f85790e5870ca09cbe8027b0ebe67)\\n            mstore(mload(add(vk, 0x100)), 0x11fa05498a27bc35ebd32baceca58a061b13481223ba25307c65929776b58739)//vk.Q4\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x18bec637b3b7729cb595012283fa2bbc0d7f61bb7a869a767cadcd42e9dd3e35)\\n            mstore(mload(add(vk, 0x120)), 0x2788137533de6d10b7d67109cbaaf3c73f2319af8bb402080199dddd5e502da9)//vk.Q5\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x1c3fe4f3ee71fd4027ceff16ff6e33cfe61d3b1b28888b0159a4ea97eb896658)\\n            mstore(mload(add(vk, 0x140)), 0x264a9cac82e600564a5372feacf7f2cbc08ae6656e2d762eea6a48360c8a9968)//vk.QM\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x1a36b4e6148ec37b8eed5d623e06d81804fc8834708592e20544b5d9e3c91f51)\\n            mstore(mload(add(vk, 0x160)), 0x05f4b572eaa65393f2b63b6c824a79af1043ae79f6706f79d3be245d20bda756)//vk.QC\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x20935fc1adc0987f4c76f79abe5d9eb5002882993a58846fdcc61202ffe38c05)\\n            mstore(mload(add(vk, 0x180)), 0x12841b0ae4282c1c01655cb6e8426414a1a39b68c762285b708ec9014740c085)//vk.QARITH\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x0a325f616a9aadae6861b79fd3d30cb86c3ec7fcd31fc107eeef28bd97b59226)\\n            mstore(mload(add(vk, 0x1a0)), 0x1b9edae6ed8cc00c6f8e62f43a03071e8d168dbd97386a1e9ad0e603a6e96cda)//vk.QECC\\n            mstore(add(mload(add(vk, 0x1a0)), 0x20), 0x1315c8e889dcf4daf9b14712a0c3ba8de5310674a196d4f7c5c8f14e4d60d2a4)\\n            mstore(mload(add(vk, 0x1c0)), 0x290883179d3796b4d6bbce70adec1b9b76c2fd5744bf8275b19850f5d2739817)//vk.QRANGE\\n            mstore(add(mload(add(vk, 0x1c0)), 0x20), 0x3058ee1e47a36d540530b4113c7156ec3e7bd907e805a19928c04b962a953370)\\n            mstore(mload(add(vk, 0x1e0)), 0x27cda6c91bb4d3077580b03448546ca1ad7535e7ba0298ce8e6d809ee448b42a)//vk.QLOGIC\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x02f356e126f28aa1446d87dd22b9a183c049460d7c658864cdebcf908fdfbf2b)\\n            mstore(mload(add(vk, 0x200)), 0x2dbafbc4667551f312ba1e14c0c02f1e21a507ba89cc6b43f50506f3ed130098)//vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x200)), 0x20), 0x21b49d4d7da26f536f4003f483bdd9a3857164007936a642ac5cbe35dd10e69b)\\n            mstore(mload(add(vk, 0x220)), 0x036d08d23ea8281c2f1b401bec96bb3561b825ebc87491ba9dce5b2a03e67b83)//vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x220)), 0x20), 0x125ea463b888e42436cbffb49b27c340072edcab06cebd66814b6f71acb59a96)\\n            mstore(mload(add(vk, 0x240)), 0x0763fe7c9a67f9bb6025eb47717d1523ae606abc807ed6f16fdffe0de5ce3597)//vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x240)), 0x20), 0x1428160f56926ed37cae2ee3de9a3996b63c991fa885121dd7c6013d2921e6db)\\n            mstore(mload(add(vk, 0x260)), 0x06ce65857f9f4580eee392740fd1e9bf944312a6d718b555a9688e6259279caa)//vk.SIGMA4\\n            mstore(add(mload(add(vk, 0x260)), 0x20), 0x1e16e263733a9c3db51bbacd70872580c90a0dedc13cc0d0cada208a3d8c80ce)\\n            mstore(add(vk, 0x280), 0x01) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x2a0), 62) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x2c0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x2c0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/Rollup28x1Vk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from '../cryptography/Types.sol';\\nimport {Bn254Crypto} from '../cryptography/Bn254Crypto.sol';\\n\\nlibrary Rollup28x1Vk {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n\\n    function get_verification_key() internal pure returns (Types.VerificationKey memory) {\\n        Types.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 1048576) // vk.circuit_size\\n            mstore(add(vk, 0x20), 414) // vk.num_inputs\\n            mstore(add(vk, 0x40),0x26125da10a0ed06327508aba06d1e303ac616632dbed349f53422da953337857) // vk.work_root\\n            mstore(add(vk, 0x60),0x30644b6c9c4a72169e4daa317d25f04512ae15c53b34e8f5acd8e155d0a6c101) // vk.domain_inverse\\n            mstore(add(vk, 0x80),0x100c332d2100895fab6473bc2c51bfca521f45cb3baca6260852a8fde26c91f3) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x2196fca99cdf384fd4d16c84f7c8f203d2d83b53270d0ca999ddc0261d7b911c)//vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x2fdf6b9cb188a0fb39630fdd70eee6ab565e1590a3fbd99ff7084aec7e023c60)\\n            mstore(mload(add(vk, 0xc0)), 0x10daf1db0872adaf0f8b6a7ca3a4323db0e6032436f60b4d8107a333343935db)//vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x07cd7fd5d20f1f145bac6caf6dfeecdf94c448d4f737d2e887c1d05c95a4eea0)\\n            mstore(mload(add(vk, 0xe0)), 0x0716d0c8ecd5f4de245505802ffc9f3b600b4f363aaeb5f1e6bae609c34e9ec0)//vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x180b0f77e48ddb0148866b58ca0729d088cadaa81cb791f476b202851ada0dd6)\\n            mstore(mload(add(vk, 0x100)), 0x17f67f82a53f726931c94d68e1b1c85255a6c9fae9b4a5c3400b35a4f91bacc1)//vk.Q4\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x0588ed9770ebbdba2f33304a04e80eb9606935d2a6d270019052bc18b46ded7d)\\n            mstore(mload(add(vk, 0x120)), 0x020c2dc4dc94d2a51cdf59997b0f0a2e49239325033162de576f33afe6234015)//vk.Q5\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x2cf542e642ef2b92c7ba41c2ade86510826c70a59b5556b8423563252e517bf5)\\n            mstore(mload(add(vk, 0x140)), 0x14621110b991356af79ae17112ea874144c39c520d8fa258ebc57246cdfbea75)//vk.QM\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x0ac77e8fb752574a51837c968760ee3c3e1fd74094a1ecf36d2531114435b3cc)\\n            mstore(mload(add(vk, 0x160)), 0x1fa9aa774c5bbf552f5fb24a9b66f90561a50d5e9c8a230b47485eedf66997c8)//vk.QC\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x0baa4ef83dfbfbad77f2deea7b970f7c26945d52a569622bf9ed583f1b003b3b)\\n            mstore(mload(add(vk, 0x180)), 0x2619d4bcb4171a3a0cd4f369ff676178c269a58620ecbe6a3c3fcfc546aec396)//vk.QARITH\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x1f8db7de67d896a210afaa1e3708ae6a78c4e938a8c18d9107956051ec72b071)\\n            mstore(mload(add(vk, 0x1a0)), 0x0c45250be3d1aef45f00bd2d6a7089212a937bebd4a15e95225440d0c6e4c76f)//vk.QECC\\n            mstore(add(mload(add(vk, 0x1a0)), 0x20), 0x294d8b005b9e0bff4da7e2a6bc7c9a888cdffa69b05f783ea1c3604429fea63a)\\n            mstore(mload(add(vk, 0x1c0)), 0x17ca617c07a352cc3ffed601db32f9865754eca3000a8d85c5dcec9c2de64a15)//vk.QRANGE\\n            mstore(add(mload(add(vk, 0x1c0)), 0x20), 0x106900630a849ed16000076caab5eea0d263fdf2bf255d9fda10917830596b0c)\\n            mstore(mload(add(vk, 0x1e0)), 0x01902b1a4652cb8eeaf73c03be6dd9cc46537a64f691358f31598ea108a13b37)//vk.QLOGIC\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x13484549915a2a4bf652cc3200039c60e5d4e3097632590ac89ade0957f4e474)\\n            mstore(mload(add(vk, 0x200)), 0x2964ce100082204c2de4d88fe9385ed8aeb29c5925bfdda01bcfe751c28d809f)//vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x200)), 0x20), 0x1524cdae86827dca0474e731c93cc09c63e4ca57135038765994898d8ee5e82a)\\n            mstore(mload(add(vk, 0x220)), 0x00c32810272471549f6a543ec669ed4480f763fdd3febf0101de32207ca8f004)//vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x220)), 0x20), 0x05119b3735e392d40ec63b0ea3c72fa6191193c2a2c547ec096374d54c0e8700)\\n            mstore(mload(add(vk, 0x240)), 0x256f35341ebe2a24762259d96797df05b0d884de43ed0f4cc3a182ffc697ffd2)//vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x240)), 0x20), 0x13f43715bba65b01a130cd9885a556e1e39b7dce4aba4d74cbe44bff706b780e)\\n            mstore(mload(add(vk, 0x260)), 0x1d8bf7ba423e0bc6b0e7adbc502115cb8cd67c890cdaf1858211bf65874411a4)//vk.SIGMA4\\n            mstore(add(mload(add(vk, 0x260)), 0x20), 0x2e0e1242399d885a8a33418d348d8099fdfc7a70e9df05832059ac6ab348f5a2)\\n            mstore(add(vk, 0x280), 0x01) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x2a0), 398) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x2c0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x2c0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/Rollup28x2Vk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from '../cryptography/Types.sol';\\nimport {Bn254Crypto} from '../cryptography/Bn254Crypto.sol';\\n\\nlibrary Rollup28x2Vk {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n\\n    function get_verification_key() internal pure returns (Types.VerificationKey memory) {\\n        Types.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 2097152) // vk.circuit_size\\n            mstore(add(vk, 0x20), 798) // vk.num_inputs\\n            mstore(add(vk, 0x40),0x1ded8980ae2bdd1a4222150e8598fc8c58f50577ca5a5ce3b2c87885fcd0b523) // vk.work_root\\n            mstore(add(vk, 0x60),0x30644cefbebe09202b4ef7f3ff53a4511d70ff06da772cc3785d6b74e0536081) // vk.domain_inverse\\n            mstore(add(vk, 0x80),0x19c6dfb841091b14ab14ecc1145f527850fd246e940797d3f5fac783a376d0f0) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x083eec82f54876c5f79fe64d804d9b939a4151dcac6d8617b3d6099866a0f77e)//vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x1d88766a559cbf8dbb94eab290f1b709b8c4c1950fde35d10256879d594f4fb0)\\n            mstore(mload(add(vk, 0xc0)), 0x1735a313d5f63d25ad1ceab7c79fd02e8c399fca8ef16ea2c783c5cd6a065925)//vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x267d598d81622c1cc210990690b4d9dad3824339b6de77e6281e0b3a1ef12ff7)\\n            mstore(mload(add(vk, 0xe0)), 0x149881c31dbf92050731c54853e1dbffce5e432bbedbd6701d7f6ebcc9e86661)//vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x01b4cc111e156304b4af0da5d44df4da0a14f50810ec390cec47639809adb97f)\\n            mstore(mload(add(vk, 0x100)), 0x200e37ec9a0ffaa0e25ae88f7891ba70c6eebd088ae5e7a58b1bd758e0839067)//vk.Q4\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x06928009896114dc84ac0de71d224afdfb4267dee32a66dd95be05a33ebac2f2)\\n            mstore(mload(add(vk, 0x120)), 0x171bd670606e79bfd4bee7a904535a6c687c08e32b110942bcb8cd1bd082240e)//vk.Q5\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x02bd31be051b434e285d81c6d956b5a72140916427c8879357d75252c5001813)\\n            mstore(mload(add(vk, 0x140)), 0x080637fa943079b3905b2171d3d03e57a34af325c36d6832563a8c05f102d809)//vk.QM\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x22288d0eeb954a0dd52f1ac95901d35de729c89f7f6defcbfbd8762ee56d5726)\\n            mstore(mload(add(vk, 0x160)), 0x242c1cb27ab6c727f4f543e6c12e1a03dabcab2201fea3a054da1b8fa8886815)//vk.QC\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x2e852fe5eced4ff84316eb02647b450d7b1f0cd6b7789581858f9f53b2ee5b97)\\n            mstore(mload(add(vk, 0x180)), 0x133ec8621fbd6894063a5c4a636a87758694e374344c9ca10c259a44ee1c594a)//vk.QARITH\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x18879c87e928f11b93a567935298d09e734ccf5cea51c755d6aa0bc23dd840a6)\\n            mstore(mload(add(vk, 0x1a0)), 0x214f7db081debb408f865a226cf017346cc2b06f3f6ff7ac7fbfb35877a87a36)//vk.QECC\\n            mstore(add(mload(add(vk, 0x1a0)), 0x20), 0x1fd8ca5d3daee196ea279e97c1d6d8048b4c90185a49b1f3a1063c6a4e09044e)\\n            mstore(mload(add(vk, 0x1c0)), 0x015968f39bf53733220cf5277c47c7b6bd5dc05ef53cafb6547b3a2343d43d54)//vk.QRANGE\\n            mstore(add(mload(add(vk, 0x1c0)), 0x20), 0x05f18632da7092477f0ddeb08174ca6aa81104d37d98fe3838831612b375fd02)\\n            mstore(mload(add(vk, 0x1e0)), 0x27257a08dffe29b8e4bf78a9844d01fd808ee8f6e7d419b4e348cdf7d4ab686e)//vk.QLOGIC\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x11ee0a08f3d883b9eecc693f4c03f1b15356393c5b617da28b96dc5bf9236a91)\\n            mstore(mload(add(vk, 0x200)), 0x080083de43db5d2797be31d60b174cfeb2bc473b4e6acc3a0d2c54e853faff79)//vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x200)), 0x20), 0x022b3876a88df3c53766c6a8caf399e9b4de3c2d64b6cc080aac85be97dad8fe)\\n            mstore(mload(add(vk, 0x220)), 0x073fdc8c514c0819d3f8247a228bdfb702dc42c315f092a3d4a68ec8c4258bb0)//vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x220)), 0x20), 0x22d229466abdf8460d69afc325fc9337fe5153c7e35f3a6727d70491d512afc4)\\n            mstore(mload(add(vk, 0x240)), 0x09cc150da825c5e6828a07fd571bbaa40daa350d9cdb93d5422637dbede4832a)//vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x240)), 0x20), 0x20a923804888ce991a0dcfc252eeb4969ffc2615aab03fa3189e8e090c8cb6fe)\\n            mstore(mload(add(vk, 0x260)), 0x15075967867a50974b5ff84e2dfa0ca762898a302b9163f45be68fe653b8fee1)//vk.SIGMA4\\n            mstore(add(mload(add(vk, 0x260)), 0x20), 0x1c314b0f1d0722f5e32dfdc007f584aab7513a08a61eb53d850f1453f97de23a)\\n            mstore(add(vk, 0x280), 0x01) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x2a0), 782) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x2c0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x2c0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/Rollup28x4Vk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from '../cryptography/Types.sol';\\nimport {Bn254Crypto} from '../cryptography/Bn254Crypto.sol';\\n\\nlibrary Rollup28x4Vk {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n\\n    function get_verification_key() internal pure returns (Types.VerificationKey memory) {\\n        Types.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 4194304) // vk.circuit_size\\n            mstore(add(vk, 0x20), 1566) // vk.num_inputs\\n            mstore(add(vk, 0x40),0x1ad92f46b1f8d9a7cda0ceb68be08215ec1a1f05359eebbba76dde56a219447e) // vk.work_root\\n            mstore(add(vk, 0x60),0x30644db14ff7d4a4f1cf9ed5406a7e5722d273a7aa184eaa5e1fb0846829b041) // vk.domain_inverse\\n            mstore(add(vk, 0x80),0x2eb584390c74a876ecc11e9c6d3c38c3d437be9d4beced2343dc52e27faa1396) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x2235e845ffffce329781d42d3749a3e979e32056259764e53ed87c0a7fbb7621)//vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x16ed97eb129ac46aa1793c34064f4dfbed9bef7a04b0833393375a9fa4bd8f27)\\n            mstore(mload(add(vk, 0xc0)), 0x04d9bc6b231782b964ac52bb8a541ae7afdc15cd77e163ef5003db84bee9db67)//vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x15aa1a98129ad341f224e0c6cb0ccf7140f80a6c3b2818b97756d29750cdf65b)\\n            mstore(mload(add(vk, 0xe0)), 0x2b51c97692a31d58050514812c665e88f0693cfd2b1f1700e7b292f38f131eab)//vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x02293ffef9cd3633dc81263189eddaf25229cfd885c2841fd7c649038e0cba99)\\n            mstore(mload(add(vk, 0x100)), 0x0cdbc42be8e617333076b89441a6e3fe4531efc53379f26e40713dcd6581f254)//vk.Q4\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x1d3f54958bcef1bfa5c609888bc5473b7b786d55eaeccd123ce527eae46039c0)\\n            mstore(mload(add(vk, 0x120)), 0x11780fe296089b6cfa66ccc42e58e52ea8fff5ffb1f16126385998381e5701df)//vk.Q5\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x01805831da0d3467b60c0e97e97028b5407531dce50fceb99ed270c53be75be2)\\n            mstore(mload(add(vk, 0x140)), 0x162382cda216393cc1032930468becada75a61b4b699954a8d3354665e7bd864)//vk.QM\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x16bd9cc0531489d3e1a1bb313936eac2944df9ee2095d7f3b4436ad368ab7491)\\n            mstore(mload(add(vk, 0x160)), 0x126eb9f99b5ec84ef9bcbc7c5a57dbb0a0f9a108edb51b98afa9c06090ba5e53)//vk.QC\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x0a8d881f16d4a2eb9cb4d9ad35eab95cbca0bcf9f37d8c45e1b71a7394430c05)\\n            mstore(mload(add(vk, 0x180)), 0x28275156dc2830093090dcdfd84ca7de6c32951bc8090358e2400c5e0fd318ff)//vk.QARITH\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x0c99a03aab57b6ec2ad4317b10bab925dd8180bd37a38b28167bd387833cc305)\\n            mstore(mload(add(vk, 0x1a0)), 0x0c5a55334e5f488c8c8d0b3a570d4427f5d6270fe9ed7c2f372a997afbe8df3f)//vk.QECC\\n            mstore(add(mload(add(vk, 0x1a0)), 0x20), 0x2c152400afb3d41599e7a760ef2bd44a4cfca97f8d7375eb50664470bf90628d)\\n            mstore(mload(add(vk, 0x1c0)), 0x0d1778269b54ec38bafd8448e85469acf21c56fe52072d12ddc5519ff0ff929b)//vk.QRANGE\\n            mstore(add(mload(add(vk, 0x1c0)), 0x20), 0x1b13450aed355f85cddc35c3517baea1f0c30780b948c302e9dc781e0843cff1)\\n            mstore(mload(add(vk, 0x1e0)), 0x2c1e3dfcae155cfe932bab710d284da6b03cb5d0d2e2bc1a68534213e56f3b9a)//vk.QLOGIC\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x1edf920496e650dcf4454ac2b508880f053447b19a83978f915744c979df19b9)\\n            mstore(mload(add(vk, 0x200)), 0x123e690dd753c7a133628947416d2763b11e6611e9f84a2d6806884ef30adcfa)//vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x200)), 0x20), 0x2ca133f04ad92a1a6011791c68cadb450df32f4c4def0fff9a1d79da2c193bb9)\\n            mstore(mload(add(vk, 0x220)), 0x03ce75b2d7b5fe33e7fc4e5d6a9c280c7e85919179a3ba684c081bf55ffcdba8)//vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x220)), 0x20), 0x0ed6f6272716c696d4337bf6d22377d61e005e3e14824a176d2c181738ad55e6)\\n            mstore(mload(add(vk, 0x240)), 0x02df19b2aef05e0654941a7e47b38a1ff144f37801b0f055761f980a8dd1a632)//vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x240)), 0x20), 0x06eb38abb255bb5dbc37e5f8465453488535b01fbc4694384c591c4abeb40c6e)\\n            mstore(mload(add(vk, 0x260)), 0x02c13a0286eb35ce560a2477032ab4939d32a0ea33a16d2c353c7abff58dbf93)//vk.SIGMA4\\n            mstore(add(mload(add(vk, 0x260)), 0x20), 0x2d7af8d128b8f8fbef65cadd8c129f3393485fb2b7d88f7618336defd35b52e5)\\n            mstore(add(vk, 0x280), 0x01) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x2a0), 1550) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x2c0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x2c0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/EscapeHatchVk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from '../cryptography/Types.sol';\\nimport {Bn254Crypto} from '../cryptography/Bn254Crypto.sol';\\n\\nlibrary EscapeHatchVk {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n\\n    function get_verification_key() internal pure returns (Types.VerificationKey memory) {\\n        Types.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 524288) // vk.circuit_size\\n            mstore(add(vk, 0x20), 26) // vk.num_inputs\\n            mstore(add(vk, 0x40),0x2260e724844bca5251829353968e4915305258418357473a5c1d597f613f6cbd) // vk.work_root\\n            mstore(add(vk, 0x60),0x3064486657634403844b0eac78ca882cfd284341fcb0615a15cfcd17b14d8201) // vk.domain_inverse\\n            mstore(add(vk, 0x80),0x06e402c0a314fb67a15cf806664ae1b722dbc0efe66e6c81d98f9924ca535321) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x1279d2085cc7d5cd109ab9dd43ff33cb95c7a13046b453a4bfb61bbdd72492d2)//vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x28ab33a6fa82f60cdad385a78bcdd940aaccd9a7cf9b453ac8c80aac1b4777fe)\\n            mstore(mload(add(vk, 0xc0)), 0x27f67bd4f2baa8fcb9eb46fa5295491ff1081db334232b913925fae0b0329961)//vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x0faf0ab4d5d4177b157d05d7956a3e7efc2e7786ab8864605e2b3b6b3f8ae3b5)\\n            mstore(mload(add(vk, 0xe0)), 0x014ca3daa697ac00fc7de92d65456acef16a42be471c75756fddb5237850b350)//vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x0375707a4a831032ee8611f7b0ef4a7b03399cfdf9f1235cae1199aadc49523f)\\n            mstore(mload(add(vk, 0x100)), 0x15d63ab4cf44a3fdcca802224cc3d5da9a9dde520363f22e436c7b442bdfc626)//vk.Q4\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x2571127f4c6af3eb0b5faffdf0c14b52e57a61b9788727afeed2e1b45bb6d1c2)\\n            mstore(mload(add(vk, 0x120)), 0x14be377de9fbabbb4aef102f1d2ece5770e2d46e8dd30876054e4b64af9c35a9)//vk.Q5\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x01b810b38e1cb22cbf270e19cb150debdac6ab8fa38b66e266b1a55db3453855)\\n            mstore(mload(add(vk, 0x140)), 0x2d01e34f2251daa161281a8d5e6a163d58c6672683e7e77f3a76c92b7c8d4e93)//vk.QM\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x262c29a17182888bb5499f98029b04dd74b33150c89f82233e932d52e1812ca1)\\n            mstore(mload(add(vk, 0x160)), 0x0e65650672209a49af8bef4a76ec549d56d4d0f28e1fed391cb2dd592066d6e9)//vk.QC\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x1a60dd5babb1e856ec8eea11fc1e2fd6546a5555be097d58437cb0cbff25b920)\\n            mstore(mload(add(vk, 0x180)), 0x2929e4fb516b4387375d4a42203afac5c218fc9b0b680d9fc83119d59948da9d)//vk.QARITH\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x22b1f8d3d1aa27b317984ecccf9e5af9e07258a9dde282a3a2f15c0a8357ce08)\\n            mstore(mload(add(vk, 0x1a0)), 0x014bc072259718b55bb0fb3edb5118e4824e6473da3c4c65100f7d64ad45dce1)//vk.QECC\\n            mstore(add(mload(add(vk, 0x1a0)), 0x20), 0x128eb91aa74e12801bd61c6027450804979f053eb0c99fdcc8c13daf147c0853)\\n            mstore(mload(add(vk, 0x1c0)), 0x090b293c05cb024ab4872f57f5ff36216155f2ea362cda33c9f38bcf92ac34a9)//vk.QRANGE\\n            mstore(add(mload(add(vk, 0x1c0)), 0x20), 0x2524fd5a1fd9ae231b821fbc8267642cf8efc3dccd7f33d8e32c0c2c70338788)\\n            mstore(mload(add(vk, 0x1e0)), 0x1886069e4af02aab5feccdd3dc48f40c3940fad4c1ae712e6e192e408050560b)//vk.QLOGIC\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x1e8ca495b98ef622e367ac42edf7bdd6c6a56ae2cae87bb9fb0ef29413f0e3a8)\\n            mstore(mload(add(vk, 0x200)), 0x0f88644a940dce7b381323b2b29e879508a6c1f5c56f227565c4ecb506921cf0)//vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x200)), 0x20), 0x1fc4901ccd07a280a0317940225b0c8c7fd4515d0fbed46ded77a5cd7e8fc540)\\n            mstore(mload(add(vk, 0x220)), 0x0f0259931fea8cc0f1f8fbf4a118dd097efc00d47fd579e29ad5b9b806896514)//vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x220)), 0x20), 0x24424eb4cd780341b9c16b5817bbe9a3bf8e0e18389866c3768f74976802109c)\\n            mstore(mload(add(vk, 0x240)), 0x2d478be2413dfbb000f5695cf291843469a09291506b55eb878f90c43c2f8618)//vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x240)), 0x20), 0x0c02fc72b2a78f75a063d32104ca0deaba3fb1210a1017e6a7d66a63f8c24331)\\n            mstore(mload(add(vk, 0x260)), 0x15edfc8c28858c9c3f827169777bc657fcc3006e7e40cf4993df86a99918a4e1)//vk.SIGMA4\\n            mstore(add(mload(add(vk, 0x260)), 0x20), 0x1081c10d1a67ce208f5832c8217669ddbc43b75f005f2c5ce1af4d7efbd154c0)\\n            mstore(add(vk, 0x280), 0x00) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x2a0), 0) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x2c0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x2c0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/verifier/keys/VerificationKeys.sol\": {\r\n        \"VerificationKeys\": \"0x61d4477dbdaabb9091685d52bd372f0bc8b3740e\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"rollup_size\",\"type\":\"uint256\"}],\"name\":\"verify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TurboVerifier", "CompilerVersion": "v0.6.10+commit.00c0fcaf", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}