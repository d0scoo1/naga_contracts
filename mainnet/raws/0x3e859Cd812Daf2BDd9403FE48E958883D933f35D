{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PakMergeSnapshot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n                                                                                                                                                                                                                                      \\nimport \\\"./IMerge.sol\\\";\\n\\ncontract PakMergeSnapshot {    \\n        \\n    IMerge immutable public _mergeContract;\\n\\n    constructor() {\\n        _mergeContract = IMerge(0xc3f8a0F5841aBFf777d3eefA5047e8D413a1C9AB);\\n    }       \\n\\n    function getOwners(uint256 tokenIdBegin, uint256 tokenIdEnd) public view returns (address[] memory) {\\n        require(tokenIdEnd >= tokenIdBegin, \\\"Invalid arguments\\\");\\n        uint256 numTokens = tokenIdEnd - tokenIdBegin + 1;\\n        address[] memory owners = new address[](numTokens);\\n        for(uint256 tokenId = tokenIdBegin; tokenId <= tokenIdEnd; tokenId++) {\\n            try _mergeContract.ownerOf(tokenId) returns (address owner) {\\n                owners[tokenId - tokenIdBegin] = owner;\\n            } catch Error(string memory /*reason*/) {                \\n                owners[tokenId - tokenIdBegin] = address(0);\\n            }\\n        }\\n        return owners;\\n    }\\n\\n    function getMasses(uint256 tokenIdBegin, uint256 tokenIdEnd) public view returns (uint256[] memory) {\\n        require(tokenIdEnd >= tokenIdBegin, \\\"Invalid arguments\\\");\\n        uint256 numTokens = tokenIdEnd - tokenIdBegin + 1;\\n        uint256[] memory masses = new uint256[](numTokens);\\n        for(uint256 tokenId = tokenIdBegin; tokenId <= tokenIdEnd; tokenId++) {\\n            try _mergeContract.massOf(tokenId) returns (uint256 mass) {\\n                masses[tokenId - tokenIdBegin] = mass;\\n            } catch Error(string memory /*reason*/) {                \\n                masses[tokenId - tokenIdBegin] = 0;\\n            }\\n        }\\n        return masses;        \\n    }\\n\\n    function getMergeCounts(uint256 tokenIdBegin, uint256 tokenIdEnd) public view returns (uint256[] memory) {\\n        require(tokenIdEnd >= tokenIdBegin, \\\"Invalid arguments\\\");\\n        uint256 numTokens = tokenIdEnd - tokenIdBegin + 1;\\n        uint256[] memory merges = new uint256[](numTokens);\\n        for(uint256 tokenId = tokenIdBegin; tokenId <= tokenIdEnd; tokenId++) {\\n            try _mergeContract.getMergeCount(tokenId) returns (uint256 mergeCount) {\\n                merges[tokenId - tokenIdBegin] = mergeCount;\\n            } catch Error(string memory /*reason*/) {                \\n                merges[tokenId - tokenIdBegin] = 0;\\n            }\\n        }\\n        return merges;\\n    }\\n\\n    function getClasses(uint256 tokenIdBegin, uint256 tokenIdEnd) public view returns (uint256[] memory) {\\n        require(tokenIdEnd >= tokenIdBegin, \\\"Invalid arguments\\\");\\n        uint256 numTokens = tokenIdEnd - tokenIdBegin + 1;\\n        uint256[] memory classes = new uint256[](numTokens);\\n        for(uint256 tokenId = tokenIdBegin; tokenId <= tokenIdEnd; tokenId++) {\\n            try _mergeContract.getValueOf(tokenId) returns (uint256 value) {\\n                uint256 tensDigit = tokenId % 100 / 10;\\n                uint256 onesDigit = tokenId % 10;\\n                uint256 class = tensDigit * 10 + onesDigit;\\n                classes[tokenId - tokenIdBegin] = class;\\n            } catch Error(string memory /*reason*/) {                \\n                classes[tokenId - tokenIdBegin] = 0;\\n            }\\n        }\\n        return classes;\\n    }\\n\\n    function getTiers(uint256 tokenIdBegin, uint256 tokenIdEnd) public view returns (uint256[] memory) {\\n        require(tokenIdEnd >= tokenIdBegin, \\\"Invalid arguments\\\");\\n        uint256 numTokens = tokenIdEnd - tokenIdBegin + 1;\\n        uint256[] memory tiers = new uint256[](numTokens);\\n        for(uint256 tokenId = tokenIdBegin; tokenId <= tokenIdEnd; tokenId++) {\\n            try _mergeContract.getValueOf(tokenId) returns (uint256 value) {\\n                tiers[tokenId - tokenIdBegin] = _mergeContract.decodeClass(value);\\n            } catch Error(string memory /*reason*/) {                \\n                tiers[tokenId - tokenIdBegin] = 0;\\n            }\\n        }\\n        return tiers;        \\n    }\\n\\n    function getExists(uint256 tokenIdBegin, uint256 tokenIdEnd) public view returns (bool[] memory) {\\n        require(tokenIdEnd >= tokenIdBegin, \\\"Invalid arguments\\\");\\n        uint256 numTokens = tokenIdEnd - tokenIdBegin + 1;\\n        bool[] memory existence = new bool[](numTokens);\\n        for(uint256 tokenId = tokenIdBegin; tokenId <= tokenIdEnd; tokenId++) {\\n            try _mergeContract.exists(tokenId) returns (bool exists) {\\n                existence[tokenId - tokenIdBegin] = exists;\\n            } catch Error(string memory /*reason*/) {                \\n                existence[tokenId - tokenIdBegin] = false;\\n            }\\n        }\\n        return existence;        \\n    }\\n}\"\r\n    },\r\n    \"contracts/IMerge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"@niftygateway/nifty-contracts/contracts/interfaces/IERC721.sol\\\";\\nimport \\\"@niftygateway/nifty-contracts/contracts/interfaces/IERC721Metadata.sol\\\";\\n\\ninterface IMerge is IERC721, IERC721Metadata {\\n    function getMergeCount(uint256 tokenId) external virtual view returns (uint256 mergeCount);    \\n    function totalSupply() external virtual view returns (uint256);    \\n    function massOf(uint256 tokenId) external virtual view returns (uint256);\\n    function getValueOf(uint256 tokenId) external view virtual returns (uint256 value);\\n    function exists(uint256 tokenId) external virtual view returns (bool);\\n    function decodeClassAndMass(uint256 value) external pure returns (uint256, uint256);\\n    function decodeClass(uint256 value) external pure returns (uint256 class);\\n    function decodeMass(uint256 value) external pure returns (uint256 mass);\\n}\"\r\n    },\r\n    \"@niftygateway/nifty-contracts/contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\"\r\n    },\r\n    \"@niftygateway/nifty-contracts/contracts/interfaces/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\"\r\n    },\r\n    \"@niftygateway/nifty-contracts/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"_mergeContract\",\"outputs\":[{\"internalType\":\"contract IMerge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenIdBegin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdEnd\",\"type\":\"uint256\"}],\"name\":\"getClasses\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenIdBegin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdEnd\",\"type\":\"uint256\"}],\"name\":\"getExists\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenIdBegin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdEnd\",\"type\":\"uint256\"}],\"name\":\"getMasses\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenIdBegin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdEnd\",\"type\":\"uint256\"}],\"name\":\"getMergeCounts\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenIdBegin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdEnd\",\"type\":\"uint256\"}],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenIdBegin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdEnd\",\"type\":\"uint256\"}],\"name\":\"getTiers\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PakMergeSnapshot", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "1500", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}