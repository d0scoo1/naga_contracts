{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/TruthereumToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.10;\\nimport './ERC20Token.sol';\\nimport './Owned.sol';\\nimport './TeamTranche.sol';\\nimport './TokenSale.sol';\\n\\ncontract TruthereumToken is ERC20Token, Owned {\\n\\n    // Constants\\n    string constant private NAME = \\\"Truthereum\\\";\\n    string constant private SYMBOL = \\\"TRE\\\";\\n    uint8 constant private DECIMALS = 18;\\n\\n    uint256 constant private TOKEN_UNIT = 10 ** DECIMALS;\\n    uint256 constant private TOTAL_SUPPLY = 5488039296144 * TOKEN_UNIT;\\n    uint256 constant public PUBLIC_SUPPLY = 4168188989144 * TOKEN_UNIT;\\n    uint256 constant public TEAM_SUPPLY = 1319850307000 * TOKEN_UNIT;\\n    \\n    uint256 constant public CROWDSALE_END_TIME = 1650151353; // 1650151353 April 16th, 2022 11:22:33 GMT\\n    uint256 constant public MAX_SALE_AMOUNT = 120736864515 * TOKEN_UNIT; // Never more than 2.2% of the total supply\\n\\n    // 12.5% every 3 months is distributed to the teams\\n    TeamTranche[] private TEAM_TRANCHES = [\\n        new TeamTranche(1654041600, 164981288375 * TOKEN_UNIT), // June 1st 2022, 00:00 GMT\\n        new TeamTranche(1661990400, 164981288375 * TOKEN_UNIT), // September 1st 2022, 00:00 GMT\\n        new TeamTranche(1669852800, 164981288375 * TOKEN_UNIT), // December 1st 2022, 00:00 GMT\\n        new TeamTranche(1677628800, 164981288375 * TOKEN_UNIT), // March 1st 2023, 00:00 GMT\\n        new TeamTranche(1685577600, 164981288375 * TOKEN_UNIT), // June 1st 2023, 00:00 GMT\\n        new TeamTranche(1693526400, 164981288375 * TOKEN_UNIT), // September 1st 2023, 00:00 GMT\\n        new TeamTranche(1701388800, 164981288375 * TOKEN_UNIT), // December 1st 2023, 00:00 GMT\\n        new TeamTranche(1709251200, 164981288375 * TOKEN_UNIT) // March 1st 2024, 00:00 GMT\\n    ];\\n\\n    // Variables\\n    uint256 public totalAllocated = 0;\\n    uint256 public totalTeamReleased = 0;\\n\\n    address public publicAddress;\\n    address public teamAddress;\\n    address public saleAddress = address(0);\\n\\n    TokenSale tokenSale;\\n\\n    // Modifiers\\n    modifier saleAddressRestricted() {\\n        require(msg.sender == saleAddress, 'ERROR: Can only be called from the saleAddress');\\n        _;\\n    }\\n\\n    constructor(address _publicAddress, address _teamAddress) ERC20Token(NAME, SYMBOL, DECIMALS, TOTAL_SUPPLY) {\\n        publicAddress = _publicAddress;\\n        teamAddress = _teamAddress;\\n        balanceOf[_publicAddress] = PUBLIC_SUPPLY;\\n    }\\n\\n    /**\\n        Starts a new token sale, only one can be active at a time and the total amount for sale must be\\n        less than the public supply still available for distribution\\n    */\\n    function addTokenSale(address payable _saleAddress) isValidAddress(_saleAddress) ownerRestricted public {\\n        require(isSaleWindow() == false, 'ERROR: There is already an active sale');\\n        tokenSale = TokenSale(_saleAddress);\\n        require(tokenSale.isStartable() == true, 'ERROR: The sale is not in a startable state');\\n        uint256 tokensForSale = tokenSale.tokensForSale();\\n        require(\\n            tokensForSale <= balanceOf[publicAddress] &&\\n            (hasCrowdsaleEnded() == false || tokensForSale <= MAX_SALE_AMOUNT),\\n            'ERROR: There sale amount exceeds the public balance or max sale amount'\\n        );\\n        saleAddress = _saleAddress;\\n        allowance[publicAddress][saleAddress] = tokensForSale;\\n    }\\n\\n    /**\\n        Ends the current token sale and returns and outstanding unsold amount to the public address\\n    */\\n    function endTokenSale() saleAddressRestricted public {\\n        require(isSaleWindow() == true, 'ERROR: There is no sale active');\\n        address unsoldAddress = tokenSale.unsoldAddress();\\n\\n        // The crowdsale will not have an unsold address\\n        if (unsoldAddress != address(0)) {\\n            uint256 unsoldTokens = tokenSale.availableForSale();\\n            balanceOf[unsoldAddress] = unsoldTokens;\\n            balanceOf[publicAddress] = safeSub(balanceOf[publicAddress], unsoldTokens);\\n        }\\n        \\n        allowance[publicAddress][saleAddress] = 0;\\n        saleAddress = address(0);\\n    }\\n\\n    /**\\n        Handles the transfer if the crowdsale has ended or the sender is the public address\\n    */\\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\\n        if (hasCrowdsaleEnded() == true || msg.sender == publicAddress) {\\n            assert(super.transfer(_to, _value));\\n            return true;\\n        }\\n        revert();        \\n    }\\n\\n    /**\\n        Handles the transfer from if the crowdsale has ended or the sender is the public address\\n    */\\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\\n        if (hasCrowdsaleEnded() == true || _from == publicAddress) {  \\n            assert(super.transferFrom(_from, _to, _value));\\n            return true;\\n        }\\n        revert();\\n    }\\n\\n    /**\\n        Iterates through all of the team tranches and attempts to release them\\n    */\\n    function releaseTeamTranches() ownerRestricted public {\\n        require(totalTeamReleased < TEAM_SUPPLY, 'ERROR: The entire team supply has already been released');\\n        for (uint index = 0; index < TEAM_TRANCHES.length; index++) {\\n            releaseTeamTranche(TEAM_TRANCHES[index]);\\n        }\\n    }\\n\\n    /**\\n        Releases the team tranche if the release conditions are met\\n    */\\n    function releaseTeamTranche(TeamTranche _tranche) internal returns(bool) {\\n        if (_tranche.isReleasable() == false) {\\n            return false;\\n        }\\n        balanceOf[teamAddress] = safeAdd(balanceOf[teamAddress], _tranche.amount());\\n        emit Transfer(address(0), teamAddress, _tranche.amount());\\n        totalAllocated = safeAdd(totalAllocated, _tranche.amount());\\n        totalTeamReleased = safeAdd(totalTeamReleased, _tranche.amount());\\n        _tranche.setReleased();\\n        return true;\\n    }\\n\\n    /**\\n        Adds to the total amount of tokens allocated\\n    */\\n    function addToAllocation(uint256 _amount) public saleAddressRestricted {\\n        totalAllocated = safeAdd(totalAllocated, _amount);\\n    }\\n\\n    /**\\n        Checks if the crowdsale has ended\\n    */\\n    function hasCrowdsaleEnded() public view returns(bool) {\\n        if (block.timestamp > CROWDSALE_END_TIME) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n        Checks if it is currently a sale window\\n    */\\n    function isSaleWindow() public view returns(bool) {\\n        if (saleAddress == address(0)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\"\r\n    },\r\n    \"/contracts/utilities/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.10;\\n\\ncontract Math {\\n    /**\\n        Validates that the first value is less than the second\\n    */\\n    modifier lessThan(uint256 _a, uint256 _b) {\\n        assert(_a < _b);\\n        _;\\n    }\\n\\n    /**\\n        Returns the sum of _a and _b, asserts if the calculation overflows\\n    */\\n    function safeAdd(uint256 _a, uint256 _b) pure internal returns (uint256) {\\n        uint256 z = _a + _b;\\n        assert(z >= _a);\\n        return z;\\n    }\\n\\n    /**\\n        Returns the difference of _a minus _b, asserts if the subtraction results in a negative number\\n    */\\n    function safeSub(uint256 _a, uint256 _b) pure internal returns (uint256) {\\n        assert(_a >= _b);\\n        return _a - _b;\\n    }\\n\\n    /**\\n        Returns the product of multiplying _a by _b, asserts if the calculation overflows\\n    */\\n    function safeMul(uint256 _a, uint256 _b) pure internal returns (uint256) {\\n        uint256 z = _a * _b;\\n        assert(_a == 0 || z / _a == _b);\\n        return z;\\n    }\\n}\"\r\n    },\r\n    \"/contracts/utilities/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.10;\\n\\ncontract Address {\\n    /**\\n        Verifies that the address is not null\\n    */\\n    modifier isValidAddress(address _address) {\\n        assert(_address != address(0));\\n        _;\\n    }\\n\\n    /**\\n        Verifies that the address does not match the one provided\\n    */\\n    modifier isNotAddress(address _address, address _restricted) {\\n        assert(_address != _restricted);\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IERC20Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.10;\\n\\ninterface IERC20Token {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"/contracts/TokenSale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.10;\\nimport './TruthereumToken.sol';\\nimport './Owned.sol';\\n\\ncontract TokenSale is Owned {\\n\\n    // Variables\\n    address public tokenAddress = address(0); // address of the token itself\\n    address public saleAddress; // address where the tokens are stored\\n    address public unsoldAddress; // address to send any unsold tokens to\\n    address payable public beneficiary; // address to receive ETH contributions\\n    uint256 public tokensForSale;\\n    uint256 public tokensPerETH;\\n\\n    TruthereumToken token;\\n\\n    // Events\\n    event SaleContribution(address _contributor, uint256 _amount, uint256 _return);\\n\\n    // Modifiers\\n    modifier saleActive() {\\n        require(isActive() == true, 'ERROR: There is currently no active sale');\\n        _;\\n    }\\n\\n    modifier saleNotActive() {\\n        require(isActive() == false, 'ERROR: There is currently an active sale');\\n        _;\\n    }\\n\\n    constructor(\\n        address _saleAddress,\\n        address _unsoldAddress,\\n        address payable _beneficiary,\\n        uint256 _tokensForSale,\\n        uint256 _tokensPerETH,\\n        uint256 _decimals\\n    ) {\\n        saleAddress = _saleAddress;\\n        unsoldAddress = _unsoldAddress;\\n        beneficiary = _beneficiary;\\n        tokensForSale = safeMul(_tokensForSale, (10 ** _decimals));\\n        tokensPerETH = _tokensPerETH;\\n    }\\n\\n    /**\\n        Checks if pre-start conditions are met for the sale\\n    */\\n    function isStartable() isValidAddress(tokenAddress) public view virtual returns (bool) {\\n        return true;\\n    }\\n\\n    /**\\n        Checks if the sale is active\\n    */\\n    function isActive() public view virtual returns (bool) {\\n        if (tokenAddress == address(0)) {\\n            return false;\\n        }\\n        if (availableForSale() <= 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    /**\\n        Returns the total amount of tokens still available in this sale\\n    */\\n    function availableForSale() public view returns (uint256) {\\n        return token.allowance(saleAddress, address(this));\\n    }\\n\\n    /**\\n        Sets the token variable, this can only be done once\\n    */\\n    function setToken(address _tokenAddress) isValidAddress(_tokenAddress) ownerRestricted public {\\n        require(tokenAddress == address(0), 'ERROR: The tokenAddress must be 0x0');\\n        tokenAddress = _tokenAddress;\\n        token = TruthereumToken(_tokenAddress);\\n    }\\n\\n    /**\\n        Sets the address to receive the ETH contributions\\n    */\\n    function setBeneficiary(address payable _beneficiary) isValidAddress(_beneficiary) ownerRestricted public {\\n        beneficiary = _beneficiary;\\n    }\\n\\n    /**\\n        Ends the token sale and no longer allows for contributions\\n    */\\n    function endSale() ownerRestricted public {\\n        token.endTokenSale();\\n    }\\n\\n    /**\\n        Handles ETH contributions and validates the address before further processing\\n    */\\n    function handleETHContribution(address _to) public payable saleActive isValidAddress(_to) returns (uint256) {\\n        return handleContribution(_to);\\n    }\\n\\n    /**\\n        Transfers the ETH to the beneficiary and transfers the amount of tokens in return\\n    */\\n    function handleContribution(address _to) isNotAddress(_to, token.publicAddress()) private returns (uint256) {\\n        uint256 tokens = getTotalTokensForETH(msg.value);\\n        require(availableForSale() > tokens, 'ERROR: There are not enough tokens available to cover the contribution');\\n        beneficiary.transfer(msg.value);\\n        token.transferFrom(token.publicAddress(), _to, tokens);\\n        token.addToAllocation(tokens);\\n        emit SaleContribution(_to, msg.value, tokens);\\n        return tokens;\\n    }\\n\\n    /**\\n        Returns the equivalent value of tokens for the ETH provided \\n    */\\n    function getTotalTokensForETH(uint256 _eth) public view virtual returns (uint256) {\\n        return safeMul(_eth, tokensPerETH);\\n    }\\n\\n    /**\\n        The entry point to purchase tokens\\n    */\\n    receive() payable external {\\n        handleETHContribution(msg.sender);\\n    }\\n}\"\r\n    },\r\n    \"/contracts/TeamTranche.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.10;\\nimport './Owned.sol';\\n\\ncontract TeamTranche is Owned {\\n    uint256 public releaseTime;\\n    uint256 public amount;\\n\\n    bool private released = false; \\n\\n    constructor(uint256 _releaseTime, uint256 _amount) {\\n        releaseTime = _releaseTime;\\n        amount = _amount;\\n    }\\n\\n    /**\\n        Checks if the tranche can be released\\n    */\\n    function isReleasable() public view returns (bool) {\\n        if (released == true) return false;\\n        return block.timestamp > releaseTime;\\n    }\\n\\n    /**\\n        Updated the tranches released value to true\\n    */\\n    function setReleased() ownerRestricted public {\\n        released = true;\\n    }\\n}\"\r\n    },\r\n    \"/contracts/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.10;\\nimport './utilities/Address.sol';\\nimport './utilities/Math.sol';\\n\\ncontract Owned is Address, Math {\\n    address public owner;\\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    /**\\n        A modifier to only allow modifications by the owner of the contract\\n    */\\n    modifier ownerRestricted {\\n        require(msg.sender == owner, 'ERROR: Can only be called from the owner');\\n        _;\\n    }\\n\\n    /**\\n        Reassigns the owner to the contract specified\\n    */\\n    function assignOwner(address _address) ownerRestricted isValidAddress(_address) isNotAddress(_address, owner) public {\\n        owner = _address;\\n    }\\n}\"\r\n    },\r\n    \"/contracts/ERC20Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.10;\\nimport './interfaces/IERC20Token.sol';\\nimport './utilities/Address.sol';\\nimport './utilities/Math.sol';\\n\\ncontract ERC20Token is IERC20Token, Address, Math {\\n    string public name = \\\"\\\";\\n    string public symbol = \\\"\\\";\\n    uint8 public decimals = 0;\\n    uint256 public totalSupply = 0;\\n    mapping (address => uint256) public balanceOf;\\n    mapping (address => mapping (address => uint256)) public allowance;\\n\\n    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {\\n        require(bytes(_name).length > 0, 'ERROR: No name was provided');\\n        require(bytes(_symbol).length > 0, 'ERROR: No symbol was provided');\\n\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n        totalSupply = _totalSupply;\\n    }\\n\\n    function transfer(address _to, uint256 _value) public virtual isValidAddress(_to) returns (bool success) {\\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);\\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _value)\\n        public virtual\\n        isValidAddress(_from)\\n        isValidAddress(_to)\\n        returns (bool success)\\n    {\\n        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);\\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    function approve(address _spender, uint256 _value)\\n        public\\n        isValidAddress(_spender)\\n        returns (bool success)\\n    {\\n        // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal\\n        require(_value == 0 || allowance[msg.sender][_spender] == 0, 'ERROR: Cannot approve as the allowance or value is 0');\\n\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_publicAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_teamAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CROWDSALE_END_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SALE_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PUBLIC_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TEAM_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addToAllocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_saleAddress\",\"type\":\"address\"}],\"name\":\"addTokenSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"assignOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTokenSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasCrowdsaleEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSaleWindow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseTeamTranches\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTeamReleased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TruthereumToken", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000008f00562817068325a542b7459047d58dcbb3e8f3000000000000000000000000844a7148e46701971e90cd20a156df7ee2fc2b8f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}