{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\ncontract Verification {\r\n  address private _owner;\r\n  address private signer;\r\n  IERC20 private feeToken;\r\n  uint private feeAmount;\r\n\r\n  struct VerifiedPassport {\r\n    uint expiration;\r\n    bytes32 countryAndDocNumberHash;\r\n  }\r\n\r\n  struct PersonalDetails {\r\n    bool over18;\r\n    bool over21;\r\n    uint countryCode;\r\n  }\r\n\r\n  mapping(address => VerifiedPassport) private accounts;\r\n  mapping(address => PersonalDetails) private personalData;\r\n  mapping(bytes32 => address) private idHashToAccount;\r\n  mapping(address => uint) private hasPaidFee;\r\n\r\n  event FeePaid(address indexed account);\r\n  event VerificationUpdated(address indexed account, uint256 expiration);\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  event FeeTokenChanged(address indexed previousFeeToken, address indexed newFeeToken);\r\n  event FeeAmountChanged(uint previousFeeAmount, uint newFeeAmount);\r\n  event IsOver18(address indexed account);\r\n  event IsOver21(address indexed account);\r\n  event CountryOfOrigin(address indexed account, uint countryCode);\r\n\r\n  constructor(address _signer, address _feeToken, uint _feeAmount) {\r\n    require(_signer != address(0), \"Signer must not be zero address\");\r\n    require(_feeToken != address(0), \"Fee token must not be zero address\");\r\n    _transferOwnership(msg.sender);\r\n    signer = _signer;\r\n    feeToken = IERC20(_feeToken);\r\n    feeAmount = _feeAmount;\r\n  }\r\n\r\n  function getFeeToken() external view returns (address) {\r\n    return address(feeToken);\r\n  }\r\n\r\n  function getFeeAmount() external view returns (uint) {\r\n    return feeAmount;\r\n  }\r\n\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  function payFeeFor(address account) public {\r\n    emit FeePaid(account);\r\n    hasPaidFee[account] = block.number;\r\n    bool received = feeToken.transferFrom(msg.sender, address(this), feeAmount);\r\n    require(received, \"Fee transfer failed\");\r\n  }\r\n\r\n  function payFee() external {\r\n    payFeeFor(msg.sender);\r\n  }\r\n\r\n  function unsetPaidFee(address account) external onlyOwner {\r\n    delete hasPaidFee[account];\r\n  }\r\n\r\n  function feePaidFor(address account) external view returns (uint) {\r\n    return hasPaidFee[account];\r\n  }\r\n\r\n  function publishVerification(\r\n    uint256 expiration,\r\n    bytes32 countryAndDocNumberHash,\r\n    bytes calldata signature\r\n  ) external {\r\n    // Signing server will only provide signature if fee has been paid,\r\n    //  not necessary to require it here\r\n    delete hasPaidFee[msg.sender];\r\n    // Recreate hash as built by the client\r\n    bytes32 hash = keccak256(abi.encode(msg.sender, expiration, countryAndDocNumberHash));\r\n    (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\r\n    bytes32 ethSignedHash = keccak256(\r\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n\r\n    address sigAddr = ecrecover(ethSignedHash, v, r, s);\r\n    require(sigAddr == signer, \"Invalid Signature\");\r\n\r\n    // Revoke verification for any other account that uses\r\n    //  the same document number/country\r\n    //  e.g. for case of stolen keys\r\n    if(idHashToAccount[countryAndDocNumberHash] != address(0x0)) {\r\n      _revokeVerification(idHashToAccount[countryAndDocNumberHash]);\r\n    }\r\n    // Update account state\r\n    idHashToAccount[countryAndDocNumberHash] = msg.sender;\r\n    accounts[msg.sender] = VerifiedPassport(expiration, countryAndDocNumberHash);\r\n    emit VerificationUpdated(msg.sender, expiration);\r\n  }\r\n\r\n  function revokeVerification() external {\r\n    require(accounts[msg.sender].expiration > 0, \"Account not verified\");\r\n    _revokeVerification(msg.sender);\r\n  }\r\n\r\n  function revokeVerificationOf(address account) external onlyOwner {\r\n    require(accounts[account].expiration > 0, \"Account not verified\");\r\n    _revokeVerification(account);\r\n  }\r\n\r\n  function _revokeVerification(address account) internal {\r\n    // Do not need to delete from idHashToAccount since that data is\r\n    //  not used for determining account status\r\n    delete accounts[account];\r\n    // Revoking the verification also redacts the personal data\r\n    delete personalData[account];\r\n    emit VerificationUpdated(account, 0);\r\n  }\r\n\r\n  function addressActive(address toCheck) public view returns (bool) {\r\n    return accounts[toCheck].expiration > block.timestamp;\r\n  }\r\n\r\n  function addressExpiration(address toCheck) external view returns (uint) {\r\n    return accounts[toCheck].expiration;\r\n  }\r\n\r\n  function addressIdHash(address toCheck) external view returns(bytes32) {\r\n    return accounts[toCheck].countryAndDocNumberHash;\r\n  }\r\n\r\n  function publishPersonalData(\r\n    bool over18,\r\n    bytes calldata over18Signature,\r\n    bool over21,\r\n    bytes calldata over21Signature,\r\n    uint countryCode,\r\n    bytes calldata countrySignature\r\n  ) external {\r\n    require(addressActive(msg.sender), \"Account must be active\");\r\n    if(over18Signature.length == 65) {\r\n      bytes32 hash = keccak256(abi.encode(msg.sender, over18 ? \"over18\" : \"notOver18\"));\r\n      (bytes32 r, bytes32 s, uint8 v) = splitSignature(over18Signature);\r\n      bytes32 ethSignedHash = keccak256(\r\n        abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n\r\n      address sigAddr = ecrecover(ethSignedHash, v, r, s);\r\n      require(sigAddr == signer, \"Invalid Signature\");\r\n      personalData[msg.sender].over18 = over18;\r\n      if(over18) {\r\n        emit IsOver18(msg.sender);\r\n      }\r\n    }\r\n    if(over21Signature.length == 65) {\r\n      bytes32 hash = keccak256(abi.encode(msg.sender, over21 ? \"over21\" : \"notOver21\"));\r\n      (bytes32 r, bytes32 s, uint8 v) = splitSignature(over21Signature);\r\n      bytes32 ethSignedHash = keccak256(\r\n        abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n\r\n      address sigAddr = ecrecover(ethSignedHash, v, r, s);\r\n      require(sigAddr == signer, \"Invalid Signature\");\r\n      personalData[msg.sender].over21 = over21;\r\n      if(over21) {\r\n        emit IsOver21(msg.sender);\r\n      }\r\n    }\r\n    if(countrySignature.length == 65) {\r\n      bytes32 hash = keccak256(abi.encode(msg.sender, countryCode));\r\n      (bytes32 r, bytes32 s, uint8 v) = splitSignature(countrySignature);\r\n      bytes32 ethSignedHash = keccak256(\r\n        abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n\r\n      address sigAddr = ecrecover(ethSignedHash, v, r, s);\r\n      require(sigAddr == signer, \"Invalid Signature\");\r\n      personalData[msg.sender].countryCode = countryCode;\r\n      emit CountryOfOrigin(msg.sender, countryCode);\r\n    }\r\n  }\r\n\r\n  function redactPersonalData() external {\r\n    delete personalData[msg.sender];\r\n  }\r\n\r\n  function isOver18(address toCheck) external view returns (bool) {\r\n    return personalData[toCheck].over18;\r\n  }\r\n\r\n  function isOver21(address toCheck) external view returns (bool) {\r\n    return personalData[toCheck].over21;\r\n  }\r\n\r\n  function getCountryCode(address toCheck) external view returns (uint) {\r\n    return personalData[toCheck].countryCode;\r\n  }\r\n\r\n  function setSigner(address newSigner) external onlyOwner {\r\n    require(newSigner != address(0), \"Signer cannot be zero address\");\r\n    signer = newSigner;\r\n  }\r\n\r\n  function setFeeToken(address newFeeToken) external onlyOwner {\r\n    require(newFeeToken != address(0), \"Fee Token cannot be zero address\");\r\n    address oldFeeToken = address(feeToken);\r\n    feeToken = IERC20(newFeeToken);\r\n    emit FeeTokenChanged(oldFeeToken, newFeeToken);\r\n  }\r\n\r\n  function setFeeAmount(uint newFeeAmount) external onlyOwner {\r\n    uint oldFeeAmount = feeAmount;\r\n    feeAmount = newFeeAmount;\r\n    emit FeeAmountChanged(oldFeeAmount, newFeeAmount);\r\n  }\r\n\r\n  function _transferOwnership(address newOwner) internal {\r\n    address oldOwner = _owner;\r\n    _owner = newOwner;\r\n    emit OwnershipTransferred(oldOwner, newOwner);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) external onlyOwner {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  function transferFeeToken(address recipient, uint amount) external onlyOwner {\r\n    bool sent = feeToken.transfer(recipient, amount);\r\n    require(sent, \"Fee transfer failed\");\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  // From https://solidity-by-example.org/signature/\r\n  function splitSignature(bytes memory sig) internal pure\r\n    returns (bytes32 r, bytes32 s, uint8 v)\r\n  {\r\n    require(sig.length == 65, \"invalid signature length\");\r\n    assembly {\r\n        // first 32 bytes, after the length prefix\r\n        r := mload(add(sig, 32))\r\n        // second 32 bytes\r\n        s := mload(add(sig, 64))\r\n        // final byte (first byte of the next 32 bytes)\r\n        v := byte(0, mload(add(sig, 96)))\r\n    }\r\n  }\r\n\r\n}\r\n\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address account) external view returns (uint);\r\n  function transfer(address recipient, uint amount) external returns (bool);\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n  function approve(address spender, uint amount) external returns (bool);\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint amount\r\n  ) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"countryCode\",\"type\":\"uint256\"}],\"name\":\"CountryOfOrigin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFeeAmount\",\"type\":\"uint256\"}],\"name\":\"FeeAmountChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"FeePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousFeeToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFeeToken\",\"type\":\"address\"}],\"name\":\"FeeTokenChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"IsOver18\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"IsOver21\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"VerificationUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toCheck\",\"type\":\"address\"}],\"name\":\"addressActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toCheck\",\"type\":\"address\"}],\"name\":\"addressExpiration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toCheck\",\"type\":\"address\"}],\"name\":\"addressIdHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"feePaidFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toCheck\",\"type\":\"address\"}],\"name\":\"getCountryCode\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toCheck\",\"type\":\"address\"}],\"name\":\"isOver18\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toCheck\",\"type\":\"address\"}],\"name\":\"isOver21\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"payFeeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"over18\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"over18Signature\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"over21\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"over21Signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"countryCode\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"countrySignature\",\"type\":\"bytes\"}],\"name\":\"publishPersonalData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"countryAndDocNumberHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"publishVerification\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redactPersonalData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeVerification\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeVerificationOf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFeeAmount\",\"type\":\"uint256\"}],\"name\":\"setFeeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeToken\",\"type\":\"address\"}],\"name\":\"setFeeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFeeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unsetPaidFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Verification", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000cd21a4eaf4f3d11905e1c09577735694641f39db000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000000000000000000000000000000000000002dc6c0", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dd29d05c004982bbfef8de24287c489ef6da3bbfa4f1407bf734324a4ce07b91"}]}