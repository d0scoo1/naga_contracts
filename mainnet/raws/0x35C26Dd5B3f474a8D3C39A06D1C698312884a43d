{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: contracts/utils/Ownable.sol\n\npragma solidity >=0.4.21 <0.6.0;\n\ncontract Ownable {\n    address private _contract_owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = msg.sender;\n        _contract_owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _contract_owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_contract_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_contract_owner, newOwner);\n        _contract_owner = newOwner;\n    }\n}\n\n// File: contracts/utils/SafeMath.sol\n\npragma solidity >=0.4.21 <0.6.0;\n\nlibrary SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a, \"add\");\n    }\n    function safeSubR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b <= a, s);\n        c = a - b;\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a, \"sub\");\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b, \"mul\");\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0, \"div\");\n        c = a / b;\n    }\n    function safeDivR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b > 0, s);\n        c = a / b;\n    }\n}\n\n// File: contracts/utils/Address.sol\n\npragma solidity >=0.4.21 <0.6.0;\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n\n// File: contracts/utils/ReentrancyGuard.sol\n\npragma solidity >=0.4.21 <0.6.0;\n\ncontract ReentrancyGuard {\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        _guardCounter = 1;\n    }\n\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n\n// File: contracts/erc20/IERC20.sol\n\npragma solidity >=0.4.21 <0.6.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface ERC20Property{\n  function name() external view returns (string memory);\n  function symbol() external view returns (string memory);\n  function decimals() external view returns (uint8);\n}\n\n// File: contracts/erc20/SafeERC20.sol\n\npragma solidity >=0.4.21 <0.6.0;\n\n\n\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).safeAdd(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).safeSub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// File: contracts/core/Interfaces.sol\n\npragma solidity >=0.4.21 <0.6.0;\n\ncontract UniswapV3Interface{\n    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to) external payable returns (uint256 amountOut);\n}\ncontract CurveInterface256{\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external payable returns(uint256);//change i to j\n    //0 weth, 1 crv\n}\ncontract CurveInterface128{\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns(uint256);\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns(uint256);\n    //0 crv, 1 cvxcrv\n}\ncontract TriPoolInterface{\n    function remove_liquidity_one_coin(uint256 _token_amount, uint128 i, uint256 min_amount) external;//DAI, USDC, USDT\n}\ncontract ConvexInterface{\n    function stake(uint256 amount) public returns(bool);\n    function withdraw(uint256 amount, bool claim) public returns(bool);\n    function getReward() external returns(bool);\n    function withdrawAll(bool claim) public;\n}\ncontract ChainlinkInterface{\n  function latestAnswer() external view returns (int256);\n}\n\n// File: contracts/core/EFCRVVault.sol\n\npragma solidity >=0.4.21 <0.6.0;\n\n\n\n\n\n\n\ncontract TokenInterfaceERC20{\n  function destroyTokens(address _owner, uint _amount) public returns(bool);\n  function generateTokens(address _owner, uint _amount) public returns(bool);\n}\n\ncontract EFCRVVault is Ownable, ReentrancyGuard{\n  using SafeERC20 for IERC20;\n  using SafeMath for uint256;\n  using Address for address;\n\n  address public crv;\n  address public usdc;\n\n  uint256 public ratio_base;\n  uint256 public slippage;\n  uint256 public withdraw_fee_ratio;\n  uint256 public harvest_fee_ratio;\n  address payable public fee_pool;\n  address public ef_token;\n  uint256 public lp_balance;//cvxcrv balance\n  uint256 public deposit_target_amount;//CRV\n  uint256 public last_earn_block;\n\n\n  address public eth_usdc_router;\n  address public weth;\n  address public cvxcrv;\n  address public eth_crv_router;\n  address public crv_cvxcrv_router;\n  address public eth_usdt_router;//0 usdt, 1wbtc, 2weth\n  address public tri_curve;\n  address public staker;\n  address public usdt;\n  address public oracle;//our price is 18 dec\n  address public oracle_eth;\n\n  address[] public extra_yield_tokens;\n\n  mapping(address => uint256) reward_types;//0:origin, 1:cvx, 2:3crv\n  mapping(address => address) swaper;\n\n  bool is_paused;\n\n  //@param _crv, means ETH if it's 0x0\n  constructor(address _ef_token) public {\n    crv = address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    usdc =  address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    ratio_base = 10000;\n    ef_token = _ef_token;\n    eth_usdc_router =  address(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\n    weth =  address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    cvxcrv =  address(0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7);\n    eth_crv_router =  address(0x8301AE4fc9c624d1D396cbDAa1ed877821D7C511);\n    crv_cvxcrv_router =  address(0x9D0464996170c6B9e75eED71c68B99dDEDf279e8);//curve128\n    eth_usdt_router =  address(0xD51a44d3FaE010294C616388b506AcdA1bfAAE46);\n    usdt =  address(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    oracle =  address(0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f);\n    staker = address(0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e);\n    oracle_eth = address(0x986b5E1e1755e3C2440e960477f25201B0a8bbD4);//usdc to eth, 18 dec\n  }\n\n  event CFFDeposit(address from, uint256 target_amount, uint256 stable_amount, uint256 cff_amount, uint256 virtual_price);\n  event CFFDepositFee(address from, uint256 target_amount, uint256 fee_amount);\n\n  function deposit(uint256 _amount) public payable nonReentrant{\n    require(!is_paused, \"paused\");\n\n    require(IERC20(crv).allowance(msg.sender, address(this)) >= _amount, \"CFVault: not enough allowance\");\n\n    require(_amount != 0, \"too small amount\");\n\n    uint tt_before = IERC20(crv).balanceOf(address(this));\n    IERC20(crv).safeTransferFrom(msg.sender, address(this), _amount);\n\n    uint tt_after = IERC20(crv).balanceOf(address(this));\n    require(tt_after.safeSub(tt_before) == _amount, \"token inflation\");\n\n    _deposit(_amount.safeMul(uint256(ChainlinkInterface(oracle).latestAnswer())).safeDiv(1e20), _amount);//Todo\n  }\n  function depositStable(uint256 _amount) public payable nonReentrant{\n    require(!is_paused, \"paused\");\n\n    require(IERC20(usdc).allowance(msg.sender, address(this)) >= _amount, \"CFVault: not enough allowance\");\n    IERC20(usdc).safeTransferFrom(msg.sender, address(this), _amount);\n\n    if (IERC20(usdc).allowance(address(this), eth_usdc_router) != 0){\n      IERC20(usdc).approve(eth_usdc_router, 0);\n    }\n    IERC20(usdc).approve(eth_usdc_router, _amount);\n\n    uint256 weth_before = IERC20(weth).balanceOf(address(this));\n    {\n      address[] memory t = new address[](2);\n      t[0] = usdc;\n      t[1] = weth;\n      uint256 min_amount = _amount.safeMul(uint256(ChainlinkInterface(oracle).latestAnswer())).safeMul(slippage).safeDiv(1e10);//-6-4\n      UniswapV3Interface(eth_usdc_router).swapExactTokensForTokens(_amount, min_amount, t, address(this));\n    }\n    uint256 weth_amount = IERC20(weth).balanceOf(address(this)).safeSub(weth_before);\n    if (IERC20(weth).allowance(address(this), eth_crv_router) != 0){\n      IERC20(weth).approve(eth_crv_router, 0);\n    }\n    IERC20(weth).approve(eth_crv_router, weth_amount);\n\n    uint256 tt_before = IERC20(crv).balanceOf(address(this));\n    CurveInterface256(eth_crv_router).exchange(0, 1, weth_amount, 0);\n    uint256 tt_amount = IERC20(crv).balanceOf(address(this)).safeSub(tt_before);\n\n    _deposit(_amount, tt_amount);\n  }\n\n  function _deposit(uint256 _stable_amount, uint256 _amount) internal{\n    uint256 lp_before = lp_balance;\n    uint256 lp_amount = _stake(_amount);\n\n    uint256 d = 18;\n    uint cff_amount = 0;\n    if (lp_before == 0){\n      cff_amount = lp_amount.safeMul(uint256(10)**18).safeDiv(uint256(10)**d);\n    }\n    else{\n      cff_amount = lp_amount.safeMul(IERC20(ef_token).totalSupply()).safeDiv(lp_before);\n    }\n    TokenInterfaceERC20(ef_token).generateTokens(msg.sender, cff_amount);\n    emit CFFDeposit(msg.sender, _amount, _stable_amount, cff_amount, getVirtualPrice());\n  }\n\n  function _stake(uint256 _amount) internal returns(uint256){\n    uint256 lp_before = IERC20(cvxcrv).balanceOf(address(this));\n    deposit_target_amount = deposit_target_amount.safeAdd(_amount);\n    if (IERC20(crv).allowance(address(this), crv_cvxcrv_router) != 0){\n      IERC20(crv).approve(crv_cvxcrv_router, 0);\n    }\n    IERC20(crv).approve(crv_cvxcrv_router, _amount);\n\n    CurveInterface128(crv_cvxcrv_router).exchange(0, 1, _amount, 0);\n    uint256 lp_amount = IERC20(cvxcrv).balanceOf(address(this)).safeSub(lp_before);\n\n    lp_balance = lp_balance.safeAdd(IERC20(cvxcrv).balanceOf(address(this)));\n\n    if (IERC20(cvxcrv).allowance(address(this), staker) != 0){\n      IERC20(cvxcrv).approve(staker, 0);\n    }\n    IERC20(cvxcrv).approve(staker, IERC20(cvxcrv).balanceOf(address(this)));\n\n    ConvexInterface(staker).stake(IERC20(cvxcrv).balanceOf(address(this)));\n    return lp_amount;\n  }\n\n  event CFFWithdraw(address from, uint256 target_amount, uint256 stable_amount, uint256 cff_amount, uint256 target_fee, uint256 virtual_price);\n  //@_amount: CFLPToken amount\n  function withdraw(uint256 _amount, bool _use_stable) public nonReentrant{\n    require(!is_paused, \"paused\");\n\n    {\n      uint256 total_balance = IERC20(ef_token).balanceOf(msg.sender);\n      require(total_balance >= _amount, \"not enough LP tokens\");\n    }\n    uint256 target_amount;\n    {\n      uint256 lp_amount = _amount.safeMul(lp_balance).safeDiv(IERC20(ef_token).totalSupply());\n\n      uint256 target_before = IERC20(crv).balanceOf(address(this));\n      _withdraw(lp_amount);\n\n      target_amount = IERC20(crv).balanceOf(address(this)).safeSub(target_before);\n    }\n    uint256 f = 0;\n    if(withdraw_fee_ratio != 0 && fee_pool != address(0x0)){\n      f = target_amount.safeMul(withdraw_fee_ratio).safeDiv(ratio_base);\n      target_amount = target_amount.safeSub(f);\n      IERC20(crv).transfer(fee_pool, f);\n      TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount);\n    }else{\n      TokenInterfaceERC20(ef_token).destroyTokens(msg.sender, _amount);\n    }\n    if (!_use_stable){\n      IERC20(crv).transfer(msg.sender, target_amount);\n      emit CFFWithdraw(msg.sender, target_amount, target_amount.safeMul(uint256(ChainlinkInterface(oracle).latestAnswer())).safeDiv(1e20), _amount, f, getVirtualPrice());\n    }\n    else{\n      if (IERC20(crv).allowance(address(this), eth_crv_router) != 0){\n        IERC20(crv).approve(eth_crv_router, 0);\n      }\n      IERC20(crv).approve(eth_crv_router, target_amount);\n\n      uint256 weth_amount;\n      {\n        uint256 weth_before = IERC20(weth).balanceOf(address(this));\n        CurveInterface256(eth_crv_router).exchange(1, 0, target_amount, 0);\n        weth_amount = IERC20(weth).balanceOf(address(this)).safeSub(weth_before);\n      }\n\n      if (IERC20(weth).allowance(address(this), eth_usdc_router) != 0){\n        IERC20(weth).approve(eth_usdc_router, 0);\n      }\n      IERC20(weth).approve(eth_usdc_router, weth_amount);\n\n      uint256 usdc_amount;\n      {\n        address[] memory t = new address[](2);\n        t[0] = weth;\n        t[1] = usdc;\n        uint256 usdc_before = IERC20(usdc).balanceOf(address(this));\n        uint256 min_amount = weth_amount.safeMul(slippage).safeMul(1e2).safeDiv(uint256(ChainlinkInterface(oracle).latestAnswer()));//6-4\n        UniswapV3Interface(eth_usdc_router).swapExactTokensForTokens(weth_amount, min_amount, t, address(this));\n        usdc_amount = IERC20(usdc).balanceOf(address(this)).safeSub(usdc_before);\n      }\n      IERC20(usdc).transfer(msg.sender, usdc_amount);\n      emit CFFWithdraw(msg.sender, target_amount, usdc_amount, _amount, f, getVirtualPrice());\n    }\n  }\n\n  function _withdraw(uint256 _amount) internal{\n    ConvexInterface(staker).withdraw(_amount, false);\n    lp_balance = lp_balance.safeSub(_amount);\n\n    if (IERC20(cvxcrv).allowance(address(this), crv_cvxcrv_router)!= 0){\n      IERC20(cvxcrv).approve(crv_cvxcrv_router, 0);\n    }\n    IERC20(cvxcrv).approve(crv_cvxcrv_router, _amount);\n\n    CurveInterface128(crv_cvxcrv_router).exchange(1, 0, _amount, 0);\n  }\n\n  event EFRefundCRV(uint256 amount, uint256 fee);\n  function earnReward() public onlyOwner{\n    require(!is_paused, \"paused\");\n\n    last_earn_block = block.number;\n\n    ConvexInterface(staker).getReward();\n\n    for(uint i = 0; i < extra_yield_tokens.length; i++){\n      uint256 extra_amount = IERC20(extra_yield_tokens[i]).balanceOf(address(this));\n      if(extra_amount > 0){\n        _handleExtraToken(extra_yield_tokens[i]);\n      }\n    }\n    uint256 crv_amount = IERC20(crv).balanceOf(address(this));\n\n    if(harvest_fee_ratio != 0 && fee_pool != address(0x0)){\n      uint256 f = crv_amount.safeMul(harvest_fee_ratio).safeDiv(ratio_base);\n      crv_amount = crv_amount.safeSub(f);\n      emit EFRefundCRV(crv_amount, f);\n      if(f != 0){\n        IERC20(crv).transfer(fee_pool, f);\n      }\n    }else{\n      emit EFRefundCRV(crv_amount, 0);\n    }\n    _stake(crv_amount);\n  }\n  function _handleExtraToken(address _token) internal{\n    uint256 _type = reward_types[_token];\n    address router = swaper[_token];\n\n    if (_type == 0) return;\n    if (_type == 1){\n      if (IERC20(_token).allowance(address(this), router)!= 0){\n        IERC20(_token).approve(router, 0);\n      }\n      IERC20(_token).approve(router, IERC20(_token).balanceOf(address(this)));\n      CurveInterface256(router).exchange(1, 0, IERC20(_token).balanceOf(address(this)), 0);\n      _exchange_weth();\n    }\n    if (_type == 2){\n      TriPoolInterface(router).remove_liquidity_one_coin(IERC20(_token).balanceOf(address(this)), 2, 0);\n      IERC20(usdt).safeApprove(eth_usdt_router, 0);\n      IERC20(usdt).safeApprove(eth_usdt_router, IERC20(usdt).balanceOf(address(this)));\n      CurveInterface256(eth_usdt_router).exchange(0, 2, IERC20(usdt).balanceOf(address(this)), 0);      \n      _exchange_weth();\n    }\n  }\n  function _exchange_weth() internal{\n    if (IERC20(weth).allowance(address(this), eth_crv_router)!= 0){\n      IERC20(weth).approve(eth_crv_router, 0);\n    }\n    IERC20(weth).approve(eth_crv_router, IERC20(weth).balanceOf(address(this)));\n    CurveInterface256(eth_crv_router).exchange(0, 1, IERC20(weth).balanceOf(address(this)), 0);\n  }\n\n  function getLPTokenBalance() public view returns(uint256){\n    return lp_balance;\n  }\n\n  event ChangeFeeConfig(address fee_pool, uint256 withdraw_fee, uint256 harvest_fee);\n  function changeFeeConfig(address payable _pool, uint256 _wfee, uint256 _hfee) public onlyOwner{\n    require(_wfee < ratio_base && _hfee < ratio_base, \"invalid fee\");\n    fee_pool = _pool;\n    withdraw_fee_ratio = _wfee;\n    harvest_fee_ratio = _hfee;\n    emit ChangeFeeConfig(_pool, _wfee, _hfee);\n  }\n\n  event CFFChangePause(bool is_paused);\n  function changePause(bool _paused) public onlyOwner{\n    is_paused = _paused;\n    emit CFFChangePause(is_paused);\n  }\n  function changeSlippage(uint256 _slippage) public onlyOwner{\n    slippage = _slippage;\n  }\n\n  function getVirtualPrice() public view returns(uint256){\n    if (IERC20(ef_token).totalSupply() == 0) return 0;\n    uint256 lp_amount = lp_balance.safeMul(1e18).safeDiv(IERC20(ef_token).totalSupply());\n    return CurveInterface128(crv_cvxcrv_router).get_dy(1, 0, lp_amount);\n  }\n\n  event AddExtraToken(address _new, uint256 types);\n  function addExtraToken(address _new, address _swap, uint256 _types) public onlyOwner{\n    require(_new != address(0x0), \"invalid extra token\");\n    extra_yield_tokens.push(_new);\n    reward_types[_new] = _types;\n    swaper[_new] = _swap;\n    emit AddExtraToken(_new, _types);\n  }\n\n  event RemoveExtraToken(address _addr);\n  function removeExtraToken(address _addr) public onlyOwner{\n    require(_addr != address(0x0), \"invalid address\");\n    uint len = extra_yield_tokens.length;\n    for(uint i = 0; i < len; i++){\n      if(extra_yield_tokens[i] == _addr){\n        extra_yield_tokens[i] = extra_yield_tokens[len - 1];\n        extra_yield_tokens[len - 1] =address(0x0);\n        extra_yield_tokens.length = len - 1;\n        emit RemoveExtraToken(_addr);\n      }\n    }\n  }\n\n  function callWithData(address payable to, bytes memory data, uint256 amount, bool dele)public payable onlyOwner{\n    bool status;\n    if (dele == false){\n      (status, ) = to.call.value(amount)(data);\n    }\n    else{\n      (status, ) = to.delegatecall(data);\n    }\n    require(status, \"call failed\");\n  }\n  function() external payable{}\n}\n\ncontract EFCRVVaultFactory{\n  event NewCFVault(address addr);\n\n  function createCFVault(address _ef_token) public returns(address){\n    EFCRVVault cf = new EFCRVVault(_ef_token);\n    cf.transferOwnership(msg.sender);\n    emit NewCFVault(address(cf));\n    return address(cf);\n  }\n\n}\n", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"ratio_base\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositStable\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lp_balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_use_stable\",\"type\":\"bool\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle_eth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"slippage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"dele\",\"type\":\"bool\"}],\"name\":\"callWithData\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"last_earn_block\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"changePause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"staker\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eth_usdc_router\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ef_token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crv\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"extra_yield_tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdraw_fee_ratio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee_pool\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_new\",\"type\":\"address\"},{\"name\":\"_swap\",\"type\":\"address\"},{\"name\":\"_types\",\"type\":\"uint256\"}],\"name\":\"addExtraToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"harvest_fee_ratio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crv_cvxcrv_router\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_wfee\",\"type\":\"uint256\"},{\"name\":\"_hfee\",\"type\":\"uint256\"}],\"name\":\"changeFeeConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eth_crv_router\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cvxcrv\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"changeSlippage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeExtraToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eth_usdt_router\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deposit_target_amount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLPTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tri_curve\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getVirtualPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"earnReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ef_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"target_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stable_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cff_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"virtual_price\",\"type\":\"uint256\"}],\"name\":\"CFFDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"target_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee_amount\",\"type\":\"uint256\"}],\"name\":\"CFFDepositFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"target_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stable_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"cff_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"target_fee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"virtual_price\",\"type\":\"uint256\"}],\"name\":\"CFFWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"EFRefundCRV\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fee_pool\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"withdraw_fee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"harvest_fee\",\"type\":\"uint256\"}],\"name\":\"ChangeFeeConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"is_paused\",\"type\":\"bool\"}],\"name\":\"CFFChangePause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_new\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"types\",\"type\":\"uint256\"}],\"name\":\"AddExtraToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"RemoveExtraToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "EFCRVVault", "CompilerVersion": "v0.5.10+commit.5a6ea5b1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000da503732a8593856fcc8ab13fb517921010f38e3", "EVMVersion": "Default", "Library": "SafeMath:071108ad85d7a766b41e0f5e5195537a8fc8e74d", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}