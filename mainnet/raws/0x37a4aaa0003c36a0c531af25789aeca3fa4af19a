{"status": "1", "message": "OK", "result": [{"SourceCode": "// Sources flattened with hardhat v2.7.0 https://hardhat.org\r\n\r\n// File sol-temple/src/tokens/ERC721.sol@v1.2.1\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * @title ERC721\r\n * @notice A complete ERC721 implementation including metadata and enumerable\r\n * functions. Completely gas optimized and extensible.\r\n */\r\nabstract contract ERC721 {\r\n\r\n  /// @notice See {ERC721-Transfer}.\r\n  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n  /// @notice See {ERC721-Approval}.\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n  /// @notice See {ERC721-ApprovalForAll}.\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  /// @notice See {ERC721Metadata-name}.\r\n  string public name;\r\n  /// @notice See {ERC721Metadata-symbol}.\r\n  string public symbol;\r\n\r\n  /// @notice See {ERC721Enumerable-totalSupply}.\r\n  uint256 public totalSupply;\r\n\r\n  /// @notice Array of all owners.\r\n  address[] private _owners;\r\n  /// @notice Mapping of all balances.\r\n  mapping(address => uint256) private _balanceOf;\r\n  /// @notice Mapping from token Id to it's approved address.\r\n  mapping(uint256 => address) private _tokenApprovals;\r\n  /// @notice Mapping of approvals between owner and operator.\r\n  mapping(address => mapping(address => bool)) private _isApprovedForAll;\r\n\r\n  constructor(string memory name_, string memory symbol_) {\r\n    name = name_;\r\n    symbol = symbol_;\r\n  }\r\n\r\n  /// @notice See {ERC721-balanceOf}.\r\n  function balanceOf(address account_) public view virtual returns (uint256) {\r\n    require(account_ != address(0), \"ERC721: balance query for the zero address\");\r\n    return _balanceOf[account_];\r\n  }\r\n\r\n  /// @notice See {ERC721-ownerOf}.\r\n  function ownerOf(uint256 tokenId_) public view virtual returns (address) {\r\n    require(_exists(tokenId_), \"ERC721: query for nonexistent token\");\r\n    address owner = _owners[tokenId_];\r\n    return owner;\r\n  }\r\n\r\n  /// @notice See {ERC721Metadata-tokenURI}.\r\n  function tokenURI(uint256) public view virtual returns (string memory);\r\n\r\n  /// @notice See {ERC721-approve}.\r\n  function approve(address to_, uint256 tokenId_) public virtual {\r\n    address owner = ownerOf(tokenId_);\r\n    require(to_ != owner, \"ERC721: approval to current owner\");\r\n\r\n    require(\r\n      msg.sender == owner || _isApprovedForAll[owner][msg.sender],\r\n      \"ERC721: caller is not owner nor approved for all\"\r\n    );\r\n\r\n    _approve(to_, tokenId_);\r\n  }\r\n\r\n  /// @notice See {ERC721-getApproved}.\r\n  function getApproved(uint256 tokenId_) public view virtual returns (address) {\r\n    require(_exists(tokenId_), \"ERC721: query for nonexistent token\");\r\n    return _tokenApprovals[tokenId_];\r\n  }\r\n\r\n  /// @notice See {ERC721-setApprovalForAll}.\r\n  function setApprovalForAll(address operator_, bool approved_) public virtual {\r\n    _setApprovalForAll(msg.sender, operator_, approved_);\r\n  }\r\n\r\n  /// @notice See {ERC721-isApprovedForAll}.\r\n  function isApprovedForAll(address account_, address operator_) public view virtual returns (bool) {\r\n    return _isApprovedForAll[account_][operator_];\r\n  }\r\n\r\n  /// @notice See {ERC721-transferFrom}.\r\n  function transferFrom(\r\n    address from_,\r\n    address to_,\r\n    uint256 tokenId_\r\n  ) public virtual {\r\n    require(_isApprovedOrOwner(msg.sender, tokenId_), \"ERC721: transfer caller is not owner nor approved\");\r\n    _transfer(from_, to_, tokenId_);\r\n  }\r\n\r\n  /// @notice See {ERC721-safeTransferFrom}.\r\n  function safeTransferFrom(\r\n    address from_,\r\n    address to_,\r\n    uint256 tokenId_\r\n  ) public virtual {\r\n    safeTransferFrom(from_, to_, tokenId_, \"\");\r\n  }\r\n\r\n  /// @notice See {ERC721-safeTransferFrom}.\r\n  function safeTransferFrom(\r\n    address from_,\r\n    address to_,\r\n    uint256 tokenId_,\r\n    bytes memory data_\r\n  ) public virtual {\r\n    require(_isApprovedOrOwner(msg.sender, tokenId_), \"ERC721: transfer caller is not owner nor approved\");\r\n    _safeTransfer(from_, to_, tokenId_, data_);\r\n  }\r\n\r\n  /// @notice See {ERC721Enumerable.tokenOfOwnerByIndex}.\r\n  function tokenOfOwnerByIndex(address account_, uint256 index_) public view returns (uint256 tokenId) {\r\n    require(index_ < balanceOf(account_), \"ERC721Enumerable: Index out of bounds\");\r\n    uint256 count;\r\n    for (uint256 i; i < _owners.length; ++i) {\r\n      if (account_ == _owners[i]) {\r\n        if (count == index_) return i;\r\n        else count++;\r\n      }\r\n    }\r\n    revert(\"ERC721Enumerable: Index out of bounds\");\r\n  }\r\n\r\n  /// @notice See {ERC721Enumerable.tokenByIndex}.\r\n  function tokenByIndex(uint256 index_) public view virtual returns (uint256) {\r\n    require(index_ < _owners.length, \"ERC721Enumerable: Index out of bounds\");\r\n    return index_;\r\n  }\r\n\r\n  /// @notice Returns a list of all token Ids owned by `owner`.\r\n  function walletOfOwner(address account_) public view returns (uint256[] memory) {\r\n    uint256 balance = balanceOf(account_);\r\n    uint256[] memory ids = new uint256[](balance);\r\n    for (uint256 i = 0; i < balance; i++) {\r\n      ids[i] = tokenOfOwnerByIndex(account_, i);\r\n    }\r\n    return ids;\r\n  }\r\n\r\n   /**\r\n   * @notice Safely transfers `tokenId_` token from `from_` to `to`, checking first that contract recipients\r\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n   */\r\n  function _safeTransfer(\r\n    address from_,\r\n    address to_,\r\n    uint256 tokenId_,\r\n    bytes memory data_\r\n  ) internal virtual {\r\n    _transfer(from_, to_, tokenId_);\r\n    _checkOnERC721Received(from_, to_, tokenId_, data_);\r\n  }\r\n\r\n  /// @notice Returns whether `tokenId_` exists.\r\n  function _exists(uint256 tokenId_) internal view virtual returns (bool) {\r\n    return tokenId_ < _owners.length && _owners[tokenId_] != address(0);\r\n  }\r\n\r\n  /// @notice Returns whether `spender_` is allowed to manage `tokenId`.\r\n  function _isApprovedOrOwner(address spender_, uint256 tokenId_) internal view virtual returns (bool) {\r\n    require(_exists(tokenId_), \"ERC721: query for nonexistent token\");\r\n    address owner = _owners[tokenId_];\r\n    return (spender_ == owner || getApproved(tokenId_) == spender_ || isApprovedForAll(owner, spender_));\r\n  }\r\n\r\n  /// @notice Safely mints `tokenId_` and transfers it to `to`.\r\n  function _safeMint(address to_, uint256 tokenId_) internal virtual {\r\n    _safeMint(to_, tokenId_, \"\");\r\n  }\r\n\r\n  /**\r\n   * @notice Same as {_safeMint}, but with an additional `data_` parameter which is\r\n   * forwarded in {ERC721Receiver-onERC721Received} to contract recipients.\r\n   */\r\n  function _safeMint(\r\n    address to_,\r\n    uint256 tokenId_,\r\n    bytes memory data_\r\n  ) internal virtual {\r\n    _mint(to_, tokenId_);\r\n    _checkOnERC721Received(address(0), to_, tokenId_, data_);\r\n  }\r\n\r\n  /// @notice Mints `tokenId_` and transfers it to `to_`.\r\n  function _mint(address to_, uint256 tokenId_) internal virtual {\r\n    require(!_exists(tokenId_), \"ERC721: token already minted\");\r\n\r\n    _beforeTokenTransfer(address(0), to_, tokenId_);\r\n\r\n    _owners.push(to_);\r\n    totalSupply++;\r\n    unchecked {\r\n      _balanceOf[to_]++;\r\n    }\r\n\r\n    emit Transfer(address(0), to_, tokenId_);\r\n    _afterTokenTransfer(address(0), to_, tokenId_);\r\n  }\r\n\r\n  /// @notice Destroys `tokenId`. The approval is cleared when the token is burned.\r\n  function _burn(uint256 tokenId_) internal virtual {\r\n    address owner = ownerOf(tokenId_);\r\n\r\n    _beforeTokenTransfer(owner, address(0), tokenId_);\r\n\r\n    // Clear approvals\r\n    _approve(address(0), tokenId_);\r\n    delete _owners[tokenId_];\r\n    totalSupply--;\r\n    _balanceOf[owner]--;\r\n\r\n    emit Transfer(owner, address(0), tokenId_);\r\n    _afterTokenTransfer(owner, address(0), tokenId_);\r\n  }\r\n\r\n  /// @notice Transfers `tokenId_` from `from_` to `to`.\r\n  function _transfer(\r\n    address from_,\r\n    address to_,\r\n    uint256 tokenId_\r\n  ) internal virtual {\r\n    require(_owners[tokenId_] == from_, \"ERC721: transfer of token that is not own\");\r\n\r\n    _beforeTokenTransfer(from_, to_, tokenId_);\r\n\r\n    // Clear approvals from the previous owner\r\n    _approve(address(0), tokenId_);\r\n\r\n    _owners[tokenId_] = to_;\r\n    unchecked {\r\n      _balanceOf[from_]--;\r\n      _balanceOf[to_]++;\r\n    }\r\n\r\n    emit Transfer(from_, to_, tokenId_);\r\n    _afterTokenTransfer(from_, to_, tokenId_);\r\n  }\r\n\r\n  /// @notice Approve `to_` to operate on `tokenId_`\r\n  function _approve(address to_, uint256 tokenId_) internal virtual {\r\n    _tokenApprovals[tokenId_] = to_;\r\n    emit Approval(_owners[tokenId_], to_, tokenId_);\r\n  }\r\n\r\n  /// @notice Approve `operator_` to operate on all of `account_` tokens.\r\n  function _setApprovalForAll(\r\n    address account_,\r\n    address operator_,\r\n    bool approved_\r\n  ) internal virtual {\r\n    require(account_ != operator_, \"ERC721: approve to caller\");\r\n    _isApprovedForAll[account_][operator_] = approved_;\r\n    emit ApprovalForAll(account_, operator_, approved_);\r\n  }\r\n\r\n  /// @notice ERC721Receiver callback checking and calling helper.\r\n  function _checkOnERC721Received(\r\n    address from_,\r\n    address to_,\r\n    uint256 tokenId_,\r\n    bytes memory data_\r\n  ) private {\r\n    if (to_.code.length > 0) {\r\n      try IERC721Receiver(to_).onERC721Received(msg.sender, from_, tokenId_, data_) returns (bytes4 returned) {\r\n        require(returned == 0x150b7a02, \"ERC721: safe transfer to non ERC721Receiver implementation\");\r\n      } catch (bytes memory reason) {\r\n        if (reason.length == 0) {\r\n          revert(\"ERC721: safe transfer to non ERC721Receiver implementation\");\r\n        } else {\r\n          assembly {\r\n            revert(add(32, reason), mload(reason))\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice Hook that is called before any token transfer.\r\n  function _beforeTokenTransfer(\r\n    address from_,\r\n    address to_,\r\n    uint256 tokenId_\r\n  ) internal virtual {}\r\n\r\n  /// @notice Hook that is called after any token transfer.\r\n  function _afterTokenTransfer(\r\n    address from_,\r\n    address to_,\r\n    uint256 tokenId_\r\n  ) internal virtual {}\r\n\r\n\r\n  /// @notice See {IERC165-supportsInterface}.\r\n  function supportsInterface(bytes4 interfaceId_) public view virtual returns (bool) {\r\n    return\r\n      interfaceId_ == 0x80ac58cd || // ERC721\r\n      interfaceId_ == 0x5b5e139f || // ERC721Metadata\r\n      interfaceId_ == 0x780e9d63 || // ERC721Enumerable\r\n      interfaceId_ == 0x01ffc9a7; // ERC165\r\n  }\r\n}\r\n\r\ninterface IERC721Receiver {\r\n  function onERC721Received(\r\n    address operator,\r\n    address from,\r\n    uint256 tokenId,\r\n    bytes memory data\r\n  ) external returns (bytes4);\r\n}\r\n\r\n\r\n// File sol-temple/src/utils/Auth.sol@v1.2.1\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * @title Auth\r\n * @notice Just a simple authing system.\r\n */\r\nabstract contract Auth {\r\n\r\n\r\n  /// @notice Emitted when the ownership is transfered.\r\n  event OwnershipTransfered(address indexed from, address indexed to);\r\n\r\n  /// @notice Contract's owner address.\r\n  address public owner;\r\n\r\n  /// @notice A simple modifier just to check whether the sender is the owner.\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"Auth: sender is not the owner\");\r\n    _;\r\n  }\r\n\r\n\r\n\r\n  constructor() {\r\n    _transferOwnership(msg.sender);\r\n  }\r\n\r\n  /// @notice Set the owner address to `owner_`.\r\n  function transferOwnership(address owner_) public onlyOwner {\r\n    require(owner != owner_, \"Auth: transfering ownership to current owner\");\r\n    _transferOwnership(owner_);\r\n  }\r\n\r\n  /// @notice Set the owner address to `owner_`. Does not require anything\r\n  function _transferOwnership(address owner_) internal {\r\n    address oldOwner = owner;\r\n    owner = owner_;\r\n\r\n    emit OwnershipTransfered(oldOwner, owner_);\r\n  }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Strings.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC721/IERC721.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/IERC1155.sol@v4.4.2\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n// File contracts/CoolCazuki.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.11;\r\n\r\ncontract CoolCazuki is Auth, ERC721 {\r\n  using Strings for uint256;\r\n\r\n  /// @notice Max supply.\r\n  uint256 public constant SUPPLY_MAX = 5000;\r\n  /// @notice Max amount per claim.\r\n  uint256 public constant SUPPLY_PER_TX = 10;\r\n\r\n  /// @notice 0 = CLOSED, 1 = PUBLIC.\r\n  uint256 public saleState;\r\n\r\n  /// @notice OpenSea proxy registry.\r\n  address public opensea = 0xa5409ec958C83C3f309868babACA7c86DCB077c1;\r\n  /// @notice LooksRare marketplace transfer manager.\r\n  address public looksrare = 0xf42aa99F011A1fA7CDA90E5E98b277E306BcA83e;\r\n  /// @notice Check if marketplaces pre-approve is enabled.\r\n  bool public marketplacesApproved = true;\r\n\r\n  /// @notice Unrevelead URI.\r\n  string public unrevealedURI;\r\n  /// @notice Metadata base URI.\r\n  string public baseURI;\r\n  /// @notice Metadata base file extension.\r\n  string public baseExtension;\r\n\r\n  constructor(string memory newUnrevealedURI) ERC721(\"Cool Cazuki\", \"CoolCazuki\") {\r\n    unrevealedURI = newUnrevealedURI;\r\n  }\r\n\r\n  /// @notice Claim one or more tokens.\r\n  function mint(uint256 amount) external payable {\r\n    uint256 supply = totalSupply;\r\n    require(supply + amount <= SUPPLY_MAX, \"Max supply exceeded\");\r\n    if (msg.sender != owner) {\r\n      require(saleState == 1, \"Public sale is not open\");\r\n      require(amount > 0 && amount <= SUPPLY_PER_TX, \"Invalid claim amount\");\r\n      if (supply <= 1000) require(msg.value == 0, \"Invalid ether amount\");\r\n      else require(msg.value == amount * 0.01 ether, \"Invalid ether amount\");\r\n    }\r\n\r\n    for (uint256 i = 0; i < amount; i++) _safeMint(msg.sender, supply++);\r\n  }\r\n\r\n  /// @notice See {IERC721-tokenURI}.\r\n  function tokenURI(uint256 id) public view override returns (string memory) {\r\n    require(_exists(id), \"ERC721Metadata: query for nonexisting token\");\r\n\r\n    if (bytes(unrevealedURI).length > 0) return unrevealedURI;\r\n    return string(abi.encodePacked(baseURI, id.toString(), baseExtension));\r\n  }\r\n\r\n  /// @notice Set baseURI to `newBaseURI`.\r\n  function setBaseURI(string memory newBaseURI, string memory newBaseExtension) external onlyOwner {\r\n    baseURI = newBaseURI;\r\n    baseExtension = newBaseExtension;\r\n    delete unrevealedURI;\r\n  }\r\n\r\n  /// @notice Set unrevealedURI to `newUnrevealedURI`.\r\n  function setUnrevealedURI(string memory newUnrevealedURI) external onlyOwner {\r\n    unrevealedURI = newUnrevealedURI;\r\n    \r\n  }\r\n\r\n  /// @notice Set saleState to `newSaleState`.\r\n  function setSaleState(uint256 newSaleState) external onlyOwner {\r\n    saleState = newSaleState;\r\n  }\r\n\r\n  /// @notice Set opensea to `newOpensea`.\r\n  function setOpensea(address newOpensea) external onlyOwner {\r\n    opensea = newOpensea;\r\n  }\r\n\r\n  /// @notice Set looksrare to `newLooksrare`.\r\n  function setLooksrare(address newLooksrare) external onlyOwner {\r\n    looksrare = newLooksrare;\r\n  }\r\n\r\n  /// @notice Toggle pre-approve feature state for sender.\r\n  function toggleMarketplacesApproved() external onlyOwner {\r\n    marketplacesApproved = !marketplacesApproved;\r\n  }\r\n\r\n  /// @notice Withdraw `value` of ether to the sender.\r\n  function withdraw(address payable to, uint256 amount) external onlyOwner {\r\n    to.transfer(amount);\r\n  }\r\n\r\n  /// @notice Withdraw `value` of `token` to the sender.\r\n  function withdrawERC20(IERC20 token, uint256 value) external onlyOwner {\r\n    token.transfer(msg.sender, value);\r\n  }\r\n\r\n  /// @notice Withdraw `id` of `token` to the sender.\r\n  function withdrawERC721(IERC721 token, uint256 id) external onlyOwner {\r\n    token.safeTransferFrom(address(this), msg.sender, id);\r\n  }\r\n\r\n  /// @notice Withdraw `id` with `value` from `token` to the sender.\r\n  function withdrawERC1155(\r\n    IERC1155 token,\r\n    uint256 id,\r\n    uint256 value\r\n  ) external onlyOwner {\r\n    token.safeTransferFrom(address(this), msg.sender, id, value, \"\");\r\n  }\r\n\r\n  /// @dev Modified for opensea and looksrare pre-approve so users can make truly gasless sales.\r\n  function isApprovedForAll(address owner, address operator) public view override returns (bool) {\r\n    if (!marketplacesApproved) return super.isApprovedForAll(owner, operator);\r\n\r\n    return\r\n      operator == address(ProxyRegistry(opensea).proxies(owner)) ||\r\n      operator == looksrare ||\r\n      super.isApprovedForAll(owner, operator);\r\n  }\r\n}\r\n\r\ncontract OwnableDelegateProxy {}\r\n\r\ncontract ProxyRegistry {\r\n  mapping(address => OwnableDelegateProxy) public proxies;\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newUnrevealedURI\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SUPPLY_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPPLY_PER_TX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseExtension\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"looksrare\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketplacesApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"opensea\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved_\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newBaseExtension\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLooksrare\",\"type\":\"address\"}],\"name\":\"setLooksrare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOpensea\",\"type\":\"address\"}],\"name\":\"setOpensea\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSaleState\",\"type\":\"uint256\"}],\"name\":\"setSaleState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newUnrevealedURI\",\"type\":\"string\"}],\"name\":\"setUnrevealedURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId_\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleMarketplacesApproved\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unrevealedURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"walletOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"withdrawERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CoolCazuki", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000036697066733a2f2f516d5a6568725676656d6d5a3775744a47775551635268743879547077573334786a746d384d48454c6a574851712f00000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ce503393bbe4fe76cb67e42337c2e1dcdf380ae7ef5633c3ffd26ae3f5b441e6"}]}