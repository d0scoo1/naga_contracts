{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/discovery/GNS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport \\\"../base/Multicall.sol\\\";\\nimport \\\"../bancor/BancorFormula.sol\\\";\\nimport \\\"../upgrades/GraphUpgradeable.sol\\\";\\nimport \\\"../utils/TokenUtils.sol\\\";\\n\\nimport \\\"./IGNS.sol\\\";\\nimport \\\"./GNSStorage.sol\\\";\\n\\n/**\\n * @title GNS\\n * @dev The Graph Name System contract provides a decentralized naming system for subgraphs\\n * used in the scope of the Graph Network. It translates Subgraphs into Subgraph Versions.\\n * Each version is associated with a Subgraph Deployment. The contract has no knowledge of\\n * human-readable names. All human readable names emitted in events.\\n * The contract implements a multicall behaviour to support batching multiple calls in a single\\n * transaction.\\n */\\ncontract GNS is GNSV2Storage, GraphUpgradeable, IGNS, Multicall {\\n    using SafeMath for uint256;\\n\\n    // -- Constants --\\n\\n    uint256 private constant MAX_UINT256 = 2**256 - 1;\\n\\n    // 100% in parts per million\\n    uint32 private constant MAX_PPM = 1000000;\\n\\n    // Equates to Connector weight on bancor formula to be CW = 1\\n    uint32 private constant defaultReserveRatio = 1000000;\\n\\n    // -- Events --\\n\\n    event SubgraphNFTUpdated(address subgraphNFT);\\n\\n    /**\\n     * @dev Emitted when graph account sets its default name\\n     */\\n    event SetDefaultName(\\n        address indexed graphAccount,\\n        uint256 nameSystem, // only ENS for now\\n        bytes32 nameIdentifier,\\n        string name\\n    );\\n\\n    /**\\n     * @dev Emitted when the subgraph metadata is updated.\\n     */\\n    event SubgraphMetadataUpdated(uint256 indexed subgraphID, bytes32 subgraphMetadata);\\n\\n    /**\\n     * @dev Emitted when a subgraph version is updated.\\n     */\\n    event SubgraphVersionUpdated(\\n        uint256 indexed subgraphID,\\n        bytes32 indexed subgraphDeploymentID,\\n        bytes32 versionMetadata\\n    );\\n\\n    /**\\n     * @dev Emitted when a curator mints signal.\\n     */\\n    event SignalMinted(\\n        uint256 indexed subgraphID,\\n        address indexed curator,\\n        uint256 nSignalCreated,\\n        uint256 vSignalCreated,\\n        uint256 tokensDeposited\\n    );\\n\\n    /**\\n     * @dev Emitted when a curator burns signal.\\n     */\\n    event SignalBurned(\\n        uint256 indexed subgraphID,\\n        address indexed curator,\\n        uint256 nSignalBurnt,\\n        uint256 vSignalBurnt,\\n        uint256 tokensReceived\\n    );\\n\\n    /**\\n     * @dev Emitted when a subgraph is created.\\n     */\\n    event SubgraphPublished(\\n        uint256 indexed subgraphID,\\n        bytes32 indexed subgraphDeploymentID,\\n        uint32 reserveRatio\\n    );\\n\\n    /**\\n     * @dev Emitted when a subgraph is upgraded to point to a new\\n     * subgraph deployment, burning all the old vSignal and depositing the GRT into the\\n     * new vSignal curve.\\n     */\\n    event SubgraphUpgraded(\\n        uint256 indexed subgraphID,\\n        uint256 vSignalCreated,\\n        uint256 tokensSignalled,\\n        bytes32 indexed subgraphDeploymentID\\n    );\\n\\n    /**\\n     * @dev Emitted when a subgraph is deprecated.\\n     */\\n    event SubgraphDeprecated(uint256 indexed subgraphID, uint256 withdrawableGRT);\\n\\n    /**\\n     * @dev Emitted when a curator withdraws GRT from a deprecated subgraph\\n     */\\n    event GRTWithdrawn(\\n        uint256 indexed subgraphID,\\n        address indexed curator,\\n        uint256 nSignalBurnt,\\n        uint256 withdrawnGRT\\n    );\\n\\n    // -- Modifiers --\\n\\n    /**\\n     * @dev Emitted when a legacy subgraph is claimed\\n     */\\n    event LegacySubgraphClaimed(address indexed graphAccount, uint256 subgraphNumber);\\n\\n    /**\\n     * @dev Modifier that allows only a subgraph operator to be the caller\\n     */\\n    modifier onlySubgraphAuth(uint256 _subgraphID) {\\n        require(ownerOf(_subgraphID) == msg.sender, \\\"GNS: Must be authorized\\\");\\n        _;\\n    }\\n\\n    // -- Functions --\\n\\n    /**\\n     * @dev Initialize this contract.\\n     */\\n    function initialize(\\n        address _controller,\\n        address _bondingCurve,\\n        address _subgraphNFT\\n    ) external onlyImpl {\\n        Managed._initialize(_controller);\\n\\n        // Dependencies\\n        bondingCurve = _bondingCurve;\\n\\n        // Settings\\n        _setOwnerTaxPercentage(500000);\\n        _setSubgraphNFT(_subgraphNFT);\\n    }\\n\\n    /**\\n     * @dev Approve curation contract to pull funds.\\n     */\\n    function approveAll() external override {\\n        graphToken().approve(address(curation()), MAX_UINT256);\\n    }\\n\\n    // -- Config --\\n\\n    /**\\n     * @dev Set the owner fee percentage. This is used to prevent a subgraph owner to drain all\\n     * the name curators tokens while upgrading or deprecating and is configurable in parts per million.\\n     * @param _ownerTaxPercentage Owner tax percentage\\n     */\\n    function setOwnerTaxPercentage(uint32 _ownerTaxPercentage) external override onlyGovernor {\\n        _setOwnerTaxPercentage(_ownerTaxPercentage);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the owner tax percentage. This is used to prevent a subgraph owner to drain all\\n     * the name curators tokens while upgrading or deprecating and is configurable in parts per million.\\n     * @param _ownerTaxPercentage Owner tax percentage\\n     */\\n    function _setOwnerTaxPercentage(uint32 _ownerTaxPercentage) private {\\n        require(_ownerTaxPercentage <= MAX_PPM, \\\"Owner tax must be MAX_PPM or less\\\");\\n        ownerTaxPercentage = _ownerTaxPercentage;\\n        emit ParameterUpdated(\\\"ownerTaxPercentage\\\");\\n    }\\n\\n    /**\\n     * @dev Set the NFT registry contract\\n     * NOTE: Calling this function will break the ownership model unless\\n     * it is replaced with a fully migrated version of the NFT contract state\\n     * Use with care.\\n     * @param _subgraphNFT Address of the ERC721 contract\\n     */\\n    function setSubgraphNFT(address _subgraphNFT) public onlyGovernor {\\n        _setSubgraphNFT(_subgraphNFT);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the NFT registry contract\\n     * @param _subgraphNFT Address of the ERC721 contract\\n     */\\n    function _setSubgraphNFT(address _subgraphNFT) private {\\n        require(\\n            _subgraphNFT != address(0) && Address.isContract(_subgraphNFT),\\n            \\\"NFT must be valid\\\"\\n        );\\n        subgraphNFT = ISubgraphNFT(_subgraphNFT);\\n        emit SubgraphNFTUpdated(_subgraphNFT);\\n    }\\n\\n    // -- Actions --\\n\\n    /**\\n     * @dev Allows a graph account to set a default name\\n     * @param _graphAccount Account that is setting its name\\n     * @param _nameSystem Name system account already has ownership of a name in\\n     * @param _nameIdentifier The unique identifier that is used to identify the name in the system\\n     * @param _name The name being set as default\\n     */\\n    function setDefaultName(\\n        address _graphAccount,\\n        uint8 _nameSystem,\\n        bytes32 _nameIdentifier,\\n        string calldata _name\\n    ) external override {\\n        require(_graphAccount == msg.sender, \\\"GNS: Only you can set your name\\\");\\n        emit SetDefaultName(_graphAccount, _nameSystem, _nameIdentifier, _name);\\n    }\\n\\n    /**\\n     * @dev Allows a subgraph owner to update the metadata of a subgraph they have published\\n     * @param _subgraphID Subgraph ID\\n     * @param _subgraphMetadata IPFS hash for the subgraph metadata\\n     */\\n    function updateSubgraphMetadata(uint256 _subgraphID, bytes32 _subgraphMetadata)\\n        public\\n        override\\n        onlySubgraphAuth(_subgraphID)\\n    {\\n        _setSubgraphMetadata(_subgraphID, _subgraphMetadata);\\n    }\\n\\n    /**\\n     * @dev Publish a new subgraph.\\n     * @param _subgraphDeploymentID Subgraph deployment for the subgraph\\n     * @param _versionMetadata IPFS hash for the subgraph version metadata\\n     * @param _subgraphMetadata IPFS hash for the subgraph metadata\\n     */\\n    function publishNewSubgraph(\\n        bytes32 _subgraphDeploymentID,\\n        bytes32 _versionMetadata,\\n        bytes32 _subgraphMetadata\\n    ) external override notPaused {\\n        // Subgraph deployment must be non-empty\\n        require(_subgraphDeploymentID != 0, \\\"GNS: Cannot set deploymentID to 0 in publish\\\");\\n\\n        // Init the subgraph\\n        address subgraphOwner = msg.sender;\\n        uint256 subgraphID = _nextSubgraphID(subgraphOwner);\\n        SubgraphData storage subgraphData = _getSubgraphData(subgraphID);\\n        subgraphData.subgraphDeploymentID = _subgraphDeploymentID;\\n        subgraphData.reserveRatio = defaultReserveRatio;\\n\\n        // Mint the NFT. Use the subgraphID as tokenID.\\n        // This function will check the if tokenID already exists.\\n        _mintNFT(subgraphOwner, subgraphID);\\n        emit SubgraphPublished(subgraphID, _subgraphDeploymentID, defaultReserveRatio);\\n\\n        // Set the token metadata\\n        _setSubgraphMetadata(subgraphID, _subgraphMetadata);\\n\\n        emit SubgraphVersionUpdated(subgraphID, _subgraphDeploymentID, _versionMetadata);\\n    }\\n\\n    /**\\n     * @dev Publish a new version of an existing subgraph.\\n     * @param _subgraphID Subgraph ID\\n     * @param _subgraphDeploymentID Subgraph deployment ID of the new version\\n     * @param _versionMetadata IPFS hash for the subgraph version metadata\\n     */\\n    function publishNewVersion(\\n        uint256 _subgraphID,\\n        bytes32 _subgraphDeploymentID,\\n        bytes32 _versionMetadata\\n    ) external override notPaused onlySubgraphAuth(_subgraphID) {\\n        // Perform the upgrade from the current subgraph deployment to the new one.\\n        // This involves burning all signal from the old deployment and using the funds to buy\\n        // from the new deployment.\\n        // This will also make the change to target to the new deployment.\\n\\n        // Subgraph check\\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\\n\\n        // New subgraph deployment must be non-empty\\n        require(_subgraphDeploymentID != 0, \\\"GNS: Cannot set deploymentID to 0 in publish\\\");\\n\\n        // New subgraph deployment must be different than current\\n        require(\\n            _subgraphDeploymentID != subgraphData.subgraphDeploymentID,\\n            \\\"GNS: Cannot publish a new version with the same subgraph deployment ID\\\"\\n        );\\n\\n        // This is to prevent the owner from front running its name curators signal by posting\\n        // its own signal ahead, bringing the name curators in, and dumping on them\\n        ICuration curation = curation();\\n        require(\\n            !curation.isCurated(_subgraphDeploymentID),\\n            \\\"GNS: Owner cannot point to a subgraphID that has been pre-curated\\\"\\n        );\\n\\n        // Move all signal from previous version to new version\\n        // NOTE: We will only do this as long as there is signal on the subgraph\\n        if (subgraphData.nSignal > 0) {\\n            // Burn all version signal in the name pool for tokens (w/no slippage protection)\\n            // Sell all signal from the old deployment\\n            uint256 tokens = curation.burn(\\n                subgraphData.subgraphDeploymentID,\\n                subgraphData.vSignal,\\n                0\\n            );\\n\\n            // Take the owner cut of the curation tax, add it to the total\\n            // Upgrade is only callable by the owner, we assume then that msg.sender = owner\\n            address subgraphOwner = msg.sender;\\n            uint256 tokensWithTax = _chargeOwnerTax(\\n                tokens,\\n                subgraphOwner,\\n                curation.curationTaxPercentage()\\n            );\\n\\n            // Update pool: constant nSignal, vSignal can change (w/no slippage protection)\\n            // Buy all signal from the new deployment\\n            (subgraphData.vSignal, ) = curation.mint(_subgraphDeploymentID, tokensWithTax, 0);\\n\\n            emit SubgraphUpgraded(\\n                _subgraphID,\\n                subgraphData.vSignal,\\n                tokensWithTax,\\n                _subgraphDeploymentID\\n            );\\n        }\\n\\n        // Update target deployment\\n        subgraphData.subgraphDeploymentID = _subgraphDeploymentID;\\n\\n        emit SubgraphVersionUpdated(_subgraphID, _subgraphDeploymentID, _versionMetadata);\\n    }\\n\\n    /**\\n     * @dev Deprecate a subgraph. The bonding curve is destroyed, the vSignal is burned, and the GNS\\n     * contract holds the GRT from burning the vSignal, which all curators can withdraw manually.\\n     * Can only be done by the subgraph owner.\\n     * @param _subgraphID Subgraph ID\\n     */\\n    function deprecateSubgraph(uint256 _subgraphID)\\n        external\\n        override\\n        notPaused\\n        onlySubgraphAuth(_subgraphID)\\n    {\\n        // Subgraph check\\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\\n\\n        // Burn signal only if it has any available\\n        if (subgraphData.nSignal > 0) {\\n            subgraphData.withdrawableGRT = curation().burn(\\n                subgraphData.subgraphDeploymentID,\\n                subgraphData.vSignal,\\n                0\\n            );\\n        }\\n\\n        // Deprecate the subgraph and do cleanup\\n        subgraphData.disabled = true;\\n        subgraphData.vSignal = 0;\\n        subgraphData.reserveRatio = 0;\\n        // NOTE: We don't reset the following variable as we use it to test if the Subgraph was ever created\\n        // subgraphData.subgraphDeploymentID = 0;\\n\\n        // Burn the NFT\\n        _burnNFT(_subgraphID);\\n\\n        emit SubgraphDeprecated(_subgraphID, subgraphData.withdrawableGRT);\\n    }\\n\\n    /**\\n     * @dev Deposit GRT into a subgraph and mint signal.\\n     * @param _subgraphID Subgraph ID\\n     * @param _tokensIn The amount of tokens the nameCurator wants to deposit\\n     * @param _nSignalOutMin Expected minimum amount of name signal to receive\\n     */\\n    function mintSignal(\\n        uint256 _subgraphID,\\n        uint256 _tokensIn,\\n        uint256 _nSignalOutMin\\n    ) external override notPartialPaused {\\n        // Subgraph checks\\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\\n\\n        // Pull tokens from sender\\n        address curator = msg.sender;\\n        TokenUtils.pullTokens(graphToken(), curator, _tokensIn);\\n\\n        // Get name signal to mint for tokens deposited\\n        (uint256 vSignal, ) = curation().mint(subgraphData.subgraphDeploymentID, _tokensIn, 0);\\n        uint256 nSignal = vSignalToNSignal(_subgraphID, vSignal);\\n\\n        // Slippage protection\\n        require(nSignal >= _nSignalOutMin, \\\"GNS: Slippage protection\\\");\\n\\n        // Update pools\\n        subgraphData.vSignal = subgraphData.vSignal.add(vSignal);\\n        subgraphData.nSignal = subgraphData.nSignal.add(nSignal);\\n        subgraphData.curatorNSignal[curator] = subgraphData.curatorNSignal[curator].add(nSignal);\\n\\n        emit SignalMinted(_subgraphID, curator, nSignal, vSignal, _tokensIn);\\n    }\\n\\n    /**\\n     * @dev Burn signal for a subgraph and return the GRT.\\n     * @param _subgraphID Subgraph ID\\n     * @param _nSignal The amount of nSignal the nameCurator wants to burn\\n     * @param _tokensOutMin Expected minimum amount of tokens to receive\\n     */\\n    function burnSignal(\\n        uint256 _subgraphID,\\n        uint256 _nSignal,\\n        uint256 _tokensOutMin\\n    ) external override notPartialPaused {\\n        // Subgraph checks\\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\\n\\n        // Curator balance checks\\n        address curator = msg.sender;\\n        uint256 curatorNSignal = subgraphData.curatorNSignal[curator];\\n        require(\\n            _nSignal <= curatorNSignal,\\n            \\\"GNS: Curator cannot withdraw more nSignal than they have\\\"\\n        );\\n\\n        // Get tokens for name signal amount to burn\\n        uint256 vSignal = nSignalToVSignal(_subgraphID, _nSignal);\\n        uint256 tokens = curation().burn(subgraphData.subgraphDeploymentID, vSignal, _tokensOutMin);\\n\\n        // Update pools\\n        subgraphData.vSignal = subgraphData.vSignal.sub(vSignal);\\n        subgraphData.nSignal = subgraphData.nSignal.sub(_nSignal);\\n        subgraphData.curatorNSignal[curator] = subgraphData.curatorNSignal[curator].sub(_nSignal);\\n\\n        // Return the tokens to the nameCurator\\n        require(graphToken().transfer(curator, tokens), \\\"GNS: Error sending tokens\\\");\\n\\n        emit SignalBurned(_subgraphID, curator, _nSignal, vSignal, tokens);\\n    }\\n\\n    /**\\n     * @dev Withdraw tokens from a deprecated subgraph.\\n     * When the subgraph is deprecated, any curator can call this function and\\n     * withdraw the GRT they are entitled for its original deposit\\n     * @param _subgraphID Subgraph ID\\n     */\\n    function withdraw(uint256 _subgraphID) external override notPartialPaused {\\n        // Subgraph validations\\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\\n        require(subgraphData.disabled == true, \\\"GNS: Must be disabled first\\\");\\n        require(subgraphData.withdrawableGRT > 0, \\\"GNS: No more GRT to withdraw\\\");\\n\\n        // Curator validations\\n        address curator = msg.sender;\\n        uint256 curatorNSignal = subgraphData.curatorNSignal[curator];\\n        require(curatorNSignal > 0, \\\"GNS: No signal to withdraw GRT\\\");\\n\\n        // Get curator share of tokens to be withdrawn\\n        uint256 tokensOut = curatorNSignal.mul(subgraphData.withdrawableGRT).div(\\n            subgraphData.nSignal\\n        );\\n        subgraphData.curatorNSignal[curator] = 0;\\n        subgraphData.nSignal = subgraphData.nSignal.sub(curatorNSignal);\\n        subgraphData.withdrawableGRT = subgraphData.withdrawableGRT.sub(tokensOut);\\n\\n        // Return tokens to the curator\\n        TokenUtils.pushTokens(graphToken(), curator, tokensOut);\\n\\n        emit GRTWithdrawn(_subgraphID, curator, curatorNSignal, tokensOut);\\n    }\\n\\n    /**\\n     * @dev Calculate tax that owner will have to cover for upgrading or deprecating.\\n     * @param _tokens Tokens that were received from deprecating the old subgraph\\n     * @param _owner Subgraph owner\\n     * @param _curationTaxPercentage Tax percentage on curation deposits from Curation contract\\n     * @return Total tokens that will be sent to curation, _tokens + ownerTax\\n     */\\n    function _chargeOwnerTax(\\n        uint256 _tokens,\\n        address _owner,\\n        uint32 _curationTaxPercentage\\n    ) private returns (uint256) {\\n        if (_curationTaxPercentage == 0 || ownerTaxPercentage == 0) {\\n            return 0;\\n        }\\n\\n        // Tax on the total bonding curve funds\\n        uint256 taxOnOriginal = _tokens.mul(_curationTaxPercentage).div(MAX_PPM);\\n        // Total after the tax\\n        uint256 totalWithoutOwnerTax = _tokens.sub(taxOnOriginal);\\n        // The portion of tax that the owner will pay\\n        uint256 ownerTax = taxOnOriginal.mul(ownerTaxPercentage).div(MAX_PPM);\\n\\n        uint256 totalWithOwnerTax = totalWithoutOwnerTax.add(ownerTax);\\n\\n        // The total after tax, plus owner partial repay, divided by\\n        // the tax, to adjust it slightly upwards. ex:\\n        // 100 GRT, 5 GRT Tax, owner pays 100% --> 5 GRT\\n        // To get 100 in the protocol after tax, Owner deposits\\n        // ~5.26, as ~105.26 * .95 = 100\\n        uint256 totalAdjustedUp = totalWithOwnerTax.mul(MAX_PPM).div(\\n            uint256(MAX_PPM).sub(uint256(_curationTaxPercentage))\\n        );\\n\\n        uint256 ownerTaxAdjustedUp = totalAdjustedUp.sub(_tokens);\\n\\n        // Get the owner of the subgraph to reimburse the curation tax\\n        TokenUtils.pullTokens(graphToken(), _owner, ownerTaxAdjustedUp);\\n\\n        return totalAdjustedUp;\\n    }\\n\\n    /**\\n     * @dev Calculate subgraph signal to be returned for an amount of tokens.\\n     * @param _subgraphID Subgraph ID\\n     * @param _tokensIn Tokens being exchanged for subgraph signal\\n     * @return Amount of subgraph signal and curation tax\\n     */\\n    function tokensToNSignal(uint256 _subgraphID, uint256 _tokensIn)\\n        public\\n        view\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\\n        (uint256 vSignal, uint256 curationTax) = curation().tokensToSignal(\\n            subgraphData.subgraphDeploymentID,\\n            _tokensIn\\n        );\\n        uint256 nSignal = vSignalToNSignal(_subgraphID, vSignal);\\n        return (vSignal, nSignal, curationTax);\\n    }\\n\\n    /**\\n     * @dev Calculate tokens returned for an amount of subgraph signal.\\n     * @param _subgraphID Subgraph ID\\n     * @param _nSignalIn Subgraph signal being exchanged for tokens\\n     * @return Amount of tokens returned for an amount of subgraph signal\\n     */\\n    function nSignalToTokens(uint256 _subgraphID, uint256 _nSignalIn)\\n        public\\n        view\\n        override\\n        returns (uint256, uint256)\\n    {\\n        // Get subgraph or revert if not published\\n        // It does not make sense to convert signal from a disabled or non-existing one\\n        SubgraphData storage subgraphData = _getSubgraphOrRevert(_subgraphID);\\n        uint256 vSignal = nSignalToVSignal(_subgraphID, _nSignalIn);\\n        uint256 tokensOut = curation().signalToTokens(subgraphData.subgraphDeploymentID, vSignal);\\n        return (vSignal, tokensOut);\\n    }\\n\\n    /**\\n     * @dev Calculate subgraph signal to be returned for an amount of subgraph deployment signal.\\n     * @param _subgraphID Subgraph ID\\n     * @param _vSignalIn Amount of subgraph deployment signal to exchange for subgraph signal\\n     * @return Amount of subgraph signal that can be bought\\n     */\\n    function vSignalToNSignal(uint256 _subgraphID, uint256 _vSignalIn)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\\n\\n        // Handle initialization by using 1:1 version to name signal\\n        if (subgraphData.vSignal == 0) {\\n            return _vSignalIn;\\n        }\\n\\n        return\\n            BancorFormula(bondingCurve).calculatePurchaseReturn(\\n                subgraphData.nSignal,\\n                subgraphData.vSignal,\\n                subgraphData.reserveRatio,\\n                _vSignalIn\\n            );\\n    }\\n\\n    /**\\n     * @dev Calculate subgraph deployment signal to be returned for an amount of subgraph signal.\\n     * @param _subgraphID Subgraph ID\\n     * @param _nSignalIn Subgraph signal being exchanged for subgraph deployment signal\\n     * @return Amount of subgraph deployment signal that can be returned\\n     */\\n    function nSignalToVSignal(uint256 _subgraphID, uint256 _nSignalIn)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\\n        return\\n            BancorFormula(bondingCurve).calculateSaleReturn(\\n                subgraphData.nSignal,\\n                subgraphData.vSignal,\\n                subgraphData.reserveRatio,\\n                _nSignalIn\\n            );\\n    }\\n\\n    /**\\n     * @dev Get the amount of subgraph signal a curator has.\\n     * @param _subgraphID Subgraph ID\\n     * @param _curator Curator address\\n     * @return Amount of subgraph signal owned by a curator\\n     */\\n    function getCuratorSignal(uint256 _subgraphID, address _curator)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _getSubgraphData(_subgraphID).curatorNSignal[_curator];\\n    }\\n\\n    /**\\n     * @dev Return the total signal on the subgraph.\\n     * @param _subgraphID Subgraph ID\\n     * @return Total signal on the subgraph\\n     */\\n    function subgraphSignal(uint256 _subgraphID) external view override returns (uint256) {\\n        return _getSubgraphData(_subgraphID).nSignal;\\n    }\\n\\n    /**\\n     * @dev Return the total tokens on the subgraph at current value.\\n     * @param _subgraphID Subgraph ID\\n     * @return Total tokens on the subgraph\\n     */\\n    function subgraphTokens(uint256 _subgraphID) external view override returns (uint256) {\\n        uint256 signal = _getSubgraphData(_subgraphID).nSignal;\\n        if (signal > 0) {\\n            (, uint256 tokens) = nSignalToTokens(_subgraphID, signal);\\n            return tokens;\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Create subgraphID for legacy subgraph and mint ownership NFT.\\n     * @param _graphAccount Account that created the subgraph\\n     * @param _subgraphNumber The sequence number of the created subgraph\\n     * @param _subgraphMetadata IPFS hash for the subgraph metadata\\n     */\\n    function migrateLegacySubgraph(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        bytes32 _subgraphMetadata\\n    ) external {\\n        // Must be an existing legacy subgraph\\n        bool legacySubgraphExists = legacySubgraphData[_graphAccount][_subgraphNumber]\\n            .subgraphDeploymentID != 0;\\n        require(legacySubgraphExists == true, \\\"GNS: Subgraph does not exist\\\");\\n\\n        // Must not be a claimed subgraph\\n        uint256 subgraphID = _buildSubgraphID(_graphAccount, _subgraphNumber);\\n        require(\\n            legacySubgraphKeys[subgraphID].account == address(0),\\n            \\\"GNS: Subgraph was already claimed\\\"\\n        );\\n\\n        // Store a reference for a legacy subgraph\\n        legacySubgraphKeys[subgraphID] = IGNS.LegacySubgraphKey({\\n            account: _graphAccount,\\n            accountSeqID: _subgraphNumber\\n        });\\n\\n        // Delete state for legacy subgraph\\n        legacySubgraphs[_graphAccount][_subgraphNumber] = 0;\\n\\n        // Mint the NFT and send to owner\\n        // The subgraph owner is the graph account that created it\\n        _mintNFT(_graphAccount, subgraphID);\\n        emit LegacySubgraphClaimed(_graphAccount, _subgraphNumber);\\n\\n        // Set the token metadata\\n        _setSubgraphMetadata(subgraphID, _subgraphMetadata);\\n    }\\n\\n    /**\\n     * @dev Return whether a subgraph is published.\\n     * @param _subgraphID Subgraph ID\\n     * @return Return true if subgraph is currently published\\n     */\\n    function isPublished(uint256 _subgraphID) public view override returns (bool) {\\n        return _isPublished(_getSubgraphData(_subgraphID));\\n    }\\n\\n    /**\\n     * @dev Build a subgraph ID based on the account creating it and a sequence number for that account.\\n     * Subgraph ID is the keccak hash of account+seqID\\n     * @return Subgraph ID\\n     */\\n    function _buildSubgraphID(address _account, uint256 _seqID) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encodePacked(_account, _seqID)));\\n    }\\n\\n    /**\\n     * @dev Return the next subgraphID given the account that is creating the subgraph.\\n     * NOTE: This function updates the sequence ID for the account\\n     * @return Sequence ID for the account\\n     */\\n    function _nextSubgraphID(address _account) internal returns (uint256) {\\n        return _buildSubgraphID(_account, _nextAccountSeqID(_account));\\n    }\\n\\n    /**\\n     * @dev Return a new consecutive sequence ID for an account and update to the next value.\\n     * NOTE: This function updates the sequence ID for the account\\n     * @return Sequence ID for the account\\n     */\\n    function _nextAccountSeqID(address _account) internal returns (uint256) {\\n        uint256 seqID = nextAccountSeqID[_account];\\n        nextAccountSeqID[_account] = nextAccountSeqID[_account].add(1);\\n        return seqID;\\n    }\\n\\n    /**\\n     * @dev Get subgraph data.\\n     * This function will first look for a v1 subgraph and return it if found.\\n     * @param _subgraphID Subgraph ID\\n     * @return Subgraph Data\\n     */\\n    function _getSubgraphData(uint256 _subgraphID) private view returns (SubgraphData storage) {\\n        // If there is a legacy subgraph created return it\\n        LegacySubgraphKey storage legacySubgraphKey = legacySubgraphKeys[_subgraphID];\\n        if (legacySubgraphKey.account != address(0)) {\\n            return legacySubgraphData[legacySubgraphKey.account][legacySubgraphKey.accountSeqID];\\n        }\\n        // Return new subgraph type\\n        return subgraphs[_subgraphID];\\n    }\\n\\n    /**\\n     * @dev Return whether a subgraph is published.\\n     * @param _subgraphData Subgraph Data\\n     * @return Return true if subgraph is currently published\\n     */\\n    function _isPublished(SubgraphData storage _subgraphData) internal view returns (bool) {\\n        return _subgraphData.subgraphDeploymentID != 0 && _subgraphData.disabled == false;\\n    }\\n\\n    /**\\n     * @dev Return the subgraph data or revert if not published or deprecated.\\n     * @param _subgraphID Subgraph ID\\n     * @return Subgraph Data\\n     */\\n    function _getSubgraphOrRevert(uint256 _subgraphID)\\n        internal\\n        view\\n        returns (SubgraphData storage)\\n    {\\n        SubgraphData storage subgraphData = _getSubgraphData(_subgraphID);\\n        require(_isPublished(subgraphData) == true, \\\"GNS: Must be active\\\");\\n        return subgraphData;\\n    }\\n\\n    // -- NFT --\\n\\n    /**\\n     * @dev Return the owner of a subgraph.\\n     * @param _tokenID Subgraph ID\\n     * @return Owner address\\n     */\\n    function ownerOf(uint256 _tokenID) public view override returns (address) {\\n        return subgraphNFT.ownerOf(_tokenID);\\n    }\\n\\n    /**\\n     * @dev Mint the NFT for the subgraph.\\n     * @param _owner Owner address\\n     * @param _tokenID Subgraph ID\\n     */\\n    function _mintNFT(address _owner, uint256 _tokenID) internal {\\n        subgraphNFT.mint(_owner, _tokenID);\\n    }\\n\\n    /**\\n     * @dev Burn the NFT for the subgraph.\\n     * @param _tokenID Subgraph ID\\n     */\\n    function _burnNFT(uint256 _tokenID) internal {\\n        subgraphNFT.burn(_tokenID);\\n    }\\n\\n    /**\\n     * @dev Set the subgraph metadata.\\n     * @param _tokenID Subgraph ID\\n     * @param _subgraphMetadata IPFS hash of the subgraph metadata\\n     */\\n    function _setSubgraphMetadata(uint256 _tokenID, bytes32 _subgraphMetadata) internal {\\n        subgraphNFT.setSubgraphMetadata(_tokenID, _subgraphMetadata);\\n\\n        // Even if the following event is emitted in the NFT we emit it here to facilitate\\n        // subgraph indexing\\n        emit SubgraphMetadataUpdated(_tokenID, _subgraphMetadata);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./IMulticall.sol\\\";\\n\\n// Inspired by https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol\\n// Note: Removed payable from the multicall\\n\\n/**\\n * @title Multicall\\n * @notice Enables calling multiple methods in a single call to the contract\\n */\\nabstract contract Multicall is IMulticall {\\n    /// @inheritdoc IMulticall\\n    function multicall(bytes[] calldata data) external override returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n\\n            if (!success) {\\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\\n                if (result.length < 68) revert();\\n                assembly {\\n                    result := add(result, 0x04)\\n                }\\n                revert(abi.decode(result, (string)));\\n            }\\n\\n            results[i] = result;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bancor/BancorFormula.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract BancorFormula {\\n    using SafeMath for uint256;\\n\\n    uint16 public constant version = 6;\\n\\n    uint256 private constant ONE = 1;\\n    uint32 private constant MAX_RATIO = 1000000;\\n    uint8 private constant MIN_PRECISION = 32;\\n    uint8 private constant MAX_PRECISION = 127;\\n\\n    /**\\n     * @dev Auto-generated via 'PrintIntScalingFactors.py'\\n     */\\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\\n\\n    /**\\n     * @dev Auto-generated via 'PrintLn2ScalingFactors.py'\\n     */\\n    uint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\\n\\n    /**\\n     * @dev Auto-generated via 'PrintFunctionOptimalLog.py' and 'PrintFunctionOptimalExp.py'\\n     */\\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\\n\\n    /**\\n     * @dev Auto-generated via 'PrintFunctionConstructor.py'\\n     */\\n    uint256[128] private maxExpArray;\\n\\n    constructor() {\\n        //  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\\n        //  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\\n        //  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\\n        //  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\\n        //  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\\n        //  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\\n        //  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\\n        //  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\\n        //  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\\n        //  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\\n        //  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\\n        //  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\\n        //  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\\n        //  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\\n        //  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\\n        maxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\\n        maxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\\n        maxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\\n        maxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\\n        maxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\\n        maxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\\n        maxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\\n        maxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\\n        maxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\\n        maxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\\n        maxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\\n        maxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\\n        maxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\\n        maxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\\n        maxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\\n        maxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\\n        maxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\\n        maxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\\n        maxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\\n        maxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\\n        maxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\\n        maxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\\n        maxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\\n        maxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\\n        maxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\\n        maxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\\n        maxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\\n        maxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\\n        maxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\\n        maxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\\n        maxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\\n        maxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\\n        maxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\\n        maxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\\n        maxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\\n        maxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\\n        maxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\\n        maxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\\n        maxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\\n        maxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\\n        maxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\\n        maxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\\n        maxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\\n        maxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\\n        maxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\\n        maxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\\n        maxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\\n        maxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\\n        maxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\\n        maxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\\n        maxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\\n        maxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\\n        maxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\\n        maxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\\n        maxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\\n        maxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\\n        maxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\\n        maxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\\n        maxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\\n        maxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\\n        maxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\\n        maxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\\n        maxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\\n        maxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\\n        maxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\\n        maxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\\n        maxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\\n        maxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\\n    }\\n\\n    /**\\n     * @dev given a token supply, reserve balance, ratio and a deposit amount (in the reserve token),\\n     * calculates the return for a given conversion (in the main token)\\n     *\\n     * Formula:\\n     * Return = _supply * ((1 + _depositAmount / _reserveBalance) ^ (_reserveRatio / 1000000) - 1)\\n     *\\n     * @param _supply              token total supply\\n     * @param _reserveBalance      total reserve balance\\n     * @param _reserveRatio        reserve ratio, represented in ppm, 1-1000000\\n     * @param _depositAmount       deposit amount, in reserve token\\n     *\\n     * @return purchase return amount\\n     */\\n    function calculatePurchaseReturn(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _reserveRatio,\\n        uint256 _depositAmount\\n    ) public view returns (uint256) {\\n        // validate input\\n        require(\\n            _supply > 0 && _reserveBalance > 0 && _reserveRatio > 0 && _reserveRatio <= MAX_RATIO,\\n            \\\"invalid parameters\\\"\\n        );\\n\\n        // special case for 0 deposit amount\\n        if (_depositAmount == 0) return 0;\\n\\n        // special case if the ratio = 100%\\n        if (_reserveRatio == MAX_RATIO) return _supply.mul(_depositAmount) / _reserveBalance;\\n\\n        uint256 result;\\n        uint8 precision;\\n        uint256 baseN = _depositAmount.add(_reserveBalance);\\n        (result, precision) = power(baseN, _reserveBalance, _reserveRatio, MAX_RATIO);\\n        uint256 temp = _supply.mul(result) >> precision;\\n        return temp - _supply;\\n    }\\n\\n    /**\\n     * @dev given a token supply, reserve balance, ratio and a sell amount (in the main token),\\n     * calculates the return for a given conversion (in the reserve token)\\n     *\\n     * Formula:\\n     * Return = _reserveBalance * (1 - (1 - _sellAmount / _supply) ^ (1000000 / _reserveRatio))\\n     *\\n     * @param _supply              token total supply\\n     * @param _reserveBalance      total reserve\\n     * @param _reserveRatio        constant reserve Ratio, represented in ppm, 1-1000000\\n     * @param _sellAmount          sell amount, in the token itself\\n     *\\n     * @return sale return amount\\n     */\\n    function calculateSaleReturn(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _reserveRatio,\\n        uint256 _sellAmount\\n    ) public view returns (uint256) {\\n        // validate input\\n        require(\\n            _supply > 0 &&\\n                _reserveBalance > 0 &&\\n                _reserveRatio > 0 &&\\n                _reserveRatio <= MAX_RATIO &&\\n                _sellAmount <= _supply,\\n            \\\"invalid parameters\\\"\\n        );\\n\\n        // special case for 0 sell amount\\n        if (_sellAmount == 0) return 0;\\n\\n        // special case for selling the entire supply\\n        if (_sellAmount == _supply) return _reserveBalance;\\n\\n        // special case if the ratio = 100%\\n        if (_reserveRatio == MAX_RATIO) return _reserveBalance.mul(_sellAmount) / _supply;\\n\\n        uint256 result;\\n        uint8 precision;\\n        uint256 baseD = _supply - _sellAmount;\\n        (result, precision) = power(_supply, baseD, MAX_RATIO, _reserveRatio);\\n        uint256 temp1 = _reserveBalance.mul(result);\\n        uint256 temp2 = _reserveBalance << precision;\\n        return (temp1 - temp2) / result;\\n    }\\n\\n    /**\\n     * @dev given two reserve balances/ratios and a sell amount (in the first reserve token),\\n     * calculates the return for a conversion from the first reserve token to the second reserve token (in the second reserve token)\\n     * note that prior to version 4, you should use 'calculateCrossConnectorReturn' instead\\n     *\\n     * Formula:\\n     * Return = _toReserveBalance * (1 - (_fromReserveBalance / (_fromReserveBalance + _amount)) ^ (_fromReserveRatio / _toReserveRatio))\\n     *\\n     * @param _fromReserveBalance      input reserve balance\\n     * @param _fromReserveRatio        input reserve ratio, represented in ppm, 1-1000000\\n     * @param _toReserveBalance        output reserve balance\\n     * @param _toReserveRatio          output reserve ratio, represented in ppm, 1-1000000\\n     * @param _amount                  input reserve amount\\n     *\\n     * @return second reserve amount\\n     */\\n    function calculateCrossReserveReturn(\\n        uint256 _fromReserveBalance,\\n        uint32 _fromReserveRatio,\\n        uint256 _toReserveBalance,\\n        uint32 _toReserveRatio,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        // validate input\\n        require(\\n            _fromReserveBalance > 0 &&\\n                _fromReserveRatio > 0 &&\\n                _fromReserveRatio <= MAX_RATIO &&\\n                _toReserveBalance > 0 &&\\n                _toReserveRatio > 0 &&\\n                _toReserveRatio <= MAX_RATIO\\n        );\\n\\n        // special case for equal ratios\\n        if (_fromReserveRatio == _toReserveRatio)\\n            return _toReserveBalance.mul(_amount) / _fromReserveBalance.add(_amount);\\n\\n        uint256 result;\\n        uint8 precision;\\n        uint256 baseN = _fromReserveBalance.add(_amount);\\n        (result, precision) = power(baseN, _fromReserveBalance, _fromReserveRatio, _toReserveRatio);\\n        uint256 temp1 = _toReserveBalance.mul(result);\\n        uint256 temp2 = _toReserveBalance << precision;\\n        return (temp1 - temp2) / result;\\n    }\\n\\n    /**\\n     * @dev given a smart token supply, reserve balance, total ratio and an amount of requested smart tokens,\\n     * calculates the amount of reserve tokens required for purchasing the given amount of smart tokens\\n     *\\n     * Formula:\\n     * Return = _reserveBalance * (((_supply + _amount) / _supply) ^ (MAX_RATIO / _totalRatio) - 1)\\n     *\\n     * @param _supply              smart token supply\\n     * @param _reserveBalance      reserve token balance\\n     * @param _totalRatio          total ratio, represented in ppm, 2-2000000\\n     * @param _amount              requested amount of smart tokens\\n     *\\n     * @return amount of reserve tokens\\n     */\\n    function calculateFundCost(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _totalRatio,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        // validate input\\n        require(\\n            _supply > 0 && _reserveBalance > 0 && _totalRatio > 1 && _totalRatio <= MAX_RATIO * 2\\n        );\\n\\n        // special case for 0 amount\\n        if (_amount == 0) return 0;\\n\\n        // special case if the total ratio = 100%\\n        if (_totalRatio == MAX_RATIO) return (_amount.mul(_reserveBalance) - 1) / _supply + 1;\\n\\n        uint256 result;\\n        uint8 precision;\\n        uint256 baseN = _supply.add(_amount);\\n        (result, precision) = power(baseN, _supply, MAX_RATIO, _totalRatio);\\n        uint256 temp = ((_reserveBalance.mul(result) - 1) >> precision) + 1;\\n        return temp - _reserveBalance;\\n    }\\n\\n    /**\\n     * @dev given a smart token supply, reserve balance, total ratio and an amount of smart tokens to liquidate,\\n     * calculates the amount of reserve tokens received for selling the given amount of smart tokens\\n     *\\n     * Formula:\\n     * Return = _reserveBalance * (1 - ((_supply - _amount) / _supply) ^ (MAX_RATIO / _totalRatio))\\n     *\\n     * @param _supply              smart token supply\\n     * @param _reserveBalance      reserve token balance\\n     * @param _totalRatio          total ratio, represented in ppm, 2-2000000\\n     * @param _amount              amount of smart tokens to liquidate\\n     *\\n     * @return amount of reserve tokens\\n     */\\n    function calculateLiquidateReturn(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _totalRatio,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        // validate input\\n        require(\\n            _supply > 0 &&\\n                _reserveBalance > 0 &&\\n                _totalRatio > 1 &&\\n                _totalRatio <= MAX_RATIO * 2 &&\\n                _amount <= _supply\\n        );\\n\\n        // special case for 0 amount\\n        if (_amount == 0) return 0;\\n\\n        // special case for liquidating the entire supply\\n        if (_amount == _supply) return _reserveBalance;\\n\\n        // special case if the total ratio = 100%\\n        if (_totalRatio == MAX_RATIO) return _amount.mul(_reserveBalance) / _supply;\\n\\n        uint256 result;\\n        uint8 precision;\\n        uint256 baseD = _supply - _amount;\\n        (result, precision) = power(_supply, baseD, MAX_RATIO, _totalRatio);\\n        uint256 temp1 = _reserveBalance.mul(result);\\n        uint256 temp2 = _reserveBalance << precision;\\n        return (temp1 - temp2) / result;\\n    }\\n\\n    /**\\n     * @dev General Description:\\n     *     Determine a value of precision.\\n     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\\n     *     Return the result along with the precision used.\\n     *\\n     * Detailed Description:\\n     *     Instead of calculating \\\"base ^ exp\\\", we calculate \\\"e ^ (log(base) * exp)\\\".\\n     *     The value of \\\"log(base)\\\" is represented with an integer slightly smaller than \\\"log(base) * 2 ^ precision\\\".\\n     *     The larger \\\"precision\\\" is, the more accurately this value represents the real value.\\n     *     However, the larger \\\"precision\\\" is, the more bits are required in order to store this value.\\n     *     And the exponentiation function, which takes \\\"x\\\" and calculates \\\"e ^ x\\\", is limited to a maximum exponent (maximum value of \\\"x\\\").\\n     *     This maximum exponent depends on the \\\"precision\\\" used, and it is given by \\\"maxExpArray[precision] >> (MAX_PRECISION - precision)\\\".\\n     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\\n     *     This allows us to compute \\\"base ^ exp\\\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\\n     *     This functions assumes that \\\"_expN < 2 ^ 256 / log(MAX_NUM - 1)\\\", otherwise the multiplication should be replaced with a \\\"safeMul\\\".\\n     *     Since we rely on unsigned-integer arithmetic and \\\"base < 1\\\" ==> \\\"log(base) < 0\\\", this function does not support \\\"_baseN < _baseD\\\".\\n     */\\n    function power(\\n        uint256 _baseN,\\n        uint256 _baseD,\\n        uint32 _expN,\\n        uint32 _expD\\n    ) internal view returns (uint256, uint8) {\\n        require(_baseN < MAX_NUM);\\n\\n        uint256 baseLog;\\n        uint256 base = (_baseN * FIXED_1) / _baseD;\\n        if (base < OPT_LOG_MAX_VAL) {\\n            baseLog = optimalLog(base);\\n        } else {\\n            baseLog = generalLog(base);\\n        }\\n\\n        uint256 baseLogTimesExp = (baseLog * _expN) / _expD;\\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\\n        } else {\\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\\n            return (\\n                generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision),\\n                precision\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev computes log(x / FIXED_1) * FIXED_1.\\n     * This functions assumes that \\\"x >= FIXED_1\\\", because the output would be negative otherwise.\\n     */\\n    function generalLog(uint256 x) internal pure returns (uint256) {\\n        uint256 res = 0;\\n\\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\\n        if (x >= FIXED_2) {\\n            uint8 count = floorLog2(x / FIXED_1);\\n            x >>= count; // now x < 2\\n            res = count * FIXED_1;\\n        }\\n\\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\\n        if (x > FIXED_1) {\\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\\n                x = (x * x) / FIXED_1; // now 1 < x < 4\\n                if (x >= FIXED_2) {\\n                    x >>= 1; // now 1 < x < 2\\n                    res += ONE << (i - 1);\\n                }\\n            }\\n        }\\n\\n        return (res * LN2_NUMERATOR) / LN2_DENOMINATOR;\\n    }\\n\\n    /**\\n     * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\\n     */\\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\\n        uint8 res = 0;\\n\\n        if (_n < 256) {\\n            // At most 8 iterations\\n            while (_n > 1) {\\n                _n >>= 1;\\n                res += 1;\\n            }\\n        } else {\\n            // Exactly 8 iterations\\n            for (uint8 s = 128; s > 0; s >>= 1) {\\n                if (_n >= (ONE << s)) {\\n                    _n >>= s;\\n                    res |= s;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @dev the global \\\"maxExpArray\\\" is sorted in descending order, and therefore the following statements are equivalent:\\n     * - This function finds the position of [the smallest value in \\\"maxExpArray\\\" larger than or equal to \\\"x\\\"]\\n     * - This function finds the highest position of [a value in \\\"maxExpArray\\\" larger than or equal to \\\"x\\\"]\\n     */\\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\\n        uint8 lo = MIN_PRECISION;\\n        uint8 hi = MAX_PRECISION;\\n\\n        while (lo + 1 < hi) {\\n            uint8 mid = (lo + hi) / 2;\\n            if (maxExpArray[mid] >= _x) lo = mid;\\n            else hi = mid;\\n        }\\n\\n        if (maxExpArray[hi] >= _x) return hi;\\n        if (maxExpArray[lo] >= _x) return lo;\\n\\n        require(false);\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev this function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.\\n     * it approximates \\\"e ^ x\\\" via maclaurin summation: \\\"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\\\".\\n     * it returns \\\"e ^ (x / 2 ^ precision) * 2 ^ precision\\\", that is, the result is upshifted for accuracy.\\n     * the global \\\"maxExpArray\\\" maps each \\\"precision\\\" to \\\"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\\\".\\n     * the maximum permitted value for \\\"x\\\" is therefore given by \\\"maxExpArray[precision] >> (MAX_PRECISION - precision)\\\".\\n     */\\n    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\\n        uint256 xi = _x;\\n        uint256 res = 0;\\n\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)\\n\\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\\n    }\\n\\n    /**\\n     * @dev computes log(x / FIXED_1) * FIXED_1\\n     * Input range: FIXED_1 <= x <= LOG_EXP_MAX_VAL - 1\\n     * Auto-generated via 'PrintFunctionOptimalLog.py'\\n     * Detailed description:\\n     * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\\n     * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\\n     * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\\n     * - The natural logarithm of the input is calculated by summing up the intermediate results above\\n     * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\\n     */\\n    function optimalLog(uint256 x) internal pure returns (uint256) {\\n        uint256 res = 0;\\n\\n        uint256 y;\\n        uint256 z;\\n        uint256 w;\\n\\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\\n            res += 0x40000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\\n        } // add 1 / 2^1\\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\\n            res += 0x20000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\\n        } // add 1 / 2^2\\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\\n            res += 0x10000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\\n        } // add 1 / 2^3\\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\\n            res += 0x08000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\\n        } // add 1 / 2^4\\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {\\n            res += 0x04000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\\n        } // add 1 / 2^5\\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\\n            res += 0x02000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\\n        } // add 1 / 2^6\\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {\\n            res += 0x01000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\\n        } // add 1 / 2^7\\n        if (x >= 0x808040155aabbbe9451521693554f733) {\\n            res += 0x00800000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733;\\n        } // add 1 / 2^8\\n\\n        z = y = x - FIXED_1;\\n        w = (y * y) / FIXED_1;\\n        res +=\\n            (z * (0x100000000000000000000000000000000 - y)) /\\n            0x100000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^01 / 01 - y^02 / 02\\n        res +=\\n            (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) /\\n            0x200000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^03 / 03 - y^04 / 04\\n        res +=\\n            (z * (0x099999999999999999999999999999999 - y)) /\\n            0x300000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^05 / 05 - y^06 / 06\\n        res +=\\n            (z * (0x092492492492492492492492492492492 - y)) /\\n            0x400000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^07 / 07 - y^08 / 08\\n        res +=\\n            (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) /\\n            0x500000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^09 / 09 - y^10 / 10\\n        res +=\\n            (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) /\\n            0x600000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^11 / 11 - y^12 / 12\\n        res +=\\n            (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) /\\n            0x700000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^13 / 13 - y^14 / 14\\n        res +=\\n            (z * (0x088888888888888888888888888888888 - y)) /\\n            0x800000000000000000000000000000000; // add y^15 / 15 - y^16 / 16\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @dev computes e ^ (x / FIXED_1) * FIXED_1\\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\\n     * auto-generated via 'PrintFunctionOptimalExp.py'\\n     * Detailed description:\\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\\n     * - The exponentiation of each binary exponent is given (pre-calculated)\\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\\n     */\\n    function optimalExp(uint256 x) internal pure returns (uint256) {\\n        uint256 res = 0;\\n\\n        uint256 y;\\n        uint256 z;\\n\\n        z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\\n        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\\n\\n        if ((x & 0x010000000000000000000000000000000) != 0)\\n            res = (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\\n        if ((x & 0x020000000000000000000000000000000) != 0)\\n            res = (res * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\\n        if ((x & 0x040000000000000000000000000000000) != 0)\\n            res = (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\\n        if ((x & 0x080000000000000000000000000000000) != 0)\\n            res = (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\\n        if ((x & 0x100000000000000000000000000000000) != 0)\\n            res = (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\\n        if ((x & 0x200000000000000000000000000000000) != 0)\\n            res = (res * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\\n        if ((x & 0x400000000000000000000000000000000) != 0)\\n            res = (res * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @dev deprecated, backward compatibility\\n     */\\n    function calculateCrossConnectorReturn(\\n        uint256 _fromConnectorBalance,\\n        uint32 _fromConnectorWeight,\\n        uint256 _toConnectorBalance,\\n        uint32 _toConnectorWeight,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        return\\n            calculateCrossReserveReturn(\\n                _fromConnectorBalance,\\n                _fromConnectorWeight,\\n                _toConnectorBalance,\\n                _toConnectorWeight,\\n                _amount\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/upgrades/GraphUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"./IGraphProxy.sol\\\";\\n\\n/**\\n * @title Graph Upgradeable\\n * @dev This contract is intended to be inherited from upgradeable contracts.\\n */\\ncontract GraphUpgradeable {\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant IMPLEMENTATION_SLOT =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Check if the caller is the proxy admin.\\n     */\\n    modifier onlyProxyAdmin(IGraphProxy _proxy) {\\n        require(msg.sender == _proxy.admin(), \\\"Caller must be the proxy admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check if the caller is the implementation.\\n     */\\n    modifier onlyImpl() {\\n        require(msg.sender == _implementation(), \\\"Caller must be the implementation\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     * @return impl Address of the current implementation\\n     */\\n    function _implementation() internal view returns (address impl) {\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Accept to be an implementation of proxy.\\n     */\\n    function acceptProxy(IGraphProxy _proxy) external onlyProxyAdmin(_proxy) {\\n        _proxy.acceptUpgrade();\\n    }\\n\\n    /**\\n     * @dev Accept to be an implementation of proxy and then call a function from the new\\n     * implementation as specified by `_data`, which should be an encoded function call. This is\\n     * useful to initialize new storage variables in the proxied contract.\\n     */\\n    function acceptProxyAndCall(IGraphProxy _proxy, bytes calldata _data)\\n        external\\n        onlyProxyAdmin(_proxy)\\n    {\\n        _proxy.acceptUpgradeAndCall(_data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/TokenUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"../token/IGraphToken.sol\\\";\\n\\nlibrary TokenUtils {\\n    /**\\n     * @dev Pull tokens from an address to this contract.\\n     * @param _graphToken Token to transfer\\n     * @param _from Address sending the tokens\\n     * @param _amount Amount of tokens to transfer\\n     */\\n    function pullTokens(\\n        IGraphToken _graphToken,\\n        address _from,\\n        uint256 _amount\\n    ) internal {\\n        if (_amount > 0) {\\n            require(_graphToken.transferFrom(_from, address(this), _amount), \\\"!transfer\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Push tokens from this contract to a receiving address.\\n     * @param _graphToken Token to transfer\\n     * @param _to Address receiving the tokens\\n     * @param _amount Amount of tokens to transfer\\n     */\\n    function pushTokens(\\n        IGraphToken _graphToken,\\n        address _to,\\n        uint256 _amount\\n    ) internal {\\n        if (_amount > 0) {\\n            require(_graphToken.transfer(_to, _amount), \\\"!transfer\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Burn tokens held by this contract.\\n     * @param _graphToken Token to burn\\n     * @param _amount Amount of tokens to burn\\n     */\\n    function burnTokens(IGraphToken _graphToken, uint256 _amount) internal {\\n        if (_amount > 0) {\\n            _graphToken.burn(_amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/discovery/IGNS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.6;\\n\\ninterface IGNS {\\n    // -- Pool --\\n\\n    struct SubgraphData {\\n        uint256 vSignal; // The token of the subgraph-deployment bonding curve\\n        uint256 nSignal; // The token of the subgraph bonding curve\\n        mapping(address => uint256) curatorNSignal;\\n        bytes32 subgraphDeploymentID;\\n        uint32 reserveRatio;\\n        bool disabled;\\n        uint256 withdrawableGRT;\\n    }\\n\\n    struct LegacySubgraphKey {\\n        address account;\\n        uint256 accountSeqID;\\n    }\\n\\n    // -- Configuration --\\n\\n    function approveAll() external;\\n\\n    function setOwnerTaxPercentage(uint32 _ownerTaxPercentage) external;\\n\\n    // -- Publishing --\\n\\n    function setDefaultName(\\n        address _graphAccount,\\n        uint8 _nameSystem,\\n        bytes32 _nameIdentifier,\\n        string calldata _name\\n    ) external;\\n\\n    function updateSubgraphMetadata(uint256 _subgraphID, bytes32 _subgraphMetadata) external;\\n\\n    function publishNewSubgraph(\\n        bytes32 _subgraphDeploymentID,\\n        bytes32 _versionMetadata,\\n        bytes32 _subgraphMetadata\\n    ) external;\\n\\n    function publishNewVersion(\\n        uint256 _subgraphID,\\n        bytes32 _subgraphDeploymentID,\\n        bytes32 _versionMetadata\\n    ) external;\\n\\n    function deprecateSubgraph(uint256 _subgraphID) external;\\n\\n    // -- Curation --\\n\\n    function mintSignal(\\n        uint256 _subgraphID,\\n        uint256 _tokensIn,\\n        uint256 _nSignalOutMin\\n    ) external;\\n\\n    function burnSignal(\\n        uint256 _subgraphID,\\n        uint256 _nSignal,\\n        uint256 _tokensOutMin\\n    ) external;\\n\\n    function withdraw(uint256 _subgraphID) external;\\n\\n    // -- Getters --\\n\\n    function ownerOf(uint256 _tokenID) external view returns (address);\\n\\n    function subgraphSignal(uint256 _subgraphID) external view returns (uint256);\\n\\n    function subgraphTokens(uint256 _subgraphID) external view returns (uint256);\\n\\n    function tokensToNSignal(uint256 _subgraphID, uint256 _tokensIn)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function nSignalToTokens(uint256 _subgraphID, uint256 _nSignalIn)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    function vSignalToNSignal(uint256 _subgraphID, uint256 _vSignalIn)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function nSignalToVSignal(uint256 _subgraphID, uint256 _nSignalIn)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getCuratorSignal(uint256 _subgraphID, address _curator)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function isPublished(uint256 _subgraphID) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/discovery/GNSStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../governance/Managed.sol\\\";\\n\\nimport \\\"./erc1056/IEthereumDIDRegistry.sol\\\";\\nimport \\\"./IGNS.sol\\\";\\nimport \\\"./ISubgraphNFT.sol\\\";\\n\\nabstract contract GNSV1Storage is Managed {\\n    // -- State --\\n\\n    // In parts per hundred\\n    uint32 public ownerTaxPercentage;\\n\\n    // Bonding curve formula\\n    address public bondingCurve;\\n\\n    // Stores what subgraph deployment a particular legacy subgraph targets\\n    // A subgraph is defined by (graphAccountID, subgraphNumber)\\n    // A subgraph can target one subgraph deployment (bytes32 hash)\\n    // (graphAccountID, subgraphNumber) => subgraphDeploymentID\\n    mapping(address => mapping(uint256 => bytes32)) internal legacySubgraphs;\\n\\n    // Every time an account creates a subgraph it increases a per-account sequence ID\\n    // account => seqID\\n    mapping(address => uint256) public nextAccountSeqID;\\n\\n    // Stores all the signal deposited on a legacy subgraph\\n    // (graphAccountID, subgraphNumber) => SubgraphData\\n    mapping(address => mapping(uint256 => IGNS.SubgraphData)) public legacySubgraphData;\\n\\n    // [DEPRECATED] ERC-1056 contract reference\\n    // This contract is used for managing identities\\n    IEthereumDIDRegistry private __DEPRECATED_erc1056Registry;\\n}\\n\\nabstract contract GNSV2Storage is GNSV1Storage {\\n    // Use it whenever a legacy (v1) subgraph NFT was claimed to maintain compatibility\\n    // Keep a reference from subgraphID => (graphAccount, subgraphNumber)\\n    mapping(uint256 => IGNS.LegacySubgraphKey) public legacySubgraphKeys;\\n\\n    // Store data for all NFT-based (v2) subgraphs\\n    // subgraphID => SubgraphData\\n    mapping(uint256 => IGNS.SubgraphData) public subgraphs;\\n\\n    // Contract that represents subgraph ownership through an NFT\\n    ISubgraphNFT public subgraphNFT;\\n}\\n\"\r\n    },\r\n    \"contracts/base/IMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\n/**\\n * @title Multicall interface\\n * @notice Enables calling multiple methods in a single call to the contract\\n */\\ninterface IMulticall {\\n    /**\\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\\n     * @param data The encoded function data for each of the calls to make to this contract\\n     * @return results The results from each of the calls passed in via data\\n     */\\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"contracts/upgrades/IGraphProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.6;\\n\\ninterface IGraphProxy {\\n    function admin() external returns (address);\\n\\n    function setAdmin(address _newAdmin) external;\\n\\n    function implementation() external returns (address);\\n\\n    function pendingImplementation() external returns (address);\\n\\n    function upgradeTo(address _newImplementation) external;\\n\\n    function acceptUpgrade() external;\\n\\n    function acceptUpgradeAndCall(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/token/IGraphToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IGraphToken is IERC20 {\\n    // -- Mint and Burn --\\n\\n    function burn(uint256 amount) external;\\n\\n    function mint(address _to, uint256 _amount) external;\\n\\n    // -- Mint Admin --\\n\\n    function addMinter(address _account) external;\\n\\n    function removeMinter(address _account) external;\\n\\n    function renounceMinter() external;\\n\\n    function isMinter(address _account) external view returns (bool);\\n\\n    // -- Permit --\\n\\n    function permit(\\n        address _owner,\\n        address _spender,\\n        uint256 _value,\\n        uint256 _deadline,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/governance/Managed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"./IController.sol\\\";\\n\\nimport \\\"../curation/ICuration.sol\\\";\\nimport \\\"../epochs/IEpochManager.sol\\\";\\nimport \\\"../rewards/IRewardsManager.sol\\\";\\nimport \\\"../staking/IStaking.sol\\\";\\nimport \\\"../token/IGraphToken.sol\\\";\\n\\n/**\\n * @title Graph Managed contract\\n * @dev The Managed contract provides an interface to interact with the Controller.\\n * It also provides local caching for contract addresses. This mechanism relies on calling the\\n * public `syncAllContracts()` function whenever a contract changes in the controller.\\n *\\n * Inspired by Livepeer:\\n * https://github.com/livepeer/protocol/blob/streamflow/contracts/Controller.sol\\n */\\ncontract Managed {\\n    // -- State --\\n\\n    // Controller that contract is registered with\\n    IController public controller;\\n    mapping(bytes32 => address) private addressCache;\\n    uint256[10] private __gap;\\n\\n    // -- Events --\\n\\n    event ParameterUpdated(string param);\\n    event SetController(address controller);\\n\\n    /**\\n     * @dev Emitted when contract with `nameHash` is synced to `contractAddress`.\\n     */\\n    event ContractSynced(bytes32 indexed nameHash, address contractAddress);\\n\\n    // -- Modifiers --\\n\\n    function _notPartialPaused() internal view {\\n        require(!controller.paused(), \\\"Paused\\\");\\n        require(!controller.partialPaused(), \\\"Partial-paused\\\");\\n    }\\n\\n    function _notPaused() internal view {\\n        require(!controller.paused(), \\\"Paused\\\");\\n    }\\n\\n    function _onlyGovernor() internal view {\\n        require(msg.sender == controller.getGovernor(), \\\"Caller must be Controller governor\\\");\\n    }\\n\\n    function _onlyController() internal view {\\n        require(msg.sender == address(controller), \\\"Caller must be Controller\\\");\\n    }\\n\\n    modifier notPartialPaused() {\\n        _notPartialPaused();\\n        _;\\n    }\\n\\n    modifier notPaused() {\\n        _notPaused();\\n        _;\\n    }\\n\\n    // Check if sender is controller.\\n    modifier onlyController() {\\n        _onlyController();\\n        _;\\n    }\\n\\n    // Check if sender is the governor.\\n    modifier onlyGovernor() {\\n        _onlyGovernor();\\n        _;\\n    }\\n\\n    // -- Functions --\\n\\n    /**\\n     * @dev Initialize the controller.\\n     */\\n    function _initialize(address _controller) internal {\\n        _setController(_controller);\\n    }\\n\\n    /**\\n     * @notice Set Controller. Only callable by current controller.\\n     * @param _controller Controller contract address\\n     */\\n    function setController(address _controller) external onlyController {\\n        _setController(_controller);\\n    }\\n\\n    /**\\n     * @dev Set controller.\\n     * @param _controller Controller contract address\\n     */\\n    function _setController(address _controller) internal {\\n        require(_controller != address(0), \\\"Controller must be set\\\");\\n        controller = IController(_controller);\\n        emit SetController(_controller);\\n    }\\n\\n    /**\\n     * @dev Return Curation interface.\\n     * @return Curation contract registered with Controller\\n     */\\n    function curation() internal view returns (ICuration) {\\n        return ICuration(_resolveContract(keccak256(\\\"Curation\\\")));\\n    }\\n\\n    /**\\n     * @dev Return EpochManager interface.\\n     * @return Epoch manager contract registered with Controller\\n     */\\n    function epochManager() internal view returns (IEpochManager) {\\n        return IEpochManager(_resolveContract(keccak256(\\\"EpochManager\\\")));\\n    }\\n\\n    /**\\n     * @dev Return RewardsManager interface.\\n     * @return Rewards manager contract registered with Controller\\n     */\\n    function rewardsManager() internal view returns (IRewardsManager) {\\n        return IRewardsManager(_resolveContract(keccak256(\\\"RewardsManager\\\")));\\n    }\\n\\n    /**\\n     * @dev Return Staking interface.\\n     * @return Staking contract registered with Controller\\n     */\\n    function staking() internal view returns (IStaking) {\\n        return IStaking(_resolveContract(keccak256(\\\"Staking\\\")));\\n    }\\n\\n    /**\\n     * @dev Return GraphToken interface.\\n     * @return Graph token contract registered with Controller\\n     */\\n    function graphToken() internal view returns (IGraphToken) {\\n        return IGraphToken(_resolveContract(keccak256(\\\"GraphToken\\\")));\\n    }\\n\\n    /**\\n     * @dev Resolve a contract address from the cache or the Controller if not found.\\n     * @return Address of the contract\\n     */\\n    function _resolveContract(bytes32 _nameHash) internal view returns (address) {\\n        address contractAddress = addressCache[_nameHash];\\n        if (contractAddress == address(0)) {\\n            contractAddress = controller.getContractProxy(_nameHash);\\n        }\\n        return contractAddress;\\n    }\\n\\n    /**\\n     * @dev Cache a contract address from the Controller registry.\\n     * @param _name Name of the contract to sync into the cache\\n     */\\n    function _syncContract(string memory _name) internal {\\n        bytes32 nameHash = keccak256(abi.encodePacked(_name));\\n        address contractAddress = controller.getContractProxy(nameHash);\\n        if (addressCache[nameHash] != contractAddress) {\\n            addressCache[nameHash] = contractAddress;\\n            emit ContractSynced(nameHash, contractAddress);\\n        }\\n    }\\n\\n    /**\\n     * @dev Sync protocol contract addresses from the Controller registry.\\n     * This function will cache all the contracts using the latest addresses\\n     * Anyone can call the function whenever a Proxy contract change in the\\n     * controller to ensure the protocol is using the latest version\\n     */\\n    function syncAllContracts() external {\\n        _syncContract(\\\"Curation\\\");\\n        _syncContract(\\\"EpochManager\\\");\\n        _syncContract(\\\"RewardsManager\\\");\\n        _syncContract(\\\"Staking\\\");\\n        _syncContract(\\\"GraphToken\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/discovery/erc1056/IEthereumDIDRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.7.6;\\n\\ninterface IEthereumDIDRegistry {\\n    function identityOwner(address identity) external view returns (address);\\n\\n    function setAttribute(\\n        address identity,\\n        bytes32 name,\\n        bytes calldata value,\\n        uint256 validity\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/discovery/ISubgraphNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface ISubgraphNFT is IERC721 {\\n    // -- Config --\\n\\n    function setMinter(address _minter) external;\\n\\n    function setTokenDescriptor(address _tokenDescriptor) external;\\n\\n    function setBaseURI(string memory _baseURI) external;\\n\\n    // -- Actions --\\n\\n    function mint(address _to, uint256 _tokenId) external;\\n\\n    function burn(uint256 _tokenId) external;\\n\\n    function setSubgraphMetadata(uint256 _tokenId, bytes32 _subgraphMetadata) external;\\n\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/governance/IController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.6.12 <0.8.0;\\n\\ninterface IController {\\n    function getGovernor() external view returns (address);\\n\\n    // -- Registry --\\n\\n    function setContractProxy(bytes32 _id, address _contractAddress) external;\\n\\n    function unsetContractProxy(bytes32 _id) external;\\n\\n    function updateController(bytes32 _id, address _controller) external;\\n\\n    function getContractProxy(bytes32 _id) external view returns (address);\\n\\n    // -- Pausing --\\n\\n    function setPartialPaused(bool _partialPaused) external;\\n\\n    function setPaused(bool _paused) external;\\n\\n    function setPauseGuardian(address _newPauseGuardian) external;\\n\\n    function paused() external view returns (bool);\\n\\n    function partialPaused() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/curation/ICuration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"./IGraphCurationToken.sol\\\";\\n\\ninterface ICuration {\\n    // -- Configuration --\\n\\n    function setDefaultReserveRatio(uint32 _defaultReserveRatio) external;\\n\\n    function setMinimumCurationDeposit(uint256 _minimumCurationDeposit) external;\\n\\n    function setCurationTaxPercentage(uint32 _percentage) external;\\n\\n    function setCurationTokenMaster(address _curationTokenMaster) external;\\n\\n    // -- Curation --\\n\\n    function mint(\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokensIn,\\n        uint256 _signalOutMin\\n    ) external returns (uint256, uint256);\\n\\n    function burn(\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _signalIn,\\n        uint256 _tokensOutMin\\n    ) external returns (uint256);\\n\\n    function collect(bytes32 _subgraphDeploymentID, uint256 _tokens) external;\\n\\n    // -- Getters --\\n\\n    function isCurated(bytes32 _subgraphDeploymentID) external view returns (bool);\\n\\n    function getCuratorSignal(address _curator, bytes32 _subgraphDeploymentID)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getCurationPoolSignal(bytes32 _subgraphDeploymentID) external view returns (uint256);\\n\\n    function getCurationPoolTokens(bytes32 _subgraphDeploymentID) external view returns (uint256);\\n\\n    function tokensToSignal(bytes32 _subgraphDeploymentID, uint256 _tokensIn)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    function signalToTokens(bytes32 _subgraphDeploymentID, uint256 _signalIn)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function curationTaxPercentage() external view returns (uint32);\\n}\\n\"\r\n    },\r\n    \"contracts/epochs/IEpochManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.6;\\n\\ninterface IEpochManager {\\n    // -- Configuration --\\n\\n    function setEpochLength(uint256 _epochLength) external;\\n\\n    // -- Epochs\\n\\n    function runEpoch() external;\\n\\n    // -- Getters --\\n\\n    function isCurrentEpochRun() external view returns (bool);\\n\\n    function blockNum() external view returns (uint256);\\n\\n    function blockHash(uint256 _block) external view returns (bytes32);\\n\\n    function currentEpoch() external view returns (uint256);\\n\\n    function currentEpochBlock() external view returns (uint256);\\n\\n    function currentEpochBlockSinceStart() external view returns (uint256);\\n\\n    function epochsSince(uint256 _epoch) external view returns (uint256);\\n\\n    function epochsSinceUpdate() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/rewards/IRewardsManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.6;\\n\\ninterface IRewardsManager {\\n    /**\\n     * @dev Stores accumulated rewards and snapshots related to a particular SubgraphDeployment.\\n     */\\n    struct Subgraph {\\n        uint256 accRewardsForSubgraph;\\n        uint256 accRewardsForSubgraphSnapshot;\\n        uint256 accRewardsPerSignalSnapshot;\\n        uint256 accRewardsPerAllocatedToken;\\n    }\\n\\n    // -- Params --\\n\\n    function setIssuanceRate(uint256 _issuanceRate) external;\\n\\n    // -- Denylist --\\n\\n    function setSubgraphAvailabilityOracle(address _subgraphAvailabilityOracle) external;\\n\\n    function setDenied(bytes32 _subgraphDeploymentID, bool _deny) external;\\n\\n    function setDeniedMany(bytes32[] calldata _subgraphDeploymentID, bool[] calldata _deny)\\n        external;\\n\\n    function isDenied(bytes32 _subgraphDeploymentID) external view returns (bool);\\n\\n    // -- Getters --\\n\\n    function getNewRewardsPerSignal() external view returns (uint256);\\n\\n    function getAccRewardsPerSignal() external view returns (uint256);\\n\\n    function getAccRewardsForSubgraph(bytes32 _subgraphDeploymentID)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getAccRewardsPerAllocatedToken(bytes32 _subgraphDeploymentID)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    function getRewards(address _allocationID) external view returns (uint256);\\n\\n    // -- Updates --\\n\\n    function updateAccRewardsPerSignal() external returns (uint256);\\n\\n    function takeRewards(address _allocationID) external returns (uint256);\\n\\n    // -- Hooks --\\n\\n    function onSubgraphSignalUpdate(bytes32 _subgraphDeploymentID) external returns (uint256);\\n\\n    function onSubgraphAllocationUpdate(bytes32 _subgraphDeploymentID) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.6.12 <0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./IStakingData.sol\\\";\\n\\ninterface IStaking is IStakingData {\\n    // -- Allocation Data --\\n\\n    /**\\n     * @dev Possible states an allocation can be\\n     * States:\\n     * - Null = indexer == address(0)\\n     * - Active = not Null && tokens > 0\\n     * - Closed = Active && closedAtEpoch != 0\\n     * - Finalized = Closed && closedAtEpoch + channelDisputeEpochs > now()\\n     * - Claimed = not Null && tokens == 0\\n     */\\n    enum AllocationState {\\n        Null,\\n        Active,\\n        Closed,\\n        Finalized,\\n        Claimed\\n    }\\n\\n    // -- Configuration --\\n\\n    function setMinimumIndexerStake(uint256 _minimumIndexerStake) external;\\n\\n    function setThawingPeriod(uint32 _thawingPeriod) external;\\n\\n    function setCurationPercentage(uint32 _percentage) external;\\n\\n    function setProtocolPercentage(uint32 _percentage) external;\\n\\n    function setChannelDisputeEpochs(uint32 _channelDisputeEpochs) external;\\n\\n    function setMaxAllocationEpochs(uint32 _maxAllocationEpochs) external;\\n\\n    function setRebateRatio(uint32 _alphaNumerator, uint32 _alphaDenominator) external;\\n\\n    function setDelegationRatio(uint32 _delegationRatio) external;\\n\\n    function setDelegationParameters(\\n        uint32 _indexingRewardCut,\\n        uint32 _queryFeeCut,\\n        uint32 _cooldownBlocks\\n    ) external;\\n\\n    function setDelegationParametersCooldown(uint32 _blocks) external;\\n\\n    function setDelegationUnbondingPeriod(uint32 _delegationUnbondingPeriod) external;\\n\\n    function setDelegationTaxPercentage(uint32 _percentage) external;\\n\\n    function setSlasher(address _slasher, bool _allowed) external;\\n\\n    function setAssetHolder(address _assetHolder, bool _allowed) external;\\n\\n    // -- Operation --\\n\\n    function setOperator(address _operator, bool _allowed) external;\\n\\n    function isOperator(address _operator, address _indexer) external view returns (bool);\\n\\n    // -- Staking --\\n\\n    function stake(uint256 _tokens) external;\\n\\n    function stakeTo(address _indexer, uint256 _tokens) external;\\n\\n    function unstake(uint256 _tokens) external;\\n\\n    function slash(\\n        address _indexer,\\n        uint256 _tokens,\\n        uint256 _reward,\\n        address _beneficiary\\n    ) external;\\n\\n    function withdraw() external;\\n\\n    function setRewardsDestination(address _destination) external;\\n\\n    // -- Delegation --\\n\\n    function delegate(address _indexer, uint256 _tokens) external returns (uint256);\\n\\n    function undelegate(address _indexer, uint256 _shares) external returns (uint256);\\n\\n    function withdrawDelegated(address _indexer, address _newIndexer) external returns (uint256);\\n\\n    // -- Channel management and allocations --\\n\\n    function allocate(\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        address _allocationID,\\n        bytes32 _metadata,\\n        bytes calldata _proof\\n    ) external;\\n\\n    function allocateFrom(\\n        address _indexer,\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        address _allocationID,\\n        bytes32 _metadata,\\n        bytes calldata _proof\\n    ) external;\\n\\n    function closeAllocation(address _allocationID, bytes32 _poi) external;\\n\\n    function closeAllocationMany(CloseAllocationRequest[] calldata _requests) external;\\n\\n    function closeAndAllocate(\\n        address _oldAllocationID,\\n        bytes32 _poi,\\n        address _indexer,\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        address _allocationID,\\n        bytes32 _metadata,\\n        bytes calldata _proof\\n    ) external;\\n\\n    function collect(uint256 _tokens, address _allocationID) external;\\n\\n    function claim(address _allocationID, bool _restake) external;\\n\\n    function claimMany(address[] calldata _allocationID, bool _restake) external;\\n\\n    // -- Getters and calculations --\\n\\n    function hasStake(address _indexer) external view returns (bool);\\n\\n    function getIndexerStakedTokens(address _indexer) external view returns (uint256);\\n\\n    function getIndexerCapacity(address _indexer) external view returns (uint256);\\n\\n    function getAllocation(address _allocationID) external view returns (Allocation memory);\\n\\n    function getAllocationState(address _allocationID) external view returns (AllocationState);\\n\\n    function isAllocation(address _allocationID) external view returns (bool);\\n\\n    function getSubgraphAllocatedTokens(bytes32 _subgraphDeploymentID)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getDelegation(address _indexer, address _delegator)\\n        external\\n        view\\n        returns (Delegation memory);\\n\\n    function isDelegator(address _indexer, address _delegator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/curation/IGraphCurationToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\ninterface IGraphCurationToken is IERC20Upgradeable {\\n    function initialize(address _owner) external;\\n\\n    function burnFrom(address _account, uint256 _amount) external;\\n\\n    function mint(address _to, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/IStakingData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.6.12 <0.8.0;\\n\\ninterface IStakingData {\\n    /**\\n     * @dev Allocate GRT tokens for the purpose of serving queries of a subgraph deployment\\n     * An allocation is created in the allocate() function and consumed in claim()\\n     */\\n    struct Allocation {\\n        address indexer;\\n        bytes32 subgraphDeploymentID;\\n        uint256 tokens; // Tokens allocated to a SubgraphDeployment\\n        uint256 createdAtEpoch; // Epoch when it was created\\n        uint256 closedAtEpoch; // Epoch when it was closed\\n        uint256 collectedFees; // Collected fees for the allocation\\n        uint256 effectiveAllocation; // Effective allocation when closed\\n        uint256 accRewardsPerAllocatedToken; // Snapshot used for reward calc\\n    }\\n\\n    /**\\n     * @dev Represents a request to close an allocation with a specific proof of indexing.\\n     * This is passed when calling closeAllocationMany to define the closing parameters for\\n     * each allocation.\\n     */\\n    struct CloseAllocationRequest {\\n        address allocationID;\\n        bytes32 poi;\\n    }\\n\\n    // -- Delegation Data --\\n\\n    /**\\n     * @dev Delegation pool information. One per indexer.\\n     */\\n    struct DelegationPool {\\n        uint32 cooldownBlocks; // Blocks to wait before updating parameters\\n        uint32 indexingRewardCut; // in PPM\\n        uint32 queryFeeCut; // in PPM\\n        uint256 updatedAtBlock; // Block when the pool was last updated\\n        uint256 tokens; // Total tokens as pool reserves\\n        uint256 shares; // Total shares minted in the pool\\n        mapping(address => Delegation) delegators; // Mapping of delegator => Delegation\\n    }\\n\\n    /**\\n     * @dev Individual delegation data of a delegator in a pool.\\n     */\\n    struct Delegation {\\n        uint256 shares; // Shares owned by a delegator in the pool\\n        uint256 tokensLocked; // Tokens locked for undelegation\\n        uint256 tokensLockedUntil; // Block when locked tokens can be withdrawn\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nameHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"ContractSynced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nSignalBurnt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnGRT\",\"type\":\"uint256\"}],\"name\":\"GRTWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"graphAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subgraphNumber\",\"type\":\"uint256\"}],\"name\":\"LegacySubgraphClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"param\",\"type\":\"string\"}],\"name\":\"ParameterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"SetController\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"graphAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nameSystem\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nameIdentifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"SetDefaultName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nSignalBurnt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vSignalBurnt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensReceived\",\"type\":\"uint256\"}],\"name\":\"SignalBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nSignalCreated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vSignalCreated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensDeposited\",\"type\":\"uint256\"}],\"name\":\"SignalMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawableGRT\",\"type\":\"uint256\"}],\"name\":\"SubgraphDeprecated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"subgraphMetadata\",\"type\":\"bytes32\"}],\"name\":\"SubgraphMetadataUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"subgraphNFT\",\"type\":\"address\"}],\"name\":\"SubgraphNFTUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"subgraphDeploymentID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"reserveRatio\",\"type\":\"uint32\"}],\"name\":\"SubgraphPublished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vSignalCreated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSignalled\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"subgraphDeploymentID\",\"type\":\"bytes32\"}],\"name\":\"SubgraphUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"subgraphDeploymentID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"versionMetadata\",\"type\":\"bytes32\"}],\"name\":\"SubgraphVersionUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IGraphProxy\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"acceptProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IGraphProxy\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"acceptProxyAndCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approveAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondingCurve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_subgraphID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nSignal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokensOutMin\",\"type\":\"uint256\"}],\"name\":\"burnSignal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_subgraphID\",\"type\":\"uint256\"}],\"name\":\"deprecateSubgraph\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_subgraphID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_curator\",\"type\":\"address\"}],\"name\":\"getCuratorSignal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bondingCurve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_subgraphNFT\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_subgraphID\",\"type\":\"uint256\"}],\"name\":\"isPublished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"legacySubgraphData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vSignal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nSignal\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"subgraphDeploymentID\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"reserveRatio\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableGRT\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"legacySubgraphKeys\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"accountSeqID\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graphAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subgraphNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_subgraphMetadata\",\"type\":\"bytes32\"}],\"name\":\"migrateLegacySubgraph\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_subgraphID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokensIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nSignalOutMin\",\"type\":\"uint256\"}],\"name\":\"mintSignal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_subgraphID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nSignalIn\",\"type\":\"uint256\"}],\"name\":\"nSignalToTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_subgraphID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nSignalIn\",\"type\":\"uint256\"}],\"name\":\"nSignalToVSignal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nextAccountSeqID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenID\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerTaxPercentage\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_subgraphDeploymentID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_versionMetadata\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_subgraphMetadata\",\"type\":\"bytes32\"}],\"name\":\"publishNewSubgraph\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_subgraphID\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_subgraphDeploymentID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_versionMetadata\",\"type\":\"bytes32\"}],\"name\":\"publishNewVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graphAccount\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_nameSystem\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_nameIdentifier\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setDefaultName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_ownerTaxPercentage\",\"type\":\"uint32\"}],\"name\":\"setOwnerTaxPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_subgraphNFT\",\"type\":\"address\"}],\"name\":\"setSubgraphNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"subgraphNFT\",\"outputs\":[{\"internalType\":\"contract ISubgraphNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_subgraphID\",\"type\":\"uint256\"}],\"name\":\"subgraphSignal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_subgraphID\",\"type\":\"uint256\"}],\"name\":\"subgraphTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"subgraphs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vSignal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nSignal\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"subgraphDeploymentID\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"reserveRatio\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableGRT\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"syncAllContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_subgraphID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokensIn\",\"type\":\"uint256\"}],\"name\":\"tokensToNSignal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_subgraphID\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_subgraphMetadata\",\"type\":\"bytes32\"}],\"name\":\"updateSubgraphMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_subgraphID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vSignalIn\",\"type\":\"uint256\"}],\"name\":\"vSignalToNSignal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_subgraphID\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GNS", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}