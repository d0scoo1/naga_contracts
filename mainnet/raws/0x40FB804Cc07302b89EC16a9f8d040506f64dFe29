{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/state-transfer/FxStateRootTunnel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\nimport { FxBaseRootTunnel } from \\\"../tunnel/FxBaseRootTunnel.sol\\\";\\n\\n/**\\n * @title FxStateRootTunnel\\n */\\ncontract FxStateRootTunnel is FxBaseRootTunnel, AccessControl {\\n\\tbytes public latestData;\\n\\taddress public maticX;\\n\\n\\tconstructor(\\n\\t\\taddress _checkpointManager,\\n\\t\\taddress _fxRoot,\\n\\t\\taddress _maticX\\n\\t) FxBaseRootTunnel(_checkpointManager, _fxRoot) {\\n\\t\\t_setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n\\n\\t\\tmaticX = _maticX;\\n\\t}\\n\\n\\tfunction _processMessageFromChild(bytes memory data) internal override {\\n\\t\\tlatestData = data;\\n\\t}\\n\\n\\tfunction sendMessageToChild(bytes memory message) public {\\n\\t\\trequire(msg.sender == maticX, \\\"Not maticX\\\");\\n\\t\\t_sendMessageToChild(message);\\n\\t}\\n\\n\\tfunction setMaticX(address _maticX) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n\\t\\tmaticX = _maticX;\\n\\t}\\n\\n\\tfunction setFxChildTunnel(address _fxChildTunnel)\\n\\t\\texternal\\n\\t\\toverride\\n\\t\\tonlyRole(DEFAULT_ADMIN_ROLE)\\n\\t{\\n\\t\\tfxChildTunnel = _fxChildTunnel;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tunnel/FxBaseRootTunnel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { RLPReader } from \\\"../lib/RLPReader.sol\\\";\\nimport { MerklePatriciaProof } from \\\"../lib/MerklePatriciaProof.sol\\\";\\nimport { Merkle } from \\\"../lib/Merkle.sol\\\";\\nimport \\\"../lib/ExitPayloadReader.sol\\\";\\n\\ninterface IFxStateSender {\\n\\tfunction sendMessageToChild(address _receiver, bytes calldata _data)\\n\\t\\texternal;\\n}\\n\\ncontract ICheckpointManager {\\n\\tstruct HeaderBlock {\\n\\t\\tbytes32 root;\\n\\t\\tuint256 start;\\n\\t\\tuint256 end;\\n\\t\\tuint256 createdAt;\\n\\t\\taddress proposer;\\n\\t}\\n\\n\\t/**\\n\\t * @notice mapping of checkpoint header numbers to block details\\n\\t * @dev These checkpoints are submited by plasma contracts\\n\\t */\\n\\tmapping(uint256 => HeaderBlock) public headerBlocks;\\n}\\n\\nabstract contract FxBaseRootTunnel {\\n\\tusing RLPReader for RLPReader.RLPItem;\\n\\tusing Merkle for bytes32;\\n\\tusing ExitPayloadReader for bytes;\\n\\tusing ExitPayloadReader for ExitPayloadReader.ExitPayload;\\n\\tusing ExitPayloadReader for ExitPayloadReader.Log;\\n\\tusing ExitPayloadReader for ExitPayloadReader.LogTopics;\\n\\tusing ExitPayloadReader for ExitPayloadReader.Receipt;\\n\\n\\t// keccak256(MessageSent(bytes))\\n\\tbytes32 public constant SEND_MESSAGE_EVENT_SIG =\\n\\t\\t0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036;\\n\\n\\t// state sender contract\\n\\tIFxStateSender public fxRoot;\\n\\t// root chain manager\\n\\tICheckpointManager public checkpointManager;\\n\\t// child tunnel contract which receives and sends messages\\n\\taddress public fxChildTunnel;\\n\\n\\t// storage to avoid duplicate exits\\n\\tmapping(bytes32 => bool) public processedExits;\\n\\n\\tconstructor(address _checkpointManager, address _fxRoot) {\\n\\t\\tcheckpointManager = ICheckpointManager(_checkpointManager);\\n\\t\\tfxRoot = IFxStateSender(_fxRoot);\\n\\t}\\n\\n\\tfunction setFxChildTunnel(address _fxChildTunnel) external virtual;\\n\\n\\t/**\\n\\t * @notice Send bytes message to Child Tunnel\\n\\t * @param message bytes message that will be sent to Child Tunnel\\n\\t * some message examples -\\n\\t *   abi.encode(tokenId);\\n\\t *   abi.encode(tokenId, tokenMetadata);\\n\\t *   abi.encode(messageType, messageData);\\n\\t */\\n\\tfunction _sendMessageToChild(bytes memory message) internal {\\n\\t\\tfxRoot.sendMessageToChild(fxChildTunnel, message);\\n\\t}\\n\\n\\tfunction _validateAndExtractMessage(bytes memory inputData)\\n\\t\\tinternal\\n\\t\\treturns (bytes memory)\\n\\t{\\n\\t\\tExitPayloadReader.ExitPayload memory payload = inputData\\n\\t\\t\\t.toExitPayload();\\n\\n\\t\\tbytes memory branchMaskBytes = payload.getBranchMaskAsBytes();\\n\\t\\tuint256 blockNumber = payload.getBlockNumber();\\n\\t\\t// checking if exit has already been processed\\n\\t\\t// unique exit is identified using hash of (blockNumber, branchMask, receiptLogIndex)\\n\\t\\tbytes32 exitHash = keccak256(\\n\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\tblockNumber,\\n\\t\\t\\t\\t// first 2 nibbles are dropped while generating nibble array\\n\\t\\t\\t\\t// this allows branch masks that are valid but bypass exitHash check (changing first 2 nibbles only)\\n\\t\\t\\t\\t// so converting to nibble array and then hashing it\\n\\t\\t\\t\\tMerklePatriciaProof._getNibbleArray(branchMaskBytes),\\n\\t\\t\\t\\tpayload.getReceiptLogIndex()\\n\\t\\t\\t)\\n\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\tprocessedExits[exitHash] == false,\\n\\t\\t\\t\\\"FxRootTunnel: EXIT_ALREADY_PROCESSED\\\"\\n\\t\\t);\\n\\t\\tprocessedExits[exitHash] = true;\\n\\n\\t\\tExitPayloadReader.Receipt memory receipt = payload.getReceipt();\\n\\t\\tExitPayloadReader.Log memory log = receipt.getLog();\\n\\n\\t\\t// check child tunnel\\n\\t\\trequire(\\n\\t\\t\\tfxChildTunnel == log.getEmitter(),\\n\\t\\t\\t\\\"FxRootTunnel: INVALID_FX_CHILD_TUNNEL\\\"\\n\\t\\t);\\n\\n\\t\\tbytes32 receiptRoot = payload.getReceiptRoot();\\n\\t\\t// verify receipt inclusion\\n\\t\\trequire(\\n\\t\\t\\tMerklePatriciaProof.verify(\\n\\t\\t\\t\\treceipt.toBytes(),\\n\\t\\t\\t\\tbranchMaskBytes,\\n\\t\\t\\t\\tpayload.getReceiptProof(),\\n\\t\\t\\t\\treceiptRoot\\n\\t\\t\\t),\\n\\t\\t\\t\\\"FxRootTunnel: INVALID_RECEIPT_PROOF\\\"\\n\\t\\t);\\n\\n\\t\\t// verify checkpoint inclusion\\n\\t\\t_checkBlockMembershipInCheckpoint(\\n\\t\\t\\tblockNumber,\\n\\t\\t\\tpayload.getBlockTime(),\\n\\t\\t\\tpayload.getTxRoot(),\\n\\t\\t\\treceiptRoot,\\n\\t\\t\\tpayload.getHeaderNumber(),\\n\\t\\t\\tpayload.getBlockProof()\\n\\t\\t);\\n\\n\\t\\tExitPayloadReader.LogTopics memory topics = log.getTopics();\\n\\n\\t\\trequire(\\n\\t\\t\\tbytes32(topics.getField(0).toUint()) == SEND_MESSAGE_EVENT_SIG, // topic0 is event sig\\n\\t\\t\\t\\\"FxRootTunnel: INVALID_SIGNATURE\\\"\\n\\t\\t);\\n\\n\\t\\t// received message data\\n\\t\\tbytes memory message = abi.decode(log.getData(), (bytes)); // event decodes params again, so decoding bytes to get message\\n\\t\\treturn message;\\n\\t}\\n\\n\\tfunction _checkBlockMembershipInCheckpoint(\\n\\t\\tuint256 blockNumber,\\n\\t\\tuint256 blockTime,\\n\\t\\tbytes32 txRoot,\\n\\t\\tbytes32 receiptRoot,\\n\\t\\tuint256 headerNumber,\\n\\t\\tbytes memory blockProof\\n\\t) private view returns (uint256) {\\n\\t\\t(\\n\\t\\t\\tbytes32 headerRoot,\\n\\t\\t\\tuint256 startBlock,\\n\\t\\t\\t,\\n\\t\\t\\tuint256 createdAt,\\n\\n\\t\\t) = checkpointManager.headerBlocks(headerNumber);\\n\\n\\t\\trequire(\\n\\t\\t\\tkeccak256(\\n\\t\\t\\t\\tabi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot)\\n\\t\\t\\t).checkMembership(blockNumber - startBlock, headerRoot, blockProof),\\n\\t\\t\\t\\\"FxRootTunnel: INVALID_HEADER\\\"\\n\\t\\t);\\n\\t\\treturn createdAt;\\n\\t}\\n\\n\\t/**\\n\\t * @notice receive message from  L2 to L1, validated by proof\\n\\t * @dev This function verifies if the transaction actually happened on child chain\\n\\t *\\n\\t * @param inputData RLP encoded data of the reference tx containing following list of fields\\n\\t *  0 - headerNumber - Checkpoint header block number containing the reference tx\\n\\t *  1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root\\n\\t *  2 - blockNumber - Block number containing the reference tx on child chain\\n\\t *  3 - blockTime - Reference tx block time\\n\\t *  4 - txRoot - Transactions root of block\\n\\t *  5 - receiptRoot - Receipts root of block\\n\\t *  6 - receipt - Receipt of the reference transaction\\n\\t *  7 - receiptProof - Merkle proof of the reference receipt\\n\\t *  8 - branchMask - 32 bits denoting the path of receipt in merkle tree\\n\\t *  9 - receiptLogIndex - Log Index to read from the receipt\\n\\t */\\n\\tfunction receiveMessage(bytes memory inputData) public virtual {\\n\\t\\tbytes memory message = _validateAndExtractMessage(inputData);\\n\\t\\t_processMessageFromChild(message);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Process message received from Child Tunnel\\n\\t * @dev function needs to be implemented to handle message as per requirement\\n\\t * This is called by onStateReceive function.\\n\\t * Since it is called via a system call, any event will not be emitted during its execution.\\n\\t * @param message bytes message that was sent from Child Tunnel\\n\\t */\\n\\tfunction _processMessageFromChild(bytes memory message) internal virtual;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/RLPReader.sol\": {\r\n      \"content\": \"/*\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\npragma solidity ^0.8.0;\\n\\nlibrary RLPReader {\\n\\tuint8 constant STRING_SHORT_START = 0x80;\\n\\tuint8 constant STRING_LONG_START = 0xb8;\\n\\tuint8 constant LIST_SHORT_START = 0xc0;\\n\\tuint8 constant LIST_LONG_START = 0xf8;\\n\\tuint8 constant WORD_SIZE = 32;\\n\\n\\tstruct RLPItem {\\n\\t\\tuint256 len;\\n\\t\\tuint256 memPtr;\\n\\t}\\n\\n\\tstruct Iterator {\\n\\t\\tRLPItem item; // Item that's being iterated over.\\n\\t\\tuint256 nextPtr; // Position of the next item in the list.\\n\\t}\\n\\n\\t/*\\n\\t * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n\\t * @param self The iterator.\\n\\t * @return The next element in the iteration.\\n\\t */\\n\\tfunction next(Iterator memory self) internal pure returns (RLPItem memory) {\\n\\t\\trequire(hasNext(self));\\n\\n\\t\\tuint256 ptr = self.nextPtr;\\n\\t\\tuint256 itemLength = _itemLength(ptr);\\n\\t\\tself.nextPtr = ptr + itemLength;\\n\\n\\t\\treturn RLPItem(itemLength, ptr);\\n\\t}\\n\\n\\t/*\\n\\t * @dev Returns true if the iteration has more elements.\\n\\t * @param self The iterator.\\n\\t * @return true if the iteration has more elements.\\n\\t */\\n\\tfunction hasNext(Iterator memory self) internal pure returns (bool) {\\n\\t\\tRLPItem memory item = self.item;\\n\\t\\treturn self.nextPtr < item.memPtr + item.len;\\n\\t}\\n\\n\\t/*\\n\\t * @param item RLP encoded bytes\\n\\t */\\n\\tfunction toRlpItem(bytes memory item)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (RLPItem memory)\\n\\t{\\n\\t\\tuint256 memPtr;\\n\\t\\tassembly {\\n\\t\\t\\tmemPtr := add(item, 0x20)\\n\\t\\t}\\n\\n\\t\\treturn RLPItem(item.length, memPtr);\\n\\t}\\n\\n\\t/*\\n\\t * @dev Create an iterator. Reverts if item is not a list.\\n\\t * @param self The RLP item.\\n\\t * @return An 'Iterator' over the item.\\n\\t */\\n\\tfunction iterator(RLPItem memory self)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (Iterator memory)\\n\\t{\\n\\t\\trequire(isList(self));\\n\\n\\t\\tuint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n\\t\\treturn Iterator(self, ptr);\\n\\t}\\n\\n\\t/*\\n\\t * @param item RLP encoded bytes\\n\\t */\\n\\tfunction rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n\\t\\treturn item.len;\\n\\t}\\n\\n\\t/*\\n\\t * @param item RLP encoded bytes\\n\\t */\\n\\tfunction payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n\\t\\treturn item.len - _payloadOffset(item.memPtr);\\n\\t}\\n\\n\\t/*\\n\\t * @param item RLP encoded list in bytes\\n\\t */\\n\\tfunction toList(RLPItem memory item)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (RLPItem[] memory)\\n\\t{\\n\\t\\trequire(isList(item));\\n\\n\\t\\tuint256 items = numItems(item);\\n\\t\\tRLPItem[] memory result = new RLPItem[](items);\\n\\n\\t\\tuint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n\\t\\tuint256 dataLen;\\n\\t\\tfor (uint256 i = 0; i < items; i++) {\\n\\t\\t\\tdataLen = _itemLength(memPtr);\\n\\t\\t\\tresult[i] = RLPItem(dataLen, memPtr);\\n\\t\\t\\tmemPtr = memPtr + dataLen;\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\t// @return indicator whether encoded payload is a list. negate this function call for isData.\\n\\tfunction isList(RLPItem memory item) internal pure returns (bool) {\\n\\t\\tif (item.len == 0) return false;\\n\\n\\t\\tuint8 byte0;\\n\\t\\tuint256 memPtr = item.memPtr;\\n\\t\\tassembly {\\n\\t\\t\\tbyte0 := byte(0, mload(memPtr))\\n\\t\\t}\\n\\n\\t\\tif (byte0 < LIST_SHORT_START) return false;\\n\\t\\treturn true;\\n\\t}\\n\\n\\t/*\\n\\t * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n\\t * @return keccak256 hash of RLP encoded bytes.\\n\\t */\\n\\tfunction rlpBytesKeccak256(RLPItem memory item)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bytes32)\\n\\t{\\n\\t\\tuint256 ptr = item.memPtr;\\n\\t\\tuint256 len = item.len;\\n\\t\\tbytes32 result;\\n\\t\\tassembly {\\n\\t\\t\\tresult := keccak256(ptr, len)\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\tfunction payloadLocation(RLPItem memory item)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256, uint256)\\n\\t{\\n\\t\\tuint256 offset = _payloadOffset(item.memPtr);\\n\\t\\tuint256 memPtr = item.memPtr + offset;\\n\\t\\tuint256 len = item.len - offset; // data length\\n\\t\\treturn (memPtr, len);\\n\\t}\\n\\n\\t/*\\n\\t * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n\\t * @return keccak256 hash of the item payload.\\n\\t */\\n\\tfunction payloadKeccak256(RLPItem memory item)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bytes32)\\n\\t{\\n\\t\\t(uint256 memPtr, uint256 len) = payloadLocation(item);\\n\\t\\tbytes32 result;\\n\\t\\tassembly {\\n\\t\\t\\tresult := keccak256(memPtr, len)\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\t/** RLPItem conversions into data types **/\\n\\n\\t// @returns raw rlp encoding in bytes\\n\\tfunction toRlpBytes(RLPItem memory item)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bytes memory)\\n\\t{\\n\\t\\tbytes memory result = new bytes(item.len);\\n\\t\\tif (result.length == 0) return result;\\n\\n\\t\\tuint256 ptr;\\n\\t\\tassembly {\\n\\t\\t\\tptr := add(0x20, result)\\n\\t\\t}\\n\\n\\t\\tcopy(item.memPtr, ptr, item.len);\\n\\t\\treturn result;\\n\\t}\\n\\n\\t// any non-zero byte is considered true\\n\\tfunction toBoolean(RLPItem memory item) internal pure returns (bool) {\\n\\t\\trequire(item.len == 1);\\n\\t\\tuint256 result;\\n\\t\\tuint256 memPtr = item.memPtr;\\n\\t\\tassembly {\\n\\t\\t\\tresult := byte(0, mload(memPtr))\\n\\t\\t}\\n\\n\\t\\treturn result == 0 ? false : true;\\n\\t}\\n\\n\\tfunction toAddress(RLPItem memory item) internal pure returns (address) {\\n\\t\\t// 1 byte for the length prefix\\n\\t\\trequire(item.len == 21);\\n\\n\\t\\treturn address(uint160(toUint(item)));\\n\\t}\\n\\n\\tfunction toUint(RLPItem memory item) internal pure returns (uint256) {\\n\\t\\trequire(item.len > 0 && item.len <= 33);\\n\\n\\t\\tuint256 offset = _payloadOffset(item.memPtr);\\n\\t\\tuint256 len = item.len - offset;\\n\\n\\t\\tuint256 result;\\n\\t\\tuint256 memPtr = item.memPtr + offset;\\n\\t\\tassembly {\\n\\t\\t\\tresult := mload(memPtr)\\n\\n\\t\\t\\t// shfit to the correct location if neccesary\\n\\t\\t\\tif lt(len, 32) {\\n\\t\\t\\t\\tresult := div(result, exp(256, sub(32, len)))\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\t// enforces 32 byte length\\n\\tfunction toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n\\t\\t// one byte prefix\\n\\t\\trequire(item.len == 33);\\n\\n\\t\\tuint256 result;\\n\\t\\tuint256 memPtr = item.memPtr + 1;\\n\\t\\tassembly {\\n\\t\\t\\tresult := mload(memPtr)\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n\\n\\tfunction toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n\\t\\trequire(item.len > 0);\\n\\n\\t\\tuint256 offset = _payloadOffset(item.memPtr);\\n\\t\\tuint256 len = item.len - offset; // data length\\n\\t\\tbytes memory result = new bytes(len);\\n\\n\\t\\tuint256 destPtr;\\n\\t\\tassembly {\\n\\t\\t\\tdestPtr := add(0x20, result)\\n\\t\\t}\\n\\n\\t\\tcopy(item.memPtr + offset, destPtr, len);\\n\\t\\treturn result;\\n\\t}\\n\\n\\t/*\\n\\t * Private Helpers\\n\\t */\\n\\n\\t// @return number of payload items inside an encoded list.\\n\\tfunction numItems(RLPItem memory item) private pure returns (uint256) {\\n\\t\\tif (item.len == 0) return 0;\\n\\n\\t\\tuint256 count = 0;\\n\\t\\tuint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n\\t\\tuint256 endPtr = item.memPtr + item.len;\\n\\t\\twhile (currPtr < endPtr) {\\n\\t\\t\\tcurrPtr = currPtr + _itemLength(currPtr); // skip over an item\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n\\n\\t// @return entire rlp item byte length\\n\\tfunction _itemLength(uint256 memPtr) private pure returns (uint256) {\\n\\t\\tuint256 itemLen;\\n\\t\\tuint256 byte0;\\n\\t\\tassembly {\\n\\t\\t\\tbyte0 := byte(0, mload(memPtr))\\n\\t\\t}\\n\\n\\t\\tif (byte0 < STRING_SHORT_START) itemLen = 1;\\n\\t\\telse if (byte0 < STRING_LONG_START)\\n\\t\\t\\titemLen = byte0 - STRING_SHORT_START + 1;\\n\\t\\telse if (byte0 < LIST_SHORT_START) {\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tlet byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n\\t\\t\\t\\tmemPtr := add(memPtr, 1) // skip over the first byte\\n\\t\\t\\t\\t/* 32 byte word size */\\n\\t\\t\\t\\tlet dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n\\t\\t\\t\\titemLen := add(dataLen, add(byteLen, 1))\\n\\t\\t\\t}\\n\\t\\t} else if (byte0 < LIST_LONG_START) {\\n\\t\\t\\titemLen = byte0 - LIST_SHORT_START + 1;\\n\\t\\t} else {\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tlet byteLen := sub(byte0, 0xf7)\\n\\t\\t\\t\\tmemPtr := add(memPtr, 1)\\n\\n\\t\\t\\t\\tlet dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n\\t\\t\\t\\titemLen := add(dataLen, add(byteLen, 1))\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn itemLen;\\n\\t}\\n\\n\\t// @return number of bytes until the data\\n\\tfunction _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n\\t\\tuint256 byte0;\\n\\t\\tassembly {\\n\\t\\t\\tbyte0 := byte(0, mload(memPtr))\\n\\t\\t}\\n\\n\\t\\tif (byte0 < STRING_SHORT_START) return 0;\\n\\t\\telse if (\\n\\t\\t\\tbyte0 < STRING_LONG_START ||\\n\\t\\t\\t(byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)\\n\\t\\t) return 1;\\n\\t\\telse if (byte0 < LIST_SHORT_START)\\n\\t\\t\\t// being explicit\\n\\t\\t\\treturn byte0 - (STRING_LONG_START - 1) + 1;\\n\\t\\telse return byte0 - (LIST_LONG_START - 1) + 1;\\n\\t}\\n\\n\\t/*\\n\\t * @param src Pointer to source\\n\\t * @param dest Pointer to destination\\n\\t * @param len Amount of memory to copy from the source\\n\\t */\\n\\tfunction copy(\\n\\t\\tuint256 src,\\n\\t\\tuint256 dest,\\n\\t\\tuint256 len\\n\\t) private pure {\\n\\t\\tif (len == 0) return;\\n\\n\\t\\t// copy as many word sizes as possible\\n\\t\\tfor (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tmstore(dest, mload(src))\\n\\t\\t\\t}\\n\\n\\t\\t\\tsrc += WORD_SIZE;\\n\\t\\t\\tdest += WORD_SIZE;\\n\\t\\t}\\n\\n\\t\\tif (len == 0) return;\\n\\n\\t\\t// left over bytes. Mask is used to remove unwanted bytes from the word\\n\\t\\tuint256 mask = 256**(WORD_SIZE - len) - 1;\\n\\n\\t\\tassembly {\\n\\t\\t\\tlet srcpart := and(mload(src), not(mask)) // zero out src\\n\\t\\t\\tlet destpart := and(mload(dest), mask) // retrieve the bytes\\n\\t\\t\\tmstore(dest, or(destpart, srcpart))\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/lib/MerklePatriciaProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { RLPReader } from \\\"./RLPReader.sol\\\";\\n\\nlibrary MerklePatriciaProof {\\n\\t/*\\n\\t * @dev Verifies a merkle patricia proof.\\n\\t * @param value The terminating value in the trie.\\n\\t * @param encodedPath The path in the trie leading to value.\\n\\t * @param rlpParentNodes The rlp encoded stack of nodes.\\n\\t * @param root The root hash of the trie.\\n\\t * @return The boolean validity of the proof.\\n\\t */\\n\\tfunction verify(\\n\\t\\tbytes memory value,\\n\\t\\tbytes memory encodedPath,\\n\\t\\tbytes memory rlpParentNodes,\\n\\t\\tbytes32 root\\n\\t) internal pure returns (bool) {\\n\\t\\tRLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);\\n\\t\\tRLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);\\n\\n\\t\\tbytes memory currentNode;\\n\\t\\tRLPReader.RLPItem[] memory currentNodeList;\\n\\n\\t\\tbytes32 nodeKey = root;\\n\\t\\tuint256 pathPtr = 0;\\n\\n\\t\\tbytes memory path = _getNibbleArray(encodedPath);\\n\\t\\tif (path.length == 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tfor (uint256 i = 0; i < parentNodes.length; i++) {\\n\\t\\t\\tif (pathPtr > path.length) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrentNode = RLPReader.toRlpBytes(parentNodes[i]);\\n\\t\\t\\tif (nodeKey != keccak256(currentNode)) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tcurrentNodeList = RLPReader.toList(parentNodes[i]);\\n\\n\\t\\t\\tif (currentNodeList.length == 17) {\\n\\t\\t\\t\\tif (pathPtr == path.length) {\\n\\t\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t\\tkeccak256(RLPReader.toBytes(currentNodeList[16])) ==\\n\\t\\t\\t\\t\\t\\tkeccak256(value)\\n\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuint8 nextPathNibble = uint8(path[pathPtr]);\\n\\t\\t\\t\\tif (nextPathNibble > 16) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnodeKey = bytes32(\\n\\t\\t\\t\\t\\tRLPReader.toUintStrict(currentNodeList[nextPathNibble])\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tpathPtr += 1;\\n\\t\\t\\t} else if (currentNodeList.length == 2) {\\n\\t\\t\\t\\tuint256 traversed = _nibblesToTraverse(\\n\\t\\t\\t\\t\\tRLPReader.toBytes(currentNodeList[0]),\\n\\t\\t\\t\\t\\tpath,\\n\\t\\t\\t\\t\\tpathPtr\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tif (pathPtr + traversed == path.length) {\\n\\t\\t\\t\\t\\t//leaf node\\n\\t\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\t\\tkeccak256(RLPReader.toBytes(currentNodeList[1])) ==\\n\\t\\t\\t\\t\\t\\tkeccak256(value)\\n\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//extension node\\n\\t\\t\\t\\tif (traversed == 0) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tpathPtr += traversed;\\n\\t\\t\\t\\tnodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _nibblesToTraverse(\\n\\t\\tbytes memory encodedPartialPath,\\n\\t\\tbytes memory path,\\n\\t\\tuint256 pathPtr\\n\\t) private pure returns (uint256) {\\n\\t\\tuint256 len = 0;\\n\\t\\t// encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\\n\\t\\t// and slicedPath have elements that are each one hex character (1 nibble)\\n\\t\\tbytes memory partialPath = _getNibbleArray(encodedPartialPath);\\n\\t\\tbytes memory slicedPath = new bytes(partialPath.length);\\n\\n\\t\\t// pathPtr counts nibbles in path\\n\\t\\t// partialPath.length is a number of nibbles\\n\\t\\tfor (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {\\n\\t\\t\\tbytes1 pathNibble = path[i];\\n\\t\\t\\tslicedPath[i - pathPtr] = pathNibble;\\n\\t\\t}\\n\\n\\t\\tif (keccak256(partialPath) == keccak256(slicedPath)) {\\n\\t\\t\\tlen = partialPath.length;\\n\\t\\t} else {\\n\\t\\t\\tlen = 0;\\n\\t\\t}\\n\\t\\treturn len;\\n\\t}\\n\\n\\t// bytes b must be hp encoded\\n\\tfunction _getNibbleArray(bytes memory b)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bytes memory)\\n\\t{\\n\\t\\tbytes memory nibbles = \\\"\\\";\\n\\t\\tif (b.length > 0) {\\n\\t\\t\\tuint8 offset;\\n\\t\\t\\tuint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));\\n\\t\\t\\tif (hpNibble == 1 || hpNibble == 3) {\\n\\t\\t\\t\\tnibbles = new bytes(b.length * 2 - 1);\\n\\t\\t\\t\\tbytes1 oddNibble = _getNthNibbleOfBytes(1, b);\\n\\t\\t\\t\\tnibbles[0] = oddNibble;\\n\\t\\t\\t\\toffset = 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnibbles = new bytes(b.length * 2 - 2);\\n\\t\\t\\t\\toffset = 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (uint256 i = offset; i < nibbles.length; i++) {\\n\\t\\t\\t\\tnibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nibbles;\\n\\t}\\n\\n\\tfunction _getNthNibbleOfBytes(uint256 n, bytes memory str)\\n\\t\\tprivate\\n\\t\\tpure\\n\\t\\treturns (bytes1)\\n\\t{\\n\\t\\treturn\\n\\t\\t\\tbytes1(\\n\\t\\t\\t\\tn % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10\\n\\t\\t\\t);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Merkle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Merkle {\\n\\tfunction checkMembership(\\n\\t\\tbytes32 leaf,\\n\\t\\tuint256 index,\\n\\t\\tbytes32 rootHash,\\n\\t\\tbytes memory proof\\n\\t) internal pure returns (bool) {\\n\\t\\trequire(proof.length % 32 == 0, \\\"Invalid proof length\\\");\\n\\t\\tuint256 proofHeight = proof.length / 32;\\n\\t\\t// Proof of size n means, height of the tree is n+1.\\n\\t\\t// In a tree of height n+1, max #leafs possible is 2 ^ n\\n\\t\\trequire(index < 2**proofHeight, \\\"Leaf index is too big\\\");\\n\\n\\t\\tbytes32 proofElement;\\n\\t\\tbytes32 computedHash = leaf;\\n\\t\\tfor (uint256 i = 32; i <= proof.length; i += 32) {\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tproofElement := mload(add(proof, i))\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (index % 2 == 0) {\\n\\t\\t\\t\\tcomputedHash = keccak256(\\n\\t\\t\\t\\t\\tabi.encodePacked(computedHash, proofElement)\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcomputedHash = keccak256(\\n\\t\\t\\t\\t\\tabi.encodePacked(proofElement, computedHash)\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\tindex = index / 2;\\n\\t\\t}\\n\\t\\treturn computedHash == rootHash;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ExitPayloadReader.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport { RLPReader } from \\\"./RLPReader.sol\\\";\\n\\nlibrary ExitPayloadReader {\\n\\tusing RLPReader for bytes;\\n\\tusing RLPReader for RLPReader.RLPItem;\\n\\n\\tuint8 constant WORD_SIZE = 32;\\n\\n\\tstruct ExitPayload {\\n\\t\\tRLPReader.RLPItem[] data;\\n\\t}\\n\\n\\tstruct Receipt {\\n\\t\\tRLPReader.RLPItem[] data;\\n\\t\\tbytes raw;\\n\\t\\tuint256 logIndex;\\n\\t}\\n\\n\\tstruct Log {\\n\\t\\tRLPReader.RLPItem data;\\n\\t\\tRLPReader.RLPItem[] list;\\n\\t}\\n\\n\\tstruct LogTopics {\\n\\t\\tRLPReader.RLPItem[] data;\\n\\t}\\n\\n\\t// copy paste of private copy() from RLPReader to avoid changing of existing contracts\\n\\tfunction copy(\\n\\t\\tuint256 src,\\n\\t\\tuint256 dest,\\n\\t\\tuint256 len\\n\\t) private pure {\\n\\t\\tif (len == 0) return;\\n\\n\\t\\t// copy as many word sizes as possible\\n\\t\\tfor (; len >= WORD_SIZE; len -= WORD_SIZE) {\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tmstore(dest, mload(src))\\n\\t\\t\\t}\\n\\n\\t\\t\\tsrc += WORD_SIZE;\\n\\t\\t\\tdest += WORD_SIZE;\\n\\t\\t}\\n\\n\\t\\t// left over bytes. Mask is used to remove unwanted bytes from the word\\n\\t\\tuint256 mask = 256**(WORD_SIZE - len) - 1;\\n\\t\\tassembly {\\n\\t\\t\\tlet srcpart := and(mload(src), not(mask)) // zero out src\\n\\t\\t\\tlet destpart := and(mload(dest), mask) // retrieve the bytes\\n\\t\\t\\tmstore(dest, or(destpart, srcpart))\\n\\t\\t}\\n\\t}\\n\\n\\tfunction toExitPayload(bytes memory data)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (ExitPayload memory)\\n\\t{\\n\\t\\tRLPReader.RLPItem[] memory payloadData = data.toRlpItem().toList();\\n\\n\\t\\treturn ExitPayload(payloadData);\\n\\t}\\n\\n\\tfunction getHeaderNumber(ExitPayload memory payload)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\treturn payload.data[0].toUint();\\n\\t}\\n\\n\\tfunction getBlockProof(ExitPayload memory payload)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bytes memory)\\n\\t{\\n\\t\\treturn payload.data[1].toBytes();\\n\\t}\\n\\n\\tfunction getBlockNumber(ExitPayload memory payload)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\treturn payload.data[2].toUint();\\n\\t}\\n\\n\\tfunction getBlockTime(ExitPayload memory payload)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\treturn payload.data[3].toUint();\\n\\t}\\n\\n\\tfunction getTxRoot(ExitPayload memory payload)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bytes32)\\n\\t{\\n\\t\\treturn bytes32(payload.data[4].toUint());\\n\\t}\\n\\n\\tfunction getReceiptRoot(ExitPayload memory payload)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bytes32)\\n\\t{\\n\\t\\treturn bytes32(payload.data[5].toUint());\\n\\t}\\n\\n\\tfunction getReceipt(ExitPayload memory payload)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (Receipt memory receipt)\\n\\t{\\n\\t\\treceipt.raw = payload.data[6].toBytes();\\n\\t\\tRLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();\\n\\n\\t\\tif (receiptItem.isList()) {\\n\\t\\t\\t// legacy tx\\n\\t\\t\\treceipt.data = receiptItem.toList();\\n\\t\\t} else {\\n\\t\\t\\t// pop first byte before parsting receipt\\n\\t\\t\\tbytes memory typedBytes = receipt.raw;\\n\\t\\t\\tbytes memory result = new bytes(typedBytes.length - 1);\\n\\t\\t\\tuint256 srcPtr;\\n\\t\\t\\tuint256 destPtr;\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tsrcPtr := add(33, typedBytes)\\n\\t\\t\\t\\tdestPtr := add(0x20, result)\\n\\t\\t\\t}\\n\\n\\t\\t\\tcopy(srcPtr, destPtr, result.length);\\n\\t\\t\\treceipt.data = result.toRlpItem().toList();\\n\\t\\t}\\n\\n\\t\\treceipt.logIndex = getReceiptLogIndex(payload);\\n\\t\\treturn receipt;\\n\\t}\\n\\n\\tfunction getReceiptProof(ExitPayload memory payload)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bytes memory)\\n\\t{\\n\\t\\treturn payload.data[7].toBytes();\\n\\t}\\n\\n\\tfunction getBranchMaskAsBytes(ExitPayload memory payload)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bytes memory)\\n\\t{\\n\\t\\treturn payload.data[8].toBytes();\\n\\t}\\n\\n\\tfunction getBranchMaskAsUint(ExitPayload memory payload)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\treturn payload.data[8].toUint();\\n\\t}\\n\\n\\tfunction getReceiptLogIndex(ExitPayload memory payload)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (uint256)\\n\\t{\\n\\t\\treturn payload.data[9].toUint();\\n\\t}\\n\\n\\t// Receipt methods\\n\\tfunction toBytes(Receipt memory receipt)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (bytes memory)\\n\\t{\\n\\t\\treturn receipt.raw;\\n\\t}\\n\\n\\tfunction getLog(Receipt memory receipt) internal pure returns (Log memory) {\\n\\t\\tRLPReader.RLPItem memory logData = receipt.data[3].toList()[\\n\\t\\t\\treceipt.logIndex\\n\\t\\t];\\n\\t\\treturn Log(logData, logData.toList());\\n\\t}\\n\\n\\t// Log methods\\n\\tfunction getEmitter(Log memory log) internal pure returns (address) {\\n\\t\\treturn RLPReader.toAddress(log.list[0]);\\n\\t}\\n\\n\\tfunction getTopics(Log memory log)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (LogTopics memory)\\n\\t{\\n\\t\\treturn LogTopics(log.list[1].toList());\\n\\t}\\n\\n\\tfunction getData(Log memory log) internal pure returns (bytes memory) {\\n\\t\\treturn log.list[2].toBytes();\\n\\t}\\n\\n\\tfunction toRlpBytes(Log memory log) internal pure returns (bytes memory) {\\n\\t\\treturn log.data.toRlpBytes();\\n\\t}\\n\\n\\t// LogTopics methods\\n\\tfunction getField(LogTopics memory topics, uint256 index)\\n\\t\\tinternal\\n\\t\\tpure\\n\\t\\treturns (RLPReader.RLPItem memory)\\n\\t{\\n\\t\\treturn topics.data[index];\\n\\t}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_checkpointManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fxRoot\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_maticX\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SEND_MESSAGE_EVENT_SIG\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpointManager\",\"outputs\":[{\"internalType\":\"contract ICheckpointManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxChildTunnel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxRoot\",\"outputs\":[{\"internalType\":\"contract IFxStateSender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maticX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"processedExits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"inputData\",\"type\":\"bytes\"}],\"name\":\"receiveMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"sendMessageToChild\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fxChildTunnel\",\"type\":\"address\"}],\"name\":\"setFxChildTunnel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_maticX\",\"type\":\"address\"}],\"name\":\"setMaticX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FxStateRootTunnel", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000086e4dc95c7fbdbf52e33d563bbdb00823894c287000000000000000000000000fe5e5d361b2ad62c541bab87c45a0b9b018389a2000000000000000000000000f03a7eb46d01d9ecaa104558c732cf82f6b6b645", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}