{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"ISelfServiceFrequencyControls.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\ninterface ISelfServiceFrequencyControls {\\n\\n  /*\\n   * Checks is the given artist can create another edition\\n   * @param artist - the edition artist\\n   * @param totalAvailable - the edition size\\n   * @param priceInWei - the edition price in wei\\n   */\\n  function canCreateNewEdition(address artist) external view returns (bool);\\n\\n  /*\\n   * Records that an edition has been created\\n   * @param artist - the edition artist\\n   * @param totalAvailable - the edition size\\n   * @param priceInWei - the edition price in wei\\n   */\\n  function recordSuccessfulMint(address artist, uint256 totalAvailable, uint256 priceInWei) external returns (bool);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n  address public owner;\\n\\n\\n  event OwnershipRenounced(address indexed previousOwner);\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to relinquish control of the contract.\\n   * @notice Renouncing to ownership will leave the contract without an owner.\\n   * It will not be possible to call the functions with the `onlyOwner`\\n   * modifier anymore.\\n   */\\n  function renounceOwnership() public onlyOwner {\\n    emit OwnershipRenounced(owner);\\n    owner = address(0);\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param _newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address _newOwner) public onlyOwner {\\n    _transferOwnership(_newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers control of the contract to a newOwner.\\n   * @param _newOwner The address to transfer ownership to.\\n   */\\n  function _transferOwnership(address _newOwner) internal {\\n    require(_newOwner != address(0));\\n    emit OwnershipTransferred(owner, _newOwner);\\n    owner = _newOwner;\\n  }\\n}\"},\"RBAC.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./Roles.sol\\\";\\n\\n\\n/**\\n * @title RBAC (Role-Based Access Control)\\n * @author Matt Condon (@Shrugs)\\n * @dev Stores and provides setters and getters for roles and addresses.\\n * Supports unlimited numbers of roles and addresses.\\n * See //contracts/mocks/RBACMock.sol for an example of usage.\\n * This RBAC method uses strings to key roles. It may be beneficial\\n * for you to write your own implementation of this interface using Enums or similar.\\n */\\ncontract RBAC {\\n  using Roles for Roles.Role;\\n\\n  mapping (string =\\u003e Roles.Role) private roles;\\n\\n  event RoleAdded(address indexed operator, string role);\\n  event RoleRemoved(address indexed operator, string role);\\n\\n  /**\\n   * @dev reverts if addr does not have role\\n   * @param _operator address\\n   * @param _role the name of the role\\n   * // reverts\\n   */\\n  function checkRole(address _operator, string _role)\\n    public\\n    view\\n  {\\n    roles[_role].check(_operator);\\n  }\\n\\n  /**\\n   * @dev determine if addr has role\\n   * @param _operator address\\n   * @param _role the name of the role\\n   * @return bool\\n   */\\n  function hasRole(address _operator, string _role)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    return roles[_role].has(_operator);\\n  }\\n\\n  /**\\n   * @dev add a role to an address\\n   * @param _operator address\\n   * @param _role the name of the role\\n   */\\n  function addRole(address _operator, string _role)\\n    internal\\n  {\\n    roles[_role].add(_operator);\\n    emit RoleAdded(_operator, _role);\\n  }\\n\\n  /**\\n   * @dev remove a role from an address\\n   * @param _operator address\\n   * @param _role the name of the role\\n   */\\n  function removeRole(address _operator, string _role)\\n    internal\\n  {\\n    roles[_role].remove(_operator);\\n    emit RoleRemoved(_operator, _role);\\n  }\\n\\n  /**\\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\\n   * @param _role the name of the role\\n   * // reverts\\n   */\\n  modifier onlyRole(string _role)\\n  {\\n    checkRole(msg.sender, _role);\\n    _;\\n  }\\n\\n  /**\\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\\n   * @param _roles the names of the roles to scope access to\\n   * // reverts\\n   *\\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\\n   *  see: https://github.com/ethereum/solidity/issues/2467\\n   */\\n  // modifier onlyRoles(string[] _roles) {\\n  //     bool hasAnyRole = false;\\n  //     for (uint8 i = 0; i \\u003c _roles.length; i++) {\\n  //         if (hasRole(msg.sender, _roles[i])) {\\n  //             hasAnyRole = true;\\n  //             break;\\n  //         }\\n  //     }\\n\\n  //     require(hasAnyRole);\\n\\n  //     _;\\n  // }\\n}\"},\"Roles.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title Roles\\n * @author Francisco Giordano (@frangio)\\n * @dev Library for managing addresses assigned to a Role.\\n * See RBAC.sol for example usage.\\n */\\nlibrary Roles {\\n  struct Role {\\n    mapping (address =\\u003e bool) bearer;\\n  }\\n\\n  /**\\n   * @dev give an address access to this role\\n   */\\n  function add(Role storage _role, address _addr)\\n    internal\\n  {\\n    _role.bearer[_addr] = true;\\n  }\\n\\n  /**\\n   * @dev remove an address\\u0027 access to this role\\n   */\\n  function remove(Role storage _role, address _addr)\\n    internal\\n  {\\n    _role.bearer[_addr] = false;\\n  }\\n\\n  /**\\n   * @dev check if an address has this role\\n   * // reverts\\n   */\\n  function check(Role storage _role, address _addr)\\n    internal\\n    view\\n  {\\n    require(has(_role, _addr));\\n  }\\n\\n  /**\\n   * @dev check if an address has this role\\n   * @return bool\\n   */\\n  function has(Role storage _role, address _addr)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _role.bearer[_addr];\\n  }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\\n    // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (_a == 0) {\\n      return 0;\\n    }\\n\\n    c = _a * _b;\\n    assert(c / _a == _b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    // assert(_b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = _a / _b;\\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn\\u0027t hold\\n    return _a / _b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    assert(_b \\u003c= _a);\\n    return _a - _b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\\n    c = _a + _b;\\n    assert(c \\u003e= _a);\\n    return c;\\n  }\\n}\"},\"SelfServiceFrequencyControls.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Whitelist.sol\\\";\\nimport \\\"./ISelfServiceFrequencyControls.sol\\\";\\n\\ncontract SelfServiceFrequencyControls is ISelfServiceFrequencyControls, Whitelist {\\n  using SafeMath for uint256;\\n\\n  // frozen out for..\\n  uint256 public freezeWindow = 1 days;\\n\\n  // When the current time period started\\n  mapping(address =\\u003e uint256) public frozenTil;\\n\\n  // Frequency override list for users - you can temporaily add in address which disables the 24hr check\\n  mapping(address =\\u003e bool) public frequencyOverride;\\n\\n  constructor() public {\\n    super.addAddressToWhitelist(msg.sender);\\n  }\\n\\n  function canCreateNewEdition(address artist) external view returns (bool) {\\n    if (frequencyOverride[artist]) {\\n      return true;\\n    }\\n    return (block.timestamp \\u003e= frozenTil[artist]);\\n  }\\n\\n  function recordSuccessfulMint(address artist, uint256 totalAvailable, uint256 priceInWei) external onlyIfWhitelisted(msg.sender) returns (bool) {\\n    frozenTil[artist] = block.timestamp.add(freezeWindow);\\n    return true;\\n  }\\n\\n  function setFrequencyOverride(address artist, bool value) external onlyIfWhitelisted(msg.sender) {\\n    frequencyOverride[artist] = value;\\n  }\\n\\n  /**\\n   * @dev Sets freeze window\\n   * @dev Only callable from owner\\n   */\\n  function setFreezeWindow(uint256 _freezeWindow) onlyIfWhitelisted(msg.sender) public {\\n    freezeWindow = _freezeWindow;\\n  }\\n\\n  /**\\n   * @dev Allows for the ability to extract stuck ether\\n   * @dev Only callable from owner\\n   */\\n  function withdrawStuckEther(address _withdrawalAccount) onlyIfWhitelisted(msg.sender) public {\\n    require(_withdrawalAccount != address(0), \\\"Invalid address provided\\\");\\n    _withdrawalAccount.transfer(address(this).balance);\\n  }\\n}\\n\"},\"Whitelist.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./RBAC.sol\\\";\\n\\n\\n/**\\n * @title Whitelist\\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\\n * This simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Whitelist is Ownable, RBAC {\\n  string public constant ROLE_WHITELISTED = \\\"whitelist\\\";\\n\\n  /**\\n   * @dev Throws if operator is not whitelisted.\\n   * @param _operator address\\n   */\\n  modifier onlyIfWhitelisted(address _operator) {\\n    checkRole(_operator, ROLE_WHITELISTED);\\n    _;\\n  }\\n\\n  /**\\n   * @dev add an address to the whitelist\\n   * @param _operator address\\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\\n   */\\n  function addAddressToWhitelist(address _operator)\\n    public\\n    onlyOwner\\n  {\\n    addRole(_operator, ROLE_WHITELISTED);\\n  }\\n\\n  /**\\n   * @dev getter to determine if address is in whitelist\\n   */\\n  function whitelist(address _operator)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    return hasRole(_operator, ROLE_WHITELISTED);\\n  }\\n\\n  /**\\n   * @dev add addresses to the whitelist\\n   * @param _operators addresses\\n   * @return true if at least one address was added to the whitelist,\\n   * false if all addresses were already in the whitelist\\n   */\\n  function addAddressesToWhitelist(address[] _operators)\\n    public\\n    onlyOwner\\n  {\\n    for (uint256 i = 0; i \\u003c _operators.length; i++) {\\n      addAddressToWhitelist(_operators[i]);\\n    }\\n  }\\n\\n  /**\\n   * @dev remove an address from the whitelist\\n   * @param _operator address\\n   * @return true if the address was removed from the whitelist,\\n   * false if the address wasn\\u0027t in the whitelist in the first place\\n   */\\n  function removeAddressFromWhitelist(address _operator)\\n    public\\n    onlyOwner\\n  {\\n    removeRole(_operator, ROLE_WHITELISTED);\\n  }\\n\\n  /**\\n   * @dev remove addresses from the whitelist\\n   * @param _operators addresses\\n   * @return true if at least one address was removed from the whitelist,\\n   * false if all addresses weren\\u0027t in the whitelist in the first place\\n   */\\n  function removeAddressesFromWhitelist(address[] _operators)\\n    public\\n    onlyOwner\\n  {\\n    for (uint256 i = 0; i \\u003c _operators.length; i++) {\\n      removeAddressFromWhitelist(_operators[i]);\\n    }\\n  }\\n\\n}\"}}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frequencyOverride\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_WHITELISTED\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operators\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawalAccount\",\"type\":\"address\"}],\"name\":\"withdrawStuckEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freezeWindow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenTil\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"artist\",\"type\":\"address\"},{\"name\":\"totalAvailable\",\"type\":\"uint256\"},{\"name\":\"priceInWei\",\"type\":\"uint256\"}],\"name\":\"recordSuccessfulMint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"artist\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setFrequencyOverride\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operators\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"artist\",\"type\":\"address\"}],\"name\":\"canCreateNewEdition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_freezeWindow\",\"type\":\"uint256\"}],\"name\":\"setFreezeWindow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "SelfServiceFrequencyControls", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://b6c9fd128c55d91b437c8bacae154c368621dcad640e229753880246b7ec38ea"}]}