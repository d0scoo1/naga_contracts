{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\",\r\n          \"stackAllocation\": true\r\n        }\r\n      },\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Pytheas.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\r\\nimport \\\"./interfaces/IERC721TokenReciever.sol\\\";\\r\\nimport \\\"./interfaces/IPytheas.sol\\\";\\r\\nimport \\\"./interfaces/IOrbitalBlockade.sol\\\";\\r\\nimport \\\"./interfaces/IShatteredEON.sol\\\";\\r\\nimport \\\"./interfaces/IMasterStaker.sol\\\";\\r\\nimport \\\"./interfaces/IColonist.sol\\\";\\r\\nimport \\\"./interfaces/IRAW.sol\\\";\\r\\nimport \\\"./interfaces/IRandomizer.sol\\\";\\r\\n\\r\\ncontract Pytheas is IPytheas, IERC721TokenReceiver, Pausable {\\r\\n    // struct to store a stake's token, sOwner, and earning values\\r\\n    struct Stake {\\r\\n        uint16 tokenId;\\r\\n        uint80 value;\\r\\n        address sOwner;\\r\\n    }\\r\\n\\r\\n    event ColonistStaked(\\r\\n        address indexed sOwner,\\r\\n        uint256 indexed tokenId,\\r\\n        uint256 value\\r\\n    );\\r\\n    event ColonistClaimed(\\r\\n        uint256 indexed tokenId,\\r\\n        bool indexed unstaked,\\r\\n        uint256 earned\\r\\n    );\\r\\n\\r\\n    event Metamorphosis(address indexed addr, uint256 indexed tokenId);\\r\\n\\r\\n    // reference to the Colonist NFT contract\\r\\n    IColonist public colonistNFT;\\r\\n    // reference to the game logic  contract\\r\\n    IShatteredEON public shattered;\\r\\n    // reference to the masterStaker contract\\r\\n    IMasterStaker public masterStaker;\\r\\n    // reference to orbital blockade to retrieve information on staked pirates\\r\\n    IOrbitalBlockade public orbital;\\r\\n    // reference to the $rEON contract for minting $rEON earnings\\r\\n    IRAW public raw;\\r\\n    // reference to Randomizer\\r\\n    IRandomizer public randomizer;\\r\\n\\r\\n    // maps tokenId to stake\\r\\n    mapping(uint256 => Stake) private pytheas;\\r\\n\\r\\n    // address => used in allowing system communication between contracts\\r\\n    mapping(address => bool) private admins;\\r\\n\\r\\n    // colonist earn 2700 $rEON per day\\r\\n    uint256 public constant DAILY_rEON_RATE = 2700;\\r\\n    // colonist must have 2 days worth of $rEON to unstake or else they're still down in the mines\\r\\n    uint256 public constant MINIMUM_TO_EXIT = 2 days;\\r\\n    // pirates take a 20% tax on all $rEON claimed\\r\\n    uint256 public constant rEON_CLAIM_TAX_PERCENTAGE = 20;\\r\\n    // there will only ever be (roughly) 3.125 billion (half of the total supply) rEON earned through staking;\\r\\n    uint256 public constant MAXIMUM_GLOBAL_rEON = 3125000000;\\r\\n    // colonistStaked\\r\\n    uint256 public numColonistStaked;\\r\\n    // amount of $rEON earned so far\\r\\n    uint256 public totalRawEonEarned;\\r\\n    // the last time $rEON was claimed\\r\\n    uint256 private lastClaimTimestamp;\\r\\n    //allowed to call owner functions\\r\\n    address public auth;\\r\\n\\r\\n    // emergency rescue to allow unstaking without any checks but without $rEON\\r\\n    bool public rescueEnabled;\\r\\n\\r\\n    constructor() {\\r\\n        _pause();\\r\\n        auth = msg.sender;\\r\\n        admins[msg.sender] = true;\\r\\n    }\\r\\n\\r\\n    modifier noCheaters() {\\r\\n        uint256 size = 0;\\r\\n        address acc = msg.sender;\\r\\n        assembly {\\r\\n            size := extcodesize(acc)\\r\\n        }\\r\\n\\r\\n        require(\\r\\n            admins[msg.sender] || (msg.sender == tx.origin && size == 0),\\r\\n            \\\"you're trying to cheat!\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == auth);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /** CRITICAL TO SETUP */\\r\\n    modifier requireContractsSet() {\\r\\n        require(\\r\\n            address(colonistNFT) != address(0) &&\\r\\n                address(raw) != address(0) &&\\r\\n                address(orbital) != address(0) &&\\r\\n                address(shattered) != address(0) &&\\r\\n                address(masterStaker) != address(0) &&\\r\\n                address(randomizer) != address(0),\\r\\n            \\\"Contracts not set\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setContracts(\\r\\n        address _colonistNFT,\\r\\n        address _raw,\\r\\n        address _orbital,\\r\\n        address _shattered,\\r\\n        address _masterStaker,\\r\\n        address _rand\\r\\n    ) external onlyOwner {\\r\\n        colonistNFT = IColonist(_colonistNFT);\\r\\n        raw = IRAW(_raw);\\r\\n        orbital = IOrbitalBlockade(_orbital);\\r\\n        shattered = IShatteredEON(_shattered);\\r\\n        masterStaker = IMasterStaker(_masterStaker);\\r\\n        randomizer = IRandomizer(_rand);\\r\\n    }\\r\\n\\r\\n    /** STAKING */\\r\\n\\r\\n    /**\\r\\n     * adds Colonists to pytheas and crew\\r\\n     * @param account the address of the staker\\r\\n     * @param tokenIds the IDs of the Colonists to stake\\r\\n     */\\r\\n    function addColonistToPytheas(address account, uint16[] calldata tokenIds)\\r\\n        external\\r\\n        override\\r\\n        whenNotPaused\\r\\n        noCheaters\\r\\n    {\\r\\n        require(account == tx.origin);\\r\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\r\\n            if (msg.sender == address(masterStaker)) {\\r\\n                require(\\r\\n                    colonistNFT.isOwner(tokenIds[i]) == account,\\r\\n                    \\\"Not Colonist Owner\\\"\\r\\n                );\\r\\n                colonistNFT.transferFrom(account, address(this), tokenIds[i]);\\r\\n            } else if (msg.sender != address(shattered)) {\\r\\n                // dont do this step if its a mint + stake\\r\\n                require(\\r\\n                    colonistNFT.isOwner(tokenIds[i]) == msg.sender,\\r\\n                    \\\"Not Colonist Owner\\\"\\r\\n                );\\r\\n                colonistNFT.transferFrom(\\r\\n                    msg.sender,\\r\\n                    address(this),\\r\\n                    tokenIds[i]\\r\\n                );\\r\\n            } else if (tokenIds[i] == 0) {\\r\\n                continue; // there may be gaps in the array for stolen tokens\\r\\n            }\\r\\n            _addColonistToPytheas(account, tokenIds[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * adds a single Colonist to pytheas\\r\\n     * @param account the address of the staker\\r\\n     * @param tokenId the ID of the Colonist to add to pytheas\\r\\n     */\\r\\n    function _addColonistToPytheas(address account, uint256 tokenId)\\r\\n        internal\\r\\n        _updateEarnings\\r\\n    {\\r\\n        pytheas[tokenId] = Stake({\\r\\n            sOwner: account,\\r\\n            tokenId: uint16(tokenId),\\r\\n            value: uint80(block.timestamp)\\r\\n        });\\r\\n        numColonistStaked += 1;\\r\\n        emit ColonistStaked(account, tokenId, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /** CLAIMING / UNSTAKING */\\r\\n\\r\\n    /**\\r\\n     * realize $rEON earnings and optionally unstake tokens from Pytheas / Crew\\r\\n     * to unstake a Colonist it will require it has 2 days worth of $rEON unclaimed\\r\\n     * @param tokenIds the IDs of the tokens to claim earnings from\\r\\n     * @param unstake whether or not to unstake ALL of the tokens listed in tokenIds\\r\\n     */\\r\\n    function claimColonistFromPytheas(\\r\\n        address account,\\r\\n        uint16[] calldata tokenIds,\\r\\n        bool unstake\\r\\n    ) external whenNotPaused _updateEarnings noCheaters {\\r\\n        uint256 owed = 0;\\r\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\r\\n            owed += _claimColonistFromPytheas(account, tokenIds[i], unstake);\\r\\n        }\\r\\n        if (owed == 0) {\\r\\n            return;\\r\\n        }\\r\\n        raw.mint(1, owed, account);\\r\\n    }\\r\\n\\r\\n    /** external function to see the amount of raw eon\\r\\n  a colonist has mined\\r\\n  */\\r\\n\\r\\n    function calculateRewards(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 owed)\\r\\n    {\\r\\n        Stake memory stake = pytheas[tokenId];\\r\\n        if (totalRawEonEarned < MAXIMUM_GLOBAL_rEON) {\\r\\n            owed = ((block.timestamp - stake.value) * DAILY_rEON_RATE) / 1 days;\\r\\n        } else if (stake.value > lastClaimTimestamp) {\\r\\n            owed = 0; // $rEON production stopped already\\r\\n        } else {\\r\\n            owed =\\r\\n                ((lastClaimTimestamp - stake.value) * DAILY_rEON_RATE) /\\r\\n                1 days; // stop earning additional $rEON if it's all been earned\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * realize $rEON earnings for a single Colonist and optionally unstake it\\r\\n     * if not unstaking, pay a 20% tax to the staked Pirates\\r\\n     * if unstaking, there is a 50% chance all $rEON is stolen\\r\\n     * @param tokenId the ID of the Colonist to claim earnings from\\r\\n     * @param unstake whether or not to unstake the Colonist\\r\\n     * @return owed - the amount of $rEON earned\\r\\n     */\\r\\n    function _claimColonistFromPytheas(\\r\\n        address account,\\r\\n        uint256 tokenId,\\r\\n        bool unstake\\r\\n    ) internal returns (uint256 owed) {\\r\\n        Stake memory stake = pytheas[tokenId];\\r\\n        require(stake.sOwner == account, \\\"Not Owner\\\");\\r\\n        require(\\r\\n            !(unstake && block.timestamp - stake.value < MINIMUM_TO_EXIT),\\r\\n            \\\"Your shift isn't over!\\\"\\r\\n        );\\r\\n        if (totalRawEonEarned < MAXIMUM_GLOBAL_rEON) {\\r\\n            owed = ((block.timestamp - stake.value) * DAILY_rEON_RATE) / 1 days;\\r\\n        } else if (stake.value > lastClaimTimestamp) {\\r\\n            owed = 0; // $rEON production stopped already\\r\\n        } else {\\r\\n            owed =\\r\\n                ((lastClaimTimestamp - stake.value) * DAILY_rEON_RATE) /\\r\\n                1 days; // stop earning additional $rEON if it's all been earned\\r\\n        }\\r\\n        if (unstake) {\\r\\n            if (randomizer.random(tokenId) & 1 == 1) {\\r\\n                // 50% chance of all $rEON stolen\\r\\n                orbital.payPirateTax(owed);\\r\\n                owed = 0;\\r\\n            }\\r\\n            delete pytheas[tokenId];\\r\\n            numColonistStaked -= 1;\\r\\n            // Always transfer last to guard against reentrance\\r\\n            colonistNFT.safeTransferFrom(address(this), account, tokenId, \\\"\\\"); // send back colonist\\r\\n        } else {\\r\\n            orbital.payPirateTax((owed * rEON_CLAIM_TAX_PERCENTAGE) / 100); // percentage tax to staked pirates\\r\\n            owed = (owed * (100 - rEON_CLAIM_TAX_PERCENTAGE)) / 100; // remainder goes to Colonist sOwner\\r\\n            pytheas[tokenId] = Stake({\\r\\n                sOwner: account,\\r\\n                tokenId: uint16(tokenId),\\r\\n                value: uint80(block.timestamp)\\r\\n            }); // reset stake\\r\\n        }\\r\\n        emit ColonistClaimed(tokenId, unstake, owed);\\r\\n    }\\r\\n\\r\\n    // To be worthy of joining the pirates one must be\\r\\n    // willing to risk it all, used to handle the colonist\\r\\n    // token burn when making an attempt to join the pirates\\r\\n    function handleJoinPirates(address addr, uint16 tokenId)\\r\\n        external\\r\\n        override\\r\\n        noCheaters\\r\\n    {\\r\\n        require(admins[msg.sender]);\\r\\n        Stake memory stake = pytheas[tokenId];\\r\\n        require(stake.sOwner == addr, \\\"Pytheas: Not Owner\\\");\\r\\n        delete pytheas[tokenId];\\r\\n        colonistNFT.burn(tokenId);\\r\\n\\r\\n        emit Metamorphosis(addr, tokenId);\\r\\n    }\\r\\n\\r\\n    function payUp(\\r\\n        uint16 tokenId,\\r\\n        uint256 amtMined,\\r\\n        address addr\\r\\n    ) external override _updateEarnings {\\r\\n        require(admins[msg.sender]);\\r\\n        uint256 minusTax = 0;\\r\\n        minusTax += _piratesLife(tokenId, amtMined, addr);\\r\\n        if (minusTax == 0) {\\r\\n            return;\\r\\n        }\\r\\n        raw.mint(1, minusTax, addr);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n   * external admin only function to get the amount owed to a colonist\\r\\n   * for use whem making a pirate attempt\\r\\n   @param account the account that owns the colonist\\r\\n   @param tokenId  the ID of the colonist who is mining\\r\\n    */\\r\\n    function getColonistMined(address account, uint16 tokenId)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256 minedAmt)\\r\\n    {\\r\\n        require(admins[msg.sender]);\\r\\n        uint256 mined = 0;\\r\\n        mined += colonistDues(account, tokenId);\\r\\n        return mined;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n * internal function to calculate the amount a colonist\\r\\n * is owed for their mining attempts;\\r\\n * for use with making a pirate attempt;\\r\\n @param addr the owner of the colonist\\r\\n @param tokenId the ID of the colonist who is mining\\r\\n  */\\r\\n    function colonistDues(address addr, uint16 tokenId)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256 mined)\\r\\n    {\\r\\n        Stake memory stake = pytheas[tokenId];\\r\\n        require(stake.sOwner == addr, \\\"Not Owner\\\");\\r\\n        if (totalRawEonEarned < MAXIMUM_GLOBAL_rEON) {\\r\\n            mined =\\r\\n                ((block.timestamp - stake.value) * DAILY_rEON_RATE) /\\r\\n                1 days;\\r\\n        } else if (stake.value > lastClaimTimestamp) {\\r\\n            mined = 0; // $rEON production stopped already\\r\\n        } else {\\r\\n            mined =\\r\\n                ((lastClaimTimestamp - stake.value) * DAILY_rEON_RATE) /\\r\\n                1 days; // stop earning additional $rEON if it's all been earned\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\nRealizes gained rEON on a failed pirate attempt and always pays pirate tax\\r\\n*/\\r\\n    function _piratesLife(\\r\\n        uint16 tokenId,\\r\\n        uint256 amtMined,\\r\\n        address addr\\r\\n    ) internal returns (uint256 owed) {\\r\\n        Stake memory stake = pytheas[tokenId];\\r\\n        require(stake.sOwner == addr, \\\"Pytheas: Not Owner\\\");\\r\\n        // tax amount sent to pirates\\r\\n        uint256 pirateTax = (amtMined * rEON_CLAIM_TAX_PERCENTAGE) / 100;\\r\\n        orbital.payPirateTax(pirateTax);\\r\\n        // remainder after pirate tax goes to Colonist\\r\\n        //sOwner who made the pirate attempt\\r\\n        owed = (amtMined - pirateTax);\\r\\n        // reset stake\\r\\n        pytheas[tokenId] = Stake({\\r\\n            sOwner: addr,\\r\\n            tokenId: uint16(tokenId),\\r\\n            value: uint80(block.timestamp)\\r\\n        });\\r\\n        emit ColonistClaimed(tokenId, false, owed);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * emergency unstake tokens\\r\\n     * @param tokenIds the IDs of the tokens to claim earnings from\\r\\n     */\\r\\n    function rescue(uint256[] calldata tokenIds) external noCheaters {\\r\\n        require(rescueEnabled, \\\"Rescue Not Enabled\\\");\\r\\n        uint256 tokenId;\\r\\n        Stake memory stake;\\r\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\r\\n            tokenId = tokenIds[i];\\r\\n            stake = pytheas[tokenId];\\r\\n            require(stake.sOwner == msg.sender, \\\"Not Owner\\\");\\r\\n            delete pytheas[tokenId];\\r\\n            numColonistStaked -= 1;\\r\\n            colonistNFT.safeTransferFrom(\\r\\n                address(this),\\r\\n                msg.sender,\\r\\n                tokenId,\\r\\n                \\\"\\\"\\r\\n            ); // send back Colonist\\r\\n            emit ColonistClaimed(tokenId, true, 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** ACCOUNTING */\\r\\n\\r\\n    /**\\r\\n     * tracks $rEON earnings to ensure it stops once 6.5 billion is eclipsed\\r\\n     */\\r\\n    modifier _updateEarnings() {\\r\\n        if (totalRawEonEarned < MAXIMUM_GLOBAL_rEON) {\\r\\n            totalRawEonEarned +=\\r\\n                ((block.timestamp - lastClaimTimestamp) *\\r\\n                    numColonistStaked *\\r\\n                    DAILY_rEON_RATE) /\\r\\n                1 days;\\r\\n            lastClaimTimestamp = block.timestamp;\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    //Admin\\r\\n    /**\\r\\n     * allows owner to enable \\\"rescue mode\\\"\\r\\n     * simplifies accounting, prioritizes tokens out in emergency\\r\\n     */\\r\\n    function setRescueEnabled(bool _enabled) external onlyOwner {\\r\\n        rescueEnabled = _enabled;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * enables owner to pause / unpause contract\\r\\n     */\\r\\n    function setPaused(bool _paused) external requireContractsSet onlyOwner {\\r\\n        if (_paused) _pause();\\r\\n        else _unpause();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * enables an address to mint / burn\\r\\n     * @param addr the address to enable\\r\\n     */\\r\\n    function addAdmin(address addr) external onlyOwner {\\r\\n        admins[addr] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * disables an address from minting / burning\\r\\n     * @param addr the address to disbale\\r\\n     */\\r\\n    function removeAdmin(address addr) external onlyOwner {\\r\\n        admins[addr] = false;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) external onlyOwner {\\r\\n        auth = newOwner;\\r\\n    }\\r\\n\\r\\n    //READ ONLY\\r\\n\\r\\n    function onERC721Received(\\r\\n        address,\\r\\n        address from,\\r\\n        uint256,\\r\\n        bytes calldata\\r\\n    ) external pure override returns (bytes4) {\\r\\n        require(from == address(0x0), \\\"Only EOA\\\");\\r\\n        return IERC721TokenReceiver.onERC721Received.selector;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IColonist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IColonist {\\r\\n    // struct to store each Colonist's traits\\r\\n    struct Colonist {\\r\\n        bool isColonist;\\r\\n        uint8 background;\\r\\n        uint8 body;\\r\\n        uint8 shirt;\\r\\n        uint8 jacket;\\r\\n        uint8 jaw;\\r\\n        uint8 eyes;\\r\\n        uint8 hair;\\r\\n        uint8 held;\\r\\n        uint8 gen;\\r\\n    }\\r\\n\\r\\n    struct HColonist {\\r\\n        uint8 Legendary;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function isOwner(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function minted() external returns (uint16);\\r\\n\\r\\n    function totalCir() external returns (uint256);\\r\\n\\r\\n    function _mintColonist(address recipient, uint256 seed) external;\\r\\n\\r\\n    function _mintToHonors(address recipient, uint256 seed) external;\\r\\n\\r\\n    function _mintHonors(address recipient, uint8 id) external;\\r\\n\\r\\n    function burn(uint256 tokenId) external;\\r\\n\\r\\n    function getMaxTokens() external view returns (uint256);\\r\\n\\r\\n    function getPaidTokens() external view returns (uint256);\\r\\n\\r\\n    function getTokenTraitsColonist(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (Colonist memory);\\r\\n\\r\\n    function getTokenTraitsHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (HColonist memory);\\r\\n\\r\\n    function tokenNameByIndex(uint256 index)\\r\\n        external\\r\\n        view\\r\\n        returns (string memory);\\r\\n\\r\\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\\r\\n\\r\\n    function nameColonist(uint256 tokenId, string memory newName) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721TokenReciever.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\npragma solidity ^0.8.11;\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\ninterface IERC721TokenReceiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMasterStaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\npragma solidity ^0.8.0;\\n\\ninterface IMasterStaker {\\n\\n function masterStake(\\n        uint16[] calldata colonistTokenIds,\\n        uint16[] calldata pirateTokenIds\\n    ) external;\\n\\n function masterUnstake(\\n        uint16[] calldata colonistTokenIds,\\n        uint16[] calldata pirateTokenIds\\n    ) external;\\n\\n function masterClaim(\\n        uint16[] calldata colonistTokenIds,\\n        uint16[] calldata pirateTokenIds\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IOrbitalBlockade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.0;\\n\\ninterface IOrbitalBlockade {\\n    function addPiratesToCrew(address account, uint16[] calldata tokenIds)\\n        external;\\n    \\n    function claimPiratesFromCrew(address account, uint16[] calldata tokenIds, bool unstake)\\n        external;\\n\\n    function payPirateTax(uint256 amount) external;\\n\\n    function randomPirateOwner(uint256 seed) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPytheas.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPytheas {\\r\\n    function addColonistToPytheas(address account, uint16[] calldata tokenIds)\\r\\n        external;\\r\\n\\r\\n    function claimColonistFromPytheas(address account, uint16[] calldata tokenIds, bool unstake)\\r\\n        external;\\r\\n\\r\\n    function getColonistMined(address account, uint16 tokenId)\\r\\n        external\\r\\n        returns (uint256);\\r\\n\\r\\n    function handleJoinPirates(address addr, uint16 tokenId) external;\\r\\n\\r\\n    function payUp(\\r\\n        uint16 tokenId,\\r\\n        uint256 amtMined,\\r\\n        address addr\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IRAW.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IRAW {\\r\\n\\r\\n    function getBalance(\\r\\n        address account,\\r\\n        uint256 id\\r\\n    ) external returns(uint256);\\r\\n\\r\\n    function mint(\\r\\n        uint256 typeId,\\r\\n        uint256 qty,\\r\\n        address recipient\\r\\n    ) external;\\r\\n\\r\\n    function burn(\\r\\n        uint256 typeId,\\r\\n        uint256 qty,\\r\\n        address burnFrom\\r\\n    ) external;\\r\\n\\r\\n    function updateMintBurns(\\r\\n        uint256 typeId,\\r\\n        uint256 mintQty,\\r\\n        uint256 burnQty\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IRandomizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IRandomizer {\\r\\n    function random(uint256) external returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IShatteredEON.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IShatteredEON {}\\r\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"}],\"name\":\"ColonistClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ColonistStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Metamorphosis\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAILY_rEON_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_GLOBAL_rEON\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_TO_EXIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"}],\"name\":\"addColonistToPytheas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"calculateRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"owed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"},{\"internalType\":\"bool\",\"name\":\"unstake\",\"type\":\"bool\"}],\"name\":\"claimColonistFromPytheas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"colonistNFT\",\"outputs\":[{\"internalType\":\"contract IColonist\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"getColonistMined\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minedAmt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"}],\"name\":\"handleJoinPirates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterStaker\",\"outputs\":[{\"internalType\":\"contract IMasterStaker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numColonistStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orbital\",\"outputs\":[{\"internalType\":\"contract IOrbitalBlockade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amtMined\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"payUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rEON_CLAIM_TAX_PERCENTAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomizer\",\"outputs\":[{\"internalType\":\"contract IRandomizer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raw\",\"outputs\":[{\"internalType\":\"contract IRAW\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_colonistNFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_raw\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_orbital\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_shattered\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_masterStaker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rand\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setRescueEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shattered\",\"outputs\":[{\"internalType\":\"contract IShatteredEON\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRawEonEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Pytheas", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}