{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Registry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interface/Iregistry.sol\\\";\\nimport \\\"./interface/Isettings.sol\\\";\\nimport \\\"./interface/Ibridge.sol\\\";\\nimport \\\"./interface/Icontroller.sol\\\";\\nimport \\\"./interface/IERCOwnable.sol\\\";\\n\\n\\ncontract  Registry is Ownable {\\n    struct Transaction{\\n       uint256 chainId;\\n       address assetAddress;\\n       uint256 amount;\\n       address receiver;\\n       uint256 nounce;\\n       bool  isCompleted;\\n   }\\n   struct validation {\\n       uint256 validationCount;\\n       bool validated;\\n   }\\n   enum transactionType {send , burn , mint ,claim}\\n\\n   mapping (address => uint256) public assetTotalTransactionCount;\\n   mapping (address => mapping( uint256 => uint256 )) public assetTransactionTypeCount;\\n   mapping(address => mapping( uint256 => uint256 )) public assetChainBalance;\\n   mapping(address => uint256) public getUserNonce; \\n   mapping (bytes32 => bool)  public isSendTransaction;\\n   mapping (bytes32 => Transaction)  public sendTransactions;\\n   mapping (bytes32 => bool)  public isClaimTransaction;\\n   mapping (bytes32 => Transaction)  public claimTransactions;\\n   mapping(bytes32 => Transaction) public mintTransactions;\\n   mapping(bytes32 => bool) public isMintTransaction;\\n   mapping(bytes32 => Transaction) public burnTransactions;\\n   mapping(bytes32 => bool) public isburnTransaction;\\n   mapping(bytes32 => validation ) public transactionValidations;\\n   mapping(bytes32 => address[] ) public TransactionValidators;\\n   mapping(bytes32 => mapping(address => bool)) public hasValidatedTransaction;\\n   uint256 public totalTransactions;\\n\\n   event TransactionValidated(bytes32 indexed transactionID);\\n   event SendTransactionCompleted(bytes32 indexed transactionID);\\n   event BurnTransactionCompleted(bytes32 indexed transactionID);\\n   event MintTransactionCompleted(bytes32 indexed transactionID);\\n   event ClaimTransactionCompleted(bytes32 indexed transactionID);\\n\\n   constructor(){}\\n  \\n\\n  function completeSendTransaction(bytes32 transactionID) external {\\n      require(isSendTransaction[transactionID] ,\\\"invalid Transaction\\\");\\n      emit SendTransactionCompleted(transactionID);\\n      sendTransactions[transactionID].isCompleted = true;\\n  }\\n\\n\\n  function completeBurnTransaction(bytes32 transactionID) external {\\n       require(isburnTransaction[transactionID] ,\\\"invalid Transaction\\\");\\n       emit BurnTransactionCompleted(transactionID);\\n       burnTransactions[transactionID].isCompleted = true ;\\n  }\\n\\n\\n  function completeMintTransaction(bytes32 transactionID) external {\\n       require(isMintTransaction[transactionID] ,\\\"invalid Transaction\\\");\\n       emit MintTransactionCompleted(transactionID);\\n       mintTransactions[transactionID].isCompleted = true;\\n  }\\n\\n\\n  function completeClaimTransaction(bytes32 transactionID) external {\\n      require(isClaimTransaction[transactionID] ,\\\"invalid Transaction\\\");\\n      emit ClaimTransactionCompleted(transactionID);\\n      assetChainBalance[claimTransactions[transactionID].assetAddress][claimTransactions[transactionID].chainId] -= convertToAssetDecimals(claimTransactions[transactionID].amount,claimTransactions[transactionID].assetAddress) ;\\n       claimTransactions[transactionID].isCompleted = true;\\n  }\\n\\n\\n   \\n\\n\\n  function registerTransaction(\\n       uint256 chainTo,\\n       address assetAddress,\\n       uint256 amount,\\n       address receiver,\\n       transactionType _transactionType\\n  ) \\n        public \\n        onlyOwner \\n        returns (bytes32 transactionID ,uint256 nounce ) \\n  {\\n      if (_transactionType  == transactionType.send) {\\n\\n           nounce = getUserNonce[receiver];\\n            transactionID =  keccak256(abi.encodePacked(\\n                getChainId(),\\n                chainTo,\\n                assetAddress ,\\n                amount,\\n                receiver,\\n                nounce \\n            ));\\n      \\n          sendTransactions[transactionID] = Transaction(chainTo , assetAddress ,amount , receiver ,nounce, false);\\n          isSendTransaction[transactionID] = true;\\n          getUserNonce[receiver]++;\\n          assetChainBalance[assetAddress][chainTo] += convertToAssetDecimals(amount, assetAddress);\\n          \\n      } else if (_transactionType  == transactionType.burn) {\\n          nounce = getUserNonce[receiver];\\n            transactionID =  keccak256(abi.encodePacked(\\n                getChainId(),\\n                chainTo,\\n                assetAddress ,\\n                amount,\\n                receiver,\\n                nounce \\n            ));\\n      \\n          burnTransactions[transactionID] = Transaction(chainTo , assetAddress ,amount , receiver ,nounce, false);\\n          isburnTransaction[transactionID] = true;\\n          getUserNonce[receiver]++;\\n      }\\n      assetTotalTransactionCount[assetAddress]++;\\n      totalTransactions++;\\n\\n      \\n  }\\n  \\n  \\n  function _registerTransaction(\\n       bytes32 transactionID,\\n       uint256 chainId,\\n       address assetAddress,\\n       uint256 amount,\\n       address receiver,\\n       uint256 nounce,\\n       transactionType _transactionType\\n  ) \\n      internal\\n  {\\n      if (_transactionType  == transactionType.mint) {\\n          mintTransactions[transactionID] = Transaction(chainId , assetAddress ,amount , receiver ,nounce, false);\\n          isMintTransaction[transactionID] = true;\\n      } else if (_transactionType  == transactionType.claim) {\\n          claimTransactions[transactionID] = Transaction(chainId , assetAddress ,amount , receiver ,nounce, false);\\n          isClaimTransaction[transactionID] = true;\\n      }\\n  }\\n  \\n  \\n  function registerClaimTransaction(\\n      bytes32 claimID,\\n      uint256 chainFrom,\\n      address assetAddress,\\n      uint256 amount,\\n      address receiver,\\n      uint256 nounce\\n    ) \\n      external \\n    {\\n        require(IController(Ibridge(owner()).controller()).isOracle(msg.sender),\\\"U_A\\\");\\n        require(!isClaimTransaction[claimID], \\\"registerred\\\");\\n        require(Ibridge(owner()).isAssetSupportedChain(assetAddress ,chainFrom), \\\"chain_err\\\");\\n        bytes32 requiredClaimID = keccak256(abi.encodePacked(\\n            chainFrom,\\n            getChainId(),\\n            assetAddress,\\n            amount,\\n            receiver,\\n            nounce\\n            ));\\n\\n        require(claimID  == requiredClaimID , \\\"claimid_err\\\");\\n        _registerTransaction(claimID ,chainFrom , assetAddress, amount , receiver ,nounce, transactionType.claim );\\n   }\\n\\n\\n   function registerMintTransaction(\\n       bytes32 mintID,\\n       uint256 chainFrom,\\n       address assetAddress,\\n       uint256 amount,\\n       address receiver,\\n       uint256 nounce\\n    ) \\n       external \\n    {\\n        require(IController(Ibridge(owner()).controller()).isOracle(msg.sender),\\\"U_A\\\");\\n        require(!isMintTransaction[mintID], \\\"registerred\\\");\\n        Ibridge  bridge = Ibridge(owner());\\n        address wrappedAddress = bridge.wrappedForiegnPair(assetAddress ,chainFrom);\\n        require(wrappedAddress != address(0), \\\"I_A\\\");\\n        if(!bridge.isDirectSwap(assetAddress , chainFrom)){\\n            Ibridge.asset memory  foriegnAsset = bridge.foriegnAssets(wrappedAddress);\\n            require(foriegnAsset.isSet , \\\"asset_err\\\");\\n            require(bridge.foriegnAssetChainID(wrappedAddress) == chainFrom , \\\"chain_err\\\");\\n        }\\n        \\n        bytes32 requiredmintID = keccak256(abi.encodePacked(\\n            chainFrom,\\n            bridge.chainId(),\\n            assetAddress,\\n            amount,\\n            receiver,\\n            nounce\\n            ));\\n        require(mintID  == requiredmintID, \\\"mint: error validation mint ID\\\");\\n        _registerTransaction(mintID ,chainFrom , wrappedAddress, amount , receiver ,nounce, transactionType.mint);\\n   }\\n\\n\\n     function convertToAssetDecimals(uint256 amount  ,address assetAddress  ) internal view returns (uint256) {\\n         uint256 decimals;\\n        if (assetAddress == address(0)){\\n            decimals =  Ibridge(owner()).standardDecimals();\\n        }else {\\n         decimals = IERCOwnable(assetAddress).decimals();\\n        }\\n       return amount / (10**(Ibridge(owner()).standardDecimals() - decimals));\\n    }\\n   function validateTransaction(bytes32 transactionId , bytes[] memory signatures ,bool mintable) external  {\\n       require(IController(Ibridge(owner()).controller()).isValidator(msg.sender) , \\\"U_A\\\");\\n       require(Isettings(Ibridge(owner()).settings()).minValidations() != 0 , \\\"minvalidator_err\\\");\\n       Transaction memory transaction;\\n       if (mintable) {\\n           require(isMintTransaction[transactionId] , \\\"mintID_err\\\"); \\n           transaction =  mintTransactions[transactionId];\\n           if(!Ibridge(owner()).isDirectSwap(transaction.assetAddress , transaction.chainId)){\\n               (,uint256 max) =  Ibridge(owner()).assetLimits(transaction.assetAddress, false);\\n               require(convertToAssetDecimals(transaction.amount,transaction.assetAddress ) <= max , \\\"Amount_limit_Err\\\");\\n           }\\n        } else {\\n            require(isClaimTransaction[transactionId] , \\\"caimID_err\\\"); \\n            transaction =  claimTransactions[transactionId]; \\n            (,uint256 max) =  Ibridge(owner()).assetLimits(transaction.assetAddress , true);\\n            require(convertToAssetDecimals(transaction.amount,transaction.assetAddress ) <= max && convertToAssetDecimals(transaction.amount,transaction.assetAddress ) <= assetChainBalance[transaction.assetAddress][transaction.chainId]   , \\\"Amount_limit_Err\\\");\\n        }\\n       require(!transaction.isCompleted, \\\"completed\\\");\\n       uint256 validSignatures;\\n       for (uint256 i ; i < signatures.length; i++)  {\\n          address signer = getSigner(getChainId() ,transaction.chainId , transaction.assetAddress , transaction.amount , transaction.receiver , transaction.nounce , signatures[i]);\\n           if (IController(Ibridge(owner()).controller()).isValidator(signer) && !hasValidatedTransaction[transactionId][signer]) {\\n               validSignatures = validSignatures + 1;\\n               TransactionValidators[transactionId].push(signer);\\n               hasValidatedTransaction[transactionId][signer] = true;\\n           }\\n       }\\n       \\n       require(validSignatures >= Isettings(Ibridge(owner()).settings()).minValidations() ,\\\"insuficient_signers\\\");\\n       transactionValidations[transactionId].validationCount = validSignatures; \\n       transactionValidations[transactionId].validated  = true;\\n        emit TransactionValidated(transactionId);\\n       if (mintable) {\\n           Ibridge(owner()).mint(transactionId);\\n       } else {\\n           Ibridge(owner()).claim(transactionId);\\n       }\\n      \\n   }\\n\\n\\n   function getEthSignedMessageHash(\\n       uint256 chainID,\\n       uint256 interfacingChainId,\\n       address assetAddress,\\n       uint256 amount,\\n       address receiver,\\n       uint256 nounce\\n    )\\n       public\\n       pure\\n       returns (bytes32) \\n    {\\n        return keccak256(abi.encodePacked(\\n            \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n            keccak256(abi.encodePacked(\\n                chainID,\\n                interfacingChainId,\\n                assetAddress,\\n                amount,\\n                receiver,\\n                nounce\\n            ))));\\n    }\\n    \\n    \\n    function getSigner(\\n        uint256 chainID,\\n        uint256 interfacingChainId,\\n        address assetAddress,\\n        uint256 amount,\\n        address receiver,\\n        uint256 nounce,\\n        bytes memory signature\\n    ) \\n        public \\n        pure \\n        returns (address) \\n    {\\n        bytes32 ethSignedMessageHash =  getEthSignedMessageHash(\\n            chainID,\\n            interfacingChainId,\\n            assetAddress, amount, receiver, nounce);\\n        return recoverSigner(ethSignedMessageHash, signature);\\n    }\\n\\n\\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)\\n        public\\n        pure\\n        returns (address)\\n    {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\n    }\\n\\n\\n    function splitSignature(bytes memory sig)\\n        public\\n        pure\\n        returns (\\n            bytes32 r,\\n            bytes32 s,\\n            uint8 v\\n        )\\n    {\\n        require(sig.length == 65, \\\"invalid signature length\\\");\\n\\n        assembly {\\n            /*\\n            First 32 bytes stores the length of the signature\\n\\n            add(sig, 32) = pointer of sig + 32\\n            effectively, skips first 32 bytes of signature\\n\\n            mload(p) loads next 32 bytes starting at the memory address p into memory\\n            */\\n\\n            // first 32 bytes, after the length prefix\\n            r := mload(add(sig, 32))\\n            // second 32 bytes\\n            s := mload(add(sig, 64))\\n            // final byte (first byte of the next 32 bytes)\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n    }\\n\\n    function transactionValidated(bytes32 transactionID) external  view returns (bool) {\\n      return transactionValidations[transactionID].validated;\\n  }\\n  function getChainId() internal view returns(uint256 id){\\n        assembly {\\n        id := chainid()\\n        }\\n    }\\n   function getID(\\n       uint256 chainFrom,\\n       uint256 chainTo,\\n       address assetAddress,\\n       uint256 amount,\\n       address receiver,\\n       uint256 nounce\\n   )\\n       public\\n       pure\\n       returns (bytes32)  \\n  {\\n       return  keccak256(abi.encodePacked(chainFrom, chainTo , assetAddress , amount, receiver, nounce));\\n  }\\n\\n}\\n\\n  \\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/Iregistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\ninterface IRegistery {\\n    struct Transaction{\\n            uint256 chainId;\\n            address assetAddress;\\n            uint256 amount;\\n            address receiver;\\n            uint256 nounce;\\n            bool  isCompleted;\\n        }\\n\\n    function getUserNonce(address user) external returns (uint256);\\n    function isSendTransaction(bytes32 transactionID) external returns (bool);\\n    function isClaimTransaction(bytes32 transactionID) external returns (bool);\\n    function isMintTransaction(bytes32 transactionID) external returns (bool);\\n    function isburnTransactio(bytes32 transactionID) external returns (bool);\\n    function transactionValidated(bytes32 transactionID) external returns (bool);\\n    function assetChainBalance(address asset, uint256 chainid) external returns (uint256);\\n\\n    function sendTransactions(bytes32 transactionID) external returns (Transaction memory);\\n    function claimTransactions(bytes32 transactionID) external returns (Transaction memory);\\n    function burnTransactions(bytes32 transactionID) external returns (Transaction memory);\\n    function mintTransactions(bytes32 transactionID) external returns (Transaction memory);\\n    \\n    function completeSendTransaction(bytes32 transactionID) external;\\n    function completeBurnTransaction(bytes32 transactionID) external;\\n    function completeMintTransaction(bytes32 transactionID) external;\\n    function completeClaimTransaction(bytes32 transactionID) external;\\n    function transferOwnership(address newOwner) external;\\n    \\n  \\n    \\n      function registerTransaction(\\n       uint256 chainTo,\\n       address assetAddress,\\n       uint256 amount,\\n       address receiver,\\n       uint8 _transactionType\\n        ) \\n        external  \\n        returns (bytes32 transactionID ,uint256 _nounce );\\n     \\n}\"\r\n    },\r\n    \"contracts/interface/Isettings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\ninterface Isettings {\\n\\n    function networkFee(uint256 chainId) external view returns (uint256);\\n\\n    function minValidations() external view returns (uint256);\\n    \\n    function isNetworkSupportedChain(uint256 chainID) external view returns (bool);\\n\\n    function feeRemitance() external view returns (address);\\n\\n    function railRegistrationFee() external view returns (uint256);\\n\\n    function railOwnerFeeShare() external view returns (uint256);\\n\\n    function onlyOwnableRail() external view returns (bool);\\n\\n    function updatableAssetState() external view returns (bool);\\n\\n    function minWithdrawableFee() external view returns (uint256);\\n\\n    function brgToken() external view returns (address);\\n\\n    function getNetworkSupportedChains() external view returns(uint256[] memory);\\n    \\n    function baseFeePercentage() external view returns(uint256);\\n\\n    function baseFeeEnable() external view returns(bool);\\n\\n    function approvedToAdd(address token , address user) external view returns(bool);\\n}\\n\\n\"\r\n    },\r\n    \"contracts/interface/Ibridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.0;\\n\\n\\ninterface Ibridge{\\n    struct asset {\\n        address tokenAddress; \\n        uint256 minAmount;\\n        uint256 maxAmount;\\n        uint256 feeBalance;\\n        uint256 collectedFees;\\n        bool ownedRail;\\n        address manager;\\n        address feeRemitance;\\n        uint256 balance;\\n        bool isSet;\\n     }\\n\\n\\n    function isAssetSupportedChain(address assetAddress , uint256 chainID) external view returns (bool);\\n\\n\\n    function controller() external view returns (address);\\n\\n\\n    function claim(bytes32 transaction_id) external;\\n\\n\\n    function mint(bytes32 transaction_id) external ;\\n\\n\\n    function settings() external view returns (address); \\n\\n\\n    function chainId() external view returns (uint256);\\n\\n\\n    function foriegnAssetChainID(address _asset) external view returns (uint256);\\n\\n    function standardDecimals() external view returns (uint256);\\n\\n\\n    function assetLimits(address _asset, bool native) external view returns (uint256 , uint256);\\n\\n\\n    function foriegnAssets(address assetAddress) external view returns (asset memory);\\n\\n\\n    function wrappedForiegnPair(address assetAddress , uint256 chainID) external view returns (address);\\n\\n    function udpadateBridgePool(address _bridgePool) external;\\n\\n    function isDirectSwap(address assetAddress ,uint256 chainID) external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interface/Icontroller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\ninterface IController {\\n\\n    function isAdmin(address account) external view returns (bool);\\n\\n\\n    function isRegistrar(address account) external view returns (bool);\\n\\n\\n    function isOracle(address account) external view returns (bool);\\n\\n\\n    function isValidator(address account) external view returns (bool);\\n\\n\\n    function owner() external view returns (address);\\n\\n    \\n    function validatorsCount() external view returns (uint256);\\n\\n    function settings() external view returns (address);\\n\\n\\n    function deployer() external view returns (address);\\n\\n\\n    function feeController() external view returns (address);\\n\\n    \\n}\"\r\n    },\r\n    \"contracts/interface/IERCOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\ninterface IERCOwnable {\\n     function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n    \\n     function owner() external view  returns (address);\\n    }\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionID\",\"type\":\"bytes32\"}],\"name\":\"BurnTransactionCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionID\",\"type\":\"bytes32\"}],\"name\":\"ClaimTransactionCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionID\",\"type\":\"bytes32\"}],\"name\":\"MintTransactionCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionID\",\"type\":\"bytes32\"}],\"name\":\"SendTransactionCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionID\",\"type\":\"bytes32\"}],\"name\":\"TransactionValidated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TransactionValidators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assetChainBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assetTotalTransactionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assetTransactionTypeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"burnTransactions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nounce\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCompleted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"claimTransactions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nounce\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCompleted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionID\",\"type\":\"bytes32\"}],\"name\":\"completeBurnTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionID\",\"type\":\"bytes32\"}],\"name\":\"completeClaimTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionID\",\"type\":\"bytes32\"}],\"name\":\"completeMintTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionID\",\"type\":\"bytes32\"}],\"name\":\"completeSendTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interfacingChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nounce\",\"type\":\"uint256\"}],\"name\":\"getEthSignedMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chainTo\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nounce\",\"type\":\"uint256\"}],\"name\":\"getID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interfacingChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nounce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"getSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getUserNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasValidatedTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isClaimTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isMintTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isSendTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isburnTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"mintTransactions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nounce\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCompleted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_ethSignedMessageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"claimID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"chainFrom\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nounce\",\"type\":\"uint256\"}],\"name\":\"registerClaimTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"mintID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"chainFrom\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nounce\",\"type\":\"uint256\"}],\"name\":\"registerMintTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainTo\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"enum Registry.transactionType\",\"name\":\"_transactionType\",\"type\":\"uint8\"}],\"name\":\"registerTransaction\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nounce\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"sendTransactions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nounce\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isCompleted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"splitSignature\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTransactions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionID\",\"type\":\"bytes32\"}],\"name\":\"transactionValidated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"transactionValidations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"validationCount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"validated\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"},{\"internalType\":\"bool\",\"name\":\"mintable\",\"type\":\"bool\"}],\"name\":\"validateTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Registry", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}