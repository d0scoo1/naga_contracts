{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/bot/EvaFlowChainLinkKeeperBot.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n//Create by Openflow.network core team.\\npragma solidity ^0.8.0;\\n\\nimport \\\"../venders/chainlink/KeeperRegistryInterface.sol\\\";\\nimport \\\"../venders/chainlink/KeeperCompatibleInterface.sol\\\";\\nimport {EvaKeepBotBase} from \\\"../keeper/EvaKeepBotBase.sol\\\";\\nimport {IEvabaseConfig} from \\\"../interfaces/IEvabaseConfig.sol\\\";\\nimport {IEvaFlowChecker} from \\\"../interfaces/IEvaFlowChecker.sol\\\";\\nimport {IEvaFlowController} from \\\"../interfaces/IEvaFlowController.sol\\\";\\nimport {IEvaFlow} from \\\"../interfaces/IEvaFlow.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {KeepNetWork} from \\\"../lib/EvabaseHelper.sol\\\";\\n\\ncontract EvaFlowChainLinkKeeperBot is EvaKeepBotBase, KeeperCompatibleInterface, Ownable {\\n    uint256 public lastMoveTime;\\n\\n    address private immutable _keeperRegistry;\\n\\n    event SetEvaCheck(address indexed evaCheck);\\n\\n    constructor(\\n        address config_,\\n        address evaFlowChecker_,\\n        address keeperRegistry_\\n    ) {\\n        require(config_ != address(0), \\\"addess is 0x\\\");\\n        require(evaFlowChecker_ != address(0), \\\"addess is 0x\\\");\\n        require(keeperRegistry_ != address(0), \\\"addess is 0x\\\");\\n\\n        config = IEvabaseConfig(config_);\\n        evaFlowChecker = IEvaFlowChecker(evaFlowChecker_);\\n        _keeperRegistry = keeperRegistry_;\\n        lastMoveTime = block.timestamp; // solhint-disable\\n    }\\n\\n    function checkUpkeep(bytes calldata checkData)\\n        external\\n        override\\n        returns (bool upkeepNeeded, bytes memory performData)\\n    {\\n        (upkeepNeeded, performData) = _check(checkData);\\n    }\\n\\n    function performUpkeep(bytes calldata performData) external override {\\n        //Removal of pre-execution by chainlink keeper\\n        // solhint-disable avoid-tx-origin\\n        if (tx.origin == address(0)) {\\n            return; // return if call from chainlink keeper\\n        }\\n        _exec(performData);\\n    }\\n\\n    function _check(bytes memory _checkdata) internal override returns (bool needExec, bytes memory execdata) {\\n        uint32 keepBotId = abi.decode(_checkdata, (uint32));\\n        (needExec, execdata) = evaFlowChecker.check(keepBotId, lastMoveTime, KeepNetWork.ChainLink);\\n    }\\n\\n    function _exec(bytes memory execdata) internal override {\\n        require(msg.sender == _keeperRegistry, \\\"only for keeperRegistry\\\");\\n        lastMoveTime = block.timestamp; // solhint-disable\\n        IEvaFlowController(config.control()).batchExecFlow(tx.origin, execdata);\\n    }\\n\\n    function setEvaCheck(IEvaFlowChecker evaFlowChecker_) external onlyOwner {\\n        require(address(evaFlowChecker_) != address(0), \\\"addess is 0x\\\");\\n        evaFlowChecker = evaFlowChecker_;\\n        emit SetEvaCheck(address(evaFlowChecker_));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/venders/chainlink/KeeperRegistryInterface.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n//Create by Openflow.network core team.\\npragma solidity ^0.8.0;\\n\\ninterface KeeperRegistryBaseInterface {\\n    function registerUpkeep(\\n        address target,\\n        uint32 gasLimit,\\n        address admin,\\n        bytes calldata checkData\\n    ) external returns (uint256 id);\\n\\n    function performUpkeep(uint256 id, bytes calldata performData) external returns (bool success);\\n\\n    function cancelUpkeep(uint256 id) external;\\n\\n    function addFunds(uint256 id, uint96 amount) external;\\n\\n    function getUpkeep(uint256 id)\\n        external\\n        view\\n        returns (\\n            address target,\\n            uint32 executeGas,\\n            bytes memory checkData,\\n            uint96 balance,\\n            address lastKeeper,\\n            address admin,\\n            uint64 maxValidBlocknumber\\n        );\\n\\n    function getUpkeepCount() external view returns (uint256);\\n\\n    function getCanceledUpkeepList() external view returns (uint256[] memory);\\n\\n    function getKeeperList() external view returns (address[] memory);\\n\\n    function getKeeperInfo(address query)\\n        external\\n        view\\n        returns (\\n            address payee,\\n            bool active,\\n            uint96 balance\\n        );\\n\\n    function getConfig()\\n        external\\n        view\\n        returns (\\n            uint32 paymentPremiumPPB,\\n            uint24 checkFrequencyBlocks,\\n            uint32 checkGasLimit,\\n            uint24 stalenessSeconds,\\n            uint16 gasCeilingMultiplier,\\n            uint256 fallbackGasPrice,\\n            uint256 fallbackLinkPrice\\n        );\\n}\\n\\n/**\\n * @dev The view methods are not actually marked as view in the implementation\\n * but we want them to be easily queried off-chain. Solidity will not compile\\n * if we actually inherit from this interface, so we document it here.\\n */\\ninterface KeeperRegistryInterface is KeeperRegistryBaseInterface {\\n    function checkUpkeep(uint256 upkeepId, address from)\\n        external\\n        view\\n        returns (\\n            bytes memory performData,\\n            uint256 maxLinkPayment,\\n            uint256 gasLimit,\\n            int256 gasWei,\\n            int256 linkEth\\n        );\\n}\\n\\ninterface KeeperRegistryExecutableInterface is KeeperRegistryBaseInterface {\\n    function checkUpkeep(uint256 upkeepId, address from)\\n        external\\n        returns (\\n            bytes memory performData,\\n            uint256 maxLinkPayment,\\n            uint256 gasLimit,\\n            uint256 adjustedGasWei,\\n            uint256 linkEth\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/venders/chainlink/KeeperCompatibleInterface.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n//Create by Openflow.network core team.\\npragma solidity ^0.8.0;\\n\\ninterface KeeperCompatibleInterface {\\n    /**\\n     * @notice method that is simulated by the keepers to see if any work actually\\n     * needs to be performed. This method does does not actually need to be\\n     * executable, and since it is only ever simulated it can consume lots of gas.\\n     * @dev To ensure that it is never called, you may want to add the\\n     * cannotExecute modifier from KeeperBase to your implementation of this\\n     * method.\\n     * @param checkData specified in the upkeep registration so it is always the\\n     * same for a registered upkeep. This can easily be broken down into specific\\n     * arguments using `abi.decode`, so multiple upkeeps can be registered on the\\n     * same contract and easily differentiated by the contract.\\n     * @return upkeepNeeded boolean to indicate whether the keeper should call\\n     * performUpkeep or not.\\n     * @return performData bytes that the keeper should call performUpkeep with, if\\n     * upkeep is needed. If you would like to encode data to decode later, try\\n     * `abi.encode`.\\n     */\\n    function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\\n\\n    /**\\n     * @notice method that is actually executed by the keepers, via the registry.\\n     * The data returned by the checkUpkeep simulation will be passed into\\n     * this method to actually be executed.\\n     * @dev The input to this method should not be trusted, and the caller of the\\n     * method should not even be restricted to any single registry. Anyone should\\n     * be able call it, and the input should be validated, there is no guarantee\\n     * that the data passed in is the performData returned from checkUpkeep. This\\n     * could happen due to malicious keepers, racing keepers, or simply a state\\n     * change while the performUpkeep transaction is waiting for confirmation.\\n     * Always validate the data passed in.\\n     * @param performData is the data which was passed back from the checkData\\n     * simulation. If it is encoded, it can easily be decoded into other types by\\n     * calling `abi.decode`. This data should not be trusted, and should be\\n     * validated against the contract's current state.\\n     */\\n    function performUpkeep(bytes calldata performData) external;\\n}\\n\"\r\n    },\r\n    \"contracts/keeper/EvaKeepBotBase.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n//Create by Openflow.network core team.\\npragma solidity ^0.8.0;\\nimport {IEvabaseConfig} from \\\"../interfaces/IEvabaseConfig.sol\\\";\\nimport {IEvaFlowChecker} from \\\"../interfaces/IEvaFlowChecker.sol\\\";\\n\\nabstract contract EvaKeepBotBase {\\n    IEvabaseConfig public config;\\n    IEvaFlowChecker public evaFlowChecker;\\n\\n    function _check(bytes memory checkdata) internal virtual returns (bool needExec, bytes memory execdata);\\n\\n    function _exec(bytes memory execdata) internal virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEvabaseConfig.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n//Create by evabase.network core team.\\npragma solidity ^0.8.0;\\nimport {KeepNetWork} from \\\"../lib/EvabaseHelper.sol\\\";\\n\\nstruct KeepInfo {\\n    bool isActive;\\n    KeepNetWork keepNetWork;\\n}\\n\\ninterface IEvabaseConfig {\\n    event AddKeeper(address indexed user, address keeper, KeepNetWork keepNetWork);\\n    event RemoveKeeper(address indexed user, address keeper);\\n    event AddBatchKeeper(address indexed user, address[] keeper, KeepNetWork[] keepNetWork);\\n    event RemoveBatchKeeper(address indexed user, address[] keeper);\\n\\n    event SetControl(address indexed user, address control);\\n    event SetBatchFlowNum(address indexed user, uint32 num);\\n\\n    function getBytes32Item(bytes32 key) external view returns (bytes32);\\n\\n    function getAddressItem(bytes32 key) external view returns (address);\\n\\n    function control() external view returns (address);\\n\\n    function isKeeper(address query) external view returns (bool);\\n\\n    function batchFlowNum() external view returns (uint32);\\n\\n    function keepBotSizes(KeepNetWork keepNetWork) external view returns (uint32);\\n\\n    function getKeepBot(address add) external view returns (KeepInfo memory);\\n\\n    function isActiveControler(address add) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEvaFlowChecker.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n//author: Evabase core team\\n\\npragma solidity ^0.8.0;\\nimport {KeepNetWork} from \\\"../lib/EvabaseHelper.sol\\\";\\n\\ninterface IEvaFlowChecker {\\n    function check(\\n        uint256 keepbotId,\\n        uint256 lastMoveTime,\\n        KeepNetWork keepNetWork\\n    ) external returns (bool needExec, bytes memory execData);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEvaFlowController.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n//Create by evabase.network core team.\\npragma solidity ^0.8.0;\\nimport {FlowStatus, KeepNetWork} from \\\"../lib/EvabaseHelper.sol\\\";\\n\\n//struct\\nstruct EvaFlowMeta {\\n    FlowStatus flowStatus;\\n    KeepNetWork keepNetWork;\\n    address admin;\\n    address lastKeeper;\\n    address lastVersionflow;\\n    uint256 lastExecNumber;\\n    uint256 maxVaildBlockNumber;\\n    string flowName;\\n    bytes checkData;\\n}\\n\\nstruct EvaUserMeta {\\n    uint120 ethBal;\\n    uint120 gasTokenBal; //keep\\n    uint8 vaildFlowsNum;\\n}\\n\\nstruct MinConfig {\\n    address feeRecived;\\n    address feeToken;\\n    uint64 minGasFundForUser;\\n    uint64 minGasFundOneFlow;\\n    uint16 ppb;\\n    uint16 blockCountPerTurn;\\n}\\n\\ninterface IEvaFlowController {\\n    event FlowOperatorChanged(address op, bool removed);\\n    event FlowCreated(address indexed user, uint256 indexed flowId, address flowAdd, bytes checkData, uint256 fee);\\n    event FlowUpdated(address indexed user, uint256 flowId, address flowAdd);\\n    event FlowClosed(address indexed user, uint256 flowId);\\n    event FlowExecuteSuccess(\\n        address indexed user,\\n        uint256 indexed flowId,\\n        uint120 payAmountByETH,\\n        uint120 payAmountByFeeToken,\\n        uint256 gasUsed\\n    );\\n    event FlowExecuteFailed(\\n        address indexed user,\\n        uint256 indexed flowId,\\n        uint120 payAmountByETH,\\n        uint120 payAmountByFeeToken,\\n        uint256 gasUsed,\\n        string reason\\n    );\\n\\n    event SetMinConfig(\\n        address indexed user,\\n        address feeRecived,\\n        address feeToken,\\n        uint64 minGasFundForUser,\\n        uint64 minGasFundOneFlow,\\n        uint16 ppb,\\n        uint16 blockCountPerTurn\\n    );\\n\\n    function registerFlow(\\n        string memory name,\\n        KeepNetWork keepNetWork,\\n        address flow,\\n        bytes memory checkdata\\n    ) external payable returns (uint256 flowId);\\n\\n    function closeFlow(uint256 flowId) external;\\n\\n    function closeFlowWithGas(uint256 flowId, uint256 before) external;\\n\\n    function execFlow(\\n        address keeper,\\n        uint256 flowId,\\n        bytes memory inputData\\n    ) external;\\n\\n    function depositFund(address flowAdmin) external payable;\\n\\n    function withdrawFund(address recipient, uint256 amount) external;\\n\\n    function withdrawPayment(uint256 amount) external;\\n\\n    function getIndexVaildFlow(uint256 index, KeepNetWork keepNetWork) external view returns (uint256 value);\\n\\n    function getAllVaildFlowSize(KeepNetWork keepNetWork) external view returns (uint256 size);\\n\\n    function getFlowMetas(uint256 index) external view returns (EvaFlowMeta memory);\\n\\n    function getFlowMetaSize() external view returns (uint256);\\n\\n    function batchExecFlow(address keeper, bytes memory data) external;\\n\\n    function getFlowCheckInfo(uint256 flowId) external view returns (address flow, bytes memory checkData);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEvaFlow.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n//Create by evabase.network core team.\\npragma solidity ^0.8.0;\\n\\ninterface IEvaFlow {\\n    function check(bytes memory checkData) external view returns (bool needExecute, bytes memory executeData);\\n\\n    function execute(bytes memory executeData) external returns (bool canDestoryFlow);\\n\\n    function needClose(bytes memory checkData) external returns (bool yes);\\n\\n    function close(bytes memory checkData) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/EvabaseHelper.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n//Create by evabase.network core team.\\npragma solidity ^0.8.0;\\n\\nenum CompareOperator {\\n    Eq,\\n    Ne,\\n    Ge,\\n    Gt,\\n    Le,\\n    Lt\\n}\\n\\nenum FlowStatus {\\n    Active, //\u53ef\u6267\u884c\\n    Closed,\\n    Expired,\\n    Completed,\\n    Unknown\\n}\\n\\nenum KeepNetWork {\\n    ChainLink,\\n    Evabase,\\n    Gelato,\\n    Others\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"config_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"evaFlowChecker_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"keeperRegistry_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"evaCheck\",\"type\":\"address\"}],\"name\":\"SetEvaCheck\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"internalType\":\"contract IEvabaseConfig\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"evaFlowChecker\",\"outputs\":[{\"internalType\":\"contract IEvaFlowChecker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastMoveTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IEvaFlowChecker\",\"name\":\"evaFlowChecker_\",\"type\":\"address\"}],\"name\":\"setEvaCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EvaFlowChainLinkKeeperBot", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d184542faf47350e7042e31a74af188803dc9907000000000000000000000000d78c4b1c1ff1d2fbb069e29379540fa59d5a11c10000000000000000000000007b3ec232b08bd7b4b3305be0c044d907b2df960b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}