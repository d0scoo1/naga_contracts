{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"ECDA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n *\\n * @dev Copy of the Zeppelin\\u0027s library:\\n *      https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b0cf6fbb7a70f31527f36579ad644e1cf12fdf4e/contracts/utils/cryptography/ECDSA.sol\\n */\\nlibrary ECDSA {\\n\\t/**\\n\\t * @dev Returns the address that signed a hashed message (`hash`) with\\n\\t * `signature`. This address can then be used for verification purposes.\\n\\t *\\n\\t * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n\\t * this function rejects them by requiring the `s` value to be in the lower\\n\\t * half order, and the `v` value to be either 27 or 28.\\n\\t *\\n\\t * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n\\t * verification to be secure: it is possible to craft signatures that\\n\\t * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n\\t * this is by receiving a hash of the original message (which may otherwise\\n\\t * be too long), and then calling {toEthSignedMessageHash} on it.\\n\\t *\\n\\t * Documentation for signature generation:\\n\\t * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n\\t * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n\\t */\\n\\tfunction recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n\\t\\t// Divide the signature in r, s and v variables\\n\\t\\tbytes32 r;\\n\\t\\tbytes32 s;\\n\\t\\tuint8 v;\\n\\n\\t\\t// Check the signature length\\n\\t\\t// - case 65: r,s,v signature (standard)\\n\\t\\t// - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n\\t\\tif (signature.length == 65) {\\n\\t\\t\\t// ecrecover takes the signature parameters, and the only way to get them\\n\\t\\t\\t// currently is to use assembly.\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tr := mload(add(signature, 0x20))\\n\\t\\t\\t\\ts := mload(add(signature, 0x40))\\n\\t\\t\\t\\tv := byte(0, mload(add(signature, 0x60)))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (signature.length == 64) {\\n\\t\\t\\t// ecrecover takes the signature parameters, and the only way to get them\\n\\t\\t\\t// currently is to use assembly.\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tlet vs := mload(add(signature, 0x40))\\n\\t\\t\\t\\tr := mload(add(signature, 0x20))\\n\\t\\t\\t\\ts := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n\\t\\t\\t\\tv := add(shr(255, vs), 27)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\trevert(\\\"invalid signature length\\\");\\n\\t\\t}\\n\\n\\t\\treturn recover(hash, v, r, s);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Overload of {ECDSA-recover} that receives the `v`,\\n\\t * `r` and `s` signature fields separately.\\n\\t */\\n\\tfunction recover(\\n\\t\\tbytes32 hash,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) internal pure returns (address) {\\n\\t\\t// EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n\\t\\t// unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n\\t\\t// the valid range for s in (281): 0 \\u003c s \\u003c secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\\n\\t\\t// signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n\\t\\t//\\n\\t\\t// If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n\\t\\t// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n\\t\\t// vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n\\t\\t// these malleable signatures as well.\\n\\t\\trequire(\\n\\t\\t\\tuint256(s) \\u003c= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n\\t\\t\\t\\\"invalid signature \\u0027s\\u0027 value\\\"\\n\\t\\t);\\n\\t\\trequire(v == 27 || v == 28, \\\"invalid signature \\u0027v\\u0027 value\\\");\\n\\n\\t\\t// If the signature is valid (and not malleable), return the signer address\\n\\t\\taddress signer = ecrecover(hash, v, r, s);\\n\\t\\trequire(signer != address(0), \\\"invalid signature\\\");\\n\\n\\t\\treturn signer;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n\\t * produces hash corresponding to the one signed with the\\n\\t * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n\\t * JSON-RPC method as part of EIP-191.\\n\\t *\\n\\t * See {recover}.\\n\\t */\\n\\tfunction toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n\\t\\t// 32 is the length in bytes of hash,\\n\\t\\t// enforced by the type signature above\\n\\t\\treturn keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns an Ethereum Signed Typed Data, created from a\\n\\t * `domainSeparator` and a `structHash`. This produces hash corresponding\\n\\t * to the one signed with the\\n\\t * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n\\t * JSON-RPC method as part of EIP-712.\\n\\t *\\n\\t * See {recover}.\\n\\t */\\n\\tfunction toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n\\t\\treturn keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n\\t}\\n}\\n\"},\"ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"},\"ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./Context.sol\\\";\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Base URI for token metadata\\n    string public URI;\\n    \\n    // Record sell data of token\\n    struct Sell {\\n        uint256 price;\\n        bool forSell;\\n        uint8 sellType;     // option 0 = fixed price, 1 = auction\\n        uint64 endTime;\\n    }\\n    \\n    // Mapping from token Id to Sell \\n    mapping(uint256 =\\u003e Sell) public sellData;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 =\\u003e address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address =\\u003e uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 =\\u003e address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length \\u003e 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return URI;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``\\u0027s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``\\u0027s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n\\n        require(!sellData[tokenId].forSell, \\\"HomeJab: Ongoing sell\\\");\\n\\n        require(from != to, \\\"HomeJab: Invalid input\\\");\\n\\n    }\\n    \\n}\\n\"},\"ERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\n * account.\\n */\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 =\\u003e uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 =\\u003e uint256) private _allTokensIndex;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        require(index \\u003c ERC721.balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        require(index \\u003c ERC721Enumerable.totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``\\u0027s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``\\u0027s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n\\n        if (from == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            _addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension\\u0027s ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = ERC721.balanceOf(to);\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension\\u0027s token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension\\u0027s ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from\\u0027s tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\\u0027s index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension\\u0027s token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an \\u0027if\\u0027 statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\\u0027s index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n}\\n\"},\"HomeJab.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ERC721Enumerable.sol\\\";\\r\\nimport \\\"./ECDA.sol\\\";\\r\\n\\r\\n// Link to Payment token\\r\\ninterface IBEP20TOKEN {\\r\\n\\r\\n    // Transfer Payment token\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns(bool);\\r\\n    \\r\\n    // Return spending allowance\\r\\n    function allowance(\\r\\n      address _owner,\\r\\n      address _spender\\r\\n    ) external returns (uint256);\\r\\n\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title HomeJab Marketplace version 1.0\\r\\n *\\r\\n * @author HomeJab(Joe Jesuele)\\r\\n */\\r\\ncontract HomeJab is ERC721Enumerable {\\r\\n\\r\\n    // Address of owner of the contract\\r\\n    address public owner;\\r\\n\\r\\n    // Marketplace fee in terms of percentage\\r\\n    uint8 public marketplaceFee;\\r\\n\\r\\n    // Maximum batch size allowed\\r\\n    uint8 public batchSize;\\r\\n\\r\\n    // Contract address of payment token\\r\\n    address public paymentToken;\\r\\n\\r\\n    /**\\r\\n\\t * @notice EIP-712 contract\\u0027s domain typeHash,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\r\\n\\t *\\r\\n\\t * @dev Note: we do not include version into the domain typehash/separator,\\r\\n\\t *      it is implied version is concatenated to the name field, like \\\"HomeJab\\\"\\r\\n\\t */\\r\\n\\t// keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\")\\r\\n\\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 contract\\u0027s domain separator,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\\r\\n\\t */\\r\\n\\tbytes32 public immutable DOMAIN_SEPARATOR;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 permit (EIP-2612) struct typeHash,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\r\\n\\t */\\r\\n\\t// keccak256(\\\"Permit(address owner,address operator,uint256 tokenId,uint256 nonce,uint256 deadline)\\\")\\r\\n\\tbytes32 public constant PERMIT_TYPEHASH = 0xee2282d7affd5a432b221a559e429129347b0c19a3f102179a5fb1859eef3d29;\\r\\n    \\r\\n    /**\\r\\n\\t * @dev A record of nonces for signing/validating signatures in EIP-712 based\\r\\n\\t *      `permit` and `permitForAll` functions\\r\\n\\t *\\r\\n\\t * @dev Each time the nonce is used, it is increased by one, meaning reordering\\r\\n\\t *      of the EIP-712 transactions is not possible\\r\\n\\t *\\r\\n\\t * @dev Inspired by EIP-2612 extension for ERC20 token standard\\r\\n\\t *\\r\\n\\t * @dev Maps token owner address =\\u003e token owner nonce\\r\\n\\t */\\r\\n\\tmapping(address =\\u003e uint256) public permitNonces;\\r\\n\\r\\n    // Record bidder address and bidding amount\\r\\n    struct Bid {\\r\\n        address from;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    // Mapping from token Id to address of creator \\r\\n    mapping(uint256 =\\u003e address) public creator;\\r\\n\\r\\n    // Mapping from token Id to royalty fee associated with\\r\\n    mapping(uint256 =\\u003e uint8) public royalty;\\r\\n\\r\\n    // Mapping from token Id to user bids\\r\\n    mapping(uint256 =\\u003e Bid[]) public auctionBids;\\r\\n\\r\\n    /**\\r\\n\\t * @dev Fired in transferOwnership() when ownership transfered \\r\\n\\t *\\r\\n\\t * @param _previousOwner an address of previous owner\\r\\n\\t * @param _newOwner an address of new owner\\r\\n\\t */\\r\\n    event OwnershipTransferred(\\r\\n        address indexed _previousOwner,\\r\\n        address indexed _newOwner\\r\\n    );\\r\\n\\r\\n    /**\\r\\n\\t * @dev Fired in mint() when NFT minted\\r\\n\\t *\\r\\n\\t * @param _to an address of NFT minted to\\r\\n\\t * @param _id token Id of minted NFT \\r\\n     * @param _royaltyFee fees charged as royalty in terms of percentage\\r\\n\\t */\\r\\n    event Minted(\\r\\n        address indexed _to,\\r\\n        uint256 indexed _id,\\r\\n        uint8 _royaltyFee\\r\\n    );\\r\\n\\r\\n    /**\\r\\n\\t * @dev Fired in listForSell() when NFT listed for sell \\r\\n\\t *\\r\\n\\t * @param _by an address of NFT owner\\r\\n\\t * @param _id token Id of listed NFT \\r\\n     * @param _price sell price for the NFT\\r\\n     * @param _type sell type (0 = fixed price, 1 = english auction)\\r\\n\\t */\\r\\n    event Listed(\\r\\n        address indexed _by,\\r\\n        uint256 indexed _id,\\r\\n        uint256 _price,\\r\\n        uint8 _type\\r\\n    );\\r\\n\\r\\n    /**\\r\\n\\t * @dev Fired in revokeSell() when NFT delisted  \\r\\n\\t *\\r\\n\\t * @param _by an address of NFT owner\\r\\n\\t * @param _id token Id of minted NFT\\r\\n     */\\r\\n    event Delisted(\\r\\n        address indexed _by,\\r\\n        uint256 indexed _id\\r\\n    );\\r\\n\\r\\n    /**\\r\\n\\t * @dev Fired in editPrice() when NFT relisted at new price \\r\\n\\t *\\r\\n\\t * @param _by an address of NFT owner\\r\\n\\t * @param _id token Id of relisted NFT\\r\\n     * @param _oldPrice sell price before relisting\\r\\n     * @param _newPrice sell price after relisting\\r\\n\\t */\\r\\n    event Relisted(\\r\\n        address indexed _by,\\r\\n        uint256 indexed _id,\\r\\n        uint256 _oldPrice,\\r\\n        uint256 _newPrice\\r\\n    );\\r\\n\\r\\n    /**\\r\\n\\t * @dev Fired in buy() when NFT bought \\r\\n\\t *\\r\\n     * @param _from an address of seller\\r\\n\\t * @param _to an address of buyer\\r\\n\\t * @param _id token Id of sold NFT \\r\\n     * @param _price price paid by buyer \\r\\n     * @param _marketplaceFee fees charged by marketplace \\r\\n     * @param _royaltyFee fees charged as royalty\\r\\n\\t */\\r\\n    event Bought(\\r\\n        address indexed _from,\\r\\n        address indexed _to,\\r\\n        uint256 indexed _id,\\r\\n        uint256 _price,\\r\\n        uint256 _marketplaceFee,\\r\\n        uint256 _royaltyFee\\r\\n    );\\r\\n\\r\\n    /**\\r\\n\\t * @dev Fired in bidOnAuction() and revokeBid() when bid is placed/revoked\\r\\n\\t *      for english auction successfully\\r\\n\\t *\\r\\n\\t * @param _from an address of bidder\\r\\n\\t * @param _id token Id of bidded NFT\\r\\n\\t * @param _amount defines bid amount to be paid (zero if bid is revoked)\\r\\n\\t */\\r\\n    event BidUpdate(\\r\\n        address indexed _from,\\r\\n        uint256 indexed _id,\\r\\n        uint256 _amount\\r\\n    );\\r\\n\\r\\n    // To check ownership for restricted access functions\\r\\n    modifier onlyOwner {\\r\\n\\r\\n        verifyOwner();\\r\\n    \\r\\n        _;\\r\\n\\r\\n    }\\r\\n\\r\\n    // To check batch request lies within limits\\r\\n    modifier batchLimit(uint256 length_) {\\r\\n\\r\\n        verifyBatchLimit(length_);\\r\\n\\r\\n        _;\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n\\t * @dev Creates/deploys HomeJab Marketplace\\r\\n\\t *\\r\\n\\t * @param fee_ marketplace fee in terms of percentage\\r\\n\\t * @param batchSize_ maximum allowed amount in a batch\\r\\n\\t * @param baseURI_ base URL for token metadata end point\\r\\n\\t * @param paymentToken_ address of BEP20 token for payments\\r\\n\\t */\\r\\n    constructor(\\r\\n        uint8 fee_,\\r\\n        uint8 batchSize_,\\r\\n        string memory baseURI_,\\r\\n        address paymentToken_\\r\\n    ) ERC721(\\\"HomeJab Market\\\",\\\"REAL\\\") {\\r\\n        \\r\\n        require(\\r\\n            fee_ \\u003c= 10 \\u0026\\u0026 paymentToken_ != address(0),\\r\\n            \\\"HomeJab: Invalid input\\\"\\r\\n        );\\r\\n        \\r\\n        //----------Set Internal State----------//\\r\\n        owner = msg.sender;\\r\\n\\r\\n        marketplaceFee = fee_;\\r\\n\\r\\n        batchSize = batchSize_;\\r\\n\\r\\n        URI = baseURI_;\\r\\n\\r\\n        paymentToken = paymentToken_;\\r\\n\\r\\n        // build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\\r\\n\\t\\t// note: we specify contract version in its name\\r\\n\\t\\tDOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\\\"HomeJab\\\")), block.chainid, address(this)));\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns address of the owner\\r\\n     */\\r\\n    function getOwner() external view returns(address) {\\r\\n        return owner;\\r\\n    }    \\r\\n\\r\\n    /**\\r\\n     * @dev Returns royalty info as par the NFT Royalty Standard(EIP-2981) \\r\\n     * \\r\\n     * @notice Called with the sale price to determine how much royalty\\r\\n     *          is owed and to whom.\\r\\n     * @param id_ the NFT asset queried for royalty information\\r\\n     * @param price_ the sale price of the NFT asset specified by id_\\r\\n     * @return receiver_ address of who should be sent the royalty payment\\r\\n     * @return royaltyAmount_ the royalty payment amount for price_\\r\\n     */\\r\\n    function royaltyInfo(uint256 id_, uint256 price_)\\r\\n        external\\r\\n        view\\r\\n        returns (address receiver_, uint256 royaltyAmount_)\\r\\n    {\\r\\n    \\r\\n        receiver_ = creator[id_];\\r\\n        \\r\\n        royaltyAmount_ = (price_ * royalty[id_]) / 100;\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner_`).\\r\\n     *      Can only be called by the current owner.\\r\\n     * \\r\\n     * @param newOwner_ address of new owner\\r\\n     */\\r\\n    function transferOwnership(address newOwner_) external onlyOwner {\\r\\n        \\r\\n        require(\\r\\n            newOwner_ != address(0),\\r\\n            \\\"HomeJab: new owner is the zero address\\\"\\r\\n        );\\r\\n\\r\\n        emit OwnershipTransferred(owner, newOwner_);\\r\\n        \\r\\n        owner = newOwner_;\\r\\n        \\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets marketplace fee \\r\\n     *\\r\\n     * @notice Restricted access function, should be called by owner only \\r\\n     * @param fee_ defines marketplace fee in terms of percentage\\r\\n     */\\r\\n    function setMarketplaceFee(uint8 fee_) \\r\\n        external \\r\\n        onlyOwner\\r\\n    {\\r\\n        \\r\\n        require(fee_ \\u003c= 10, \\\"HomeJab: Invalid input\\\");\\r\\n        \\r\\n        marketplaceFee = fee_;\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets batch size for batch operations \\r\\n     *\\r\\n     * @notice Restricted access function, should be called by owner only \\r\\n     * @param batchSize_ defines batch size\\r\\n     */\\r\\n    function setBatchSize(uint8 batchSize_) \\r\\n        external \\r\\n        onlyOwner\\r\\n    {    \\r\\n        batchSize = batchSize_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets base URI for token metadata \\r\\n     *\\r\\n     * @notice Restricted access function, should be called by owner only \\r\\n     * @param baseURI_ defines base URI\\r\\n     */\\r\\n    function setBaseURI(string memory baseURI_) \\r\\n        external \\r\\n        onlyOwner\\r\\n    {\\r\\n        URI = baseURI_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets payment token interface \\r\\n     *\\r\\n     * @notice Restricted access function, should be called by owner only \\r\\n     * @param paymentToken_ defines contract address of BEP20 token\\r\\n     */\\r\\n    function setPaymentInterface(address paymentToken_) \\r\\n        external \\r\\n        onlyOwner\\r\\n    {\\r\\n        \\r\\n        require(paymentToken_ != address(0), \\\"HomeJab: Invalid input\\\");\\r\\n\\r\\n        paymentToken = paymentToken_;\\r\\n    \\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mint new NFT\\r\\n     *\\r\\n     * @param royalty_ defines royalty fee in terms of percentage\\r\\n     * @return id_ defines token id that is minted for creator\\r\\n     */\\r\\n    function mint(uint8 royalty_) public returns(uint256 id_) {\\r\\n\\r\\n        require(royalty_ \\u003c= 10, \\\"HomeJab: Invalid royalty fee\\\");\\r\\n\\r\\n        // Get Id\\r\\n        uint256 _id = totalSupply() + 1;\\r\\n\\r\\n        // Record creator address\\r\\n        creator[_id] = msg.sender;\\r\\n\\r\\n        // Record royalty fee\\r\\n        royalty[_id] = royalty_;\\r\\n\\r\\n        // Mint token with given Id\\r\\n        _safeMint(msg.sender, _id);\\r\\n\\r\\n        // Emit an event\\r\\n        emit Minted(msg.sender, _id, royalty_);\\r\\n\\r\\n        return _id;\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mints new NFTs in batch\\r\\n     *\\r\\n     * @param amount_ defines amount of NFTs to be minted for creator\\r\\n     * @param royalty_ defines royalty fee per NFT in terms of percentage\\r\\n     */\\r\\n    function mintBatch(uint8 amount_, uint8 royalty_)\\r\\n        external\\r\\n        batchLimit(amount_)  \\r\\n    {\\r\\n\\r\\n        for(uint8 i; i \\u003c amount_; i++) {\\r\\n            \\r\\n            mint(royalty_);\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mints new NFT to creator and transfer it to buyer\\r\\n     *\\r\\n     * @param creator_ defines address creator\\r\\n     * @param royalty_ defines royalty fee per NFT in terms of percentage\\r\\n     * @param price_ defines price of given NFT \\r\\n     */\\r\\n    function lazyMint(address creator_, uint8 royalty_, uint256 price_) public {\\r\\n        \\r\\n        require(royalty_ \\u003c= 10, \\\"HomeJab: Invalid royalty fee\\\");\\r\\n\\r\\n        // Get Id\\r\\n        uint256 _id = totalSupply() + 1;\\r\\n\\r\\n        // Record creator address\\r\\n        creator[_id] = creator_;\\r\\n\\r\\n        // Record royalty fee\\r\\n        royalty[_id] = royalty_;\\r\\n\\r\\n        // Mint token with given Id\\r\\n        _safeMint(creator_, _id);\\r\\n\\r\\n        // Emit an event\\r\\n        emit Minted(creator_, _id, royalty_);\\r\\n        \\r\\n        // Calculates marketplace fee\\r\\n        uint256 _marketplaceFee = (price_ * marketplaceFee) / 100; \\r\\n        \\r\\n        //------------------ Transfer price and fees ------------------//\\r\\n        IBEP20TOKEN(paymentToken).transferFrom(msg.sender, owner, _marketplaceFee);\\r\\n\\r\\n        IBEP20TOKEN(paymentToken).transferFrom(msg.sender, creator_, price_ - _marketplaceFee);\\r\\n        \\r\\n        // Transfer NFT to buyer\\r\\n        _transfer(creator_, msg.sender, _id);\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev List NFT for sell at fixed price\\r\\n     *\\r\\n     * @param id_ defines token Id to be listed for sell\\r\\n     * @param price_ defines desired sell price of NFT\\r\\n     */\\r\\n    function listForSell(uint256 id_, uint256 price_)\\r\\n        public\\r\\n    {\\r\\n\\r\\n        require(msg.sender == ownerOf(id_), \\\"HomeJab: only NFT owner can list NFT for sell\\\");\\r\\n\\r\\n        require(!sellData[id_].forSell, \\\"HomeJab: Sell is active\\\");\\r\\n\\r\\n        // Record sell data\\r\\n        sellData[id_] = Sell(price_, true, 0, 0);\\r\\n\\r\\n        // Emit an event\\r\\n        emit Listed(msg.sender, id_, price_, 0);\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev List NFTs for sell at fixed price\\r\\n     *\\r\\n     * @param id_ defines array of token Ids to be listed for sell\\r\\n     * @param price_ defines desired sell price per NFT\\r\\n     */\\r\\n    function listForSellBatch(uint256[] memory id_, uint256 price_)\\r\\n        external\\r\\n        batchLimit(id_.length)\\r\\n    {\\r\\n        \\r\\n        for(uint8 i; i \\u003c id_.length; i++) {\\r\\n\\r\\n            listForSell(id_[i], price_);\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Edit sell price for given NFT\\r\\n     *\\r\\n     * @param id_ defines token Id of NFT\\r\\n     * @param newPrice_ defines new price to be set for sell\\r\\n     */\\r\\n    function editPrice(uint256 id_, uint256 newPrice_) \\r\\n        external\\r\\n    {\\r\\n        require(msg.sender == ownerOf(id_), \\\"HomeJab: only NFT owner can edit price\\\");\\r\\n\\r\\n        require(\\r\\n            sellData[id_].forSell \\u0026\\u0026 sellData[id_].sellType == 0,\\r\\n            \\\"HomeJab: Fixed price sell is not active\\\"\\r\\n        );\\r\\n        \\r\\n        // Get old price\\r\\n        uint256 _oldPrice = sellData[id_].price;\\r\\n        \\r\\n        // Record new price\\r\\n        sellData[id_].price = newPrice_;\\r\\n\\r\\n        // Emit an event\\r\\n        emit Relisted(msg.sender, id_, _oldPrice, newPrice_);\\r\\n\\r\\n    }    \\r\\n\\r\\n    /**\\r\\n     * @dev Buy given NFT\\r\\n     *\\r\\n     * @param id_ defines token Id of NFT\\r\\n     */\\r\\n    function buy(uint256 id_)\\r\\n        external\\r\\n    {\\r\\n        \\r\\n        require(sellData[id_].forSell, \\\"HomeJab: Sell is not active\\\");\\r\\n\\r\\n        // Get address of seller\\r\\n        address _seller = ownerOf(id_);\\r\\n\\r\\n        // Get sell price of given NFT\\r\\n        uint256 _price = sellData[id_].price;\\r\\n\\r\\n        // Calculate marketplace fee\\r\\n        uint256 _marketplaceFee = (_price * marketplaceFee) / 100;\\r\\n        \\r\\n        // Calculate royalty fee\\r\\n        uint256 _royaltyFee = (_price * royalty[id_]) / 100;\\r\\n\\r\\n        //------------------ Transfer price and fees ------------------//    \\r\\n        IBEP20TOKEN(paymentToken).transferFrom(\\r\\n            msg.sender,\\r\\n            _seller,\\r\\n            _price - (_marketplaceFee + _royaltyFee)\\r\\n        );\\r\\n\\r\\n        IBEP20TOKEN(paymentToken).transferFrom(msg.sender, owner, _marketplaceFee);\\r\\n        \\r\\n        IBEP20TOKEN(paymentToken).transferFrom(msg.sender, creator[id_], _royaltyFee);\\r\\n\\r\\n        // Remove sell data\\r\\n        sellData[id_] = Sell(0, false, 0, 0);\\r\\n\\r\\n        // Transfer NFT to buyer\\r\\n        _transfer(_seller, msg.sender, id_);\\r\\n\\r\\n        // Emit an event\\r\\n        emit Bought(_seller, msg.sender, id_, _price, _marketplaceFee, _royaltyFee);\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev List NFT for sell on english auction\\r\\n     *\\r\\n     * @param id_ defines token Id to be listed for sell\\r\\n     * @param basePrice_ defines desired base price of NFT\\r\\n     * @param endTime_ defines auction ending time in timestamp\\r\\n     */\\r\\n    function listForEnglishAuction(\\r\\n        uint256 id_,\\r\\n        uint256 basePrice_,\\r\\n        uint64 endTime_\\r\\n    ) public {\\r\\n        \\r\\n        require(msg.sender == ownerOf(id_), \\\"HomeJab: only NFT owner can list NFT for sell\\\");\\r\\n\\r\\n        require(!sellData[id_].forSell, \\\"HomeJab: Sell is active\\\");\\r\\n\\r\\n        require(endTime_ \\u003e block.timestamp, \\\"HomeJab: Past time\\\");\\r\\n\\r\\n        // Record sell data\\r\\n        sellData[id_] = Sell(basePrice_, true, 1, endTime_);\\r\\n\\r\\n        // Emit an event\\r\\n        emit Listed(msg.sender, id_, basePrice_, 1);\\r\\n\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev List NFTs for sell on english auction\\r\\n     *\\r\\n     * @param id_ defines array of token Ids to be listed for sell\\r\\n     * @param basePrice_ defines desired base price per NFT\\r\\n     * @param endTime_ defines auction ending time in timestamp\\r\\n     */\\r\\n    function listForEnglishAuctionBatch(\\r\\n        uint256[] memory id_,\\r\\n        uint256 basePrice_,\\r\\n        uint64 endTime_\\r\\n    )\\r\\n        external\\r\\n        batchLimit(id_.length)\\r\\n    {\\r\\n\\r\\n        for(uint8 i; i \\u003c id_.length; i++) {\\r\\n\\r\\n            listForEnglishAuction(id_[i], basePrice_, endTime_);\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    /** \\r\\n     * @dev returns bid count of NFT listed in english auction\\r\\n     * \\r\\n     * @param id_ unsigned integer defines token Id \\r\\n     */\\r\\n    function getBidCount(uint256 id_) public view returns (uint256) {\\r\\n      return auctionBids[id_].length;\\r\\n    }\\r\\n\\r\\n    /** \\r\\n     * @dev Bid for NFT listed in english auction\\r\\n     *\\r\\n     * @param id_ defines token Id of auctioned NFT \\r\\n     * @param bidPrice_ defines number of payment tokens offered for bid  \\r\\n     */\\r\\n    function bidOnAuction(\\r\\n        uint256 id_,\\r\\n        uint256 bidPrice_\\r\\n    ) external {\\r\\n\\r\\n        require(\\r\\n            isAuctionActive(id_),\\r\\n            \\\"HomeJab: Auction is not active\\\"\\r\\n        );\\r\\n\\r\\n        // Get last bid amount\\r\\n        uint256 _lastBid = (getBidCount(id_) == 0) ?\\r\\n                            sellData[id_].price - 1 : auctionBids[id_][getBidCount(id_) - 1].amount;  \\r\\n\\r\\n        require(\\r\\n            bidPrice_ \\u003e _lastBid \\u0026\\u0026\\r\\n            IBEP20TOKEN(paymentToken).allowance(msg.sender, address(this)) \\u003e bidPrice_,\\r\\n            \\\"HomeJab: Bid price is less than last bid price / base price\\\"\\r\\n        );\\r\\n\\r\\n        // Wrap bid information\\r\\n        Bid memory newBid = Bid(msg.sender, bidPrice_);\\r\\n\\r\\n        // Record bid information\\r\\n        auctionBids[id_].push(newBid);\\r\\n        \\r\\n        // Emit an event\\r\\n        emit BidUpdate(msg.sender, id_, bidPrice_);\\r\\n\\r\\n    }\\r\\n\\r\\n    /** \\r\\n     * @dev Revoke existing Bid for NFT listed in english auction\\r\\n     *\\r\\n     * @param id_ defines token Id of auctioned NFT \\r\\n     * @param bidIndex_ defines index of bid to be revoked \\r\\n     */\\r\\n    function revokeBid(\\r\\n        uint256 id_,\\r\\n        uint256 bidIndex_\\r\\n    ) external {\\r\\n\\r\\n        require(\\r\\n            isAuctionActive(id_),\\r\\n            \\\"HomeJab: Auction is not active\\\"\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            msg.sender == auctionBids[id_][bidIndex_].from,\\r\\n            \\\"HomeJab: Invalid bidder\\\"\\r\\n        );\\r\\n\\r\\n        // Get last index\\r\\n        uint256 _lastIndex = getBidCount(id_) - 1;\\r\\n        \\r\\n        // Remove given bid index by shifting elements from right to left\\r\\n        for(uint i = bidIndex_; i \\u003c _lastIndex; i++) {\\r\\n            auctionBids[id_][i] = auctionBids[id_][i + 1];\\r\\n        }\\r\\n        \\r\\n        // Remove last index\\r\\n        auctionBids[id_].pop();\\r\\n\\r\\n        // Emit an event\\r\\n        emit BidUpdate(msg.sender, id_, 0);\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Accept bid for NFT listed in english auction \\r\\n     *\\r\\n     * @notice on success NFT is transfered to bidder and seller gets the amount\\r\\n     * @notice limited access function that can be called by seller only\\r\\n     * \\r\\n     * @param id_ defines token Id of auctioned NFT\\r\\n     * @param bidIndex_ defines index of given bid to accept for finalize auction\\r\\n     */\\r\\n    function acceptBid(\\r\\n        uint256 id_,\\r\\n        uint256 bidIndex_\\r\\n    ) external {\\r\\n\\r\\n        require(\\r\\n            sellData[id_].forSell \\u0026\\u0026 sellData[id_].sellType == 1,\\r\\n            \\\"HomeJab: Not listed for auction\\\"\\r\\n        );\\r\\n\\r\\n        require(msg.sender == ownerOf(id_), \\\"HomeJab: Not an owner of NFT\\\");\\r\\n\\r\\n        // Get address of bidder\\r\\n        address _bidder = auctionBids[id_][bidIndex_].from;\\r\\n\\r\\n        // Get bid amount of given index\\r\\n        uint256 _price = auctionBids[id_][bidIndex_].amount;\\r\\n\\r\\n        // Calculate marketplace fee\\r\\n        uint256 _marketplaceFee = (_price * marketplaceFee) / 100;\\r\\n        \\r\\n        // Calculate royalty fee\\r\\n        uint256 _royaltyFee = (_price * royalty[id_]) / 100;\\r\\n\\r\\n        //------------------ Transfer price and fees ------------------//    \\r\\n        IBEP20TOKEN(paymentToken).transferFrom(\\r\\n            _bidder,\\r\\n            msg.sender,\\r\\n            _price - (_marketplaceFee + _royaltyFee)\\r\\n        );\\r\\n\\r\\n        IBEP20TOKEN(paymentToken).transferFrom(_bidder, owner, _marketplaceFee);\\r\\n        \\r\\n        IBEP20TOKEN(paymentToken).transferFrom(_bidder, creator[id_], _royaltyFee);\\r\\n\\r\\n        // Remove sell data\\r\\n        sellData[id_] = Sell(0, false, 0, 0);\\r\\n\\r\\n        // Clear Bidding information\\r\\n        delete auctionBids[id_];\\r\\n\\r\\n        // Transfer NFT to buyer\\r\\n        _transfer(msg.sender, _bidder, id_);\\r\\n        \\r\\n        // Emit an event\\r\\n        emit Bought(msg.sender, _bidder, id_, _price, _marketplaceFee, _royaltyFee);\\r\\n        \\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mint a NFT and List it for sell at fixed price/ base price(english auction)\\r\\n     *\\r\\n     * @param royalty_ defines royalty fee in terms of percentage\\r\\n     * @param price_ defines desired sell price/ base price of NFT\\r\\n     * @param endTime_ defines auction ending time in timestamp(Value must be \\u00270\\u0027 For fixed price sell)\\r\\n     */\\r\\n    function mintAndList(uint8 royalty_, uint256 price_, uint64 endTime_)\\r\\n        public\\r\\n    {\\r\\n        \\r\\n        // Mint new NFT and record Id\\r\\n        uint256 _id = mint(royalty_);\\r\\n\\r\\n        if(endTime_ == 0) {\\r\\n\\r\\n            // List NFT for fixed price sell\\r\\n            listForSell(_id, price_);\\r\\n\\r\\n        } else {\\r\\n            \\r\\n            // List NFT for english auction\\r\\n            listForEnglishAuction(_id, price_, endTime_);\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mint NFTs and List them for sell at fixed price/ base price(english auction)\\r\\n     *\\r\\n     * @param amount_ defines amount of NFTs minted and listed\\r\\n     * @param royalty_ defines royalty fee per NFT in terms of percentage\\r\\n     * @param price_ defines desired sell price/ base price per NFT\\r\\n     * @param endTime_ defines auction ending time in timestamp(Value must be \\u00270\\u0027 For fixed price sell)\\r\\n     */\\r\\n    function mintAndListBatch(uint8 amount_, uint8 royalty_, uint256 price_, uint64 endTime_)\\r\\n        external\\r\\n        batchLimit(amount_)\\r\\n    {\\r\\n        \\r\\n        for(uint8 i; i \\u003c amount_; i++) {\\r\\n\\r\\n            mintAndList(royalty_, price_, endTime_);\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Ends ongoing sell for given NFT\\r\\n     *\\r\\n     * @param id_ defines token Id of NFT\\r\\n     */\\r\\n    function revokeSell(uint256 id_) \\r\\n        external\\r\\n    {\\r\\n\\r\\n        require(msg.sender == ownerOf(id_), \\\"HomeJab: only NFT owner can revoke sell\\\");\\r\\n\\r\\n        require(sellData[id_].forSell, \\\"HomeJab: Sell is not active\\\");\\r\\n\\r\\n        // Remove sell data\\r\\n        sellData[id_] = Sell(0, false, 0, 0);\\r\\n\\r\\n        // Clear Bidding information in case of English auction\\r\\n        delete auctionBids[id_];\\r\\n        \\r\\n        // Emit an event\\r\\n        emit Delisted(msg.sender, id_);   \\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Called internally to verify that english auction is running and active\\r\\n     */\\r\\n    function isAuctionActive(uint256 id_) internal view returns(bool) {\\r\\n        return sellData[id_].forSell \\u0026\\u0026 sellData[id_].sellType == 1 \\u0026\\u0026 sellData[id_].endTime \\u003e block.timestamp;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Called internally to verify that function is being called by HomeJab owner\\r\\n     */\\r\\n    function verifyOwner() internal view {\\r\\n\\r\\n        require(\\r\\n            msg.sender == owner,\\r\\n            \\\"HomeJab: Not an owner\\\"\\r\\n        );\\r\\n        \\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Called internally to verify that batch request lies within permissible limit\\r\\n     */\\r\\n    function verifyBatchLimit(uint256 length_) internal view {\\r\\n\\r\\n        require(\\r\\n            length_ \\u003c= batchSize,\\r\\n            \\\"HomeJab: Invalid batch size\\\"\\r\\n        );\\r\\n\\r\\n    }\\r\\n\\r\\n    // ===== End: ERC721 mutative functions (transfers, approvals) =====\\r\\n\\r\\n\\t// ===== Start: Meta-transactions Support =====\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Change or reaffirm the approved address for an NFT on behalf\\r\\n\\t *\\r\\n\\t * @dev Executes approve(_operator, _tokenId) on behalf of the token owner\\r\\n\\t *      who EIP-712 signed the transaction, i.e. as if transaction sender is the EIP712 signer\\r\\n\\t *\\r\\n\\t * @dev Sets the `_tokenId` as the allowance of `_operator` over `_owner` token,\\r\\n\\t *      given `_owner` EIP-712 signed approval\\r\\n\\t *\\r\\n\\t * @dev Emits `Approval` event in the same way as `approve` does\\r\\n\\t *\\r\\n\\t * @dev Requires:\\r\\n\\t *     - `_operator` to be non-zero address\\r\\n\\t *     - `_exp` to be a timestamp in the future\\r\\n\\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\\r\\n\\t *        over the EIP712-formatted function arguments.\\r\\n\\t *     - the signature to use `_owner` current nonce (see `permitNonces`).\\r\\n\\t *\\r\\n\\t * @dev For more information on the signature format, see the\\r\\n\\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\\r\\n\\t *\\r\\n\\t * @param _owner owner of the token to set approval on behalf of,\\r\\n\\t *      an address which signed the EIP-712 message\\r\\n\\t * @param _operator new approved NFT controller\\r\\n\\t * @param _tokenId token ID to approve\\r\\n\\t * @param _exp signature expiration time (unix timestamp)\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction permit(address _owner, address _operator, uint256 _tokenId, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\\r\\n\\t\\t// derive signer of the EIP712 Permit message, and\\r\\n\\t\\t// update the nonce for that particular signer to avoid replay attack!!! -----------\\u003e\\u003e\\u003e \u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\\r\\n\\t\\taddress signer = __deriveSigner(abi.encode(PERMIT_TYPEHASH, _owner, _operator, _tokenId, permitNonces[_owner]++, _exp), v, r, s);\\r\\n\\r\\n\\t\\t// perform message integrity and security validations\\r\\n\\t\\trequire(signer == _owner, \\\"invalid signature\\\");\\r\\n\\t\\trequire(block.timestamp \\u003c _exp, \\\"signature expired\\\");\\r\\n\\r\\n\\t\\t// delegate call to `__approve` - execute the logic required\\r\\n\\t\\t_approve(_operator, _tokenId);\\r\\n\\t}\\r\\n\\r\\n    /**\\r\\n\\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\\r\\n\\t *\\r\\n\\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\\r\\n\\t\\t// build the EIP-712 hashStruct of the message\\r\\n\\t\\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\\r\\n\\r\\n\\t\\t// calculate the EIP-712 digest \\\"\\\\x19\\\\x01\\\" \u2016 domainSeparator \u2016 hashStruct(message)\\r\\n\\t\\tbytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR, hashStruct));\\r\\n\\r\\n\\t\\t// recover the address which signed the message with v, r, s\\r\\n\\t\\taddress signer = ECDSA.recover(digest, v, r, s);\\r\\n\\r\\n\\t\\t// return the signer address derived from the signature\\r\\n\\t\\treturn signer;\\r\\n\\t}\\r\\n\\r\\n}\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``\\u0027s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"},\"IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``\\u0027s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"},\"IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"},\"IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _ALPHABET = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp \\u003e\\u003e= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\n            buffer[i] = _ALPHABET[value \\u0026 0xf];\\n            value \\u003e\\u003e= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"fee_\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"batchSize_\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"paymentToken_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BidUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_marketplaceFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_royaltyFee\",\"type\":\"uint256\"}],\"name\":\"Bought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"Delisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"Listed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_royaltyFee\",\"type\":\"uint8\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"Relisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"URI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidIndex_\",\"type\":\"uint256\"}],\"name\":\"acceptBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctionBids\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batchSize\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidPrice_\",\"type\":\"uint256\"}],\"name\":\"bidOnAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPrice_\",\"type\":\"uint256\"}],\"name\":\"editPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"getBidCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creator_\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"royalty_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"}],\"name\":\"lazyMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basePrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"endTime_\",\"type\":\"uint64\"}],\"name\":\"listForEnglishAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"id_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"basePrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"endTime_\",\"type\":\"uint64\"}],\"name\":\"listForEnglishAuctionBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"}],\"name\":\"listForSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"id_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"}],\"name\":\"listForSellBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketplaceFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"royalty_\",\"type\":\"uint8\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"royalty_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"endTime_\",\"type\":\"uint64\"}],\"name\":\"mintAndList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"amount_\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"royalty_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"endTime_\",\"type\":\"uint64\"}],\"name\":\"mintAndListBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"amount_\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"royalty_\",\"type\":\"uint8\"}],\"name\":\"mintBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_exp\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"permitNonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidIndex_\",\"type\":\"uint256\"}],\"name\":\"revokeBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"revokeSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"royalty\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sellData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"forSell\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"sellType\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"batchSize_\",\"type\":\"uint8\"}],\"name\":\"setBatchSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"fee_\",\"type\":\"uint8\"}],\"name\":\"setMarketplaceFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"paymentToken_\",\"type\":\"address\"}],\"name\":\"setPaymentInterface\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HomeJab", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000080000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000000000000000000000002668747470733a2f2f6e66742d6170692e686f6d656a61622e636f6d2f746f6b656e2f6574682f0000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://89ffe8b1e547af936f72ca288ef8db453c8878cd386eb48b115d098dd6a27b08"}]}