{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/SalePlatform.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nimport \\\"./interfaces/IQuantumArt.sol\\\";\\nimport \\\"./interfaces/IQuantumMintPass.sol\\\";\\nimport \\\"./interfaces/IQuantumSplitter.sol\\\";\\nimport \\\"./ContinuousDutchAuction.sol\\\";\\nimport \\\"./SaleModule.sol\\\";\\nimport \\\"./WhitelistModule.sol\\\";\\nimport \\\"./MintpassModule.sol\\\";\\nimport \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/BitMaps.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\ncontract SalePlatform is \\n    ReentrancyGuard,\\n    Auth,\\n    SaleModule,\\n    WhitelistModule,\\n    MintpassModule,\\n    ContinuousDutchAuction \\n{\\n    using BitMaps for BitMaps.BitMap;\\n    using Strings for uint256;\\n\\n    event Purchased(uint256 indexed dropId, uint256 tokenId, address to);\\n\\n    address[] public privilegedContracts;\\n    IQuantumArt public quantum;\\n    IQuantumSplitter public splitter;\\n\\n    BitMaps.BitMap private _disablingLimiter;\\n    mapping (address => BitMaps.BitMap) private _alreadyBought;\\n\\n    constructor(\\n        address quantum_,\\n        address mintpass_,\\n        address admin_,\\n        address authority_,\\n        address splitter_) Auth(admin_, Authority(authority_)) {\\n        quantum = IQuantumArt(quantum_);\\n        mintpass = IQuantumMintPass(mintpass_);\\n        splitter = IQuantumSplitter(splitter_);\\n    }\\n\\n    modifier checkCaller {\\n        require(msg.sender.code.length == 0, \\\"Contract forbidden\\\");\\n        _;\\n    }\\n\\n    modifier isFirstTime(uint256 dropId) {\\n        if (!_disablingLimiter.get(dropId)) {\\n            require(!_alreadyBought[msg.sender].get(dropId), string(abi.encodePacked(\\\"Already bought drop \\\", dropId.toString())));\\n            _alreadyBought[msg.sender].set(dropId);\\n        }\\n        _;\\n    }\\n\\n    function setPrivilegedContracts(address[] calldata contracts) requiresAuth public {\\n        privilegedContracts = contracts;\\n    }\\n\\n    function setSplitter(address splitter_) requiresAuth public {\\n        splitter = IQuantumSplitter(splitter_);\\n    }\\n\\n    function withdraw(address payable to) requiresAuth public {\\n        Address.sendValue(to, address(this).balance);\\n    }\\n\\n    function premint(uint256 dropId, address[] calldata recipients) requiresAuth public {\\n        for(uint256 i = 0; i < recipients.length; i++) {\\n            uint256 tokenId = quantum.mintTo(dropId, recipients[i]);\\n            emit Purchased(dropId, tokenId, recipients[i]);\\n        }\\n    }\\n\\n    function flipLimiterForDrop(uint256 dropId) requiresAuth public {\\n        if (_disablingLimiter.get(dropId)) {\\n            _disablingLimiter.unset(dropId);\\n        } else {\\n            _disablingLimiter.set(dropId);\\n        }\\n    }\\n\\n    function setAuction(\\n        uint256 auctionId,\\n        uint256 startingPrice,\\n        uint128 decreasingConstant,\\n        uint64 start,\\n        uint64 period\\n    ) public override requiresAuth {\\n        super.setAuction(auctionId, startingPrice, decreasingConstant, start, period);\\n    }\\n\\n    function _depositToSplitter(uint256 dropId, uint256 amount) internal {\\n        splitter.deposit{value:amount}(dropId);\\n    }\\n\\n    function _isPrivileged(address user) internal view returns (bool) {\\n        uint256 length = privilegedContracts.length;\\n        unchecked {\\n            for(uint i; i < length; i++) {\\n                /// @dev using this interface because has balanceOf\\n                if (IQuantumArt(privilegedContracts[i]).balanceOf(user) > 0) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function purchase(uint256 dropId, uint256 amount) nonReentrant checkCaller isFirstTime(dropId) payable public {\\n        _purchase(dropId, amount);\\n        for(uint256 i = 0; i < amount; i++) {\\n            uint256 tokenId = quantum.mintTo(dropId, msg.sender);\\n            emit Purchased(dropId, tokenId, msg.sender);\\n        }\\n        _depositToSplitter(dropId, msg.value);\\n    }\\n\\n\\n    function purchaseThroughAuction(uint256 dropId) nonReentrant checkCaller isFirstTime(dropId) payable public {\\n        Auction memory auction = _auctions[dropId];\\n        // if 5 minutes before public auction\\n        // if holder -> special treatment\\n        uint256 userPaid = auction.startingPrice;\\n        if (\\n            block.timestamp <= auction.start && \\n            block.timestamp >= auction.start - 300 &&\\n            _isPrivileged(msg.sender)\\n        ) {\\n            require(msg.value == userPaid, \\\"PURCHASE:INCORRECT MSG.VALUE\\\");\\n\\n        } else {\\n            userPaid = verifyBid(dropId);\\n        }\\n        uint256 tokenId = quantum.mintTo(dropId, msg.sender);\\n        emit Purchased(dropId, tokenId, msg.sender);\\n        _depositToSplitter(dropId, userPaid);\\n    }\\n\\n    function claimWithMintPass(uint256 dropId, uint256 amount) nonReentrant payable public {\\n        _claimWithMintPass(dropId, amount);\\n        for(uint256 i = 0; i < amount; i++) {\\n            uint256 tokenId = quantum.mintTo(dropId, msg.sender);\\n            emit Purchased(dropId, tokenId, msg.sender);\\n        }\\n        if (msg.value > 0) _depositToSplitter(dropId, msg.value);\\n    }\\n\\n    function purchaseThroughWhitelist(uint256 dropId, uint256 amount, uint256 index, bytes32[] calldata merkleProof) nonReentrant external payable {\\n        _purchaseThroughWhitelist(dropId, amount, index, merkleProof);\\n        uint256 tokenId = quantum.mintTo(dropId, msg.sender);\\n        emit Purchased(dropId, tokenId, msg.sender);\\n        _depositToSplitter(dropId, msg.value);\\n    }\\n}\"\r\n    },\r\n    \"src/interfaces/IQuantumArt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IQuantumArt {\\n    function mintTo(uint256 dropId, address artist) external returns (uint256);\\n    function burn(uint256 tokenId) external;\\n    function getArtist(uint256 dropId) external view returns (address);\\n    function balanceOf(address user) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IQuantumMintPass.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IQuantumMintPass {\\n    function burnFromRedeem(address user, uint256 mpId, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IQuantumSplitter.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.11;\\n\\ninterface IQuantumSplitter {\\n    function deposit(uint256 dropId) external payable;\\n}\\n\"\r\n    },\r\n    \"src/ContinuousDutchAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nabstract contract ContinuousDutchAuction {\\n\\n    struct Auction {\\n        uint256 startingPrice;\\n        uint128 decreasingConstant;\\n        uint64 start;\\n        uint64 period; //period in seconds : MAX IS 18 HOURS\\n    }\\n\\n    mapping (uint => Auction) internal _auctions;\\n\\n    function auctions(uint256 auctionId) public view returns (\\n        uint256 startingPrice,\\n        uint128 decreasingConstant,\\n        uint64 start,\\n        uint64 period,\\n        bool active\\n    ) {\\n        Auction memory auction = _auctions[auctionId];\\n        startingPrice = auction.startingPrice;\\n        decreasingConstant = auction.decreasingConstant;\\n        start = auction.start;\\n        period = auction.period;\\n        active = start > 0 && block.timestamp >= start;\\n    }\\n\\n    function setAuction(\\n        uint256 auctionId,\\n        uint256 startingPrice,\\n        uint128 decreasingConstant,\\n        uint64 start,\\n        uint64 period\\n    ) virtual public {\\n        unchecked {\\n            require(startingPrice - decreasingConstant * period <= startingPrice, \\\"setAuction: floor price underflow\\\");\\n        }\\n        _auctions[auctionId] = Auction(startingPrice, decreasingConstant, start, period);\\n    }\\n\\n    function getPrice(uint256 auctionId) virtual public view returns (uint256 price) {\\n        Auction memory auction = _auctions[auctionId];\\n        //only compute correct price if necessary\\n        if (block.timestamp < auction.start) price = auction.startingPrice;\\n        else if (block.timestamp >= auction.start + auction.period) price = auction.startingPrice - auction.period * auction.decreasingConstant;\\n        else price = auction.startingPrice - (auction.decreasingConstant * (block.timestamp - auction.start));\\n    }\\n\\n    function verifyBid(uint256 auctionId) internal returns (uint256) {\\n        Auction memory auction = _auctions[auctionId];\\n        require(auction.start > 0, \\\"AUCTION:NOT CREATED\\\");\\n        require(block.timestamp >= auction.start, \\\"PURCHASE:AUCTION NOT STARTED\\\");\\n        uint256 pricePaid = getPrice(auctionId);\\n        require(msg.value >= pricePaid, \\\"PURCHASE:INCORRECT MSG.VALUE\\\");\\n        if (msg.value - pricePaid > 0) Address.sendValue(payable(msg.sender), msg.value-pricePaid); //refund difference\\n        return pricePaid;\\n    }\\n}\"\r\n    },\r\n    \"src/SaleModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nimport \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\n\\nabstract contract SaleModule is Auth {\\n\\n    struct Sale {\\n        uint128 price;\\n        uint64 start;\\n        uint64 limit;\\n    }\\n\\n    mapping (uint256 => Sale) public sales;\\n    \\n    function createSale(uint256 dropId, uint128 price, uint64 start, uint64 limit) requiresAuth public {\\n        sales[dropId] = Sale(price, start, limit);\\n    }\\n\\n    function flipSaleState(uint256 dropId) requiresAuth public {\\n        sales[dropId].start = sales[dropId].start > 0 ? 0 : type(uint64).max;\\n    }\\n\\n    function _purchase(uint256 dropId, uint256 amount) internal {\\n        Sale memory sale = sales[dropId];\\n        require(block.timestamp >= sale.start, \\\"PURCHASE:SALE INACTIVE\\\");\\n        require(amount <= sale.limit, \\\"PURCHASE:OVER LIMIT\\\");\\n        require(msg.value == amount * sale.price, \\\"PURCHASE:INCORRECT MSG.VALUE\\\");\\n    }\\n}\"\r\n    },\r\n    \"src/WhitelistModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nimport \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/BitMaps.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\nabstract contract WhitelistModule is Auth {\\n    using BitMaps for BitMaps.BitMap;\\n\\n    struct Whitelist {\\n        uint192 price;\\n        uint64 start;\\n        bytes32 merkleRoot;\\n    }\\n\\n    mapping (uint256 => Whitelist) public whitelists;\\n    mapping (uint256 => BitMaps.BitMap) private _claimedWL;\\n\\n    function createWLClaim(uint256 dropId, uint192 price, uint64 start, bytes32 root) requiresAuth public {\\n        whitelists[dropId] = Whitelist(price, start, root);\\n    }\\n\\n    function flipWLState(uint256 dropId) requiresAuth public {\\n        whitelists[dropId].start = whitelists[dropId].start > 0 ? 0 : type(uint64).max;\\n    }\\n\\n    function _purchaseThroughWhitelist(uint256 dropId, uint256 amount, uint256 index, bytes32[] calldata merkleProof) internal{\\n        Whitelist memory whitelist = whitelists[dropId];\\n        require(block.timestamp >= whitelist.start, \\\"WL:INACTIVE\\\");\\n        require(msg.value == whitelist.price * amount, \\\"WL: INVALID MSG.VALUE\\\");\\n        require(!_claimedWL[dropId].get(index), \\\"WL:ALREADY CLAIMED\\\");\\n        bytes32 node = keccak256(abi.encodePacked(msg.sender, amount, index));\\n        require(MerkleProof.verify(merkleProof, whitelist.merkleRoot, node),\\\"WL:INVALID PROOF\\\");\\n        _claimedWL[dropId].set(index);\\n    }\\n\\n    function isWLClaimed(uint256 dropId, uint256 index) public view returns (bool) {\\n        return _claimedWL[dropId].get(index);\\n    }\\n}\"\r\n    },\r\n    \"src/MintpassModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nimport \\\"./interfaces/IQuantumMintPass.sol\\\";\\nimport \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\n\\nabstract contract MintpassModule is Auth {\\n\\n    struct MPClaim {\\n        uint64 mpId;\\n        uint64 start;\\n        uint128 price;\\n    }\\n\\n    mapping (uint256 => MPClaim) public mpClaims;\\n    IQuantumMintPass public mintpass;\\n\\n    function setMintpass(address deployedMP) requiresAuth public {\\n        mintpass = IQuantumMintPass(deployedMP);\\n    }\\n\\n    function createMPClaim(uint256 dropId, uint64 mpId, uint64 start, uint128 price) requiresAuth public {\\n        mpClaims[dropId] = MPClaim(mpId, start, price);\\n    }\\n\\n    function flipMPClaimState(uint256 dropId) requiresAuth public {\\n        mpClaims[dropId].start = mpClaims[dropId].start > 0 ? 0 : type(uint64).max;\\n    }\\n\\n    function _claimWithMintPass(uint256 dropId, uint256 amount) internal {\\n        MPClaim memory mpClaim = mpClaims[dropId];\\n        require(block.timestamp >= mpClaim.start, \\\"MP: CLAIMING INACTIVE\\\");\\n        require(msg.value == amount * mpClaim.price, \\\"MP:WRONG MSG.VALUE\\\");\\n        mintpass.burnFromRedeem(msg.sender, mpClaim.mpId, amount); //burn mintpasses\\n    }\\n}\"\r\n    },\r\n    \"@rari-capital/solmate/src/auth/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n\\n    constructor(address _owner, Authority _authority) {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n        emit AuthorityUpdated(msg.sender, _authority);\\n    }\\n\\n    modifier requiresAuth() {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/BitMaps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/BitMaps.sol)\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\\n * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\\n */\\nlibrary BitMaps {\\n    struct BitMap {\\n        mapping(uint256 => uint256) _data;\\n    }\\n\\n    /**\\n     * @dev Returns whether the bit at `index` is set.\\n     */\\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        return bitmap._data[bucket] & mask != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index` to the boolean `value`.\\n     */\\n    function setTo(\\n        BitMap storage bitmap,\\n        uint256 index,\\n        bool value\\n    ) internal {\\n        if (value) {\\n            set(bitmap, index);\\n        } else {\\n            unset(bitmap, index);\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index`.\\n     */\\n    function set(BitMap storage bitmap, uint256 index) internal {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        bitmap._data[bucket] |= mask;\\n    }\\n\\n    /**\\n     * @dev Unsets the bit at `index`.\\n     */\\n    function unset(BitMap storage bitmap, uint256 index) internal {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        bitmap._data[bucket] &= ~mask;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = _efficientHash(computedHash, proofElement);\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = _efficientHash(proofElement, computedHash);\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"quantum_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mintpass_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"authority_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"splitter_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Purchased\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"auctions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"decreasingConstant\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"period\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimWithMintPass\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"mpId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"}],\"name\":\"createMPClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"limit\",\"type\":\"uint64\"}],\"name\":\"createSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint192\",\"name\":\"price\",\"type\":\"uint192\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"createWLClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"flipLimiterForDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"flipMPClaimState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"flipSaleState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"flipWLState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isWLClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintpass\",\"outputs\":[{\"internalType\":\"contract IQuantumMintPass\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mpClaims\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"mpId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"}],\"name\":\"premint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"privilegedContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"purchaseThroughAuction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"purchaseThroughWhitelist\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quantum\",\"outputs\":[{\"internalType\":\"contract IQuantumArt\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sales\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"limit\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"decreasingConstant\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"period\",\"type\":\"uint64\"}],\"name\":\"setAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployedMP\",\"type\":\"address\"}],\"name\":\"setMintpass\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"name\":\"setPrivilegedContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"splitter_\",\"type\":\"address\"}],\"name\":\"setSplitter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"splitter\",\"outputs\":[{\"internalType\":\"contract IQuantumSplitter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"whitelists\",\"outputs\":[{\"internalType\":\"uint192\",\"name\":\"price\",\"type\":\"uint192\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SalePlatform", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "00000000000000000000000046ac8540d698167fcbb9e846511beb8cf8af9bd80000000000000000000000002fea46fbccb5ee07c293fe500353579895abf7d00000000000000000000000009fef8de6fb60f43079565ece74f235aed225face0000000000000000000000008c1927427eaaca6a64e238544adfb95451cc05a1000000000000000000000000ee4e047036c752db3032dbc3d11ffafad4bed48b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}