{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"Address.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary Address {\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        assembly {\\r\\n            codehash := extcodehash(account)\\r\\n        }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(\\r\\n            address(this).balance \\u003e= amount,\\r\\n            \\\"Address: insufficient balance\\\"\\r\\n        );\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(\\r\\n            success,\\r\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function functionCall(address target, bytes memory data)\\r\\n        internal\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return\\r\\n            functionCallWithValue(\\r\\n                target,\\r\\n                data,\\r\\n                value,\\r\\n                \\\"Address: low-level call with value failed\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(\\r\\n            address(this).balance \\u003e= value,\\r\\n            \\\"Address: insufficient balance for call\\\"\\r\\n        );\\r\\n        return _functionCallWithValue(target, data, value, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 weiValue,\\r\\n        string memory errorMessage\\r\\n    ) private returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\\r\\n            data\\r\\n        );\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"},\"Context.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view returns (address payable) {\\r\\n        return payable(msg.sender);\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.8.1;\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\ninterface IERC20{\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\"},\"IERC20MetaData.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n}\"},\"IUniswapV2Factory.sol\":{\"content\":\" pragma solidity \\u003e=0.5.0;\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(\\r\\n        address indexed token0,\\r\\n        address indexed token1,\\r\\n        address pair,\\r\\n        uint256\\r\\n    );\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB)\\r\\n        external\\r\\n        view\\r\\n        returns (address pair);\\r\\n\\r\\n    function allPairs(uint256) external view returns (address pair);\\r\\n\\r\\n    function allPairsLength() external view returns (uint256);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB)\\r\\n        external\\r\\n        returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n\\r\\n    function setFeeToSetter(address) external;\\r\\n}\"},\"IUniswapV2Pair.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\r\\n pragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n\\r\\n    function symbol() external pure returns (string memory);\\r\\n\\r\\n    function decimals() external pure returns (uint8);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\r\\n    event Burn(\\r\\n        address indexed sender,\\r\\n        uint256 amount0,\\r\\n        uint256 amount1,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint256 amount0In,\\r\\n        uint256 amount1In,\\r\\n        uint256 amount0Out,\\r\\n        uint256 amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\r\\n\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    function getReserves()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint112 reserve0,\\r\\n            uint112 reserve1,\\r\\n            uint32 blockTimestampLast\\r\\n        );\\r\\n\\r\\n    function price0CumulativeLast() external view returns (uint256);\\r\\n\\r\\n    function price1CumulativeLast() external view returns (uint256);\\r\\n\\r\\n    function kLast() external view returns (uint256);\\r\\n\\r\\n    function mint(address to) external returns (uint256 liquidity);\\r\\n\\r\\n    function burn(address to)\\r\\n        external\\r\\n        returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    function swap(\\r\\n        uint256 amount0Out,\\r\\n        uint256 amount1Out,\\r\\n        address to,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    function skim(address to) external;\\r\\n\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\"},\"IUniswapV2Router01.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicensed\\r\\npragma solidity \\u003e=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 amountA,\\r\\n            uint256 amountB,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountETH,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactETHForTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactETH(\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETH(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapETHForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function quote(\\r\\n        uint256 amountA,\\r\\n        uint256 reserveA,\\r\\n        uint256 reserveB\\r\\n    ) external pure returns (uint256 amountB);\\r\\n\\r\\n    function getAmountOut(\\r\\n        uint256 amountIn,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) external pure returns (uint256 amountOut);\\r\\n\\r\\n    function getAmountIn(\\r\\n        uint256 amountOut,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) external pure returns (uint256 amountIn);\\r\\n\\r\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory amounts);\\r\\n\\r\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory amounts);\\r\\n}\"},\"IUniswapV2Router02.sol\":{\"content\":\"pragma solidity \\u003e=0.6.2;\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\nimport \\\"./IUniswapV2Router01.sol\\\";\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountETH);\\r\\n\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n}\"},\"LP.sol\":{\"content\":\"pragma solidity ^0.8.1;\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\nimport \\\"./Verifier.sol\\\";\\r\\nimport \\\"./IUniswapV2Factory.sol\\\";\\r\\n// made by a special little birdy \\r\\ncontract R is Context, Ownable, IERC20Metadata {\\r\\n    using Address for address;\\r\\n\\r\\n    string private _name = \\\"FOUR TWEETY\\\";\\r\\n    string private _symbol = \\\"BLAZEIT\\\";\\r\\n    uint8 private _decimals = 9;\\r\\n    uint256 private _tTotal = 1_000_000_000 * 10**_decimals;\\r\\n    address payable public _marketingWallet;\\r\\n\\r\\n    mapping(address =\\u003e uint256) private _tOwned;\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\r\\n    mapping(address =\\u003e bool) public _isExcludedFromFee;\\r\\n    mapping(address =\\u003e bool) public lpPairs;\\r\\n\\r\\n    struct IFees {\\r\\n        uint256 liquidityFee;\\r\\n        uint256 marketingFee;\\r\\n        uint256 totalFee;\\r\\n    }\\r\\n    IFees public BuyFees;\\r\\n    IFees public SellFees;\\r\\n    IFees public TransferFees;\\r\\n    IFees public MaxFees =\\r\\n        IFees({\\r\\n            liquidityFee: 50,\\r\\n            marketingFee: 50, \\r\\n            totalFee: 100\\r\\n        });\\r\\n    \\r\\n    struct ItxSettings {\\r\\n        uint256 maxTxAmount;\\r\\n        uint256 maxWalletAmount;\\r\\n        bool txLimits;\\r\\n    }\\r\\n\\r\\n    ItxSettings public txSettings;\\r\\n    uint256 constant public taxDivisor = 1000;\\r\\n    uint256 numTokensToSwap;\\r\\n    uint256 lastSwap;\\r\\n    uint256 swapInterval = 30 seconds;\\r\\n    uint256 public sellMultiplier;\\r\\n    uint256 sniperTaxBlocks;\\r\\n    uint256 constant maxSellMultiplier = 3;\\r\\n    uint256 public liquidityFeeAccumulator;\\r\\n    Verify public verifier;\\r\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\r\\n    address public uniswapV2Pair;\\r\\n    bool inSwapAndLiquify;\\r\\n    bool public swapAndLiquifyEnabled;\\r\\n    bool public liquidityOrMarketing;\\r\\n    bool public tradingEnabled;\\r\\n    bool public feesEnabled;\\r\\n    modifier lockTheSwap() {\\r\\n        inSwapAndLiquify = true;\\r\\n        _;\\r\\n        inSwapAndLiquify = false;\\r\\n    }\\r\\n\\r\\n    constructor() {\\r\\n        setWallets(_msgSender());\\r\\n        setTxSettings(11,10,11,10,true);\\r\\n        _tOwned[_msgSender()] = _tTotal;\\r\\n        // IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\r\\n        // IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3);\\r\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n        lpPairs[uniswapV2Pair] = true;\\r\\n        _approve(_msgSender(), address(_uniswapV2Router), type(uint256).max);\\r\\n        _approve(address(this), address(_uniswapV2Router), type(uint256).max);\\r\\n        verifier = new Verifier([address(this), _msgSender(), address(_uniswapV2Router), address(uniswapV2Pair)]);\\r\\n        _isExcludedFromFee[address(this)] = true;\\r\\n        _isExcludedFromFee[_msgSender()] = true;\\r\\n        emit Transfer(address(0), _msgSender(), _tTotal);\\r\\n    }\\r\\n\\r\\n    function setLpPair(address pair, bool enabled) public onlyOwner {\\r\\n        lpPairs[pair] = enabled;\\r\\n        verifier.setLpPair(pair, enabled);\\r\\n    }\\r\\n\\r\\n    function updateVerifier(address token, address router) public onlyOwner {\\r\\n        verifier.updateToken(token);\\r\\n        verifier.updateRouter(router);\\r\\n    }\\r\\n\\r\\n    //return functions\\r\\n\\r\\n    function name() external view override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() external view override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() external view override returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return _tTotal;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _tOwned[account];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function getCoolDownSettings() public view returns(bool buyCooldown, bool sellCooldown, uint256 coolDownTime, uint256 coolDownLimit) {\\r\\n        return verifier.getCoolDownSettings();\\r\\n    }\\r\\n\\r\\n    function getLaunchedAt() public view returns(uint256 launchedAt){\\r\\n        return verifier.getLaunchedAt();\\r\\n    }\\r\\n\\r\\n    function getBlacklistStatus(address account) public view returns(bool) {\\r\\n        return verifier.getBlacklistStatus(account);\\r\\n    }\\r\\n\\r\\n    function limits(address from, address to) private view returns (bool) {\\r\\n        return from != owner()\\r\\n            \\u0026\\u0026 to != owner()\\r\\n            \\u0026\\u0026 tx.origin != owner()\\r\\n            \\u0026\\u0026 !_isExcludedFromFee[from]\\r\\n            \\u0026\\u0026 !_isExcludedFromFee[to]\\r\\n            \\u0026\\u0026 to != address(0xdead)\\r\\n            \\u0026\\u0026 to != address(0)\\r\\n            \\u0026\\u0026 from != address(this);\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool){\\r\\n        _approve(\\r\\n            _msgSender(),\\r\\n            spender,\\r\\n            _allowances[_msgSender()][spender] + (addedValue)\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(\\r\\n            _msgSender(),\\r\\n            spender,\\r\\n            _allowances[_msgSender()][spender] - (subtractedValue)\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Transaction functions\\r\\n    function setTxSettings(uint256 txp, uint256 txd, uint256 mwp, uint256 mwd, bool limit) public onlyOwner {\\r\\n        require((_tTotal * txp) / txd \\u003e= _tTotal / 1000, \\\"Max Transaction must be above 0.1% of total supply.\\\");\\r\\n        require((_tTotal * mwp) / mwd \\u003e= _tTotal / 1000, \\\"Max Wallet must be above 0.1% of total supply.\\\");\\r\\n        uint256 newTx = (_tTotal * txp) / txd;\\r\\n        uint256 newMw = (_tTotal * mwp) / mwd;\\r\\n        txSettings = ItxSettings ({\\r\\n            maxTxAmount: newTx,\\r\\n            maxWalletAmount: newMw,\\r\\n            txLimits: limit\\r\\n        });\\r\\n    }\\r\\n\\r\\n    function setCooldownEnabled(bool onoff, bool offon, uint256 amount) external onlyOwner{\\r\\n        verifier.setCooldownEnabled(onoff,offon);\\r\\n        verifier.setCooldown(amount);\\r\\n    }\\r\\n\\r\\n    // Tax functions\\r\\n\\r\\n    function takeFee(address sender, address receiver, uint256 amount) internal returns (uint256) {\\r\\n        if (_isExcludedFromFee[sender] || _isExcludedFromFee[receiver]) {return amount;}\\r\\n        uint256 totalFee;\\r\\n        if (lpPairs[receiver]) {\\r\\n            if(sellMultiplier \\u003e= 1){\\r\\n                totalFee = SellFees.totalFee * sellMultiplier;\\r\\n            } else {\\r\\n                totalFee = SellFees.totalFee;\\r\\n            }\\r\\n        } else if(lpPairs[sender]){\\r\\n            totalFee = BuyFees.totalFee;\\r\\n        } else {\\r\\n            totalFee = TransferFees.totalFee;\\r\\n        }\\r\\n\\r\\n        if(block.number \\u003c= getLaunchedAt() + sniperTaxBlocks){\\r\\n            totalFee += 500; // Adds 50% tax onto original tax;\\r\\n        }\\r\\n\\r\\n        uint256 feeAmount = (amount * totalFee) / taxDivisor;\\r\\n\\r\\n        _tOwned[address(this)] += feeAmount;\\r\\n        emit Transfer(sender, address(this), feeAmount);\\r\\n        liquidityFeeAccumulator += (feeAmount * (BuyFees.liquidityFee + SellFees.liquidityFee + TransferFees.liquidityFee)) / (BuyFees.totalFee + SellFees.totalFee + TransferFees.totalFee) + (BuyFees.liquidityFee + SellFees.liquidityFee + TransferFees.liquidityFee);\\r\\n        return amount - feeAmount;\\r\\n    }\\r\\n\\r\\n    function FeesEnabled(bool _enabled) public onlyOwner {\\r\\n        feesEnabled = _enabled;\\r\\n        emit areFeesEnabled(_enabled);\\r\\n    }\\r\\n\\r\\n    function decreaseMaxFee(uint256 _liquidityFee, uint256 _marketingFee, bool resetFees) public onlyOwner {\\r\\n        require(_liquidityFee \\u003c= MaxFees.liquidityFee \\u0026\\u0026 _marketingFee \\u003c= MaxFees.marketingFee);\\r\\n        MaxFees = IFees({\\r\\n            liquidityFee: _liquidityFee, \\r\\n            marketingFee: _marketingFee,\\r\\n            totalFee: _liquidityFee + _marketingFee\\r\\n        });\\r\\n        if(resetFees){\\r\\n            setBuyFees(_liquidityFee, _marketingFee);\\r\\n            setSellFees(_liquidityFee, _marketingFee);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setBuyFees(uint256 _liquidityFee, uint256 _marketingFee) public onlyOwner {\\r\\n        require(_liquidityFee \\u003c= MaxFees.liquidityFee \\u0026\\u0026 _marketingFee \\u003c= MaxFees.marketingFee);\\r\\n        BuyFees = IFees({\\r\\n            liquidityFee: _liquidityFee,\\r\\n            marketingFee: _marketingFee,\\r\\n            totalFee: _liquidityFee +\\r\\n                _marketingFee \\r\\n        });\\r\\n    }\\r\\n\\r\\n    function setSellFees(uint256 _liquidityFee, uint256 _marketingFee) public onlyOwner {\\r\\n        require(_liquidityFee \\u003c= MaxFees.liquidityFee \\u0026\\u0026 _marketingFee \\u003c= MaxFees.marketingFee);\\r\\n        SellFees = IFees({\\r\\n            liquidityFee: _liquidityFee,\\r\\n            marketingFee: _marketingFee,\\r\\n            totalFee: _liquidityFee +\\r\\n                _marketingFee \\r\\n        });\\r\\n    }\\r\\n\\r\\n    function setTransferFees(uint256 _liquidityFee, uint256 _marketingFee) public onlyOwner {\\r\\n        require(_liquidityFee \\u003c= MaxFees.liquidityFee \\u0026\\u0026 _marketingFee \\u003c= MaxFees.marketingFee);\\r\\n        TransferFees = IFees({\\r\\n            liquidityFee: _liquidityFee,\\r\\n            marketingFee: _marketingFee,\\r\\n            totalFee: _liquidityFee +\\r\\n                _marketingFee \\r\\n        });\\r\\n    }\\r\\n\\r\\n    function excludeOrIncludeInFee(address account) public onlyOwner {\\r\\n        if(!_isExcludedFromFee[account]){\\r\\n            _isExcludedFromFee[account] = true;\\r\\n            verifier.feeExcluded(account);\\r\\n        } else {\\r\\n            _isExcludedFromFee[account] = false;\\r\\n            verifier.feeIncluded(account);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setSellMultiplier(uint256 SM) external onlyOwner {\\r\\n        require(SM \\u003c= maxSellMultiplier);\\r\\n        sellMultiplier = SM;\\r\\n    }\\r\\n\\r\\n    // wallet function\\r\\n    function setWallets(address payable m) public onlyOwner {\\r\\n        _marketingWallet = payable(m);\\r\\n    }\\r\\n\\r\\n    // blacklist\\r\\n    function setBlacklistStatus(address account, bool blacklisted) external onlyOwner {\\r\\n        verifier.setSniperStatus(account, blacklisted);\\r\\n    }\\r\\n\\r\\n    // contract swap functions\\r\\n    function setNumTokensToSwap( uint256 percent, uint256 divisor) public onlyOwner {\\r\\n        numTokensToSwap = (_tTotal * percent) / divisor;\\r\\n    }\\r\\n\\r\\n    function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {\\r\\n        swapAndLiquifyEnabled = _enabled;\\r\\n        emit SwapAndLiquifyEnabledUpdated(_enabled);\\r\\n    }\\r\\n\\r\\n    //to receive ETH from uniswapV2Router when swapping\\r\\n    receive() external payable {}\\r\\n\\r\\n    function _approve(address owner,address spender,uint256 amount) private {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function clearStuckBalance(uint256 amountPercentage) external onlyOwner {\\r\\n        require(amountPercentage \\u003c= 100);\\r\\n        uint256 amountETH = address(this).balance;\\r\\n        payable(_marketingWallet).transfer(\\r\\n            (amountETH * amountPercentage) / 100\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function clearStuckToken(address to) external onlyOwner {\\r\\n        uint256 _balance = balanceOf(address(this));\\r\\n        _transfer(address(this), to, _balance);\\r\\n    }\\r\\n\\r\\n    function clearStuckTokens(address _token, address _to) external onlyOwner returns (bool _sent) {\\r\\n        require(_token != address(0));\\r\\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\\r\\n        _sent = IERC20(_token).transfer(_to, _contractBalance);\\r\\n    }\\r\\n\\r\\n    function airDropTokens(address[] memory addresses, uint256[] memory amounts) external {\\r\\n        require(addresses.length == amounts.length, \\\"Lengths do not match.\\\");\\r\\n        for (uint8 i = 0; i \\u003c addresses.length; i++) {\\r\\n            require(balanceOf(_msgSender()) \\u003e= amounts[i]);\\r\\n            _transfer(_msgSender(), addresses[i], amounts[i]*10**_decimals);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function swapAndLiquify() private lockTheSwap {\\r\\n        if(liquidityOrMarketing \\u0026\\u0026 liquidityFeeAccumulator \\u003e= numTokensToSwap){\\r\\n            uint256 liquidityTokens = numTokensToSwap / 2;\\r\\n            swapTokensForEth(numTokensToSwap - liquidityTokens);\\r\\n            uint256 toLiquidity = address(this).balance;\\r\\n            addLiquidity(liquidityTokens, toLiquidity);\\r\\n            emit SwapAndLiquify(liquidityTokens, toLiquidity);\\r\\n            liquidityFeeAccumulator -= numTokensToSwap;\\r\\n            if(liquidityFeeAccumulator \\u003c= numTokensToSwap) {\\r\\n                liquidityOrMarketing = false;\\r\\n            }\\r\\n        } else {\\r\\n            swapTokensForEth(numTokensToSwap);\\r\\n            uint256 toMarketing = address(this).balance;\\r\\n            _marketingWallet.transfer(toMarketing);\\r\\n            emit ToMarketing(toMarketing);\\r\\n            if(!liquidityOrMarketing \\u0026\\u0026 liquidityFeeAccumulator \\u003e= numTokensToSwap){\\r\\n                liquidityOrMarketing = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function swapTokensForEth(uint256 tokenAmount) private {\\r\\n        // generate the uniswap pair path of token -\\u003e weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = uniswapV2Router.WETH();\\r\\n\\r\\n        if(_allowances[address(this)][address(uniswapV2Router)] != type(uint256).max) {\\r\\n            _allowances[address(this)][address(uniswapV2Router)] = type(uint256).max;\\r\\n        }\\r\\n        // make the swap\\r\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\r\\n        // approve token transfer to cover all possible scenarios\\r\\n        if(_allowances[address(this)][address(uniswapV2Router)] != type(uint256).max) {\\r\\n            _allowances[address(this)][address(uniswapV2Router)] = type(uint256).max;\\r\\n        }\\r\\n        // add the liquidity\\r\\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            0, // slippage is unavoidable\\r\\n            0, // slippage is unavoidable\\r\\n            owner(),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender,address recipient,uint256 amount) public override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(\\r\\n            sender,\\r\\n            _msgSender(),\\r\\n            _allowances[sender][_msgSender()] - (\\r\\n                amount\\r\\n            )\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setLaunch() internal {\\r\\n        setSellFees(50,50);\\r\\n        setBuyFees(50,50);\\r\\n        FeesEnabled(true);\\r\\n        setTransferFees(5,5);\\r\\n        setNumTokensToSwap(1,1000);\\r\\n        setSwapAndLiquifyEnabled(true);\\r\\n        setTxSettings(1,100,2,100,true);\\r\\n    }\\r\\n    \\r\\n    function checkLaunch(uint256 blockAmount) internal {\\r\\n        verifier.checkLaunch(block.number, true, true, blockAmount);\\r\\n    }\\r\\n\\r\\n    function enableTrading(uint256 blockAmount) public onlyOwner {\\r\\n        require(blockAmount \\u003c= 5);\\r\\n        require(!tradingEnabled);\\r\\n        setLaunch();\\r\\n        sniperTaxBlocks = blockAmount;\\r\\n        checkLaunch(blockAmount);\\r\\n        enableTrading();\\r\\n        emit Launch();\\r\\n    }\\r\\n    \\r\\n    function enableTrading() private {\\r\\n        tradingEnabled = true;\\r\\n    }\\r\\n\\r\\n    function _basicTransfer(address from, address to, uint256 amount) internal returns (bool) {\\r\\n        _tOwned[from] -= amount;\\r\\n        _tOwned[to] += amount;\\r\\n        emit Transfer(from, to, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(address from, address to, uint256 amount) private returns(bool){\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(amount \\u003e 0, \\\"Transfer amount must be greater than zero\\\");\\r\\n        if(inSwapAndLiquify){\\r\\n           return _basicTransfer(from, to, amount);\\r\\n        }\\r\\n        if(limits(from, to)){\\r\\n            if(!tradingEnabled) {\\r\\n                revert();\\r\\n            }\\r\\n            if(tradingEnabled){\\r\\n                if (txSettings.txLimits) {\\r\\n                    if (lpPairs[from] || lpPairs[to]) {\\r\\n                        if(!_isExcludedFromFee[to] \\u0026\\u0026 !_isExcludedFromFee[from]) {\\r\\n                            require(amount \\u003c= txSettings.maxTxAmount);\\r\\n                        }\\r\\n                    }\\r\\n\\r\\n                    if(to != address(uniswapV2Router) \\u0026\\u0026 !lpPairs[to]) {\\r\\n                        if(!_isExcludedFromFee[to]){\\r\\n                            require(balanceOf(to) + amount \\u003c= txSettings.maxWalletAmount);\\r\\n                        }\\r\\n                    }\\r\\n\\r\\n                    if (lpPairs[to]){\\r\\n                        if(swapAndLiquifyEnabled \\u0026\\u0026 !inSwapAndLiquify){\\r\\n                            if(lastSwap + swapInterval \\u003c= block.timestamp){\\r\\n                                if(balanceOf(address(this)) \\u003e numTokensToSwap) {\\r\\n                                    swapAndLiquify();        \\r\\n                                    lastSwap = block.timestamp;\\r\\n                                }\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }        \\r\\n        return _transferCheck(from, to, amount);\\r\\n    }\\r\\n\\r\\n    function _transferCheck(address from, address to, uint256 amount) private returns(bool){\\r\\n        if(tradingEnabled){\\r\\n            if(limits(from, to)) {\\r\\n                verifier.verifyUser(from, to);\\r\\n            }\\r\\n        }\\r\\n        _tOwned[from] -= amount;\\r\\n        uint256 amountSent = feesEnabled \\u0026\\u0026 !_isExcludedFromFee[from] ? takeFee(from, to, amount) : amount;\\r\\n        _tOwned[to] += amountSent;\\r\\n        emit Transfer(from, to, amountSent);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    event ToMarketing(uint256 marketingBalance);\\r\\n    event SwapAndLiquify(uint256 liquidityTokens, uint256 liquidityFees);    \\r\\n    event Launch();\\r\\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\\r\\n    event areFeesEnabled(bool _enabled);\\r\\n\\r\\n}\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.8.1;\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\nimport \\\"./Context.sol\\\";\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n    address private _previousOwner;\\r\\n    uint256 private _lockTime;\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    constructor() {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(\\r\\n            newOwner != address(0),\\r\\n            \\\"Ownable: new owner is the zero address\\\"\\r\\n        );\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"},\"Verifier.sol\":{\"content\":\"pragma solidity ^0.8.1;\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\nimport \\\"./IERC20MetaData.sol\\\";\\r\\nimport \\\"./Verify.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./IUniswapV2Pair.sol\\\";\\r\\nimport \\\"./IUniswapV2Router02.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\n\\r\\ncontract Verifier is Verify{\\r\\n    using Address for address;\\r\\n    mapping (address =\\u003e bool) lpPairs;\\r\\n    mapping(address =\\u003e uint256) private buycooldown;\\r\\n    mapping(address =\\u003e uint256) private sellcooldown;\\r\\n    mapping(address =\\u003e bool) public _isBlacklisted;\\r\\n    mapping(address =\\u003e bool) public _isExcludedFromFee;\\r\\n    address _token;\\r\\n    IUniswapV2Router02 public uniswapV2Router;\\r\\n    modifier onlyToken() {\\r\\n        require(msg.sender == _token); _;\\r\\n    }\\r\\n    struct ILaunch {\\r\\n        uint256 launchedAt;\\r\\n        uint256 antiBlocks;\\r\\n        bool launched;\\r\\n        bool launchProtection;\\r\\n    }\\r\\n    ILaunch public wenLaunch;\\r\\n\\r\\n    struct Icooldown {\\r\\n        bool buycooldownEnabled;\\r\\n        bool sellcooldownEnabled;\\r\\n        uint256 cooldown;\\r\\n        uint256 cooldownLimit;\\r\\n    }\\r\\n    Icooldown public cooldownInfo =\\r\\n        Icooldown({\\r\\n            buycooldownEnabled: true,\\r\\n            sellcooldownEnabled: true,\\r\\n            cooldown: 30 seconds,\\r\\n            cooldownLimit: 60 seconds\\r\\n        });\\r\\n\\r\\n\\r\\n    constructor(address[4] memory addresses) {\\r\\n        uniswapV2Router = IUniswapV2Router02(addresses[2]);\\r\\n        _token = addresses[0];\\r\\n        _isExcludedFromFee[addresses[0]] = true;\\r\\n        _isExcludedFromFee[addresses[1]] = true;\\r\\n        lpPairs[addresses[3]] = true;\\r\\n    }\\r\\n    \\r\\n    function updateToken(address token) external override onlyToken {\\r\\n        _token = token;\\r\\n    }\\r\\n\\r\\n    function updateRouter(address router) external override onlyToken {\\r\\n        uniswapV2Router = IUniswapV2Router02(router);\\r\\n    }\\r\\n\\r\\n    function feeExcluded(address account) external override onlyToken {\\r\\n        _isExcludedFromFee[account] = true;\\r\\n    }\\r\\n\\r\\n    function feeIncluded(address account) external override onlyToken {\\r\\n        _isExcludedFromFee[account] = false;\\r\\n    }\\r\\n\\r\\n    function getCoolDownSettings() public view override returns(bool, bool, uint256, uint256) {\\r\\n        return(cooldownInfo.buycooldownEnabled, cooldownInfo.sellcooldownEnabled, cooldownInfo.cooldown, cooldownInfo.cooldownLimit);\\r\\n    }\\r\\n        \\r\\n    function getBlacklistStatus(address account) external view override returns(bool) {\\r\\n        return _isBlacklisted[account];\\r\\n    }\\r\\n\\r\\n    function setCooldownEnabled(bool onoff, bool offon) external override onlyToken {\\r\\n        cooldownInfo.buycooldownEnabled = onoff;\\r\\n        cooldownInfo.sellcooldownEnabled = offon;\\r\\n    }\\r\\n\\r\\n    function setCooldown(uint256 amount) external override onlyToken {\\r\\n        require(amount \\u003c= cooldownInfo.cooldownLimit);\\r\\n        cooldownInfo.cooldown = amount;\\r\\n    }\\r\\n\\r\\n    function setSniperStatus(address account, bool blacklisted) external override onlyToken {\\r\\n        _setSniperStatus(account, blacklisted);\\r\\n    }\\r\\n\\r\\n    function _setSniperStatus(address account, bool blacklisted) internal {\\r\\n        if(lpPairs[account] || account == address(_token) || account == address(uniswapV2Router) || _isExcludedFromFee[account]) {revert();}\\r\\n        \\r\\n        if (blacklisted == true) {\\r\\n            _isBlacklisted[account] = true;\\r\\n        } else {\\r\\n            _isBlacklisted[account] = false;\\r\\n        }    \\r\\n    }\\r\\n\\r\\n    function getLaunchedAt() external override view returns(uint256 launchedAt){\\r\\n        return wenLaunch.launchedAt;\\r\\n    }\\r\\n\\r\\n    function checkLaunch(uint256 launchedAt, bool launched, bool protection, uint256 blockAmount) external override onlyToken {\\r\\n        wenLaunch.launchedAt = launchedAt;\\r\\n        wenLaunch.launched = launched;\\r\\n        wenLaunch.launchProtection = protection;\\r\\n        wenLaunch.antiBlocks = blockAmount;\\r\\n    }\\r\\n\\r\\n    function setLpPair(address pair, bool enabled) external override onlyToken {\\r\\n        lpPairs[pair] = enabled;\\r\\n    }\\r\\n\\r\\n    function verifyUser(address from, address to) public override onlyToken {\\r\\n        require(!_isBlacklisted[to]);\\r\\n        require(!_isBlacklisted[from]);\\r\\n        if (wenLaunch.launchProtection) {\\r\\n            if (lpPairs[from] \\u0026\\u0026 to != address(uniswapV2Router) \\u0026\\u0026 !_isExcludedFromFee[to]) {\\r\\n                if (block.number \\u003c= wenLaunch.launchedAt + wenLaunch.antiBlocks) {\\r\\n                    _setSniperStatus(to, true);\\r\\n              }\\r\\n            } else {\\r\\n                wenLaunch.launchProtection = false;\\r\\n            }\\r\\n        }\\r\\n        if (lpPairs[from] \\u0026\\u0026 to != address(uniswapV2Router) \\u0026\\u0026 !_isExcludedFromFee[to] \\u0026\\u0026 cooldownInfo.buycooldownEnabled) {\\r\\n            require(buycooldown[to] \\u003c block.timestamp);\\r\\n            buycooldown[to] = block.timestamp + (cooldownInfo.cooldown);\\r\\n            } else if (!lpPairs[from] \\u0026\\u0026 !_isExcludedFromFee[from] \\u0026\\u0026 cooldownInfo.sellcooldownEnabled){\\r\\n                require(sellcooldown[from] \\u003c= block.timestamp);\\r\\n                sellcooldown[from] = block.timestamp + (cooldownInfo.cooldown);\\r\\n            } \\r\\n    }\\r\\n}\"},\"Verify.sol\":{\"content\":\"pragma solidity ^0.8.1;\\r\\n// SPDX-License-Identifier: Unlicensed\\r\\ninterface Verify {\\r\\n    function setSniperStatus(address account, bool blacklisted) external;\\r\\n    function setLpPair(address pair, bool enabled) external;\\r\\n    function verifyUser(address from, address to) external;\\r\\n    function checkLaunch(uint256 launchedAt, bool launched, bool protection, uint256 blockAmount) external;\\r\\n    function feeExcluded(address account) external;\\r\\n    function feeIncluded(address account) external;\\r\\n    function getCoolDownSettings() external view returns(bool buyCooldown, bool sellCooldown, uint256 coolDownTime, uint256 coolDownLimit);\\r\\n    function getBlacklistStatus(address account) external view returns(bool);\\r\\n    function setCooldownEnabled(bool onoff, bool offon) external;\\r\\n    function setCooldown(uint256 amount) external;\\r\\n    function updateToken(address token) external;\\r\\n    function updateRouter(address router) external;\\r\\n    function getLaunchedAt() external view returns(uint256 launchedAt);\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Launch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityFees\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketingBalance\",\"type\":\"uint256\"}],\"name\":\"ToMarketing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"areFeesEnabled\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BuyFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"FeesEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MaxFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SellFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TransferFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketingWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"airDropTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountPercentage\",\"type\":\"uint256\"}],\"name\":\"clearStuckBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"clearStuckToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"clearStuckTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_sent\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"resetFees\",\"type\":\"bool\"}],\"name\":\"decreaseMaxFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockAmount\",\"type\":\"uint256\"}],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeOrIncludeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBlacklistStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCoolDownSettings\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"buyCooldown\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"sellCooldown\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"coolDownTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coolDownLimit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLaunchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"launchedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFeeAccumulator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityOrMarketing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lpPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"blacklisted\",\"type\":\"bool\"}],\"name\":\"setBlacklistStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"}],\"name\":\"setBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"onoff\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"offon\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setCooldownEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setLpPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"divisor\",\"type\":\"uint256\"}],\"name\":\"setNumTokensToSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"}],\"name\":\"setSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"SM\",\"type\":\"uint256\"}],\"name\":\"setSellMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"}],\"name\":\"setTransferFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"txp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mwp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mwd\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"limit\",\"type\":\"bool\"}],\"name\":\"setTxSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"m\",\"type\":\"address\"}],\"name\":\"setWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxDivisor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txSettings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWalletAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"txLimits\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"updateVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"internalType\":\"contract Verify\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "R", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e2f9e7212133a225f9a9f2ebe3614732a477839ff03bb64dc533dbaf2b1b2742"}]}