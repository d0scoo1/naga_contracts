{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.11;\r\n\r\n/// @title ERC165 Interface\r\n/// @dev https://eips.ethereum.org/EIPS/eip-165\r\n/// @author Andreas Bigger <andreas@nascent.xyz>\r\ninterface IERC165 {\r\n    /// @dev Returns if the contract implements the defined interface\r\n    /// @param interfaceId the 4 byte interface signature\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/// @title ERC721 Interface\r\n/// @dev https://eips.ethereum.org/EIPS/eip-721\r\n/// @author Andreas Bigger <andreas@nascent.xyz>\r\ninterface IERC721 is IERC165 {\r\n    /// @dev Emitted when a token is transferred\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    /// @dev Emitted when a token owner approves `approved`\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    /// @dev Emitted when `owner` enables or disables `operator` for all tokens\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    /// @dev Returns the number of tokens owned by `owner`\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /// @dev Returns the owner of token with id `tokenId`\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /// @dev Safely transfers the token with id `tokenId`\r\n    /// @dev Requires the sender to be approved through an `approve` or `setApprovalForAll`\r\n    /// @dev Emits a Transfer Event\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /// @dev Transfers the token with id `tokenId`\r\n    /// @dev Requires the sender to be approved through an `approve` or `setApprovalForAll`\r\n    /// @dev Emits a Transfer Event\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /// @dev Approves `to` to transfer the given token\r\n    /// @dev Approval is reset on transfer\r\n    /// @dev Caller must be the owner or approved\r\n    /// @dev Only one address can be approved at a time\r\n    /// @dev Emits an Approval Event\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /// @dev Returns the address approved for the given token\r\n    function getApproved(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address operator);\r\n\r\n    /// @dev Sets an operator as approved or disallowed for all tokens owned by the caller\r\n    /// @dev Emits an ApprovalForAll Event\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /// @dev Returns if the operator is allowed approved for owner's tokens\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @dev Safely transfers a token with id `tokenId`\r\n    /// @dev Emits a Transfer Event\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n/// Fee Overflow\r\n/// @param sender address that caused the revert\r\n/// @param fee uint256 proposed fee percent\r\nerror FeeOverflow(address sender, uint256 fee);\r\n\r\n/// Non Coordinator\r\n/// @param sender The coordinator impersonator address\r\n/// @param coordinator The expected coordinator address\r\nerror NonCoordinator(address sender, address coordinator);\r\n\r\n/// @title Coordinator\r\n/// @notice Coordinates fees and receivers\r\n/// @author Andreas Bigger <andreas@nascent.xyz>\r\ncontract Coordinator {\r\n    /// @dev This contracts coordinator\r\n    address public coordinator;\r\n\r\n    /// @dev Address of the profit receiver\r\n    address payable public profitReceiver;\r\n\r\n    /// @dev Pack the below variables using uint32 values\r\n    /// @dev Fee paid by bots\r\n    uint32 public botFeeBips;\r\n\r\n    /// @dev The absolute maximum fee in bips (10,000 bips or 100%)\r\n    uint32 public constant MAXIMUM_FEE = 10_000;\r\n\r\n    /// @dev Modifier restricting msg.sender to solely be the coordinatoooor\r\n    modifier onlyCoordinator() {\r\n        if (msg.sender != coordinator) revert NonCoordinator(msg.sender, coordinator);\r\n        _;\r\n    }\r\n\r\n    /// @notice Constructor sets coordinator, profit receiver, and fee in bips\r\n    /// @param _profitReceiver the address of the profit receiver\r\n    /// @param _botFeeBips the fee in bips\r\n    /// @dev The fee cannot be greater than 100%\r\n    constructor(address _profitReceiver, uint32 _botFeeBips) {\r\n        if (botFeeBips > MAXIMUM_FEE) revert FeeOverflow(msg.sender, _botFeeBips);\r\n        coordinator = msg.sender;\r\n        profitReceiver = payable(_profitReceiver);\r\n        botFeeBips = _botFeeBips;\r\n    }\r\n\r\n    /// @notice Coordinator can change the stored Coordinator address\r\n    /// @param newCoordinator The address of the new coordinator\r\n    function changeCoordinator(address newCoordinator) external onlyCoordinator {\r\n        coordinator = newCoordinator;\r\n    }\r\n\r\n    /// @notice The Coordinator can change the address that receives the fee profits\r\n    /// @param newProfitReceiver The address of the new profit receiver\r\n    function changeProfitReceiver(address newProfitReceiver) external onlyCoordinator {\r\n        profitReceiver = payable(newProfitReceiver);\r\n    }\r\n\r\n    /// @notice The Coordinator can change the fee amount in bips\r\n    /// @param newBotFeeBips The unsigned integer representing the new fee amount in bips\r\n    /// @dev The fee cannot be greater than 100%\r\n    function changeBotFeeBips(uint32 newBotFeeBips) external onlyCoordinator {\r\n        if (newBotFeeBips > MAXIMUM_FEE) revert FeeOverflow(msg.sender, newBotFeeBips);\r\n        botFeeBips = newBotFeeBips;\r\n    }\r\n}\r\n\r\n/// Require EOA\r\nerror NonEOA();\r\n\r\n/// Order Out of Bounds\r\n/// @param sender The address of the msg sender\r\n/// @param orderNumber The requested order number for the user (maps to an order id)\r\n/// @param maxOrderCount The maximum number of orders a user has placed\r\nerror OrderOOB(address sender, uint256 orderNumber, uint256 maxOrderCount);\r\n\r\n/// Order Nonexistent\r\n/// @param user The address of the user who owns the order\r\n/// @param orderNumber The requested order number for the user (maps to an order id)\r\n/// @param orderId The order's Id\r\nerror OrderNonexistent(address user, uint256 orderNumber, uint256 orderId);\r\n\r\n/// Invalid Amount\r\n/// @param sender The address of the msg sender\r\n/// @param priceInWeiEach The order's priceInWeiEach\r\n/// @param quantity The order's quantity\r\n/// @param tokenAddress The order's token address\r\nerror InvalidAmount(address sender, uint256 priceInWeiEach, uint256 quantity, address tokenAddress);\r\n\r\n/// Insufficient price in wei\r\n/// @param sender The address of the msg sender\r\n/// @param orderId The order's Id\r\n/// @param tokenId The ERC721 Token ID\r\n/// @param expectedPriceInWeiEach The expected priceInWeiEach\r\n/// @param priceInWeiEach The order's actual priceInWeiEach from internal store\r\nerror InsufficientPrice(address sender, uint256 orderId, uint256 tokenId, uint256 expectedPriceInWeiEach, uint256 priceInWeiEach);\r\n\r\n/// Inconsistent Arguments\r\n/// @param sender The address of the msg sender\r\nerror InconsistentArguments(address sender);\r\n\r\n/// @title YobotERC721LimitOrder\r\n/// @author Andreas Bigger <andreas@nascent.xyz>\r\n/// @notice Original contract implementation was open-sourced and verified on etherscan at:\r\n///         https://etherscan.io/address/0x56E6FA0e461f92644c6aB8446EA1613F4D72a756#code\r\n///         with the original UI at See ArtBotter.io\r\n/// @notice Permissionless Broker for Generalized ERC721 Minting using Flashbot Searchers\r\ncontract YobotERC721LimitOrder is Coordinator {\r\n    /// @notice A user's order\r\n    struct Order {\r\n        /// @dev The Order owner\r\n        address owner;\r\n        /// @dev The Order's Token Address\r\n        address tokenAddress;\r\n        /// @dev the price to pay for each erc721 token\r\n        uint256 priceInWeiEach;\r\n        /// @dev the quantity of tokens to pay\r\n        uint256 quantity;\r\n        /// @dev the order number for the user, used for reverse mapping\r\n        uint256 num;\r\n    }\r\n\r\n    /// @dev Current Order Id\r\n    /// @dev Starts at 1, 0 is a deleted order\r\n    uint256 public orderId = 1;\r\n\r\n    /// @dev Mapping from order id to an Order\r\n    mapping(uint256 => Order) public orderStore;\r\n\r\n    /// @dev user => order number => order id\r\n    mapping(address => mapping(uint256 => uint256)) public userOrders;\r\n\r\n    /// @dev The number of user orders\r\n    mapping(address => uint256) public userOrderCount;\r\n\r\n    /// @dev bot => eth balance\r\n    mapping(address => uint256) public balances;\r\n\r\n    /// @notice Emitted whenever a respective individual executes a function\r\n    /// @param _user the address of the sender executing the action - used primarily for indexing\r\n    /// @param _tokenAddress The token address to interact with\r\n    /// @param _priceInWeiEach The bid price in wei for each ERC721 Token\r\n    /// @param _quantity The number of tokens\r\n    /// @param _action The action being emitted\r\n    /// @param _orderId The order's id\r\n    /// @param _orderNum The user<>num order\r\n    /// @param _tokenId The optional token id (used primarily on bot fills)\r\n    event Action(\r\n        address indexed _user,\r\n        address indexed _tokenAddress,\r\n        uint256 indexed _priceInWeiEach,\r\n        uint256 _quantity,\r\n        string _action,\r\n        uint256 _orderId,\r\n        uint256 _orderNum,\r\n        uint256 _tokenId\r\n    );\r\n\r\n    /// @notice Creates a new yobot erc721 limit order broker\r\n    /// @param _profitReceiver The profit receiver for fees\r\n    /// @param _botFeeBips The fee rake\r\n    // solhint-disable-next-line no-empty-blocks\r\n    constructor(address _profitReceiver, uint32 _botFeeBips) Coordinator(_profitReceiver, _botFeeBips) {}\r\n\r\n    ////////////////////////////////////////////////////\r\n    ///                     ORDERS                   ///\r\n    ////////////////////////////////////////////////////\r\n\r\n    /// @notice places an open order for a user\r\n    /// @notice users should place orders ONLY for token addresses that they trust\r\n    /// @param _tokenAddress the erc721 token address\r\n    /// @param _quantity the number of tokens\r\n    function placeOrder(address _tokenAddress, uint256 _quantity) external payable {\r\n        // Removes user foot-guns and garuantees user can receive NFTs\r\n        // We disable linting against tx-origin to purposefully allow EOA checks\r\n        // solhint-disable-next-line avoid-tx-origin\r\n        if (msg.sender != tx.origin) revert NonEOA();\r\n\r\n        // Check to make sure the bids are gt zero\r\n        uint256 priceInWeiEach = msg.value / _quantity;\r\n        if (priceInWeiEach == 0 || _quantity == 0) revert InvalidAmount(msg.sender, priceInWeiEach, _quantity, _tokenAddress);\r\n\r\n        // Update the Order Id\r\n        uint256 currOrderId = orderId;\r\n        orderId += 1;\r\n\r\n        // Get the current order number for the user\r\n        uint256 currUserOrderCount = userOrderCount[msg.sender];\r\n\r\n        // Create a new Order\r\n        orderStore[currOrderId].owner = msg.sender;\r\n        orderStore[currOrderId].tokenAddress = _tokenAddress;\r\n        orderStore[currOrderId].priceInWeiEach = priceInWeiEach;\r\n        orderStore[currOrderId].quantity = _quantity;\r\n        orderStore[currOrderId].num = currUserOrderCount;\r\n\r\n        // Update the user's orders\r\n        userOrders[msg.sender][currUserOrderCount] = currOrderId;\r\n        userOrderCount[msg.sender] += 1;\r\n\r\n        emit Action(msg.sender, _tokenAddress, priceInWeiEach, _quantity, \"ORDER_PLACED\", currOrderId, currUserOrderCount, 0);\r\n    }\r\n\r\n    /// @notice Cancels a user's order for the given erc721 token\r\n    /// @param _orderNum The user's order number\r\n    function cancelOrder(uint256 _orderNum) external {\r\n        // Check to make sure the user's order is in bounds\r\n        uint256 currUserOrderCount = userOrderCount[msg.sender];\r\n        if (_orderNum >= currUserOrderCount) revert OrderOOB(msg.sender, _orderNum, currUserOrderCount);\r\n\r\n        // Get the id for the given user order num\r\n        uint256 currOrderId = userOrders[msg.sender][_orderNum];\r\n        \r\n        // Revert if the order id is 0, already deleted or filled\r\n        if (currOrderId == 0) revert OrderNonexistent(msg.sender, _orderNum, currOrderId);\r\n\r\n        // Get the order\r\n        Order memory order = orderStore[currOrderId];\r\n        uint256 amountToSendBack = order.priceInWeiEach * order.quantity;\r\n        if (amountToSendBack == 0) revert InvalidAmount(msg.sender, order.priceInWeiEach, order.quantity, order.tokenAddress);\r\n\r\n        // Delete the order\r\n        delete orderStore[currOrderId];\r\n\r\n        // Delete the order id from the userOrders mapping\r\n        delete userOrders[msg.sender][_orderNum];\r\n\r\n        // Send the value back to the user\r\n        sendValue(payable(msg.sender), amountToSendBack);\r\n\r\n        emit Action(msg.sender, order.tokenAddress, order.priceInWeiEach, order.quantity, \"ORDER_CANCELLED\", currOrderId, _orderNum, 0);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////\r\n    ///                  BOT LOGIC                   ///\r\n    ////////////////////////////////////////////////////\r\n\r\n    /// @notice Fill a single order\r\n    /// @param _orderId The id of the order\r\n    /// @param _tokenId the token id to mint\r\n    /// @param _expectedPriceInWeiEach the price to pay\r\n    /// @param _profitTo the address to send the fee to\r\n    /// @param _sendNow whether or not to send the fee now\r\n    function fillOrder(\r\n        uint256 _orderId,\r\n        uint256 _tokenId,\r\n        uint256 _expectedPriceInWeiEach,\r\n        address _profitTo,\r\n        bool _sendNow\r\n    ) public returns (uint256) {\r\n        Order storage order = orderStore[_orderId];\r\n\r\n        // Make sure the order isn't deleted\r\n        uint256 orderIdFromMap = userOrders[order.owner][order.num];\r\n        if (order.quantity == 0 || order.priceInWeiEach == 0 || orderIdFromMap == 0) revert InvalidAmount(order.owner, order.priceInWeiEach, order.quantity, order.tokenAddress);\r\n\r\n        // Protects bots from users frontrunning them\r\n        if (order.priceInWeiEach < _expectedPriceInWeiEach) revert InsufficientPrice(msg.sender, _orderId, _tokenId, _expectedPriceInWeiEach, order.priceInWeiEach);\r\n\r\n        // Transfer NFT to user (benign reentrancy possible here)\r\n        // ERC721-compliant contracts revert on failure here\r\n        IERC721(order.tokenAddress).safeTransferFrom(msg.sender, order.owner, _tokenId);\r\n        \r\n        // This reverts on underflow\r\n        order.quantity -= 1;\r\n        uint256 botFee = (order.priceInWeiEach * botFeeBips) / 10_000;\r\n        balances[profitReceiver] += botFee;\r\n\r\n        // Pay the bot with the remaining amount\r\n        uint256 botPayment = order.priceInWeiEach - botFee;\r\n        if (_sendNow) {\r\n            sendValue(payable(_profitTo), botPayment);\r\n        } else {\r\n            balances[_profitTo] += botPayment;\r\n        }\r\n\r\n        // Emit the action later so we can log trace on a bot dashboard\r\n        emit Action(order.owner, order.tokenAddress, order.priceInWeiEach, order.quantity, \"ORDER_FILLED\", _orderId, order.num, _tokenId);\r\n\r\n        // Clear up if the quantity is now 0\r\n        if (order.quantity == 0) {\r\n            delete orderStore[_orderId];\r\n            userOrders[order.owner][order.num] = 0;\r\n        }\r\n\r\n        // RETURN\r\n        return botPayment;\r\n    }\r\n\r\n    /// @notice allows a bot to fill multiple outstanding orders\r\n    /// @dev there should be one token id and token price specified for each users\r\n    /// @dev So, _users.length == _tokenIds.length == _expectedPriceInWeiEach.length\r\n    /// @param _orderIds a list of order ids\r\n    /// @param _tokenIds a list of token ids\r\n    /// @param _expectedPriceInWeiEach the price of each token\r\n    /// @param _profitTo the address to send the bot's profit to\r\n    /// @param _sendNow whether the profit should be sent immediately\r\n    function fillMultipleOrdersOptimized(\r\n        uint256[] memory _orderIds,\r\n        uint256[] memory _tokenIds,\r\n        uint256[] memory _expectedPriceInWeiEach,\r\n        address _profitTo,\r\n        bool _sendNow\r\n    ) external returns (uint256[] memory) {\r\n        if (_orderIds.length != _tokenIds.length || _tokenIds.length != _expectedPriceInWeiEach.length) revert InconsistentArguments(msg.sender);\r\n        uint256[] memory output = new uint256[](_orderIds.length);\r\n        for (uint256 i = 0; i < _orderIds.length; i++) {\r\n            output[i] = fillOrder(_orderIds[i], _tokenIds[i], _expectedPriceInWeiEach[i], _profitTo, _sendNow);\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /// @notice allows a bot to fill multiple outstanding orders with\r\n    /// @dev all argument array lengths should be equal\r\n    /// @param _orderIds a list of order ids\r\n    /// @param _tokenIds a list of token ids\r\n    /// @param _expectedPriceInWeiEach the price of each token\r\n    /// @param _profitTo the addresses to send the bot's profit to\r\n    /// @param _sendNow whether the profit should be sent immediately\r\n    function fillMultipleOrdersUnOptimized(\r\n        uint256[] memory _orderIds,\r\n        uint256[] memory _tokenIds,\r\n        uint256[] memory _expectedPriceInWeiEach,\r\n        address[] memory _profitTo,\r\n        bool[] memory _sendNow\r\n    ) external returns (uint256[] memory) {\r\n        if (\r\n            _orderIds.length != _tokenIds.length\r\n            || _tokenIds.length != _expectedPriceInWeiEach.length\r\n            || _expectedPriceInWeiEach.length != _profitTo.length\r\n            || _profitTo.length != _sendNow.length\r\n        ) revert InconsistentArguments(msg.sender);\r\n\r\n        // Fill the orders iteratively\r\n        uint256[] memory output = new uint256[](_orderIds.length);\r\n        for (uint256 i = 0; i < _orderIds.length; i++) {\r\n            output[i] = fillOrder(_orderIds[i], _tokenIds[i], _expectedPriceInWeiEach[i], _profitTo[i], _sendNow[i]);\r\n        }\r\n        return output;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////\r\n    ///                 WITHDRAWALS                  ///\r\n    ////////////////////////////////////////////////////\r\n\r\n    /// @notice Allows profitReceiver and bots to withdraw their fees\r\n    /// @dev delete balances on withdrawal to free up storage\r\n    function withdraw() external {\r\n        // EFFECTS\r\n        uint256 amount = balances[msg.sender];\r\n        delete balances[msg.sender];\r\n        // INTERACTIONS\r\n        sendValue(payable(msg.sender), amount);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////\r\n    ///                   HELPERS                    ///\r\n    ////////////////////////////////////////////////////\r\n\r\n    /// @notice sends ETH out of this contract to the recipient\r\n    /// @dev OpenZeppelin's sendValue function\r\n    /// @param recipient the recipient to send the ETH to | payable\r\n    /// @param amount the amount of ETH to send\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /// @notice Returns an open order for a user and order number pair\r\n    /// @param _user The user\r\n    /// @param _orderNum The order number (NOT ID)\r\n    function viewUserOrder(address _user, uint256 _orderNum) public view returns (Order memory) {\r\n        // Revert if the order id is 0\r\n        uint256 _orderId = userOrders[_user][_orderNum];\r\n        if (_orderId == 0) revert OrderNonexistent(_user, _orderNum, _orderId);\r\n        return orderStore[_orderId];\r\n    }\r\n\r\n    /// @notice Returns all open orders for a given user\r\n    /// @param _user The user\r\n    function viewUserOrders(address _user) public view returns (Order[] memory output) {\r\n        uint256 _userOrderCount = userOrderCount[_user];\r\n        output = new Order[](_userOrderCount);\r\n        for (uint256 i = 0; i < _userOrderCount; i += 1) {\r\n            uint256 _orderId = userOrders[_user][i];\r\n            output[i] = orderStore[_orderId]; \r\n        }\r\n    }\r\n\r\n    /// @notice Returns the open orders for a list of users\r\n    /// @param _users the users address\r\n    function viewMultipleOrders(address[] memory _users) public view returns (Order[][] memory output) {\r\n        Order[][] memory output = new Order[][](_users.length);\r\n        for (uint256 i = 0; i < _users.length; i++) {\r\n            output[i] = viewUserOrders(_users[i]);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_profitReceiver\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_botFeeBips\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FeeOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"InconsistentArguments\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedPriceInWeiEach\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceInWeiEach\",\"type\":\"uint256\"}],\"name\":\"InsufficientPrice\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"priceInWeiEach\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coordinator\",\"type\":\"address\"}],\"name\":\"NonCoordinator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NonEOA\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"orderNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"OrderNonexistent\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"orderNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxOrderCount\",\"type\":\"uint256\"}],\"name\":\"OrderOOB\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_priceInWeiEach\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_action\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_orderNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Action\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAXIMUM_FEE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"botFeeBips\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderNum\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newBotFeeBips\",\"type\":\"uint32\"}],\"name\":\"changeBotFeeBips\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCoordinator\",\"type\":\"address\"}],\"name\":\"changeCoordinator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newProfitReceiver\",\"type\":\"address\"}],\"name\":\"changeProfitReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coordinator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_orderIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_expectedPriceInWeiEach\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_profitTo\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_sendNow\",\"type\":\"bool\"}],\"name\":\"fillMultipleOrdersOptimized\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_orderIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_expectedPriceInWeiEach\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_profitTo\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_sendNow\",\"type\":\"bool[]\"}],\"name\":\"fillMultipleOrdersUnOptimized\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expectedPriceInWeiEach\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_profitTo\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_sendNow\",\"type\":\"bool\"}],\"name\":\"fillOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderStore\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"priceInWeiEach\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"placeOrder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitReceiver\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userOrderCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userOrders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"viewMultipleOrders\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"priceInWeiEach\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"internalType\":\"struct YobotERC721LimitOrder.Order[][]\",\"name\":\"output\",\"type\":\"tuple[][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_orderNum\",\"type\":\"uint256\"}],\"name\":\"viewUserOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"priceInWeiEach\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"internalType\":\"struct YobotERC721LimitOrder.Order\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserOrders\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"priceInWeiEach\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"internalType\":\"struct YobotERC721LimitOrder.Order[]\",\"name\":\"output\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "YobotERC721LimitOrder", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c9ab63915c6738c8ce5ca245979203bfa3f2499f00000000000000000000000000000000000000000000000000000000000001f4", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://df8c25e0bf021034fee90fc9247dfc99b158529db50301439d3173355d4874bd"}]}