{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/C/Users/nejcs/Desktop/JOB/seascape-smartcontracts/contracts/nft_swap/swap_params/ScapeSwapParams.sol\": {\r\n      \"content\": \"pragma solidity 0.6.7;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./../SwapSigner.sol\\\";\\n\\n/// @title ScapeSwapParams is nft params encoder/decoder, signature verifyer\\n/// @author Nejc Schneider\\ncontract ScapeSwapParams {\\n    SwapSigner private swapSigner;\\n\\n    constructor(address _signerAddress) public {\\n        swapSigner = SwapSigner(_signerAddress);\\n    }\\n\\n    // takes in _encodedData and converts to seascape\\n    function paramsAreValid (uint256 _offerId, bytes memory _encodedData,\\n      uint8 v, bytes32 r, bytes32 s) public view returns (bool){\\n\\n      (uint256 imgId, uint256 generation, uint8 quality) = decodeParams(_encodedData);\\n\\n      bytes32 hash = this.encodeParams(_offerId, imgId, generation, quality);\\n\\n      address recover = ecrecover(hash, v, r, s);\\n      require(recover == swapSigner.getSigner(),  \\\"Verification failed\\\");\\n\\n    \\treturn true;\\n    }\\n\\n    function encodeParams(\\n        uint256 _offerId,\\n        uint256 _imgId,\\n        uint256 _generation,\\n        uint8 _quality\\n    )\\n        public\\n        view\\n        returns (bytes32 message)\\n    {\\n        bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\n        bytes32 messageNoPrefix = keccak256(abi\\n            .encode(_offerId, _imgId, _generation, _quality));\\n        bytes32 hash = keccak256(abi.encodePacked(prefix, messageNoPrefix));\\n\\n        return hash;\\n    }\\n\\n    function decodeParams (bytes memory _encodedData)\\n        public\\n        view\\n        returns (\\n            uint256 imgId,\\n            uint256 generation,\\n            uint8 quality\\n        )\\n    {\\n        (uint256 imgId, uint256 generation, uint8 quality) = abi\\n            .decode(_encodedData, (uint256, uint256, uint8));\\n\\n        return (imgId, generation, quality);\\n    }\\n\\n\\n}\\n\"\r\n    },\r\n    \"/C/Users/nejcs/Desktop/JOB/seascape-smartcontracts/contracts/openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"/C/Users/nejcs/Desktop/JOB/seascape-smartcontracts/contracts/openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"/C/Users/nejcs/Desktop/JOB/seascape-smartcontracts/contracts/nft_swap/SwapSigner.sol\": {\r\n      \"content\": \"pragma solidity 0.6.7;\\r\\n\\r\\nimport \\\"./../openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\n/// @title SwapSigner holds address for signature verification.\\r\\n/// It is used by NftSwap and SwapParams contracts.\\r\\n/// @author Nejc Schneider\\r\\ncontract SwapSigner is Ownable {\\r\\n\\r\\n    address public signer;         // @dev verify v, r, s signature\\r\\n\\r\\n    constructor() public { signer = msg.sender; }\\r\\n\\r\\n    /// @notice change address to verify signature against\\r\\n    /// @param _signer new signer address\\r\\n    function setSigner(address _signer) external onlyOwner {\\r\\n        require(_signer != address(0), \\\"invalid signer address\\\");\\r\\n        signer = _signer;\\r\\n    }\\r\\n\\r\\n    /// @notice returns verifier of signatures\\r\\n    /// @return signer address\\r\\n    function getSigner() external view returns(address) { return signer; }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_encodedData\",\"type\":\"bytes\"}],\"name\":\"decodeParams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"imgId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generation\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"quality\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_imgId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_generation\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_quality\",\"type\":\"uint8\"}],\"name\":\"encodeParams\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"message\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_encodedData\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"paramsAreValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ScapeSwapParams", "CompilerVersion": "v0.6.7+commit.b8d736ae", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000029c447b64a580088fc34cd4601aa8334914ecec7", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}