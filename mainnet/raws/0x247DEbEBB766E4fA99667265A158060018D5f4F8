{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: node_modules\\@openzeppelin\\contracts\\introspection\\IERC165.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\introspection\\ERC165.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts may inherit from this and call {_registerInterface} to declare\r\n * their support of an interface.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    /*\r\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /**\r\n     * @dev Mapping of interface ids to whether or not it's supported.\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n        // Derived contracts need only register support for their own interfaces,\r\n        // we register support for ERC165 itself here\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     *\r\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev Registers the contract as an implementer of the interface defined by\r\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\r\n     * registering its interface id is not required.\r\n     *\r\n     * See {IERC165-supportsInterface}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: contracts\\IRegistry.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n  * @title Open registry for management of AI services run on SingularityNET\r\n  * @author SingularityNET\r\n  *\r\n  */\r\ninterface IRegistry {\r\n\r\n    //    ___                        _          _   _                   __  __                 _\r\n    //   / _ \\ _ __ __ _  __ _ _ __ (_)______ _| |_(_) ___  _ __       |  \\/  | __ _ _ __ ___ | |_\r\n    //  | | | | '__/ _` |/ _` | '_ \\| |_  / _` | __| |/ _ \\| '_ \\      | |\\/| |/ _` | '_ ` _ \\| __|\r\n    //  | |_| | | | (_| | (_| | | | | |/ / (_| | |_| | (_) | | | |     | |  | | (_| | | | | | | |_\r\n    //   \\___/|_|  \\__, |\\__,_|_| |_|_/___\\__,_|\\__|_|\\___/|_| |_|     |_|  |_|\\__, |_| |_| |_|\\__|\r\n    //             |___/                                                       |___/\r\n\r\n    event OrganizationCreated (bytes32 indexed orgId);\r\n    event OrganizationModified(bytes32 indexed orgId);\r\n    event OrganizationDeleted (bytes32 indexed orgId);\r\n\r\n    /**\r\n      * @dev Adds a new organization that hosts SingularityNET services to the registry.\r\n      *      Reverts if the given organization Id has already been registered.\r\n      *\r\n      * @param orgId    Id of organization to create, must be unique registry-wide.\r\n      * @param orgMetadataURI  MetadataURI of organization to create, must be unique registry-wide.\r\n      * @param members  Array of member addresses to seed the organization with.\r\n      */\r\n    function createOrganization(bytes32 orgId, bytes calldata orgMetadataURI, address[] calldata members) external;\r\n\r\n    /**\r\n      * @dev Updates the owner of the organization.\r\n      *      Only the organization owner can invoke this method.\r\n      *      Reverts if the given organization Id is unregistered.\r\n      *\r\n      * @param orgId     Id of organization to update.\r\n      * @param newOwner  Address of new owner.\r\n      */\r\n    function changeOrganizationOwner(bytes32 orgId, address newOwner) external;\r\n\r\n    /**\r\n      * @dev Updates the name of the organization.\r\n      *      Only the organization owner can invoke this method.\r\n      *      Reverts if the given organization Id is unregistered.\r\n      *\r\n      * @param orgId     Id of organization to update.\r\n      * @param orgMetadataURI   Name of the organization.\r\n      */\r\n    function changeOrganizationMetadataURI(bytes32 orgId, bytes calldata orgMetadataURI) external;\r\n\r\n    /**\r\n      * @dev Updates an organization to add members.\r\n      *      Only an organization member can invoke this method.\r\n      *      Reverts if the given organization Id is unregistered.\r\n      *\r\n      * @param orgId     Id of organization to update.\r\n      * @param newMembers  Array of member addresses to add to an organization.\r\n      */\r\n    function addOrganizationMembers(bytes32 orgId, address[] calldata newMembers) external;\r\n\r\n    /**\r\n      * @dev Updates an organization to remove members.\r\n      *      Only an organization member can invoke this method.\r\n      *      Reverts if the given organization Id is unregistered.\r\n      *\r\n      * @param orgId          Id of organization to update.\r\n      * @param existingMembers  Array of member addresses to remove from an organization.\r\n      */\r\n    function removeOrganizationMembers(bytes32 orgId, address[] calldata existingMembers) external;\r\n\r\n    /**\r\n      * @dev Removes an organization from the registry.\r\n      *      Only the organization owner can invoke this method.\r\n      *      Reverts if the given organization Id is unregistered\r\n      *\r\n      * @param orgId               Id of organization to remove.\r\n      */\r\n    function deleteOrganization(bytes32 orgId) external;\r\n\r\n\r\n    //   ____                  _                __  __                 _\r\n    //  / ___|  ___ _ ____   ___) ___ ___      |  \\/  | __ _ _ __ ___ | |_\r\n    //  \\___ \\ / _ \\ '__\\ \\ / / |/ __/ _ \\     | |\\/| |/ _` | '_ ` _ \\| __|\r\n    //   ___) |  __/ |   \\ V /| | (__  __/     | |  | | (_| | | | | | | |_\r\n    //  |____/ \\___|_|    \\_/ |_|\\___\\___|     |_|  |_|\\__, |_| |_| |_|\\__|\r\n    //                                                 |___/\r\n\r\n    event ServiceCreated         (bytes32 indexed orgId, bytes32 indexed serviceId, bytes metadataURI);\r\n    event ServiceMetadataModified(bytes32 indexed orgId, bytes32 indexed serviceId, bytes metadataURI);\r\n    event ServiceTagsModified    (bytes32 indexed orgId, bytes32 indexed serviceId);\r\n    event ServiceDeleted         (bytes32 indexed orgId, bytes32 indexed serviceId);\r\n\r\n    /**\r\n      * @dev Adds a new service to the registry.\r\n      *      Only a member of the given organization can invoke this method.\r\n      *      Reverts if the given organization does not exist or if the given service id has already been registered.\r\n      *\r\n      * @param orgId         Id of SingularityNET organization that owns this service.\r\n      * @param serviceId     Id of the service to create, must be unique organization-wide.\r\n      * @param metadataURI   Service metadata. metadataURI should contain information for data consistency \r\n      *                      validation (for example hash). We support: IPFS URI.\r\n      */\r\n    function createServiceRegistration(bytes32 orgId, bytes32 serviceId, bytes calldata metadataURI) external;\r\n\r\n    /**\r\n      * @dev Updates a service registration record.\r\n      *      Only a member of the given organization can invoke this method.\r\n      *      Reverts if the given organization or service does not exist.\r\n      *\r\n      * @param orgId          Id of SingularityNET organization that owns this service.\r\n      * @param serviceId     Id of the service to update.\r\n      * @param metadataURI   Service metadata URI\r\n      */\r\n    function updateServiceRegistration(bytes32 orgId, bytes32 serviceId, bytes calldata metadataURI) external;\r\n\r\n\r\n    /**\r\n      * @dev Removes a service from the registry.\r\n      *      Only the owner of the given organization can invoke this method.\r\n      *      Reverts if the given organization or service does not exist.\r\n      *\r\n      * @param orgId       Id of SingularityNET organization that owns this service.\r\n      * @param serviceId   Id of the service to remove.\r\n      */\r\n    function deleteServiceRegistration(bytes32 orgId, bytes32 serviceId) external;\r\n\r\n\r\n    //    ____      _   _\r\n    //   / ___| ___| |_| |_ ___ _ __ ___\r\n    //  | |  _ / _ \\ __| __/ _ \\ '__/ __|\r\n    //  | |_| |  __/ |_| |_  __/ |  \\__ \\\r\n    //   \\____|\\___|\\__|\\__\\___|_|  |___/\r\n    //\r\n\r\n    /**\r\n      * @dev Returns an array of Ids of all registered organizations.\r\n      *\r\n      * @return orgIds Array of Ids of all registered organizations.\r\n      */\r\n    function listOrganizations() external view returns (bytes32[] memory orgIds);\r\n\r\n    /**\r\n      * @dev Retrieves the detailed registration information of a single organization.\r\n      *\r\n      * @param orgId            Id of the organization to look up.\r\n      * @return found           true if an organization with this id exists, false otherwise. If false, all other\r\n      *                         returned fields should be ignored.\r\n      * @return id              Id of organization, should be the same as the orgId parameter.\r\n      * @return orgMetadataURI  Organization Metadata URI\r\n      * @return owner           Address of the owner of the organization.\r\n      * @return members         Array of addresses of the members of this organization.\r\n      * @return serviceIds      Array of ids of services owned by the organization.\r\n      */\r\n    function getOrganizationById(bytes32 orgId) external view\r\n            returns (bool found, bytes32 id, bytes memory orgMetadataURI, address owner, address[] memory members, bytes32[] memory serviceIds);\r\n\r\n    /**\r\n      * @dev Returns an array of ids of all services owned by a given organization.\r\n      *\r\n      * @param orgId          Id of the organization whose services to list.\r\n      *\r\n      * @return found         true if an organization with this id exists, false otherwise. If false, all other\r\n      *                       returned fields should be ignored.\r\n      * @return serviceIds    Array of ids of all services owned by this organization.\r\n      */\r\n    function listServicesForOrganization(bytes32 orgId) external view returns (bool found, bytes32[] memory serviceIds);\r\n\r\n    /**\r\n      * @dev Retrieves the detailed registration information of a single service.\r\n      *\r\n      * @param orgId         Id of the organization that owns the service to look up.\r\n      * @param serviceId     Id of the service to look up.\r\n      *\r\n      * @return found        true if an organization and service with these ids exists, false otherwise. If false, all other\r\n      *                      returned fields should be ignored.\r\n      * @return id           Id of the service, should be the same as the serviceId parameter.\r\n      * @return metadataURI  Service metadata URI\r\n      */\r\n    function getServiceRegistrationById(bytes32 orgId, bytes32 serviceId) external view\r\n            returns (bool found, bytes32 id, bytes memory metadataURI);\r\n\r\n}\r\n\r\n// File: contracts\\Registry.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n\r\ncontract Registry is IRegistry, ERC165 {\r\n\r\n    struct OrganizationRegistration {\r\n        bytes32 organizationId;\r\n        bytes orgMetadataURI;\r\n        address owner;\r\n\r\n        // member indexing note:\r\n        // case (members[someAddress]) of\r\n        //   0 -> not a member of this org\r\n        //   n -> member of this org, and memberKeys[n-1] == someAddress\r\n        address[] memberKeys;\r\n        mapping(address => uint) members;\r\n\r\n        bytes32[] serviceKeys;\r\n        mapping(bytes32 => ServiceRegistration) servicesById;\r\n\r\n        uint globalOrgIndex;\r\n    }\r\n\r\n    struct ServiceRegistration {\r\n        bytes32 serviceId;\r\n        bytes   metadataURI;   //Service metadata. metadataURI should contain information for data consistency \r\n                               //validation (for example hash). We support: IPFS URI.\r\n\r\n        uint orgServiceIndex;\r\n    }\r\n\r\n    bytes32[] orgKeys;\r\n    mapping(bytes32 => OrganizationRegistration) orgsById;\r\n\r\n    constructor ()\r\n    public\r\n    {\r\n        //ERC165: https://eips.ethereum.org/EIPS/eip-165\r\n        _registerInterface(0x3f2242ea);\r\n\r\n    }\r\n\r\n\r\n    /**\r\n      * @dev Guard function that forces a revert if the tx sender is unauthorized.\r\n      *      Always authorizes org owner. Can also authorize org members.\r\n      *\r\n      * @param membersAllowed if true, revert when sender is non-owner and non-member, else revert when sender is non-owner\r\n      */\r\n    function requireAuthorization(bytes32 orgId, bool membersAllowed) internal view {\r\n        require(msg.sender == orgsById[orgId].owner || (membersAllowed && orgsById[orgId].members[msg.sender] > 0)\r\n            , \"unauthorized invocation\");\r\n    }\r\n\r\n    /**\r\n      * @dev Guard function that forces a revert if the referenced org does not meet an existence criteria.\r\n      *\r\n      * @param exists if true, revert when org does not exist, else revert when org exists\r\n      */\r\n    function requireOrgExistenceConstraint(bytes32 orgId, bool exists) internal view {\r\n        if (exists) {\r\n            require(orgsById[orgId].organizationId != bytes32(0x0), \"org does not exist\");\r\n        } else {\r\n            require(orgsById[orgId].organizationId == bytes32(0x0), \"org already exists\");\r\n        }\r\n    }\r\n\r\n    /**\r\n      * @dev Guard function that forces a revert if the referenced service does not meet an existence criteria.\r\n      *\r\n      * @param exists if true, revert when service does not exist, else revert when service exists\r\n      */\r\n    function requireServiceExistenceConstraint(bytes32 orgId, bytes32 serviceId, bool exists) internal view {\r\n        if (exists) {\r\n            require(orgsById[orgId].servicesById[serviceId].serviceId != bytes32(0x0), \"service does not exist\");\r\n        } else {\r\n            require(orgsById[orgId].servicesById[serviceId].serviceId == bytes32(0x0), \"service already exists\");\r\n        }\r\n    }\r\n\r\n    //    ___                        _          _   _                   __  __                 _\r\n    //   / _ \\ _ __ __ _  __ _ _ __ (_)______ _| |_(_) ___  _ __       |  \\/  | __ _ _ __ ___ | |_\r\n    //  | | | | '__/ _` |/ _` | '_ \\| |_  / _` | __| |/ _ \\| '_ \\      | |\\/| |/ _` | '_ ` _ \\| __|\r\n    //  | |_| | | | (_| | (_| | | | | |/ / (_| | |_| | (_) | | | |     | |  | | (_| | | | | | | |_\r\n    //   \\___/|_|  \\__, |\\__,_|_| |_|_/___\\__,_|\\__|_|\\___/|_| |_|     |_|  |_|\\__, |_| |_| |_|\\__|\r\n    //             |___/                                                       |___/\r\n\r\n    function createOrganization(bytes32 orgId, bytes calldata orgMetadataURI, address[] calldata members) external override {\r\n\r\n        requireOrgExistenceConstraint(orgId, false);\r\n\r\n        OrganizationRegistration memory organization;\r\n        orgsById[orgId] = organization;\r\n        orgsById[orgId].organizationId = orgId;\r\n        orgsById[orgId].orgMetadataURI = orgMetadataURI;\r\n        orgsById[orgId].owner = msg.sender;\r\n        orgsById[orgId].globalOrgIndex = orgKeys.length;\r\n        orgKeys.push(orgId);\r\n\r\n        addOrganizationMembersInternal(orgId, members);\r\n\r\n        emit OrganizationCreated(orgId);\r\n    }\r\n\r\n    function changeOrganizationOwner(bytes32 orgId, address newOwner) external override {\r\n\r\n        requireOrgExistenceConstraint(orgId, true);\r\n        requireAuthorization(orgId, false);\r\n\r\n        orgsById[orgId].owner = newOwner;\r\n\r\n        emit OrganizationModified(orgId);\r\n    }\r\n\r\n    function changeOrganizationMetadataURI(bytes32 orgId, bytes calldata orgMetadataURI) external override {\r\n\r\n        requireOrgExistenceConstraint(orgId, true);\r\n        requireAuthorization(orgId, false);\r\n\r\n        orgsById[orgId].orgMetadataURI = orgMetadataURI;\r\n\r\n        emit OrganizationModified(orgId);\r\n    }\r\n\r\n    function addOrganizationMembers(bytes32 orgId, address[] calldata newMembers) external override {\r\n\r\n        requireOrgExistenceConstraint(orgId, true);\r\n        requireAuthorization(orgId, true);\r\n\r\n        addOrganizationMembersInternal(orgId, newMembers);\r\n\r\n        emit OrganizationModified(orgId);\r\n    }\r\n\r\n    function addOrganizationMembersInternal(bytes32 orgId, address[] memory newMembers) internal {\r\n        for (uint i = 0; i < newMembers.length; i++) {\r\n            if (orgsById[orgId].members[newMembers[i]] == 0) {\r\n                orgsById[orgId].memberKeys.push(newMembers[i]);\r\n                orgsById[orgId].members[newMembers[i]] = orgsById[orgId].memberKeys.length;\r\n            }\r\n        }\r\n    }\r\n\r\n    function removeOrganizationMembers(bytes32 orgId, address[] calldata existingMembers) external override {\r\n\r\n        requireOrgExistenceConstraint(orgId, true);\r\n        requireAuthorization(orgId, true);\r\n\r\n        for (uint i = 0; i < existingMembers.length; i++) {\r\n            removeOrganizationMemberInternal(orgId, existingMembers[i]);\r\n        }\r\n\r\n        emit OrganizationModified(orgId);\r\n    }\r\n\r\n    function removeOrganizationMemberInternal(bytes32 orgId, address existingMember) internal {\r\n        // see \"member indexing note\"\r\n        if (orgsById[orgId].members[existingMember] != 0) {\r\n            uint storedIndexToRemove = orgsById[orgId].members[existingMember];\r\n            address memberToMove = orgsById[orgId].memberKeys[orgsById[orgId].memberKeys.length - 1];\r\n\r\n            // no-op if we are deleting the last entry\r\n            if (orgsById[orgId].memberKeys[storedIndexToRemove - 1] != memberToMove) {\r\n                // swap lut entries\r\n                orgsById[orgId].memberKeys[storedIndexToRemove - 1] = memberToMove;\r\n                orgsById[orgId].members[memberToMove] = storedIndexToRemove;\r\n            }\r\n\r\n            // shorten keys array\r\n            orgsById[orgId].memberKeys.pop();\r\n\r\n            // delete the mapping entry\r\n            delete orgsById[orgId].members[existingMember];\r\n        }\r\n    }\r\n\r\n    function deleteOrganization(bytes32 orgId) external override {\r\n\r\n        requireOrgExistenceConstraint(orgId, true);\r\n        requireAuthorization(orgId, false);\r\n\r\n        for (uint serviceIndex = orgsById[orgId].serviceKeys.length; serviceIndex > 0; serviceIndex--) {\r\n            deleteServiceRegistrationInternal(orgId, orgsById[orgId].serviceKeys[serviceIndex-1]);\r\n        }\r\n\r\n        for (uint memberIndex = orgsById[orgId].memberKeys.length; memberIndex > 0; memberIndex--) {\r\n            removeOrganizationMemberInternal(orgId, orgsById[orgId].memberKeys[memberIndex-1]);\r\n        }\r\n\r\n        // swap lut entries\r\n        uint    indexToUpdate = orgsById[orgId].globalOrgIndex;\r\n        bytes32 orgToUpdate   = orgKeys[orgKeys.length-1];\r\n\r\n        if (orgKeys[indexToUpdate] != orgToUpdate) {\r\n            orgKeys[indexToUpdate] = orgToUpdate;\r\n            orgsById[orgToUpdate].globalOrgIndex = indexToUpdate;\r\n        }\r\n\r\n        // shorten keys array\r\n        orgKeys.pop();\r\n\r\n        // delete contents of organization registration\r\n        delete orgsById[orgId];\r\n\r\n        emit OrganizationDeleted(orgId);\r\n    }\r\n\r\n    //   ____                  _                __  __                 _\r\n    //  / ___|  ___ _ ____   ___) ___ ___      |  \\/  | __ _ _ __ ___ | |_\r\n    //  \\___ \\ / _ \\ '__\\ \\ / / |/ __/ _ \\     | |\\/| |/ _` | '_ ` _ \\| __|\r\n    //   ___) |  __/ |   \\ V /| | (__  __/     | |  | | (_| | | | | | | |_\r\n    //  |____/ \\___|_|    \\_/ |_|\\___\\___|     |_|  |_|\\__, |_| |_| |_|\\__|\r\n    //                                                 |___/\r\n\r\n    function createServiceRegistration(bytes32 orgId, bytes32 serviceId, bytes calldata metadataURI) external override {\r\n\r\n        requireOrgExistenceConstraint(orgId, true);\r\n        requireAuthorization(orgId, true);\r\n        requireServiceExistenceConstraint(orgId, serviceId, false);\r\n\r\n        ServiceRegistration memory service;\r\n        service.serviceId     = serviceId;\r\n        service.metadataURI     = metadataURI;\r\n        service.orgServiceIndex = orgsById[orgId].serviceKeys.length;\r\n        orgsById[orgId].servicesById[serviceId] = service;\r\n        orgsById[orgId].serviceKeys.push(serviceId);\r\n\r\n        emit ServiceCreated(orgId, serviceId, metadataURI);\r\n    }\r\n\r\n    function updateServiceRegistration(bytes32 orgId, bytes32 serviceId, bytes calldata metadataURI) external override {\r\n\r\n        requireOrgExistenceConstraint(orgId, true);\r\n        requireAuthorization(orgId, true);\r\n        requireServiceExistenceConstraint(orgId, serviceId, true);\r\n\r\n        orgsById[orgId].servicesById[serviceId].metadataURI = metadataURI;\r\n\r\n        emit ServiceMetadataModified(orgId, serviceId, metadataURI);\r\n    }\r\n\r\n    function deleteServiceRegistration(bytes32 orgId, bytes32 serviceId) external override {\r\n\r\n        requireOrgExistenceConstraint(orgId, true);\r\n        requireAuthorization(orgId, true);\r\n        requireServiceExistenceConstraint(orgId, serviceId, true);\r\n\r\n        deleteServiceRegistrationInternal(orgId, serviceId);\r\n\r\n        emit ServiceDeleted(orgId, serviceId);\r\n    }\r\n\r\n    function deleteServiceRegistrationInternal(bytes32 orgId, bytes32 serviceId) internal {\r\n\r\n        // swap lut entries\r\n        uint    indexToUpdate   = orgsById[orgId].servicesById[serviceId].orgServiceIndex;\r\n        bytes32 serviceToUpdate = orgsById[orgId].serviceKeys[orgsById[orgId].serviceKeys.length-1];\r\n\r\n        if (orgsById[orgId].serviceKeys[indexToUpdate] != serviceToUpdate) {\r\n            orgsById[orgId].serviceKeys[indexToUpdate] = serviceToUpdate;\r\n            orgsById[orgId].servicesById[serviceToUpdate].orgServiceIndex = indexToUpdate;\r\n        }\r\n\r\n        orgsById[orgId].serviceKeys.pop();\r\n\r\n        // delete contents of service registration\r\n        delete orgsById[orgId].servicesById[serviceId];\r\n    }\r\n\r\n    //    ____      _   _\r\n    //   / ___| ___| |_| |_ ___ _ __ ___\r\n    //  | |  _ / _ \\ __| __/ _ \\ '__/ __|\r\n    //  | |_| |  __/ |_| |_  __/ |  \\__ \\\r\n    //   \\____|\\___|\\__|\\__\\___|_|  |___/\r\n    //\r\n\r\n    function listOrganizations() external override view returns (bytes32[] memory orgIds) {\r\n        return orgKeys;\r\n    }\r\n\r\n    function getOrganizationById(bytes32 orgId) external override view\r\n            returns(bool found, bytes32 id, bytes memory orgMetadataURI, address owner, address[] memory members, bytes32[] memory serviceIds) {\r\n\r\n        // check to see if this organization exists\r\n        if(orgsById[orgId].organizationId == bytes32(0x0)) {\r\n            found = false;\r\n        } \r\n        else {\r\n            found = true;\r\n            id = orgsById[orgId].organizationId;\r\n            orgMetadataURI = orgsById[orgId].orgMetadataURI;\r\n            owner = orgsById[orgId].owner;\r\n            members = orgsById[orgId].memberKeys;\r\n            serviceIds = orgsById[orgId].serviceKeys;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    function listServicesForOrganization(bytes32 orgId) external override view returns (bool found, bytes32[] memory serviceIds) {\r\n\r\n        // check to see if this organization exists\r\n        if(orgsById[orgId].organizationId == bytes32(0x0)) {\r\n            found = false;\r\n        }\r\n        else {\r\n            found = true;\r\n            serviceIds = orgsById[orgId].serviceKeys;\r\n        }\r\n    }\r\n\r\n    function getServiceRegistrationById(bytes32 orgId, bytes32 serviceId) external override view\r\n            returns (bool found, bytes32 id, bytes memory metadataURI) {\r\n\r\n        // check to see if this organization exists\r\n        if(orgsById[orgId].organizationId == bytes32(0x0)) {\r\n            found = false;\r\n        } \r\n        else if(orgsById[orgId].servicesById[serviceId].serviceId == bytes32(0x0)) {\r\n            // check to see if this repo exists\r\n            found = false;\r\n        }\r\n        else {\r\n            found        = true;\r\n            id           = orgsById[orgId].servicesById[serviceId].serviceId;\r\n            metadataURI  = orgsById[orgId].servicesById[serviceId].metadataURI;\r\n        }\r\n\r\n    }\r\n\r\n    // ERC165: https://eips.ethereum.org/EIPS/eip-165\r\n    //function supportsInterface(bytes4 interfaceID) external view returns (bool) {\r\n    //    return\r\n    //        interfaceID == this.supportsInterface.selector || // ERC165\r\n    //        interfaceID == 0x3f2242ea; // IRegistry\r\n    //}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"}],\"name\":\"OrganizationCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"}],\"name\":\"OrganizationDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"}],\"name\":\"OrganizationModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"serviceId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadataURI\",\"type\":\"bytes\"}],\"name\":\"ServiceCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"serviceId\",\"type\":\"bytes32\"}],\"name\":\"ServiceDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"serviceId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadataURI\",\"type\":\"bytes\"}],\"name\":\"ServiceMetadataModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"serviceId\",\"type\":\"bytes32\"}],\"name\":\"ServiceTagsModified\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"newMembers\",\"type\":\"address[]\"}],\"name\":\"addOrganizationMembers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"orgMetadataURI\",\"type\":\"bytes\"}],\"name\":\"changeOrganizationMetadataURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOrganizationOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"orgMetadataURI\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"members\",\"type\":\"address[]\"}],\"name\":\"createOrganization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"serviceId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"metadataURI\",\"type\":\"bytes\"}],\"name\":\"createServiceRegistration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"}],\"name\":\"deleteOrganization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"serviceId\",\"type\":\"bytes32\"}],\"name\":\"deleteServiceRegistration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"}],\"name\":\"getOrganizationById\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"found\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"orgMetadataURI\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"members\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"serviceIds\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"serviceId\",\"type\":\"bytes32\"}],\"name\":\"getServiceRegistrationById\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"found\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"metadataURI\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listOrganizations\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"orgIds\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"}],\"name\":\"listServicesForOrganization\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"found\",\"type\":\"bool\"},{\"internalType\":\"bytes32[]\",\"name\":\"serviceIds\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"existingMembers\",\"type\":\"address[]\"}],\"name\":\"removeOrganizationMembers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orgId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"serviceId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"metadataURI\",\"type\":\"bytes\"}],\"name\":\"updateServiceRegistration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Registry", "CompilerVersion": "v0.6.2+commit.bacdbe57", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://24200563242f8da6291b3b980955449d1733202dc332f2c79bf517c8012f73bf"}]}