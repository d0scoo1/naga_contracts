{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AdventurerStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n/**\\r\\n\\r\\n ________  ___    ___ ________  ___  ___  _______   ________  _________   \\r\\n|\\\\   __  \\\\|\\\\  \\\\  /  /|\\\\   __  \\\\|\\\\  \\\\|\\\\  \\\\|\\\\  ___ \\\\ |\\\\   ____\\\\|\\\\___   ___\\\\ \\r\\n\\\\ \\\\  \\\\|\\\\  \\\\ \\\\  \\\\/  / | \\\\  \\\\|\\\\  \\\\ \\\\  \\\\\\\\\\\\  \\\\ \\\\   __/|\\\\ \\\\  \\\\___|\\\\|___ \\\\  \\\\_| \\r\\n \\\\ \\\\   ____\\\\ \\\\    / / \\\\ \\\\  \\\\\\\\\\\\  \\\\ \\\\  \\\\\\\\\\\\  \\\\ \\\\  \\\\_|/_\\\\ \\\\_____  \\\\   \\\\ \\\\  \\\\  \\r\\n  \\\\ \\\\  \\\\___|/     \\\\/   \\\\ \\\\  \\\\\\\\\\\\  \\\\ \\\\  \\\\\\\\\\\\  \\\\ \\\\  \\\\_|\\\\ \\\\|____|\\\\  \\\\   \\\\ \\\\  \\\\ \\r\\n   \\\\ \\\\__\\\\  /  /\\\\   \\\\    \\\\ \\\\_____  \\\\ \\\\_______\\\\ \\\\_______\\\\____\\\\_\\\\  \\\\   \\\\ \\\\__\\\\\\r\\n    \\\\|__| /__/ /\\\\ __\\\\    \\\\|___| \\\\__\\\\|_______|\\\\|_______|\\\\_________\\\\   \\\\|__|\\r\\n          |__|/ \\\\|__|          \\\\|__|                  \\\\|_________|        \\r\\n                                                                          \\r\\n\\r\\n\\r\\n * @title AdventurerStaking\\r\\n * AdventurerStaking - a contract for staking PX Quest\\r\\n */\\r\\n\\r\\npragma solidity ^0.8.11;\\r\\n\\r\\nimport \\\"./IAdventurerStaking.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\ninterface IAdventurer {\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ninterface IChronos {\\r\\n    function grantChronos(address to, uint256 amount) external;\\r\\n}\\r\\n\\r\\ncontract AdventurerStaking is IAdventurerStaking, Ownable, ERC721Holder {\\r\\n    IAdventurer public adventurerContract;\\r\\n    IChronos public chronosContract;\\r\\n\\r\\n    // NFT tokenId to time staked and owner's address\\r\\n    mapping(uint64 => StakedToken) public stakes;\\r\\n\\r\\n    uint64 private constant NINETY_DAYS = 7776000;\\r\\n    bool grantChronos = true;\\r\\n\\r\\n    constructor(\\r\\n        address _adventurerContract,\\r\\n        address _chronosContract,\\r\\n        address _ownerAddress\\r\\n    ) {\\r\\n        require(\\r\\n            _adventurerContract != address(0),\\r\\n            \\\"nft contract cannot be 0x0\\\"\\r\\n        );\\r\\n        require(\\r\\n            _chronosContract != address(0),\\r\\n            \\\"chronos contract cannot be 0x0\\\"\\r\\n        );\\r\\n        adventurerContract = IAdventurer(_adventurerContract);\\r\\n        chronosContract = IChronos(_chronosContract);\\r\\n        if (_ownerAddress != msg.sender) {\\r\\n            transferOwnership(_ownerAddress);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function viewStakes(address _address)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory)\\r\\n    {\\r\\n        uint256[] memory _tokens = new uint256[](7500);\\r\\n        uint256 tookCount = 0;\\r\\n        for (uint64 i = 0; i < 7500; i++) {\\r\\n            if (stakes[i].user == _address) {\\r\\n                _tokens[tookCount] = i;\\r\\n                tookCount++;\\r\\n            }\\r\\n        }\\r\\n        uint256[] memory trimmedResult = new uint256[](tookCount);\\r\\n        for (uint256 j = 0; j < trimmedResult.length; j++) {\\r\\n            trimmedResult[j] = _tokens[j];\\r\\n        }\\r\\n        return trimmedResult;\\r\\n    }\\r\\n\\r\\n    function stake(uint64 tokenId) public override {\\r\\n        stakes[tokenId] = StakedToken(msg.sender, uint64(block.timestamp));\\r\\n        emit StartStake(msg.sender, tokenId);\\r\\n        adventurerContract.safeTransferFrom(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            uint256(tokenId)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function groupStake(uint64[] memory tokenIds) external override {\\r\\n        for (uint64 i = 0; i < tokenIds.length; ++i) {\\r\\n            stake(tokenIds[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function unstake(uint64 tokenId) public override {\\r\\n        require(stakes[tokenId].user != address(0), \\\"tokenId not staked\\\");\\r\\n        require(\\r\\n            stakes[tokenId].user == msg.sender,\\r\\n            \\\"sender didn't stake token\\\"\\r\\n        );\\r\\n        uint64 stakeLength = uint64(block.timestamp) -\\r\\n            stakes[tokenId].timeStaked;\\r\\n        if (grantChronos) {\\r\\n            chronosContract.grantChronos(msg.sender, (stakeLength * 5) / 86400);\\r\\n        }\\r\\n        emit Unstake(\\r\\n            msg.sender,\\r\\n            tokenId,\\r\\n            stakeLength > NINETY_DAYS,\\r\\n            stakeLength\\r\\n        );\\r\\n        delete stakes[tokenId];\\r\\n        adventurerContract.safeTransferFrom(\\r\\n            address(this),\\r\\n            msg.sender,\\r\\n            uint256(tokenId)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function groupUnstake(uint64[] memory tokenIds) external override {\\r\\n        for (uint64 i = 0; i < tokenIds.length; ++i) {\\r\\n            unstake(tokenIds[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setGrantChronos(bool _grant) external onlyOwner {\\r\\n        grantChronos = _grant;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/IAdventurerStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.11;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\r\\n\\r\\ninterface IAdventurerStaking is IERC721Receiver {\\r\\n    struct StakedToken {\\r\\n        address user;\\r\\n        uint64 timeStaked;\\r\\n    }\\r\\n\\r\\n    /// @notice Emits when a user stakes their NFT.\\r\\n    /// @param owner the wallet address of the owner of the NFT being staked.\\r\\n    /// @param tokenId the tokenId of the Adventurer NFT being staked.\\r\\n    event StartStake(address indexed owner, uint64 tokenId);\\r\\n\\r\\n    /// @notice Emits when a user unstakes their NFT.\\r\\n    /// @param owner the wallet address of the owner of the NFT being unstaked.\\r\\n    /// @param tokenId the tokenId of the Adventurer NFT being unstaked.\\r\\n    /// @param success whether or not the user staked the NFT for more than 90 days.\\r\\n    /// @param duration the duration the NFT was staked for.\\r\\n    event Unstake(\\r\\n        address indexed owner,\\r\\n        uint64 tokenId,\\r\\n        bool success,\\r\\n        uint64 duration\\r\\n    );\\r\\n\\r\\n    /// @notice Stakes a user's NFT\\r\\n    /// @param tokenId the tokenId of the NFT to be staked\\r\\n    function stake(uint64 tokenId) external;\\r\\n\\r\\n    /// @notice Stakes serveral of a user's NFTs\\r\\n    /// @param tokenIds the tokenId of the NFT to be staked\\r\\n    function groupStake(uint64[] memory tokenIds) external;\\r\\n\\r\\n    /// @notice Retrieves a user's NFT from the staking contract\\r\\n    /// @param tokenId the tokenId of the staked NFT\\r\\n    function unstake(uint64 tokenId) external;\\r\\n\\r\\n    /// @notice Unstakes serveral of a user's NFTs\\r\\n    /// @param tokenIds the tokenId of the NFT to be staked\\r\\n    function groupUnstake(uint64[] memory tokenIds) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adventurerContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_chronosContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"tokenId\",\"type\":\"uint64\"}],\"name\":\"StartStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"tokenId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"duration\",\"type\":\"uint64\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"adventurerContract\",\"outputs\":[{\"internalType\":\"contract IAdventurer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chronosContract\",\"outputs\":[{\"internalType\":\"contract IChronos\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"tokenIds\",\"type\":\"uint64[]\"}],\"name\":\"groupStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"tokenIds\",\"type\":\"uint64[]\"}],\"name\":\"groupUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_grant\",\"type\":\"bool\"}],\"name\":\"setGrantChronos\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"tokenId\",\"type\":\"uint64\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"timeStaked\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"tokenId\",\"type\":\"uint64\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"viewStakes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AdventurerStaking", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000017ed38f5f519c6ed563be6486e629041bed3dfbc000000000000000000000000a2ea5cb0614f6428421a39ec09b013cc3336efbe00000000000000000000000017a45f80efd20594afe2c59d7e1ae7ab0c6954cc", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}