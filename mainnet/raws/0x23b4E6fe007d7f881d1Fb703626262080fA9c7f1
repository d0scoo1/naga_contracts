{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CryptoshackStaking.sol\": {\r\n      \"content\": \"// contracts/CryptoshackStaking.sol\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ninterface ICryptoshackContract {\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IWorldTokenContract {\\r\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\r\\n}\\r\\n\\r\\ncontract CryptoshackStaking {\\r\\n    // contract owner\\r\\n    address public owner;\\r\\n    // reward token contract\\r\\n    ICryptoshackContract worldTokenContract;\\r\\n    // staking token contract\\r\\n    IWorldTokenContract cryptoshackContract;\\r\\n\\r\\n    // is staking allowed or not\\r\\n    bool public stakingAllowed;\\r\\n\\r\\n    bool public emergencyMode;\\r\\n\\r\\n    uint public undistributed;\\r\\n\\r\\n    // total reward tokens claimed\\r\\n    uint public totalClaimed;\\r\\n    // general info by token type\\r\\n    uint[3][5] typeToNumbers;\\r\\n    \\r\\n    // token Id to staker\\r\\n    mapping(uint => address) idToStaker;\\r\\n    // staker to all staked tokens IDs\\r\\n    mapping(address => uint[]) stakerToIds;\\r\\n    // token ID to it's index in stakerToIds\\r\\n    mapping(uint => uint) tokenIdToStakerIndex;\\r\\n    // token ID to reward tokens claimed\\r\\n    mapping(uint => uint) tokenToClaimed;\\r\\n\\r\\n    constructor() { \\r\\n        owner=msg.sender; \\r\\n\\r\\n        // staked | allocation percent | reward accumulated\\r\\n        typeToNumbers[0]=[0,50,0];\\r\\n        typeToNumbers[1]=[0,50,0];\\r\\n        typeToNumbers[2]=[0,30,0];\\r\\n        typeToNumbers[3]=[0,20,0];\\r\\n        typeToNumbers[4]=[0,20,0];\\r\\n    }\\r\\n\\r\\n    // stake tokens\\r\\n    function stake(uint[] calldata tokenIds) external onlyStakingAllowed noContracts {\\r\\n        uint tokenId;\\r\\n        uint tokenType;\\r\\n        for (uint i;i<tokenIds.length;i++) {\\r\\n            tokenId=tokenIds[i];\\r\\n            tokenType=tokenId/10000;\\r\\n\\r\\n            // increase staked tokens of a type amount\\r\\n            typeToNumbers[tokenType][0]++;\\r\\n            // set claimed level to the current reward\\r\\n            tokenToClaimed[tokenId]=typeToNumbers[tokenType][2];\\r\\n            // set staker\\r\\n            idToStaker[tokenId]=msg.sender;\\r\\n            // set idex of token in staker's wallet\\r\\n            tokenIdToStakerIndex[tokenId]=stakerToIds[msg.sender].length;\\r\\n            // push the token to staker's wallet\\r\\n            stakerToIds[msg.sender].push(tokenId);\\r\\n            // move the CS token to the contract\\r\\n            cryptoshackContract.transferFrom(msg.sender, address(this), tokenId);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // claim and unstake if `unstake` is true\\r\\n    function claim(uint[] calldata tokenIds, bool unstake) external noContracts { \\r\\n        uint[] storage tokensArray;\\r\\n        uint totalClaimable;\\r\\n        uint tokenType;\\r\\n        uint tokenId;\\r\\n        uint lastIndex;\\r\\n        uint tokenIndex;\\r\\n\\r\\n        for (uint i;i<tokenIds.length;i++) {\\r\\n            tokenId=tokenIds[i];\\r\\n            require(idToStaker[tokenId]==msg.sender, \\\"You're not the staker\\\");\\r\\n            tokenType=tokenId/10000;\\r\\n\\r\\n            totalClaimable+=typeToNumbers[tokenType][2]-tokenToClaimed[tokenId];\\r\\n\\r\\n            tokenToClaimed[tokenId]=typeToNumbers[tokenType][2];\\r\\n\\r\\n            if (unstake) {\\r\\n                tokensArray=stakerToIds[msg.sender];\\r\\n                lastIndex=tokensArray.length-1;\\r\\n                tokenIndex=tokenIdToStakerIndex[tokenId];\\r\\n\\r\\n                //nullify the staker address\\r\\n                idToStaker[tokenId]=address(0);\\r\\n                //update staked of a type amount\\r\\n                typeToNumbers[tokenType][0]--;\\r\\n                //swap token to be removed with the last one\\r\\n                tokensArray[tokenIndex]=tokensArray[lastIndex];\\r\\n                //update swapped token index\\r\\n                tokenIdToStakerIndex[tokensArray[lastIndex]]=tokenIndex;\\r\\n                //remove last element\\r\\n                tokensArray.pop();\\r\\n                //move token back to the staker wallet\\r\\n                cryptoshackContract.transferFrom(address(this), msg.sender, tokenId);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (totalClaimable > 0) {\\r\\n            totalClaimed+=totalClaimable;\\r\\n            worldTokenContract.transfer(msg.sender, totalClaimable);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // get claimable amount of reward tokens\\r\\n    function getClaimable(uint[] calldata tokenIds) external view returns(uint) { \\r\\n        uint totalClaimable;\\r\\n        for (uint i;i<tokenIds.length;i++) {\\r\\n            if (idToStaker[tokenIds[i]]!=address(0)) {\\r\\n                totalClaimable+=typeToNumbers[tokenIds[i]/10000][2]-tokenToClaimed[tokenIds[i]];\\r\\n            }\\r\\n        }\\r\\n        return totalClaimable;\\r\\n    }\\r\\n\\r\\n    // get claimable amount for the wallet\\r\\n    function getClaimableByWallet(address wallet) external view returns(uint) { \\r\\n        uint totalClaimable;\\r\\n        for (uint i;i<stakerToIds[wallet].length;i++) {\\r\\n            if (idToStaker[stakerToIds[wallet][i]]!=address(0)) {\\r\\n                totalClaimable+=typeToNumbers[stakerToIds[wallet][i]/10000][2]-tokenToClaimed[stakerToIds[wallet][i]];\\r\\n            }\\r\\n        }\\r\\n        return totalClaimable;\\r\\n    }\\r\\n\\r\\n    // get staker wallet of token Id\\r\\n    function getStaker(uint tokenId) external view returns(address) { \\r\\n        return idToStaker[tokenId];\\r\\n    }\\r\\n    \\r\\n    // get total tokens staked\\r\\n    function stakedTotal() external view returns(uint) {\\r\\n        uint totalStaked;\\r\\n        for (uint8 i;i<5;i++) {\\r\\n            totalStaked+=typeToNumbers[i][0];\\r\\n        }\\r\\n        return totalStaked;\\r\\n    }\\r\\n\\r\\n    // get all tokens staked by wallet\\r\\n    function stakedByWallet(address wallet) external view returns(uint[] memory) { \\r\\n        return stakerToIds[wallet];\\r\\n    }\\r\\n\\r\\n    // returns the count of the staked tokens of a type\\r\\n    function getStakedOfType(uint tokenType) external view returns(uint) {\\r\\n        return typeToNumbers[tokenType][0];\\r\\n    }\\r\\n\\r\\n    // top up the balance and distribute the reward token\\r\\n    function topUp(uint amount) external onlyOwner { \\r\\n        // distributing amount + remains from the previous topUp\\r\\n        uint todistribute=amount+undistributed;\\r\\n        // total amount of gophers + golden gophers staked\\r\\n        uint gophersStaked=(typeToNumbers[0][0]+typeToNumbers[1][0]);\\r\\n        // total amount of members + lege staked\\r\\n        uint membersStaked=(typeToNumbers[3][0]+typeToNumbers[4][0]);\\r\\n        // total amount that will be distributed\\r\\n        uint totalShare;\\r\\n\\r\\n        if (gophersStaked > 0) {\\r\\n            // share per gopher or golden gopher\\r\\n            uint gophersShare=(todistribute*typeToNumbers[0][1]/100)/(gophersStaked);\\r\\n            typeToNumbers[0][2]+=gophersShare;\\r\\n            typeToNumbers[1][2]+=gophersShare;\\r\\n            totalShare+=gophersShare*gophersStaked;\\r\\n        }\\r\\n        if (membersStaked > 0) {\\r\\n            // share per member or lege\\r\\n            uint membersShare=(todistribute*typeToNumbers[4][1]/100)/(membersStaked);\\r\\n            typeToNumbers[3][2]+=membersShare;\\r\\n            typeToNumbers[4][2]+=membersShare;\\r\\n            totalShare+=membersShare*membersStaked;\\r\\n        }\\r\\n        if (typeToNumbers[2][0] > 0) {\\r\\n            // share per caddie\\r\\n            uint caddiesShare=(todistribute*typeToNumbers[2][1]/100)/(typeToNumbers[2][0]);\\r\\n            typeToNumbers[2][2]+=caddiesShare;\\r\\n            totalShare+=caddiesShare*typeToNumbers[2][0];\\r\\n        }\\r\\n\\r\\n        // storing the not distributed amount for the next time\\r\\n        undistributed=todistribute-totalShare;\\r\\n        \\r\\n        worldTokenContract.transferFrom(msg.sender, address(this), amount);\\r\\n    }\\r\\n\\r\\n    // allow owner to remove token from stake in case of problems with contract\\r\\n    function ejectStakingTokens(address wallet, uint tokenId) external onlyOwner onlyEmergency { \\r\\n        cryptoshackContract.transferFrom(address(this), wallet, tokenId);\\r\\n    }\\r\\n\\r\\n    // allow owner to remove WRLD tokens from the contract in case of a problems\\r\\n    function ejectRewardTokens(address wallet) external onlyOwner onlyEmergency {\\r\\n        worldTokenContract.transfer(wallet, worldTokenContract.balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    // set reward token contract\\r\\n    function setWorldTokenContract(address worldTokenContract_) external onlyOwner { \\r\\n        worldTokenContract=ICryptoshackContract(worldTokenContract_);\\r\\n    }\\r\\n\\r\\n    // set staking token contract\\r\\n    function setCryptoshackContract(address cryptoshackContract_) external onlyOwner { \\r\\n        cryptoshackContract=IWorldTokenContract(cryptoshackContract_);\\r\\n    }\\r\\n\\r\\n    // switch the stakingAllowed flag\\r\\n    function switchStakingAllowed() external onlyOwner {\\r\\n        stakingAllowed=!stakingAllowed;\\r\\n    }\\r\\n\\r\\n    // switch the stakingAllowed flag\\r\\n    function switchEmergencyMode() external onlyOwner {\\r\\n        emergencyMode=!emergencyMode;\\r\\n    }\\r\\n\\r\\n    // transfer ownership\\r\\n    function transferOwnership(address newOwner) external onlyOwner {\\r\\n        owner=newOwner;\\r\\n    }\\r\\n\\r\\n    // execute only if stakingAllowed\\r\\n    modifier onlyStakingAllowed {\\r\\n        require(stakingAllowed,\\\"Staking is not allowed!\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // execute only if emergency mode activated\\r\\n    modifier onlyEmergency  {\\r\\n        require(emergencyMode, \\\"Emergency mode off\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // execute only if caller is not a contract\\r\\n    modifier noContracts {\\r\\n        require(msg.sender == tx.origin, \\\"No contracts allowed!\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // execute only if caller is an owner\\r\\n    modifier onlyOwner { \\r\\n        require(msg.sender == owner);\\r\\n        _; \\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"unstake\",\"type\":\"bool\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"ejectRewardTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ejectStakingTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getClaimableByWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenType\",\"type\":\"uint256\"}],\"name\":\"getStakedOfType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getStaker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cryptoshackContract_\",\"type\":\"address\"}],\"name\":\"setCryptoshackContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"worldTokenContract_\",\"type\":\"address\"}],\"name\":\"setWorldTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"stakedByWallet\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"switchEmergencyMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"switchStakingAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"topUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"undistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CryptoshackStaking", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}