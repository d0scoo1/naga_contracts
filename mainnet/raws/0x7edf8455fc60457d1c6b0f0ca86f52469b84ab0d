{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"./Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can\\u0027t have a constructor, it\\u0027s common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"},\"IUniswapV2Pair.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IUniswapV2Pair is IERC20 {\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n}\\n\"},\"IUniswapV2Router.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\ninterface IUniswapV2Router {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"},\"IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n}\\n\"},\"Liquidity.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.10;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IUniswapV2Router.sol\\\";\\nimport \\\"./IUniswapV2Pair.sol\\\";\\nimport \\\"./ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"./OwnedInitializable.sol\\\";\\nimport \\\"./IWETH.sol\\\";\\n\\nstruct Deposit {\\n    uint256 balance;\\n    uint256 withdrawnBalance;\\n    uint48 timestamp;\\n    bool locked;\\n}\\n\\ncontract Liquidity is OwnedInitializable, ReentrancyGuardUpgradeable {\\n    IUniswapV2Router private constant router = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n    IUniswapV2Pair public uniswapPair;\\n    IERC20 public token;\\n    address private _WETH;\\n    address private _token0;\\n    address private _token1;\\n\\n    mapping(address =\\u003e uint256) public nonces;\\n    mapping(address =\\u003e mapping(uint256 =\\u003e Deposit)) public deposits;\\n\\n    uint256 public lockPeriod;\\n    uint256 public vestingPeriod;\\n\\n    event ProvidedLiquidity(address indexed user, bool indexed locked, uint256 tokenId, uint256 amountLiquidity);\\n    event Withdraw(address indexed user, bool indexed locked, uint256 tokenId, uint256 amountLiquidity);\\n    event LockPeriodUpdated(uint256 oldValue, uint256 newValue);\\n    event VestingPeriodUpdated(uint256 oldValue, uint256 newValue);\\n\\n    function initialize(address _token, address _uniswapPair) public initializer {\\n        __Ownable_init();\\n        __ReentrancyGuard_init();\\n        token = IERC20(_token);\\n        uniswapPair = IUniswapV2Pair(_uniswapPair);\\n        _WETH = router.WETH();\\n        (_token0, _token1) = (_WETH \\u003c _token ? (_WETH, _token) : (_token, _WETH));\\n        lockPeriod = 26 weeks;\\n        vestingPeriod = lockPeriod * 2;\\n    }\\n\\n    /// @notice provides liquidity with uniswap\\n    /// @dev    ETH half is provided by user, token half is provided by the smart contract\\n    /// @dev    each deposit is stored with new id\\n    /// @param  _lock if true, lock total token amount for `lockPeriod` amount of time, else linearly vest amount for `vestingPeriod` amount of time\\n    function provideLiquidity(bool _lock) external payable nonReentrant {\\n        uint256 amountETH = msg.value;\\n        uint256 nonce = nonces[_msgSender()];\\n        nonces[_msgSender()]++;\\n        uint256 liquidityMinted = _provideLiquidity(amountETH);\\n        Deposit memory newDeposit = Deposit({\\n            balance: liquidityMinted,\\n            withdrawnBalance: 0,\\n            timestamp: uint48(block.timestamp),\\n            locked: _lock\\n        });\\n        deposits[_msgSender()][nonce] = newDeposit;\\n        emit ProvidedLiquidity(_msgSender(), _lock, nonce, liquidityMinted);\\n    }\\n\\n    /// @notice allows to withdraw unlocked tokens\\n    /// @dev    for locked tokens allows full withdrawal after lock period is over\\n    /// @dev    for vested tokens allows to withdraw partial unlocked amount\\n    /// @param  _id deposit id to withdraw\\n    function withdraw(uint256 _id) external nonReentrant {\\n        Deposit storage deposit = deposits[_msgSender()][_id];\\n        require(nonces[_msgSender()] \\u003e _id, \\\"Liquidity: No deposit found for provided id\\\");\\n        uint256 tokensToWithdraw = _withdrawableBalance(deposit);\\n        require(tokensToWithdraw \\u003e 0, \\\"Liquidity: No unlocked tokens to withdraw for provided id\\\");\\n        deposit.withdrawnBalance += tokensToWithdraw;\\n        assert(uniswapPair.transfer(_msgSender(), tokensToWithdraw));\\n        emit Withdraw(_msgSender(), deposit.locked, _id, tokensToWithdraw);\\n    }\\n\\n    /// @notice sets new duration of lock period\\n    /// @dev only callable by owner\\n    /// @param _newPeriod new period duration in seconds\\n    function setLockPeriod(uint256 _newPeriod) external onlyOwner {\\n        emit LockPeriodUpdated(lockPeriod, _newPeriod);\\n        lockPeriod = _newPeriod;\\n    }\\n\\n    /// @notice sets new duration of vesting period\\n    /// @dev only callable by owner\\n    /// @param _newPeriod new period duration in seconds\\n    function setVestingPeriod(uint256 _newPeriod) external onlyOwner {\\n        emit VestingPeriodUpdated(vestingPeriod, _newPeriod);\\n        vestingPeriod = _newPeriod;\\n    }\\n\\n    /// @dev returns deposited balance for a specific account and token id\\n    function depositedBalance(address _account, uint256 _id) external view returns (uint256) {\\n        if (_id \\u003e= nonces[_account]) {\\n            return 0;\\n        }\\n        return deposits[_account][_id].balance;\\n    }\\n\\n    /// @dev returns withdrawable balance for a specific account and token id\\n    function withdrawableBalance(address _account, uint256 _id) external view returns (uint256) {\\n        Deposit memory deposit = deposits[_account][_id];\\n        return _withdrawableBalance(deposit);\\n    }\\n\\n    function _provideLiquidity(uint256 _amountETH) private returns (uint256 liquidityMinted) {\\n        require(_amountETH \\u003e 0, \\\"Liquidity: No ETH provided\\\");\\n        (uint256 reserve0, uint256 reserve1, ) = uniswapPair.getReserves();\\n        assert(reserve0 \\u003e 0 \\u0026\\u0026 reserve1 \\u003e 0);\\n        (uint256 reserveA, uint256 reserveB) = address(token) == _token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n        uint256 amountToken = (_amountETH * (reserveA)) / reserveB;\\n        require(amountToken \\u003c= token.balanceOf(address(this)), \\\"Liquidity: Insufficient token amount in contract\\\");\\n        assert(token.transfer(address(uniswapPair), amountToken));\\n        IWETH weth = IWETH(_WETH);\\n        weth.deposit{value: _amountETH}();\\n        assert(weth.transfer(address(uniswapPair), _amountETH));\\n        liquidityMinted = uniswapPair.mint(address(this));\\n    }\\n\\n    function _withdrawableBalance(Deposit memory _deposit) private view returns (uint256) {\\n        if (_deposit.locked) {\\n            return\\n                _deposit.timestamp + lockPeriod \\u003c= block.timestamp ? _deposit.balance - _deposit.withdrawnBalance : 0;\\n        } else {\\n            uint256 amountTokensLocked = 0;\\n            if (_deposit.timestamp + vestingPeriod \\u003e block.timestamp) {\\n                amountTokensLocked =\\n                    _deposit.balance -\\n                    ((_deposit.balance * (block.timestamp - _deposit.timestamp)) / vestingPeriod);\\n            }\\n            return _deposit.balance - amountTokensLocked - _deposit.withdrawnBalance;\\n        }\\n    }\\n}\\n\"},\"OwnedInitializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport \\\"./Initializable.sol\\\";\\nimport \\\"./ContextUpgradeable.sol\\\";\\n\\ncontract OwnedInitializable is Initializable, ContextUpgradeable {\\n    address public owner;\\n    address public proposedOwner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        owner = _msgSender();\\n        emit OwnershipTransferred(address(0), _msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"Owned: not owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev propeses a new owner\\n     * Can only be called by the current owner.\\n     */\\n    function proposeOwner(address payable _newOwner) external onlyOwner {\\n        proposedOwner = _newOwner;\\n    }\\n\\n    /**\\n     * @dev claims ownership of the contract\\n     * Can only be called by the new proposed owner.\\n     */\\n    function claimOwnership() external {\\n        require(msg.sender == proposedOwner);\\n        emit OwnershipTransferred(owner, proposedOwner);\\n        owner = proposedOwner;\\n    }\\n}\\n\"},\"ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal initializer {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal initializer {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"LockPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLiquidity\",\"type\":\"uint256\"}],\"name\":\"ProvidedLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"VestingPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLiquidity\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"depositedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"timestamp\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapPair\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"proposeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_lock\",\"type\":\"bool\"}],\"name\":\"provideLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPeriod\",\"type\":\"uint256\"}],\"name\":\"setLockPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPeriod\",\"type\":\"uint256\"}],\"name\":\"setVestingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapPair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"withdrawableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Liquidity", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c2ba0293a8a87eeca0fef1213da03e00b72b132565795fdc9910f130570d0b93"}]}