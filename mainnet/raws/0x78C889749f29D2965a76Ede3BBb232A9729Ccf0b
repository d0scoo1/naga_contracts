{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"ArtistAcceptingBidsV2.sol\":{\"content\":\"pragma solidity 0.4.24;\\n\\nimport \\\"./Whitelist.sol\\\";\\nimport \\\"./Pausable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IKODAV2.sol\\\";\\n\\n/**\\n* Auction V2 interface definition - event and method definitions\\n*\\n* https://www.knownorigin.io/\\n*/\\ninterface IAuctionV2 {\\n\\n  event BidPlaced(\\n    address indexed _bidder,\\n    uint256 indexed _editionNumber,\\n    uint256 _amount\\n  );\\n\\n  event BidIncreased(\\n    address indexed _bidder,\\n    uint256 indexed _editionNumber,\\n    uint256 _amount\\n  );\\n\\n  event BidWithdrawn(\\n    address indexed _bidder,\\n    uint256 indexed _editionNumber\\n  );\\n\\n  event BidAccepted(\\n    address indexed _bidder,\\n    uint256 indexed _editionNumber,\\n    uint256 indexed _tokenId,\\n    uint256 _amount\\n  );\\n\\n  event BidRejected(\\n    address indexed _caller,\\n    address indexed _bidder,\\n    uint256 indexed _editionNumber,\\n    uint256 _amount\\n  );\\n\\n  event BidderRefunded(\\n    uint256 indexed _editionNumber,\\n    address indexed _bidder,\\n    uint256 _amount\\n  );\\n\\n  event AuctionCancelled(\\n    uint256 indexed _editionNumber\\n  );\\n\\n  event AuctionEnabled(\\n    uint256 indexed _editionNumber,\\n    address indexed _auctioneer\\n  );\\n\\n  event AuctionDisabled(\\n    uint256 indexed _editionNumber,\\n    address indexed _auctioneer\\n  );\\n\\n  function placeBid(uint256 _editionNumber) payable external returns (bool success);\\n\\n  function increaseBid(uint256 _editionNumber) payable external returns (bool success);\\n\\n  function withdrawBid(uint256 _editionNumber) external returns (bool success);\\n\\n  function acceptBid(uint256 _editionNumber) external returns (uint256 tokenId);\\n\\n  function rejectBid(uint256 _editionNumber) external returns (bool success);\\n\\n  function cancelAuction(uint256 _editionNumber) external returns (bool success);\\n}\\n\\n/**\\n* @title Artists accepting bidding contract for KnownOrigin (KODA)\\n*\\n* Rules:\\n* Can only bid for an edition which is enabled\\n* Can only add new bids higher than previous highest bid plus minimum bid amount\\n* Can increase your bid, only if you are the top current bidder\\n* Once outbid, original bidder has ETH returned\\n* Cannot double bid once you are already the highest bidder, can only call increaseBid()\\n* Only the defined controller address can accept the bid\\n* If a bid is revoked, the auction remains open however no highest bid exists\\n* If the contract is Paused, no public actions can happen e.g. bids, increases, withdrawals\\n* Managers of contract have full control over it act as a fallback in-case funds go missing or errors are found\\n* On accepting of any bid, funds are split to KO and Artists - optional 3rd party split not currently supported\\n* If an edition is sold out, the auction is stopped, manual refund required by bidder or whitelisted\\n* Upon cancelling a bid which is in flight, funds are returned and contract stops further bids on the edition\\n* Artists commissions and address are pulled from the KODA contract and are not based on the controller address\\n*\\n* Scenario:\\n* 1) Config artist (Dave) \\u0026 edition (1000)\\n* 2) Bob places a bid on edition 1000 for 1 ETH\\n* 3) Alice places a higher bid of 1.5ETH, overriding Bobs position as the leader, sends Bobs 1 ETH back and taking 1st place\\n* 4) Dave accepts Alice\\u0027s bid\\n* 5) KODA token generated and transferred to Alice, funds are split between KO and Artist\\n*\\n* https://www.knownorigin.io/\\n*\\n* BE ORIGINAL. BUY ORIGINAL.\\n*/\\ncontract ArtistAcceptingBidsV2 is Whitelist, Pausable, IAuctionV2 {\\n  using SafeMath for uint256;\\n\\n  // A mapping of the controller address to the edition number\\n  mapping(uint256 =\\u003e address) public editionNumberToArtistControlAddress;\\n\\n  // Enabled/disable the auction for the edition number\\n  mapping(uint256 =\\u003e bool) public enabledEditions;\\n\\n  // Edition to current highest bidders address\\n  mapping(uint256 =\\u003e address) public editionHighestBid;\\n\\n  // Mapping for edition -\\u003e bidder -\\u003e bid amount\\n  mapping(uint256 =\\u003e mapping(address =\\u003e uint256)) internal editionBids;\\n\\n  // A simple list of editions which have been once added to this contract\\n  uint256[] public editionsOnceEnabledForAuctions;\\n\\n  // Min increase in bid amount\\n  uint256 public minBidAmount = 0.01 ether;\\n\\n  // Interface into the KODA world\\n  IKODAV2 public kodaAddress;\\n\\n  // KO account which can receive commission\\n  address public koCommissionAccount;\\n\\n  ///////////////\\n  // Modifiers //\\n  ///////////////\\n\\n  // Checks the auction is enabled\\n  modifier whenAuctionEnabled(uint256 _editionNumber) {\\n    require(enabledEditions[_editionNumber], \\\"Edition is not enabled for auctions\\\");\\n    _;\\n  }\\n\\n  // Checks the msg.sender is the artists control address or the auction whitelisted\\n  modifier whenCallerIsController(uint256 _editionNumber) {\\n    require(editionNumberToArtistControlAddress[_editionNumber] == msg.sender || whitelist(msg.sender), \\\"Edition not managed by calling address\\\");\\n    _;\\n  }\\n\\n  // Checks the bid is higher than the current amount + min bid\\n  modifier whenPlacedBidIsAboveMinAmount(uint256 _editionNumber) {\\n    address currentHighestBidder = editionHighestBid[_editionNumber];\\n    uint256 currentHighestBidderAmount = editionBids[_editionNumber][currentHighestBidder];\\n    require(currentHighestBidderAmount.add(minBidAmount) \\u003c= msg.value, \\\"Bids must be higher than previous bids plus minimum bid\\\");\\n    _;\\n  }\\n\\n  // Checks the bid is higher than the min bid\\n  modifier whenBidIncreaseIsAboveMinAmount() {\\n    require(minBidAmount \\u003c= msg.value, \\\"Bids must be higher than minimum bid amount\\\");\\n    _;\\n  }\\n\\n  // Check the caller in not already the highest bidder\\n  modifier whenCallerNotAlreadyTheHighestBidder(uint256 _editionNumber) {\\n    address currentHighestBidder = editionHighestBid[_editionNumber];\\n    require(currentHighestBidder != msg.sender, \\\"Cant bid anymore, you are already the current highest\\\");\\n    _;\\n  }\\n\\n  // Checks msg.sender is the highest bidder\\n  modifier whenCallerIsHighestBidder(uint256 _editionNumber) {\\n    require(editionHighestBid[_editionNumber] == msg.sender, \\\"Can only withdraw a bid if you are the highest bidder\\\");\\n    _;\\n  }\\n\\n  // Only when editions are not sold out in KODA\\n  modifier whenEditionNotSoldOut(uint256 _editionNumber) {\\n    uint256 totalRemaining = kodaAddress.totalRemaining(_editionNumber);\\n    require(totalRemaining \\u003e 0, \\\"Unable to accept any more bids, edition is sold out\\\");\\n    _;\\n  }\\n\\n  // Only when edition exists in KODA\\n  modifier whenEditionExists(uint256 _editionNumber) {\\n    bool editionExists = kodaAddress.editionExists(_editionNumber);\\n    require(editionExists, \\\"Edition does not exist\\\");\\n    _;\\n  }\\n\\n  /////////////////\\n  // Constructor //\\n  /////////////////\\n\\n  // Set the caller as the default KO account\\n  constructor(IKODAV2 _kodaAddress) public {\\n    kodaAddress = _kodaAddress;\\n    koCommissionAccount = msg.sender;\\n    super.addAddressToWhitelist(msg.sender);\\n  }\\n\\n  //////////////////////////\\n  // Core Auction Methods //\\n  //////////////////////////\\n\\n  /**\\n   * @dev Public method for placing a bid, reverts if:\\n   * - Contract is Paused\\n   * - Edition provided is not valid\\n   * - Edition provided is not configured for auctions\\n   * - Edition provided is sold out\\n   * - msg.sender is already the highest bidder\\n   * - msg.value is not greater than highest bid + minimum amount\\n   * @dev refunds the previous bidders ether if the bid is overwritten\\n   * @return true on success\\n   */\\n  function placeBid(uint256 _editionNumber)\\n  public\\n  payable\\n  whenNotPaused\\n  whenEditionExists(_editionNumber)\\n  whenAuctionEnabled(_editionNumber)\\n  whenPlacedBidIsAboveMinAmount(_editionNumber)\\n  whenCallerNotAlreadyTheHighestBidder(_editionNumber)\\n  whenEditionNotSoldOut(_editionNumber)\\n  returns (bool success)\\n  {\\n    // Grab the previous holders bid so we can refund it\\n    _refundHighestBidder(_editionNumber);\\n\\n    // Keep a record of the current users bid (previous bidder has been refunded)\\n    editionBids[_editionNumber][msg.sender] = msg.value;\\n\\n    // Update the highest bid to be the latest bidder\\n    editionHighestBid[_editionNumber] = msg.sender;\\n\\n    // Emit event\\n    emit BidPlaced(msg.sender, _editionNumber, msg.value);\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Public method for increasing your bid, reverts if:\\n   * - Contract is Paused\\n   * - Edition provided is not valid\\n   * - Edition provided is not configured for auctions\\n   * - Edition provided is sold out\\n   * - msg.sender is not the current highest bidder\\n   * @return true on success\\n   */\\n  function increaseBid(uint256 _editionNumber)\\n  public\\n  payable\\n  whenNotPaused\\n  whenBidIncreaseIsAboveMinAmount\\n  whenEditionExists(_editionNumber)\\n  whenAuctionEnabled(_editionNumber)\\n  whenEditionNotSoldOut(_editionNumber)\\n  whenCallerIsHighestBidder(_editionNumber)\\n  returns (bool success)\\n  {\\n    // Bump the current highest bid by provided amount\\n    editionBids[_editionNumber][msg.sender] = editionBids[_editionNumber][msg.sender].add(msg.value);\\n\\n    // Emit event\\n    emit BidIncreased(msg.sender, _editionNumber, editionBids[_editionNumber][msg.sender]);\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Public method for withdrawing your bid, reverts if:\\n   * - Contract is Paused\\n   * - msg.sender is not the current highest bidder\\n   * @dev removes current highest bid so there is no current highest bidder\\n   * @return true on success\\n   */\\n  function withdrawBid(uint256 _editionNumber)\\n  public\\n  whenNotPaused\\n  whenEditionExists(_editionNumber)\\n  whenCallerIsHighestBidder(_editionNumber)\\n  returns (bool success)\\n  {\\n    // get current highest bid and refund it\\n    _refundHighestBidder(_editionNumber);\\n\\n    // Fire event\\n    emit BidWithdrawn(msg.sender, _editionNumber);\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Method for cancelling an auction, only called from contract whitelist\\n   * @dev refunds previous highest bidders bid\\n   * @dev removes current highest bid so there is no current highest bidder\\n   * @return true on success\\n   */\\n  function cancelAuction(uint256 _editionNumber)\\n  public\\n  onlyIfWhitelisted(msg.sender)\\n  whenEditionExists(_editionNumber)\\n  returns (bool success)\\n  {\\n    // get current highest bid and refund it\\n    _refundHighestBidder(_editionNumber);\\n\\n    // Disable the auction\\n    enabledEditions[_editionNumber] = false;\\n\\n    // Fire event\\n    emit AuctionCancelled(_editionNumber);\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Public method for increasing your bid, reverts if:\\n   * - Contract is Paused\\n   * - Edition provided is not valid\\n   * - Edition provided is not configured for auctions\\n   * - Edition provided is sold out\\n   * - msg.sender is not the current highest bidder\\n   * @return true on success\\n   */\\n  function rejectBid(uint256 _editionNumber)\\n  public\\n  whenNotPaused\\n  whenEditionExists(_editionNumber)\\n  whenCallerIsController(_editionNumber) // Checks only the controller can call this\\n  whenAuctionEnabled(_editionNumber) // Checks auction is still enabled\\n  returns (bool success)\\n  {\\n    address rejectedBidder = editionHighestBid[_editionNumber];\\n    uint256 rejectedBidAmount = editionBids[_editionNumber][rejectedBidder];\\n\\n    // get current highest bid and refund it\\n    _refundHighestBidder(_editionNumber);\\n\\n    emit BidRejected(msg.sender, rejectedBidder, _editionNumber, rejectedBidAmount);\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Method for accepting the highest bid, only called by edition creator, reverts if:\\n   * - Contract is Paused\\n   * - msg.sender is not the edition controller\\n   * - Edition provided is not valid\\n   * @dev Mints a new token in KODA contract\\n   * @dev Splits bid amount to KO and Artist, based on KODA contract defined values\\n   * @dev Removes current highest bid so there is no current highest bidder\\n   * @dev If no more editions are available the auction is stopped\\n   * @return the generated tokenId on success\\n   */\\n  function acceptBid(uint256 _editionNumber)\\n  public\\n  whenNotPaused\\n  whenCallerIsController(_editionNumber) // Checks only the controller can call this\\n  whenAuctionEnabled(_editionNumber) // Checks auction is still enabled\\n  returns (uint256 tokenId)\\n  {\\n    // Get total remaining here so we can use it below\\n    uint256 totalRemaining = kodaAddress.totalRemaining(_editionNumber);\\n    require(totalRemaining \\u003e 0, \\\"Unable to accept bid, edition is sold out\\\");\\n\\n    // Get the winner of the bidding action\\n    address winningAccount = editionHighestBid[_editionNumber];\\n    require(winningAccount != address(0), \\\"Cannot win an auction when there is no highest bidder\\\");\\n\\n    uint256 winningBidAmount = editionBids[_editionNumber][winningAccount];\\n    require(winningBidAmount \\u003e= 0, \\\"Cannot win an auction when no bid amount set\\\");\\n\\n    // Mint a new token to the winner\\n    uint256 _tokenId = kodaAddress.mint(winningAccount, _editionNumber);\\n    require(_tokenId != 0, \\\"Failed to mint new token\\\");\\n\\n    // Split the monies\\n    _handleFunds(_editionNumber, winningBidAmount);\\n\\n    // Clear out highest bidder for this auction\\n    delete editionHighestBid[_editionNumber];\\n\\n    // If the edition is sold out, disable the auction\\n    if (totalRemaining.sub(1) == 0) {\\n      enabledEditions[_editionNumber] = false;\\n    }\\n\\n    // Fire event\\n    emit BidAccepted(winningAccount, _editionNumber, _tokenId, winningBidAmount);\\n\\n    return _tokenId;\\n  }\\n\\n  /**\\n   * Handle all splitting of funds to the artist, any optional split and KO\\n   */\\n  function _handleFunds(uint256 _editionNumber, uint256 _winningBidAmount) internal {\\n\\n    // Get the commission and split bid amount accordingly\\n    (address artistAccount, uint256 artistCommission) = kodaAddress.artistCommission(_editionNumber);\\n\\n    // Extract the artists commission and send it\\n    uint256 artistPayment = _winningBidAmount.div(100).mul(artistCommission);\\n    artistAccount.transfer(artistPayment);\\n\\n    // Optional Commission Splits\\n    (uint256 optionalCommissionRate, address optionalCommissionRecipient) = kodaAddress.editionOptionalCommission(_editionNumber);\\n\\n    // Apply optional commission structure if we have one\\n    if (optionalCommissionRate \\u003e 0) {\\n      uint256 rateSplit = _winningBidAmount.div(100).mul(optionalCommissionRate);\\n      optionalCommissionRecipient.transfer(rateSplit);\\n    }\\n\\n    // Send KO remaining amount\\n    uint256 remainingCommission = _winningBidAmount.sub(artistPayment).sub(rateSplit);\\n    koCommissionAccount.transfer(remainingCommission);\\n  }\\n\\n  /**\\n   * Returns funds of the previous highest bidder back to them if present\\n   */\\n  function _refundHighestBidder(uint256 _editionNumber) internal {\\n    // Get current highest bidder\\n    address currentHighestBidder = editionHighestBid[_editionNumber];\\n\\n    // Get current highest bid amount\\n    uint256 currentHighestBiddersAmount = editionBids[_editionNumber][currentHighestBidder];\\n\\n    if (currentHighestBidder != address(0) \\u0026\\u0026 currentHighestBiddersAmount \\u003e 0) {\\n\\n      // Clear out highest bidder as there is no long one\\n      delete editionHighestBid[_editionNumber];\\n\\n      // Refund it\\n      currentHighestBidder.transfer(currentHighestBiddersAmount);\\n\\n      // Emit event\\n      emit BidderRefunded(_editionNumber, currentHighestBidder, currentHighestBiddersAmount);\\n    }\\n  }\\n\\n  ///////////////////////////////\\n  // Public management methods //\\n  ///////////////////////////////\\n\\n  /**\\n   * @dev Enables the edition for auctions in a single call\\n   * @dev Only callable from whitelisted account or KODA edition artists\\n   */\\n  function enableEditionForArtist(uint256 _editionNumber)\\n  public\\n  whenNotPaused\\n  whenEditionExists(_editionNumber)\\n  returns (bool)\\n  {\\n    // Ensure caller is whitelisted or artists\\n    (address artistAccount, uint256 artistCommission) = kodaAddress.artistCommission(_editionNumber);\\n    require(whitelist(msg.sender) || msg.sender == artistAccount, \\\"Cannot enable when not the edition artist\\\");\\n\\n    // Ensure not already setup\\n    require(!enabledEditions[_editionNumber], \\\"Edition already enabled\\\");\\n\\n    // Enable the auction\\n    enabledEditions[_editionNumber] = true;\\n\\n    // keep track of the edition\\n    editionsOnceEnabledForAuctions.push(_editionNumber);\\n\\n    // Setup the controller address to be the artist\\n    editionNumberToArtistControlAddress[_editionNumber] = artistAccount;\\n\\n    emit AuctionEnabled(_editionNumber, msg.sender);\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Enables the edition for auctions\\n   * @dev Only callable from whitelist\\n   */\\n  function enableEdition(uint256 _editionNumber)\\n  onlyIfWhitelisted(msg.sender)\\n  public returns (bool) {\\n    enabledEditions[_editionNumber] = true;\\n    emit AuctionEnabled(_editionNumber, msg.sender);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Disables the edition for auctions\\n   * @dev Only callable from whitelist\\n   */\\n  function disableEdition(uint256 _editionNumber)\\n  onlyIfWhitelisted(msg.sender)\\n  public returns (bool) {\\n    enabledEditions[_editionNumber] = false;\\n    emit AuctionDisabled(_editionNumber, msg.sender);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Sets the edition artist control address\\n   * @dev Only callable from whitelist\\n   */\\n  function setArtistsControlAddress(uint256 _editionNumber, address _address)\\n  onlyIfWhitelisted(msg.sender)\\n  public returns (bool) {\\n    editionNumberToArtistControlAddress[_editionNumber] = _address;\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Sets the edition artist control address and enables the edition for auction\\n   * @dev Only callable from whitelist\\n   */\\n  function setArtistsControlAddressAndEnabledEdition(uint256 _editionNumber, address _address)\\n  onlyIfWhitelisted(msg.sender)\\n  public returns (bool) {\\n    require(!enabledEditions[_editionNumber], \\\"Edition already enabled\\\");\\n\\n    // Enable the edition\\n    enabledEditions[_editionNumber] = true;\\n\\n    // Setup the artist address for this edition\\n    editionNumberToArtistControlAddress[_editionNumber] = _address;\\n\\n    // keep track of the edition\\n    editionsOnceEnabledForAuctions.push(_editionNumber);\\n\\n    emit AuctionEnabled(_editionNumber, _address);\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Sets the minimum bid amount\\n   * @dev Only callable from whitelist\\n   */\\n  function setMinBidAmount(uint256 _minBidAmount) onlyIfWhitelisted(msg.sender) public {\\n    minBidAmount = _minBidAmount;\\n  }\\n\\n  /**\\n   * @dev Sets the KODA address\\n   * @dev Only callable from whitelist\\n   */\\n  function setKodavV2(IKODAV2 _kodaAddress) onlyIfWhitelisted(msg.sender) public {\\n    kodaAddress = _kodaAddress;\\n  }\\n\\n  /**\\n   * @dev Sets the KODA address\\n   * @dev Only callable from whitelist\\n   */\\n  function setKoCommissionAccount(address _koCommissionAccount) public onlyIfWhitelisted(msg.sender) {\\n    require(_koCommissionAccount != address(0), \\\"Invalid address\\\");\\n    koCommissionAccount = _koCommissionAccount;\\n  }\\n\\n  /////////////////////////////\\n  // Manual Override methods //\\n  /////////////////////////////\\n\\n  /**\\n   * @dev Allows for the ability to extract ether so we can distribute to the correct bidders accordingly\\n   * @dev Only callable from whitelist\\n   */\\n  function withdrawStuckEther(address _withdrawalAccount)\\n  onlyIfWhitelisted(msg.sender)\\n  public {\\n    require(_withdrawalAccount != address(0), \\\"Invalid address provided\\\");\\n    require(address(this).balance != 0, \\\"No more ether to withdraw\\\");\\n    _withdrawalAccount.transfer(address(this).balance);\\n  }\\n\\n  /**\\n   * @dev Allows for the ability to extract specific ether amounts so we can distribute to the correct bidders accordingly\\n   * @dev Only callable from whitelist\\n   */\\n  function withdrawStuckEtherOfAmount(address _withdrawalAccount, uint256 _amount)\\n  onlyIfWhitelisted(msg.sender)\\n  public {\\n    require(_withdrawalAccount != address(0), \\\"Invalid address provided\\\");\\n    require(_amount != 0, \\\"Invalid amount to withdraw\\\");\\n    require(address(this).balance \\u003e= _amount, \\\"No more ether to withdraw\\\");\\n    _withdrawalAccount.transfer(_amount);\\n  }\\n\\n  /**\\n   * @dev Manual override method for setting edition highest bid \\u0026 the highest bidder to the provided address\\n   * @dev Only callable from whitelist\\n   */\\n  function manualOverrideEditionHighestBidAndBidder(uint256 _editionNumber, address _bidder, uint256 _amount)\\n  onlyIfWhitelisted(msg.sender)\\n  public returns (bool) {\\n    editionBids[_editionNumber][_bidder] = _amount;\\n    editionHighestBid[_editionNumber] = _bidder;\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Manual override method removing bidding values\\n   * @dev Only callable from whitelist\\n   */\\n  function manualDeleteEditionBids(uint256 _editionNumber, address _bidder)\\n  onlyIfWhitelisted(msg.sender)\\n  public returns (bool) {\\n    delete editionHighestBid[_editionNumber];\\n    delete editionBids[_editionNumber][_bidder];\\n    return true;\\n  }\\n\\n  //////////////////////////\\n  // Public query methods //\\n  //////////////////////////\\n\\n  /**\\n   * @dev Look up all the known data about the latest edition bidding round\\n   * @dev Returns zeros for all values when not valid\\n   */\\n  function auctionDetails(uint256 _editionNumber) public view returns (bool _enabled, address _bidder, uint256 _value, address _controller) {\\n    address highestBidder = editionHighestBid[_editionNumber];\\n    uint256 bidValue = editionBids[_editionNumber][highestBidder];\\n    address controlAddress = editionNumberToArtistControlAddress[_editionNumber];\\n    return (\\n    enabledEditions[_editionNumber],\\n    highestBidder,\\n    bidValue,\\n    controlAddress\\n    );\\n  }\\n\\n  /**\\n   * @dev Look up all the current highest bidder for the latest edition\\n   * @dev Returns zeros for all values when not valid\\n   */\\n  function highestBidForEdition(uint256 _editionNumber) public view returns (address _bidder, uint256 _value) {\\n    address highestBidder = editionHighestBid[_editionNumber];\\n    uint256 bidValue = editionBids[_editionNumber][highestBidder];\\n    return (highestBidder, bidValue);\\n  }\\n\\n  /**\\n   * @dev Check an edition is enabled for auction\\n   */\\n  function isEditionEnabled(uint256 _editionNumber) public view returns (bool) {\\n    return enabledEditions[_editionNumber];\\n  }\\n\\n  /**\\n   * @dev Check which address can action a bid for the given edition\\n   */\\n  function editionController(uint256 _editionNumber) public view returns (address) {\\n    return editionNumberToArtistControlAddress[_editionNumber];\\n  }\\n\\n  /**\\n   * @dev Returns the array of edition numbers\\n   */\\n  function addedEditions() public view returns (uint256[]) {\\n    return editionsOnceEnabledForAuctions;\\n  }\\n\\n}\\n\"},\"IKODAV2.sol\":{\"content\":\"/**\\n* Minimal interface definition for KODA V2 contract calls\\n*\\n* https://www.knownorigin.io/\\n*/\\ninterface IKODAV2 {\\n  function mint(address _to, uint256 _editionNumber) external returns (uint256);\\n\\n  function editionExists(uint256 _editionNumber) external returns (bool);\\n\\n  function totalRemaining(uint256 _editionNumber) external view returns (uint256);\\n\\n  function artistCommission(uint256 _editionNumber) external view returns (address _artistAccount, uint256 _artistCommission);\\n\\n  function editionOptionalCommission(uint256 _editionNumber) external view returns (uint256 _rate, address _recipient);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n  address public owner;\\n\\n\\n  event OwnershipRenounced(address indexed previousOwner);\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to relinquish control of the contract.\\n   * @notice Renouncing to ownership will leave the contract without an owner.\\n   * It will not be possible to call the functions with the `onlyOwner`\\n   * modifier anymore.\\n   */\\n  function renounceOwnership() public onlyOwner {\\n    emit OwnershipRenounced(owner);\\n    owner = address(0);\\n  }\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param _newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address _newOwner) public onlyOwner {\\n    _transferOwnership(_newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers control of the contract to a newOwner.\\n   * @param _newOwner The address to transfer ownership to.\\n   */\\n  function _transferOwnership(address _newOwner) internal {\\n    require(_newOwner != address(0));\\n    emit OwnershipTransferred(owner, _newOwner);\\n    owner = _newOwner;\\n  }\\n}\"},\"Pausable.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n\\n/**\\n * @title Pausable\\n * @dev Base contract which allows children to implement an emergency stop mechanism.\\n */\\ncontract Pausable is Ownable {\\n  event Pause();\\n  event Unpause();\\n\\n  bool public paused = false;\\n\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!paused);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is paused.\\n   */\\n  modifier whenPaused() {\\n    require(paused);\\n    _;\\n  }\\n\\n  /**\\n   * @dev called by the owner to pause, triggers stopped state\\n   */\\n  function pause() public onlyOwner whenNotPaused {\\n    paused = true;\\n    emit Pause();\\n  }\\n\\n  /**\\n   * @dev called by the owner to unpause, returns to normal state\\n   */\\n  function unpause() public onlyOwner whenPaused {\\n    paused = false;\\n    emit Unpause();\\n  }\\n}\"},\"RBAC.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./Roles.sol\\\";\\n\\n\\n/**\\n * @title RBAC (Role-Based Access Control)\\n * @author Matt Condon (@Shrugs)\\n * @dev Stores and provides setters and getters for roles and addresses.\\n * Supports unlimited numbers of roles and addresses.\\n * See //contracts/mocks/RBACMock.sol for an example of usage.\\n * This RBAC method uses strings to key roles. It may be beneficial\\n * for you to write your own implementation of this interface using Enums or similar.\\n */\\ncontract RBAC {\\n  using Roles for Roles.Role;\\n\\n  mapping (string =\\u003e Roles.Role) private roles;\\n\\n  event RoleAdded(address indexed operator, string role);\\n  event RoleRemoved(address indexed operator, string role);\\n\\n  /**\\n   * @dev reverts if addr does not have role\\n   * @param _operator address\\n   * @param _role the name of the role\\n   * // reverts\\n   */\\n  function checkRole(address _operator, string _role)\\n    public\\n    view\\n  {\\n    roles[_role].check(_operator);\\n  }\\n\\n  /**\\n   * @dev determine if addr has role\\n   * @param _operator address\\n   * @param _role the name of the role\\n   * @return bool\\n   */\\n  function hasRole(address _operator, string _role)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    return roles[_role].has(_operator);\\n  }\\n\\n  /**\\n   * @dev add a role to an address\\n   * @param _operator address\\n   * @param _role the name of the role\\n   */\\n  function addRole(address _operator, string _role)\\n    internal\\n  {\\n    roles[_role].add(_operator);\\n    emit RoleAdded(_operator, _role);\\n  }\\n\\n  /**\\n   * @dev remove a role from an address\\n   * @param _operator address\\n   * @param _role the name of the role\\n   */\\n  function removeRole(address _operator, string _role)\\n    internal\\n  {\\n    roles[_role].remove(_operator);\\n    emit RoleRemoved(_operator, _role);\\n  }\\n\\n  /**\\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\\n   * @param _role the name of the role\\n   * // reverts\\n   */\\n  modifier onlyRole(string _role)\\n  {\\n    checkRole(msg.sender, _role);\\n    _;\\n  }\\n\\n  /**\\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\\n   * @param _roles the names of the roles to scope access to\\n   * // reverts\\n   *\\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\\n   *  see: https://github.com/ethereum/solidity/issues/2467\\n   */\\n  // modifier onlyRoles(string[] _roles) {\\n  //     bool hasAnyRole = false;\\n  //     for (uint8 i = 0; i \\u003c _roles.length; i++) {\\n  //         if (hasRole(msg.sender, _roles[i])) {\\n  //             hasAnyRole = true;\\n  //             break;\\n  //         }\\n  //     }\\n\\n  //     require(hasAnyRole);\\n\\n  //     _;\\n  // }\\n}\"},\"Roles.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title Roles\\n * @author Francisco Giordano (@frangio)\\n * @dev Library for managing addresses assigned to a Role.\\n * See RBAC.sol for example usage.\\n */\\nlibrary Roles {\\n  struct Role {\\n    mapping (address =\\u003e bool) bearer;\\n  }\\n\\n  /**\\n   * @dev give an address access to this role\\n   */\\n  function add(Role storage _role, address _addr)\\n    internal\\n  {\\n    _role.bearer[_addr] = true;\\n  }\\n\\n  /**\\n   * @dev remove an address\\u0027 access to this role\\n   */\\n  function remove(Role storage _role, address _addr)\\n    internal\\n  {\\n    _role.bearer[_addr] = false;\\n  }\\n\\n  /**\\n   * @dev check if an address has this role\\n   * // reverts\\n   */\\n  function check(Role storage _role, address _addr)\\n    internal\\n    view\\n  {\\n    require(has(_role, _addr));\\n  }\\n\\n  /**\\n   * @dev check if an address has this role\\n   * @return bool\\n   */\\n  function has(Role storage _role, address _addr)\\n    internal\\n    view\\n    returns (bool)\\n  {\\n    return _role.bearer[_addr];\\n  }\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\\n    // Gas optimization: this is cheaper than asserting \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n    if (_a == 0) {\\n      return 0;\\n    }\\n\\n    c = _a * _b;\\n    assert(c / _a == _b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    // assert(_b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = _a / _b;\\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn\\u0027t hold\\n    return _a / _b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n    assert(_b \\u003c= _a);\\n    return _a - _b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\\n    c = _a + _b;\\n    assert(c \\u003e= _a);\\n    return c;\\n  }\\n}\"},\"Whitelist.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./RBAC.sol\\\";\\n\\n\\n/**\\n * @title Whitelist\\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\\n * This simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Whitelist is Ownable, RBAC {\\n  string public constant ROLE_WHITELISTED = \\\"whitelist\\\";\\n\\n  /**\\n   * @dev Throws if operator is not whitelisted.\\n   * @param _operator address\\n   */\\n  modifier onlyIfWhitelisted(address _operator) {\\n    checkRole(_operator, ROLE_WHITELISTED);\\n    _;\\n  }\\n\\n  /**\\n   * @dev add an address to the whitelist\\n   * @param _operator address\\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\\n   */\\n  function addAddressToWhitelist(address _operator)\\n    public\\n    onlyOwner\\n  {\\n    addRole(_operator, ROLE_WHITELISTED);\\n  }\\n\\n  /**\\n   * @dev getter to determine if address is in whitelist\\n   */\\n  function whitelist(address _operator)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    return hasRole(_operator, ROLE_WHITELISTED);\\n  }\\n\\n  /**\\n   * @dev add addresses to the whitelist\\n   * @param _operators addresses\\n   * @return true if at least one address was added to the whitelist,\\n   * false if all addresses were already in the whitelist\\n   */\\n  function addAddressesToWhitelist(address[] _operators)\\n    public\\n    onlyOwner\\n  {\\n    for (uint256 i = 0; i \\u003c _operators.length; i++) {\\n      addAddressToWhitelist(_operators[i]);\\n    }\\n  }\\n\\n  /**\\n   * @dev remove an address from the whitelist\\n   * @param _operator address\\n   * @return true if the address was removed from the whitelist,\\n   * false if the address wasn\\u0027t in the whitelist in the first place\\n   */\\n  function removeAddressFromWhitelist(address _operator)\\n    public\\n    onlyOwner\\n  {\\n    removeRole(_operator, ROLE_WHITELISTED);\\n  }\\n\\n  /**\\n   * @dev remove addresses from the whitelist\\n   * @param _operators addresses\\n   * @return true if at least one address was removed from the whitelist,\\n   * false if all addresses weren\\u0027t in the whitelist in the first place\\n   */\\n  function removeAddressesFromWhitelist(address[] _operators)\\n    public\\n    onlyOwner\\n  {\\n    for (uint256 i = 0; i \\u003c _operators.length; i++) {\\n      removeAddressFromWhitelist(_operators[i]);\\n    }\\n  }\\n\\n}\"}}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"increaseBid\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"highestBidForEdition\",\"outputs\":[{\"name\":\"_bidder\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"withdrawBid\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_WHITELISTED\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operators\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawalAccount\",\"type\":\"address\"}],\"name\":\"withdrawStuckEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"acceptBid\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addedEditions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minBidAmount\",\"type\":\"uint256\"}],\"name\":\"setMinBidAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"editionHighestBid\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBidAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"editionsOnceEnabledForAuctions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"editionController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"rejectBid\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"koCommissionAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"disableEdition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"editionNumberToArtistControlAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"auctionDetails\",\"outputs\":[{\"name\":\"_enabled\",\"type\":\"bool\"},{\"name\":\"_bidder\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_controller\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"enableEditionForArtist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_bidder\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"manualOverrideEditionHighestBidAndBidder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_koCommissionAccount\",\"type\":\"address\"}],\"name\":\"setKoCommissionAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_bidder\",\"type\":\"address\"}],\"name\":\"manualDeleteEditionBids\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"placeBid\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setArtistsControlAddressAndEnabledEdition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawalAccount\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStuckEtherOfAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_kodaAddress\",\"type\":\"address\"}],\"name\":\"setKodavV2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"enabledEditions\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setArtistsControlAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kodaAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operators\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"isEditionEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"enableEdition\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_kodaAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_bidder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BidPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_bidder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BidIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_bidder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"BidWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_bidder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BidAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_caller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_bidder\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BidRejected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BidderRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_editionNumber\",\"type\":\"uint256\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_auctioneer\",\"type\":\"address\"}],\"name\":\"AuctionEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_editionNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_auctioneer\",\"type\":\"address\"}],\"name\":\"AuctionDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "ArtistAcceptingBidsV2", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003ad503084f1bd8d15a7f5ebe7a038c064e1e3fa1", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://568eefcf2b7eefd7088af24ea0dadc63b627e9ff5a58b189ecf9bfd937d7333a"}]}