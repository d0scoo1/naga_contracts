{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PricePrediction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport './interfaces/AggregatorProxy.sol';\\nimport './interfaces/ISmoltingInu.sol';\\nimport './SmolGame.sol';\\n\\n/**\\n * @title PricePrediction\\n * @dev Predict if price goes up or down over a time period\\n */\\ncontract PricePrediction is SmolGame {\\n  uint256 private constant PERCENT_DENOMENATOR = 1000;\\n  address private constant DEAD = address(0xdead);\\n\\n  struct PredictionConfig {\\n    uint256 timePeriodSeconds;\\n    uint256 payoutPercentage;\\n  }\\n  struct Prediction {\\n    address priceFeedProxy;\\n    uint256 configTimePeriodSeconds;\\n    uint256 configPayoutPercentage;\\n    bool isLong; // true if price should go higher, otherwise price expected to go lower\\n    uint256 amountWagered;\\n    uint16 startPhaseId;\\n    uint80 startRoundId;\\n    uint16 endPhaseId; // not set until prediction is settled\\n    uint80 endRoundId; // not set until prediction is settled\\n    bool isDraw; // not set until prediction is settled\\n    bool isWinner; // not set until prediction is settled\\n  }\\n\\n  uint256 public minBalancePerc = (PERCENT_DENOMENATOR * 35) / 100; // 35% user's balance\\n  uint256 public minWagerAbsolute;\\n  uint256 public maxWagerAbsolute;\\n\\n  uint80 public roundIdStartOffset = 1;\\n\\n  address[] public validPriceFeedProxies;\\n  mapping(address => bool) public isValidPriceFeedProxy;\\n\\n  PredictionConfig[] public predictionOptions;\\n\\n  address public smol = 0x2bf6267c4997548d8de56087E5d48bDCCb877E77;\\n  ISmoltingInu private smolContract = ISmoltingInu(smol);\\n\\n  uint256 public totalPredictionsMade;\\n  uint256 public totalPredictionsWon;\\n  uint256 public totalPredictionsLost;\\n  uint256 public totalPredictionsDraw;\\n  uint256 public totalPredictionsAmountWon;\\n  uint256 public totalPredictionsAmountLost;\\n  // user => predictions[]\\n  mapping(address => Prediction[]) public predictions;\\n  mapping(address => uint256) public predictionsUserWon;\\n  mapping(address => uint256) public predictionsUserLost;\\n  mapping(address => uint256) public predictionsUserDraw;\\n  mapping(address => uint256) public predictionsAmountUserWon;\\n  mapping(address => uint256) public predictionsAmountUserLost;\\n\\n  event Predict(\\n    address indexed user,\\n    address indexed proxy,\\n    uint16 startPhase,\\n    uint80 startRound,\\n    uint256 amountWager\\n  );\\n  event Settle(\\n    address indexed user,\\n    address indexed proxy,\\n    bool isWinner,\\n    bool isDraw,\\n    uint256 amountWon\\n  );\\n\\n  function getAllValidPriceFeeds() external view returns (address[] memory) {\\n    return validPriceFeedProxies;\\n  }\\n\\n  function getNumberUserPredictions(address _user)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return predictions[_user].length;\\n  }\\n\\n  function getLatestUserPrediction(address _user)\\n    external\\n    view\\n    returns (Prediction memory)\\n  {\\n    require(predictions[_user].length > 0, 'no predictions for user');\\n    return predictions[_user][predictions[_user].length - 1];\\n  }\\n\\n  /**\\n   * Returns the latest price with returned value from a price feed proxy at 18 decimals\\n   * more info (proxy vs agg) here:\\n   * https://stackoverflow.com/questions/70377502/what-is-the-best-way-to-access-historical-price-data-from-chainlink-on-a-token-i/70389049#70389049\\n   *\\n   * https://docs.chain.link/docs/get-the-latest-price/\\n   */\\n  function getRoundInfoAndPriceUSD(address _proxy)\\n    public\\n    view\\n    returns (\\n      uint16,\\n      uint80,\\n      uint256\\n    )\\n  {\\n    // https://docs.chain.link/docs/reference-contracts/\\n    // https://github.com/pcaversaccio/chainlink-price-feed/blob/main/README.md\\n    AggregatorProxy priceFeed = AggregatorProxy(_proxy);\\n    uint16 phaseId = priceFeed.phaseId();\\n    uint8 decimals = priceFeed.decimals();\\n    (uint80 proxyRoundId, int256 price, , , ) = priceFeed.latestRoundData();\\n    return (phaseId, proxyRoundId, uint256(price) * (10**18 / 10**decimals));\\n  }\\n\\n  function getPriceUSDAtRound(address _proxy, uint80 _roundId)\\n    public\\n    view\\n    returns (uint256)\\n  {\\n    AggregatorProxy priceFeed = AggregatorProxy(_proxy);\\n    uint8 decimals = priceFeed.decimals();\\n    (, int256 price, , , ) = priceFeed.getRoundData(_roundId);\\n    return uint256(price) * (10**18 / 10**decimals);\\n  }\\n\\n  // https://docs.chain.link/docs/historical-price-data/\\n  function getHistoricalPriceFromAggregatorInfo(\\n    address _proxy,\\n    uint16 _phaseId,\\n    uint80 _aggRoundId,\\n    bool _requireCompletion\\n  )\\n    public\\n    view\\n    returns (\\n      uint80,\\n      uint256,\\n      uint256,\\n      uint80\\n    )\\n  {\\n    AggregatorProxy proxy = AggregatorProxy(_proxy);\\n    uint80 _proxyRoundId = _getProxyRoundId(_phaseId, _aggRoundId);\\n    (\\n      uint80 roundId,\\n      int256 price,\\n      ,\\n      uint256 timestamp,\\n      uint80 answeredInRound\\n    ) = proxy.getRoundData(_proxyRoundId);\\n    uint8 decimals = proxy.decimals();\\n    if (_requireCompletion) {\\n      require(timestamp > 0, 'Round not complete');\\n    }\\n    return (\\n      roundId,\\n      uint256(price) * (10**18 / 10**decimals),\\n      timestamp,\\n      answeredInRound\\n    );\\n  }\\n\\n  // _isLong: if true, user wants price to go up, else price should go down\\n  function predict(\\n    uint256 _configIndex,\\n    address _priceFeedProxy,\\n    uint256 _amountWager,\\n    bool _isLong\\n  ) external payable {\\n    require(\\n      isValidPriceFeedProxy[_priceFeedProxy],\\n      'not a valid price feed to predict'\\n    );\\n    require(\\n      _amountWager >=\\n        (smolContract.balanceOf(msg.sender) * minBalancePerc) /\\n          PERCENT_DENOMENATOR,\\n      'did not wager enough of balance'\\n    );\\n    require(_amountWager >= minWagerAbsolute, 'did not wager at least minimum');\\n    require(\\n      maxWagerAbsolute == 0 || _amountWager <= maxWagerAbsolute,\\n      'wagering more than maximum'\\n    );\\n\\n    address _user = msg.sender;\\n    if (predictions[_user].length > 0) {\\n      Prediction memory _openPrediction = predictions[_user][\\n        predictions[_user].length - 1\\n      ];\\n      require(\\n        _openPrediction.endRoundId > 0,\\n        'there is an open prediction you must settle before creating a new one'\\n      );\\n    }\\n\\n    smolContract.transferFrom(msg.sender, address(this), _amountWager);\\n    (uint16 _phaseId, uint80 _proxyRoundId, ) = getRoundInfoAndPriceUSD(\\n      _priceFeedProxy\\n    );\\n    (, uint64 _aggRoundId) = getAggregatorPhaseAndRoundId(_proxyRoundId);\\n    uint80 _startRoundId = _getProxyRoundId(\\n      _phaseId,\\n      _aggRoundId + roundIdStartOffset\\n    );\\n\\n    PredictionConfig memory _config = predictionOptions[_configIndex];\\n    require(_config.timePeriodSeconds > 0, 'invalid config provided');\\n\\n    Prediction memory _newPrediction = Prediction({\\n      priceFeedProxy: _priceFeedProxy,\\n      configTimePeriodSeconds: _config.timePeriodSeconds,\\n      configPayoutPercentage: _config.payoutPercentage,\\n      isLong: _isLong,\\n      amountWagered: _amountWager,\\n      startPhaseId: _phaseId,\\n      startRoundId: _startRoundId,\\n      endPhaseId: 0,\\n      endRoundId: 0,\\n      isDraw: false,\\n      isWinner: false\\n    });\\n    predictions[_user].push(_newPrediction);\\n\\n    totalPredictionsMade++;\\n    _payServiceFee();\\n    emit Predict(\\n      msg.sender,\\n      _priceFeedProxy,\\n      _phaseId,\\n      _startRoundId,\\n      _amountWager\\n    );\\n  }\\n\\n  // in order to settle an open prediction, the settling executor must know the\\n  // user with the open prediction they are settling and the round ID that corresponds\\n  // to the time it should be settled.\\n  function settlePrediction(\\n    address _user,\\n    uint16 _answeredPhaseId,\\n    uint80 _answeredAggRoundId\\n  ) public {\\n    _user = _user == address(0) ? msg.sender : _user;\\n    require(predictions[_user].length > 0, 'no predictions created yet');\\n    Prediction storage _openPrediction = predictions[_user][\\n      predictions[_user].length - 1\\n    ];\\n    require(\\n      _openPrediction.priceFeedProxy != address(0),\\n      'no predictions created yet to settle'\\n    );\\n    require(\\n      _openPrediction.endRoundId == 0,\\n      'latest prediction already settled'\\n    );\\n\\n    (\\n      ,\\n      uint256 priceStart,\\n      uint256 timestampStart,\\n      uint80 answeredInRoundIdStart\\n    ) = getHistoricalPriceFromAggregatorInfo(\\n        _openPrediction.priceFeedProxy,\\n        _openPrediction.startPhaseId,\\n        _openPrediction.startRoundId,\\n        true\\n      );\\n    require(\\n      answeredInRoundIdStart > 0 && timestampStart > 0,\\n      'start round is not fresh'\\n    );\\n    (\\n      uint80 roundActual,\\n      ,\\n      uint256 timestampActual,\\n\\n    ) = getHistoricalPriceFromAggregatorInfo(\\n        _openPrediction.priceFeedProxy,\\n        _answeredPhaseId,\\n        _answeredAggRoundId,\\n        true\\n      );\\n    (, , uint256 timestampAfter, ) = getHistoricalPriceFromAggregatorInfo(\\n      _openPrediction.priceFeedProxy,\\n      _answeredPhaseId,\\n      _answeredAggRoundId + 1,\\n      false\\n    );\\n    require(\\n      roundActual > 0 && timestampActual > 0,\\n      'actual round not finished yet'\\n    );\\n    require(\\n      timestampActual <=\\n        timestampStart + _openPrediction.configTimePeriodSeconds,\\n      'actual round was completed after our time period'\\n    );\\n    require(\\n      timestampAfter >\\n        timestampStart + _openPrediction.configTimePeriodSeconds ||\\n        (timestampAfter == 0 &&\\n          block.timestamp >\\n          timestampStart + _openPrediction.configTimePeriodSeconds),\\n      'after round was completed before our time period'\\n    );\\n\\n    uint256 settlePrice = getPriceUSDAtRound(\\n      _openPrediction.priceFeedProxy,\\n      roundActual\\n    );\\n\\n    bool _isDraw = settlePrice == priceStart;\\n    bool _isWinner = false;\\n    if (!_isDraw) {\\n      _isWinner = _openPrediction.isLong\\n        ? settlePrice > priceStart\\n        : settlePrice < priceStart;\\n    }\\n\\n    _openPrediction.endPhaseId = _answeredPhaseId;\\n    _openPrediction.endRoundId = roundActual;\\n    _openPrediction.isDraw = _isDraw;\\n    _openPrediction.isWinner = _isWinner;\\n\\n    uint256 _finalWinAmount = _isWinner\\n      ? (_openPrediction.amountWagered *\\n        _openPrediction.configPayoutPercentage) / PERCENT_DENOMENATOR\\n      : 0;\\n\\n    if (_isDraw || _isWinner) {\\n      smolContract.transfer(_user, _openPrediction.amountWagered);\\n      if (_finalWinAmount > 0) {\\n        smolContract.gameMint(_user, _finalWinAmount);\\n      }\\n    } else {\\n      smolContract.gameBurn(address(this), _openPrediction.amountWagered);\\n    }\\n\\n    _updateAnalytics(\\n      _user,\\n      _isDraw,\\n      _isWinner,\\n      _openPrediction.amountWagered,\\n      _finalWinAmount\\n    );\\n\\n    emit Settle(\\n      _user,\\n      _openPrediction.priceFeedProxy,\\n      _isWinner,\\n      _isDraw,\\n      _finalWinAmount\\n    );\\n  }\\n\\n  function settlePredictionShortCircuitLoss() external {\\n    require(predictions[msg.sender].length > 0, 'no predictions created yet');\\n    Prediction storage _prediction = predictions[msg.sender][\\n      predictions[msg.sender].length - 1\\n    ];\\n    require(\\n      _prediction.priceFeedProxy != address(0),\\n      'no predictions created yet to settle'\\n    );\\n    require(_prediction.endRoundId == 0, 'latest prediction already settled');\\n    // just set the end phase and round to the start if we short circuit here\\n    _prediction.endPhaseId = _prediction.startPhaseId;\\n    _prediction.endRoundId = _prediction.startRoundId;\\n    smolContract.gameBurn(address(this), _prediction.amountWagered);\\n    _updateAnalytics(msg.sender, false, false, _prediction.amountWagered, 0);\\n    emit Settle(msg.sender, _prediction.priceFeedProxy, false, false, 0);\\n  }\\n\\n  function settleMultiplePredictions(\\n    address[] memory _users,\\n    uint16[] memory _phaseIds,\\n    uint80[] memory _aggRoundIds\\n  ) external {\\n    require(_users.length == _phaseIds.length, 'need to be same size arrays');\\n    require(\\n      _users.length == _aggRoundIds.length,\\n      'need to be same size arrays'\\n    );\\n    for (uint256 i = 0; i < _users.length; i++) {\\n      settlePrediction(_users[i], _phaseIds[i], _aggRoundIds[i]);\\n    }\\n  }\\n\\n  function _updateAnalytics(\\n    address _user,\\n    bool _isDraw,\\n    bool _isWinner,\\n    uint256 _amountWagered,\\n    uint256 _finalWinAmount\\n  ) internal {\\n    totalPredictionsWon += _isWinner ? 1 : 0;\\n    predictionsUserWon[_user] += _isWinner ? 1 : 0;\\n    totalPredictionsLost += !_isWinner && !_isDraw ? 1 : 0;\\n    predictionsUserLost[_user] += !_isWinner && !_isDraw ? 1 : 0;\\n    totalPredictionsDraw += _isDraw ? 1 : 0;\\n    predictionsUserDraw[_user] += _isDraw ? 1 : 0;\\n    totalPredictionsAmountWon += _isWinner ? _finalWinAmount : 0;\\n    predictionsAmountUserWon[_user] += _isWinner ? _finalWinAmount : 0;\\n    totalPredictionsAmountLost += !_isWinner && !_isDraw ? _amountWagered : 0;\\n    predictionsAmountUserLost[_user] += !_isWinner && !_isDraw\\n      ? _amountWagered\\n      : 0;\\n  }\\n\\n  function _getProxyRoundId(uint16 _phaseId, uint80 _aggRoundId)\\n    internal\\n    pure\\n    returns (uint80)\\n  {\\n    return uint80((uint256(_phaseId) << 64) | _aggRoundId);\\n  }\\n\\n  function getAggregatorPhaseAndRoundId(uint256 _proxyRoundId)\\n    public\\n    pure\\n    returns (uint16, uint64)\\n  {\\n    uint16 phaseId = uint16(_proxyRoundId >> 64);\\n    uint64 aggregatorRoundId = uint64(_proxyRoundId);\\n    return (phaseId, aggregatorRoundId);\\n  }\\n\\n  function getAllPredictionOptions()\\n    external\\n    view\\n    returns (PredictionConfig[] memory)\\n  {\\n    return predictionOptions;\\n  }\\n\\n  function setMinBalancePerc(uint256 _perc) external onlyOwner {\\n    require(_perc <= PERCENT_DENOMENATOR, 'cannot be more than 100%');\\n    minBalancePerc = _perc;\\n  }\\n\\n  function setMinWagerAbsolute(uint256 _amount) external onlyOwner {\\n    minWagerAbsolute = _amount;\\n  }\\n\\n  function setMaxWagerAbsolute(uint256 _amount) external onlyOwner {\\n    maxWagerAbsolute = _amount;\\n  }\\n\\n  function addPredictionOption(uint256 _seconds, uint256 _percentage)\\n    external\\n    onlyOwner\\n  {\\n    require(_seconds > 60, 'must be longer than 60 seconds');\\n    require(_percentage <= PERCENT_DENOMENATOR, 'cannot be more than 100%');\\n    predictionOptions.push(\\n      PredictionConfig({\\n        timePeriodSeconds: _seconds,\\n        payoutPercentage: _percentage\\n      })\\n    );\\n  }\\n\\n  function removePredictionOption(uint256 _index) external onlyOwner {\\n    predictionOptions[_index] = predictionOptions[predictionOptions.length - 1];\\n    predictionOptions.pop();\\n  }\\n\\n  function updatePredictionOption(\\n    uint256 _index,\\n    uint256 _seconds,\\n    uint256 _percentage\\n  ) external onlyOwner {\\n    PredictionConfig storage _pred = predictionOptions[_index];\\n    _pred.timePeriodSeconds = _seconds;\\n    _pred.payoutPercentage = _percentage;\\n  }\\n\\n  function setWagerToken(address _token) external onlyOwner {\\n    smol = _token;\\n    smolContract = ISmoltingInu(_token);\\n  }\\n\\n  function setRoundIdStartOffset(uint80 _offset) external onlyOwner {\\n    require(_offset > 0, 'must be at least an offset of 1 round');\\n    roundIdStartOffset = _offset;\\n  }\\n\\n  function addPriceFeed(address _proxy) external onlyOwner {\\n    for (uint256 i = 0; i < validPriceFeedProxies.length; i++) {\\n      if (validPriceFeedProxies[i] == _proxy) {\\n        require(false, 'price feed already in feed list');\\n      }\\n    }\\n    isValidPriceFeedProxy[_proxy] = true;\\n    validPriceFeedProxies.push(_proxy);\\n  }\\n\\n  function removePriceFeed(address _proxy) external onlyOwner {\\n    for (uint256 i = 0; i < validPriceFeedProxies.length; i++) {\\n      if (validPriceFeedProxies[i] == _proxy) {\\n        delete isValidPriceFeedProxy[_proxy];\\n        validPriceFeedProxies[i] = validPriceFeedProxies[\\n          validPriceFeedProxies.length - 1\\n        ];\\n        validPriceFeedProxies.pop();\\n        break;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/AggregatorProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol';\\n\\n/**\\n * @dev Interface for chainlink feed proxy, that contains info\\n * about all aggregators for data feed\\n */\\n\\ninterface AggregatorProxy is AggregatorV2V3Interface {\\n  function aggregator() external view returns (address);\\n\\n  function phaseId() external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISmoltingInu.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\\n\\n/**\\n * @dev SmoltingInu token interface\\n */\\n\\ninterface ISmoltingInu is IERC20 {\\n  function decimals() external view returns (uint8);\\n\\n  function gameMint(address _user, uint256 _amount) external;\\n\\n  function gameBurn(address _user, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/SmolGame.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.9;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\\n\\ncontract SmolGame is Ownable {\\n  address payable public treasury;\\n  uint256 public serviceFeeWei;\\n\\n  function _payServiceFee() internal {\\n    if (serviceFeeWei > 0) {\\n      require(msg.value >= serviceFeeWei, 'not able to pay service fee');\\n      address payable _treasury = treasury == address(0)\\n        ? payable(owner())\\n        : treasury;\\n      (bool success, ) = _treasury.call{ value: serviceFeeWei }('');\\n      require(success, 'could not pay service fee');\\n    }\\n  }\\n\\n  function setTreasury(address _treasury) external onlyOwner {\\n    treasury = payable(_treasury);\\n  }\\n\\n  function setServiceFeeWei(uint256 _feeWei) external onlyOwner {\\n    serviceFeeWei = _feeWei;\\n  }\\n\\n  function withdrawTokens(address _tokenAddy, uint256 _amount)\\n    external\\n    onlyOwner\\n  {\\n    IERC20 _token = IERC20(_tokenAddy);\\n    _amount = _amount > 0 ? _amount : _token.balanceOf(address(this));\\n    require(_amount > 0, 'make sure there is a balance available to withdraw');\\n    _token.transfer(owner(), _amount);\\n  }\\n\\n  function withdrawETH(uint256 _amountWei) external onlyOwner {\\n    _amountWei = _amountWei == 0 ? address(this).balance : _amountWei;\\n    payable(owner()).call{ value: _amountWei }('');\\n  }\\n\\n  receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"startPhase\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint80\",\"name\":\"startRound\",\"type\":\"uint80\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWager\",\"type\":\"uint256\"}],\"name\":\"Predict\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isWinner\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isDraw\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWon\",\"type\":\"uint256\"}],\"name\":\"Settle\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"addPredictionOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"addPriceFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proxyRoundId\",\"type\":\"uint256\"}],\"name\":\"getAggregatorPhaseAndRoundId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPredictionOptions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timePeriodSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutPercentage\",\"type\":\"uint256\"}],\"internalType\":\"struct PricePrediction.PredictionConfig[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllValidPriceFeeds\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_phaseId\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"_aggRoundId\",\"type\":\"uint80\"},{\"internalType\":\"bool\",\"name\":\"_requireCompletion\",\"type\":\"bool\"}],\"name\":\"getHistoricalPriceFromAggregatorInfo\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getLatestUserPrediction\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"priceFeedProxy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"configTimePeriodSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"configPayoutPercentage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountWagered\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"startPhaseId\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"startRoundId\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"endPhaseId\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"endRoundId\",\"type\":\"uint80\"},{\"internalType\":\"bool\",\"name\":\"isDraw\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isWinner\",\"type\":\"bool\"}],\"internalType\":\"struct PricePrediction.Prediction\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getNumberUserPredictions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"_roundId\",\"type\":\"uint80\"}],\"name\":\"getPriceUSDAtRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"getRoundInfoAndPriceUSD\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isValidPriceFeedProxy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWagerAbsolute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBalancePerc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minWagerAbsolute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_configIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_priceFeedProxy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountWager\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isLong\",\"type\":\"bool\"}],\"name\":\"predict\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"predictionOptions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timePeriodSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutPercentage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"predictions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"priceFeedProxy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"configTimePeriodSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"configPayoutPercentage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountWagered\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"startPhaseId\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"startRoundId\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"endPhaseId\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"endRoundId\",\"type\":\"uint80\"},{\"internalType\":\"bool\",\"name\":\"isDraw\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isWinner\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"predictionsAmountUserLost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"predictionsAmountUserWon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"predictionsUserDraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"predictionsUserLost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"predictionsUserWon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removePredictionOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"removePriceFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"roundIdStartOffset\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"serviceFeeWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMaxWagerAbsolute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_perc\",\"type\":\"uint256\"}],\"name\":\"setMinBalancePerc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMinWagerAbsolute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"_offset\",\"type\":\"uint80\"}],\"name\":\"setRoundIdStartOffset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeWei\",\"type\":\"uint256\"}],\"name\":\"setServiceFeeWei\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setWagerToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"_phaseIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint80[]\",\"name\":\"_aggRoundIds\",\"type\":\"uint80[]\"}],\"name\":\"settleMultiplePredictions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_answeredPhaseId\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"_answeredAggRoundId\",\"type\":\"uint80\"}],\"name\":\"settlePrediction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlePredictionShortCircuitLoss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smol\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPredictionsAmountLost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPredictionsAmountWon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPredictionsDraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPredictionsLost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPredictionsMade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPredictionsWon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"updatePredictionOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validPriceFeedProxies\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountWei\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PricePrediction", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}