{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.9;\r\n\r\n\r\n\r\n/**\r\n * @title PixelCons interface\r\n * @dev Interface for the core PixelCons contract\r\n */\r\ninterface IPixelCons {\r\n\tfunction getAdmin() external view returns(address);\r\n\r\n\t//PixelCon Tokens\r\n\tfunction create(address to, uint256 tokenId, bytes8 name) external payable returns(uint64);\r\n\tfunction rename(uint256 tokenId, bytes8 name) external returns(uint64);\r\n\tfunction exists(uint256 tokenId) external view returns(bool);\r\n\tfunction creatorOf(uint256 tokenId) external view returns(address);\r\n\tfunction creatorTotal(address creator) external view returns(uint256);\r\n\tfunction tokenOfCreatorByIndex(address creator, uint256 index) external view returns(uint256);\r\n\tfunction getTokenIndex(uint256 tokenId) external view returns(uint64);\r\n\r\n\t//Collections\r\n\tfunction createCollection(uint64[] memory tokenIndexes, bytes8 name) external returns(uint64);\r\n\tfunction renameCollection(uint64 collectionIndex, bytes8 name) external returns(uint64);\r\n\tfunction clearCollection(uint64 collectionIndex) external returns(uint64);\r\n\tfunction collectionExists(uint64 collectionIndex) external view returns(bool);\r\n\tfunction collectionCleared(uint64 collectionIndex) external view returns(bool);\r\n\tfunction totalCollections() external view returns(uint256);\r\n\tfunction collectionOf(uint256 tokenId) external view returns(uint256);\r\n\tfunction collectionTotal(uint64 collectionIndex) external view returns(uint256);\r\n\tfunction getCollectionName(uint64 collectionIndex) external view returns(bytes8);\r\n\tfunction tokenOfCollectionByIndex(uint64 collectionIndex, uint256 index) external view returns(uint256);\r\n\r\n\t//ERC-721 Implementation\r\n\tfunction balanceOf(address owner) external view returns(uint256);\r\n\tfunction ownerOf(uint256 tokenId) external view returns(address);\r\n\tfunction approve(address to, uint256 tokenId) external;\r\n\tfunction getApproved(uint256 tokenId) external view returns(address);\r\n\tfunction setApprovalForAll(address to, bool approved) external;\r\n\tfunction isApprovedForAll(address owner, address operator) external view returns(bool);\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) external;\r\n\r\n\t//ERC-721 Enumeration Implementation\r\n\tfunction totalSupply() external view returns(uint256);\r\n\tfunction tokenByIndex(uint256 tokenIndex) external view returns(uint256);\r\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) external view returns(uint256);\r\n\r\n\t//ERC-721 Metadata Implementation\r\n\tfunction name() external view returns(string memory);\r\n\tfunction symbol() external view returns(string memory);\r\n\tfunction tokenURI(uint256 tokenId) external view returns(string memory);\r\n}\r\n\r\n\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"New owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ICrossDomainMessenger\r\n */\r\ninterface ICrossDomainMessenger {\r\n    /**********\r\n     * Events *\r\n     **********/\r\n\r\n    event SentMessage(\r\n        address indexed target,\r\n        address sender,\r\n        bytes message,\r\n        uint256 messageNonce,\r\n        uint256 gasLimit\r\n    );\r\n    event RelayedMessage(bytes32 indexed msgHash);\r\n    event FailedRelayedMessage(bytes32 indexed msgHash);\r\n\r\n    /*************\r\n     * Variables *\r\n     *************/\r\n\r\n    function xDomainMessageSender() external view returns (address);\r\n\r\n    /********************\r\n     * Public Functions *\r\n     ********************/\r\n\r\n    /**\r\n     * Sends a cross domain message to the target messenger.\r\n     * @param _target Target contract address.\r\n     * @param _message Message to send to the target.\r\n     * @param _gasLimit Gas limit for the provided message.\r\n     */\r\n    function sendMessage(\r\n        address _target,\r\n        bytes calldata _message,\r\n        uint32 _gasLimit\r\n    ) external;\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title CrossDomainEnabled\r\n * @dev Helper contract for contracts performing cross-domain communications\r\n *\r\n * Compiler used: defined by inheriting contract\r\n */\r\ncontract CrossDomainEnabled {\r\n    /*************\r\n     * Variables *\r\n     *************/\r\n\r\n    // Messenger contract used to send and recieve messages from the other domain.\r\n    address public messenger;\r\n\r\n    /***************\r\n     * Constructor *\r\n     ***************/\r\n\r\n    /**\r\n     * @param _messenger Address of the CrossDomainMessenger on the current layer.\r\n     */\r\n    constructor(address _messenger) {\r\n        messenger = _messenger;\r\n    }\r\n\r\n    /**********************\r\n     * Function Modifiers *\r\n     **********************/\r\n\r\n    /**\r\n     * Enforces that the modified function is only callable by a specific cross-domain account.\r\n     * @param _sourceDomainAccount The only account on the originating domain which is\r\n     *  authenticated to call this function.\r\n     */\r\n    modifier onlyFromCrossDomainAccount(address _sourceDomainAccount) {\r\n        require(\r\n            msg.sender == address(getCrossDomainMessenger()),\r\n            \"OVM_XCHAIN: messenger contract unauthenticated\"\r\n        );\r\n\r\n        require(\r\n            getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,\r\n            \"OVM_XCHAIN: wrong sender of cross-domain message\"\r\n        );\r\n\r\n        _;\r\n    }\r\n\r\n    /**********************\r\n     * Internal Functions *\r\n     **********************/\r\n\r\n    /**\r\n     * Gets the messenger, usually from storage. This function is exposed in case a child contract\r\n     * needs to override.\r\n     * @return The address of the cross-domain messenger contract which should be used.\r\n     */\r\n    function getCrossDomainMessenger() internal virtual returns (ICrossDomainMessenger) {\r\n        return ICrossDomainMessenger(messenger);\r\n    }\r\n\r\n    /**q\r\n     * Sends a message to an account on another domain\r\n     * @param _crossDomainTarget The intended recipient on the destination domain\r\n     * @param _message The data to send to the target (usually calldata to a function with\r\n     *  `onlyFromCrossDomainAccount()`)\r\n     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.\r\n     */\r\n    function sendCrossDomainMessage(\r\n        address _crossDomainTarget,\r\n        uint32 _gasLimit,\r\n        bytes memory _message\r\n    ) internal {\r\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\r\n        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title PixelConInvadersBridge\r\n * @notice The purpose of this contract is to generate, custody and bridge Invader PixelCons. All users are treated equally with the exception \r\n * of an admin user who only controls the ability to reseed generation. No fees are required to interact with this contract beyond base gas fees. \r\n * For more information about PixelConInvaders, please visit (https://invaders.pixelcons.io)\r\n * @dev This contract follows the standard Optimism L2 bridging contracts\r\n * See (https://github.com/ethereum-optimism/optimism)\r\n * @author PixelCons\r\n */\r\ncontract PixelConInvadersBridge is Ownable, CrossDomainEnabled {\r\n\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t///////////////////////////////////////////////////////// Structs/Constants /////////////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t\r\n\t// Constants\r\n\tuint64 constant MAX_TOKENS = 1000;\r\n\tuint64 constant MINT1_PIXELCON_INDEX = 1411;//before Feb 1st, 2022 (620 mintable)\r\n\tuint64 constant MINT2_PIXELCON_INDEX = 791; //before Jan 1st, 2021 (156 mintable)\r\n\tuint64 constant MINT3_PIXELCON_INDEX = 713; //before Jan 1st, 2020 (186 mintable)\r\n\tuint64 constant MINT4_PIXELCON_INDEX = 651; //Genesis (1950 mintable)\r\n\tuint64 constant MINT5_PIXELCON_INDEX = 651; \r\n\tuint64 constant MINT6_PIXELCON_INDEX = 651; //2912 Invaders to mint from\r\n\t\r\n\t\r\n\t\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t///////////////////////////////////////////////////////////// Storage ///////////////////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t\r\n\t// Address of the original PixelCons contract\r\n\taddress internal _pixelconsContract;\r\n\t\r\n\t// Address of the PixelCon Invaders contract (L2)\r\n\taddress internal _pixelconInvadersContract;\r\n\r\n\t// The base seed used for invader generation\r\n\tuint256 internal _generationSeed;\r\n\r\n\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t///////////////////////////////////////////////////////////// Events ////////////////////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t// Invader token events\r\n\tevent Mint(uint256 indexed invaderId, uint256 generationSeed, uint256 generationId, uint256 generationIndex, address minter);\r\n\tevent Bridge(uint256 indexed invaderId, address to);\r\n\tevent Unbridge(uint256 indexed invaderId, address to);\r\n\r\n\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////// PixelConInvadersBridge //////////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\t/**\r\n\t * @dev Contract constructor\r\n\t */\r\n\tconstructor(address pixelconsContract, address l1CrossDomainMessenger) CrossDomainEnabled(l1CrossDomainMessenger) Ownable() {\r\n\t\t//require(pixelconsContract != address(0), \"Invalid address\"); //unlikely\r\n\t\t//require(l1CrossDomainMessenger != address(0), \"Invalid address\"); //unlikely\r\n\t\t_pixelconsContract = pixelconsContract;\r\n\t\t_pixelconInvadersContract = address(0);\r\n\t\t_generationSeed = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.difficulty)));\r\n\t}\r\n\r\n\t/**\r\n     * @dev Sets the Invader contract address on L2\r\n\t * @param pixelconInvadersContract -Invader contract address\r\n\t */\r\n\tfunction linkInvadersContract(address pixelconInvadersContract) public onlyOwner {\r\n\t\t//require(pixelconInvadersContract != address(0), \"Invalid address\"); //unlikely\r\n\t\trequire(_pixelconInvadersContract == address(0), \"Already set\");\r\n\t\t_pixelconInvadersContract = pixelconInvadersContract;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Updates the generation seed\r\n\t */\r\n\tfunction cycleGenerationSeed() public onlyOwner {\r\n\t\t_generationSeed = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.difficulty)));\r\n\t}\r\n\t\r\n\t////////////////// PixelCon Invader Tokens //////////////////\r\n\t\r\n\t/**\r\n\t * @dev Mint an Invader\r\n\t * @param pixelconId -ID of the PixelCon to generate from\r\n\t * @param generationIndex -Index number to generate from\r\n\t * @param gasLimit -Amount of gas for messenger (advise to keep <=1900000)\r\n\t * @return ID of the new invader\r\n\t */\r\n\tfunction mintInvader(uint256 pixelconId, uint32 generationIndex, uint32 gasLimit) public returns (uint256) {\r\n\t\t//require(pixelconId != uint256(0), \"Invalid ID\"); //duplicate require in 'ownerOf' function\r\n\t\trequire(generationIndex < 6, \"Invalid index\");\r\n\t\taddress minter = _msgSender();\r\n\t\t\r\n\t\t//check that minter owns the pixelcon\r\n\t\taddress pixelconOwner = IPixelCons(_pixelconsContract).ownerOf(pixelconId);\r\n\t\trequire(pixelconOwner == minter, \"Not PixelCon owner\");\r\n\t\t\r\n\t\t//check that invaders can still be minted\r\n\t\tuint256 numInvadersCreated = IPixelCons(_pixelconsContract).creatorTotal(address(this));\r\n\t\trequire(numInvadersCreated < MAX_TOKENS, \"Max Invaders have been minted\");\r\n\t\t\r\n\t\t//check that the given generation index is valid for the pixelcon\r\n\t\tuint64 pixelconIndex = IPixelCons(_pixelconsContract).getTokenIndex(pixelconId);\r\n\t\tif(generationIndex == 5) require(pixelconIndex <= MINT6_PIXELCON_INDEX, \"Index out of bounds\");\r\n\t\tif(generationIndex == 4) require(pixelconIndex <= MINT5_PIXELCON_INDEX, \"Index out of bounds\");\r\n\t\tif(generationIndex == 3) require(pixelconIndex <= MINT4_PIXELCON_INDEX, \"Index out of bounds\");\r\n\t\tif(generationIndex == 2) require(pixelconIndex <= MINT3_PIXELCON_INDEX, \"Index out of bounds\");\r\n\t\tif(generationIndex == 1) require(pixelconIndex <= MINT2_PIXELCON_INDEX, \"Index out of bounds\");\r\n\t\tif(generationIndex == 0) require(pixelconIndex <= MINT1_PIXELCON_INDEX, \"Index out of bounds\");\r\n\t\t\r\n\t\t//generate the invader\r\n\t\tuint256 invaderId = _generate(pixelconId, generationIndex);\r\n\t\t\r\n\t\t//create the pixelcon\r\n\t\tIPixelCons(_pixelconsContract).create(address(this), invaderId, bytes8(0));\r\n\r\n\t\t//bridge pixelcon to the invader contract on L2\r\n\t\t_bridgeToL2(invaderId, minter, gasLimit);\r\n\r\n\t\t//emit events\r\n\t\temit Mint(invaderId, _generationSeed, pixelconId, generationIndex, minter);\r\n\t\treturn invaderId;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Bridge an Invader to L2\r\n\t * @param tokenId -ID of the Invader to bridge\r\n\t * @param from -Address of current Invader PixelCon owner\r\n\t * @param to -Address of desired Invader owner\r\n\t * @param gasLimit -Amount of gas for messenger (advise to keep <=1900000)\r\n\t */\r\n\tfunction bridgeToL2(uint256 tokenId, address from, address to, uint32 gasLimit) public {\r\n\t\t//require(tokenId != uint256(0), \"Invalid ID\"); //duplicate require in 'ownerOf' function\r\n\t\t//require(from != address(0), \"Invalid address\"); //duplicate require in 'transferFrom' function\r\n\t\trequire(to != address(0), \"Invalid address\");\r\n\t\t\r\n\t\t//check that caller owns the pixelcon\r\n\t\taddress pixelconOwner = IPixelCons(_pixelconsContract).ownerOf(tokenId);\r\n\t\trequire(pixelconOwner == _msgSender(), \"Not owner\");\r\n\t\t\r\n\t\t//check that the pixelcon was created by this contract\r\n\t\taddress pixelconCreator = IPixelCons(_pixelconsContract).creatorOf(tokenId);\r\n\t\trequire(pixelconCreator == address(this), \"Not Invader\");\r\n\t\t\r\n\t\t//transfer pixelcon to this contract\r\n\t\tIPixelCons(_pixelconsContract).transferFrom(from, address(this), tokenId);\r\n\t\r\n\t\t//bridge pixelcon to the invader contract on L2\r\n\t\t_bridgeToL2(tokenId, to, gasLimit);\r\n\t}\r\n\t\r\n    /**\r\n     * @dev Unbridge the Invader PixelCon from L2 (callable only by the L1 messenger)\r\n\t * @param tokenId -ID of token\r\n\t * @param to -New owner address\r\n\t */\r\n\tfunction unbridgeFromL2(uint256 tokenId, address to) external onlyFromCrossDomainAccount(_pixelconInvadersContract) {\r\n\t\t//require(tokenId != uint256(0), \"Invalid ID\"); //duplicate require in 'transferFrom' function\r\n\t\t//require(to != address(0), \"Invalid address\"); //duplicate require in 'transferFrom' function\r\n\t\t\r\n\t\t//transfer\r\n\t\tIPixelCons(_pixelconsContract).transferFrom(address(this), to, tokenId);\r\n\t\temit Unbridge(tokenId, to);\r\n\t}\r\n\t\r\n    /**\r\n     * @dev Returns the current seed used in generation\r\n\t * @return Current generation seed\r\n     */\r\n    function getGenerationSeed() public view returns (uint256) {\r\n        return _generationSeed;\r\n    }\r\n\t\r\n    /**\r\n     * @dev Returns linked Pixelcons contract\r\n\t * @return Pixelcons contract\r\n     */\r\n    function getPixelconsContract() public view returns (address) {\r\n        return _pixelconsContract;\r\n    }\r\n\t\r\n    /**\r\n     * @dev Returns linked PixelconInvaders contract\r\n\t * @return PixelconInvaders contract\r\n     */\r\n    function getPixelconInvadersContract() public view returns (address) {\r\n        return _pixelconInvadersContract;\r\n    }\r\n\t\r\n\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t////////////////////////////////////////////////////////////// Utils ////////////////////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t\r\n\t/**\r\n     * @dev Bridges the Invader to L2\r\n\t * @param tokenId -ID of the Invader\r\n\t * @param to -The address to receive the Invader\r\n\t * @param gasLimit -Amount of gas for messenger\r\n\t */\r\n\tfunction _bridgeToL2(uint256 tokenId, address to, uint32 gasLimit) private {\r\n\t\t//construct calldata for L2 bridge function\r\n\t\tbytes memory message = abi.encodeWithSignature(\"bridgeFromL1(uint256,address)\", tokenId, to);\r\n\r\n\t\t//send message to L2\r\n\t\tsendCrossDomainMessage(_pixelconInvadersContract, gasLimit, message);\r\n\t\temit Bridge(tokenId, to);\r\n\t}\r\n\t\r\n\t\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////// Invader Generation //////////////////////////////////////////////////////////////////\r\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t\r\n\t/**\r\n\t * @dev Generates an Invader from a PixelCon ID and generation index\r\n\t * @param pixelconId -The PixelCon ID to use in generation\r\n\t * @param generationIndex -The index to use in generation\r\n\t * @return Invader ID\r\n\t */\r\n\tfunction _generate(uint256 pixelconId, uint32 generationIndex) private view returns (uint256) {\r\n\t\tuint256 seed = uint256(keccak256(abi.encodePacked(_generationSeed, pixelconId, generationIndex)));\r\n\t\t/*                      [mask 3         ] [mask 2] [mask 1] [colors] [flags]\r\n\t\tseed: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 */\r\n\r\n\t\t//flags\r\n\t\tuint8 horizontalExpand1 = uint8(seed & 0x00000001);\r\n\t\tuint8 verticalExpand1 = uint8(seed & 0x00000002);\r\n\t\tuint8 horizontalExpand2 = uint8(seed & 0x00000004);\r\n\t\tuint8 verticalExpand2 = uint8(seed & 0x00000008);\r\n\t\tseed = seed >> 32;\r\n\r\n\t\t//colors\r\n\t\t(uint256 color1, uint256 color2, uint256 color3) = _getColors(seed);\r\n\t\tseed = seed >> 32;\r\n\r\n\t\t//masks\r\n\t\tuint256 mask1 = _generateMask_5x5(seed, verticalExpand1, horizontalExpand1);\r\n\t\tseed = seed >> 32;\r\n\t\tuint256 mask2 = _generateMask_5x5(seed, verticalExpand2, horizontalExpand2);\r\n\t\tseed = seed >> 32;\r\n\t\tuint256 mask3 = _generateMask_8x8(seed);\r\n\t\tseed = seed >> 64;\r\n\t\tuint256 combinedMask = mask1 & mask2;\r\n\t\tuint256 highlightMask = mask1 & mask3;\r\n\r\n\t\tuint256 invaderId = ((mask1 & ~combinedMask & ~highlightMask) & color1) | ((combinedMask & ~highlightMask) & color2) | (highlightMask & color3);\r\n\t\treturn invaderId;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Generates an 8x8 mask\r\n\t * @param seed -Randomness for generation\r\n\t * @return 256bit mask\r\n\t */\r\n\tfunction _generateMask_8x8(uint256 seed) private pure returns (uint256){\r\n\t\tuint256 mask = _generateLine_8x8(seed);\r\n\t\tmask = (mask << 32) + _generateLine_8x8(seed >> 8);\r\n\t\tmask = (mask << 32) + _generateLine_8x8(seed >> 16);\r\n\t\tmask = (mask << 32) + _generateLine_8x8(seed >> 24);\r\n\t\tmask = (mask << 32) + _generateLine_8x8(seed >> 32);\r\n\t\tmask = (mask << 32) + _generateLine_8x8(seed >> 40);\r\n\t\tmask = (mask << 32) + _generateLine_8x8(seed >> 48);\r\n\t\tmask = (mask << 32) + _generateLine_8x8(seed >> 56);\r\n\t\treturn mask;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Generates a single line for 8x8 mask\r\n\t * @param seed -Randomness for generation\r\n\t * @return 256bit mask line\r\n\t */\r\n\tfunction _generateLine_8x8(uint256 seed) private pure returns (uint256){\r\n\t\tuint256 line = 0x00000000;\r\n\t\tif((seed & 0x00000003) == 0x00000001) line |= 0x000ff000;\r\n\t\tif((seed & 0x0000000c) == 0x00000004) line |= 0x00f00f00;\r\n\t\tif((seed & 0x00000030) == 0x00000010) line |= 0x0f0000f0;\r\n\t\tif((seed & 0x000000c0) == 0x00000040) line |= 0xf000000f;\r\n\t\treturn line;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Generates an 5x5 mask\r\n\t * @param seed -Randomness for generation\r\n\t * @param verticalExpand -Flag for vertical expand mode\r\n\t * @param horizontalExpand -Flag for horizontal expand mode\r\n\t * @return 256bit mask\r\n\t */\r\n\tfunction _generateMask_5x5(uint256 seed, uint8 verticalExpand, uint8 horizontalExpand) private pure returns (uint256){\r\n\t\tuint256 mask = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\t\tuint256 line1 = _generateLine_5x5(seed, horizontalExpand);\r\n\t\tuint256 line2 = _generateLine_5x5(seed >> 3, horizontalExpand);\r\n\t\tuint256 line3 = _generateLine_5x5(seed >> 6, horizontalExpand);\r\n\t\tuint256 line4 = _generateLine_5x5(seed >> 9, horizontalExpand);\r\n\t\tuint256 line5 = _generateLine_5x5(seed >> 12, horizontalExpand);\r\n\t\tif(verticalExpand > 0) {\r\n\t\t\tmask = (line1 << 224) + (line2 << 192) + (line2 << 160) + (line3 << 128) + (line4 << 96) + (line4 << 64) + (line5 << 32) + (line5);\r\n\t\t} else {\r\n\t\t\tmask = (line1 << 224) + (line1 << 192) + (line2 << 160) + (line2 << 128) + (line3 << 96) + (line4 << 64) + (line4 << 32) + (line5);\r\n\t\t}\r\n\t\treturn mask;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Generates a single line for 5x5 mask\r\n\t * @param seed -Randomness for generation\r\n\t * @param horizontalExpand -Flag for horizontal expand mode\r\n\t * @return 256bit mask line\r\n\t */\r\n\tfunction _generateLine_5x5(uint256 seed, uint8 horizontalExpand) private pure returns (uint256){\r\n\t\tuint256 line = 0x00000000;\r\n\t\tif((seed & 0x00000001) == 0x00000001) line |= 0x000ff000;\r\n\t\tif(horizontalExpand > 0) {\r\n\t\t\tif((seed & 0x00000002) == 0x00000002) line |= 0x0ff00ff0;\r\n\t\t\tif((seed & 0x00000004) == 0x00000004) line |= 0xf000000f;\r\n\t\t} else {\r\n\t\t\tif((seed & 0x00000002) == 0x00000002) line |= 0x00f00f00;\r\n\t\t\tif((seed & 0x00000004) == 0x00000004) line |= 0xff0000ff;\r\n\t\t}\r\n\t\treturn line;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Gets colors for generation\r\n\t * @param seed -Randomness for generation\r\n\t * @return 256bit color templates\r\n\t */\r\n\tfunction _getColors(uint256 seed) private pure returns (uint256, uint256, uint256){\r\n\t\tuint256 color1 = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\t\tuint256 color2 = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\t\tuint256 color3 = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n\r\n\t\tuint256 colorNum = seed & 0x000000ff;\r\n\t\tif(colorNum < 0x00000080) {\r\n\t\t\tif(colorNum < 0x00000055) {\r\n\t\t\t\tif(colorNum < 0x0000002B) color3 = 0x7777777777777777777777777777777777777777777777777777777777777777;\r\n\t\t\t\telse color3 = 0x8888888888888888888888888888888888888888888888888888888888888888;\r\n\t\t\t} else {\r\n\t\t\t\tcolor3 = 0x9999999999999999999999999999999999999999999999999999999999999999;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif(colorNum < 0x000000D5) {\r\n\t\t\t\tif(colorNum < 0x000000AB) color3 = 0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\r\n\t\t\t\telse color3 = 0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\r\n\t\t\t} else {\r\n\t\t\t\tcolor3 = 0xcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif((seed & 0x00000100) == 0x00000100) color1 = 0x1111111111111111111111111111111111111111111111111111111111111111;\r\n\t\telse color1 = 0x5555555555555555555555555555555555555555555555555555555555555555;\r\n\r\n\t\tif((seed & 0x00000200) == 0x00000200) color2 = 0x6666666666666666666666666666666666666666666666666666666666666666;\r\n\t\telse color2 = 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd;\r\n\r\n\t\treturn (color1, color2, color3);\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pixelconsContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l1CrossDomainMessenger\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"invaderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Bridge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"invaderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"generationSeed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"generationId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"generationIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"invaderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Unbridge\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"}],\"name\":\"bridgeToL2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cycleGenerationSeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGenerationSeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPixelconInvadersContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPixelconsContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pixelconInvadersContract\",\"type\":\"address\"}],\"name\":\"linkInvadersContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messenger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pixelconId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"generationIndex\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"}],\"name\":\"mintInvader\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"unbridgeFromL2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PixelConInvadersBridge", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005536b6aadd29eaf0db112bb28046a5fad3761bd400000000000000000000000025ace71c97b33cc4729cf772ae268934f7ab5fa1", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://46a7d7716b881d26e6749012460cbef9ed93ce07e39ccfaf38b137e83e96d336"}]}