{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/SatoshiblesStacksBridgeLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n *      ____        _            _     _ _     _\\n *     / ___|  __ _| |_ ___  ___| |__ (_) |__ | | ___  ___\\n *     \\\\___ \\\\ / _` | __/ _ \\\\/ __| '_ \\\\| | '_ \\\\| |/ _ \\\\/ __|\\n *      ___) | (_| | || (_) \\\\__ \\\\ | | | | |_) | |  __/\\\\__ \\\\\\n *     |____/ \\\\__,_|\\\\__\\\\___/|___/_| |_|_|_.__/|_|\\\\___||___/\\n *      ____  _             _        ____       _     _\\n *     / ___|| |_ __ _  ___| | _____| __ ) _ __(_) __| | __ _  ___\\n *     \\\\___ \\\\| __/ _` |/ __| |/ / __|  _ \\\\| '__| |/ _` |/ _` |/ _ \\\\\\n *      ___) | || (_| | (__|   <\\\\__ \\\\ |_) | |  | | (_| | (_| |  __/\\n *     |____/ \\\\__\\\\__,_|\\\\___|_|\\\\_\\\\___/____/|_|  |_|\\\\__,_|\\\\__, |\\\\___|\\n *                                                      |___/\\n */\\n\\nimport \\\"./ERC721Receiver.sol\\\";\\nimport \\\"./Interfaces.sol\\\";\\nimport \\\"./MerkleProof.sol\\\";\\nimport \\\"./OwnableSafe.sol\\\";\\n\\n/**\\n * @title Satoshibles Stacks Bridge Lock\\n * @notice NFT locker for the ethereum side of the Satoshibles Stacks Bridge\\n * @author Aaron Hanson <coffee.becomes.code@gmail.com>\\n * The StacksBridge can be used at https://stacksbridge.com/\\n */\\ncontract SatoshiblesStacksBridgeLock is OwnableSafe, ERC721Receiver {\\n\\n    /// Maximum number of tokens that can be locked/released in one tx\\n    uint256 public constant MAX_BATCH_SIZE = 50;\\n\\n    /// Satoshibles contract instance\\n    IERC721 public immutable SATOSHIBLE_CONTRACT;\\n\\n    /// Bridge worker address\\n    address public worker;\\n\\n    /// Whether the bridge is open overall\\n    bool public bridgeIsOpen;\\n\\n    /// Whether the bridge is open to the public\\n    bool public bridgeIsOpenToPublic;\\n\\n    /// Gas escrow fee paid per locked token, to cover gas when releasing\\n    uint256 public gasEscrowFee;\\n\\n    /// Merkle root summarizing all accounts with early access\\n    bytes32 public earlyAccessMerkleRoot;\\n\\n    /// Tracks number of early access tickets used per address\\n    mapping(address => uint256) public earlyAccessTicketsUsed;\\n\\n    /**\\n     * @notice Emitted when the bridgeIsOpen flag changes\\n     * @param isOpen Whether the bridge is now open overall\\n     */\\n    event BridgeStateChanged(\\n        bool indexed isOpen\\n    );\\n\\n    /**\\n     * @notice Emitted when the bridgeIsOpenToPublic flag changes\\n     * @param isOpenToPublic Whether the bridge is now open to the public\\n     */\\n    event BridgePublicStateChanged(\\n        bool indexed isOpenToPublic\\n    );\\n\\n    /**\\n     * @notice Emitted when a Satoshible is locked (bridging to Stacks)\\n     * @param tokenId The satoshible token ID\\n     * @param ethereumSender The sender's eth address\\n     * @param stacksReceiver The receiver's stacks address\\n     */\\n    event Locked(\\n        uint256 indexed tokenId,\\n        address indexed ethereumSender,\\n        string stacksReceiver\\n    );\\n\\n    /**\\n     * @notice Requires the bridge to be open\\n     */\\n    modifier onlyWhenBridgeIsOpen()\\n    {\\n        require(\\n            bridgeIsOpen == true,\\n            \\\"Bridge is not open\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Requires the bridge to be open to the public\\n     */\\n    modifier onlyWhenBridgeIsOpenToPublic()\\n    {\\n        require(\\n            bridgeIsOpen == true && bridgeIsOpenToPublic == true,\\n            \\\"Bridge is not open to public\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Requires msg.sender to be the bridge worker address\\n     */\\n    modifier onlyWorker()\\n    {\\n        require(\\n             _msgSender() == worker,\\n            \\\"Caller is not the worker\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @param _immutableSatoshible The Satoshible contract address\\n     * @param _worker The bridge worker address\\n     * @param _earlyAccessMerkleRoot The initial early access merkle root\\n     */\\n    constructor(\\n        address _immutableSatoshible,\\n        address _worker,\\n        bytes32 _earlyAccessMerkleRoot\\n    ) {\\n        SATOSHIBLE_CONTRACT = IERC721(\\n            _immutableSatoshible\\n        );\\n\\n        worker = _worker;\\n        earlyAccessMerkleRoot = _earlyAccessMerkleRoot;\\n        bridgeIsOpen = true;\\n    }\\n\\n    /**\\n     * @notice Locks one or more satoshibles to bridge to Stacks\\n     * @param _tokenIds The satoshible token IDs\\n     * @param _stacksReceiver The stacks address to receive the satoshibles\\n     */\\n    function lock(\\n        uint256[] calldata _tokenIds,\\n        string calldata _stacksReceiver\\n    )\\n        external\\n        payable\\n        onlyWhenBridgeIsOpenToPublic\\n    {\\n        _lock(\\n            _tokenIds,\\n            _stacksReceiver\\n        );\\n    }\\n\\n    /**\\n     * @notice Locks one or more satoshibles to bridge to Stacks (early access)\\n     * @param _tokenIds The satoshible token IDs\\n     * @param _stacksReceiver The stacks address to receive the satoshibles\\n     * @param _earlyAccessTickets The total early access tickets for _account\\n     * @param _proof The merkle proof to be verified\\n     */\\n    function lockEarlyAccess(\\n        uint256[] calldata _tokenIds,\\n        string calldata _stacksReceiver,\\n        uint256 _earlyAccessTickets,\\n        bytes32[] calldata _proof\\n    )\\n        external\\n        payable\\n        onlyWhenBridgeIsOpen\\n    {\\n        require(\\n            verifyEarlyAccessTickets(\\n                _msgSender(),\\n                _earlyAccessTickets,\\n                _proof\\n            ) == true,\\n            \\\"Invalid early access proof\\\"\\n        );\\n\\n        unchecked {\\n            require(\\n                earlyAccessTicketsUsed[_msgSender()] + _tokenIds.length\\n                    <= _earlyAccessTickets,\\n                \\\"Not enough tickets remaining\\\"\\n            );\\n\\n            earlyAccessTicketsUsed[_msgSender()] += _tokenIds.length;\\n        }\\n\\n        _lock(\\n            _tokenIds,\\n            _stacksReceiver\\n        );\\n    }\\n\\n    /**\\n     * @notice Releases one or more satoshibles after bridging from Stacks\\n     * @param _tokenIds The satoshible token IDs\\n     * @param _receiver The eth address to receive the satoshibles\\n     */\\n    function release(\\n        uint256[] calldata _tokenIds,\\n        address _receiver\\n    )\\n        external\\n        onlyWorker\\n        onlyWhenBridgeIsOpen\\n    {\\n        require(\\n            _tokenIds.length > 0,\\n            \\\"No token IDs specified\\\"\\n        );\\n\\n        require(\\n            _tokenIds.length <= MAX_BATCH_SIZE,\\n            \\\"Too many token IDs (max 50)\\\"\\n        );\\n\\n        unchecked {\\n            for (uint256 i = 0; i < _tokenIds.length; i++) {\\n                SATOSHIBLE_CONTRACT.safeTransferFrom(\\n                    address(this),\\n                    _receiver,\\n                    _tokenIds[i]\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Opens or closes the bridge overall\\n     * @param _isOpen Whether to open or close the bridge overall\\n     */\\n    function setBridgeIsOpen(\\n        bool _isOpen\\n    )\\n        external\\n        onlyOwner\\n    {\\n        bridgeIsOpen = _isOpen;\\n\\n        emit BridgeStateChanged(\\n            _isOpen\\n        );\\n    }\\n\\n    /**\\n     * @notice Opens or closes the bridge to the public\\n     * @param _isOpenToPublic Whether to open or close the bridge to the public\\n     */\\n    function setBridgeIsOpenToPublic(\\n        bool _isOpenToPublic\\n    )\\n        external\\n        onlyOwner\\n    {\\n        bridgeIsOpenToPublic = _isOpenToPublic;\\n\\n        emit BridgePublicStateChanged(\\n            _isOpenToPublic\\n        );\\n    }\\n\\n    /**\\n     * @notice Sets a new earlyAccessMerkleRoot\\n     * @param _newMerkleRoot The new merkle root\\n     */\\n    function setEarlyAccessMerkleRoot(\\n        bytes32 _newMerkleRoot\\n    )\\n        external\\n        onlyOwner\\n    {\\n        earlyAccessMerkleRoot = _newMerkleRoot;\\n    }\\n\\n    /**\\n     * @notice Sets a new worker address\\n     * @param _newWorker The new worker address\\n     */\\n    function setWorker(\\n        address _newWorker\\n    )\\n        external\\n        onlyOwner\\n    {\\n        worker = _newWorker;\\n    }\\n\\n    /**\\n     * @notice Sets a new gas escrow fee\\n     * @param _newGasEscrowFee The new gas escrow fee amount (in wei)\\n     */\\n    function setGasEscrowFee(\\n        uint256 _newGasEscrowFee\\n    )\\n        external\\n        onlyOwner\\n    {\\n        gasEscrowFee = _newGasEscrowFee;\\n    }\\n\\n    /**\\n     * @notice Transfers gas escrow ether to worker address\\n     * @param _amount The amount to transfer (in wei)\\n     */\\n    function transferGasEscrowToWorker(\\n        uint256 _amount\\n    )\\n        external\\n        onlyOwner\\n    {\\n        payable(worker).transfer(\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @notice Withdraws any ERC20 tokens in case of accidental transfers\\n     * @dev WARNING: Double check token transfer function\\n     * @param _token The contract address of token\\n     * @param _to The address to which to withdraw\\n     * @param _amount The amount to withdraw\\n     * @param _hasVerifiedToken Must be true (sanity check)\\n     */\\n    function withdrawERC20(\\n        address _token,\\n        address _to,\\n        uint256 _amount,\\n        bool _hasVerifiedToken\\n    )\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            _hasVerifiedToken == true,\\n            \\\"Need to verify token\\\"\\n        );\\n\\n        IERC20(_token).transfer(\\n            _to,\\n            _amount\\n        );\\n    }\\n\\n    /**\\n     * @notice Withdraws any ERC721 tokens in case of accidental transfers\\n     * @dev WARNING: Double check token safeTransferFrom function\\n     * @param _token The contract address of token\\n     * @param _to The address to which to withdraw\\n     * @param _tokenIds The token IDs to withdraw\\n     * @param _hasVerifiedToken Must be true (sanity check)\\n     */\\n    function withdrawERC721(\\n        address _token,\\n        address _to,\\n        uint256[] calldata _tokenIds,\\n        bool _hasVerifiedToken\\n    )\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            _hasVerifiedToken == true,\\n            \\\"Need to verify token\\\"\\n        );\\n\\n        unchecked {\\n            for (uint256 i = 0; i < _tokenIds.length; i++) {\\n                IERC721(_token).safeTransferFrom(\\n                    address(this),\\n                    _to,\\n                    _tokenIds[i]\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Verifies the merkle proof of an account's early access tickets\\n     * @param _account The account to verify\\n     * @param _earlyAccessTickets The total early access tickets for _account\\n     * @param _proof The merkle proof to be verified\\n     * @return isVerified True if the merkle proof is verified\\n     */\\n    function verifyEarlyAccessTickets(\\n        address _account,\\n        uint256 _earlyAccessTickets,\\n        bytes32[] calldata _proof\\n    )\\n        public\\n        view\\n        returns (bool isVerified)\\n    {\\n        bytes32 node = keccak256(\\n            abi.encodePacked(\\n                _account,\\n                _earlyAccessTickets\\n            )\\n        );\\n\\n        isVerified = MerkleProof.verify(\\n            _proof,\\n            earlyAccessMerkleRoot,\\n            node\\n        );\\n    }\\n\\n    /**\\n     * @dev Locks one or more satoshibles to bridge to Stacks\\n     * @param _tokenIds The satoshible token IDs\\n     * @param _stacksReceiver The stacks address to receive the satoshibles\\n     */\\n    function _lock(\\n        uint256[] calldata _tokenIds,\\n        string calldata _stacksReceiver\\n    )\\n        private\\n    {\\n        require(\\n            _tokenIds.length > 0,\\n            \\\"No token IDs specified\\\"\\n        );\\n\\n        require(\\n            _tokenIds.length <= MAX_BATCH_SIZE,\\n            \\\"Too many token IDs (max 50)\\\"\\n        );\\n\\n        unchecked {\\n            require(\\n                msg.value == gasEscrowFee * _tokenIds.length,\\n                \\\"Incorrect gas escrow ether\\\"\\n            );\\n\\n            for (uint256 i = 0; i < _tokenIds.length; i++) {\\n                uint256 tokenId = _tokenIds[i];\\n\\n                SATOSHIBLE_CONTRACT.safeTransferFrom(\\n                    _msgSender(),\\n                    address(this),\\n                    tokenId\\n                );\\n\\n                emit Locked(\\n                    tokenId,\\n                    _msgSender(),\\n                    _stacksReceiver\\n                );\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/OwnableSafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Based on OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n// With renounceOwnership() removed\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"./ContextSimple.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableSafe is ContextSimple {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\nlibrary MerkleProof {\\n    /**\\n     * @dev Verifies a merkle proof for a root and leaf node\\n     * @param _proof The merkle proof to verify\\n     * @param _root The merkle root\\n     * @param _leaf The leaf node\\n     * @return isVerified True if the merkle proof is verified\\n     */\\n    function verify(\\n        bytes32[] memory _proof,\\n        bytes32 _root,\\n        bytes32 _leaf\\n    )\\n        internal\\n        pure\\n        returns (bool isVerified)\\n    {\\n        bytes32 computedHash = _leaf;\\n\\n        unchecked {\\n            for (uint256 i = 0; i < _proof.length; i++) {\\n                bytes32 proofElement = _proof[i];\\n\\n                if (computedHash <= proofElement) {\\n                    computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n                } else {\\n                    computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n                }\\n            }\\n        }\\n\\n        isVerified = computedHash == _root;\\n    }\\n}\"\r\n    },\r\n    \"/contracts/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\ninterface IERC20 {\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\\ninterface IERC721 {\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n}\"\r\n    },\r\n    \"/contracts/ERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n * @notice ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ncontract ERC721Receiver {\\n\\n    /**\\n     * @notice ERC721 token receiver interface\\n     * @dev Interface for any contract that wants to support safeTransfers\\n     * from ERC721 asset contracts.\\n     */\\n    function onERC721Received(\\n        address _operator,\\n        address _from,\\n        uint256 _tokenId,\\n        bytes calldata _data\\n    )\\n        external\\n        pure\\n        returns (bytes4)\\n    {\\n        return 0x150b7a02;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/ContextSimple.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Based on OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n// With _msgData() removed\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n * @dev Provides the msg.sender in the current execution context.\\n */\\nabstract contract ContextSimple {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_immutableSatoshible\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_worker\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_earlyAccessMerkleRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isOpenToPublic\",\"type\":\"bool\"}],\"name\":\"BridgePublicStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"name\":\"BridgeStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ethereumSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"stacksReceiver\",\"type\":\"string\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_BATCH_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SATOSHIBLE_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgeIsOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgeIsOpenToPublic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earlyAccessMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"earlyAccessTicketsUsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasEscrowFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"_stacksReceiver\",\"type\":\"string\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"_stacksReceiver\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_earlyAccessTickets\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"lockEarlyAccess\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isOpen\",\"type\":\"bool\"}],\"name\":\"setBridgeIsOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isOpenToPublic\",\"type\":\"bool\"}],\"name\":\"setBridgeIsOpenToPublic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_newMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setEarlyAccessMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newGasEscrowFee\",\"type\":\"uint256\"}],\"name\":\"setGasEscrowFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWorker\",\"type\":\"address\"}],\"name\":\"setWorker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferGasEscrowToWorker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_earlyAccessTickets\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyEarlyAccessTickets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isVerified\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_hasVerifiedToken\",\"type\":\"bool\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"_hasVerifiedToken\",\"type\":\"bool\"}],\"name\":\"withdrawERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"worker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SatoshiblesStacksBridgeLock", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "0000000000000000000000000b0b186841c55d8a09d53db48dc8cab9dbf4dbd600000000000000000000000000f879b1e26a3b6575061f80f241d28a66e835f2a28d5a6417b932ca5c582b8df875f434c1b206283ed932e7959b47be734da3fe", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}