{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"blackdomains_escrow.sol\":{\"content\":\"pragma solidity \\u003e=0.6.0 \\u003c0.9.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ncontract BlackcomDomainsEscrow {\\r\\n\\taddress private mediator;\\r\\n\\r\\n\\taddress public erc20_contract_address;\\r\\n\\tIERC20 private erc20_contract;\\r\\n\\taddress public fee_address;\\r\\n\\tuint public intervention_lock_until_block_number;\\r\\n\\tbytes32 public release_funds_hash;\\r\\n\\r\\n\\taddress public receiver_address;\\r\\n\\tuint public price;\\r\\n\\tuint public fee;\\r\\n\\r\\n\\tconstructor(address _erc20_contract_address, address _fee_address) {\\r\\n\\t\\terc20_contract_address = _erc20_contract_address;\\r\\n\\t\\terc20_contract = IERC20(_erc20_contract_address);\\r\\n\\t\\tmediator = msg.sender;\\r\\n\\t\\tfee_address = _fee_address;\\r\\n\\t}\\r\\n\\r\\n\\tfunction prepare(address _receiver_address, uint _price, uint _fee, bytes32 _release_funds_hash) public {\\r\\n\\t\\trequire(msg.sender == mediator, \\\"Caller is not authorized.\\\");\\r\\n\\t\\trequire(erc20_contract.balanceOf(address(this)) == 0, \\\"Balance must be 0.\\\");\\r\\n\\r\\n\\t\\treceiver_address = _receiver_address;\\r\\n\\t\\tprice = _price;\\r\\n\\t\\tfee = _fee;\\r\\n\\t\\tintervention_lock_until_block_number = block.number + 40320;\\r\\n\\t\\trelease_funds_hash = _release_funds_hash;\\r\\n\\t}\\r\\n\\r\\n\\tfunction releaseFunds(string memory _release_funds_key) public {\\r\\n\\t\\trequire(keccak256(abi.encodePacked(_release_funds_key)) == release_funds_hash, \\\"Caller is not authorized.\\\");\\r\\n\\r\\n\\t\\tuint balance = erc20_contract.balanceOf(address(this));\\r\\n\\t\\trequire(balance \\u003e= price, \\\"Not enough funds.\\\");\\r\\n\\r\\n\\t\\terc20_contract.transfer(receiver_address, price - fee);\\r\\n\\t\\terc20_contract.transfer(fee_address, balance - (price - fee));\\r\\n\\r\\n\\t\\tintervention_lock_until_block_number = 0;\\r\\n\\t}\\r\\n\\r\\n\\tfunction refundTo(address _to) public {\\r\\n\\t\\trequire(msg.sender == mediator, \\\"Caller is not authorized.\\\");\\r\\n\\t\\trequire(block.number \\u003e= intervention_lock_until_block_number, \\\"Caller is not authorized.\\\");\\r\\n\\r\\n\\t\\terc20_contract.transfer(_to, erc20_contract.balanceOf(address(this)));\\r\\n\\t}\\r\\n\\r\\n\\tfunction changeMediator(address _new_mediator) public {\\r\\n\\t\\trequire(msg.sender == mediator, \\\"Caller is not authorized.\\\");\\r\\n\\r\\n\\t\\tmediator = _new_mediator;\\r\\n\\t}\\r\\n\\r\\n\\tfunction changeFeeAddress(address _new_fee_address) public {\\r\\n\\t\\trequire(msg.sender == mediator, \\\"Caller is not authorized.\\\");\\r\\n\\r\\n\\t\\tfee_address = _new_fee_address;\\r\\n\\t}\\r\\n\\r\\n\\tfunction changeERC20Contract(address _new_erc20_contract_address) public {\\r\\n\\t\\trequire(msg.sender == mediator, \\\"Caller is not authorized.\\\");\\r\\n\\t\\trequire(block.number \\u003e= intervention_lock_until_block_number, \\\"Caller is not authorized.\\\");\\r\\n\\r\\n\\t\\terc20_contract_address = _new_erc20_contract_address;\\r\\n\\t\\terc20_contract = IERC20(_new_erc20_contract_address);\\r\\n\\t}\\r\\n}\"},\"IERC20.sol\":{\"content\":\"\\r\\n// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.3.2 (token/ERC20/IERC20.sol)\\r\\n// Local copy of https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.0.0/contracts/token/ERC20\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc20_contract_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fee_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new_erc20_contract_address\",\"type\":\"address\"}],\"name\":\"changeERC20Contract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new_fee_address\",\"type\":\"address\"}],\"name\":\"changeFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new_mediator\",\"type\":\"address\"}],\"name\":\"changeMediator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20_contract_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"intervention_lock_until_block_number\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_release_funds_hash\",\"type\":\"bytes32\"}],\"name\":\"prepare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiver_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"refundTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_release_funds_key\",\"type\":\"string\"}],\"name\":\"releaseFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"release_funds_hash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BlackcomDomainsEscrow", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000932ef0bb220efc584c49b44df93eef5219a0759e", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bf25058e84b559cfb7d93c68661641e531949ebe8f98d75e0deff99b74d1b947"}]}