{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Unlock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n/**\\n * @title The Unlock contract\\n * @author Julien Genestoux (unlock-protocol.com)\\n * This smart contract has 3 main roles:\\n *  1. Distribute discounts to discount token holders\\n *  2. Grant dicount tokens to users making referrals and/or publishers granting discounts.\\n *  3. Create & deploy Public Lock contracts.\\n * In order to achieve these 3 elements, it keeps track of several things such as\\n *  a. Deployed locks addresses and balances of discount tokens granted by each lock.\\n *  b. The total network product (sum of all key sales, net of discounts)\\n *  c. Total of discounts granted\\n *  d. Balances of discount tokens, including 'frozen' tokens (which have been used to claim\\n * discounts and cannot be used/transferred for a given period)\\n *  e. Growth rate of Network Product\\n *  f. Growth rate of Discount tokens supply\\n * The smart contract has an owner who only can perform the following\\n *  - Upgrades\\n *  - Change in golden rules (20% of GDP available in discounts, and supply growth rate is at most\\n * 50% of GNP growth rate)\\n * NOTE: This smart contract is partially implemented for now until enough Locks are deployed and\\n * in the wild.\\n * The partial implementation includes the following features:\\n *  a. Keeping track of deployed locks\\n *  b. Keeping track of GNP\\n */\\n\\nimport '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\\nimport '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';\\nimport 'hardlydifficult-eth/contracts/protocols/Uniswap/IUniswapOracle.sol';\\nimport './utils/UnlockOwnable.sol';\\nimport './utils/UnlockInitializable.sol';\\nimport './interfaces/IPublicLock.sol';\\nimport './interfaces/IMintableERC20.sol';\\n\\n/// @dev Must list the direct base contracts in the order from \u201cmost base-like\u201d to \u201cmost derived\u201d.\\n/// https://solidity.readthedocs.io/en/latest/contracts.html#multiple-inheritance-and-linearization\\ncontract Unlock is\\n  UnlockInitializable,\\n  UnlockOwnable\\n{\\n\\n  /**\\n   * The struct for a lock\\n   * We use deployed to keep track of deployments.\\n   * This is required because both totalSales and yieldedDiscountTokens are 0 when initialized,\\n   * which would be the same values when the lock is not set.\\n   */\\n  struct LockBalances\\n  {\\n    bool deployed;\\n    uint totalSales; // This is in wei\\n    uint yieldedDiscountTokens;\\n  }\\n\\n  modifier onlyFromDeployedLock() {\\n    require(locks[msg.sender].deployed, 'ONLY_LOCKS');\\n    _;\\n  }\\n\\n  uint public grossNetworkProduct;\\n\\n  uint public totalDiscountGranted;\\n\\n  // We keep track of deployed locks to ensure that callers are all deployed locks.\\n  mapping (address => LockBalances) public locks;\\n\\n  // global base token URI\\n  // Used by locks where the owner has not set a custom base URI.\\n  string public globalBaseTokenURI;\\n\\n  // global base token symbol\\n  // Used by locks where the owner has not set a custom symbol\\n  string public globalTokenSymbol;\\n\\n  // The address of the latest public lock template, used by default when `createLock` is called\\n  address public publicLockAddress;\\n\\n  // Map token address to oracle contract address if the token is supported\\n  // Used for GDP calculations\\n  mapping (address => IUniswapOracle) public uniswapOracles;\\n\\n  // The WETH token address, used for value calculations\\n  address public weth;\\n\\n  // The UDT token address, used to mint tokens on referral\\n  address public udt;\\n\\n  // The approx amount of gas required to purchase a key\\n  uint public estimatedGasForPurchase;\\n\\n  // Blockchain ID the network id on which this version of Unlock is operating\\n  uint public chainId;\\n\\n  // store proxy admin\\n  address public proxyAdminAddress;\\n  ProxyAdmin private proxyAdmin;\\n\\n  // publicLock templates\\n  mapping(address => uint16) private _publicLockVersions;\\n  mapping(uint16 => address) private _publicLockImpls;\\n  uint16 public publicLockLatestVersion;\\n\\n  // Events\\n  event NewLock(\\n    address indexed lockOwner,\\n    address indexed newLockAddress\\n  );\\n\\n  event LockUpgraded(\\n    address lockAddress,\\n    uint16 version\\n  );\\n\\n  event ConfigUnlock(\\n    address udt,\\n    address weth,\\n    uint estimatedGasForPurchase,\\n    string globalTokenSymbol,\\n    string globalTokenURI,\\n    uint chainId\\n  );\\n\\n  event SetLockTemplate(\\n    address publicLockAddress\\n  );\\n\\n  event ResetTrackedValue(\\n    uint grossNetworkProduct,\\n    uint totalDiscountGranted\\n  );\\n\\n  event UnlockTemplateAdded(\\n    address indexed impl,\\n    uint16 indexed version\\n  );\\n\\n  // Use initialize instead of a constructor to support proxies (for upgradeability via OZ).\\n  function initialize(\\n    address _unlockOwner\\n  )\\n    public\\n    initializer()\\n  {\\n    // We must manually initialize Ownable\\n    UnlockOwnable.__initializeOwnable(_unlockOwner);\\n    // add a proxy admin on deployment\\n    _deployProxyAdmin();\\n  }\\n\\n  function initializeProxyAdmin() public onlyOwner {\\n    require(proxyAdminAddress == address(0), \\\"ProxyAdmin already deployed\\\");\\n    _deployProxyAdmin();\\n  }\\n\\n  /**\\n  * @dev Deploy the ProxyAdmin contract that will manage lock templates upgrades\\n  * This deploys an instance of ProxyAdmin used by PublicLock transparent proxies.\\n  */\\n  function _deployProxyAdmin() private returns(address) {\\n    proxyAdmin = new ProxyAdmin();\\n    proxyAdminAddress = address(proxyAdmin);\\n    return address(proxyAdmin);\\n  }\\n\\n  /**\\n  * @dev Helper to get the version number of a template from his address\\n  */\\n  function publicLockVersions(address _impl) external view returns(uint16) {\\n    return _publicLockVersions[_impl];\\n  }\\n\\n  /**\\n  * @dev Helper to get the address of a template based on its version number\\n  */\\n  function publicLockImpls(uint16 _version) external view returns(address) {\\n    return _publicLockImpls[_version];\\n  }\\n\\n  /**\\n  * @dev Registers a new PublicLock template immplementation\\n  * The template is identified by a version number\\n  * Once registered, the template can be used to upgrade an existing Lock\\n  */\\n  function addLockTemplate(address impl, uint16 version) public onlyOwner {\\n    _publicLockVersions[impl] = version;\\n    _publicLockImpls[version] = impl;\\n    if (publicLockLatestVersion < version) publicLockLatestVersion = version;\\n\\n    emit UnlockTemplateAdded(impl, version);\\n  }\\n\\n  /**\\n  * @notice Create lock (legacy)\\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\\n  * @param _expirationDuration the duration of the lock (pass 0 for unlimited duration)\\n  * @param _tokenAddress set to the ERC20 token address, or 0 for ETH.\\n  * @param _keyPrice the price of each key\\n  * @param _maxNumberOfKeys the maximum nimbers of keys to be edited\\n  * @param _lockName the name of the lock\\n  * param _salt [deprec] -- kept only for backwards copatibility\\n  * This may be implemented as a sequence ID or with RNG. It's used with `create2`\\n  * to know the lock's address before the transaction is mined.\\n  * @dev internally call `createUpgradeableLock`\\n  */\\n  function createLock(\\n    uint _expirationDuration,\\n    address _tokenAddress,\\n    uint _keyPrice,\\n    uint _maxNumberOfKeys,\\n    string calldata _lockName,\\n    bytes12 // _salt\\n  ) public returns(address) {\\n\\n    bytes memory data = abi.encodeWithSignature(\\n      'initialize(address,uint256,address,uint256,uint256,string)',\\n      msg.sender,\\n      _expirationDuration,\\n      _tokenAddress,\\n      _keyPrice,\\n      _maxNumberOfKeys,\\n      _lockName\\n    );\\n\\n    return createUpgradeableLock(data);\\n  }\\n\\n  /**\\n  * @notice Create upgradeable lock\\n  * This deploys a lock for a creator. It also keeps track of the deployed lock.\\n  * @param data bytes containing the call to initialize the lock template\\n  * @dev this call is passed as encoded function - for instance:\\n  *  bytes memory data = abi.encodeWithSignature(\\n  *    'initialize(address,uint256,address,uint256,uint256,string)',\\n  *    msg.sender,\\n  *    _expirationDuration,\\n  *    _tokenAddress,\\n  *    _keyPrice,\\n  *    _maxNumberOfKeys,\\n  *    _lockName\\n  *  );\\n  * @return address of the create lock\\n  */\\n  function createUpgradeableLock(\\n    bytes memory data\\n  ) public returns(address)\\n  {\\n    require(proxyAdminAddress != address(0), \\\"proxyAdmin is not set\\\");\\n    require(publicLockAddress != address(0), 'MISSING_LOCK_TEMPLATE');\\n\\n    // deploy a proxy pointing to impl\\n    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(publicLockAddress, proxyAdminAddress, data);\\n    address payable newLock = payable(address(proxy));\\n\\n    // assign the new Lock\\n    locks[newLock] = LockBalances({\\n      deployed: true, totalSales: 0, yieldedDiscountTokens: 0\\n    });\\n\\n    // trigger event\\n    emit NewLock(msg.sender, newLock);\\n    return newLock;\\n  }\\n\\n  /**\\n   * @dev Upgrade a Lock template implementation\\n   * @param lockAddress the address of the lock to be upgraded\\n   * @param version the version number of the template\\n   */\\n  function upgradeLock(address payable lockAddress, uint16 version) external returns(address) {\\n    require(proxyAdminAddress != address(0), \\\"proxyAdmin is not set\\\");\\n\\n    // check perms\\n    require(_isLockManager(lockAddress, msg.sender) == true, \\\"caller is not a manager of this lock\\\");\\n\\n    // check version\\n    IPublicLock lock = IPublicLock(lockAddress);\\n    uint16 currentVersion = lock.publicLockVersion();\\n    require( version == currentVersion + 1, 'version error: only +1 increments are allowed');\\n\\n    // make our upgrade\\n    address impl = _publicLockImpls[version];\\n    require(impl != address(0), \\\"this version number has no corresponding lock template\\\");\\n\\n    TransparentUpgradeableProxy proxy = TransparentUpgradeableProxy(lockAddress);\\n    proxyAdmin.upgrade(proxy, impl);\\n\\n    emit LockUpgraded(lockAddress, version);\\n    return lockAddress;\\n  }\\n\\n  function _isLockManager(address lockAddress, address _sender) private view returns(bool isManager) {\\n    IPublicLock lock = IPublicLock(lockAddress);\\n    return lock.isLockManager(_sender);\\n  }\\n\\n  /**\\n   * @notice [DEPRECATED] Call to this function has been removed from PublicLock > v9.\\n   * @dev [DEPRECATED] Kept for backwards compatibility\\n   */\\n  function computeAvailableDiscountFor(\\n    address /* _purchaser */,\\n    uint /* _keyPrice */\\n  )\\n    public\\n    pure\\n    returns (uint discount, uint tokens)\\n  {\\n    return (0, 0);\\n  }\\n\\n  /**\\n   * Helper to get the network mining basefee as introduced in EIP-1559\\n   * @dev this helper can be wrapped in try/catch statement to avoid \\n   * revert in networks where EIP-1559 is not implemented\\n   */\\n  function networkBaseFee() external view returns (uint) {\\n    return block.basefee;\\n  }\\n\\n  /**\\n   * This function keeps track of the added GDP, as well as grants of discount tokens\\n   * to the referrer, if applicable.\\n   * The number of discount tokens granted is based on the value of the referal,\\n   * the current growth rate and the lock's discount token distribution rate\\n   * This function is invoked by a previously deployed lock only.\\n   * TODO: actually implement\\n   */\\n  function recordKeyPurchase(\\n    uint _value,\\n    address _referrer\\n  )\\n    public\\n    onlyFromDeployedLock()\\n  {\\n    if(_value > 0) {\\n      uint valueInETH;\\n      address tokenAddress = IPublicLock(msg.sender).tokenAddress();\\n      if(tokenAddress != address(0) && tokenAddress != weth) {\\n        // If priced in an ERC-20 token, find the supported uniswap oracle\\n        IUniswapOracle oracle = uniswapOracles[tokenAddress];\\n        if(address(oracle) != address(0)) {\\n          valueInETH = oracle.updateAndConsult(tokenAddress, _value, weth);\\n        }\\n      }\\n      else {\\n        // If priced in ETH (or value is 0), no conversion is required\\n        valueInETH = _value;\\n      }\\n\\n      grossNetworkProduct = grossNetworkProduct + valueInETH;\\n      // If GNP does not overflow, the lock totalSales should be safe\\n      locks[msg.sender].totalSales += valueInETH;\\n\\n      // Mint UDT\\n      if(_referrer != address(0))\\n      {\\n        IUniswapOracle udtOracle = uniswapOracles[udt];\\n        if(address(udtOracle) != address(0))\\n        {\\n          // Get the value of 1 UDT (w/ 18 decimals) in ETH\\n          uint udtPrice = udtOracle.updateAndConsult(udt, 10 ** 18, weth);\\n\\n          // base fee default to 100 GWEI for chains that does \\n          uint baseFee;\\n          try this.networkBaseFee() returns (uint _basefee) {\\n            // no assigned value\\n            if(_basefee == 0) {\\n              baseFee = 100;\\n            } else {\\n              baseFee = _basefee;\\n            }\\n          } catch {\\n            // block.basefee not supported\\n            baseFee = 100;\\n          }\\n\\n          // tokensToDistribute is either == to the gas cost times 1.25 to cover the 20% dev cut\\n          uint tokensToDistribute = (estimatedGasForPurchase * baseFee) * (125 * 10 ** 18) / 100 / udtPrice;\\n\\n          // or tokensToDistribute is capped by network GDP growth\\n          uint maxTokens = 0;\\n          if (chainId > 1)\\n          {\\n            // non mainnet: we distribute tokens using asymptotic curve between 0 and 0.5\\n            // maxTokens = IMintableERC20(udt).balanceOf(address(this)).mul((valueInETH / grossNetworkProduct) / (2 + 2 * valueInETH / grossNetworkProduct));\\n            maxTokens = IMintableERC20(udt).balanceOf(address(this)) * valueInETH / (2 + 2 * valueInETH / grossNetworkProduct) / grossNetworkProduct;\\n          } else {\\n            // Mainnet: we mint new token using log curve\\n            maxTokens = IMintableERC20(udt).totalSupply() * valueInETH / 2 / grossNetworkProduct;\\n          }\\n\\n          // cap to GDP growth!\\n          if(tokensToDistribute > maxTokens)\\n          {\\n            tokensToDistribute = maxTokens;\\n          }\\n\\n          if(tokensToDistribute > 0)\\n          {\\n            // 80% goes to the referrer, 20% to the Unlock dev - round in favor of the referrer\\n            uint devReward = tokensToDistribute * 20 / 100;\\n            if (chainId > 1)\\n            {\\n              uint balance = IMintableERC20(udt).balanceOf(address(this));\\n              if (balance > tokensToDistribute) {\\n                // Only distribute if there are enough tokens\\n                IMintableERC20(udt).transfer(_referrer, tokensToDistribute - devReward);\\n                IMintableERC20(udt).transfer(owner(), devReward);\\n              }\\n            } else {\\n              // No distribnution\\n              IMintableERC20(udt).mint(_referrer, tokensToDistribute - devReward);\\n              IMintableERC20(udt).mint(owner(), devReward);\\n            }\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice [DEPRECATED] Call to this function has been removed from PublicLock > v9.\\n   * @dev [DEPRECATED] only Kept for backwards compatibility\\n   */\\n  function recordConsumedDiscount(\\n    uint /* _discount */,\\n    uint /* _tokens */\\n  )\\n    public\\n    view\\n    onlyFromDeployedLock()\\n  {\\n    return;\\n  }\\n\\n  // The version number of the current Unlock implementation on this network\\n  function unlockVersion(\\n  ) external pure\\n    returns (uint16)\\n  {\\n    return 10;\\n  }\\n\\n  /**\\n   * @notice Allows the owner to update configuration variables\\n   */\\n  function configUnlock(\\n    address _udt,\\n    address _weth,\\n    uint _estimatedGasForPurchase,\\n    string calldata _symbol,\\n    string calldata _URI,\\n    uint _chainId\\n  ) external\\n    onlyOwner\\n  {\\n    udt = _udt;\\n    weth = _weth;\\n    estimatedGasForPurchase = _estimatedGasForPurchase;\\n\\n    globalTokenSymbol = _symbol;\\n    globalBaseTokenURI = _URI;\\n\\n    chainId = _chainId;\\n\\n    emit ConfigUnlock(_udt, _weth, _estimatedGasForPurchase, _symbol, _URI, _chainId);\\n  }\\n\\n  /**\\n   * @notice Upgrade the PublicLock template used for future calls to `createLock`.\\n   * @dev This will initialize the template and revokeOwnership.\\n   */\\n  function setLockTemplate(\\n    address _publicLockAddress\\n  ) external\\n    onlyOwner\\n  {\\n    // First claim the template so that no-one else could\\n    // this will revert if the template was already initialized.\\n    IPublicLock(_publicLockAddress).initialize(\\n      address(this), 0, address(0), 0, 0, ''\\n    );\\n    IPublicLock(_publicLockAddress).renounceLockManager();\\n\\n    publicLockAddress = _publicLockAddress;\\n\\n    emit SetLockTemplate(_publicLockAddress);\\n  }\\n\\n  /**\\n   * @notice allows the owner to set the oracle address to use for value conversions\\n   * setting the _oracleAddress to address(0) removes support for the token\\n   * @dev This will also call update to ensure at least one datapoint has been recorded.\\n   */\\n  function setOracle(\\n    address _tokenAddress,\\n    address _oracleAddress\\n  ) external\\n    onlyOwner\\n  {\\n    uniswapOracles[_tokenAddress] = IUniswapOracle(_oracleAddress);\\n    if(_oracleAddress != address(0)) {\\n      IUniswapOracle(_oracleAddress).update(_tokenAddress, weth);\\n    }\\n  }\\n\\n  // Allows the owner to change the value tracking variables as needed.\\n  function resetTrackedValue(\\n    uint _grossNetworkProduct,\\n    uint _totalDiscountGranted\\n  ) external\\n    onlyOwner\\n  {\\n    grossNetworkProduct = _grossNetworkProduct;\\n    totalDiscountGranted = _totalDiscountGranted;\\n\\n    emit ResetTrackedValue(_grossNetworkProduct, _totalDiscountGranted);\\n  }\\n\\n  /**\\n   * @dev Redundant with globalBaseTokenURI() for backwards compatibility with v3 & v4 locks.\\n   */\\n  function getGlobalBaseTokenURI()\\n    external\\n    view\\n    returns (string memory)\\n  {\\n    return globalBaseTokenURI;\\n  }\\n\\n  /**\\n   * @dev Redundant with globalTokenSymbol() for backwards compatibility with v3 & v4 locks.\\n   */\\n  function getGlobalTokenSymbol()\\n    external\\n    view\\n    returns (string memory)\\n  {\\n    return globalTokenSymbol;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1967/ERC1967Proxy.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n *\\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n *\\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n *\\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n *\\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\\n */\\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\\n    /**\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\\n     */\\n    constructor(\\n        address _logic,\\n        address admin_,\\n        bytes memory _data\\n    ) payable ERC1967Proxy(_logic, _data) {\\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _changeAdmin(admin_);\\n    }\\n\\n    /**\\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _getAdmin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function admin() external ifAdmin returns (address admin_) {\\n        admin_ = _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function implementation() external ifAdmin returns (address implementation_) {\\n        implementation_ = _implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\\n     */\\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\\n        _changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\\n     */\\n    function upgradeTo(address newImplementation) external ifAdmin {\\n        _upgradeToAndCall(newImplementation, bytes(\\\"\\\"), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n     * proxied contract.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\\n        _upgradeToAndCall(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _admin() internal view virtual returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\\n     */\\n    function _beforeFallback() internal virtual override {\\n        require(msg.sender != _getAdmin(), \\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\n        super._beforeFallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./TransparentUpgradeableProxy.sol\\\";\\nimport \\\"../../access/Ownable.sol\\\";\\n\\n/**\\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\\n */\\ncontract ProxyAdmin is Ownable {\\n    /**\\n     * @dev Returns the current implementation of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"implementation()\\\")) == 0x5c60da1b\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\\\"5c60da1b\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Returns the current admin of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"admin()\\\")) == 0xf851a440\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\\\"f851a440\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Changes the admin of `proxy` to `newAdmin`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the current admin of `proxy`.\\n     */\\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\\n        proxy.changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\\n        proxy.upgradeTo(implementation);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgradeAndCall(\\n        TransparentUpgradeableProxy proxy,\\n        address implementation,\\n        bytes memory data\\n    ) public payable virtual onlyOwner {\\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"hardlydifficult-eth/contracts/protocols/Uniswap/IUniswapOracle.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapOracle\\n{\\n    function PERIOD() external returns (uint);\\n    function factory() external returns (address);\\n    function update(\\n      address _tokenIn,\\n      address _tokenOut\\n    ) external;\\n    function consult(\\n      address _tokenIn,\\n      uint _amountIn,\\n      address _tokenOut\\n    ) external view\\n      returns (uint _amountOut);\\n    function updateAndConsult(\\n      address _tokenIn,\\n      uint _amountIn,\\n      address _tokenOut\\n    ) external\\n      returns (uint _amountOut);\\n}\"\r\n    },\r\n    \"contracts/utils/UnlockOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport './UnlockInitializable.sol';\\nimport './UnlockContextUpgradeable.sol';\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\\n * the owner.\\n * \\n * This contract was originally part of openzeppelin/contracts-ethereum-package\\n * but had to be included (instead of using the one in openzeppelin/contracts-upgradeable ) \\n * because the ______gap array length was 49 instead of 50\\n */\\nabstract contract UnlockOwnable is UnlockInitializable, UnlockContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __initializeOwnable(address sender) public initializer {\\n        _owner = sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * > Note: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n      require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n      _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    uint256[50] private ______gap;\\n}\"\r\n    },\r\n    \"contracts/utils/UnlockInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract UnlockInitializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(initializing ? _isConstructor() : !initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !initializing;\\n        if (isTopLevelCall) {\\n            initializing = true;\\n            initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPublicLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.17 <0.9.0;\\n\\n/**\\n* @title The PublicLock Interface\\n* @author Nick Furfaro (unlock-protocol.com)\\n */\\n\\n\\ninterface IPublicLock\\n{\\n\\n// See indentationissue description here:\\n// https://github.com/duaraghav8/Ethlint/issues/268\\n// solium-disable indentation\\n\\n  /// Functions\\n  function initialize(\\n    address _lockCreator,\\n    uint _expirationDuration,\\n    address _tokenAddress,\\n    uint _keyPrice,\\n    uint _maxNumberOfKeys,\\n    string calldata _lockName\\n  ) external;\\n\\n  /**\\n   * @notice Allow the contract to accept tips in ETH sent directly to the contract.\\n   * @dev This is okay to use even if the lock is priced in ERC-20 tokens\\n   */\\n  // receive() external payable;\\n\\n  // roles\\n  function DEFAULT_ADMIN_ROLE() external pure returns (bytes32);\\n  function KEY_GRANTER_ROLE() external pure returns (bytes32);\\n  function LOCK_MANAGER_ROLE() external pure returns (bytes32);\\n\\n  /**\\n  * @notice The version number of the current implementation on this network.\\n  * @return The current version number.\\n  */\\n  function publicLockVersion() external pure returns (uint16);\\n\\n  /**\\n  * @notice Used to disable lock before migrating keys and/or destroying contract.\\n  * @dev Throws if called by other than a lock manager.\\n  * @dev Throws if lock contract has already been disabled.\\n  */\\n  function disableLock() external;\\n\\n  /**\\n   * @dev Called by a lock manager or beneficiary to withdraw all funds from the lock and send them to the `beneficiary`.\\n   * @dev Throws if called by other than a lock manager or beneficiary\\n   * @param _tokenAddress specifies the token address to withdraw or 0 for ETH. This is usually\\n   * the same as `tokenAddress` in MixinFunds.\\n   * @param _amount specifies the max amount to withdraw, which may be reduced when\\n   * considering the available balance. Set to 0 or MAX_UINT to withdraw everything.\\n   *  -- however be wary of draining funds as it breaks the `cancelAndRefund` and `expireAndRefundFor`\\n   * use cases.\\n   */\\n  function withdraw(\\n    address _tokenAddress,\\n    uint _amount\\n  ) external;\\n\\n  /**\\n   * @notice An ERC-20 style approval, allowing the spender to transfer funds directly from this lock.\\n   */\\n  function approveBeneficiary(\\n    address _spender,\\n    uint _amount\\n  ) external\\n    returns (bool);\\n\\n  /**\\n   * A function which lets a Lock manager of the lock to change the price for future purchases.\\n   * @dev Throws if called by other than a Lock manager\\n   * @dev Throws if lock has been disabled\\n   * @dev Throws if _tokenAddress is not a valid token\\n   * @param _keyPrice The new price to set for keys\\n   * @param _tokenAddress The address of the erc20 token to use for pricing the keys,\\n   * or 0 to use ETH\\n   */\\n  function updateKeyPricing( uint _keyPrice, address _tokenAddress ) external;\\n\\n  /**\\n   * A function to change the default duration of each key in the lock\\n   * @notice keys previously bought are unaffected by this change (i.e.\\n   * existing keys timestamps are not recalculated/updated)\\n   * @param _newExpirationDuration the new amount of time for each key purchased \\n   * or zero (0) for a non-expiring key\\n   */\\n  function setExpirationDuration(uint _newExpirationDuration) external;\\n\\n  /**\\n   * A function which lets a Lock manager update the beneficiary account,\\n   * which receives funds on withdrawal.\\n   * @dev Throws if called by other than a Lock manager or beneficiary\\n   * @dev Throws if _beneficiary is address(0)\\n   * @param _beneficiary The new address to set as the beneficiary\\n   */\\n  function updateBeneficiary( address _beneficiary ) external;\\n\\n  /**\\n   * Checks if the user has a non-expired key.\\n   * @param _user The address of the key owner\\n   */\\n  function getHasValidKey(\\n    address _user\\n  ) external view returns (bool);\\n\\n  /**\\n   * @notice Find the tokenId for a given user\\n   * @return The tokenId of the NFT, else returns 0\\n   * @param _account The address of the key owner\\n  */\\n  function getTokenIdFor(\\n    address _account\\n  ) external view returns (uint);\\n\\n  /**\\n  * @dev Returns the key's ExpirationTimestamp field for a given owner.\\n  * @param _keyOwner address of the user for whom we search the key\\n  * @dev Returns 0 if the owner has never owned a key for this lock\\n  */\\n  function keyExpirationTimestampFor(\\n    address _keyOwner\\n  ) external view returns (uint timestamp);\\n  \\n  /**\\n   * Public function which returns the total number of unique owners (both expired\\n   * and valid).  This may be larger than totalSupply.\\n   */\\n  function numberOfOwners() external view returns (uint);\\n\\n  /**\\n   * Allows a Lock manager to assign a descriptive name for this Lock.\\n   * @param _lockName The new name for the lock\\n   * @dev Throws if called by other than a Lock manager\\n   */\\n  function updateLockName(\\n    string calldata _lockName\\n  ) external;\\n\\n  /**\\n   * Allows a Lock manager to assign a Symbol for this Lock.\\n   * @param _lockSymbol The new Symbol for the lock\\n   * @dev Throws if called by other than a Lock manager\\n   */\\n  function updateLockSymbol(\\n    string calldata _lockSymbol\\n  ) external;\\n\\n  /**\\n    * @dev Gets the token symbol\\n    * @return string representing the token symbol\\n    */\\n  function symbol()\\n    external view\\n    returns(string memory);\\n\\n    /**\\n   * Allows a Lock manager to update the baseTokenURI for this Lock.\\n   * @dev Throws if called by other than a Lock manager\\n   * @param _baseTokenURI String representing the base of the URI for this lock.\\n   */\\n  function setBaseTokenURI(\\n    string calldata _baseTokenURI\\n  ) external;\\n\\n  /**  @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n   * @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\n   *  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n   *  Metadata JSON Schema\\\".\\n   * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n   * @param _tokenId The tokenID we're inquiring about\\n   * @return String representing the URI for the requested token\\n   */\\n  function tokenURI(\\n    uint256 _tokenId\\n  ) external view returns(string memory);\\n\\n  /**\\n   * @notice Allows a Lock manager to add or remove an event hook\\n   */\\n  function setEventHooks(\\n    address _onKeyPurchaseHook,\\n    address _onKeyCancelHook,\\n    address _onValidKeyHook,\\n    address _onTokenURIHook\\n  ) external;\\n\\n  /**\\n   * Allows a Lock manager to give a collection of users a key with no charge.\\n   * Each key may be assigned a different expiration date.\\n   * @dev Throws if called by other than a Lock manager\\n   * @param _recipients An array of receiving addresses\\n   * @param _expirationTimestamps An array of expiration Timestamps for the keys being granted\\n   */\\n  function grantKeys(\\n    address[] calldata _recipients,\\n    uint[] calldata _expirationTimestamps,\\n    address[] calldata _keyManagers\\n  ) external;\\n\\n  /**\\n  * @dev Purchase function\\n  * @param _value the number of tokens to pay for this purchase >= the current keyPrice - any applicable discount\\n  * (_value is ignored when using ETH)\\n  * @param _recipient address of the recipient of the purchased key\\n  * @param _referrer address of the user making the referral\\n  * @param _keyManager optional address to grant managing rights to a specific address on creation\\n  * @param _data arbitrary data populated by the front-end which initiated the sale\\n  * @dev Throws if lock is disabled. Throws if lock is sold-out. Throws if _recipient == address(0).\\n  * @dev Setting _value to keyPrice exactly doubles as a security feature. That way if a Lock manager increases the\\n  * price while my transaction is pending I can't be charged more than I expected (only applicable to ERC-20 when more\\n  * than keyPrice is approved for spending).\\n  */\\n  function purchase(\\n    uint256 _value,\\n    address _recipient,\\n    address _referrer,\\n    address _keyManager,\\n    bytes calldata _data\\n  ) external payable;\\n\\n  /**\\n  * @param _gasRefundValue price in wei or token in smallest price unit\\n  * @dev Set the value to be refunded to the sender on purchase\\n  */\\n  function setGasRefundValue(uint256 _gasRefundValue) external;\\n  \\n  /**\\n  * _gasRefundValue price in wei or token in smallest price unit\\n  * @dev Returns the value/rpice to be refunded to the sender on purchase\\n  */\\n  function gasRefundValue() external view returns (uint256 _gasRefundValue);\\n\\n  /**\\n   * @notice returns the minimum price paid for a purchase with these params.\\n   * @dev this considers any discount from Unlock or the OnKeyPurchase hook.\\n   */\\n  function purchasePriceFor(\\n    address _recipient,\\n    address _referrer,\\n    bytes calldata _data\\n  ) external view\\n    returns (uint);\\n\\n  /**\\n   * Allow a Lock manager to change the transfer fee.\\n   * @dev Throws if called by other than a Lock manager\\n   * @param _transferFeeBasisPoints The new transfer fee in basis-points(bps).\\n   * Ex: 200 bps = 2%\\n   */\\n  function updateTransferFee(\\n    uint _transferFeeBasisPoints\\n  ) external;\\n\\n  /**\\n   * Determines how much of a fee a key owner would need to pay in order to\\n   * transfer the key to another account.  This is pro-rated so the fee goes down\\n   * overtime.\\n   * @dev Throws if _keyOwner does not have a valid key\\n   * @param _keyOwner The owner of the key check the transfer fee for.\\n   * @param _time The amount of time to calculate the fee for.\\n   * @return The transfer fee in seconds.\\n   */\\n  function getTransferFee(\\n    address _keyOwner,\\n    uint _time\\n  ) external view returns (uint);\\n\\n  /**\\n   * @dev Invoked by a Lock manager to expire the user's key and perform a refund and cancellation of the key\\n   * @param _keyOwner The key owner to whom we wish to send a refund to\\n   * @param amount The amount to refund the key-owner\\n   * @dev Throws if called by other than a Lock manager\\n   * @dev Throws if _keyOwner does not have a valid key\\n   */\\n  function expireAndRefundFor(\\n    address _keyOwner,\\n    uint amount\\n  ) external;\\n\\n   /**\\n   * @dev allows the key manager to expire a given tokenId\\n   * and send a refund to the keyOwner based on the amount of time remaining.\\n   * @param _tokenId The id of the key to cancel.\\n   */\\n  function cancelAndRefund(uint _tokenId) external;\\n\\n  /**\\n   * Allow a Lock manager to change the refund penalty.\\n   * @dev Throws if called by other than a Lock manager\\n   * @param _freeTrialLength The new duration of free trials for this lock\\n   * @param _refundPenaltyBasisPoints The new refund penaly in basis-points(bps)\\n   */\\n  function updateRefundPenalty(\\n    uint _freeTrialLength,\\n    uint _refundPenaltyBasisPoints\\n  ) external;\\n\\n  /**\\n   * @dev Determines how much of a refund a key owner would receive if they issued\\n   * @param _keyOwner The key owner to get the refund value for.\\n   * a cancelAndRefund block.timestamp.\\n   * Note that due to the time required to mine a tx, the actual refund amount will be lower\\n   * than what the user reads from this call.\\n   */\\n  function getCancelAndRefundValueFor(\\n    address _keyOwner\\n  ) external view returns (uint refund);\\n\\n  function addKeyGranter(address account) external;\\n\\n  function addLockManager(address account) external;\\n\\n  function isKeyGranter(address account) external view returns (bool);\\n\\n  function isLockManager(address account) external view returns (bool);\\n\\n  function onKeyPurchaseHook() external view returns(address);\\n\\n  function onKeyCancelHook() external view returns(address);\\n  \\n  function onValidKeyHook() external view returns(bool);\\n\\n  function onTokenURIHook() external view returns(string memory);\\n\\n  function revokeKeyGranter(address _granter) external;\\n\\n  function renounceLockManager() external;\\n\\n  /**\\n   * @dev Change the maximum number of keys the lock can edit\\n   * @param _maxNumberOfKeys uint the maximum number of keys\\n   */\\n  function setMaxNumberOfKeys (uint _maxNumberOfKeys) external;\\n\\n  ///===================================================================\\n  /// Auto-generated getter functions from public state variables\\n\\n  function beneficiary() external view returns (address );\\n\\n  function expirationDuration() external view returns (uint256 );\\n\\n  function freeTrialLength() external view returns (uint256 );\\n\\n  function isAlive() external view returns (bool );\\n\\n  function keyPrice() external view returns (uint256 );\\n\\n  function maxNumberOfKeys() external view returns (uint256 );\\n\\n  function refundPenaltyBasisPoints() external view returns (uint256 );\\n\\n  function tokenAddress() external view returns (address );\\n\\n  function transferFeeBasisPoints() external view returns (uint256 );\\n\\n  function unlockProtocol() external view returns (address );\\n\\n  function keyManagerOf(uint) external view returns (address );\\n\\n  ///===================================================================\\n\\n  /**\\n  * @notice Allows the key owner to safely share their key (parent key) by\\n  * transferring a portion of the remaining time to a new key (child key).\\n  * @dev Throws if key is not valid.\\n  * @dev Throws if `_to` is the zero address\\n  * @param _to The recipient of the shared key\\n  * @param _tokenId the key to share\\n  * @param _timeShared The amount of time shared\\n  * checks if `_to` is a smart contract (code size > 0). If so, it calls\\n  * `onERC721Received` on `_to` and throws if the return value is not\\n  * `bytes4(keccak256('onERC721Received(address,address,uint,bytes)'))`.\\n  * @dev Emit Transfer event\\n  */\\n  function shareKey(\\n    address _to,\\n    uint _tokenId,\\n    uint _timeShared\\n  ) external;\\n\\n  /**\\n  * @notice Update transfer and cancel rights for a given key\\n  * @param _tokenId The id of the key to assign rights for\\n  * @param _keyManager The address to assign the rights to for the given key\\n  */\\n  function setKeyManagerOf(\\n    uint _tokenId,\\n    address _keyManager\\n  ) external;\\n\\n  /// @notice A descriptive name for a collection of NFTs in this contract\\n  function name() external view returns (string memory _name);\\n  ///===================================================================\\n\\n  /// From ERC165.sol\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n  ///===================================================================\\n\\n  /// From ERC-721\\n  /**\\n     * @dev Returns the number of NFTs in `owner`'s account.\\n     */\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the NFT specified by `tokenId`.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address _owner);\\n\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Requirements:\\n     * - `from`, `to` cannot be zero.\\n     * - `tokenId` must be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this\\n     * NFT by either {approve} or {setApprovalForAll}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n    \\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Requirements:\\n     * - If the caller is not `from`, it must be approved to move this NFT by\\n     * either {approve} or {setApprovalForAll}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n    * @notice Get the approved address for a single NFT\\n    * @dev Throws if `_tokenId` is not a valid NFT.\\n    * @param _tokenId The NFT to find the approved address for\\n    * @return operator The approved address for this NFT, or the zero address if there is none\\n    */\\n    function getApproved(uint256 _tokenId) external view returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n    function isApprovedForAll(address _owner, address operator) external view returns (bool);\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    function totalSupply() external view returns (uint256);\\n    function tokenOfOwnerByIndex(address _owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n\\n    /**\\n    * Innherited from Open Zeppelin AccessControl.sol\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n    function grantRole(bytes32 role, address account) external;\\n    function revokeRole(bytes32 role, address account) external;\\n    function renounceRole(bytes32 role, address account) external;\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @notice An ERC-20 style transfer.\\n     * @param _value sends a token with _value * expirationDuration (the amount of time remaining on a standard purchase).\\n     * @dev The typical use case would be to call this with _value 1, which is on par with calling `transferFrom`. If the user\\n     * has more than `expirationDuration` time remaining this may use the `shareKey` function to send some but not all of the token.\\n     */\\n    function transfer(\\n      address _to,\\n      uint _value\\n    ) external\\n      returns (bool success);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMintableERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.17 <0.9.0;\\n\\ninterface IMintableERC20\\n{\\n  function mint(address account, uint256 amount) external returns (bool);\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n  function totalSupply() external returns (uint);\\n  function balanceOf(address account) external returns (uint256);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallSecure(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        address oldImplementation = _getImplementation();\\n\\n        // Initial upgrade and setup call\\n        _setImplementation(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n\\n        // Perform rollback test if not already in progress\\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\\n        if (!rollbackTesting.value) {\\n            // Trigger rollback using upgradeTo from the new implementation\\n            rollbackTesting.value = true;\\n            Address.functionDelegateCall(\\n                newImplementation,\\n                abi.encodeWithSignature(\\\"upgradeTo(address)\\\", oldImplementation)\\n            );\\n            rollbackTesting.value = false;\\n            // Check rollback was effective\\n            require(oldImplementation == _getImplementation(), \\\"ERC1967Upgrade: upgrade breaks further upgrades\\\");\\n            // Finally reset to the new implementation and log the upgrade\\n            _upgradeTo(newImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/UnlockContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"./UnlockInitializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract UnlockContextUpgradeable is UnlockInitializable {\\n    function __Context_init() internal onlyInitializing {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private ______gap;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"udt\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"weth\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"estimatedGasForPurchase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"globalTokenSymbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"globalTokenURI\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"ConfigUnlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lockAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"LockUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lockOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newLockAddress\",\"type\":\"address\"}],\"name\":\"NewLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"grossNetworkProduct\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDiscountGranted\",\"type\":\"uint256\"}],\"name\":\"ResetTrackedValue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"publicLockAddress\",\"type\":\"address\"}],\"name\":\"SetLockTemplate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"UnlockTemplateAdded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"__initializeOwnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"addLockTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"computeAvailableDiscountFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"discount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_udt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_estimatedGasForPurchase\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_URI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"configUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_expirationDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_keyPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxNumberOfKeys\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_lockName\",\"type\":\"string\"},{\"internalType\":\"bytes12\",\"name\":\"\",\"type\":\"bytes12\"}],\"name\":\"createLock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"createUpgradeableLock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estimatedGasForPurchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalBaseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalTokenSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalBaseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalTokenSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"grossNetworkProduct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_unlockOwner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializeProxyAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"locks\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"deployed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalSales\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yieldedDiscountTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkBaseFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyAdminAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicLockAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"}],\"name\":\"publicLockImpls\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicLockLatestVersion\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"}],\"name\":\"publicLockVersions\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"recordConsumedDiscount\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"recordKeyPurchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_grossNetworkProduct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalDiscountGranted\",\"type\":\"uint256\"}],\"name\":\"resetTrackedValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_publicLockAddress\",\"type\":\"address\"}],\"name\":\"setLockTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracleAddress\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDiscountGranted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"udt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"uniswapOracles\",\"outputs\":[{\"internalType\":\"contract IUniswapOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockVersion\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"lockAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"upgradeLock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Unlock", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}