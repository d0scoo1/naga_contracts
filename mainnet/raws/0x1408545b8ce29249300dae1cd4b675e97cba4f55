{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\ninterface IRelayer {\n    enum RelayerType {\n        DiscountRate,\n        SpotPrice,\n        COUNT\n    }\n\n    function execute() external returns (bool);\n\n    function executeWithRevert() external;\n}interface IOracle {\n    function value() external view returns (int256, bool);\n\n    function update() external returns (bool);\n}// Lightweight interface for Collybus\n// Source: https://github.com/fiatdao/fiat-lux/blob/f49a9457fbcbdac1969c35b4714722f00caa462c/src/interfaces/ICollybus.sol\ninterface ICollybus {\n    function updateDiscountRate(uint256 tokenId_, uint256 rate_) external;\n\n    function updateSpot(address token_, uint256 spot_) external;\n}/// @title Guarded\n/// @notice Mixin implementing an authentication scheme on a method level\nabstract contract Guarded {\n    /// ======== Custom Errors ======== ///\n\n    error Guarded__notRoot();\n    error Guarded__notGranted();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Wildcard for granting a caller to call every guarded method\n    bytes32 public constant ANY_SIG = keccak256(\"ANY_SIG\");\n    /// @notice Wildcard for granting a caller to call every guarded method\n    address public constant ANY_CALLER =\n        address(uint160(uint256(bytes32(keccak256(\"ANY_CALLER\")))));\n\n    /// @notice Mapping storing who is granted to which method\n    /// @dev Method Signature => Caller => Bool\n    mapping(bytes32 => mapping(address => bool)) private _canCall;\n\n    /// ======== Events ======== ///\n\n    event AllowCaller(bytes32 sig, address who);\n    event BlockCaller(bytes32 sig, address who);\n\n    constructor() {\n        // set root\n        _setRoot(msg.sender);\n    }\n\n    /// ======== Auth ======== ///\n\n    modifier callerIsRoot() {\n        if (_canCall[ANY_SIG][msg.sender]) {\n            _;\n        } else revert Guarded__notRoot();\n    }\n\n    modifier checkCaller() {\n        if (canCall(msg.sig, msg.sender)) {\n            _;\n        } else revert Guarded__notGranted();\n    }\n\n    /// @notice Grant the right to call method `sig` to `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig_ Method signature (4Byte)\n    /// @param who_ Address of who should be able to call `sig`\n    function allowCaller(bytes32 sig_, address who_) public callerIsRoot {\n        _canCall[sig_][who_] = true;\n        emit AllowCaller(sig_, who_);\n    }\n\n    /// @notice Revoke the right to call method `sig` from `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig_ Method signature (4Byte)\n    /// @param who_ Address of who should not be able to call `sig` anymore\n    function blockCaller(bytes32 sig_, address who_) public callerIsRoot {\n        _canCall[sig_][who_] = false;\n        emit BlockCaller(sig_, who_);\n    }\n\n    /// @notice Returns if `who` can call `sig`\n    /// @param sig_ Method signature (4Byte)\n    /// @param who_ Address of who should be able to call `sig`\n    function canCall(bytes32 sig_, address who_) public view returns (bool) {\n        return (_canCall[sig_][who_] ||\n            _canCall[ANY_SIG][who_] ||\n            _canCall[sig_][ANY_CALLER]);\n    }\n\n    /// @notice Sets the root user (granted `ANY_SIG`)\n    /// @param root_ Address of who should be set as root\n    function _setRoot(address root_) internal {\n        _canCall[ANY_SIG][root_] = true;\n        emit AllowCaller(ANY_SIG, root_);\n    }\n}\n/// @notice The Relayer contract manages the relationship between an oracle and Collybus.\n/// The Relayer manages an Oracle for which it controls the update flow and via execute() calls\n/// pushes data to Collybus when it's needed\n/// @dev The Relayer should be the single entity that updates the oracle so that the Relayer and the Oracle\n/// are value synched. The same is true for the Relayer-Collybus relationship as we do not interrogate the Collybus\n/// for the current value and use a storage cached last updated value.\ncontract Relayer is Guarded, IRelayer {\n    /// @notice Emitter during executeWithRevert() if the oracle is not updated successfully\n    error Relayer__executeWithRevert_noUpdate(RelayerType relayerType);\n\n    /// @notice Emitted when trying to set a parameter that does not exist\n    error Relayer__setParam_unrecognizedParam(bytes32 param);\n\n    event SetParam(bytes32 param, uint256 value);\n    event UpdateOracle(address oracle, int256 value, bool valid);\n    event UpdatedCollybus(bytes32 tokenId, uint256 rate, RelayerType);\n\n    /// ======== Storage ======== ///\n\n    address public immutable collybus;\n    RelayerType public immutable relayerType;\n    address public immutable oracle;\n    bytes32 public immutable encodedTokenId;\n\n    uint256 public minimumPercentageDeltaValue;\n    int256 private _lastUpdateValue;\n\n    /// @param collybusAddress_ Address of the collybus\n    /// @param type_ Relayer type, DiscountRate or SpotPrice\n    /// @param encodedTokenId_ Encoded token Id that will be used to push values to Collybus\n    /// uint256 for discount rate, address for spot price\n    /// @param minimumPercentageDeltaValue_ Minimum delta value used to determine when to\n    /// push data to Collybus\n    constructor(\n        address collybusAddress_,\n        RelayerType type_,\n        address oracleAddress_,\n        bytes32 encodedTokenId_,\n        uint256 minimumPercentageDeltaValue_\n    ) {\n        collybus = collybusAddress_;\n        relayerType = type_;\n        oracle = oracleAddress_;\n        encodedTokenId = encodedTokenId_;\n        minimumPercentageDeltaValue = minimumPercentageDeltaValue_;\n        _lastUpdateValue = 0;\n    }\n\n    /// @notice Sets a Relayer parameter\n    /// Supported parameters are:\n    /// - minimumPercentageDeltaValue\n    /// @param param_ The identifier of the parameter that should be updated\n    /// @param value_ The new value\n    /// @dev Reverts if parameter is not found\n    function setParam(bytes32 param_, uint256 value_) public checkCaller {\n        if (param_ == \"minimumPercentageDeltaValue\") {\n            minimumPercentageDeltaValue = value_;\n        } else revert Relayer__setParam_unrecognizedParam(param_);\n\n        emit SetParam(param_, value_);\n    }\n\n    /// @notice Updates the oracle and pushes the updated data to Collybus if the\n    /// delta change in value is bigger than the minimum threshold value.\n    function execute() public override(IRelayer) returns (bool) {\n        // We always update the oracles before retrieving the rates\n        bool oracleUpdated = IOracle(oracle).update();\n        (int256 oracleValue, bool isValid) = IOracle(oracle).value();\n\n        // If the oracle was not updated, the value is invalid or the delta condition is not met, we can exit early\n        if (\n            !oracleUpdated ||\n            !isValid ||\n            !checkDeviation(\n                _lastUpdateValue,\n                oracleValue,\n                minimumPercentageDeltaValue\n            )\n        ) {\n            return oracleUpdated;\n        }\n\n        _lastUpdateValue = oracleValue;\n\n        if (relayerType == RelayerType.DiscountRate) {\n            ICollybus(collybus).updateDiscountRate(\n                uint256(encodedTokenId),\n                uint256(oracleValue)\n            );\n        } else if (relayerType == RelayerType.SpotPrice) {\n            ICollybus(collybus).updateSpot(\n                address(uint160(uint256(encodedTokenId))),\n                uint256(oracleValue)\n            );\n        }\n\n        emit UpdatedCollybus(encodedTokenId, uint256(oracleValue), relayerType);\n\n        return oracleUpdated;\n    }\n\n    /// @notice The function will call `execute()` and will revert if the oracle was not updated\n    /// @dev This method is needed for services that run on each block and only call the method if it doesn't fail\n    function executeWithRevert() public override(IRelayer) {\n        if (!execute()) {\n            revert Relayer__executeWithRevert_noUpdate(relayerType);\n        }\n    }\n\n    /// @notice Returns true if the percentage difference between the two values is bigger than the `percentage`\n    /// @param baseValue_ The value that the percentage is based on\n    /// @param newValue_ The new value\n    /// @param percentage_ The percentage threshold value (100% = 100_00, 50% = 50_00, etc)\n    function checkDeviation(\n        int256 baseValue_,\n        int256 newValue_,\n        uint256 percentage_\n    ) public pure returns (bool) {\n        int256 deviation = (baseValue_ * int256(percentage_)) / 100_00;\n\n        if (\n            baseValue_ + deviation <= newValue_ ||\n            baseValue_ - deviation >= newValue_\n        ) return true;\n\n        return false;\n    }\n}\ncontract StaticRelayer is IRelayer {\n    /// @notice Emitted during executeWithRevert() if the Collybus was already updated\n    error StaticRelayer__executeWithRevert_collybusAlreadyUpdated(\n        IRelayer.RelayerType relayerType\n    );\n\n    /// ======== Events ======== ///\n\n    event UpdatedCollybus(\n        bytes32 tokenId,\n        uint256 rate,\n        IRelayer.RelayerType relayerType\n    );\n\n    /// ======== Storage ======== ///\n\n    address public immutable collybus;\n    IRelayer.RelayerType public immutable relayerType;\n    bytes32 public immutable encodedTokenId;\n    uint256 public immutable value;\n\n    // Flag used to ensure that the value is pushed to Collybus only once\n    bool private _updatedCollybus;\n\n    constructor(\n        address collybusAddress_,\n        IRelayer.RelayerType type_,\n        bytes32 encodedTokenId_,\n        uint256 value_\n    ) {\n        collybus = collybusAddress_;\n        relayerType = type_;\n        encodedTokenId = encodedTokenId_;\n        value = value_;\n        _updatedCollybus = false;\n    }\n\n    /// @notice Pushes the hardcoded value to Collybus for the hardcoded token id\n    /// @dev The execute will exit early after the first update\n    function execute() public override(IRelayer) returns (bool) {\n        if (_updatedCollybus) return false;\n\n        _updatedCollybus = true;\n        if (relayerType == IRelayer.RelayerType.DiscountRate) {\n            ICollybus(collybus).updateDiscountRate(\n                uint256(encodedTokenId),\n                value\n            );\n        } else if (relayerType == IRelayer.RelayerType.SpotPrice) {\n            ICollybus(collybus).updateSpot(\n                address(uint160(uint256(encodedTokenId))),\n                value\n            );\n        }\n\n        emit UpdatedCollybus(encodedTokenId, value, relayerType);\n        return true;\n    }\n\n    /// @notice The function will call `execute()` and will revert if _updatedCollybus is true\n    function executeWithRevert() public override(IRelayer) {\n        if (!execute()) {\n            revert StaticRelayer__executeWithRevert_collybusAlreadyUpdated(\n                relayerType\n            );\n        }\n    }\n}\n\ninterface IRelayerFactory {\n    function create(\n        address collybus_,\n        IRelayer.RelayerType relayerType_,\n        address oracleAddress,\n        bytes32 encodedTokenId,\n        uint256 minimumPercentageDeltaValue\n    ) external returns (address);\n\n    function createStatic(\n        address collybus_,\n        IRelayer.RelayerType relayerType_,\n        bytes32 encodedTokenId_,\n        uint256 value_\n    ) external returns (address);\n}\n\ncontract RelayerFactory is IRelayerFactory {\n    // Emitted when a Relayer is created\n    event RelayerDeployed(\n        address relayerAddress,\n        IRelayer.RelayerType relayerType,\n        address oracleAddress,\n        bytes32 encodedTokenId,\n        uint256 minimumPercentageDeltaValue\n    );\n    // Emitted when a Static Relayer is created\n    event StaticRelayerDeployed(\n        address relayerAddress,\n        IRelayer.RelayerType relayerType,\n        bytes32 encodedTokenId,\n        uint256 value\n    );\n\n    /// @notice Creates a Relayer contract that manages an Oracle in order to push data to Collybus\n    /// @param collybus_ The address of the Collybus where the Relayer will push data\n    /// @param relayerType_ Relayer type, can be DiscountRate or SpotPrice\n    /// @param oracleAddress_ The address of the oracle that will provide data\n    /// @param encodedTokenId_ Encoded tokenId that will be used to push data to Collybus\n    /// @param minimumPercentageDeltaValue_ Minimum delta value used to decide when to push data to Collybus\n    function create(\n        address collybus_,\n        Relayer.RelayerType relayerType_,\n        address oracleAddress_,\n        bytes32 encodedTokenId_,\n        uint256 minimumPercentageDeltaValue_\n    ) public override(IRelayerFactory) returns (address) {\n        Relayer relayer = new Relayer(\n            collybus_,\n            relayerType_,\n            oracleAddress_,\n            encodedTokenId_,\n            minimumPercentageDeltaValue_\n        );\n\n        // Pass permissions to the intended contract owner\n        relayer.allowCaller(relayer.ANY_SIG(), msg.sender);\n        relayer.blockCaller(relayer.ANY_SIG(), address(this));\n\n        emit RelayerDeployed(\n            address(relayer),\n            relayerType_,\n            oracleAddress_,\n            encodedTokenId_,\n            minimumPercentageDeltaValue_\n        );\n        return address(relayer);\n    }\n\n    /// @notice Creates a Static Relayer contract that acts as a one time data provider.\n    /// @param collybus_ The address of the Collybus where the StaticRelayer will push data\n    /// @param relayerType_ Relayer type, can be DiscountRate or SpotPrice\n    /// @param encodedTokenId_ Encoded tokenId that will be used to push data to Collybus\n    /// @param value_ The value that will be pushed.\n    /// @dev The contract will self-destruct after the rate is successfully pushed to Collybus\n    function createStatic(\n        address collybus_,\n        Relayer.RelayerType relayerType_,\n        bytes32 encodedTokenId_,\n        uint256 value_\n    ) public override(IRelayerFactory) returns (address) {\n        // Create the Static Relayer contract\n        StaticRelayer staticRelayer = new StaticRelayer(\n            collybus_,\n            relayerType_,\n            encodedTokenId_,\n            value_\n        );\n\n        emit StaticRelayerDeployed(\n            address(staticRelayer),\n            relayerType_,\n            encodedTokenId_,\n            value_\n        );\n        return address(staticRelayer);\n    }\n}\n", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum IRelayer.RelayerType\",\"name\":\"relayerType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oracleAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"encodedTokenId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumPercentageDeltaValue\",\"type\":\"uint256\"}],\"name\":\"RelayerDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum IRelayer.RelayerType\",\"name\":\"relayerType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"encodedTokenId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"StaticRelayerDeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collybus_\",\"type\":\"address\"},{\"internalType\":\"enum IRelayer.RelayerType\",\"name\":\"relayerType_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"oracleAddress_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"encodedTokenId_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"minimumPercentageDeltaValue_\",\"type\":\"uint256\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collybus_\",\"type\":\"address\"},{\"internalType\":\"enum IRelayer.RelayerType\",\"name\":\"relayerType_\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"encodedTokenId_\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"}],\"name\":\"createStatic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RelayerFactory", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "8000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}