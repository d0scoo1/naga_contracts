{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TokenListVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libraries/BytesUtils.sol\\\";\\n\\ncontract TokenListVerifier {\\n    using BytesUtils for bytes;\\n\\n    function verifyErc721(bytes memory callData) public pure {\\n        uint256 tokenId = abi.decode(callData.slice(68, 32), (uint256));\\n\\n        (bytes32 root, bytes32[] memory proof) = abi.decode(\\n            callData.drop(100),\\n            (bytes32, bytes32[])\\n        );\\n\\n        require(\\n            verify(proof, root, keccak256(abi.encodePacked(tokenId))),\\n            \\\"Invalid merkle proof\\\"\\n        );\\n    }\\n\\n    function verifyErc1155(bytes memory callData) public pure {\\n        uint256 tokenId = abi.decode(callData.slice(68, 32), (uint256));\\n\\n        (bytes32 root, bytes32[] memory proof) = abi.decode(\\n            callData.drop(196),\\n            (bytes32, bytes32[])\\n        );\\n\\n        require(\\n            verify(proof, root, keccak256(abi.encodePacked(tokenId))),\\n            \\\"Invalid merkle proof\\\"\\n        );\\n    }\\n\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            // Once we get to an empty proof element, stop\\n            if (proofElement == bytes32(0)) {\\n                break;\\n            }\\n\\n            if (computedHash <= proofElement) {\\n                // hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(\\n                    abi.encodePacked(computedHash, proofElement)\\n                );\\n            } else {\\n                // hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(\\n                    abi.encodePacked(proofElement, computedHash)\\n                );\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BytesUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// Inspired from the Wyvern V3 source code:\\n// https://github.com/wyvernprotocol/wyvern-v3/blob/1d89d6a91faddf3c3494e6ebdcb07b46fe111fb4/contracts/lib/ArrayUtils.sol\\n\\nlibrary BytesUtils {\\n    function drop(bytes memory array, uint256 start)\\n        public\\n        pure\\n        returns (bytes memory result)\\n    {\\n        result = slice(array, start, array.length - start);\\n    }\\n\\n    function slice(\\n        bytes memory array,\\n        uint256 start,\\n        uint256 length\\n    ) public pure returns (bytes memory result) {\\n        assembly {\\n            switch iszero(length)\\n            case 0 {\\n                // Get a location of some free memory and store it in `result`\\n                result := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthMod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthMod := and(length, 31)\\n\\n                // The multiplication in the next line is necessary because when\\n                // slicing multiples of 32 bytes (`lengthMod == 0`) the following\\n                // copy loop was copying the origin's length and then ending in a\\n                // premature way not copying everything it should.\\n                let mc := add(\\n                    add(result, lengthMod),\\n                    mul(0x20, iszero(lengthMod))\\n                )\\n                let end := add(mc, length)\\n\\n                for {\\n                    // The multiplication below has the same exact purpose as the one above\\n                    let cc := add(\\n                        add(\\n                            add(array, lengthMod),\\n                            mul(0x20, iszero(lengthMod))\\n                        ),\\n                        start\\n                    )\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(result, length)\\n\\n                // Update free-memory pointer, allocating the array padded to 32 bytes\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            // If we want a zero-length slice then simply return a zero-length array\\n            default {\\n                result := mload(0x40)\\n\\n                mstore(0x40, add(result, 0x20))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/BytesUtils.sol\": {\r\n        \"BytesUtils\": \"0x5595ddec926bfb297814c33a90e44f97c6074fe5\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"verifyErc1155\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"verifyErc721\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "TokenListVerifier", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}