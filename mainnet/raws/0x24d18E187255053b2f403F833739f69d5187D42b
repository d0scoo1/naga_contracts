{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nabstract contract ITranchedPool {\r\n  uint256 public createdAt;\r\n\r\n  enum Tranches {\r\n    Reserved,\r\n    Senior,\r\n    Junior\r\n  }\r\n\r\n  struct TrancheInfo {\r\n    uint256 id;\r\n    uint256 principalDeposited;\r\n    uint256 principalSharePrice;\r\n    uint256 interestSharePrice;\r\n    uint256 lockedUntil;\r\n  }\r\n\r\n  struct PoolSlice {\r\n    TrancheInfo seniorTranche;\r\n    TrancheInfo juniorTranche;\r\n    uint256 totalInterestAccrued;\r\n    uint256 principalDeployed;\r\n  }\r\n\r\n  struct SliceInfo {\r\n    uint256 reserveFeePercent;\r\n    uint256 interestAccrued;\r\n    uint256 principalAccrued;\r\n  }\r\n\r\n  struct ApplyResult {\r\n    uint256 interestRemaining;\r\n    uint256 principalRemaining;\r\n    uint256 reserveDeduction;\r\n    uint256 oldInterestSharePrice;\r\n    uint256 oldPrincipalSharePrice;\r\n  }\r\n\r\n  function initialize(\r\n    address _config,\r\n    address _borrower,\r\n    uint256 _juniorFeePercent,\r\n    uint256 _limit,\r\n    uint256 _interestApr,\r\n    uint256 _paymentPeriodInDays,\r\n    uint256 _termInDays,\r\n    uint256 _lateFeeApr,\r\n    uint256 _principalGracePeriodInDays,\r\n    uint256 _fundableAt,\r\n    uint256[] calldata _allowedUIDTypes\r\n  ) public virtual;\r\n\r\n  function getTranche(uint256 tranche) external view virtual returns (TrancheInfo memory);\r\n\r\n  function pay(uint256 amount) external virtual;\r\n\r\n  function lockJuniorCapital() external virtual;\r\n\r\n  function lockPool() external virtual;\r\n\r\n  function initializeNextSlice(uint256 _fundableAt) external virtual;\r\n\r\n  function totalJuniorDeposits() external view virtual returns (uint256);\r\n\r\n  function drawdown(uint256 amount) external virtual;\r\n\r\n  function setFundableAt(uint256 timestamp) external virtual;\r\n\r\n  function deposit(uint256 tranche, uint256 amount) external virtual returns (uint256 tokenId);\r\n\r\n  function assess() external virtual;\r\n\r\n  function depositWithPermit(\r\n    uint256 tranche,\r\n    uint256 amount,\r\n    uint256 deadline,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external virtual returns (uint256 tokenId);\r\n\r\n  function availableToWithdraw(uint256 tokenId)\r\n    external\r\n    view\r\n    virtual\r\n    returns (uint256 interestRedeemable, uint256 principalRedeemable);\r\n\r\n  function withdraw(uint256 tokenId, uint256 amount)\r\n    external\r\n    virtual\r\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\r\n\r\n  function withdrawMax(uint256 tokenId)\r\n    external\r\n    virtual\r\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\r\n\r\n  function withdrawMultiple(uint256[] calldata tokenIds, uint256[] calldata amounts) external virtual;\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: ruiyang/alloyx_v2/contracts/IPoolTokens.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\ninterface IPoolTokens is IERC721 {\r\n  event TokenMinted(\r\n    address indexed owner,\r\n    address indexed pool,\r\n    uint256 indexed tokenId,\r\n    uint256 amount,\r\n    uint256 tranche\r\n  );\r\n\r\n  event TokenRedeemed(\r\n    address indexed owner,\r\n    address indexed pool,\r\n    uint256 indexed tokenId,\r\n    uint256 principalRedeemed,\r\n    uint256 interestRedeemed,\r\n    uint256 tranche\r\n  );\r\n  event TokenBurned(address indexed owner, address indexed pool, uint256 indexed tokenId);\r\n\r\n  struct TokenInfo {\r\n    address pool;\r\n    uint256 tranche;\r\n    uint256 principalAmount;\r\n    uint256 principalRedeemed;\r\n    uint256 interestRedeemed;\r\n  }\r\n\r\n  struct MintParams {\r\n    uint256 principalAmount;\r\n    uint256 tranche;\r\n  }\r\n\r\n  function mint(MintParams calldata params, address to) external returns (uint256);\r\n\r\n  function redeem(\r\n    uint256 tokenId,\r\n    uint256 principalRedeemed,\r\n    uint256 interestRedeemed\r\n  ) external;\r\n\r\n  function burn(uint256 tokenId) external;\r\n\r\n  function onPoolCreated(address newPool) external;\r\n\r\n  function getTokenInfo(uint256 tokenId) external view returns (TokenInfo memory);\r\n\r\n  function validPool(address sender) external view returns (bool);\r\n\r\n  function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\r\n}\r\n\r\n// File: ruiyang/alloyx_v2/contracts/TestContract.sol\r\n\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\n\r\ncontract TestContract  {\r\n    uint256 private discountRate;\r\n    uint256 private protocolFee;\r\n    uint256 private operatorFee;\r\n    constructor(\r\n\r\n    ) {\r\n        discountRate = 0.01 * 10**6;\r\n        protocolFee = 0.002 * 10**6;\r\n        operatorFee = 0.002 * 10**6;\r\n\r\n    }\r\n    struct PurchaseInfo {\r\n        uint256 tokenValue;\r\n        uint256 discountAmount;\r\n        uint256 sellerAmount;\r\n        uint256 protcolAmount;\r\n        uint256 operatorAmount;\r\n        uint256 totalPrice;\r\n    }\r\n    function getPurchaseInfo(address _tokenAddress, uint256 _tokenID) public view returns (PurchaseInfo memory) {\r\n        // get the token value\r\n        uint256 tokenValue = getTokenValue(_tokenAddress, _tokenID);\r\n        // calculate the discount amount\r\n        uint256 discountAmount = (tokenValue * discountRate) / 1e6;\r\n        // calculate the amount of stable coin the seller will receive\r\n        uint256 sellerAmount = tokenValue - discountAmount;\r\n        // calculate the amount to be transferred to the protocol\r\n        uint256 protcolAmount = (sellerAmount * protocolFee) / 1e6;\r\n        // calculate the amount to be transferred to the operator\r\n        uint256 operatorAmount = (sellerAmount * operatorFee) / 1e6;\r\n        // calculate the total value the buyer will spend\r\n        uint256 totalPrice = sellerAmount + protcolAmount + operatorAmount;\r\n        return PurchaseInfo(tokenValue, discountAmount, sellerAmount, protcolAmount, operatorAmount, totalPrice);\r\n    }\r\n    function getTokenValue(address poolToken, uint256 tokenId) public view returns (uint256) {\r\n        IPoolTokens poolTokenContract = IPoolTokens(poolToken);\r\n        IPoolTokens.TokenInfo memory tokenInfo = poolTokenContract.getTokenInfo(tokenId);\r\n        uint256 principalAmount = tokenInfo.principalAmount;\r\n        uint256 totalRedeemed = tokenInfo.principalRedeemed + tokenInfo.interestRedeemed;\r\n        address tranchedPoolAddress = tokenInfo.pool;\r\n        ITranchedPool tranchedTokenContract = ITranchedPool(tranchedPoolAddress);\r\n        (uint256 interestRedeemable, uint256 principalRedeemable) = tranchedTokenContract.availableToWithdraw(tokenId);\r\n        uint256 totalRedeemable = interestRedeemable + principalRedeemable;\r\n        return principalAmount - totalRedeemed + totalRedeemable;\r\n    }\r\n\r\n    function isValidPool(address poolToken, uint256 tokenId) public view returns (bool) {\r\n        IPoolTokens poolTokenContract = IPoolTokens(poolToken);\r\n        IPoolTokens.TokenInfo memory tokenInfo = poolTokenContract.getTokenInfo(tokenId);\r\n        address tranchedPool = tokenInfo.pool;\r\n        return poolTokenContract.validPool(tranchedPool);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenID\",\"type\":\"uint256\"}],\"name\":\"getPurchaseInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"discountAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protcolAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operatorAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct TestContract.PurchaseInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isValidPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TestContract", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://784bca6ec36420561ca50e037f55b4cdf3b6e66a0ea14261c84a592fb619162d"}]}