{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nenum DepositActionType {\r\n    // No deposit action\r\n    None,\r\n    // Deposit asset cash, depositActionAmount is specified in asset cash external precision\r\n    DepositAsset,\r\n    // Deposit underlying tokens that are mintable to asset cash, depositActionAmount is specified in underlying token\r\n    // external precision\r\n    DepositUnderlying,\r\n    // Deposits specified asset cash external precision amount into an nToken and mints the corresponding amount of\r\n    // nTokens into the account\r\n    DepositAssetAndMintNToken,\r\n    // Deposits specified underlying in external precision, mints asset cash, and uses that asset cash to mint nTokens\r\n    DepositUnderlyingAndMintNToken,\r\n    // Redeems an nToken balance to asset cash. depositActionAmount is specified in nToken precision. Considered a deposit action\r\n    // because it deposits asset cash into an account. If there are fCash residuals that cannot be sold off, will revert.\r\n    RedeemNToken,\r\n    // Converts specified amount of asset cash balance already in Notional to nTokens. depositActionAmount is specified in\r\n    // Notional internal 8 decimal precision.\r\n    ConvertCashToNToken\r\n}\r\n\r\nenum TradeActionType {\r\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 minImpliedRate, uint120 unused)\r\n    Lend, \r\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 maxImpliedRate, uint128 unused)\r\n    Borrow,\r\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 assetCashAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\r\n    AddLiquidity,\r\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 tokenAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\r\n    RemoveLiquidity,\r\n    // (uint8 TradeActionType, uint32 Maturity, int88 fCashResidualAmount, uint128 unused)\r\n    PurchaseNTokenResidual,\r\n    // (uint8 TradeActionType, address CounterpartyAddress, int88 fCashAmountToSettle)\r\n    SettleCashDebt\r\n}\r\n\r\n/// @dev Market object as represented in memory\r\nstruct MarketParameters {\r\n    bytes32 storageSlot;\r\n    uint256 maturity;  //\u5230\u671f\u65e5\r\n    // Total amount of fCash available for purchase in the market.\r\n    int256 totalfCash;  \r\n    // Total amount of cash available for purchase in the market.\r\n    int256 totalAssetCash;\r\n    // Total amount of liquidity tokens (representing a claim on liquidity) in the market.\r\n    int256 totalLiquidity;\r\n    // This is the previous annualized interest rate in RATE_PRECISION that the market traded\r\n    // at. This is used to calculate the rate anchor to smooth interest rates over time.\r\n    \r\n    uint256 lastImpliedRate; //fcash\u7684\u5151\u6362\u7387\r\n    // Time lagged version of lastImpliedRate, used to value fCash assets at market rates while\r\n    // remaining resistent to flash loan attacks.\r\n\r\n    //lastImpliedRate\u7684\u65f6\u6ede\u7248\u672c\uff0c\u7528\u4e8e\u4ee5\u5e02\u573a\u5229\u7387\u5bf9fCash\u8d44\u4ea7\u8fdb\u884c\u4f30\u503c\uff0c\u540c\u65f6\u4fdd\u6301\u5bf9\u95ea\u7535\u8d37\u6b3e\u653b\u51fb\u7684\u62b5\u6297\u529b\u3002\r\n    uint256 oracleRate;\r\n\r\n    // This is the timestamp of the previous trade\r\n    uint256 previousTradeTime;\r\n}\r\n\r\ninterface AssetRateAdapter {\r\n    function token() external view returns (address);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function description() external view returns (string memory);\r\n\r\n    function version() external view returns (uint256);\r\n\r\n    function underlying() external view returns (address);\r\n\r\n    function getExchangeRateStateful() external returns (int256);\r\n\r\n    function getExchangeRateView() external view returns (int256);\r\n\r\n    function getAnnualizedSupplyRate() external view returns (uint256);\r\n}\r\n\r\ninterface AggregatorInterface {\r\n  function latestAnswer() external view returns (int256);\r\n  function latestTimestamp() external view returns (uint256);\r\n  function latestRound() external view returns (uint256);\r\n  function getAnswer(uint256 roundId) external view returns (int256);\r\n  function getTimestamp(uint256 roundId) external view returns (uint256);\r\n\r\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\r\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface{\r\n\r\n}\r\n\r\n\r\ninterface Notional {\r\n\r\n\t//\u5f97\u5230\u7528\u6237cash\u4f59\u989d \u6ce8\u610f\u662fctoken!!!!\r\n\tfunction getAccountBalance(uint16 currencyId, address account) external view returns (\r\n            int256 cashBalance,\r\n            int256 nTokenBalance,\r\n            uint256 lastClaimTime\r\n    );\r\n\r\n\tfunction getRateStorage(uint16 currencyId) external view returns (ETHRateStorage memory ethRate, AssetRateStorage memory assetRate);\r\n   \r\n    \r\n\tfunction getAccountContext(address account) external view returns (AccountContext memory);\r\n    \r\n\tfunction settleAccount(address account) external returns (AccountContext memory);\r\n\r\n\tfunction getfCashAmountGivenCashAmount(uint16 currencyId,int88 netCashToAccount,uint256 marketIndex,uint256 blockTime) external view returns (int256);\r\n\r\n\tfunction batchBalanceAndTradeAction(address account, BalanceActionWithTrades[] calldata actions) external payable;\r\n        \r\n\tfunction initializeMarkets(uint16 currencyId, bool isFirstInit) external;\r\n    \r\n}\r\n\r\ninterface ICERC20 {\r\n    function transfer(address dst, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);  \r\n}\r\n\r\nstruct AssetRateParameters {\r\n    // Address of the asset rate oracle\r\n    AssetRateAdapter rateOracle;\r\n    // The exchange rate from base to quote (if invert is required it is already done)\r\n    int256 rate;//\u4ece\u5e95\u5c42\u8d44\u4ea7\u5230\u5408\u6210\u8d44\u4ea7\u7684\u6c47\u7387\uff08\u5982\u679c\u9700\u8981\u53cd\u8f6c\uff0c\u5219\u5df2\u5b8c\u6210\uff09\r\n    // The decimals of the underlying, the rate converts to the underlying decimals\r\n    int256 underlyingDecimals; //\u5e95\u5c42\u8d44\u4ea7\u7684\u7cbe\u5ea6\uff0c\u8f6c\u6362\u4e3a\u5e95\u5c42\u8d44\u4ea7\u7684\u6bd4\u5217\r\n}\r\n\r\nstruct AccountContext {\r\n    // Used to check when settlement must be triggered on an account\r\n    //\u4e0b\u4e00\u6b21\u7ed3\u7b97\u65f6\u95f4\r\n    uint40 nextSettleTime;\r\n    // For lenders that never incur debt, we use this flag to skip the free collateral check.\r\n    //\u662f\u5426\u6709\u8fc7\u8d37\u6b3e\r\n    bytes1 hasDebt;\r\n    // Length of the account's asset array\r\n    // \u7528\u6237\u8d44\u4ea7\u6570\u91cf\r\n    uint8 assetArrayLength;\r\n    // If this account has bitmaps set, this is the corresponding currency id\r\n    //  \u672a\u77e5\r\n    uint16 bitmapCurrencyId;\r\n    //  \u672a\u77e5\r\n    // 9 total active currencies possible (2 bytes each)\r\n    bytes18 activeCurrencies;\r\n}\r\n\r\nenum AssetStorageState {NoChange, Update, Delete, RevertIfStored}\r\n\r\nstruct PortfolioAsset {\r\n    // Asset currency id\r\n    uint256 currencyId;\r\n    uint256 maturity; //\u5230\u671f\u65e5\r\n    // Asset type, fCash or liquidity token.\r\n    uint256 assetType; //\u8d44\u4ea7\u7c7b\u578b\uff0c\u6709LT \u4e5f\u6709fcash\r\n    // fCash amount or liquidity token amount\r\n    int256 notional;      //\u8d44\u4ea7\u6570\u91cf\uff0c\u6709\u6b63\u6570\u6709\u8d1f\u6570\r\n    // Used for managing portfolio asset state\r\n    uint256 storageSlot;\r\n    // The state of the asset for when it is written to storage\r\n    AssetStorageState storageState;\r\n}\r\n\r\nstruct BalanceActionWithTrades {\r\n\tDepositActionType actionType;\r\n\tuint16 currencyId;\r\n\tuint256 depositActionAmount;\r\n\tuint256 withdrawAmountInternalPrecision;\r\n\tbool withdrawEntireCashBalance;\r\n\tbool redeemToUnderlying;\r\n\t// Array of tightly packed 32 byte objects that represent trades. See TradeActionType documentation\r\n\tbytes32[] trades;\r\n}\r\n\r\n\r\n/// @notice In memory ETH exchange rate used during free collateral calculation.\r\nstruct ETHRate {\r\n    // The decimals (i.e. 10^rateDecimalPlaces) of the exchange rate, defined by the rate oracle\r\n    int256 rateDecimals;\r\n    // The exchange rate from base to ETH (if rate invert is required it is already done)\r\n    int256 rate;\r\n    // Amount of buffer as a multiple with a basis of 100 applied to negative balances.\r\n    int256 buffer;\r\n    // Amount of haircut as a multiple with a basis of 100 applied to positive balances\r\n    int256 haircut;\r\n    // Liquidation discount as a multiple with a basis of 100 applied to the exchange rate\r\n    // as an incentive given to liquidators.\r\n    int256 liquidationDiscount;\r\n}\r\n\r\nenum TokenType {UnderlyingToken, cToken, cETH, Ether, NonMintable}\r\n\r\n/// @notice Internal object that represents a token\r\nstruct Token {\r\n    address tokenAddress;\r\n    bool hasTransferFee;\r\n    int256 decimals;\r\n    TokenType tokenType;\r\n    uint256 maxCollateralBalance;\r\n}\r\n\r\n/// @dev Exchange rate object as it is represented in storage, total storage is 25 bytes.\r\nstruct ETHRateStorage {\r\n    // Address of the rate oracle\r\n    AggregatorV2V3Interface rateOracle;\r\n    // The decimal places of precision that the rate oracle uses\r\n    uint8 rateDecimalPlaces;\r\n    // True of the exchange rate must be inverted\r\n    bool mustInvert;\r\n    // NOTE: both of these governance values are set with BUFFER_DECIMALS precision\r\n    // Amount of buffer to apply to the exchange rate for negative balances.\r\n    uint8 buffer;\r\n    // Amount of haircut to apply to the exchange rate for positive balances\r\n    uint8 haircut;\r\n    // Liquidation discount in percentage point terms, 106 means a 6% discount\r\n    uint8 liquidationDiscount;\r\n}\r\n\r\n/// @dev Asset rate oracle object as it is represented in storage, total storage is 21 bytes.\r\nstruct AssetRateStorage {\r\n    // Address of the rate oracle\r\n    AssetRateAdapter rateOracle;\r\n    // The decimal places of the underlying asset\r\n    uint8 underlyingDecimalPlaces;\r\n}\r\n\r\n\r\n\r\nlibrary SafeInt256 {\r\n    int256 private constant _INT256_MIN = type(int256).min;\r\n\r\n    \r\n    function mul(int256 a, int256 b) internal pure returns (int256 c) {\r\n        c = a * b;\r\n        if (a == -1) require (b == 0 || c / b == a);\r\n        else require (a == 0 || c / a == b);\r\n    }\r\n\r\n   \r\n    function div(int256 a, int256 b) internal pure returns (int256 c) {\r\n        require(!(b == -1 && a == _INT256_MIN)); // dev: int256 div overflow\r\n        // NOTE: solidity will automatically revert on divide by zero\r\n        c = a / b;\r\n    }\r\n \r\n}\r\n\r\ncontract Owner {\r\n\r\n    address private owner;\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier isOwner() {\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor() {\r\n        owner = msg.sender; // 'msg.sender' is sender of current call, contract deployer for a constructor\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public isOwner {\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\ncontract settle  is Owner  {\r\n\tuint256 internal constant DAY = 86400;\r\n    // We use six day weeks to ensure that all time references divide evenly\r\n    uint256 internal constant WEEK = DAY * 6;\r\n    uint256 internal constant MONTH = WEEK * 5;\r\n    uint256 internal constant QUARTER = MONTH * 3;\r\n\r\n\taddress constant NotionalAddress = 0x1344A36A1B56144C3Bc62E7757377D288fDE0369;\r\n\tusing SafeInt256 for int256;\r\n\r\n\tconstructor(){\r\n\t\t\r\n\t}\r\n\r\n\t\r\n\tfunction convertToUnderlying(uint16 currencyId,int256 assetBalance) public view returns (int256) {\r\n\r\n\t\t(,AssetRateStorage memory assetRate) = Notional(NotionalAddress).getRateStorage(currencyId);\r\n\r\n\t\tint256 rate = AssetRateAdapter(assetRate.rateOracle).getExchangeRateView(); //\u4ece\u5916\u90e8\u5730\u5740\u83b7\u53d6\u5151\u6362\u7387 ctoken\u4e0e\u5e95\u5c42\u8d44\u4ea7\u7684\u5151\u6362\u7387\r\n\r\n        // Calculation here represents:\r\n        // rate * balance * internalPrecision / rateDecimals * underlyingPrecision\r\n        int256 underlyingBalance = rate\r\n            .mul(assetBalance)\r\n            .div(1e10)\r\n            .div(int256(uint256(assetRate.underlyingDecimalPlaces)));\r\n\r\n        return underlyingBalance;\r\n    }\r\n\r\n\t//marketIndex \u4e3a\u8981\u5151\u6362\u7684\u5e02\u573a\uff0c\u8fd9\u91cc\u5343\u4e07\u6ce8\u610f \u56e0\u4e3a\u4e0b\u4e2a\u5e02\u573a\u4f1a\u53d8\u5316\r\n\t//cashBalance\u4e3a\u8d1f\u6570,fcashAmount\u4e3a\u8d1f\u6570\r\n\tfunction getPayCashAndFcash(address account,uint16 currencyId,uint256 marketIndex) public view  returns(int256 ,int256) {\r\n\t\t//\u5728\u8fd9\u4e4b\u524d\u5e02\u573a\u5fc5\u987b\u8981\u8fdb\u884c\u521d\u59cb\u5316\t\r\n\t\tint256 fcashAmount = 0;\r\n\r\n\t\tuint256 blockTime = block.timestamp;\r\n\t\t(int256 cashBalanceAsset,,) = Notional(NotionalAddress).getAccountBalance(currencyId,account);\r\n\t\tif(cashBalanceAsset >= 0) { //\u5df2\u7ecf\u88ab\u7ed3\u7b97\u8fc7\u4e86\r\n\t\t\treturn (cashBalanceAsset,fcashAmount);  //\u8fd9\u91cc\u5c31\u4e0d\u7ee7\u7eed\u8f6c\u6362\u6210\u5e95\u5c42\u8d44\u4ea7\u4e86,\u56e0\u4e3a\u5df2\u7ecf\u4e0d\u9700\u8981\u7ed3\u7b97\u4e86\r\n\t\t}\r\n\r\n\t\t//\u6ce8\u610fcashBalanceAsset\u662fctoken,\u8fd9\u91cc\u505a\u4e00\u6b21\u8f6c\u6362\r\n\t\tint256 cashBalance = convertToUnderlying(currencyId,cashBalanceAsset);\r\n\r\n\t\t//\u6ce8\u610ffcashAmount\u7684\u7b26\u53f7,\u8fd9\u91cccashBalance\u4e3a\u8d1f\u6570 fcashAmount\u5c31\u4e3a\u6b63\u6570\u3002\u5982\u679c\u4f20\u9519\u4e86\u6ed1\u70b9\u5c31\u4f1a\u6ed1\u5411\u76f8\u53cd\u7684\u65b9\u5411\uff0c\u4e0e\u5b9e\u9645\u60c5\u51b5\u4e0d\u7b26\r\n\t\t//\u6240\u4ee5\u8981\u4f20\u5165\u8d1f\u6570 \u6700\u7ec8\u7ed3\u679cfcash\u4e3a\u8d1f\u6570\u3002\u8fd9\u91cc\u8868\u793a\u7528\u6237\u8981\u5f97\u5230\u6b63\u7684cash,\u8d26\u6237\u4f1a\u7d2f\u8ba1\u591a\u5c11\u8d1f\u7684fcash\r\n\t\t//\u6b64\u5904\u7684\u542b\u4e49\u662f\u7ed3\u7b97\u4eba\u4e3a\u4e86\u5e2e\u52a9 \u6b20\u6b3e\u4eba \u7ed3\u7b97 \u9700\u8981\u4ed8\u51facashBalance\u7684\u8d44\u91d1\uff0c\u4ece\u800c\u81ea\u5df1\u9700\u8981\u4ece\u5e02\u573a\u4e0a\u501f\u591a\u5c11fcash\r\n\t\tfcashAmount = Notional(NotionalAddress).getfCashAmountGivenCashAmount(currencyId,int88(-cashBalance),marketIndex,blockTime);\r\n\r\n\t\t//\u56e0\u4e3a\u6700\u7ec8\u5f97\u5230\u6b63\u7684fcash\u4f1a\u7a0d\u5fae\u6709\u76c8\u4f59\uff0c\u6240\u4ee5\u8fd9\u91cc\u53ef\u4ee5\u9002\u5f53\u589e\u52a0fcash\u7684\u6570\u91cf\r\n\r\n\t\treturn (cashBalance,fcashAmount);\r\n\t}\r\n\r\n\tfunction executeTradesByMultiUser(address[] memory accounts,uint16 currencyId,uint256 maturity) isOwner external {\r\n\t\t//\u5224\u65ad\u65f6\u95f4\u662f\u5426\u5230\u4e86\u53ef\u4ee5\u521d\u59cb\u5316\u4e0e\u6e05\u7b97\u7684\u65f6\u5019, maturity\u4e3a\u5230\u671f\u65e5\r\n\t\tuint256 blockTime = block.timestamp;\r\n\t\trequire(blockTime >= maturity,\"please settle later\");\r\n\t\t//\u5224\u65ad\u5e02\u573a\u662f\u5426\u9700\u8981\u521d\u59cb\u5316. \u8fd9\u4e2a\u5fc5\u987b\u5728getPayCashAndFcash \u4e4b\u524d\r\n\t\t_initMaketIfRequired(currencyId);\r\n\r\n\t\tfor (uint i = 0; i < accounts.length; i++) {\r\n\t\t\t_executeTrade(accounts[i],currencyId);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction executeTradesBySingleUser(address account,uint16 currencyId,uint256 maturity) isOwner external {\r\n\t\t//\u5224\u65ad\u65f6\u95f4\u662f\u5426\u5230\u4e86\u53ef\u4ee5\u521d\u59cb\u5316\u4e0e\u6e05\u7b97\u7684\u65f6\u5019, maturity\u4e3a\u5230\u671f\u65e5\r\n\t\tuint256 blockTime = block.timestamp;\r\n\t\trequire(blockTime >= maturity,\"please settle later\");\r\n\t\t//\u5224\u65ad\u5e02\u573a\u662f\u5426\u9700\u8981\u521d\u59cb\u5316. \u8fd9\u4e2a\u5fc5\u987b\u5728getPayCashAndFcash \u4e4b\u524d\r\n\t\t_initMaketIfRequired(currencyId);\r\n\r\n\t\t_executeTrade(account,currencyId);\r\n\t}\r\n\r\n\t//\u7528\u6765\u4e0e\u5408\u7ea6\u8fdb\u884c\u4ea4\u4e92, \u65b9\u4fbf\u540e\u7eed\u63d0\u6b3e.\r\n\tfunction executeTradesBatch(BalanceActionWithTrades[] memory tradeBatch) isOwner external {\r\n\t\tNotional(NotionalAddress).batchBalanceAndTradeAction(address(this),tradeBatch);\r\n\t}\r\n\r\n\tfunction ERC20Transfer(address token,address to,uint256 amount) isOwner external {\r\n        ICERC20(token).transfer(to,amount);\r\n    }\r\n\r\n    function ERC20TransferFrom(address token,address to,uint256 amount) isOwner external {\r\n        ICERC20(token).transferFrom(address(this),to,amount);\r\n    }\r\n\r\n\tfunction ETHTransfer() isOwner external {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n\r\n\t//\u7ed3\u7b97\u5355\u4e2a\u7528\u6237\r\n\tfunction _executeTrade(address account,uint16 currencyId) internal {\r\n\t\t\r\n\t\t//\u5f97\u5230\u662f\u5426\u9700\u8981\u7ed3\u7b97\r\n\t\t_settleAccountIfRequired(account);\r\n\r\n\t\tuint256 marketIndex = 1; //\u8fd9\u91ccmarketIndex\u6c38\u8fdc\u662f1,\u8868\u793a\u5728\u5e02\u573a\u521d\u59cb\u5316\u4e4b\u540e\u7684 \u7b2c\u4e00\u4e2a\u5e02\u573a\r\n\r\n        //\u8fd9\u91ccfcashAmount\u4e5f\u4e3a\u8d1f\u6570\r\n\t\t(int256 cashBalance,int256 fcashAmount) = getPayCashAndFcash(account,currencyId,marketIndex);\r\n\r\n\t\tif(cashBalance >= 0){ //\u5df2\u7ecf\u88ab\u7ed3\u7b97\u4e86\r\n\t\t\treturn ;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\tbytes memory tradeBorrowItem = new bytes(32);\r\n\t\ttradeBorrowItem = abi.encodePacked(uint8(TradeActionType.Borrow),uint8(marketIndex),uint88(uint256(-fcashAmount)),uint32(0));\r\n\t\t\r\n\t\r\n\r\n\t\tbytes memory tradeSettleItem = new bytes(32);\r\n\t\ttradeSettleItem = abi.encodePacked(uint8(TradeActionType.SettleCashDebt),account,uint88(0));\r\n\t\t\r\n\t\t\r\n\t\tbytes32[] memory trades = new bytes32[](2);\r\n\t\t\r\n\t\ttrades[0] = _bytesToBytes32(tradeBorrowItem);\r\n\t\ttrades[1] = _bytesToBytes32(tradeSettleItem);\r\n\t\t\r\n\t\tBalanceActionWithTrades memory tradeItem = BalanceActionWithTrades(\r\n\t\t\tDepositActionType.None,\r\n\t\t\tcurrencyId,\r\n\t\t\t0, //depositActionAmount\r\n\t\t\t0,//withdrawAmountInternalPrecision \u63d0\u6b3e\u6570\u91cf\r\n\t\t\tfalse,//withdrawEntireCashBalance \u662f\u5426\u5c06cash\u5168\u90e8\u63d0\u51fa ;\r\n\t\t\tfalse,//redeemToUnderlying \u662f\u5426\u8d4e\u56de\u5e95\u5c42\u8d44\u4ea7\r\n\t\t\t// Array of tightly packed 32 byte objects that represent trades. See TradeActionType documentation\r\n\t\t\ttrades\r\n\t\t);\r\n\t\t\r\n\t\tBalanceActionWithTrades[] memory tradeBatch = new BalanceActionWithTrades[](1);\r\n\t\ttradeBatch[0] = tradeItem;\r\n\r\n\t\tNotional(NotionalAddress).batchBalanceAndTradeAction(address(this),tradeBatch);\r\n\r\n\t}\r\n\r\n\tfunction _settleAccountIfRequired(address account) internal {\r\n\t\tuint256 blockTime = block.timestamp;\r\n\r\n\t\tAccountContext memory accContext = Notional(NotionalAddress).getAccountContext(account);\r\n\t\tbool mustSettle =  0 < accContext.nextSettleTime && accContext.nextSettleTime <= blockTime;\r\n\r\n\t\tif (mustSettle) { //\u5f00\u59cb\u7ed3\u7b97\r\n\t\t\tNotional(NotionalAddress).settleAccount(account);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _getReferenceTime(uint256 blockTime) internal pure returns (uint256) {\r\n        require(blockTime >= QUARTER);\r\n        return blockTime - (blockTime % QUARTER);\r\n    }\r\n\r\n\t//\u67e5\u770b\u662f\u5426\u9700\u8981\u521d\u59cb\u5316\r\n\tfunction _initMaketIfRequired(uint16 currencyId) internal {\r\n\t\tuint256 blockTime = block.timestamp;\r\n\t\tuint256 threeMonthMaturity = _getReferenceTime(blockTime) + QUARTER;\r\n\t\t//(bool ok,bytes memory returndata) =   address(notional).staticcall(abi.encodeWithSignature(\"getMarket(uint16,uint256,uint256)\",currencyId,maturity,settlementDate)) ;\r\n      \t(bool success,bytes memory returndata) = address(NotionalAddress).staticcall(abi.encodeWithSignature(\"getMarket(uint16,uint256,uint256)\",currencyId,threeMonthMaturity,threeMonthMaturity));\r\n\r\n        MarketParameters   memory market ;\r\n        \r\n        if(success){\r\n            ( market) =  abi.decode(returndata,(MarketParameters))  ;\r\n            if(market.oracleRate==0){\r\n                Notional(NotionalAddress).initializeMarkets(currencyId,false);\r\n            }\r\n        }else{\r\n            Notional(NotionalAddress).initializeMarkets(currencyId,false);\r\n        }\r\n\r\n\t} \r\n\r\n\t//\u8f6c\u6362\r\n\tfunction _bytesToBytes32(bytes memory source) internal pure returns (bytes32 result) {\r\n        if (source.length == 0) {\r\n            return 0x0;\r\n        }\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n     }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20Transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20TransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETHTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"int256\",\"name\":\"assetBalance\",\"type\":\"int256\"}],\"name\":\"convertToUnderlying\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum DepositActionType\",\"name\":\"actionType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"depositActionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmountInternalPrecision\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withdrawEntireCashBalance\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"redeemToUnderlying\",\"type\":\"bool\"},{\"internalType\":\"bytes32[]\",\"name\":\"trades\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct BalanceActionWithTrades[]\",\"name\":\"tradeBatch\",\"type\":\"tuple[]\"}],\"name\":\"executeTradesBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"}],\"name\":\"executeTradesByMultiUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"}],\"name\":\"executeTradesBySingleUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"marketIndex\",\"type\":\"uint256\"}],\"name\":\"getPayCashAndFcash\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "settle", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://036d7f3e723c7d303754abcfb8e34391b7fd4ab1f4f12073a32ce77abeca4466"}]}