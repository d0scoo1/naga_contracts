{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.4;\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n\ninterface ICodex {\n    function init(address vault) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address,\n        bytes32,\n        uint256\n    ) external;\n\n    function credit(address) external view returns (uint256);\n\n    function unbackedDebt(address) external view returns (uint256);\n\n    function balances(\n        address,\n        uint256,\n        address\n    ) external view returns (uint256);\n\n    function vaults(address vault)\n        external\n        view\n        returns (\n            uint256 totalNormalDebt,\n            uint256 rate,\n            uint256 debtCeiling,\n            uint256 debtFloor\n        );\n\n    function positions(\n        address vault,\n        uint256 tokenId,\n        address position\n    ) external view returns (uint256 collateral, uint256 normalDebt);\n\n    function globalDebt() external view returns (uint256);\n\n    function globalUnbackedDebt() external view returns (uint256);\n\n    function globalDebtCeiling() external view returns (uint256);\n\n    function delegates(address, address) external view returns (uint256);\n\n    function grantDelegate(address) external;\n\n    function revokeDelegate(address) external;\n\n    function modifyBalance(\n        address,\n        uint256,\n        address,\n        int256\n    ) external;\n\n    function transferBalance(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function transferCredit(\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function modifyCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function transferCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function confiscateCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function settleUnbackedDebt(uint256 debt) external;\n\n    function createUnbackedDebt(\n        address debtor,\n        address creditor,\n        uint256 debt\n    ) external;\n\n    function modifyRate(\n        address vault,\n        address creditor,\n        int256 rate\n    ) external;\n\n    function lock() external;\n}// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\ninterface IDebtAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function tokenToSellBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function aer() external view returns (address);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(\n        address recipient,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock() external;\n\n    function cancelAuction(uint256 id) external;\n}interface ISurplusAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(uint256 creditToSell, uint256 bid) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 creditToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock(uint256 credit) external;\n\n    function cancelAuction(uint256 id) external;\n}\n\ninterface IAer {\n    function codex() external view returns (ICodex);\n\n    function surplusAuction() external view returns (ISurplusAuction);\n\n    function debtAuction() external view returns (IDebtAuction);\n\n    function debtQueue(uint256) external view returns (uint256);\n\n    function queuedDebt() external view returns (uint256);\n\n    function debtOnAuction() external view returns (uint256);\n\n    function auctionDelay() external view returns (uint256);\n\n    function debtAuctionSellSize() external view returns (uint256);\n\n    function debtAuctionBidSize() external view returns (uint256);\n\n    function surplusAuctionSellSize() external view returns (uint256);\n\n    function surplusBuffer() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function queueDebt(uint256 debt) external;\n\n    function unqueueDebt(uint256 queuedAt) external;\n\n    function settleDebtWithSurplus(uint256 debt) external;\n\n    function settleAuctionedDebt(uint256 debt) external;\n\n    function startDebtAuction() external returns (uint256 auctionId);\n\n    function startSurplusAuction() external returns (uint256 auctionId);\n\n    function transferCredit(address to, uint256 credit) external;\n\n    function lock() external;\n}\ninterface IGuarded {\n    function ANY_SIG() external view returns (bytes32);\n\n    function ANY_CALLER() external view returns (address);\n\n    function allowCaller(bytes32 sig, address who) external;\n\n    function blockCaller(bytes32 sig, address who) external;\n\n    function canCall(bytes32 sig, address who) external view returns (bool);\n}\n/// @title Guarded\n/// @notice Mixin implementing an authentication scheme on a method level\nabstract contract Guarded is IGuarded {\n    /// ======== Custom Errors ======== ///\n\n    error Guarded__notRoot();\n    error Guarded__notGranted();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Wildcard for granting a caller to call every guarded method\n    bytes32 public constant override ANY_SIG = keccak256(\"ANY_SIG\");\n    /// @notice Wildcard for granting a caller to call every guarded method\n    address public constant override ANY_CALLER = address(uint160(uint256(bytes32(keccak256(\"ANY_CALLER\")))));\n\n    /// @notice Mapping storing who is granted to which method\n    /// @dev Method Signature => Caller => Bool\n    mapping(bytes32 => mapping(address => bool)) private _canCall;\n\n    /// ======== Events ======== ///\n\n    event AllowCaller(bytes32 sig, address who);\n    event BlockCaller(bytes32 sig, address who);\n\n    constructor() {\n        // set root\n        _setRoot(msg.sender);\n    }\n\n    /// ======== Auth ======== ///\n\n    modifier callerIsRoot() {\n        if (_canCall[ANY_SIG][msg.sender]) {\n            _;\n        } else revert Guarded__notRoot();\n    }\n\n    modifier checkCaller() {\n        if (canCall(msg.sig, msg.sender)) {\n            _;\n        } else revert Guarded__notGranted();\n    }\n\n    /// @notice Grant the right to call method `sig` to `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should be able to call `sig`\n    function allowCaller(bytes32 sig, address who) public override callerIsRoot {\n        _canCall[sig][who] = true;\n        emit AllowCaller(sig, who);\n    }\n\n    /// @notice Revoke the right to call method `sig` from `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should not be able to call `sig` anymore\n    function blockCaller(bytes32 sig, address who) public override callerIsRoot {\n        _canCall[sig][who] = false;\n        emit BlockCaller(sig, who);\n    }\n\n    /// @notice Returns if `who` can call `sig`\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should be able to call `sig`\n    function canCall(bytes32 sig, address who) public view override returns (bool) {\n        return (_canCall[sig][who] || _canCall[ANY_SIG][who] || _canCall[sig][ANY_CALLER]);\n    }\n\n    /// @notice Sets the root user (granted `ANY_SIG`)\n    /// @param root Address of who should be set as root\n    function _setRoot(address root) internal {\n        _canCall[ANY_SIG][root] = true;\n        emit AllowCaller(ANY_SIG, root);\n    }\n\n    /// @notice Unsets the root user (granted `ANY_SIG`)\n    /// @param root Address of who should be unset as root\n    function _unsetRoot(address root) internal {\n        _canCall[ANY_SIG][root] = false;\n        emit AllowCaller(ANY_SIG, root);\n    }\n}// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n\nuint256 constant MLN = 10**6;\nuint256 constant BLN = 10**9;\nuint256 constant WAD = 10**18;\nuint256 constant RAY = 10**18;\nuint256 constant RAD = 10**18;\n\n/* solhint-disable func-visibility, no-inline-assembly */\n\nerror Math__toInt256_overflow(uint256 x);\n\nfunction toInt256(uint256 x) pure returns (int256) {\n    if (x > uint256(type(int256).max)) revert Math__toInt256_overflow(x);\n    return int256(x);\n}\n\nfunction min(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x <= y ? x : y;\n    }\n}\n\nfunction max(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x >= y ? x : y;\n    }\n}\n\nerror Math__diff_overflow(uint256 x, uint256 y);\n\nfunction diff(uint256 x, uint256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) - int256(y);\n        if (!(int256(x) >= 0 && int256(y) >= 0)) revert Math__diff_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow(uint256 x, uint256 y);\n\nfunction add(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add_overflow(x, y);\n    }\n}\n\nerror Math__add48_overflow(uint256 x, uint256 y);\n\nfunction add48(uint48 x, uint48 y) pure returns (uint48 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add48_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow_signed(uint256 x, int256 y);\n\nfunction add(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x + uint256(y);\n        if (!(y >= 0 || z <= x)) revert Math__add_overflow_signed(x, y);\n        if (!(y <= 0 || z >= x)) revert Math__add_overflow_signed(x, y);\n    }\n}\n\nerror Math__sub_overflow(uint256 x, uint256 y);\n\nfunction sub(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x - y) > x) revert Math__sub_overflow(x, y);\n    }\n}\n\nerror Math__sub_overflow_signed(uint256 x, int256 y);\n\nfunction sub(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x - uint256(y);\n        if (!(y <= 0 || z <= x)) revert Math__sub_overflow_signed(x, y);\n        if (!(y >= 0 || z >= x)) revert Math__sub_overflow_signed(x, y);\n    }\n}\n\nerror Math__mul_overflow(uint256 x, uint256 y);\n\nfunction mul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (!(y == 0 || (z = x * y) / y == x)) revert Math__mul_overflow(x, y);\n    }\n}\n\nerror Math__mul_overflow_signed(uint256 x, int256 y);\n\nfunction mul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) * y;\n        if (int256(x) < 0) revert Math__mul_overflow_signed(x, y);\n        if (!(y == 0 || z / y == int256(x))) revert Math__mul_overflow_signed(x, y);\n    }\n}\n\nfunction wmul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, y) / WAD;\n    }\n}\n\nfunction wmul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = mul(x, y) / int256(WAD);\n    }\n}\n\nerror Math__div_overflow(uint256 x, uint256 y);\n\nfunction div(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (y == 0) revert Math__div_overflow(x, y);\n        return x / y;\n    }\n}\n\nfunction wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, WAD) / y;\n    }\n}\n\n// optimized version from dss PR #78\nfunction wpow(\n    uint256 x,\n    uint256 n,\n    uint256 b\n) pure returns (uint256 z) {\n    unchecked {\n        assembly {\n            switch n\n            case 0 {\n                z := b\n            }\n            default {\n                switch x\n                case 0 {\n                    z := 0\n                }\n                default {\n                    switch mod(n, 2)\n                    case 0 {\n                        z := b\n                    }\n                    default {\n                        z := x\n                    }\n                    let half := div(b, 2) // for rounding.\n                    for {\n                        n := div(n, 2)\n                    } n {\n                        n := div(n, 2)\n                    } {\n                        let xx := mul(x, x)\n                        if shr(128, x) {\n                            revert(0, 0)\n                        }\n                        let xxRound := add(xx, half)\n                        if lt(xxRound, xx) {\n                            revert(0, 0)\n                        }\n                        x := div(xxRound, b)\n                        if mod(n, 2) {\n                            let zx := mul(z, x)\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                                revert(0, 0)\n                            }\n                            let zxRound := add(zx, half)\n                            if lt(zxRound, zx) {\n                                revert(0, 0)\n                            }\n                            z := div(zxRound, b)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/* solhint-disable func-visibility, no-inline-assembly */\n/// @title Aer (short for Aerarium)\n/// @notice `Aer` is used for managing the protocol's debt and surplus balances via the DebtAuction and\n/// SurplusAuction contracts.\n/// Uses Vow.sol from DSS (MakerDAO) / AccountingEngine.sol from GEB (Reflexer Labs) as a blueprint\n/// Changes from Vow.sol / AccountingEngine.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\ncontract Aer is Guarded, IAer {\n    /// ======== Custom Errors ======== ///\n\n    error Aer__setParam_unrecognizedParam();\n    error Aer__unqueueDebt_auctionDelayNotPassed();\n    error Aer__settleDebtWithSurplus_insufficientSurplus();\n    error Aer__settleDebtWithSurplus_insufficientDebt();\n    error Aer__settleAuctionedDebt_notEnoughDebtOnAuction();\n    error Aer__settleAuctionedDebt_insufficientSurplus();\n    error Aer__startDebtAuction_insufficientDebt();\n    error Aer__startDebtAuction_surplusNotZero();\n    error Aer__startSurplusAuction_insufficientSurplus();\n    error Aer__startSurplusAuction_debtNotZero();\n    error Aer__transferCredit_insufficientCredit();\n    error Aer__lock_notLive();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Codex\n    ICodex public immutable override codex;\n    /// @notice SurplusAuction\n    ISurplusAuction public override surplusAuction;\n    /// @notice DebtAuction\n    IDebtAuction public override debtAuction;\n\n    /// @notice List of debt amounts to be auctioned sorted by the time at which they where queued\n    /// @dev Queued at timestamp => Debt [wad]\n    mapping(uint256 => uint256) public override debtQueue;\n    /// @notice Queued debt amount [wad]\n    uint256 public override queuedDebt;\n    /// @notice Amount of debt currently on auction [wad]\n    uint256 public override debtOnAuction;\n\n    /// @notice Time after which queued debt can be put up for auction [seconds]\n    uint256 public override auctionDelay;\n    /// @notice Amount of tokens to sell in each debt auction [wad]\n    uint256 public override debtAuctionSellSize;\n    /// @notice Min. amount of (credit to bid or debt to sell) for tokens [wad]\n    uint256 public override debtAuctionBidSize;\n\n    /// @notice Amount of credit to sell in each surplus auction [wad]\n    uint256 public override surplusAuctionSellSize;\n    /// @notice Amount of credit required for starting a surplus auction [wad]\n    uint256 public override surplusBuffer;\n\n    /// @notice Boolean indicating if this contract is live (0 - not live, 1 - live)\n    uint256 public override live;\n\n    /// ======== Events ======== ///\n    event SetParam(bytes32 indexed param, uint256 data);\n    event SetParam(bytes32 indexed param, address indexed data);\n    event QueueDebt(uint256 indexed queuedAt, uint256 debtQueue, uint256 queuedDebt);\n    event UnqueueDebt(uint256 indexed queuedAt, uint256 queuedDebt);\n    event StartDebtAuction(uint256 debtOnAuction, uint256 indexed auctionId);\n    event SettleAuctionedDebt(uint256 debtOnAuction);\n    event StartSurplusAuction(uint256 indexed auctionId);\n    event SettleDebtWithSurplus(uint256 debt);\n    event Lock();\n\n    constructor(\n        address codex_,\n        address surplusAuction_,\n        address debtAuction_\n    ) Guarded() {\n        codex = ICodex(codex_);\n        surplusAuction = ISurplusAuction(surplusAuction_);\n        debtAuction = IDebtAuction(debtAuction_);\n        ICodex(codex_).grantDelegate(surplusAuction_);\n        live = 1;\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (param == \"auctionDelay\") auctionDelay = data;\n        else if (param == \"surplusAuctionSellSize\") surplusAuctionSellSize = data;\n        else if (param == \"debtAuctionBidSize\") debtAuctionBidSize = data;\n        else if (param == \"debtAuctionSellSize\") debtAuctionSellSize = data;\n        else if (param == \"surplusBuffer\") surplusBuffer = data;\n        else revert Aer__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(bytes32 param, address data) external override checkCaller {\n        if (param == \"surplusAuction\") {\n            codex.revokeDelegate(address(surplusAuction));\n            surplusAuction = ISurplusAuction(data);\n            codex.grantDelegate(data);\n        } else if (param == \"debtAuction\") debtAuction = IDebtAuction(data);\n        else revert Aer__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// ======== Debt Auction ======== ///\n\n    /// @notice Pushes new debt to the debt queue\n    /// @dev Sender has to be allowed to call this method\n    /// @param debt Amount of debt [wad]\n    function queueDebt(uint256 debt) external override checkCaller {\n        debtQueue[block.timestamp] = add(debtQueue[block.timestamp], debt);\n        queuedDebt = add(queuedDebt, debt);\n        emit QueueDebt(block.timestamp, debtQueue[block.timestamp], queuedDebt);\n    }\n\n    /// @notice Pops debt from the debt queue\n    /// @param queuedAt Timestamp at which the debt has been queued [seconds]\n    function unqueueDebt(uint256 queuedAt) external override {\n        if (add(queuedAt, auctionDelay) > block.timestamp) revert Aer__unqueueDebt_auctionDelayNotPassed();\n        queuedDebt = sub(queuedDebt, debtQueue[queuedAt]);\n        debtQueue[queuedAt] = 0;\n        emit UnqueueDebt(queuedAt, queuedDebt);\n    }\n\n    /// @notice Starts a debt auction\n    /// @dev Sender has to be allowed to call this method\n    /// Checks if enough debt exists to be put up for auction\n    /// debtAuctionBidSize > (unbackedDebt - queuedDebt - debtOnAuction)\n    /// @return auctionId Id of the debt auction\n    function startDebtAuction() external override checkCaller returns (uint256 auctionId) {\n        if (debtAuctionBidSize > sub(sub(codex.unbackedDebt(address(this)), queuedDebt), debtOnAuction))\n            revert Aer__startDebtAuction_insufficientDebt();\n        if (codex.credit(address(this)) != 0) revert Aer__startDebtAuction_surplusNotZero();\n        debtOnAuction = add(debtOnAuction, debtAuctionBidSize);\n        auctionId = debtAuction.startAuction(address(this), debtAuctionSellSize, debtAuctionBidSize);\n        emit StartDebtAuction(debtOnAuction, auctionId);\n    }\n\n    /// @notice Settles debt collected from debt auctions\n    /// @dev Cannot settle debt with accrued surplus (only from debt auctions)\n    /// @param debt Amount of debt to settle [wad]\n    function settleAuctionedDebt(uint256 debt) external override {\n        if (debt > debtOnAuction) revert Aer__settleAuctionedDebt_notEnoughDebtOnAuction();\n        if (debt > codex.credit(address(this))) revert Aer__settleAuctionedDebt_insufficientSurplus();\n        debtOnAuction = sub(debtOnAuction, debt);\n        codex.settleUnbackedDebt(debt);\n        emit SettleAuctionedDebt(debtOnAuction);\n    }\n\n    /// ======== Surplus Auction ======== ///\n\n    /// @notice Starts a surplus auction\n    /// @dev Sender has to be allowed to call this method\n    /// Checks if enough surplus has accrued (surplusAuctionSellSize + surplusBuffer) and there's\n    /// no queued debt to be put up for a debt auction\n    /// @return auctionId Id of the surplus auction\n    function startSurplusAuction() external override checkCaller returns (uint256 auctionId) {\n        if (\n            codex.credit(address(this)) <\n            add(add(codex.unbackedDebt(address(this)), surplusAuctionSellSize), surplusBuffer)\n        ) revert Aer__startSurplusAuction_insufficientSurplus();\n        if (sub(sub(codex.unbackedDebt(address(this)), queuedDebt), debtOnAuction) != 0)\n            revert Aer__startSurplusAuction_debtNotZero();\n        auctionId = surplusAuction.startAuction(surplusAuctionSellSize, 0);\n        emit StartSurplusAuction(auctionId);\n    }\n\n    /// @notice Settles debt with the accrued surplus\n    /// @dev Sender has to be allowed to call this method\n    /// Can not settle more debt than there's unbacked debt and which is not expected\n    /// to be settled via debt auctions (queuedDebt + debtOnAuction)\n    /// @param debt Amount of debt to settle [wad]\n    function settleDebtWithSurplus(uint256 debt) external override checkCaller {\n        if (debt > codex.credit(address(this))) revert Aer__settleDebtWithSurplus_insufficientSurplus();\n        if (debt > sub(sub(codex.unbackedDebt(address(this)), queuedDebt), debtOnAuction))\n            revert Aer__settleDebtWithSurplus_insufficientDebt();\n        codex.settleUnbackedDebt(debt);\n        emit SettleDebtWithSurplus(debt);\n    }\n\n    /// @notice Transfer accrued credit surplus to another account\n    /// @dev Can only transfer backed credit out of Aer\n    /// @param credit Amount of debt to settle [wad]\n    function transferCredit(address to, uint256 credit) external override checkCaller {\n        if (credit > sub(codex.credit(address(this)), codex.unbackedDebt(address(this))))\n            revert Aer__transferCredit_insufficientCredit();\n        codex.transferCredit(address(this), to, credit);\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Locks the contract\n    /// @dev Sender has to be allowed to call this method\n    /// Wipes queued debt and debt on auction, locks DebtAuction and SurplusAuction and\n    /// settles debt with what it has available\n    function lock() external override checkCaller {\n        if (live == 0) revert Aer__lock_notLive();\n        live = 0;\n        queuedDebt = 0;\n        debtOnAuction = 0;\n        surplusAuction.lock(codex.credit(address(surplusAuction)));\n        debtAuction.lock();\n        codex.settleUnbackedDebt(min(codex.credit(address(this)), codex.unbackedDebt(address(this))));\n        emit Lock();\n    }\n}\ninterface IGuard {\n    function isGuard() external view returns (bool);\n}\ncontract Delayed {\n    error Delayed__setParam_notDelayed();\n    error Delayed__delay_invalidEta();\n    error Delayed__execute_unknown();\n    error Delayed__execute_stillDelayed();\n    error Delayed__execute_executionError();\n\n    mapping(bytes32 => bool) public queue;\n    uint256 public delay;\n\n    event SetParam(bytes32 param, uint256 data);\n    event Queue(address target, bytes data, uint256 eta);\n    event Unqueue(address target, bytes data, uint256 eta);\n    event Execute(address target, bytes data, uint256 eta);\n\n    constructor(uint256 delay_) {\n        delay = delay_;\n        emit SetParam(\"delay\", delay_);\n    }\n\n    function _setParam(bytes32 param, uint256 data) internal {\n        if (param == \"delay\") delay = data;\n        emit SetParam(param, data);\n    }\n\n    function _delay(\n        address target,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        if (eta < block.timestamp + delay) revert Delayed__delay_invalidEta();\n        queue[keccak256(abi.encode(target, data, eta))] = true;\n        emit Queue(target, data, eta);\n    }\n\n    function _skip(\n        address target,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        queue[keccak256(abi.encode(target, data, eta))] = false;\n        emit Unqueue(target, data, eta);\n    }\n\n    function execute(\n        address target,\n        bytes calldata data,\n        uint256 eta\n    ) external returns (bytes memory out) {\n        bytes32 callHash = keccak256(abi.encode(target, data, eta));\n\n        if (!queue[callHash]) revert Delayed__execute_unknown();\n        if (block.timestamp < eta) revert Delayed__execute_stillDelayed();\n\n        queue[callHash] = false;\n\n        bool ok;\n        (ok, out) = target.call(data);\n        if (!ok) revert Delayed__execute_executionError();\n\n        emit Execute(target, data, eta);\n    }\n}\nabstract contract BaseGuard is Delayed, IGuard {\n    /// ======== Custom Errors ======== ///\n\n    error BaseGuard__isSenatus_notSenatus();\n    error BaseGuard__isGuardian_notGuardian();\n    error BaseGuard__isDelayed_notSelf(address, address);\n    error BaseGuard__inRange_notInRange();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Address of the DAO\n    address public senatus;\n    /// @notice Address of the guardian\n    address public guardian;\n\n    constructor(\n        address senatus_,\n        address guardian_,\n        uint256 delay\n    ) Delayed(delay) {\n        senatus = senatus_;\n        guardian = guardian_;\n    }\n\n    modifier isSenatus() {\n        if (msg.sender != senatus) revert BaseGuard__isSenatus_notSenatus();\n        _;\n    }\n\n    modifier isGuardian() {\n        if (msg.sender != guardian) revert BaseGuard__isGuardian_notGuardian();\n        _;\n    }\n\n    modifier isDelayed() {\n        if (msg.sender != address(this)) revert BaseGuard__isDelayed_notSelf(msg.sender, address(this));\n        _;\n    }\n\n    /// @notice Callback method which allows Guard to check if he has sufficient rights over the corresponding contract\n    /// @return bool True if he has sufficient rights\n    function isGuard() external view virtual override returns (bool);\n\n    /// @notice Updates the address of senatus\n    /// @dev Can only be called by Senatus\n    /// @param senatus_ Address of the new senatus\n    function setSenatus(address senatus_) external isSenatus {\n        senatus = senatus_;\n    }\n\n    /// @notice Updates the address of the guardian\n    /// @dev Can only be called by Senatus\n    /// @param guardian_ Address of the new guardian\n    function setGuardian(address guardian_) external isSenatus {\n        guardian = guardian_;\n    }\n\n    /// ======== Capabilities ======== ///\n\n    /// @notice Updates the time which has to elapse for certain parameter updates\n    /// @dev Can only be called by Senatus\n    /// @param delay Time which has to elapse before parameter can be updated [seconds]\n    function setDelay(uint256 delay) external isSenatus {\n        _setParam(\"delay\", delay);\n    }\n\n    /// @notice Schedule method call for methods which have to be delayed\n    /// @dev Can only be called by the guardian\n    /// @param data Call data\n    function schedule(bytes calldata data) external isGuardian {\n        _delay(address(this), data, block.timestamp + delay);\n    }\n\n    /// ======== Helper Methods ======== ///\n\n    /// @notice Checks if `value` is at least equal to `min_` or at most equal to `max`\n    /// @dev Revers if check failed\n    /// @param value Value to check\n    /// @param min_ Min. value for `value`\n    /// @param max Max. value for `value`\n    function _inRange(\n        uint256 value,\n        uint256 min_,\n        uint256 max\n    ) internal pure {\n        if (max < value || value < min_) revert BaseGuard__inRange_notInRange();\n    }\n}\n/// @title AerGuard\n/// @notice Contract which guards parameter updates for `Aer`\ncontract AerGuard is BaseGuard {\n    /// ======== Custom Errors ======== ///\n\n    error AerGuard__isGuard_cantCall();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Address of Aer\n    Aer public immutable aer;\n\n    constructor(\n        address senatus,\n        address guardian,\n        uint256 delay,\n        address aer_\n    ) BaseGuard(senatus, guardian, delay) {\n        aer = Aer(aer_);\n    }\n\n    /// @notice See `BaseGuard`\n    function isGuard() external view override returns (bool) {\n        if (!aer.canCall(aer.ANY_SIG(), address(this))) revert AerGuard__isGuard_cantCall();\n        return true;\n    }\n\n    /// ======== Capabilities ======== ///\n\n    /// @notice Sets the `auctionDelay` parameter on Aer\n    /// @dev Can only be called by the guardian. Checks if the value is in the allowed range.\n    /// @param auctionDelay See. Aer\n    function setAuctionDelay(uint256 auctionDelay) external isGuardian {\n        _inRange(auctionDelay, 0, 7 days);\n        aer.setParam(\"auctionDelay\", auctionDelay);\n    }\n\n    /// @notice Sets the `surplusAuctionSellSize` parameter on Aer\n    /// @dev Can only be called by the guardian. Checks if the value is in the allowed range.\n    /// @param surplusAuctionSellSize See. Aer\n    function setSurplusAuctionSellSize(uint256 surplusAuctionSellSize) external isGuardian {\n        _inRange(surplusAuctionSellSize, 0, 200_000 * WAD);\n        aer.setParam(\"surplusAuctionSellSize\", surplusAuctionSellSize);\n    }\n\n    /// @notice Sets the `debtAuctionBidSize` parameter on Aer\n    /// @dev Can only be called by the guardian. Checks if the value is in the allowed range.\n    /// @param debtAuctionBidSize See. Aer\n    function setDebtAuctionBidSize(uint256 debtAuctionBidSize) external isGuardian {\n        _inRange(debtAuctionBidSize, 0, 200_000 * WAD);\n        aer.setParam(\"debtAuctionBidSize\", debtAuctionBidSize);\n    }\n\n    /// @notice Sets the `debtAuctionSellSize` parameter on Aer\n    /// @dev Can only be called by the guardian. Checks if the value is in the allowed range.\n    /// @param debtAuctionSellSize See. Aer\n    function setDebtAuctionSellSize(uint256 debtAuctionSellSize) external isGuardian {\n        _inRange(debtAuctionSellSize, 0, 200_000 * WAD);\n        aer.setParam(\"debtAuctionSellSize\", debtAuctionSellSize);\n    }\n\n    /// @notice Sets the `surplusBuffer` parameter on Aer\n    /// @dev Can only be called by the guardian. Checks if the value is in the allowed range.\n    /// @param surplusBuffer See. Aer\n    function setSurplusBuffer(uint256 surplusBuffer) external isGuardian {\n        _inRange(surplusBuffer, 0, 1_000_000 * WAD);\n        aer.setParam(\"surplusBuffer\", surplusBuffer);\n    }\n\n    /// @notice Sets the `surplusAuction` parameter on Aer after the `delay` has passed.\n    /// @dev Can only be called by the guardian. After `delay` has passed it can be `execute`'d.\n    /// @param surplusAuction See. Aer\n    function setSurplusAuction(address surplusAuction) external isDelayed {\n        aer.setParam(\"surplusAuction\", surplusAuction);\n    }\n\n    /// @notice Sets the `debtAuction` parameter on Aer after the `delay` has passed.\n    /// @dev Can only be called by the guardian. After `delay` has passed it can be `execute`'d.\n    /// @param debtAuction See. Aer\n    function setDebtAuction(address debtAuction) external isDelayed {\n        aer.setParam(\"debtAuction\", debtAuction);\n    }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"senatus\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"aer_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AerGuard__isGuard_cantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseGuard__inRange_notInRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"BaseGuard__isDelayed_notSelf\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseGuard__isGuardian_notGuardian\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseGuard__isSenatus_notSenatus\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Delayed__delay_invalidEta\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Delayed__execute_executionError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Delayed__execute_stillDelayed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Delayed__execute_unknown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Delayed__setParam_notDelayed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"Execute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"Queue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"param\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"SetParam\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"Unqueue\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"aer\",\"outputs\":[{\"internalType\":\"contract Aer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"eta\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"out\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGuard\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"queue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"schedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"senatus\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionDelay\",\"type\":\"uint256\"}],\"name\":\"setAuctionDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"debtAuction\",\"type\":\"address\"}],\"name\":\"setDebtAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"debtAuctionBidSize\",\"type\":\"uint256\"}],\"name\":\"setDebtAuctionBidSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"debtAuctionSellSize\",\"type\":\"uint256\"}],\"name\":\"setDebtAuctionSellSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"setDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guardian_\",\"type\":\"address\"}],\"name\":\"setGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"senatus_\",\"type\":\"address\"}],\"name\":\"setSenatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"surplusAuction\",\"type\":\"address\"}],\"name\":\"setSurplusAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"surplusAuctionSellSize\",\"type\":\"uint256\"}],\"name\":\"setSurplusAuctionSellSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"surplusBuffer\",\"type\":\"uint256\"}],\"name\":\"setSurplusBuffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AerGuard", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "8000", "ConstructorArguments": "000000000000000000000000a55e0d3d697c4692e9c37bc3a7062b1beceef45b000000000000000000000000245bd99c7379df6740332d06530da7dedb062d61000000000000000000000000000000000000000000000000000000000002a30000000000000000000000000019b3ccb3d4493acb9fa4bc7a1ec99b906a32ae72", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}