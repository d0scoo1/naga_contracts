{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AGStakeFull.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/IAGStakeFull.sol\\\";\\r\\nimport \\\"./interfaces/IAlphaGangGenerative.sol\\\";\\r\\nimport \\\"./interfaces/IAlphaGangOG.sol\\\";\\r\\nimport \\\"./interfaces/IGangToken.sol\\\";\\r\\n\\r\\ncontract AGStakeX is IAGStake, Ownable, ERC721Holder, ERC1155Holder {\\r\\n    // address to timestamp of last update\\r\\n    mapping(address => uint256) public lastUpdate;\\r\\n\\r\\n    IAlphaGangOG immutable AlphaGangOG;\\r\\n    IAlphaGangGenerative AlphaGangG2;\\r\\n    IGangToken immutable GANG;\\r\\n\\r\\n    // maps OG tokenId to mapping of address to count of staked tokens\\r\\n    mapping(uint256 => mapping(address => uint256)) public vaultOG;\\r\\n\\r\\n    // Mapping: address to token to staked timestamp\\r\\n    mapping(address => mapping(uint256 => uint256)) public override vaultG2;\\r\\n\\r\\n    /**\\r\\n     * token ID to staked at timestamp or 0 if token is not staked\\r\\n     * Note 1 is more gas optimal than 0 for unstaked state but we won't expect too many of these changes\\r\\n     */\\r\\n    mapping(address => uint256) public stakedAtG2;\\r\\n\\r\\n    // Mapping: address to count of tokens staked\\r\\n    mapping(address => uint256) public ownerG2StakedCount;\\r\\n\\r\\n    /**\\r\\n     * mapping of address to timestamp when last OG was staked\\r\\n     * Note This offers less granular controll of staking tokens at a benefit of less complexity/gas savings\\r\\n     */\\r\\n    mapping(address => uint256) stakedAtOG;\\r\\n\\r\\n    // OG rate 300 per week\\r\\n    uint256 public ogStakeRate = 496031746031746;\\r\\n    // G2 rate 30 per week\\r\\n    uint256 public G2StakeRate = 49603174603175;\\r\\n    // Bonus base for holding OG tokens\\r\\n    uint256 bonusBase = 500_000;\\r\\n    // Bonus for holding all 3 kind of OG tokens\\r\\n    uint256 triBonus = 100_000;\\r\\n\\r\\n    uint256 constant BASE = 1_000_000;\\r\\n\\r\\n    mapping(address => uint256) public override ogAllocation;\\r\\n\\r\\n    constructor(\\r\\n        IAlphaGangOG _og,\\r\\n        IAlphaGangGenerative _G2,\\r\\n        IGangToken _token\\r\\n    ) {\\r\\n        AlphaGangOG = _og;\\r\\n        AlphaGangG2 = _G2;\\r\\n        GANG = _token;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Stake tokens for generative.\\r\\n     * Note This makes stakeAll obsolete, since we'd have to check every token minted to get all user tokens with ERC721A.\\r\\n     */\\r\\n    function stakeG2(uint256[] calldata tokenIds) public override {\\r\\n        uint256 timeNow = block.timestamp;\\r\\n        // for extra check both msg.sender and tx origin are correct:\\r\\n        address _owner = msg.sender;\\r\\n        if (msg.sender == address(AlphaGangG2)) {\\r\\n            _owner = tx.origin;\\r\\n        }\\r\\n\\r\\n        _claim(_owner);\\r\\n\\r\\n        for (uint8 i = 0; i < tokenIds.length; i++) {\\r\\n            // verify the ownership\\r\\n            require(\\r\\n                AlphaGangG2.ownerOf(tokenIds[i]) == _owner,\\r\\n                \\\"Not your token\\\"\\r\\n            );\\r\\n\\r\\n            require(vaultG2[_owner][tokenIds[i]] == 0, \\\"Token already staked\\\");\\r\\n\\r\\n            // stake the token for _owner\\r\\n            AlphaGangG2.transferFrom(_owner, address(this), tokenIds[i]);\\r\\n            vaultG2[_owner][tokenIds[i]] = timeNow;\\r\\n        }\\r\\n        // update lastStake time for _owner\\r\\n        // stakedAtG2[_owner] = timeNow;\\r\\n        unchecked {\\r\\n            ownerG2StakedCount[_owner] += tokenIds.length;\\r\\n        }\\r\\n\\r\\n        emit StakedG2(_owner, tokenIds, timeNow);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Unstake tokens for generative.\\r\\n     *\\r\\n     * @param tokenIds Array of tokens to unstake\\r\\n     */\\r\\n    function unstakeG2(uint256[] memory tokenIds) external {\\r\\n        address _owner = msg.sender;\\r\\n        _claim(_owner);\\r\\n\\r\\n        for (uint8 i = 0; i < tokenIds.length; ++i) {\\r\\n            require(vaultG2[_owner][tokenIds[i]] > 0, \\\"Not your token\\\");\\r\\n            require(\\r\\n                vaultG2[_owner][tokenIds[i]] < block.timestamp + 72 hours,\\r\\n                \\\"Token locked for 3 days\\\"\\r\\n            );\\r\\n            vaultG2[_owner][tokenIds[i]] = 0;\\r\\n\\r\\n            AlphaGangG2.transferFrom(address(this), _owner, tokenIds[i]);\\r\\n        }\\r\\n\\r\\n        ownerG2StakedCount[_owner] -= tokenIds.length;\\r\\n\\r\\n        emit UnstakedG2(_owner, tokenIds, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function claim() external {\\r\\n        _claim(msg.sender);\\r\\n    }\\r\\n\\r\\n    function claimForAddress(address account) external {\\r\\n        _claim(account);\\r\\n    }\\r\\n\\r\\n    function _claim(address account) internal {\\r\\n        uint256 earned;\\r\\n\\r\\n        // if there is no last update just set the first timestamp for address\\r\\n        if (lastUpdate[account] > 0) {\\r\\n            earned = earningInfo(account);\\r\\n        }\\r\\n\\r\\n        lastUpdate[account] = block.timestamp;\\r\\n\\r\\n        if (earned > 0) {\\r\\n            GANG.mint(account, earned);\\r\\n        }\\r\\n\\r\\n        emit Claimed(account, earned, block.timestamp);\\r\\n    }\\r\\n\\r\\n    // Check how much tokens account has for claiming\\r\\n    function earningInfo(address account) public view returns (uint256 earned) {\\r\\n        uint256 earnedWBonus;\\r\\n        uint256 earnedNBonus;\\r\\n\\r\\n        uint256 timestamp = block.timestamp;\\r\\n        uint256 _lastUpdate = lastUpdate[account];\\r\\n\\r\\n        // no earnings so far\\r\\n        if (_lastUpdate == 0) return 0;\\r\\n\\r\\n        uint256 tokenCountOG;\\r\\n\\r\\n        uint256[] memory stakedCountOG = stakedOGBalanceOf(account);\\r\\n\\r\\n        // bonus is applied for holding all 3 assets(can only be applied once)\\r\\n        uint256 triBonusCount;\\r\\n        unchecked {\\r\\n            for (uint32 i; i < 3; ++i) {\\r\\n                if (stakedCountOG[i] > 0) {\\r\\n                    tokenCountOG += stakedCountOG[i];\\r\\n                    ++triBonusCount;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 bonus = BASE; // multiplier of 1\\r\\n\\r\\n        unchecked {\\r\\n            // add G2 tokens to bonusBase\\r\\n            earnedWBonus += G2StakeRate * ownerG2StakedCount[account]; // count of owners tokens times rate for G2\\r\\n\\r\\n            // Calculate bonus to be applied\\r\\n            if (tokenCountOG > 0) {\\r\\n                // Order: 50, Mac, Riri, bonus is halved by 50% for each additional token\\r\\n                uint256 _bonusBase = bonusBase;\\r\\n\\r\\n                // Add a single token to bonusBase\\r\\n                earnedWBonus += ogStakeRate;\\r\\n                // Add rest to noBonusBase\\r\\n                earnedNBonus += ogStakeRate * (tokenCountOG - 1);\\r\\n\\r\\n                // calculate total bonus to be applied, start adding bonus for more hodls\\r\\n                for (uint32 i = 0; i < tokenCountOG; ++i) {\\r\\n                    bonus += _bonusBase;\\r\\n                    _bonusBase /= 2;\\r\\n                }\\r\\n\\r\\n                // triBonus for holding all 3 OGs\\r\\n                if (triBonusCount == 3) {\\r\\n                    bonus += triBonus;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // calculate and return how much is earned\\r\\n        return\\r\\n            (((earnedWBonus * bonus) / BASE) + earnedNBonus) *\\r\\n            (timestamp - _lastUpdate);\\r\\n    }\\r\\n\\r\\n    /** OG Functions */\\r\\n    function stakeSingleOG(uint256 tokenId, uint256 tokenCount) external {\\r\\n        address _owner = msg.sender;\\r\\n\\r\\n        // claim unstaked tokens, since count/rate will change\\r\\n        _claim(_owner);\\r\\n\\r\\n        AlphaGangOG.safeTransferFrom(\\r\\n            _owner,\\r\\n            address(this),\\r\\n            tokenId,\\r\\n            tokenCount,\\r\\n            \\\"\\\"\\r\\n        );\\r\\n\\r\\n        stakedAtOG[_owner] = block.timestamp;\\r\\n\\r\\n        unchecked {\\r\\n            vaultOG[tokenId][_owner] += tokenCount;\\r\\n        }\\r\\n\\r\\n        emit StakedOG(\\r\\n            _owner,\\r\\n            _asSingletonArray(tokenId),\\r\\n            _asSingletonArray(tokenCount),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function unstakeSingleOG(uint256 tokenId, uint256 tokenCount) external {\\r\\n        address _owner = msg.sender;\\r\\n        uint256 _totalStaked = vaultOG[tokenId][_owner];\\r\\n\\r\\n        require(\\r\\n            _totalStaked >= 0,\\r\\n            \\\"You do have any tokens available for unstaking\\\"\\r\\n        );\\r\\n        require(\\r\\n            _totalStaked >= tokenCount,\\r\\n            \\\"You do not have requested token amount available for unstaking\\\"\\r\\n        );\\r\\n        require(\\r\\n            stakedAtOG[_owner] < block.timestamp + 72 hours,\\r\\n            \\\"Tokens locked for 3 days\\\"\\r\\n        );\\r\\n\\r\\n        // claim rewards before unstaking\\r\\n        _claim(_owner);\\r\\n\\r\\n        unchecked {\\r\\n            vaultOG[tokenId][_owner] -= tokenCount;\\r\\n        }\\r\\n\\r\\n        AlphaGangOG.safeTransferFrom(\\r\\n            address(this),\\r\\n            _owner,\\r\\n            tokenId,\\r\\n            tokenCount,\\r\\n            \\\"\\\"\\r\\n        );\\r\\n\\r\\n        emit UnstakedOG(\\r\\n            msg.sender,\\r\\n            _asSingletonArray(tokenId),\\r\\n            _asSingletonArray(tokenCount),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function updateOGAllocation(address _owner, uint256 _count)\\r\\n        external\\r\\n        override\\r\\n    {\\r\\n        require(msg.sender == address(AlphaGangG2), \\\"Only Generative\\\");\\r\\n        ogAllocation[_owner] -= _count;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev\\r\\n     *\\r\\n     * Note this will stake all available tokens, but makes it possible to not immediately stake G2 tokens (@Hax)\\r\\n     */\\r\\n    function stakeOGForMint() external payable {\\r\\n        // check if OG minting is active\\r\\n        require(AlphaGangG2.mintActive(1), \\\"Sale is not active\\\");\\r\\n\\r\\n        address _owner = msg.sender;\\r\\n        uint256[] memory totalAvailable = unstakedOGBalanceOf(_owner);\\r\\n\\r\\n        // get the count of tokens\\r\\n        uint256 _totalOGsToBeStaked = totalAvailable[0] +\\r\\n            totalAvailable[1] +\\r\\n            totalAvailable[2];\\r\\n        // make sure there are tokens to be staked\\r\\n        require(_totalOGsToBeStaked > 0, \\\"No tokens to stake\\\");\\r\\n\\r\\n        /**\\r\\n         * Ammount of eth is sent to G2 contract, but checked here first\\r\\n         * all OG get 2 tokens for WL + one additional for each token staked\\r\\n         * in addition whales(3+ tokens) get reduced price\\r\\n         */\\r\\n        uint256 g2MintCount = _totalOGsToBeStaked + 2;\\r\\n\\r\\n        uint256 timeNow = block.timestamp;\\r\\n\\r\\n        uint256[] memory tokens = new uint256[](3);\\r\\n        tokens[0] = 1;\\r\\n        tokens[1] = 2;\\r\\n        tokens[2] = 3;\\r\\n\\r\\n        // claim and update the timestamp for this account\\r\\n        _claim(_owner);\\r\\n\\r\\n        AlphaGangOG.safeBatchTransferFrom(\\r\\n            _owner,\\r\\n            address(this),\\r\\n            tokens,\\r\\n            totalAvailable,\\r\\n            \\\"\\\"\\r\\n        );\\r\\n\\r\\n        // Update stake time\\r\\n        stakedAtOG[_owner] = timeNow;\\r\\n\\r\\n        ogAllocation[_owner] += g2MintCount;\\r\\n\\r\\n        // loop over and update the vault\\r\\n        unchecked {\\r\\n            for (uint32 i = 1; i < 4; i++) {\\r\\n                vaultOG[i][_owner] += totalAvailable[i - 1];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit StakedForMint(msg.sender, tokens, totalAvailable, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Stakes all OG tokens of {_owner} by transfering them to this contract.\\r\\n     *\\r\\n     * Emits a {StakedOG} event.\\r\\n     */\\r\\n    function stakeAllOG() external {\\r\\n        address _owner = msg.sender;\\r\\n        uint256[] memory totalAvailable = unstakedOGBalanceOf(_owner);\\r\\n\\r\\n        // claim for owner\\r\\n        _claim(_owner);\\r\\n\\r\\n        uint256[] memory tokens = new uint256[](3);\\r\\n        tokens[0] = 1;\\r\\n        tokens[1] = 2;\\r\\n        tokens[2] = 3;\\r\\n\\r\\n        AlphaGangOG.safeBatchTransferFrom(\\r\\n            _owner,\\r\\n            address(this),\\r\\n            tokens,\\r\\n            totalAvailable,\\r\\n            \\\"\\\"\\r\\n        );\\r\\n\\r\\n        // Update stake time\\r\\n        stakedAtOG[_owner] = block.timestamp;\\r\\n\\r\\n        // loop over and update the vault\\r\\n        unchecked {\\r\\n            for (uint32 i = 1; i < 4; i++) {\\r\\n                vaultOG[i][_owner] += totalAvailable[i - 1];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit StakedOG(msg.sender, tokens, totalAvailable, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function unstakeAllOG() external {\\r\\n        address _owner = msg.sender;\\r\\n        require(\\r\\n            stakedAtOG[_owner] < block.timestamp + 72 hours,\\r\\n            \\\"Tokens locked for 3 days\\\"\\r\\n        );\\r\\n\\r\\n        // claim for owner\\r\\n        _claim(_owner);\\r\\n\\r\\n        uint256[] memory _totalStaked = stakedOGBalanceOf(_owner);\\r\\n\\r\\n        uint256[] memory tokens = new uint256[](3);\\r\\n        tokens[0] = 1;\\r\\n        tokens[1] = 2;\\r\\n        tokens[2] = 3;\\r\\n\\r\\n        // loop over and update the vault\\r\\n        unchecked {\\r\\n            for (uint32 i = 1; i < 4; i++) {\\r\\n                vaultOG[i][_owner] -= _totalStaked[i - 1];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        AlphaGangOG.safeBatchTransferFrom(\\r\\n            address(this),\\r\\n            _owner,\\r\\n            tokens,\\r\\n            _totalStaked,\\r\\n            \\\"\\\"\\r\\n        );\\r\\n\\r\\n        emit UnstakedOG(_owner, tokens, _totalStaked, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /** Views */\\r\\n    function stakedOGBalanceOf(address account)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256[] memory _tokenBalance)\\r\\n    {\\r\\n        uint256[] memory tokenBalance = new uint256[](3);\\r\\n\\r\\n        unchecked {\\r\\n            for (uint32 i = 1; i < 4; i++) {\\r\\n                uint256 stakedCount = vaultOG[i][account];\\r\\n                if (stakedCount > 0) {\\r\\n                    tokenBalance[i - 1] += stakedCount;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return tokenBalance;\\r\\n    }\\r\\n\\r\\n    function unstakedOGBalanceOf(address account)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256[] memory _tokenBalance)\\r\\n    {\\r\\n        // This consumes ~4k gas less than batchBalanceOf with address array\\r\\n        uint256[] memory totalTokenBalance = new uint256[](3);\\r\\n        totalTokenBalance[0] = AlphaGangOG.balanceOf(account, 1);\\r\\n        totalTokenBalance[1] = AlphaGangOG.balanceOf(account, 2);\\r\\n        totalTokenBalance[2] = AlphaGangOG.balanceOf(account, 3);\\r\\n\\r\\n        return totalTokenBalance;\\r\\n    }\\r\\n\\r\\n    /** Utils */\\r\\n    function _asSingletonArray(uint256 element)\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256[] memory)\\r\\n    {\\r\\n        uint256[] memory array = new uint256[](1);\\r\\n        array[0] = element;\\r\\n\\r\\n        return array;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev\\r\\n     * (@Hax) Migrate feature in case we need to manage tokens\\r\\n     * Eg. someone sends token to staking contract directly or we need to migrate\\r\\n     *\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        AlphaGangG2.setApprovalForAll(operator, approved);\\r\\n        AlphaGangOG.setApprovalForAll(operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Withdraw any ether that might get sent/stuck on this contract\\r\\n     */\\r\\n    function withdraw() external onlyOwner {\\r\\n        payable(owner()).transfer(address(this).balance);\\r\\n    }\\r\\n\\r\\n    function stakedG2TokensOfOwner(address account)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory)\\r\\n    {\\r\\n        uint256 supply = AlphaGangG2.totalSupply();\\r\\n\\r\\n        uint256 ownerStakedTokenCount = ownerG2StakedCount[account];\\r\\n        uint256[] memory tokens = new uint256[](ownerStakedTokenCount);\\r\\n\\r\\n        uint256 index = 0;\\r\\n        for (uint256 tokenId = 1; tokenId <= supply; tokenId++) {\\r\\n            if (vaultG2[account][tokenId] > 0) {\\r\\n                tokens[index] = tokenId;\\r\\n            }\\r\\n        }\\r\\n        return tokens;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAGStakeFull.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IAGStake {\\r\\n    event StakedG2(address owner, uint256[] tokenIds, uint256 timestamp);\\r\\n    event UnstakedG2(address owner, uint256[] tokenIds, uint256 timestamp);\\r\\n    event StakedOG(\\r\\n        address owner,\\r\\n        uint256[] tokenIds,\\r\\n        uint256[] counts,\\r\\n        uint256 timestamp\\r\\n    );\\r\\n    event StakedForMint(\\r\\n        address owner,\\r\\n        uint256[] tokenIds,\\r\\n        uint256[] counts,\\r\\n        uint256 timestamp\\r\\n    );\\r\\n    event UnstakedOG(\\r\\n        address owner,\\r\\n        uint256[] tokenIds,\\r\\n        uint256[] counts,\\r\\n        uint256 timestamp\\r\\n    );\\r\\n    event Claimed(address owner, uint256 amount, uint256 timestamp);\\r\\n\\r\\n    function ogAllocation(address _owner)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 _allocation);\\r\\n\\r\\n    function vaultG2(address, uint256) external view returns (uint256);\\r\\n\\r\\n    function stakeG2(uint256[] calldata tokenIds) external;\\r\\n\\r\\n    function updateOGAllocation(address _owner, uint256 _count) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IAlphaGangGenerative.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IAlphaGangGenerative {\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function ownerOf(uint256 tokenId) external view returns (address);\\r\\n\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function SUPPLY_MAX() external view returns (uint256);\\r\\n\\r\\n    function mintActive(uint8 mintType) external view returns (bool);\\r\\n\\r\\n    function tokensOfOwner(address _owner)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory ownerTokens);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IAlphaGangOG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IAlphaGangOG {\\r\\n    function balanceOf(address account, uint256 id)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    // change to transfer\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IGangToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IGangToken {\\r\\n    function mint(address to, uint256 amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IAlphaGangOG\",\"name\":\"_og\",\"type\":\"address\"},{\"internalType\":\"contract IAlphaGangGenerative\",\"name\":\"_G2\",\"type\":\"address\"},{\"internalType\":\"contract IGangToken\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"counts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"StakedForMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"StakedG2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"counts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"StakedOG\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UnstakedG2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"counts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UnstakedOG\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"G2StakeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimForAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earningInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ogAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ogStakeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerG2StakedCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeAllOG\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"stakeG2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeOGForMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenCount\",\"type\":\"uint256\"}],\"name\":\"stakeSingleOG\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakedAtG2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"stakedG2TokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"stakedOGBalanceOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenBalance\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeAllOG\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unstakeG2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenCount\",\"type\":\"uint256\"}],\"name\":\"unstakeSingleOG\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unstakedOGBalanceOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenBalance\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"updateOGAllocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vaultG2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vaultOG\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AGStakeX", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000595a70409711f20523bd99b83d088cea9d3f92e1000000000000000000000000125808292f4bb11bf2d01b070d94e19490f7f4dc0000000000000000000000003321551494954f2bd682d2614495e365e9dffb2f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}