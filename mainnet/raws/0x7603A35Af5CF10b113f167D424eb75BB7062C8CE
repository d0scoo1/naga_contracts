{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Recipes/AuctionCreation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../Utils/SafeTransfer.sol\\\";\\n\\ninterface IMisoTokenFactory {\\n  function createToken(\\n    uint256 _templateId,\\n    address payable _integratorFeeAccount,\\n    bytes calldata _data\\n  ) external payable returns (address token);\\n}\\n\\ninterface IPointList {\\n  function deployPointList(\\n    address _listOwner,\\n    address[] calldata _accounts,\\n    uint256[] calldata _amounts\\n  ) external payable returns (address pointList);\\n}\\n\\ninterface IMisoLauncher {\\n  function createLauncher(\\n    uint256 _templateId,\\n    address _token,\\n    uint256 _tokenSupply,\\n    address payable _integratorFeeAccount,\\n    bytes calldata _data\\n  ) external payable returns (address newLauncher);\\n}\\n\\ninterface IMisoMarket {\\n  function createMarket(\\n    uint256 _templateId,\\n    address _token,\\n    uint256 _tokenSupply,\\n    address payable _integratorFeeAccount,\\n    bytes calldata _data\\n  ) external payable returns (address newMarket);\\n\\n  function setAuctionWallet(address payable _wallet) external;\\n\\n  function addAdminRole(address _address) external;\\n\\n  function getAuctionTemplate(uint256 _templateId) external view returns (address);\\n}\\n\\ninterface IAuctionTemplate {\\n  function marketTemplate() external view returns (uint256);\\n}\\n\\n// Auction Creation Recipe\\n// 1. Create Token\\n// 2. Create Whitelist (Optional)\\n// 3. Create Auction with token address and whitelist address\\n// 4. Create Liquidity Launcher with auction and token address\\n// 5. Set destination wallet of auction to liquidity launcher\\ncontract AuctionCreation is SafeTransfer {\\n  IMisoTokenFactory public misoTokenFactory;\\n  IPointList public pointListFactory;\\n  IMisoLauncher public misoLauncher;\\n  IMisoMarket public misoMarket;\\n  address public factory;\\n\\n  constructor(\\n    IMisoTokenFactory _misoTokenFactory,\\n    IPointList _pointListFactory,\\n    IMisoLauncher _misoLauncher,\\n    IMisoMarket _misoMarket,\\n    address _factory\\n  ) public {\\n    misoTokenFactory = _misoTokenFactory;\\n    pointListFactory = _pointListFactory;\\n    misoLauncher = _misoLauncher;\\n    misoMarket = _misoMarket;\\n    factory = _factory;\\n  }\\n\\n  function prepareMiso(\\n    bytes memory tokenFactoryData,\\n    address[] memory _accounts,\\n    uint256[] memory _amounts,\\n    bytes memory marketData,\\n    bytes memory launcherData\\n  ) external payable {\\n    require(_accounts.length == _amounts.length, '!len');\\n\\n    address token = createToken(tokenFactoryData);\\n\\n    address pointList = createPointList(_accounts, _amounts);\\n\\n    (address newMarket, uint256 tokenForSale) = createMarket(marketData, token, pointList);\\n\\n    // Miso market has to give admin role to the user, since it's set to this contract initially\\n    // to allow the auction wallet to be set to launcher once it's been deployed\\n    IMisoMarket(newMarket).addAdminRole(msg.sender);\\n\\n    createLauncher(launcherData, token, tokenForSale, newMarket);\\n\\n    uint256 tokenBalanceRemaining = IERC20(token).balanceOf(address(this));\\n    if (tokenBalanceRemaining > 0) {\\n      _safeTransfer(token, msg.sender, tokenBalanceRemaining);\\n    }\\n  }\\n\\n  function createToken(bytes memory tokenFactoryData) internal returns (address token) {\\n    (\\n      bool isDeployed,\\n      address deployedToken,\\n      uint256 _misoTokenFactoryTemplateId,\\n      string memory _name,\\n      string memory _symbol,\\n      uint256 _initialSupply\\n    ) = abi.decode(tokenFactoryData, (bool, address, uint256, string, string, uint256));\\n    if (isDeployed) {\\n      token = deployedToken;\\n      IERC20(deployedToken).transferFrom(msg.sender, address(this), _initialSupply);\\n    } else {\\n      token = misoTokenFactory.createToken(\\n        _misoTokenFactoryTemplateId,\\n        address(0),\\n        abi.encode(_name, _symbol, msg.sender, _initialSupply)\\n      );\\n    }\\n\\n    IERC20(token).approve(address(misoMarket), _initialSupply);\\n    IERC20(token).approve(address(misoLauncher), _initialSupply);\\n  }\\n\\n  function createPointList(address[] memory _accounts, uint256[] memory _amounts) internal returns (address pointList) {\\n    if (_accounts.length != 0) {\\n      pointList = pointListFactory.deployPointList(msg.sender, _accounts, _amounts);\\n    }\\n  }\\n\\n  function createMarket(\\n    bytes memory marketData,\\n    address token,\\n    address pointList\\n  ) internal returns (address newMarket, uint256 tokenForSale) {\\n    (uint256 _marketTemplateId, bytes memory mData) = abi.decode(marketData, (uint256, bytes));\\n\\n    tokenForSale = getTokenForSale(_marketTemplateId, mData);\\n\\n    newMarket = misoMarket.createMarket(\\n      _marketTemplateId,\\n      token,\\n      tokenForSale,\\n      address(0),\\n      abi.encodePacked(abi.encode(address(misoMarket), token), mData, abi.encode(address(this), pointList, msg.sender))\\n    );\\n  }\\n\\n  function createLauncher(\\n    bytes memory launcherData,\\n    address token,\\n    uint256 tokenForSale,\\n    address newMarket\\n  ) internal returns (address newLauncher) {\\n    (uint256 _launcherTemplateId, uint256 _liquidityPercent, uint256 _locktime) = abi.decode(\\n      launcherData,\\n      (uint256, uint256, uint256)\\n    );\\n\\n    if(_liquidityPercent > 0) {\\n      newLauncher = misoLauncher.createLauncher(\\n        _launcherTemplateId,\\n        token,\\n        (tokenForSale * _liquidityPercent) / 10000,\\n        address(0),\\n        abi.encode(newMarket, factory, msg.sender, msg.sender, _liquidityPercent, _locktime)\\n      );\\n\\n      // Have to set auction wallet to the new launcher address AFTER the market is created\\n      // new launcher address is casted to payable to satisfy interface.\\n      IMisoMarket(newMarket).setAuctionWallet(payable(newLauncher));\\n    }\\n  }\\n\\n  function getTokenForSale(uint256 marketTemplateId, bytes memory mData) internal view returns (uint256 tokenForSale) {\\n    address auctionTemplate = misoMarket.getAuctionTemplate(marketTemplateId);\\n\\n    uint256 auctionTemplateId = IAuctionTemplate(auctionTemplate).marketTemplate();\\n\\n    if (auctionTemplateId == 1) {\\n      (, tokenForSale) = abi.decode(mData, (uint256, uint256));\\n    } else {\\n      tokenForSale = abi.decode(mData, (uint256));\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Utils/SafeTransfer.sol\": {\r\n      \"content\": \"pragma solidity 0.6.12;\\n\\ncontract SafeTransfer {\\n\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @notice Event for token withdrawals.\\n    event TokensWithdrawn(address token, address to, uint256 amount);\\n\\n    /// @dev Helper function to handle both ETH and ERC20 payments\\n    function _safeTokenPayment(\\n        address _token,\\n        address payable _to,\\n        uint256 _amount\\n    ) internal {\\n        if (address(_token) == ETH_ADDRESS) {\\n            _safeTransferETH(_to,_amount );\\n        } else {\\n            _safeTransfer(_token, _to, _amount);\\n        }\\n\\n        emit TokensWithdrawn(_token, _to, _amount);\\n    }\\n\\n\\n    /// @dev Helper function to handle both ETH and ERC20 payments\\n    function _tokenPayment(\\n        address _token,\\n        address payable _to,\\n        uint256 _amount\\n    ) internal {\\n        if (address(_token) == ETH_ADDRESS) {\\n            _to.transfer(_amount);\\n        } else {\\n            _safeTransfer(_token, _to, _amount);\\n        }\\n\\n        emit TokensWithdrawn(_token, _to, _amount);\\n    }\\n\\n\\n    /// @dev Transfer helper from UniswapV2 Router\\n    function _safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n\\n    /**\\n     * There are many non-compliant ERC20 tokens... this can handle most, adapted from UniSwap V2\\n     * Im trying to make it a habit to put external calls last (reentrancy)\\n     * You can put this in an internal function if you like.\\n     */\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        // solium-disable-next-line security/no-low-level-calls\\n        (bool success, bytes memory data) =\\n            token.call(\\n                // 0xa9059cbb = bytes4(keccak256(\\\"transfer(address,uint256)\\\"))\\n                abi.encodeWithSelector(0xa9059cbb, to, amount)\\n            );\\n        require(success && (data.length == 0 || abi.decode(data, (bool)))); // ERC20 Transfer failed\\n    }\\n\\n    function _safeTransferFrom(\\n        address token,\\n        address from,\\n        uint256 amount\\n    ) internal virtual {\\n        // solium-disable-next-line security/no-low-level-calls\\n        (bool success, bytes memory data) =\\n            token.call(\\n                // 0x23b872dd = bytes4(keccak256(\\\"transferFrom(address,address,uint256)\\\"))\\n                abi.encodeWithSelector(0x23b872dd, from, address(this), amount)\\n            );\\n        require(success && (data.length == 0 || abi.decode(data, (bool)))); // ERC20 TransferFrom failed\\n    }\\n\\n    function _safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function _safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IMisoTokenFactory\",\"name\":\"_misoTokenFactory\",\"type\":\"address\"},{\"internalType\":\"contract IPointList\",\"name\":\"_pointListFactory\",\"type\":\"address\"},{\"internalType\":\"contract IMisoLauncher\",\"name\":\"_misoLauncher\",\"type\":\"address\"},{\"internalType\":\"contract IMisoMarket\",\"name\":\"_misoMarket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"misoLauncher\",\"outputs\":[{\"internalType\":\"contract IMisoLauncher\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"misoMarket\",\"outputs\":[{\"internalType\":\"contract IMisoMarket\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"misoTokenFactory\",\"outputs\":[{\"internalType\":\"contract IMisoTokenFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pointListFactory\",\"outputs\":[{\"internalType\":\"contract IPointList\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"tokenFactoryData\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"marketData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"launcherData\",\"type\":\"bytes\"}],\"name\":\"prepareMiso\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "AuctionCreation", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001be211d8da40bc0ae8719c6663307bfc987b1d6c0000000000000000000000002f686751b19a9d91cc3d57d90150bc767f050066000000000000000000000000aa26771d497814e81d305c511efbb3ced90bf5bd000000000000000000000000281bd3a3f96ae7c96049493a7ba9449df2c5b0fe000000000000000000000000c0aee478e3658e2610c5f7a4a2e1777ce9e4f2ac", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}