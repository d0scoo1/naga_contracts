{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Fodl/connectors/SetTokenURIConnector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport '../modules/FoldingAccount/FoldingAccountStorage.sol';\\nimport '../core/interfaces/IFodlNFTProvider.sol';\\nimport '../core/interfaces/IFodlNFT.sol';\\n\\ncontract SetTokenURIConnector is FoldingAccountStorage {\\n    string private constant ETH_SIGN_PREFIX = '\\\\x19Ethereum Signed Message:\\\\n32';\\n\\n    address public immutable authoriser;\\n\\n    constructor(address _authoriser) public {\\n        authoriser = _authoriser;\\n    }\\n\\n    function setTokenURI(\\n        string memory tokenURI,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external onlyAccountOwner {\\n        bytes32 h = keccak256(abi.encodePacked(ETH_SIGN_PREFIX, keccak256(abi.encodePacked(address(this), tokenURI))));\\n        require(ecrecover(h, v, r, s) == authoriser, 'Invalid authoriser signature');\\n\\n        IFodlNFT(IFodlNFTProvider(aStore().foldingRegistry).fodlNFT()).setTokenUri(tokenURI);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Fodl/modules/FoldingAccount/FoldingAccountStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ncontract FoldingAccountStorage {\\n    bytes32 constant ACCOUNT_STORAGE_POSITION = keccak256('folding.account.storage');\\n\\n    /**\\n     * entryCaller:         address of the caller of the account, during a transaction\\n     *\\n     * callbackTarget:      address of logic to be run when expecting a callback\\n     *\\n     * expectedCallbackSig: signature of function to be run when expecting a callback\\n     *\\n     * foldingRegistry      address of factory creating FoldingAccount\\n     *\\n     * nft:                 address of the nft contract.\\n     *\\n     * owner:               address of the owner of this FoldingAccount.\\n     */\\n    struct AccountStore {\\n        address entryCaller;\\n        address callbackTarget;\\n        bytes4 expectedCallbackSig;\\n        address foldingRegistry;\\n        address nft;\\n        address owner;\\n    }\\n\\n    modifier onlyAccountOwner() {\\n        AccountStore storage s = aStore();\\n        require(s.entryCaller == s.owner, 'FA2');\\n        _;\\n    }\\n\\n    modifier onlyNFTContract() {\\n        AccountStore storage s = aStore();\\n        require(s.entryCaller == s.nft, 'FA3');\\n        _;\\n    }\\n\\n    modifier onlyAccountOwnerOrRegistry() {\\n        AccountStore storage s = aStore();\\n        require(s.entryCaller == s.owner || s.entryCaller == s.foldingRegistry, 'FA4');\\n        _;\\n    }\\n\\n    function aStore() internal pure returns (AccountStore storage s) {\\n        bytes32 position = ACCOUNT_STORAGE_POSITION;\\n        assembly {\\n            s_slot := position\\n        }\\n    }\\n\\n    function accountOwner() internal view returns (address) {\\n        return aStore().owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Fodl/core/interfaces/IFodlNFTProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IFodlNFTProvider {\\n    function fodlNFT() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/Fodl/core/interfaces/IFodlNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface IFodlNFT {\\n    function setTokenUri(string memory _tokenURI) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authoriser\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"authoriser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenURI\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SetTokenURIConnector", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "0000000000000000000000007e771c0db0233f8f06361a7faa9b7637e0bd39f4", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}