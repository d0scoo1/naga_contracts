{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/protocol/integration/wrap/notional/WrappedfCash.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\nimport { wfCashERC4626 } from \\\"wrapped-fcash/contracts/wfCashERC4626.sol\\\";\\nimport { INotionalV2 } from \\\"wrapped-fcash/interfaces/notional/INotionalV2.sol\\\";\\nimport { IWETH9 } from \\\"wrapped-fcash/interfaces/IWETH9.sol\\\";\\n\\ncontract WrappedfCash is wfCashERC4626 {\\n    // Does nothing - disambiguates this contract from WrappedfCashFactory so\\n    // hardhat-etherscan can verify it.\\n    uint8 public noop;\\n    constructor(INotionalV2 _notionalProxy, IWETH9 _weth) wfCashERC4626(_notionalProxy, _weth){\\n    }\\n}\\n\"\r\n    },\r\n    \"wrapped-fcash/contracts/wfCashERC4626.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./wfCashLogic.sol\\\";\\nimport \\\"../interfaces/IERC4626.sol\\\";\\n\\ncontract wfCashERC4626 is IERC4626, wfCashLogic {\\n    constructor(INotionalV2 _notional, IWETH9 _weth) wfCashLogic(_notional, _weth) {}\\n\\n    /** @dev See {IERC4262-asset} */\\n    function asset() public view override returns (address) {\\n        (IERC20 underlyingToken, bool isETH) = getToken(true);\\n        return isETH ? address(WETH) : address(underlyingToken);\\n    }\\n\\n    function _getMaturedUnderlyingExternal() private view returns (uint256) {\\n        // If the fCash has matured we use the cash balance instead.\\n        uint16 currencyId = getCurrencyId();\\n        // We cannot settle an account in a view method, so this may fail if the account has not been settled\\n        // after maturity. This can be done by anyone so it should not be an issue\\n        (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\\n        int256 underlyingExternal = NotionalV2.convertCashBalanceToExternal(currencyId, cashBalance, true);\\n        require(underlyingExternal > 0, \\\"Must Settle\\\");\\n\\n        return uint256(underlyingExternal);\\n    }\\n\\n    /** @dev See {IERC4262-totalAssets} */\\n    function totalAssets() public view override returns (uint256) {\\n        if (hasMatured()) {\\n            return _getMaturedUnderlyingExternal();\\n        } else {\\n            (/* */, int256 precision) = getUnderlyingToken();\\n            // Get the present value of the fCash held by the contract, this is returned in 8 decimal precision\\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\\n            int256 pvInternal = NotionalV2.getPresentfCashValue(\\n                currencyId,\\n                maturity,\\n                int256(totalSupply()), // total supply cannot overflow as fCash overflows at uint88\\n                block.timestamp,\\n                false\\n            );\\n\\n            int256 pvExternal = (pvInternal * precision) / Constants.INTERNAL_TOKEN_PRECISION;\\n            // PV should always be >= 0 since we are lending\\n            require(pvExternal >= 0);\\n            return uint256(pvExternal);\\n        }\\n    }\\n\\n    /** @dev See {IERC4262-convertToShares} */\\n    function convertToShares(uint256 assets) public view override returns (uint256 shares) {\\n        if (hasMatured()) {\\n            uint256 underlyingExternal = _getMaturedUnderlyingExternal();\\n\\n            // The withdraw calculation is:\\n            // shares * cashBalance / totalSupply = cashBalanceShare\\n            //\\n            // Converting this to underlying external:\\n            // shares * convert(cashBalance) / totalSupply = underlyingExternalShare\\n            // shares * underlyingExternal / totalSupply = underlyingExternalShare\\n            // shares * underlyingExternal / totalSupply = assets\\n            // shares = (assets * totalSupply) / underlyingExternal\\n            return (assets * totalSupply()) / underlyingExternal; // uint256 overflow checked above\\n        } else {\\n            // This is how much fCash received from depositing assets\\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\\n            (uint256 fCashAmount, /* */, /* */) = NotionalV2.getfCashLendFromDeposit(\\n                currencyId,\\n                assets,\\n                maturity,\\n                0,\\n                block.timestamp,\\n                true\\n            );\\n\\n            return fCashAmount;\\n        }\\n    }\\n\\n    /** @dev See {IERC4262-convertToAssets} */\\n    function convertToAssets(uint256 shares) public view override returns (uint256 assets) {\\n        if (hasMatured()) {\\n            uint256 underlyingExternal = _getMaturedUnderlyingExternal();\\n\\n            // The withdraw calculation is:\\n            // shares * cashBalance / totalSupply = cashBalanceShare\\n            return (shares * underlyingExternal) / totalSupply(); // uint256 overflow checked above\\n        } else {\\n            // This is how much underlying it will require to lend the fCash\\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\\n            (uint256 depositAmountUnderlying, /* */, /* */, /* */) = NotionalV2.getDepositFromfCashLend(\\n                currencyId,\\n                shares,\\n                maturity,\\n                0,\\n                block.timestamp\\n            );\\n\\n            return depositAmountUnderlying;\\n        }\\n    }\\n\\n    /** @dev See {IERC4262-maxDeposit} */\\n    function maxDeposit(address) public view override returns (uint256) {\\n        return hasMatured() ? 0 : type(uint256).max;\\n    }\\n\\n    /** @dev See {IERC4262-maxMint} */\\n    function maxMint(address) public view override returns (uint256) {\\n        return hasMatured() ? 0 : type(uint88).max;\\n    }\\n\\n    /** @dev See {IERC4262-maxWithdraw} */\\n    function maxWithdraw(address owner) public view override returns (uint256) {\\n        return convertToAssets(balanceOf(owner));\\n    }\\n\\n    /** @dev See {IERC4262-maxRedeem} */\\n    function maxRedeem(address owner) public view override returns (uint256) {\\n        return balanceOf(owner);\\n    }\\n\\n    /** @dev See {IERC4262-previewDeposit} */\\n    function previewDeposit(uint256 assets) public view override returns (uint256) {\\n        require(!hasMatured(), \\\"Matured\\\");\\n        return convertToShares(assets);\\n    }\\n\\n    /** @dev See {IERC4262-previewMint} */\\n    function previewMint(uint256 shares) public view override returns (uint256) {\\n        require(!hasMatured(), \\\"Matured\\\");\\n        return convertToAssets(shares);\\n    }\\n\\n    /** @dev See {IERC4262-previewWithdraw} */\\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\\n        if (hasMatured()) {\\n            shares = convertToShares(assets);\\n        } else {\\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\\n            (shares, /* */, /* */) = NotionalV2.getfCashBorrowFromPrincipal(\\n                currencyId,\\n                assets,\\n                maturity,\\n                0,\\n                block.timestamp,\\n                true\\n            );\\n        }\\n    }\\n\\n    /** @dev See {IERC4262-previewRedeem} */\\n    function previewRedeem(uint256 shares) public view override returns (uint256 assets) {\\n        if (hasMatured()) {\\n            assets = convertToAssets(shares);\\n        } else {\\n            // If withdrawing non-matured assets, we sell them on the market (i.e. borrow)\\n            (uint16 currencyId, uint40 maturity) = getDecodedID();\\n            (assets, /* */, /* */, /* */) = NotionalV2.getPrincipalFromfCashBorrow(\\n                currencyId,\\n                shares,\\n                maturity,\\n                0,\\n                block.timestamp\\n            );\\n        }\\n    }\\n\\n    /** @dev See {IERC4262-deposit} */\\n    function deposit(uint256 assets, address receiver) public override returns (uint256) {\\n        require(assets <= maxDeposit(receiver), \\\"Max Deposit\\\");\\n        uint256 shares = previewDeposit(assets);\\n\\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n        return shares;\\n    }\\n\\n    /** @dev See {IERC4262-mint} */\\n    function mint(uint256 shares, address receiver) public override returns (uint256) {\\n        uint256 assets = previewMint(shares);\\n\\n        _mintInternal(assets, _safeUint88(shares), receiver, 0, true);\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n        return assets;\\n    }\\n\\n    /** @dev See {IERC4262-withdraw} */\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public override returns (uint256) {\\n        uint256 shares = previewWithdraw(assets);\\n\\n        if (msg.sender != owner) {\\n            _spendAllowance(owner, msg.sender, shares);\\n        }\\n        _redeemInternal(shares, receiver, owner);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        return shares;\\n    }\\n\\n    /** @dev See {IERC4262-redeem} */\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public override returns (uint256) {\\n        // It is more accurate and gas efficient to check the balance of the\\n        // receiver here than rely on the previewRedeem method.\\n        uint256 balanceBefore = IERC20(asset()).balanceOf(receiver);\\n\\n        if (msg.sender != owner) {\\n            _spendAllowance(owner, msg.sender, shares);\\n        }\\n        _redeemInternal(shares, receiver, owner);\\n\\n        uint256 balanceAfter = IERC20(asset()).balanceOf(receiver);\\n        uint256 assets = balanceAfter - balanceBefore;\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n        return assets;\\n    }\\n\\n    function _redeemInternal(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) private {\\n        bytes memory userData = abi.encode(\\n            RedeemOpts({\\n                redeemToUnderlying: true,\\n                transferfCash: false,\\n                receiver: receiver,\\n                maxImpliedRate: 0\\n            })\\n        );\\n\\n        // No operator data\\n        _burn(owner, shares, userData, \\\"\\\");\\n    }\\n\\n    function _safeNegInt88(uint256 x) private pure returns (int88) {\\n        int256 y = -int256(x);\\n        require(int256(type(int88).min) <= y);\\n        return int88(y);\\n    }\\n}\\n\"\r\n    },\r\n    \"wrapped-fcash/interfaces/notional/INotionalV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.11;\\npragma abicoder v2;\\n\\nimport \\\"../../contracts/lib/Types.sol\\\";\\n\\ninterface INotionalV2 {\\n    \\n    function getCurrency(uint16 currencyId)\\n        external\\n        view\\n        returns (Token memory assetToken, Token memory underlyingToken);\\n\\n    function getCashGroup(uint16 currencyId) external view returns (CashGroupSettings memory);\\n\\n    function getAccountContext(address account) external view returns (AccountContext memory);\\n\\n    function getAccountPortfolio(address account) external view returns (PortfolioAsset[] memory);\\n\\n    function getAccountBalance(uint16 currencyId, address account)\\n        external\\n        view\\n        returns (\\n            int256 cashBalance,\\n            int256 nTokenBalance,\\n            uint256 lastClaimTime\\n        );\\n\\n   function getfCashLendFromDeposit(\\n        uint16 currencyId,\\n        uint256 depositAmountExternal,\\n        uint256 maturity,\\n        uint32 minLendRate,\\n        uint256 blockTime,\\n        bool useUnderlying\\n    ) external view returns (\\n        uint88 fCashAmount,\\n        uint8 marketIndex,\\n        bytes32 encodedTrade\\n    );\\n\\n    function getDepositFromfCashLend(\\n        uint16 currencyId,\\n        uint256 fCashAmount,\\n        uint256 maturity,\\n        uint32 minLendRate,\\n        uint256 blockTime\\n    ) external view returns (\\n        uint256 depositAmountUnderlying,\\n        uint256 depositAmountAsset,\\n        uint8 marketIndex,\\n        bytes32 encodedTrade\\n    );\\n\\n    function getPrincipalFromfCashBorrow(\\n        uint16 currencyId,\\n        uint256 fCashBorrow,\\n        uint256 maturity,\\n        uint32 maxBorrowRate,\\n        uint256 blockTime\\n    ) external view returns (\\n        uint256 borrowAmountUnderlying,\\n        uint256 borrowAmountAsset,\\n        uint8 marketIndex,\\n        bytes32 encodedTrade\\n    );    \\n\\n    function getfCashBorrowFromPrincipal(\\n        uint16 currencyId,\\n        uint256 borrowedAmountExternal,\\n        uint256 maturity,\\n        uint32 maxBorrowRate,\\n        uint256 blockTime,\\n        bool useUnderlying\\n    ) external view returns (\\n        uint88 fCashDebt,\\n        uint8 marketIndex,\\n        bytes32 encodedTrade\\n    );\\n\\n    function convertCashBalanceToExternal(\\n        uint16 currencyId,\\n        int256 cashBalanceInternal,\\n        bool useUnderlying\\n    ) external view returns (int256);\\n\\n    function getPresentfCashValue(\\n        uint16 currencyId,\\n        uint256 maturity,\\n        int256 notional,\\n        uint256 blockTime,\\n        bool riskAdjusted\\n    ) external view returns (int256 presentValue);\\n    \\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external payable;\\n\\n    function settleAccount(address account) external;\\n\\n    function withdraw(\\n        uint16 currencyId,\\n        uint88 amountInternalPrecision,\\n        bool redeemToUnderlying\\n    ) external returns (uint256);\\n\\n    function batchBalanceAndTradeAction(address account, BalanceActionWithTrades[] calldata actions)\\n        external\\n        payable;\\n\\n    function batchLend(address account, BatchLend[] calldata actions) external;\\n\\n}\\n\"\r\n    },\r\n    \"wrapped-fcash/interfaces/IWETH9.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.11;\\n\\ninterface IWETH9 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n\\n    function transfer(address dst, uint wad) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"wrapped-fcash/contracts/wfCashLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./wfCashBase.sol\\\";\\nimport \\\"openzeppelin-contracts-V4/security/ReentrancyGuard.sol\\\";\\n\\n/// @dev This implementation contract is deployed as an UpgradeableBeacon. Each BeaconProxy\\n/// that uses this contract as an implementation will call initialize to set its own fCash id.\\n/// That identifier will represent the fCash that this ERC20 wrapper can hold.\\nabstract contract wfCashLogic is wfCashBase, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n    // bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))\\n    bytes4 internal constant ERC1155_ACCEPTED = 0xf23a6e61;\\n    // bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))\\n    bytes4 internal constant ERC1155_BATCH_ACCEPTED = 0xbc197c81;\\n\\n    constructor(INotionalV2 _notional, IWETH9 _weth) wfCashBase(_notional, _weth) {}\\n\\n    /***** Mint Methods *****/\\n\\n    /// @notice Lends deposit amount in return for fCashAmount using cTokens or aTokens\\n    /// @param depositAmountExternal amount of cash to deposit into this method\\n    /// @param fCashAmount amount of fCash to purchase (lend)\\n    /// @param receiver address to receive the fCash shares\\n    /// @param minImpliedRate minimum annualized interest rate to lend at\\n    function mintViaAsset(\\n        uint256 depositAmountExternal,\\n        uint88 fCashAmount,\\n        address receiver,\\n        uint32 minImpliedRate\\n    ) external override {\\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, false);\\n    }\\n\\n    /// @notice Lends deposit amount in return for fCashAmount using underlying tokens\\n    /// @param depositAmountExternal amount of cash to deposit into this method\\n    /// @param fCashAmount amount of fCash to purchase (lend)\\n    /// @param receiver address to receive the fCash shares\\n    /// @param minImpliedRate minimum annualized interest rate to lend at\\n    function mintViaUnderlying(\\n        uint256 depositAmountExternal,\\n        uint88 fCashAmount,\\n        address receiver,\\n        uint32 minImpliedRate\\n    ) external override {\\n        _mintInternal(depositAmountExternal, fCashAmount, receiver, minImpliedRate, true);\\n    }\\n\\n    function _mintInternal(\\n        uint256 depositAmountExternal,\\n        uint88 fCashAmount,\\n        address receiver,\\n        uint32 minImpliedRate,\\n        bool useUnderlying\\n    ) internal nonReentrant {\\n        require(!hasMatured(), \\\"fCash matured\\\");\\n        (IERC20 token, bool isETH) = getToken(useUnderlying);\\n        uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));\\n\\n        // If dealing in ETH, we use WETH in the wrapper instead of ETH. NotionalV2 uses\\n        // ETH natively but due to pull payment requirements for batchLend, it does not support\\n        // ETH. batchLend only supports ERC20 tokens like cETH or aETH. Since the wrapper is a compatibility\\n        // layer, it will support WETH so integrators can deal solely in ERC20 tokens. Instead of using\\n        // \\\"batchLend\\\" we will use \\\"batchBalanceActionWithTrades\\\". The difference is that \\\"batchLend\\\"\\n        // is more gas efficient (does not require and additional redeem call to asset tokens). If using cETH\\n        // then everything will proceed via batchLend.\\n        if (isETH) {\\n            IERC20((address(WETH))).safeTransferFrom(msg.sender, address(this), depositAmountExternal);\\n            WETH.withdraw(depositAmountExternal);\\n\\n            BalanceActionWithTrades[] memory action = EncodeDecode.encodeLendETHTrade(\\n                getCurrencyId(),\\n                getMarketIndex(),\\n                depositAmountExternal,\\n                fCashAmount,\\n                minImpliedRate\\n            );\\n            // Notional will return any residual ETH as the native token. When we _sendTokensToReceiver those\\n            // native ETH tokens will be wrapped back to WETH.\\n            NotionalV2.batchBalanceAndTradeAction{value: depositAmountExternal}(address(this), action);\\n        } else {\\n            // Transfers tokens in for lending, Notional will transfer from this contract.\\n            token.safeTransferFrom(msg.sender, address(this), depositAmountExternal);\\n\\n            // Executes a lending action on Notional\\n            BatchLend[] memory action = EncodeDecode.encodeLendTrade(\\n                getCurrencyId(),\\n                getMarketIndex(),\\n                fCashAmount,\\n                minImpliedRate,\\n                useUnderlying\\n            );\\n            NotionalV2.batchLend(address(this), action);\\n        }\\n\\n        // Mints ERC20 tokens for the receiver, the false flag denotes that we will not do an\\n        // operatorAck\\n        _mint(receiver, fCashAmount, \\\"\\\", \\\"\\\", false);\\n\\n        _sendTokensToReceiver(token, msg.sender, isETH, balanceBefore);\\n    }\\n\\n    /// @notice This hook will be called every time this contract receives fCash, will validate that\\n    /// this is the correct fCash and then mint the corresponding amount of wrapped fCash tokens\\n    /// back to the user.\\n    function onERC1155Received(\\n        address _operator,\\n        address _from,\\n        uint256 _id,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external nonReentrant returns (bytes4) {\\n        uint256 fCashID = getfCashId();\\n        // Only accept erc1155 transfers from NotionalV2\\n        require(\\n            msg.sender == address(NotionalV2) &&\\n            // Only accept the fcash id that corresponds to the listed currency and maturity\\n            _id == fCashID &&\\n            // Protect against signed value underflows\\n            int256(_value) > 0,\\n            \\\"Invalid\\\"\\n        );\\n\\n        // Double check the account's position, these are not strictly necessary and add gas costs\\n        // but might be good safe guards\\n        AccountContext memory ac = NotionalV2.getAccountContext(address(this));\\n        PortfolioAsset[] memory assets = NotionalV2.getAccountPortfolio(address(this));\\n        require(\\n            ac.hasDebt == 0x00 &&\\n            assets.length == 1 &&\\n            EncodeDecode.encodeERC1155Id(\\n                assets[0].currencyId,\\n                assets[0].maturity,\\n                assets[0].assetType\\n            ) == fCashID\\n        );\\n\\n        // Update per account fCash balance, calldata from the ERC1155 call is\\n        // passed via the ERC777 interface.\\n        bytes memory userData;\\n        bytes memory operatorData;\\n        if (_operator == _from) userData = _data;\\n        else operatorData = _data;\\n\\n        // We don't require a recipient ack here to maintain compatibility\\n        // with contracts that don't support ERC777\\n        _mint(_from, _value, userData, operatorData, false);\\n\\n        // This will allow the fCash to be accepted\\n        return ERC1155_ACCEPTED;\\n    }\\n\\n    /***** Redeem (Burn) Methods *****/\\n\\n    /// @notice Redeems tokens using custom options\\n    /// @dev re-entrancy is protected on _burn\\n    function redeem(uint256 amount, RedeemOpts memory opts) public override {\\n        bytes memory data = abi.encode(opts);\\n        // In this case, the owner is msg.sender based on the OZ ERC777 implementation\\n        burn(amount, data);\\n    }\\n\\n    /// @notice Redeems tokens to asset tokens\\n    /// @dev re-entrancy is protected on _burn\\n    function redeemToAsset(\\n        uint256 amount,\\n        address receiver,\\n        uint32 maxImpliedRate\\n    ) external override {\\n        redeem(\\n            amount,\\n            RedeemOpts({\\n                redeemToUnderlying: false,\\n                transferfCash: false,\\n                receiver: receiver,\\n                maxImpliedRate: maxImpliedRate\\n            })\\n        );\\n    }\\n\\n    /// @notice Redeems tokens to underlying\\n    /// @dev re-entrancy is protected on _burn\\n    function redeemToUnderlying(\\n        uint256 amount,\\n        address receiver,\\n        uint32 maxImpliedRate\\n    ) external override {\\n        redeem(\\n            amount,\\n            RedeemOpts({\\n                redeemToUnderlying: true,\\n                transferfCash: false,\\n                receiver: receiver,\\n                maxImpliedRate: maxImpliedRate\\n            })\\n        );\\n    }\\n\\n    /// @notice Called before tokens are burned (redemption) and so we will handle\\n    /// the fCash properly before and after maturity.\\n    function _burn(\\n        address from,\\n        uint256 amount,\\n        bytes memory userData,\\n        bytes memory operatorData\\n    ) internal override nonReentrant {\\n        // Save the total supply value before burning to calculate the cash claim share\\n        uint256 initialTotalSupply = totalSupply();\\n        RedeemOpts memory opts = abi.decode(userData, (RedeemOpts));\\n        require(opts.receiver != address(0), \\\"Receiver is zero address\\\");\\n        // This will validate that the account has sufficient tokens to burn and make\\n        // any relevant underlying stateful changes to balances.\\n        super._burn(from, amount, userData, operatorData);\\n\\n        if (hasMatured()) {\\n            // If the fCash has matured, then we need to ensure that the account is settled\\n            // and then we will transfer back the account's share of asset tokens.\\n\\n            // This is a noop if the account is already settled\\n            NotionalV2.settleAccount(address(this));\\n            uint16 currencyId = getCurrencyId();\\n\\n            (int256 cashBalance, /* */, /* */) = NotionalV2.getAccountBalance(currencyId, address(this));\\n            require(0 < cashBalance, \\\"Negative Cash Balance\\\");\\n\\n            // This always rounds down in favor of the wrapped fCash contract.\\n            uint256 assetInternalCashClaim = (uint256(cashBalance) * amount) / initialTotalSupply;\\n\\n            // Transfer withdrawn tokens to the `from` address\\n            _withdrawCashToAccount(\\n                currencyId,\\n                opts.receiver,\\n                _safeUint88(assetInternalCashClaim),\\n                opts.redeemToUnderlying\\n            );\\n        } else if (opts.transferfCash) {\\n            // If the fCash has not matured, then we can transfer it via ERC1155.\\n            // NOTE: this may fail if the destination is a contract and it does not implement \\n            // the `onERC1155Received` hook. If that is the case it is possible to use a regular\\n            // ERC20 transfer on this contract instead.\\n            NotionalV2.safeTransferFrom(\\n                address(this), // Sending from this contract\\n                opts.receiver, // Where to send the fCash\\n                getfCashId(), // fCash identifier\\n                amount, // Amount of fCash to send\\n                userData\\n            );\\n        } else {\\n            _sellfCash(\\n                opts.receiver,\\n                amount,\\n                opts.redeemToUnderlying,\\n                opts.maxImpliedRate\\n            );\\n        }\\n    }\\n\\n    /// @notice After maturity, withdraw cash back to account\\n    function _withdrawCashToAccount(\\n        uint16 currencyId,\\n        address receiver,\\n        uint88 assetInternalCashClaim,\\n        bool toUnderlying\\n    ) private returns (uint256 tokensTransferred) {\\n        (IERC20 token, bool isETH) = getToken(toUnderlying);\\n        uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));\\n\\n        NotionalV2.withdraw(currencyId, assetInternalCashClaim, toUnderlying);\\n\\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\\n    }\\n\\n    /// @dev Sells an fCash share back on the Notional AMM\\n    function _sellfCash(\\n        address receiver,\\n        uint256 fCashToSell,\\n        bool toUnderlying,\\n        uint32 maxImpliedRate\\n    ) private returns (uint256 tokensTransferred) {\\n        (IERC20 token, bool isETH) = getToken(toUnderlying);\\n        uint256 balanceBefore = isETH ? address(this).balance : token.balanceOf(address(this));\\n\\n        // Sells fCash on Notional AMM (via borrowing)\\n        BalanceActionWithTrades[] memory action = EncodeDecode.encodeBorrowTrade(\\n            getCurrencyId(),\\n            getMarketIndex(),\\n            _safeUint88(fCashToSell),\\n            maxImpliedRate,\\n            toUnderlying\\n        );\\n        NotionalV2.batchBalanceAndTradeAction(address(this), action);\\n\\n        // Send borrowed cash back to receiver\\n        tokensTransferred = _sendTokensToReceiver(token, receiver, isETH, balanceBefore);\\n    }\\n\\n    function _sendTokensToReceiver(\\n        IERC20 token,\\n        address receiver,\\n        bool isETH,\\n        uint256 balanceBefore\\n    ) private returns (uint256 tokensTransferred) {\\n        uint256 balanceAfter = isETH ? address(this).balance : token.balanceOf(address(this));\\n        tokensTransferred = balanceAfter - balanceBefore;\\n\\n        if (isETH) {\\n            WETH.deposit{value: tokensTransferred}();\\n            IERC20(address(WETH)).safeTransfer(receiver, tokensTransferred);\\n        } else {\\n            token.safeTransfer(receiver, tokensTransferred);\\n        }\\n    }\\n\\n    function _safeUint88(uint256 x) internal pure returns (uint88) {\\n        require(x <= uint256(type(uint88).max));\\n        return uint88(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"wrapped-fcash/interfaces/IERC4626.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\ninterface IERC4626 {\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n     *\\n     * - MUST be an ERC-20 token contract.\\n     * - MUST NOT revert.\\n     */\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /**\\n     * @dev Returns the total amount of the underlying asset that is \u201cmanaged\u201d by Vault.\\n     *\\n     * - SHOULD include any compounding that occurs from yield.\\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT revert.\\n     */\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /**\\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \u201cper-user\u201d price-per-share, and instead should reflect the\\n     * \u201caverage-user\u2019s\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n     * through a deposit call.\\n     *\\n     * - MUST return a limited value if receiver is subject to some deposit limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n     * - MUST NOT revert.\\n     */\\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n     *   in the same transaction.\\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   deposit execution, and are accounted for during deposit.\\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n     * - MUST return a limited value if receiver is subject to some mint limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n     * - MUST NOT revert.\\n     */\\n    function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n     *   same transaction.\\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\\n     */\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n     *   execution, and are accounted for during mint.\\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n     * Vault, through a withdraw call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n     *   called\\n     *   in the same transaction.\\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   withdraw execution, and are accounted for during withdraw.\\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n     * through a redeem call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n     *   same transaction.\\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n     */\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   redeem execution, and are accounted for during redeem.\\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 assets);\\n}\"\r\n    },\r\n    \"wrapped-fcash/contracts/wfCashBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./lib/Constants.sol\\\";\\nimport \\\"./lib/DateTime.sol\\\";\\nimport \\\"./lib/EncodeDecode.sol\\\";\\nimport \\\"../interfaces/notional/INotionalV2.sol\\\";\\nimport \\\"../interfaces/notional/IWrappedfCash.sol\\\";\\nimport \\\"../interfaces/IWETH9.sol\\\";\\nimport \\\"openzeppelin-contracts-V4/utils/Strings.sol\\\";\\nimport \\\"openzeppelin-contracts-V4/token/ERC20/IERC20.sol\\\";\\nimport \\\"openzeppelin-contracts-V4/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"openzeppelin-contracts-V4/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin-upgradeable/contracts/token/ERC777/ERC777Upgradeable.sol\\\";\\n\\nabstract contract wfCashBase is ERC777Upgradeable, IWrappedfCash {\\n    using SafeERC20 for IERC20;\\n\\n    /// @notice address to the NotionalV2 system\\n    INotionalV2 public immutable NotionalV2;\\n    IWETH9 public immutable WETH;\\n\\n    /// @dev Storage slot for fCash id. Read only and set on initialization\\n    uint256 private _fCashId;\\n\\n    /// @notice Constructor is called only on deployment to set the Notional address, rest of state\\n    /// is initialized on the proxy.\\n    /// @dev Ensure initializer modifier is on the constructor to prevent an attack on UUPSUpgradeable contracts\\n    constructor(INotionalV2 _notional, IWETH9 _weth) initializer {\\n        NotionalV2 = _notional;\\n        WETH = _weth;\\n    }\\n\\n    /// @notice Initializes a proxy for a specific fCash asset\\n    function initialize(uint16 currencyId, uint40 maturity) external override initializer {\\n        CashGroupSettings memory cashGroup = NotionalV2.getCashGroup(currencyId);\\n        require(cashGroup.maxMarketIndex > 0, \\\"Invalid currency\\\");\\n        // Ensure that the maturity is not past the max market index, also ensure that the maturity\\n        // is not in the past. This statement will allow idiosyncratic (non-tradable) fCash assets.\\n        require(\\n            DateTime.isValidMaturity(cashGroup.maxMarketIndex, maturity, block.timestamp),\\n            \\\"Invalid maturity\\\"\\n        );\\n\\n        // Get the corresponding fCash ID\\n        _fCashId = EncodeDecode.encodeERC1155Id(currencyId, maturity, Constants.FCASH_ASSET_TYPE);\\n\\n        (IERC20 underlyingToken, /* */) = getUnderlyingToken();\\n        (IERC20 assetToken, /* */, /* */) = getAssetToken();\\n\\n        string memory _symbol = address(underlyingToken) == Constants.ETH_ADDRESS\\n            ? \\\"ETH\\\"\\n            : IERC20Metadata(address(underlyingToken)).symbol();\\n\\n        string memory _maturity = Strings.toString(maturity);\\n\\n        __ERC777_init(\\n            // name\\n            string(abi.encodePacked(\\\"Wrapped f\\\", _symbol, \\\" @ \\\", _maturity)),\\n            // symbol\\n            string(abi.encodePacked(\\\"wf\\\", _symbol, \\\":\\\", _maturity)),\\n            // no default operators\\n            new address[](0)\\n        );\\n\\n        // Set approvals for Notional. It is possible for an asset token address to equal the underlying\\n        // token address when there is no money market involved.\\n        assetToken.safeApprove(address(NotionalV2), type(uint256).max);\\n        if (\\n            address(assetToken) != address(underlyingToken) &&\\n            address(underlyingToken) != Constants.ETH_ADDRESS\\n        ) {\\n            underlyingToken.safeApprove(address(NotionalV2), type(uint256).max);\\n        }\\n    }\\n\\n    /// @notice Returns the underlying fCash ID of the token\\n    function getfCashId() public view override returns (uint256) {\\n        return _fCashId;\\n    }\\n\\n    /// @notice Returns the underlying fCash maturity of the token\\n    function getMaturity() public view override returns (uint40 maturity) {\\n        (/* */, maturity, /* */) = EncodeDecode.decodeERC1155Id(_fCashId);\\n    }\\n\\n    /// @notice True if the fCash has matured, assets mature exactly on the block time\\n    function hasMatured() public view override returns (bool) {\\n        return getMaturity() <= block.timestamp;\\n    }\\n\\n    /// @notice Returns the underlying fCash currency\\n    function getCurrencyId() public view override returns (uint16 currencyId) {\\n        (currencyId, /* */, /* */) = EncodeDecode.decodeERC1155Id(_fCashId);\\n    }\\n\\n    /// @notice Returns the components of the fCash idd\\n    function getDecodedID() public view override returns (uint16 currencyId, uint40 maturity) {\\n        (currencyId, maturity, /* */) = EncodeDecode.decodeERC1155Id(_fCashId);\\n    }\\n\\n    /// @notice fCash is always denominated in 8 decimal places\\n    function decimals() public pure override returns (uint8) {\\n        return 8;\\n    }\\n\\n    /// @notice Returns the current market index for this fCash asset. If this returns\\n    /// zero that means it is idiosyncratic and cannot be traded.\\n    function getMarketIndex() public view override returns (uint8) {\\n        (uint256 marketIndex, bool isIdiosyncratic) = DateTime.getMarketIndex(\\n            Constants.MAX_TRADED_MARKET_INDEX,\\n            getMaturity(),\\n            block.timestamp\\n        );\\n\\n        if (isIdiosyncratic) return 0;\\n        // Market index as defined does not overflow this conversion\\n        return uint8(marketIndex);\\n    }\\n\\n    /// @notice Returns the token and precision of the token that this token settles\\n    /// to. For example, fUSDC will return the USDC token address and 1e6. The zero\\n    /// address will represent ETH.\\n    function getUnderlyingToken() public view override returns (IERC20 underlyingToken, int256 underlyingPrecision) {\\n        (Token memory asset, Token memory underlying) = NotionalV2.getCurrency(getCurrencyId());\\n\\n        if (asset.tokenType == TokenType.NonMintable) {\\n            // In this case the asset token is the underlying\\n            return (IERC20(asset.tokenAddress), asset.decimals);\\n        } else {\\n            return (IERC20(underlying.tokenAddress), underlying.decimals);\\n        }\\n    }\\n\\n    /// @notice Returns the asset token which the fCash settles to. This will be an interest\\n    /// bearing token like a cToken or aToken.\\n    function getAssetToken() public view override returns (IERC20 assetToken, int256 underlyingPrecision, TokenType tokenType) {\\n        (Token memory asset, /* Token memory underlying */) = NotionalV2.getCurrency(getCurrencyId());\\n        return (IERC20(asset.tokenAddress), asset.decimals, asset.tokenType);\\n    }\\n\\n    function getToken(bool useUnderlying) public view returns (IERC20 token, bool isETH) {\\n        if (useUnderlying) {\\n            (token, /* */) = getUnderlyingToken();\\n        } else {\\n            (token, /* */, /* */) = getAssetToken();\\n        }\\n        isETH = address(token) == Constants.ETH_ADDRESS;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-contracts-V4/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"wrapped-fcash/contracts/lib/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title All shared constants for the Notional system should be declared here.\\nlibrary Constants {\\n    address internal constant ETH_ADDRESS = address(0);\\n\\n    // Token precision used for all internal balances, TokenHandler library ensures that we\\n    // limit the dust amount caused by precision mismatches\\n    int256 internal constant INTERNAL_TOKEN_PRECISION = 1e8;\\n\\n    // Max number of traded markets, also used as the maximum number of assets in a portfolio array\\n    uint256 internal constant MAX_TRADED_MARKET_INDEX = 7;\\n\\n    // Internal date representations, note we use a 6/30/360 week/month/year convention here\\n    uint256 internal constant DAY = 86400;\\n    // We use six day weeks to ensure that all time references divide evenly\\n    uint256 internal constant WEEK = DAY * 6;\\n    uint256 internal constant MONTH = WEEK * 5;\\n    uint256 internal constant QUARTER = MONTH * 3;\\n    uint256 internal constant YEAR = QUARTER * 4;\\n\\n    // These constants are used in DateTime.sol\\n    uint256 internal constant DAYS_IN_WEEK = 6;\\n    uint256 internal constant DAYS_IN_MONTH = 30;\\n    uint256 internal constant DAYS_IN_QUARTER = 90;\\n\\n    // Offsets for each time chunk denominated in days\\n    uint256 internal constant MAX_DAY_OFFSET = 90;\\n    uint256 internal constant MAX_WEEK_OFFSET = 360;\\n    uint256 internal constant MAX_MONTH_OFFSET = 2160;\\n    uint256 internal constant MAX_QUARTER_OFFSET = 7650;\\n\\n    // Offsets for each time chunk denominated in bits\\n    uint256 internal constant WEEK_BIT_OFFSET = 90;\\n    uint256 internal constant MONTH_BIT_OFFSET = 135;\\n    uint256 internal constant QUARTER_BIT_OFFSET = 195;\\n\\n    uint8 internal constant FCASH_ASSET_TYPE = 1;\\n    // Liquidity token asset types are 1 + marketIndex (where marketIndex is 1-indexed)\\n    uint8 internal constant MIN_LIQUIDITY_TOKEN_INDEX = 2;\\n    uint8 internal constant MAX_LIQUIDITY_TOKEN_INDEX = 8;\\n\\n    bytes2 internal constant UNMASK_FLAGS = 0x3FFF;\\n    uint16 internal constant MAX_CURRENCIES = uint16(UNMASK_FLAGS);\\n}\\n\"\r\n    },\r\n    \"wrapped-fcash/contracts/lib/DateTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./Constants.sol\\\";\\n\\nlibrary DateTime {\\n\\n    /// @notice Returns the current reference time which is how all the AMM dates are calculated.\\n    function getReferenceTime(uint256 blockTime) internal pure returns (uint256) {\\n        require(blockTime >= Constants.QUARTER);\\n        return blockTime - (blockTime % Constants.QUARTER);\\n    }\\n\\n    /// @notice Truncates a date to midnight UTC time\\n    function getTimeUTC0(uint256 time) internal pure returns (uint256) {\\n        require(time >= Constants.DAY);\\n        return time - (time % Constants.DAY);\\n    }\\n\\n    /// @notice These are the predetermined market offsets for trading\\n    /// @dev Markets are 1-indexed because the 0 index means that no markets are listed for the cash group.\\n    function getTradedMarket(uint256 index) internal pure returns (uint256) {\\n        if (index == 1) return Constants.QUARTER;\\n        if (index == 2) return 2 * Constants.QUARTER;\\n        if (index == 3) return Constants.YEAR;\\n        if (index == 4) return 2 * Constants.YEAR;\\n        if (index == 5) return 5 * Constants.YEAR;\\n        if (index == 6) return 10 * Constants.YEAR;\\n        if (index == 7) return 20 * Constants.YEAR;\\n\\n        revert(\\\"Invalid index\\\");\\n    }\\n\\n    /// @notice Determines if an idiosyncratic maturity is valid and returns the bit reference that is the case.\\n    function isValidMaturity(\\n        uint256 maxMarketIndex,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal pure returns (bool) {\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\n        uint256 maxMaturity = tRef + DateTime.getTradedMarket(maxMarketIndex);\\n        // Cannot trade past max maturity\\n        if (maturity > maxMaturity) return false;\\n\\n        // prettier-ignore\\n        (/* */, bool isValid) = DateTime.getBitNumFromMaturity(blockTime, maturity);\\n        return isValid;\\n    }\\n\\n    /// @notice Returns the market index for a given maturity, if the maturity is idiosyncratic\\n    /// will return the nearest market index that is larger than the maturity.\\n    /// @return uint marketIndex, bool isIdiosyncratic\\n    function getMarketIndex(\\n        uint256 maxMarketIndex,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal pure returns (uint256, bool) {\\n        require(maxMarketIndex > 0, \\\"CG: no markets listed\\\");\\n        require(maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX, \\\"CG: market index bound\\\");\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\n\\n        for (uint256 i = 1; i <= maxMarketIndex; i++) {\\n            uint256 marketMaturity = tRef + DateTime.getTradedMarket(i);\\n            // If market matches then is not idiosyncratic\\n            if (marketMaturity == maturity) return (i, false);\\n            // Returns the market that is immediately greater than the maturity\\n            if (marketMaturity > maturity) return (i, true);\\n        }\\n\\n        revert(\\\"CG: no market found\\\");\\n    }\\n\\n    /// @notice Given a bit number and the reference time of the first bit, returns the bit number\\n    /// of a given maturity.\\n    /// @return bitNum and a true or false if the maturity falls on the exact bit\\n    function getBitNumFromMaturity(uint256 blockTime, uint256 maturity)\\n        internal\\n        pure\\n        returns (uint256, bool)\\n    {\\n        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);\\n\\n        // Maturities must always divide days evenly\\n        if (maturity % Constants.DAY != 0) return (0, false);\\n        // Maturity cannot be in the past\\n        if (blockTimeUTC0 >= maturity) return (0, false);\\n\\n        // Overflow check done above\\n        // daysOffset has no remainders, checked above\\n        uint256 daysOffset = (maturity - blockTimeUTC0) / Constants.DAY;\\n\\n        // These if statements need to fall through to the next one\\n        if (daysOffset <= Constants.MAX_DAY_OFFSET) {\\n            return (daysOffset, true);\\n        } else if (daysOffset <= Constants.MAX_WEEK_OFFSET) {\\n            // (daysOffset - MAX_DAY_OFFSET) is the days overflow into the week portion, must be > 0\\n            // (blockTimeUTC0 % WEEK) / DAY is the offset into the week portion\\n            // This returns the offset from the previous max offset in days\\n            uint256 offsetInDays =\\n                daysOffset -\\n                    Constants.MAX_DAY_OFFSET +\\n                    (blockTimeUTC0 % Constants.WEEK) /\\n                    Constants.DAY;\\n            \\n            return (\\n                // This converts the offset in days to its corresponding bit position, truncating down\\n                // if it does not divide evenly into DAYS_IN_WEEK\\n                Constants.WEEK_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_WEEK,\\n                (offsetInDays % Constants.DAYS_IN_WEEK) == 0\\n            );\\n        } else if (daysOffset <= Constants.MAX_MONTH_OFFSET) {\\n            uint256 offsetInDays =\\n                daysOffset -\\n                    Constants.MAX_WEEK_OFFSET +\\n                    (blockTimeUTC0 % Constants.MONTH) /\\n                    Constants.DAY;\\n\\n            return (\\n                Constants.MONTH_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_MONTH,\\n                (offsetInDays % Constants.DAYS_IN_MONTH) == 0\\n            );\\n        } else if (daysOffset <= Constants.MAX_QUARTER_OFFSET) {\\n            uint256 offsetInDays =\\n                daysOffset -\\n                    Constants.MAX_MONTH_OFFSET +\\n                    (blockTimeUTC0 % Constants.QUARTER) /\\n                    Constants.DAY;\\n\\n            return (\\n                Constants.QUARTER_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_QUARTER,\\n                (offsetInDays % Constants.DAYS_IN_QUARTER) == 0\\n            );\\n        }\\n\\n        // This is the maximum 1-indexed bit num, it is never valid because it is beyond the 20\\n        // year max maturity\\n        return (256, false);\\n    }\\n}\\n\"\r\n    },\r\n    \"wrapped-fcash/contracts/lib/EncodeDecode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./Types.sol\\\";\\n\\nlibrary EncodeDecode {\\n\\n    /// @notice Decodes asset ids\\n    function decodeERC1155Id(uint256 id)\\n        internal\\n        pure\\n        returns (\\n            uint16 currencyId,\\n            uint40 maturity,\\n            uint8 assetType\\n        )\\n    {\\n        assetType = uint8(id);\\n        maturity = uint40(id >> 8);\\n        currencyId = uint16(id >> 48);\\n    }\\n\\n    /// @notice Encodes asset ids\\n    function encodeERC1155Id(\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 assetType\\n    ) internal pure returns (uint256) {\\n        require(currencyId <= Constants.MAX_CURRENCIES);\\n        require(maturity <= type(uint40).max);\\n        require(assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX);\\n\\n        return\\n            uint256(\\n                (bytes32(uint256(uint16(currencyId))) << 48) |\\n                (bytes32(uint256(uint40(maturity))) << 8) |\\n                bytes32(uint256(uint8(assetType)))\\n            );\\n    }\\n\\n    function encodeLendTrade(\\n        uint16 currencyId,\\n        uint8 marketIndex,\\n        uint88 fCashAmount,\\n        uint32 minImpliedRate,\\n        bool useUnderlying\\n    ) internal pure returns (BatchLend[] memory action) {\\n        action = new BatchLend[](1);\\n        action[0].currencyId = currencyId;\\n        action[0].depositUnderlying = useUnderlying;\\n        action[0].trades = new bytes32[](1);\\n        action[0].trades[0] = bytes32(\\n            (uint256(uint8(TradeActionType.Lend)) << 248) |\\n            (uint256(marketIndex) << 240) |\\n            (uint256(fCashAmount) << 152) |\\n            (uint256(minImpliedRate) << 120)\\n        );\\n    }\\n\\n    function encodeLendETHTrade(\\n        uint16 currencyId,\\n        uint8 marketIndex,\\n        uint256 depositAmountExternal,\\n        uint88 fCashAmount,\\n        uint32 minImpliedRate\\n    ) internal pure returns (BalanceActionWithTrades[] memory action) {\\n        action = new BalanceActionWithTrades[](1);\\n        action[0].actionType = DepositActionType.DepositUnderlying;\\n        action[0].currencyId = currencyId;\\n        action[0].depositActionAmount = depositAmountExternal;\\n        action[0].withdrawEntireCashBalance = true;\\n        action[0].redeemToUnderlying = true;\\n        action[0].trades = new bytes32[](1);\\n        action[0].trades[0] = bytes32(\\n            (uint256(uint8(TradeActionType.Lend)) << 248) |\\n            (uint256(marketIndex) << 240) |\\n            (uint256(fCashAmount) << 152) |\\n            (uint256(minImpliedRate) << 120)\\n        );\\n    }\\n\\n    function encodeBorrowTrade(\\n        uint16 currencyId,\\n        uint8 marketIndex,\\n        uint88 fCashAmount,\\n        uint32 maxImpliedRate,\\n        bool toUnderlying\\n    ) internal pure returns (BalanceActionWithTrades[] memory action) {\\n        action = new BalanceActionWithTrades[](1);\\n        action[0].actionType = DepositActionType.None;\\n        action[0].currencyId = currencyId;\\n        action[0].withdrawEntireCashBalance = true;\\n        action[0].redeemToUnderlying = toUnderlying;\\n        action[0].trades = new bytes32[](1);\\n        action[0].trades[0] = bytes32(\\n            (uint256(uint8(TradeActionType.Borrow)) << 248) |\\n            (uint256(marketIndex) << 240) |\\n            (uint256(fCashAmount) << 152) |\\n            (uint256(maxImpliedRate) << 120)\\n        );\\n    }\\n}\"\r\n    },\r\n    \"wrapped-fcash/interfaces/notional/IWrappedfCash.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport {TokenType} from \\\"../../contracts/lib/Types.sol\\\";\\nimport \\\"../IERC4626.sol\\\";\\nimport \\\"openzeppelin-contracts-V4/token/ERC20/IERC20.sol\\\";\\nimport \\\"openzeppelin-contracts-V4/token/ERC777/IERC777.sol\\\";\\n\\ninterface IWrappedfCash {\\n    struct RedeemOpts {\\n        bool redeemToUnderlying;\\n        bool transferfCash;\\n        address receiver;\\n        // Zero signifies no maximum slippage\\n        uint32 maxImpliedRate;\\n    }\\n    function initialize(uint16 currencyId, uint40 maturity) external;\\n\\n    /// @notice Mints wrapped fCash ERC20 tokens\\n    function mintViaAsset(\\n        uint256 depositAmountExternal,\\n        uint88 fCashAmount,\\n        address receiver,\\n        uint32 minImpliedRate\\n    ) external;\\n\\n    function mintViaUnderlying(\\n        uint256 depositAmountExternal,\\n        uint88 fCashAmount,\\n        address receiver,\\n        uint32 minImpliedRate\\n    ) external;\\n\\n    function redeem(uint256 amount, RedeemOpts memory data) external;\\n    function redeemToAsset(uint256 amount, address receiver, uint32 maxImpliedRate) external;\\n    function redeemToUnderlying(uint256 amount, address receiver, uint32 maxImpliedRate) external;\\n\\n    /// @notice Returns the underlying fCash ID of the token\\n    function getfCashId() external view returns (uint256);\\n\\n    /// @notice Returns the underlying fCash maturity of the token\\n    function getMaturity() external view returns (uint40 maturity);\\n\\n    /// @notice True if the fCash has matured, assets mature exactly on the block time\\n    function hasMatured() external view returns (bool);\\n\\n    /// @notice Returns the underlying fCash currency\\n    function getCurrencyId() external view returns (uint16 currencyId);\\n\\n    /// @notice Returns the components of the fCash idd\\n    function getDecodedID() external view returns (uint16 currencyId, uint40 maturity);\\n\\n    /// @notice Returns the current market index for this fCash asset. If this returns\\n    /// zero that means it is idiosyncratic and cannot be traded.\\n    function getMarketIndex() external view returns (uint8);\\n\\n    /// @notice Returns the token and precision of the token that this token settles\\n    /// to. For example, fUSDC will return the USDC token address and 1e6. The zero\\n    /// address will represent ETH.\\n    function getUnderlyingToken() external view returns (IERC20 underlyingToken, int256 underlyingPrecision);\\n\\n    /// @notice Returns the asset token which the fCash settles to. This will be an interest\\n    /// bearing token like a cToken or aToken.\\n    function getAssetToken() external view returns (IERC20 assetToken, int256 assetPrecision, TokenType tokenType);\\n}\\n\\n\\ninterface IWrappedfCashComplete is IWrappedfCash, IERC777, IERC4626 {} \"\r\n    },\r\n    \"openzeppelin-contracts-V4/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-contracts-V4/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-contracts-V4/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-contracts-V4/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-upgradeable/contracts/token/ERC777/ERC777Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC777/ERC777.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC777Upgradeable.sol\\\";\\nimport \\\"./IERC777RecipientUpgradeable.sol\\\";\\nimport \\\"./IERC777SenderUpgradeable.sol\\\";\\nimport \\\"../ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../utils/introspection/IERC1820RegistryUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC777} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * Support for ERC20 is included in this contract, as specified by the EIP: both\\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\\n * movements.\\n *\\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\\n * are no special restrictions in the amount of tokens that created, moved, or\\n * destroyed. This makes integration with ERC20 applications seamless.\\n */\\ncontract ERC777Upgradeable is Initializable, ContextUpgradeable, IERC777Upgradeable, IERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    IERC1820RegistryUpgradeable internal constant _ERC1820_REGISTRY = IERC1820RegistryUpgradeable(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\\n\\n    mapping(address => uint256) private _balances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH = keccak256(\\\"ERC777TokensSender\\\");\\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\\\"ERC777TokensRecipient\\\");\\n\\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\\n    address[] private _defaultOperatorsArray;\\n\\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\\n    mapping(address => bool) private _defaultOperators;\\n\\n    // For each account, a mapping of its operators and revoked default operators.\\n    mapping(address => mapping(address => bool)) private _operators;\\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\\n\\n    // ERC20-allowances\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    /**\\n     * @dev `defaultOperators` may be an empty array.\\n     */\\n    function __ERC777_init(\\n        string memory name_,\\n        string memory symbol_,\\n        address[] memory defaultOperators_\\n    ) internal onlyInitializing {\\n        __ERC777_init_unchained(name_, symbol_, defaultOperators_);\\n    }\\n\\n    function __ERC777_init_unchained(\\n        string memory name_,\\n        string memory symbol_,\\n        address[] memory defaultOperators_\\n    ) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n\\n        _defaultOperatorsArray = defaultOperators_;\\n        for (uint256 i = 0; i < defaultOperators_.length; i++) {\\n            _defaultOperators[defaultOperators_[i]] = true;\\n        }\\n\\n        // register interfaces\\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\\\"ERC777Token\\\"), address(this));\\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\\\"ERC20Token\\\"), address(this));\\n    }\\n\\n    /**\\n     * @dev See {IERC777-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC777-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {ERC20-decimals}.\\n     *\\n     * Always returns 18, as per the\\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\\n     */\\n    function decimals() public pure virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC777-granularity}.\\n     *\\n     * This implementation always returns `1`.\\n     */\\n    function granularity() public view virtual override returns (uint256) {\\n        return 1;\\n    }\\n\\n    /**\\n     * @dev See {IERC777-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override(IERC20Upgradeable, IERC777Upgradeable) returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\\n     */\\n    function balanceOf(address tokenHolder) public view virtual override(IERC20Upgradeable, IERC777Upgradeable) returns (uint256) {\\n        return _balances[tokenHolder];\\n    }\\n\\n    /**\\n     * @dev See {IERC777-send}.\\n     *\\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\\n     */\\n    function send(\\n        address recipient,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        _send(_msgSender(), recipient, amount, data, \\\"\\\", true);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\\n     * interface if it is a contract.\\n     *\\n     * Also emits a {Sent} event.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        require(recipient != address(0), \\\"ERC777: transfer to the zero address\\\");\\n\\n        address from = _msgSender();\\n\\n        _callTokensToSend(from, from, recipient, amount, \\\"\\\", \\\"\\\");\\n\\n        _move(from, from, recipient, amount, \\\"\\\", \\\"\\\");\\n\\n        _callTokensReceived(from, from, recipient, amount, \\\"\\\", \\\"\\\", false);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC777-burn}.\\n     *\\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\\n     */\\n    function burn(uint256 amount, bytes memory data) public virtual override {\\n        _burn(_msgSender(), amount, data, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC777-isOperatorFor}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) public view virtual override returns (bool) {\\n        return\\n            operator == tokenHolder ||\\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\\n            _operators[tokenHolder][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC777-authorizeOperator}.\\n     */\\n    function authorizeOperator(address operator) public virtual override {\\n        require(_msgSender() != operator, \\\"ERC777: authorizing self as operator\\\");\\n\\n        if (_defaultOperators[operator]) {\\n            delete _revokedDefaultOperators[_msgSender()][operator];\\n        } else {\\n            _operators[_msgSender()][operator] = true;\\n        }\\n\\n        emit AuthorizedOperator(operator, _msgSender());\\n    }\\n\\n    /**\\n     * @dev See {IERC777-revokeOperator}.\\n     */\\n    function revokeOperator(address operator) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC777: revoking self as operator\\\");\\n\\n        if (_defaultOperators[operator]) {\\n            _revokedDefaultOperators[_msgSender()][operator] = true;\\n        } else {\\n            delete _operators[_msgSender()][operator];\\n        }\\n\\n        emit RevokedOperator(operator, _msgSender());\\n    }\\n\\n    /**\\n     * @dev See {IERC777-defaultOperators}.\\n     */\\n    function defaultOperators() public view virtual override returns (address[] memory) {\\n        return _defaultOperatorsArray;\\n    }\\n\\n    /**\\n     * @dev See {IERC777-operatorSend}.\\n     *\\n     * Emits {Sent} and {IERC20-Transfer} events.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes memory data,\\n        bytes memory operatorData\\n    ) public virtual override {\\n        require(isOperatorFor(_msgSender(), sender), \\\"ERC777: caller is not an operator for holder\\\");\\n        _send(sender, recipient, amount, data, operatorData, true);\\n    }\\n\\n    /**\\n     * @dev See {IERC777-operatorBurn}.\\n     *\\n     * Emits {Burned} and {IERC20-Transfer} events.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes memory data,\\n        bytes memory operatorData\\n    ) public virtual override {\\n        require(isOperatorFor(_msgSender(), account), \\\"ERC777: caller is not an operator for holder\\\");\\n        _burn(account, amount, data, operatorData);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     *\\n     * Note that operator and allowance concepts are orthogonal: operators may\\n     * not have allowance, and accounts with allowance may not be operators\\n     * themselves.\\n     */\\n    function allowance(address holder, address spender) public view virtual override returns (uint256) {\\n        return _allowances[holder][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Note that accounts cannot have allowance issued by their operators.\\n     */\\n    function approve(address spender, uint256 value) public virtual override returns (bool) {\\n        address holder = _msgSender();\\n        _approve(holder, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Note that operator and allowance concepts are orthogonal: operators cannot\\n     * call `transferFrom` (unless they have allowance), and accounts with\\n     * allowance cannot call `operatorSend` (unless they are operators).\\n     *\\n     * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.\\n     */\\n    function transferFrom(\\n        address holder,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        require(recipient != address(0), \\\"ERC777: transfer to the zero address\\\");\\n        require(holder != address(0), \\\"ERC777: transfer from the zero address\\\");\\n\\n        address spender = _msgSender();\\n\\n        _callTokensToSend(spender, holder, recipient, amount, \\\"\\\", \\\"\\\");\\n\\n        _spendAllowance(holder, spender, amount);\\n\\n        _move(spender, holder, recipient, amount, \\\"\\\", \\\"\\\");\\n\\n        _callTokensReceived(spender, holder, recipient, amount, \\\"\\\", \\\"\\\", false);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `operator`, `data` and `operatorData`.\\n     *\\n     * See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits {Minted} and {IERC20-Transfer} events.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 amount,\\n        bytes memory userData,\\n        bytes memory operatorData\\n    ) internal virtual {\\n        _mint(account, amount, userData, operatorData, true);\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * If `requireReceptionAck` is set to true, and if a send hook is\\n     * registered for `account`, the corresponding function will be called with\\n     * `operator`, `data` and `operatorData`.\\n     *\\n     * See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits {Minted} and {IERC20-Transfer} events.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 amount,\\n        bytes memory userData,\\n        bytes memory operatorData,\\n        bool requireReceptionAck\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC777: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), account, amount);\\n\\n        // Update state variables\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n\\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, requireReceptionAck);\\n\\n        emit Minted(operator, account, amount, userData, operatorData);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Send tokens\\n     * @param from address token holder address\\n     * @param to address recipient address\\n     * @param amount uint256 amount of tokens to transfer\\n     * @param userData bytes extra information provided by the token holder (if any)\\n     * @param operatorData bytes extra information provided by the operator (if any)\\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\\n     */\\n    function _send(\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes memory userData,\\n        bytes memory operatorData,\\n        bool requireReceptionAck\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC777: send from the zero address\\\");\\n        require(to != address(0), \\\"ERC777: send to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\\n\\n        _move(operator, from, to, amount, userData, operatorData);\\n\\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\\n    }\\n\\n    /**\\n     * @dev Burn tokens\\n     * @param from address token holder address\\n     * @param amount uint256 amount of tokens to burn\\n     * @param data bytes extra information provided by the token holder\\n     * @param operatorData bytes extra information provided by the operator (if any)\\n     */\\n    function _burn(\\n        address from,\\n        uint256 amount,\\n        bytes memory data,\\n        bytes memory operatorData\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC777: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\\n\\n        _beforeTokenTransfer(operator, from, address(0), amount);\\n\\n        // Update state variables\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC777: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Burned(operator, from, amount, data, operatorData);\\n        emit Transfer(from, address(0), amount);\\n    }\\n\\n    function _move(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes memory userData,\\n        bytes memory operatorData\\n    ) private {\\n        _beforeTokenTransfer(operator, from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC777: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Sent(operator, from, to, amount, userData, operatorData);\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    /**\\n     * @dev See {ERC20-_approve}.\\n     *\\n     * Note that accounts cannot have allowance issued by their operators.\\n     */\\n    function _approve(\\n        address holder,\\n        address spender,\\n        uint256 value\\n    ) internal virtual {\\n        require(holder != address(0), \\\"ERC777: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC777: approve to the zero address\\\");\\n\\n        _allowances[holder][spender] = value;\\n        emit Approval(holder, spender, value);\\n    }\\n\\n    /**\\n     * @dev Call from.tokensToSend() if the interface is registered\\n     * @param operator address operator requesting the transfer\\n     * @param from address token holder address\\n     * @param to address recipient address\\n     * @param amount uint256 amount of tokens to transfer\\n     * @param userData bytes extra information provided by the token holder (if any)\\n     * @param operatorData bytes extra information provided by the operator (if any)\\n     */\\n    function _callTokensToSend(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes memory userData,\\n        bytes memory operatorData\\n    ) private {\\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);\\n        if (implementer != address(0)) {\\n            IERC777SenderUpgradeable(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\\n        }\\n    }\\n\\n    /**\\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\\n     * tokensReceived() was not registered for the recipient\\n     * @param operator address operator requesting the transfer\\n     * @param from address token holder address\\n     * @param to address recipient address\\n     * @param amount uint256 amount of tokens to transfer\\n     * @param userData bytes extra information provided by the token holder (if any)\\n     * @param operatorData bytes extra information provided by the operator (if any)\\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\\n     */\\n    function _callTokensReceived(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes memory userData,\\n        bytes memory operatorData,\\n        bool requireReceptionAck\\n    ) private {\\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(to, _TOKENS_RECIPIENT_INTERFACE_HASH);\\n        if (implementer != address(0)) {\\n            IERC777RecipientUpgradeable(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\\n        } else if (requireReceptionAck) {\\n            require(!to.isContract(), \\\"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC777: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes\\n     * calls to {send}, {transfer}, {operatorSend}, minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[41] private __gap;\\n}\\n\"\r\n    },\r\n    \"wrapped-fcash/contracts/lib/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Different types of internal tokens\\n///  - UnderlyingToken: underlying asset for a cToken (except for Ether)\\n///  - cToken: Compound interest bearing token\\n///  - cETH: Special handling for cETH tokens\\n///  - Ether: the one and only\\n///  - NonMintable: tokens that do not have an underlying (therefore not cTokens)\\nenum TokenType {\\n    UnderlyingToken,\\n    cToken,\\n    cETH,\\n    Ether,\\n    NonMintable\\n}\\n\\n/// @notice Specifies the different trade action types in the system. Each trade action type is\\n/// encoded in a tightly packed bytes32 object. Trade action type is the first big endian byte of the\\n/// 32 byte trade action object. The schemas for each trade action type are defined below.\\nenum TradeActionType {\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 minImpliedRate, uint120 unused)\\n    Lend,\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 maxImpliedRate, uint120 unused)\\n    Borrow,\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 assetCashAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\\n    AddLiquidity,\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 tokenAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\\n    RemoveLiquidity,\\n    // (uint8 TradeActionType, uint32 Maturity, int88 fCashResidualAmount, uint128 unused)\\n    PurchaseNTokenResidual,\\n    // (uint8 TradeActionType, address CounterpartyAddress, int88 fCashAmountToSettle)\\n    SettleCashDebt\\n}\\n\\n/// @notice Specifies different deposit actions that can occur during BalanceAction or BalanceActionWithTrades\\nenum DepositActionType {\\n    // No deposit action\\n    None,\\n    // Deposit asset cash, depositActionAmount is specified in asset cash external precision\\n    DepositAsset,\\n    // Deposit underlying tokens that are mintable to asset cash, depositActionAmount is specified in underlying token\\n    // external precision\\n    DepositUnderlying,\\n    // Deposits specified asset cash external precision amount into an nToken and mints the corresponding amount of\\n    // nTokens into the account\\n    DepositAssetAndMintNToken,\\n    // Deposits specified underlying in external precision, mints asset cash, and uses that asset cash to mint nTokens\\n    DepositUnderlyingAndMintNToken,\\n    // Redeems an nToken balance to asset cash. depositActionAmount is specified in nToken precision. Considered a deposit action\\n    // because it deposits asset cash into an account. If there are fCash residuals that cannot be sold off, will revert.\\n    RedeemNToken,\\n    // Converts specified amount of asset cash balance already in Notional to nTokens. depositActionAmount is specified in\\n    // Notional internal 8 decimal precision.\\n    ConvertCashToNToken\\n}\\n\\n/// @notice Used internally for PortfolioHandler state\\nenum AssetStorageState {\\n    NoChange,\\n    Update,\\n    Delete\\n}\\n\\n/// @notice Defines a batch lending action\\nstruct BatchLend {\\n    uint16 currencyId;\\n    // True if the contract should try to transfer underlying tokens instead of asset tokens\\n    bool depositUnderlying;\\n    // Array of tightly packed 32 byte objects that represent trades. See TradeActionType documentation\\n    bytes32[] trades;\\n}\\n\\n/// @notice Defines a balance action with a set of trades to do as well\\nstruct BalanceActionWithTrades {\\n    DepositActionType actionType;\\n    uint16 currencyId;\\n    uint256 depositActionAmount;\\n    uint256 withdrawAmountInternalPrecision;\\n    bool withdrawEntireCashBalance;\\n    bool redeemToUnderlying;\\n    // Array of tightly packed 32 byte objects that represent trades. See TradeActionType documentation\\n    bytes32[] trades;\\n}\\n\\n/// @notice Internal object that represents a token\\nstruct Token {\\n    address tokenAddress;\\n    bool hasTransferFee;\\n    int256 decimals;\\n    TokenType tokenType;\\n    uint256 maxCollateralBalance;\\n}\\n\\nstruct PortfolioAsset {\\n    // Asset currency id\\n    uint256 currencyId;\\n    uint256 maturity;\\n    // Asset type, fCash or liquidity token.\\n    uint256 assetType;\\n    // fCash amount or liquidity token amount\\n    int256 notional;\\n    // Used for managing portfolio asset state\\n    uint256 storageSlot;\\n    // The state of the asset for when it is written to storage\\n    AssetStorageState storageState;\\n}\\n\\n/// @dev Governance parameters for a cash group, total storage is 9 bytes + 7 bytes for liquidity token haircuts\\n/// and 7 bytes for rate scalars, total of 23 bytes. Note that this is stored packed in the storage slot so there\\n/// are no indexes stored for liquidityTokenHaircuts or rateScalars, maxMarketIndex is used instead to determine the\\n/// length.\\nstruct CashGroupSettings {\\n    // Index of the AMMs on chain that will be made available. Idiosyncratic fCash\\n    // that is dated less than the longest AMM will be tradable.\\n    uint8 maxMarketIndex;\\n    // Time window in minutes that the rate oracle will be averaged over\\n    uint8 rateOracleTimeWindowMin;\\n    // Total fees per trade, specified in BPS\\n    uint8 totalFeeBPS;\\n    // Share of the fees given to the protocol, denominated in percentage\\n    uint8 reserveFeeShare;\\n    // Debt buffer specified in 5 BPS increments\\n    uint8 debtBuffer5BPS;\\n    // fCash haircut specified in 5 BPS increments\\n    uint8 fCashHaircut5BPS;\\n    // If an account has a negative cash balance, it can be settled by incurring debt at the 3 month market. This\\n    // is the basis points for the penalty rate that will be added the current 3 month oracle rate.\\n    uint8 settlementPenaltyRate5BPS;\\n    // If an account has fCash that is being liquidated, this is the discount that the liquidator can purchase it for\\n    uint8 liquidationfCashHaircut5BPS;\\n    // If an account has fCash that is being liquidated, this is the discount that the liquidator can purchase it for\\n    uint8 liquidationDebtBuffer5BPS;\\n    // Liquidity token haircut applied to cash claims, specified as a percentage between 0 and 100\\n    uint8[] liquidityTokenHaircuts;\\n    // Rate scalar used to determine the slippage of the market\\n    uint8[] rateScalars;\\n}\\n\\n/// @dev Holds account level context information used to determine settlement and\\n/// free collateral actions. Total storage is 28 bytes\\nstruct AccountContext {\\n    // Used to check when settlement must be triggered on an account\\n    uint40 nextSettleTime;\\n    // For lenders that never incur debt, we use this flag to skip the free collateral check.\\n    bytes1 hasDebt;\\n    // Length of the account's asset array\\n    uint8 assetArrayLength;\\n    // If this account has bitmaps set, this is the corresponding currency id\\n    uint16 bitmapCurrencyId;\\n    // 9 total active currencies possible (2 bytes each)\\n    bytes18 activeCurrencies;\\n}\\n\\n/// @dev Used in view methods to return account balances in a developer friendly manner\\nstruct AccountBalance {\\n    uint256 currencyId;\\n    int256 cashBalance;\\n    int256 nTokenBalance;\\n    uint256 lastClaimTime;\\n    uint256 lastClaimIntegralSupply;\\n}\\n\\n/// @dev Asset rate used to convert between underlying cash and asset cash\\nstruct AssetRateParameters {\\n    // Address of the asset rate oracle\\n    address rateOracle;\\n    // The exchange rate from base to quote (if invert is required it is already done)\\n    int256 rate;\\n    // The decimals of the underlying, the rate converts to the underlying decimals\\n    int256 underlyingDecimals;\\n}\\n\"\r\n    },\r\n    \"openzeppelin-contracts-V4/token/ERC777/IERC777.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\n * {ERC1820Implementer}.\\n */\\ninterface IERC777 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For most token contracts, this value will equal 1.\\n     */\\n    function granularity() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external;\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external;\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    event Sent(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes data,\\n        bytes operatorData\\n    );\\n\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\n\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\n\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-contracts-V4/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-upgradeable/contracts/token/ERC777/IERC777Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777Token standard as defined in the EIP.\\n *\\n * This contract uses the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\\n * token holders and recipients react to token movements by using setting implementers\\n * for the associated interfaces in said registry. See {IERC1820Registry} and\\n * {ERC1820Implementer}.\\n */\\ninterface IERC777Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the smallest part of the token that is not divisible. This\\n     * means all token operations (creation, movement and destruction) must have\\n     * amounts that are a multiple of this number.\\n     *\\n     * For most token contracts, this value will equal 1.\\n     */\\n    function granularity() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by an account (`owner`).\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * If send or receive hooks are registered for the caller and `recipient`,\\n     * the corresponding functions will be called with `data` and empty\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function send(\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\\n     * total supply.\\n     *\\n     * If a send hook is registered for the caller, the corresponding function\\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - the caller must have at least `amount` tokens.\\n     */\\n    function burn(uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns true if an account is an operator of `tokenHolder`.\\n     * Operators can send and burn tokens on behalf of their owners. All\\n     * accounts are their own operator.\\n     *\\n     * See {operatorSend} and {operatorBurn}.\\n     */\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\n\\n    /**\\n     * @dev Make an account an operator of the caller.\\n     *\\n     * See {isOperatorFor}.\\n     *\\n     * Emits an {AuthorizedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function authorizeOperator(address operator) external;\\n\\n    /**\\n     * @dev Revoke an account's operator status for the caller.\\n     *\\n     * See {isOperatorFor} and {defaultOperators}.\\n     *\\n     * Emits a {RevokedOperator} event.\\n     *\\n     * Requirements\\n     *\\n     * - `operator` cannot be calling address.\\n     */\\n    function revokeOperator(address operator) external;\\n\\n    /**\\n     * @dev Returns the list of default operators. These accounts are operators\\n     * for all token holders, even if {authorizeOperator} was never called on\\n     * them.\\n     *\\n     * This list is immutable, but individual holders may revoke these via\\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\\n     */\\n    function defaultOperators() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\\n     * be an operator of `sender`.\\n     *\\n     * If send or receive hooks are registered for `sender` and `recipient`,\\n     * the corresponding functions will be called with `data` and\\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\\n     *\\n     * Emits a {Sent} event.\\n     *\\n     * Requirements\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `sender` must have at least `amount` tokens.\\n     * - the caller must be an operator for `sender`.\\n     * - `recipient` cannot be the zero address.\\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\\n     * interface.\\n     */\\n    function operatorSend(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\\n     * The caller must be an operator of `account`.\\n     *\\n     * If a send hook is registered for `account`, the corresponding function\\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\\n     *\\n     * Emits a {Burned} event.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     * - the caller must be an operator for `account`.\\n     */\\n    function operatorBurn(\\n        address account,\\n        uint256 amount,\\n        bytes calldata data,\\n        bytes calldata operatorData\\n    ) external;\\n\\n    event Sent(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount,\\n        bytes data,\\n        bytes operatorData\\n    );\\n\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\n\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\n\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-upgradeable/contracts/token/ERC777/IERC777RecipientUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Recipient.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\\n *\\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\\n * contract implement this interface (contract holders can be their own\\n * implementer) and registering it on the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\\n *\\n * See {IERC1820Registry} and {ERC1820Implementer}.\\n */\\ninterface IERC777RecipientUpgradeable {\\n    /**\\n     * @dev Called by an {IERC777} token contract whenever tokens are being\\n     * moved or created into a registered account (`to`). The type of operation\\n     * is conveyed by `from` being the zero address or not.\\n     *\\n     * This call occurs _after_ the token contract's state is updated, so\\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\\n     *\\n     * This function may revert to prevent the operation from being executed.\\n     */\\n    function tokensReceived(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-upgradeable/contracts/token/ERC777/IERC777SenderUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Sender.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\\n *\\n * {IERC777} Token holders can be notified of operations performed on their\\n * tokens by having a contract implement this interface (contract holders can be\\n * their own implementer) and registering it on the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\\n *\\n * See {IERC1820Registry} and {ERC1820Implementer}.\\n */\\ninterface IERC777SenderUpgradeable {\\n    /**\\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\\n     * is conveyed by `to` being the zero address or not.\\n     *\\n     * This call occurs _before_ the token contract's state is updated, so\\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\\n     *\\n     * This function may revert to prevent the operation from being executed.\\n     */\\n    function tokensToSend(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-upgradeable/contracts/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-upgradeable/contracts/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-upgradeable/contracts/utils/introspection/IERC1820RegistryUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC1820Registry.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the global ERC1820 Registry, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\\n * implementers for interfaces in this registry, as well as query support.\\n *\\n * Implementers may be shared by multiple accounts, and can also implement more\\n * than a single interface for each account. Contracts can implement interfaces\\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\\n * contract.\\n *\\n * {IERC165} interfaces can also be queried via the registry.\\n *\\n * For an in-depth explanation and source code analysis, see the EIP text.\\n */\\ninterface IERC1820RegistryUpgradeable {\\n    /**\\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\\n     * account is able to set interface implementers for it.\\n     *\\n     * By default, each account is its own manager. Passing a value of `0x0` in\\n     * `newManager` will reset the manager to this initial state.\\n     *\\n     * Emits a {ManagerChanged} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the current manager for `account`.\\n     */\\n    function setManager(address account, address newManager) external;\\n\\n    /**\\n     * @dev Returns the manager for `account`.\\n     *\\n     * See {setManager}.\\n     */\\n    function getManager(address account) external view returns (address);\\n\\n    /**\\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\\n     * `interfaceHash`.\\n     *\\n     * `account` being the zero address is an alias for the caller's address.\\n     * The zero address can also be used in `implementer` to remove an old one.\\n     *\\n     * See {interfaceHash} to learn how these are created.\\n     *\\n     * Emits an {InterfaceImplementerSet} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the current manager for `account`.\\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\\n     * end in 28 zeroes).\\n     * - `implementer` must implement {IERC1820Implementer} and return true when\\n     * queried for support, unless `implementer` is the caller. See\\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\\n     */\\n    function setInterfaceImplementer(\\n        address account,\\n        bytes32 _interfaceHash,\\n        address implementer\\n    ) external;\\n\\n    /**\\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\\n     * implementer is registered, returns the zero address.\\n     *\\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\\n     * zeroes), `account` will be queried for support of it.\\n     *\\n     * `account` being the zero address is an alias for the caller's address.\\n     */\\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\\n\\n    /**\\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\\n     * corresponding\\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\\n     */\\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\\n\\n    /**\\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\\n     * @param account Address of the contract for which to update the cache.\\n     * @param interfaceId ERC165 interface for which to update the cache.\\n     */\\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\\n\\n    /**\\n     * @notice Checks whether a contract implements an ERC165 interface or not.\\n     * If the result is not cached a direct lookup on the contract address is performed.\\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\\n     * {updateERC165Cache} with the contract address.\\n     * @param account Address of the contract to check.\\n     * @param interfaceId ERC165 interface to check.\\n     * @return True if `account` implements `interfaceId`, false otherwise.\\n     */\\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\\n\\n    /**\\n     * @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\\n     * @param account Address of the contract to check.\\n     * @param interfaceId ERC165 interface to check.\\n     * @return True if `account` implements `interfaceId`, false otherwise.\\n     */\\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\\n\\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\\n\\n    event ManagerChanged(address indexed account, address indexed newManager);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract INotionalV2\",\"name\":\"_notionalProxy\",\"type\":\"address\"},{\"internalType\":\"contract IWETH9\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"Sent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NotionalV2\",\"outputs\":[{\"internalType\":\"contract INotionalV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract IWETH9\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"convertToAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"convertToShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAssetToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"assetToken\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"underlyingPrecision\",\"type\":\"int256\"},{\"internalType\":\"enum TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrencyId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDecodedID\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"uint40\",\"name\":\"maturity\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarketIndex\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaturity\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"maturity\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"useUnderlying\",\"type\":\"bool\"}],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isETH\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnderlyingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"underlyingToken\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"underlyingPrecision\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getfCashId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasMatured\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"},{\"internalType\":\"uint40\",\"name\":\"maturity\",\"type\":\"uint40\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositAmountExternal\",\"type\":\"uint256\"},{\"internalType\":\"uint88\",\"name\":\"fCashAmount\",\"type\":\"uint88\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"minImpliedRate\",\"type\":\"uint32\"}],\"name\":\"mintViaAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositAmountExternal\",\"type\":\"uint256\"},{\"internalType\":\"uint88\",\"name\":\"fCashAmount\",\"type\":\"uint88\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"minImpliedRate\",\"type\":\"uint32\"}],\"name\":\"mintViaUnderlying\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noop\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"redeemToUnderlying\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"transferfCash\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"maxImpliedRate\",\"type\":\"uint32\"}],\"internalType\":\"struct IWrappedfCash.RedeemOpts\",\"name\":\"opts\",\"type\":\"tuple\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"maxImpliedRate\",\"type\":\"uint32\"}],\"name\":\"redeemToAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"maxImpliedRate\",\"type\":\"uint32\"}],\"name\":\"redeemToUnderlying\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"send\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "WrappedfCash", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001344a36a1b56144c3bc62e7757377d288fde0369000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}