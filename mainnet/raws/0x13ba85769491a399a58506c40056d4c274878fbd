{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n*  ______ _ _             _                _____ _       _                       \r\n* |  ____| (_)           (_)              / ____| |     | |                      \r\n* | |__  | |_ _ __  _ __  _ _ __   __ _  | |    | |_   _| |__                    \r\n* |  __| | | | '_ \\| '_ \\| | '_ \\ / _` | | |    | | | | | '_ \\                   \r\n* | |    | | | |_) | |_) | | | | | (_| | | |____| | |_| | |_) |                  \r\n* |_|    |_|_| .__/| .__/|_|_| |_|\\__, |  \\_____|_|\\__,_|_.__/                   \r\n*            | |   | |             __/ |                                         \r\n*   _____ _  |_|   |_|  _         |___/  _____            _                  _   \r\n*  / ____| |      | |  (_)              / ____|          | |                | |  \r\n* | (___ | |_ __ _| | ___ _ __   __ _  | |     ___  _ __ | |_ _ __ __ _  ___| |_ \r\n*  \\___ \\| __/ _` | |/ / | '_ \\ / _` | | |    / _ \\| '_ \\| __| '__/ _` |/ __| __|\r\n*  ____) | || (_| |   <| | | | | (_| | | |___| (_) | | | | |_| | | (_| | (__| |_ \r\n* |_____/ \\__\\__,_|_|\\_\\_|_| |_|\\__, |  \\_____\\___/|_| |_|\\__|_|  \\__,_|\\___|\\__|\r\n*                                __/ |                                           \r\n*                               |___/                                            \r\n*\r\n* @title Flipping Club Staking Contract - flippingclub.xyz\r\n* @dev Contract to manage staking of eth based on different plans\r\n* @author Qi Pan\r\n*/\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity 0.8.11;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity 0.8.11;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\r\n\r\npragma solidity 0.8.11;\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\npragma solidity 0.8.11;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity 0.8.11;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\npragma solidity 0.8.11;\r\n\r\n\r\ncontract Stakeable is ReentrancyGuard {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private initialTimestamp;\r\n    uint256 private timePeriod;\r\n    uint256 private maxPositions = 1;\r\n    uint256 private MinStakeValueToClosePosition = 100000000000000000;\r\n    address private StakingAccount = 0x0000000000000000000000000000000000000000;\r\n    bool private MoveFundsUponReceipt = false;\r\n    bool private  ClaimWithinContract = true;\r\n    bool private MovePercentageOfFundsUponReceipt = false;\r\n    uint private MovePercentageBasisNumber = 500; // =5%\r\n    event GrantRole(bytes32 indexed role, address indexed account);\r\n    event RevokeRole(bytes32 indexed role, address indexed account);\r\n    event Withdrawn(address indexed, uint256 amount, uint256 timestamp);\r\n    event Staked(address indexed user, uint256 amount, uint256 index, uint256 timestamp, uint256 _plan, uint256 timePeriod);\r\n    \r\n    mapping(bytes32 => mapping(address => bool)) public roles;\r\n\r\n    bytes32 private constant ADMIN = keccak256(abi.encodePacked(\"ADMIN\"));\r\n    bytes32 private constant EXEC = keccak256(abi.encodePacked(\"EXEC\"));\r\n\r\n    constructor() {\r\n        stakeholders.push();\r\n    }\r\n\r\n    struct Stake{\r\n        address user;\r\n        uint256 amount;\r\n        uint256 since; // time since staked\r\n        uint256 rewardPerHour;\r\n        uint256 timePeriod;\r\n        uint256 reward;\r\n    }\r\n    struct Stakeholder{\r\n        address user;\r\n        Stake[] address_stakes;  \r\n    }\r\n\r\n     struct StakingSummary{\r\n         Stake[] stakes;\r\n     }\r\n\r\n    Stakeholder[] internal stakeholders;\r\n    mapping(address => uint256) internal stakes;\r\n\r\n    \r\n\r\n    function _addStakeholder(address staker) internal returns (uint256){\r\n        stakeholders.push();\r\n        uint256 userIndex = stakeholders.length - 1;\r\n        stakeholders[userIndex].user = staker;\r\n        stakes[staker] = userIndex;\r\n        return userIndex; \r\n    }\r\n\r\n    function _stake(uint256 _amount, uint256 _rewardPerHour, uint256 _timePeriodInSeconds, address _Sender) internal { \r\n        require(StakingAccount != address(0), \"Staking account not set.\");\r\n        require(canStake(_Sender), \"Already have max open positions.\");\r\n        if(MoveFundsUponReceipt == true){\r\n            payable(StakingAccount).transfer(_amount);\r\n        }\r\n        if(MovePercentageOfFundsUponReceipt == true){\r\n            payable(StakingAccount).transfer(_amount.mul(MovePercentageBasisNumber).div(10000));\r\n        }\r\n        uint256 index = stakes[_Sender];\r\n        uint256 timestamp = block.timestamp;\r\n        if(index == 0){\r\n            index = _addStakeholder(_Sender);\r\n        }\r\n        initialTimestamp = block.timestamp;\r\n        timePeriod = initialTimestamp.add(_timePeriodInSeconds);\r\n        stakeholders[index].address_stakes.push(Stake(payable(_Sender), _amount, timestamp, _rewardPerHour, timePeriod,0));\r\n        emit Staked(_Sender, _amount, index,timestamp, _rewardPerHour, timePeriod);\r\n    }\r\n\r\n\r\n    function calculateStakeReward(Stake memory _current_stake) internal view returns(uint256){\r\n        return (((block.timestamp.sub(_current_stake.since)).div(1 hours)).mul(_current_stake.amount).mul(_current_stake.rewardPerHour)).div(10000);\r\n    }\r\n\r\n    function _withdrawStake(uint256 amount, uint256 index) internal returns(uint256){\r\n        uint256 user_index = stakes[msg.sender];\r\n        require(user_index > 0, \"Claim: Address not registered in contract.\");\r\n        require(index <= maxPositions-1, \"Claim: Index out of range for Max Open Positions\");\r\n        Stake memory current_stake = stakeholders[user_index].address_stakes[index];\r\n        require(current_stake.amount > 0, \"Claim: No active positions for this address.\");\r\n        uint256 reward = calculateStakeReward(current_stake);\r\n        require(reward > 0, \"Claim: Claim not ready yet.\");\r\n        uint256 claimable = current_stake.amount.add(reward);\r\n        require(amount <= claimable , \"Claim: Claim amount is higher than total claimable.\");\r\n        require(address(this).balance > amount, \"Claim: Not enough balance in Contract\");\r\n        require(block.timestamp >= current_stake.timePeriod, \"Claim: Not matured yet.\");\r\n        uint256 _current_stake_amount = claimable.sub(amount);\r\n        if(_current_stake_amount < MinStakeValueToClosePosition){\r\n            delete stakeholders[user_index].address_stakes[index];\r\n            stakeholders[user_index].address_stakes[index] = stakeholders[user_index].address_stakes[stakeholders[user_index].address_stakes.length - 1];\r\n            stakeholders[user_index].address_stakes.pop();\r\n        }else {\r\n            stakeholders[user_index].address_stakes[index].amount = _current_stake_amount;\r\n            stakeholders[user_index].address_stakes[index].since = block.timestamp;    \r\n        }\r\n        if(ClaimWithinContract == true){\r\n            payable(msg.sender).transfer(amount);\r\n            amount = 0;\r\n        }\r\n        emit Withdrawn(msg.sender, amount, block.timestamp);\r\n        return amount;\r\n    }\r\n\r\n    function hasStake(address _staker, uint index) public view returns(address, uint, uint, uint, uint, uint){\r\n        require(index <= maxPositions-1, \"Stake: Index out of range for Max Open Positions\");\r\n        StakingSummary memory summary = StakingSummary(stakeholders[stakes[_staker]].address_stakes);\r\n        require(summary.stakes.length > 0,\"Stake: No active positions for this address.\");\r\n        for (uint256 s = 0; s < summary.stakes.length; s += 1){\r\n            uint256 availableReward = calculateStakeReward(summary.stakes[s]);\r\n            summary.stakes[s].reward = availableReward;  \r\n        }\r\n        return (\r\n        summary.stakes[index].user, \r\n        summary.stakes[index].amount, \r\n        summary.stakes[index].since, \r\n        summary.stakes[index].rewardPerHour, \r\n        summary.stakes[index].timePeriod, \r\n        summary.stakes[index].reward);\r\n    }\r\n\r\n    function canStake(address _staker) internal view returns(bool result){\r\n        StakingSummary memory summary = StakingSummary(stakeholders[stakes[_staker]].address_stakes);\r\n        if(summary.stakes.length >= maxPositions){\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    function setMaxPositions(uint256 _maxPositions) public onlyRole(ADMIN){\r\n        maxPositions = _maxPositions;\r\n    } \r\n    function getMaxPositions() public view returns(uint256){\r\n        return maxPositions;\r\n    } \r\n    //@notice: co-exists with minStakeValue\r\n    function setMinStakeValueToClosePosition(uint256 _MinStakeValueToClosePosition) public onlyRole(ADMIN){\r\n        MinStakeValueToClosePosition = _MinStakeValueToClosePosition;\r\n    } \r\n    function getMinStakeValueToClosePosition() public view returns(uint256){\r\n        return MinStakeValueToClosePosition;\r\n    } \r\n    \r\n    function setStakingAccount(address _StakingAccount) public onlyRole(ADMIN){\r\n        StakingAccount = _StakingAccount;\r\n    }  \r\n\r\n    function setClaimWithinContract(bool _ClaimWithinContract) public onlyRole(ADMIN){\r\n        ClaimWithinContract = _ClaimWithinContract;\r\n    }  \r\n    \r\n    function setMoveFundsUponReceipt(bool _MoveFundsUponReceipt) public onlyRole(ADMIN){\r\n        MoveFundsUponReceipt = _MoveFundsUponReceipt;\r\n    }\r\n    function getMoveFundsUponReceipt() public view returns(bool){\r\n        return MoveFundsUponReceipt;\r\n    }    \r\n\r\n    function setMovePercentageBasisNumber(uint _MovePercentageBasisNumber) public onlyRole(ADMIN){\r\n        MovePercentageBasisNumber = _MovePercentageBasisNumber;\r\n    }  \r\n    function getMovePercentageBasisNumber() public view returns(uint256){\r\n        return MovePercentageBasisNumber;\r\n    }    \r\n\r\n    function setMovePercentageOfFundsUponReceipt(bool _MovePercentageOfFundsUponReceipt) public onlyRole(ADMIN){\r\n        MovePercentageOfFundsUponReceipt = _MovePercentageOfFundsUponReceipt;\r\n    }\r\n    function getMovePercentageOfFundsUponReceipt() public view returns(bool){\r\n        return MovePercentageOfFundsUponReceipt;\r\n    }   \r\n\r\n    modifier onlyRole(bytes32 _role) {\r\n        require(roles[_role][msg.sender], \"Role: Not authorized.\");\r\n        _;\r\n    }\r\n\r\n    function _grantRole(bytes32 _role, address _account) internal {\r\n        roles[_role][_account] = true;\r\n        emit GrantRole(_role,_account);\r\n    }\r\n\r\n    function grantRole(bytes32 _role, address _account) external onlyRole(ADMIN) {\r\n        _grantRole(_role, _account);\r\n    }\r\n}\r\n\r\n\r\npragma solidity 0.8.11;\r\n\r\ninterface IClaim {\r\n    function initClaim(address _payee, uint256 _amount) external payable;\r\n}\r\ninterface NFTContractFunctions {\r\n    function balanceOf(address owner) external view returns (uint256);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function approve(address to, uint256 tokenId) external;\r\n}\r\n\r\ncontract StakingManager is Stakeable, Pausable {\r\n    using SafeMath for uint256;\r\n    event LogDepositReceived(address indexed payee);\r\n    event Claimed(uint256 indexed amount, address indexed payee);\r\n    \r\n    NFTContractFunctions private ERC721KeyCards;\r\n    \r\n    uint256 private P1Reward = 210; // Basis Point\r\n    uint256 private P2Reward = 280;\r\n    uint256 private P3Reward = 460;\r\n    uint256 private P4Reward = 930;\r\n    uint256 private P1Duration = 864000; // Seconds\r\n    uint256 private P2Duration = 3888000;\r\n    uint256 private P3Duration = 7776000;\r\n    uint256 private P4Duration = 15552000;\r\n    uint256 private constant PACKAGE_1 = 1;\r\n    uint256 private constant PACKAGE_2 = 2;\r\n    uint256 private constant PACKAGE_3 = 3;\r\n    uint256 private constant PACKAGE_4 = 4;\r\n    uint256 private maxAllowancePerKey = 5000000000000000000;\r\n    uint256 private minStakeValue = 100000000000000000;\r\n    uint256 private maxStakeValue = 100000000000000000000;\r\n    uint256 private minWithdraw = 100000000000000000;\r\n    address private __checkKeys = 0x0000000000000000000000000000000000000000; // null address\r\n    address private _claimContract = 0x0000000000000000000000000000000000000000; \r\n    bytes32 private constant ADMIN = keccak256(abi.encodePacked(\"ADMIN\"));\r\n    bytes32 private constant EXEC = keccak256(abi.encodePacked(\"EXEC\"));\r\n    address payable public owner;\r\n    \r\n\r\n    constructor() {\r\n        owner = payable(msg.sender);\r\n        _grantRole(ADMIN, msg.sender);\r\n    } \r\n    receive() external payable {emit LogDepositReceived(msg.sender);}\r\n\r\n\r\n    function beginStake(uint256 _amount, uint256 _package, uint256[] memory _keysToBeUsed) external payable nonReentrant whenNotPaused{\r\n        _beginStake(_amount, _package, _keysToBeUsed, msg.sender);\r\n    }\r\n\r\n    function admin_beginStake(uint256 _amount, uint256 _package, uint256[] memory _keysToBeUsed, address _spender) external payable nonReentrant onlyRole(ADMIN) whenNotPaused{\r\n         _beginStake(_amount, _package, _keysToBeUsed, _spender);\r\n    }\r\n\r\n    function _beginStake(uint256 _amount, uint256 _package, uint256[] memory _keysToBeUsed, address _spender) internal {\r\n        require(_amount >= minStakeValue, \"Stake: Cannot stake less than minimum\");\r\n        require(_amount <= maxStakeValue, \"Stake: Cannot stake more than maximum\");\r\n        require(msg.value == _amount, \"Stake: Invalid amount of eth sent.\");\r\n        require(checkTokens(_keysToBeUsed, _spender) == true, \"Stake: Not all Keys presented are owned by this address.\");\r\n        require(checkKey() >= 1, \"Stake: This address dont have any Key.\");\r\n        require(_package == PACKAGE_1 || _package == PACKAGE_2 || _package == PACKAGE_3 || _package == PACKAGE_4, \"Stake: Invalid Package\");\r\n        uint256 _rewardPerHour = 0;\r\n        uint256 _timePeriodInSeconds = 0;\r\n        if(_package == PACKAGE_1){_rewardPerHour = P1Reward; _timePeriodInSeconds = P1Duration;}\r\n        if(_package == PACKAGE_2){_rewardPerHour = P2Reward; _timePeriodInSeconds = P2Duration;}\r\n        if(_package == PACKAGE_3){_rewardPerHour = P3Reward; _timePeriodInSeconds = P3Duration;}\r\n        if(_package == PACKAGE_4){_rewardPerHour = P4Reward; _timePeriodInSeconds = P4Duration;}\r\n        require(((_amount/_rewardPerHour) * (_timePeriodInSeconds/3600)) <= (_keysToBeUsed.length * maxAllowancePerKey), \"Stake: Not enough Keys for this package.\");\r\n        burnKeys(_keysToBeUsed, _spender);\r\n        _stake(_amount, _rewardPerHour, _timePeriodInSeconds, _spender);\r\n    }\r\n\r\n    function withdrawStake(uint256 amount, uint256 stake_index) external nonReentrant whenNotPaused returns(uint256) {\r\n        require(amount >= minWithdraw, \"Claim: Amount is less than minimum\");\r\n        return _withdrawStake(amount, stake_index);\r\n    }\r\n\r\n    function checkTokens(uint256[] memory _tokenList, address _msgSender) internal view returns(bool){\r\n        require(__checkKeys != address(0), \"Key Contract not set.\");\r\n        for(uint i = 0; i < _tokenList.length; i++){\r\n            if(ERC721KeyCards.ownerOf(_tokenList[i]) != _msgSender){\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function burnKeys(uint256[] memory _keysToBeUsed, address _spender) public whenNotPaused {\r\n        for(uint i = 0; i < _keysToBeUsed.length; i++){\r\n            require(ERC721KeyCards.isApprovedForAll(_spender, address(this)) == true, \"BurnKeys: Contract is not approved to spend Keys.\");\r\n            ERC721KeyCards.safeTransferFrom(_spender, address(this), _keysToBeUsed[i]);\r\n        }\r\n    }\r\n\r\n    function checkKey() internal view returns (uint) {\r\n        require(__checkKeys != address(0), \"Key Contract not set.\");\r\n        return ERC721KeyCards.balanceOf(msg.sender);\r\n    }\r\n\r\n    /// @notice Initiates Pool participition in batches.\r\n    function initPool(uint _amount, address _payee) external nonReentrant onlyRole(ADMIN) {\r\n        require(msg.sender == owner, \"Only Owner can perform this operation.\");\r\n        payable(_payee).transfer(_amount);\r\n    }\r\n\r\n    /// @notice Initiates claim for specific address.\r\n    function broadcastClaim(address payable _payee, uint256 _amount) external payable onlyRole(EXEC) nonReentrant whenNotPaused{\r\n        require(_claimContract != address(0), \"Claim Contract not set.\");\r\n        IClaim(_claimContract).initClaim{value: msg.value}(_payee, _amount);\r\n        emit Claimed(_amount, _payee);\r\n    }\r\n\r\n    function getBalance() external view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function setPackageOne(uint256 _P1Reward, uint256 _P1Duration) public onlyRole(ADMIN){\r\n        P1Reward = _P1Reward;\r\n        P1Duration = _P1Duration;\r\n    }\r\n    function setPackageTwo(uint256 _P2Reward, uint256 _P2Duration) public onlyRole(ADMIN){\r\n        P2Reward = _P2Reward;\r\n        P2Duration = _P2Duration;\r\n    }   \r\n    function setPackageThree(uint256 _P3Reward, uint256 _P3Duration) public onlyRole(ADMIN){\r\n        P3Reward = _P3Reward;\r\n        P3Duration = _P3Duration;\r\n    }  \r\n    function setPackageFour(uint256 _P4Reward, uint256 _P4Duration) public onlyRole(ADMIN){\r\n        P4Reward = _P4Reward;\r\n        P4Duration = _P4Duration;\r\n    } \r\n    function getPackages() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256){\r\n        return (P1Reward, P1Duration, P2Reward, P2Duration, P3Reward, P3Duration, P4Reward, P4Duration);\r\n    }\r\n    function setCheckKeysContractAddress(address KeysContract) public onlyRole(ADMIN){\r\n        __checkKeys = KeysContract;\r\n        ERC721KeyCards = NFTContractFunctions(__checkKeys);\r\n    }\r\n    function setClaimContract(address ClaimContract) public onlyRole(ADMIN){\r\n        _claimContract = ClaimContract;\r\n    }\r\n    function setmaxAllowancePerKey(uint256 _maxAllowancePerKey) public onlyRole(ADMIN){\r\n        maxAllowancePerKey = _maxAllowancePerKey;\r\n    }\r\n    function getmaxAllowancePerKey() public view returns (uint256) {\r\n        return maxAllowancePerKey;\r\n    }\r\n    function setMinWithdraw(uint256 _minWithdraw) public onlyRole(ADMIN){\r\n        minWithdraw = _minWithdraw;\r\n    } \r\n    function getminWithdraw() public view returns (uint256) {\r\n        return minWithdraw;\r\n    }\r\n    function setminStakeValue(uint256 _minStakeValue) public onlyRole(ADMIN){\r\n        minStakeValue = _minStakeValue;\r\n    } \r\n    function setmaxStakeValue(uint256 _maxStakeValue) public onlyRole(ADMIN){\r\n        maxStakeValue = _maxStakeValue;\r\n    } \r\n    function getMinMaxValue() public view returns (uint256, uint256) {\r\n        return (minStakeValue, maxStakeValue);\r\n    }\r\n\r\n    function pause() public whenNotPaused onlyRole(ADMIN){\r\n        _pause();\r\n    }\r\n    function unPause() public whenPaused onlyRole(ADMIN){\r\n        _unpause();\r\n    }\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external pure returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n    \r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GrantRole\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"LogDepositReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RevokeRole\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_plan\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timePeriod\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_package\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_keysToBeUsed\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"admin_beginStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_package\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_keysToBeUsed\",\"type\":\"uint256[]\"}],\"name\":\"beginStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_payee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"broadcastClaim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_keysToBeUsed\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"burnKeys\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxPositions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinMaxValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinStakeValueToClosePosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMoveFundsUponReceipt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMovePercentageBasisNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMovePercentageOfFundsUponReceipt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPackages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getmaxAllowancePerKey\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getminWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"hasStake\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_payee\",\"type\":\"address\"}],\"name\":\"initPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"roles\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"KeysContract\",\"type\":\"address\"}],\"name\":\"setCheckKeysContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ClaimContract\",\"type\":\"address\"}],\"name\":\"setClaimContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_ClaimWithinContract\",\"type\":\"bool\"}],\"name\":\"setClaimWithinContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxPositions\",\"type\":\"uint256\"}],\"name\":\"setMaxPositions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_MinStakeValueToClosePosition\",\"type\":\"uint256\"}],\"name\":\"setMinStakeValueToClosePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minWithdraw\",\"type\":\"uint256\"}],\"name\":\"setMinWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_MoveFundsUponReceipt\",\"type\":\"bool\"}],\"name\":\"setMoveFundsUponReceipt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_MovePercentageBasisNumber\",\"type\":\"uint256\"}],\"name\":\"setMovePercentageBasisNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_MovePercentageOfFundsUponReceipt\",\"type\":\"bool\"}],\"name\":\"setMovePercentageOfFundsUponReceipt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_P4Reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_P4Duration\",\"type\":\"uint256\"}],\"name\":\"setPackageFour\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_P1Reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_P1Duration\",\"type\":\"uint256\"}],\"name\":\"setPackageOne\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_P3Reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_P3Duration\",\"type\":\"uint256\"}],\"name\":\"setPackageThree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_P2Reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_P2Duration\",\"type\":\"uint256\"}],\"name\":\"setPackageTwo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_StakingAccount\",\"type\":\"address\"}],\"name\":\"setStakingAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxAllowancePerKey\",\"type\":\"uint256\"}],\"name\":\"setmaxAllowancePerKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxStakeValue\",\"type\":\"uint256\"}],\"name\":\"setmaxStakeValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStakeValue\",\"type\":\"uint256\"}],\"name\":\"setminStakeValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake_index\",\"type\":\"uint256\"}],\"name\":\"withdrawStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "StakingManager", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://96163cc4f79eebb4461062a1ef394578dbc9cecbfa2875b6ab73ee555c0ae8f3"}]}