{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.13;\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0-rc.0) (token/ERC20/IERC20.sol)\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n/// @notice An error used to indicate that an argument passed to a function is illegal or\r\n///         inappropriate.\r\n///\r\n/// @param message The error message.\r\nerror IllegalArgument(string message);\r\n\r\n/// @notice An error used to indicate that a function has encountered an unrecoverable state.\r\n///\r\n/// @param message The error message.\r\nerror IllegalState(string message);\r\n\r\n/// @notice An error used to indicate that an operation is unsupported.\r\n///\r\n/// @param message The error message.\r\nerror UnsupportedOperation(string message);\r\n\r\n/// @notice An error used to indicate that a message sender tried to execute a privileged function.\r\n///\r\n/// @param message The error message.\r\nerror Unauthorized(string message);\r\n/// @title  Multicall\r\n/// @author Uniswap Labs\r\n///\r\n/// @notice Enables calling multiple methods in a single call to the contract\r\nabstract contract Multicall {\r\n    error MulticallFailed(bytes data, bytes result);\r\n\r\n    function multicall(\r\n        bytes[] calldata data\r\n    ) external payable returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n\r\n            if (!success) {\r\n                revert MulticallFailed(data[i], result);\r\n            }\r\n\r\n            results[i] = result;\r\n        }\r\n    }\r\n}\r\n/// @title  Mutex\r\n/// @author Alchemix Finance\r\n///\r\n/// @notice Provides a mutual exclusion lock for implementing contracts.\r\nabstract contract Mutex {\r\n    enum State {\r\n        RESERVED,\r\n        UNLOCKED,\r\n        LOCKED\r\n    }\r\n\r\n    /// @notice The lock state.\r\n    State private _lockState = State.UNLOCKED;\r\n\r\n    /// @dev A modifier which acquires the mutex.\r\n    modifier lock() {\r\n        _claimLock();\r\n\r\n        _;\r\n\r\n        _freeLock();\r\n    }\r\n\r\n    /// @dev Gets if the mutex is locked.\r\n    ///\r\n    /// @return if the mutex is locked.\r\n    function _isLocked() internal view returns (bool) {\r\n        return _lockState == State.LOCKED;\r\n    }\r\n\r\n    /// @dev Claims the lock. If the lock is already claimed, then this will revert.\r\n    function _claimLock() internal {\r\n        // Check that the lock has not been claimed yet.\r\n        if (_lockState != State.UNLOCKED) {\r\n            revert IllegalState(\"Lock already claimed\");\r\n        }\r\n\r\n        // Claim the lock.\r\n        _lockState = State.LOCKED;\r\n    }\r\n\r\n    /// @dev Frees the lock.\r\n    function _freeLock() internal {\r\n        _lockState = State.UNLOCKED;\r\n    }\r\n}\r\n\r\n/// @title  IERC20TokenReceiver\r\n/// @author Alchemix Finance\r\ninterface IERC20TokenReceiver {\r\n    /// @notice Informs implementors of this interface that an ERC20 token has been transferred.\r\n    ///\r\n    /// @param token The token that was transferred.\r\n    /// @param value The amount of the token that was transferred.\r\n    function onERC20Received(address token, uint256 value) external;\r\n}\r\n/// @title  IERC20Metadata\r\n/// @author Alchemix Finance\r\ninterface IERC20Metadata {\r\n    /// @notice Gets the name of the token.\r\n    ///\r\n    /// @return The name.\r\n    function name() external view returns (string memory);\r\n\r\n    /// @notice Gets the symbol of the token.\r\n    ///\r\n    /// @return The symbol.\r\n    function symbol() external view returns (string memory);\r\n\r\n    /// @notice Gets the number of decimals that the token has.\r\n    ///\r\n    /// @return The number of decimals.\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n/// @title IWETH9\r\ninterface IWETH9 is IERC20, IERC20Metadata {\r\n  /// @notice Deposits `msg.value` ethereum into the contract and mints `msg.value` tokens.\r\n  function deposit() external payable;\r\n\r\n  /// @notice Burns `amount` tokens to retrieve `amount` ethereum from the contract.\r\n  ///\r\n  /// @dev This version of WETH utilizes the `transfer` function which hard codes the amount of gas\r\n  ///      that is allowed to be utilized to be exactly 2300 when receiving ethereum.\r\n  ///\r\n  /// @param amount The amount of tokens to burn.\r\n  function withdraw(uint256 amount) external;\r\n}\r\ninterface IConvexBooster {\r\n    function deposit(uint256 pid, uint256 amount, bool stake) external returns (bool);\r\n    function withdraw(uint256 pid, uint256 amount) external returns (bool);\r\n}\r\ninterface IConvexRewards {\r\n    function rewardToken() external view returns (IERC20);\r\n    function earned(address account) external view returns (uint256);\r\n    function extraRewards(uint256 index) external view returns (address);\r\n    function balanceOf(address account) external returns(uint256);\r\n    function withdraw(uint256 amount, bool claim) external returns (bool);\r\n    function withdrawAndUnwrap(uint256 amount, bool claim) external returns (bool);\r\n    function getReward() external returns (bool);\r\n    function getReward(address recipient, bool claim) external returns (bool);\r\n    function stake(uint256 amount) external returns (bool);\r\n    function stakeFor(address account, uint256 amount) external returns (bool);\r\n}\r\ninterface IConvexToken is IERC20 {\r\n    function maxSupply() external view returns (uint256);\r\n    function totalCliffs() external view returns (uint256);\r\n    function reductionPerCliff() external view returns (uint256);\r\n}\r\n\r\nuint256 constant N_COINS = 2;\r\n\r\ninterface IEthStableMetaPool is IERC20 {\r\n    function get_balances() external view returns (uint256[N_COINS] memory);\r\n\r\n    function coins(uint256 index) external view returns (IERC20);\r\n\r\n    function A() external view returns (uint256);\r\n\r\n    function get_virtual_price() external view returns (uint256);\r\n\r\n    function calc_token_amount(\r\n        uint256[N_COINS] calldata amounts,\r\n        bool deposit\r\n    ) external view returns (uint256 amount);\r\n\r\n    function add_liquidity(\r\n        uint256[N_COINS] calldata amounts,\r\n        uint256 minimumMintAmount\r\n    ) external payable returns (uint256 minted);\r\n\r\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256 dy);\r\n\r\n    function get_dy_underlying(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256[N_COINS] calldata balances\r\n    ) external view returns (uint256 dy);\r\n\r\n    function exchange(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 minimumDy\r\n    ) external payable returns (uint256);\r\n\r\n    function remove_liquidity(uint256 amount, uint256[N_COINS] calldata minimumAmounts) external;\r\n\r\n    function remove_liquidity_imbalance(\r\n        uint256[N_COINS] calldata amounts,\r\n        uint256 maximumBurnAmount\r\n    ) external returns (uint256);\r\n\r\n    function calc_withdraw_one_coin(uint256 tokenAmount, int128 i) external view returns (uint256);\r\n\r\n    function remove_liquidity_one_coin(\r\n        uint256 tokenAmount,\r\n        int128 i,\r\n        uint256 minimumAmount\r\n    ) external returns (uint256);\r\n\r\n    function get_price_cumulative_last() external view returns (uint256[N_COINS] calldata);\r\n\r\n    function block_timestamp_last() external view returns (uint256);\r\n\r\n    function get_twap_balances(\r\n        uint256[N_COINS] calldata firstBalances,\r\n        uint256[N_COINS] calldata lastBalances,\r\n        uint256 timeElapsed\r\n    ) external view returns (uint256[N_COINS] calldata);\r\n\r\n    function get_dy(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256[N_COINS] calldata balances\r\n    ) external view returns (uint256);\r\n}\r\n\r\n/// @title  SafeERC20\r\n/// @author Alchemix Finance\r\nlibrary SafeERC20 {\r\n    /// @notice An error used to indicate that a call to an ERC20 contract failed.\r\n    ///\r\n    /// @param target  The target address.\r\n    /// @param success If the call to the token was a success.\r\n    /// @param data    The resulting data from the call. This is error data when the call was not a\r\n    ///                success. Otherwise, this is malformed data when the call was a success.\r\n    error ERC20CallFailed(address target, bool success, bytes data);\r\n\r\n    /// @dev A safe function to get the decimals of an ERC20 token.\r\n    ///\r\n    /// @dev Reverts with a {CallFailed} error if execution of the query fails or returns an\r\n    ///      unexpected value.\r\n    ///\r\n    /// @param token The target token.\r\n    ///\r\n    /// @return The amount of decimals of the token.\r\n    function expectDecimals(address token) internal view returns (uint8) {\r\n        (bool success, bytes memory data) = token.staticcall(\r\n            abi.encodeWithSelector(IERC20Metadata.decimals.selector)\r\n        );\r\n\r\n        if (!success || data.length < 32) {\r\n            revert ERC20CallFailed(token, success, data);\r\n        }\r\n\r\n        return abi.decode(data, (uint8));\r\n    }\r\n\r\n    /// @dev Transfers tokens to another address.\r\n    ///\r\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer failed or returns an\r\n    ///      unexpected value.\r\n    ///\r\n    /// @param token     The token to transfer.\r\n    /// @param recipient The address of the recipient.\r\n    /// @param amount    The amount of tokens to transfer.\r\n    function safeTransfer(address token, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(IERC20.transfer.selector, recipient, amount)\r\n        );\r\n\r\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\r\n            revert ERC20CallFailed(token, success, data);\r\n        }\r\n    }\r\n\r\n    /// @dev Approves tokens for the smart contract.\r\n    ///\r\n    /// @dev Reverts with a {CallFailed} error if execution of the approval fails or returns an\r\n    ///      unexpected value.\r\n    ///\r\n    /// @param token   The token to approve.\r\n    /// @param spender The contract to spend the tokens.\r\n    /// @param value   The amount of tokens to approve.\r\n    function safeApprove(address token, address spender, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(IERC20.approve.selector, spender, value)\r\n        );\r\n\r\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\r\n            revert ERC20CallFailed(token, success, data);\r\n        }\r\n    }\r\n\r\n    /// @dev Transfer tokens from one address to another address.\r\n    ///\r\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer fails or returns an\r\n    ///      unexpected value.\r\n    ///\r\n    /// @param token     The token to transfer.\r\n    /// @param owner     The address of the owner.\r\n    /// @param recipient The address of the recipient.\r\n    /// @param amount    The amount of tokens to transfer.\r\n    function safeTransferFrom(address token, address owner, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(IERC20.transferFrom.selector, owner, recipient, amount)\r\n        );\r\n\r\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\r\n            revert ERC20CallFailed(token, success, data);\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice A struct used to define initialization parameters. This is not included\r\n///         in the contract to prevent naming collisions.\r\nstruct InitializationParams {\r\n    address admin;\r\n    address operator;\r\n    address rewardReceiver;\r\n    address transmuterBuffer;\r\n    IWETH9 weth;\r\n    IERC20 curveToken;\r\n    IEthStableMetaPool metaPool;\r\n    uint256 metaPoolSlippage;\r\n    IConvexToken convexToken;\r\n    IConvexBooster convexBooster;\r\n    IConvexRewards convexRewards;\r\n    uint256 convexPoolId;\r\n}\r\n\r\n/// @dev The amount of precision that slippage parameters have.\r\nuint256 constant SLIPPAGE_PRECISION = 1e4;\r\n\r\n/// @dev The amount of precision that curve pools use for price calculations.\r\nuint256 constant CURVE_PRECISION = 1e18;\r\n\r\n/// @notice Enumerations for meta pool assets.\r\n///\r\n/// @dev Do not change the order of these fields.\r\nenum MetaPoolAsset {\r\n    ETH, ALETH\r\n}\r\n\r\nuint256 constant NUM_META_COINS = 2;\r\n\r\n/// @title  EthAssetManager\r\n/// @author Alchemix Finance\r\ncontract EthAssetManager is Multicall, Mutex, IERC20TokenReceiver {\r\n    /// @notice Emitted when the admin is updated.\r\n    ///\r\n    /// @param admin The admin.\r\n    event AdminUpdated(address admin);\r\n\r\n    /// @notice Emitted when the pending admin is updated.\r\n    ///\r\n    /// @param pendingAdmin The pending admin.\r\n    event PendingAdminUpdated(address pendingAdmin);\r\n\r\n    /// @notice Emitted when the operator is updated.\r\n    ///\r\n    /// @param operator The operator.\r\n    event OperatorUpdated(address operator);\r\n\r\n    /// @notice Emitted when the reward receiver is updated.\r\n    ///\r\n    /// @param rewardReceiver The reward receiver.\r\n    event RewardReceiverUpdated(address rewardReceiver);\r\n\r\n    /// @notice Emitted when the transmuter buffer is updated.\r\n    ///\r\n    /// @param transmuterBuffer The transmuter buffer.\r\n    event TransmuterBufferUpdated(address transmuterBuffer);\r\n\r\n    /// @notice Emitted when the meta pool slippage is updated.\r\n    ///\r\n    /// @param metaPoolSlippage The meta pool slippage.\r\n    event MetaPoolSlippageUpdated(uint256 metaPoolSlippage);\r\n\r\n    /// @notice Emitted when meta pool tokens are minted.\r\n    ///\r\n    /// @param amounts               The amounts of each meta pool asset used to mint liquidity.\r\n    /// @param mintedThreePoolTokens The amount of meta pool tokens minted.\r\n    event MintMetaPoolTokens(uint256[NUM_META_COINS] amounts, uint256 mintedThreePoolTokens);\r\n\r\n    /// @notice Emitted when meta tokens are minted.\r\n    ///\r\n    /// @param asset  The asset used to mint meta pool tokens.\r\n    /// @param amount The amount of the asset used to mint meta pool tokens.\r\n    /// @param minted The amount of meta pool tokens minted.\r\n    event MintMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 minted);\r\n\r\n    /// @notice Emitted when meta pool tokens are burned.\r\n    ///\r\n    /// @param asset     The meta pool asset that was received.\r\n    /// @param amount    The amount of meta pool tokens that were burned.\r\n    /// @param withdrawn The amount of the asset that was withdrawn.\r\n    event BurnMetaPoolTokens(MetaPoolAsset asset, uint256 amount, uint256 withdrawn);\r\n\r\n    /// @notice Emitted when meta pool tokens are deposited into convex.\r\n    ///\r\n    /// @param amount  The amount of meta pool tokens that were deposited.\r\n    /// @param success If the operation was successful.\r\n    event DepositMetaPoolTokens(uint256 amount, bool success);\r\n\r\n    /// @notice Emitted when meta pool tokens are withdrawn from convex.\r\n    ///\r\n    /// @param amount  The amount of meta pool tokens that were withdrawn.\r\n    /// @param success If the operation was successful.\r\n    event WithdrawMetaPoolTokens(uint256 amount, bool success);\r\n\r\n    /// @notice Emitted when convex rewards are claimed.\r\n    ///\r\n    /// @param success      If the operation was successful.\r\n    /// @param amountCurve  The amount of curve tokens sent to the reward recipient.\r\n    /// @param amountConvex The amount of convex tokens sent to the reward recipient.\r\n    event ClaimRewards(bool success, uint256 amountCurve, uint256 amountConvex);\r\n\r\n    /// @notice Emitted when ethereum is sent to the transmuter buffer.\r\n    ///\r\n    /// @param amount The amount of ethereum that was reclaimed.\r\n    event ReclaimEth(uint256 amount);\r\n\r\n    /// @notice Emitted when a token is swept to the admin.\r\n    ///\r\n    /// @param token  The token that was swept.\r\n    /// @param amount The amount of the token that was swept.\r\n    event SweepToken(address token, uint256 amount);\r\n\r\n    /// @notice Emitted when ethereum is swept to the admin.\r\n    ///\r\n    /// @param amount The amount of the token that was swept.\r\n    event SweepEth(uint256 amount);\r\n\r\n    /// @notice The admin.\r\n    address public admin;\r\n\r\n    /// @notice The current pending admin.\r\n    address public pendingAdmin;\r\n\r\n    /// @notice The operator.\r\n    address public operator;\r\n\r\n    // @notice The reward receiver.\r\n    address public rewardReceiver;\r\n\r\n    /// @notice The transmuter buffer.\r\n    address public transmuterBuffer;\r\n\r\n    /// @notice The wrapped ethereum token.\r\n    IWETH9 public weth;\r\n\r\n    /// @notice The curve token.\r\n    IERC20 public immutable curveToken;\r\n\r\n    /// @notice The meta pool contract.\r\n    IEthStableMetaPool public immutable metaPool;\r\n\r\n    /// @notice The amount of slippage that will be tolerated when depositing and withdrawing assets\r\n    ///         from the meta pool. In units of basis points.\r\n    uint256 public metaPoolSlippage;\r\n\r\n    /// @notice The convex token.\r\n    IConvexToken public immutable convexToken;\r\n\r\n    /// @notice The convex booster contract.\r\n    IConvexBooster public immutable convexBooster;\r\n\r\n    /// @notice The convex rewards contract.\r\n    IConvexRewards public immutable convexRewards;\r\n\r\n    /// @notice The convex pool identifier.\r\n    uint256 public immutable convexPoolId;\r\n\r\n    /// @dev A cache of the tokens that the meta pool supports.\r\n    IERC20[NUM_META_COINS] private _metaPoolAssetCache;\r\n\r\n    /// @dev A modifier which reverts if the message sender is not the admin.\r\n    modifier onlyAdmin() {\r\n        if (msg.sender != admin) {\r\n            revert Unauthorized(\"Not admin\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev A modifier which reverts if the message sender is not the operator.\r\n    modifier onlyOperator() {\r\n        if (msg.sender != operator) {\r\n            revert Unauthorized(\"Not operator\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(InitializationParams memory params) {\r\n        admin            = params.admin;\r\n        operator         = params.operator;\r\n        rewardReceiver   = params.rewardReceiver;\r\n        transmuterBuffer = params.transmuterBuffer;\r\n        weth             = params.weth;\r\n        curveToken       = params.curveToken;\r\n        metaPool         = params.metaPool;\r\n        metaPoolSlippage = params.metaPoolSlippage;\r\n        convexToken      = params.convexToken;\r\n        convexBooster    = params.convexBooster;\r\n        convexRewards    = params.convexRewards;\r\n        convexPoolId     = params.convexPoolId;\r\n\r\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\r\n            _metaPoolAssetCache[i] = params.metaPool.coins(i);\r\n            if (_metaPoolAssetCache[i] == IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)) {\r\n                _metaPoolAssetCache[i] = weth;\r\n            }\r\n        }\r\n\r\n        emit AdminUpdated(admin);\r\n        emit OperatorUpdated(operator);\r\n        emit RewardReceiverUpdated(rewardReceiver);\r\n        emit TransmuterBufferUpdated(transmuterBuffer);\r\n        emit MetaPoolSlippageUpdated(metaPoolSlippage);\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n    /// @notice Gets the amount of meta pool tokens that this contract has in reserves.\r\n    ///\r\n    /// @return The reserves.\r\n    function metaPoolReserves() external view returns (uint256) {\r\n        return metaPool.balanceOf(address(this));\r\n    }\r\n\r\n    /// @notice Gets the amount of a meta pool asset that this contract has in reserves.\r\n    ///\r\n    /// @param asset The meta pool asset.\r\n    ///\r\n    /// @return The reserves.\r\n    function metaPoolAssetReserves(MetaPoolAsset asset) external view returns (uint256) {\r\n        IERC20 token = getTokenForMetaPoolAsset(asset);\r\n        if (asset == MetaPoolAsset.ETH) {\r\n            return address(this).balance + token.balanceOf(address(this));\r\n        }\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    /// @notice Gets the amount of ethereum that one alETH is worth.\r\n    ///\r\n    /// @return The amount of the underlying token.\r\n    function exchangeRate() public view returns (uint256) {\r\n        IERC20 alETH = getTokenForMetaPoolAsset(MetaPoolAsset.ALETH);\r\n\r\n        uint256[NUM_META_COINS] memory metaBalances = metaPool.get_balances();\r\n        return metaPool.get_dy(\r\n            int128(uint128(uint256(MetaPoolAsset.ALETH))),\r\n            int128(uint128(uint256(MetaPoolAsset.ETH))),\r\n            10**SafeERC20.expectDecimals(address(alETH)),\r\n            metaBalances\r\n        );\r\n    }\r\n\r\n    /// @notice Gets the amount of curve tokens and convex tokens that can be claimed.\r\n    ///\r\n    /// @return amountCurve  The amount of curve tokens available.\r\n    /// @return amountConvex The amount of convex tokens available.\r\n    function claimableRewards() public view returns (uint256 amountCurve, uint256 amountConvex) {\r\n        amountCurve  = convexRewards.earned(address(this));\r\n        amountConvex = _getEarnedConvex(amountCurve);\r\n    }\r\n\r\n    /// @notice Gets the ERC20 token associated with a meta pool asset.\r\n    ///\r\n    /// @param asset The asset to get the token for.\r\n    ///\r\n    /// @return The token.\r\n    function getTokenForMetaPoolAsset(MetaPoolAsset asset) public view returns (IERC20) {\r\n        uint256 index = uint256(asset);\r\n        if (index >= NUM_META_COINS) {\r\n            revert IllegalArgument(\"Asset index out of bounds\");\r\n        }\r\n        return _metaPoolAssetCache[index];\r\n    }\r\n\r\n    /// @notice Begins the 2-step process of setting the administrator.\r\n    ///\r\n    /// The caller must be the admin. Setting the pending timelock to the zero address will stop\r\n    /// the process of setting a new timelock.\r\n    ///\r\n    /// @param value The value to set the pending timelock to.\r\n    function setPendingAdmin(address value) external onlyAdmin {\r\n        pendingAdmin = value;\r\n        emit PendingAdminUpdated(value);\r\n    }\r\n\r\n    /// @notice Completes the 2-step process of setting the administrator.\r\n    ///\r\n    /// The pending admin must be set and the caller must be the pending admin. After this function\r\n    /// is successfully executed, the admin will be set to the pending admin and the pending admin\r\n    /// will be reset.\r\n    function acceptAdmin() external {\r\n        if (pendingAdmin == address(0)) {\r\n            revert IllegalState(\"Pending admin unset\");\r\n        }\r\n\r\n        if (pendingAdmin != msg.sender) {\r\n            revert Unauthorized(\"Not pending admin\");\r\n        }\r\n\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n\r\n        emit AdminUpdated(admin);\r\n        emit PendingAdminUpdated(address(0));\r\n    }\r\n\r\n    /// @notice Sets the operator.\r\n    ///\r\n    /// The caller must be the admin.\r\n    ///\r\n    /// @param value The value to set the admin to.\r\n    function setOperator(address value) external onlyAdmin {\r\n        operator = value;\r\n        emit OperatorUpdated(value);\r\n    }\r\n\r\n    /// @notice Sets the reward receiver.\r\n    ///\r\n    /// @param value The value to set the reward receiver to.\r\n    function setRewardReceiver(address value) external onlyAdmin {\r\n        rewardReceiver = value;\r\n        emit RewardReceiverUpdated(value);\r\n    }\r\n\r\n    /// @notice Sets the transmuter buffer.\r\n    ///\r\n    /// @param value The value to set the transmuter buffer to.\r\n    function setTransmuterBuffer(address value) external onlyAdmin {\r\n        transmuterBuffer = value;\r\n        emit TransmuterBufferUpdated(value);\r\n    }\r\n\r\n    /// @notice Sets the slippage that will be tolerated when depositing and withdrawing meta pool\r\n    ///         assets. The slippage has a resolution of 6 decimals.\r\n    ///\r\n    /// The operator is allowed to set the slippage because it is a volatile parameter that may need\r\n    /// fine adjustment in a short time window.\r\n    ///\r\n    /// @param value The value to set the slippage to.\r\n    function setMetaPoolSlippage(uint256 value) external onlyOperator {\r\n        if (value > SLIPPAGE_PRECISION) {\r\n            revert IllegalArgument(\"Slippage not in range\");\r\n        }\r\n        metaPoolSlippage = value;\r\n        emit MetaPoolSlippageUpdated(value);\r\n    }\r\n\r\n    /// @notice Mints meta pool tokens with a combination of assets.\r\n    ///\r\n    /// @param amounts The amounts of the assets to deposit.\r\n    ///\r\n    /// @return minted The number of meta pool tokens minted.\r\n    function mintMetaPoolTokens(\r\n        uint256[NUM_META_COINS] calldata amounts\r\n    ) external lock onlyOperator returns (uint256 minted) {\r\n        return _mintMetaPoolTokens(amounts);\r\n    }\r\n\r\n    /// @notice Mints meta pool tokens with an asset.\r\n    ///\r\n    /// @param asset  The asset to deposit into the meta pool.\r\n    /// @param amount The amount of the asset to deposit.\r\n    ///\r\n    /// @return minted The number of meta pool tokens minted.\r\n    function mintMetaPoolTokens(\r\n        MetaPoolAsset asset,\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (uint256 minted) {\r\n        return _mintMetaPoolTokens(asset, amount);\r\n    }\r\n\r\n    /// @notice Burns meta pool tokens to withdraw an asset.\r\n    ///\r\n    /// @param asset  The asset to withdraw.\r\n    /// @param amount The amount of meta pool tokens to burn.\r\n    ///\r\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\r\n    function burnMetaPoolTokens(\r\n        MetaPoolAsset asset,\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (uint256 withdrawn) {\r\n        return _burnMetaPoolTokens(asset, amount);\r\n    }\r\n\r\n    /// @notice Deposits and stakes meta pool tokens into convex.\r\n    ///\r\n    /// @param amount The amount of meta pool tokens to deposit.\r\n    ///\r\n    /// @return success If the tokens were successfully deposited.\r\n    function depositMetaPoolTokens(\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (bool success) {\r\n        return _depositMetaPoolTokens(amount);\r\n    }\r\n\r\n    /// @notice Withdraws and unwraps meta pool tokens from convex.\r\n    ///\r\n    /// @param amount The amount of meta pool tokens to withdraw.\r\n    ///\r\n    /// @return success If the tokens were successfully withdrawn.\r\n    function withdrawMetaPoolTokens(\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (bool success) {\r\n        return _withdrawMetaPoolTokens(amount);\r\n    }\r\n\r\n    /// @notice Claims convex, curve, and auxiliary rewards.\r\n    ///\r\n    /// @return success If the claim was successful.\r\n    function claimRewards() external lock onlyOperator returns (bool success) {\r\n        success = convexRewards.getReward();\r\n\r\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\r\n        uint256 convexBalance = convexToken.balanceOf(address(this));\r\n\r\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\r\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\r\n\r\n        emit ClaimRewards(success, curveBalance, convexBalance);\r\n    }\r\n\r\n    /// @notice Flushes meta pool assets into convex by minting meta pool tokens using the assets,\r\n    ///         and then depositing the meta pool tokens into convex.\r\n    ///\r\n    /// This function is provided for ease of use.\r\n    ///\r\n    /// @param amounts The amounts of the meta pool assets to flush.\r\n    ///\r\n    /// @return The amount of meta pool tokens deposited into convex.\r\n    function flush(\r\n        uint256[NUM_META_COINS] calldata amounts\r\n    ) external lock onlyOperator returns (uint256) {\r\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(amounts);\r\n\r\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\r\n            revert IllegalState(\"Deposit into convex failed\");\r\n        }\r\n\r\n        return mintedMetaPoolTokens;\r\n    }\r\n\r\n    /// @notice Flushes a meta pool asset into convex by minting meta pool tokens using the asset,\r\n    ///         and then depositing the meta pool tokens into convex.\r\n    ///\r\n    /// This function is provided for ease of use.\r\n    ///\r\n    /// @param asset  The meta pool asset to flush.\r\n    /// @param amount The amount of the meta pool asset to flush.\r\n    ///\r\n    /// @return The amount of meta pool tokens deposited into convex.\r\n    function flush(\r\n        MetaPoolAsset asset,\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (uint256) {\r\n        uint256 mintedMetaPoolTokens = _mintMetaPoolTokens(asset, amount);\r\n\r\n        if (!_depositMetaPoolTokens(mintedMetaPoolTokens)) {\r\n            revert IllegalState(\"Deposit into convex failed\");\r\n        }\r\n\r\n        return mintedMetaPoolTokens;\r\n    }\r\n\r\n    /// @notice Recalls ethereum into reserves by withdrawing meta pool tokens from convex and\r\n    ///         burning the meta pool tokens for ethereum.\r\n    ///\r\n    /// This function is provided for ease of use.\r\n    ///\r\n    /// @param amount The amount of the meta pool tokens to withdraw from convex and burn.\r\n    ///\r\n    /// @return The amount of ethereum recalled.\r\n    function recall(uint256 amount) external lock onlyOperator returns (uint256) {\r\n        if (!_withdrawMetaPoolTokens(amount)) {\r\n            revert IllegalState(\"Withdraw from convex failed\");\r\n        }\r\n        return _burnMetaPoolTokens(MetaPoolAsset.ETH, amount);\r\n    }\r\n\r\n    /// @notice Reclaims a three pool asset to the transmuter buffer.\r\n    ///\r\n    /// @param amount The amount of ethereum to reclaim.\r\n    function reclaimEth(uint256 amount) public lock onlyAdmin {\r\n        uint256 balance;\r\n        if (amount > (balance = weth.balanceOf(address(this)))) weth.deposit{value: amount - balance}();\r\n\r\n        SafeERC20.safeTransfer(address(weth), transmuterBuffer, amount);\r\n\r\n        IERC20TokenReceiver(transmuterBuffer).onERC20Received(address(weth), amount);\r\n\r\n        emit ReclaimEth(amount);\r\n    }\r\n\r\n    /// @notice Sweeps a token out of the contract to the admin.\r\n    ///\r\n    /// @param token  The token to sweep.\r\n    /// @param amount The amount of the token to sweep.\r\n    function sweepToken(address token, uint256 amount) external lock onlyAdmin {\r\n        SafeERC20.safeTransfer(address(token), msg.sender, amount);\r\n        emit SweepToken(token, amount);\r\n    }\r\n\r\n    /// @notice Sweeps ethereum out of the contract to the admin.\r\n    ///\r\n    /// @param amount The amount of ethereum to sweep.\r\n    ///\r\n    /// @return result The result from the call to transfer ethereum.\r\n    function sweepEth(\r\n        uint256 amount\r\n    ) external lock onlyAdmin returns (bytes memory result) {\r\n        (bool success, bytes memory result) = admin.call{value: amount}(new bytes(0));\r\n        if (!success) {\r\n            revert IllegalState(\"Transfer failed\");\r\n        }\r\n\r\n        emit SweepEth(amount);\r\n\r\n        return result;\r\n    }\r\n\r\n    /// @inheritdoc IERC20TokenReceiver\r\n    ///\r\n    /// @dev This function is required in order to receive tokens from the conduit.\r\n    function onERC20Received(address token, uint256 value) external { /* noop */ }\r\n\r\n    /// @dev Gets the amount of convex that will be minted for an amount of curve tokens.\r\n    ///\r\n    /// @param amountCurve The amount of curve tokens.\r\n    ///\r\n    /// @return The amount of convex tokens.\r\n    function _getEarnedConvex(uint256 amountCurve) internal view returns (uint256) {\r\n        uint256 supply      = convexToken.totalSupply();\r\n        uint256 cliff       = supply / convexToken.reductionPerCliff();\r\n        uint256 totalCliffs = convexToken.totalCliffs();\r\n\r\n        if (cliff >= totalCliffs) return 0;\r\n\r\n        uint256 reduction = totalCliffs - cliff;\r\n        uint256 earned    = amountCurve * reduction / totalCliffs;\r\n\r\n        uint256 available = convexToken.maxSupply() - supply;\r\n        return earned > available ? available : earned;\r\n    }\r\n\r\n    /// @dev Mints meta pool tokens with a combination of assets.\r\n    ///\r\n    /// @param amounts The amounts of the assets to deposit.\r\n    ///\r\n    /// @return minted The number of meta pool tokens minted.\r\n    function _mintMetaPoolTokens(\r\n        uint256[NUM_META_COINS] calldata amounts\r\n    ) internal returns (uint256 minted) {\r\n        IERC20[NUM_META_COINS] memory tokens = _metaPoolAssetCache;\r\n\r\n        uint256 total = 0;\r\n        for (uint256 i = 0; i < NUM_META_COINS; i++) {\r\n            // Skip over approving WETH since we are directly swapping ETH.\r\n            if (i == uint256(MetaPoolAsset.ETH)) continue;\r\n\r\n            if (amounts[i] == 0) continue;\r\n\r\n            total += amounts[i];\r\n\r\n            // For assets like USDT, the approval must be first set to zero before updating it.\r\n            SafeERC20.safeApprove(address(tokens[i]), address(metaPool), 0);\r\n            SafeERC20.safeApprove(address(tokens[i]), address(metaPool), amounts[i]);\r\n        }\r\n\r\n        // Calculate the minimum amount of meta pool tokens that we are expecting out when\r\n        // adding liquidity for all of the assets. This value is based off the optimistic\r\n        // assumption that one of each token is approximately equal to one meta pool token.\r\n        uint256 expectedOutput    = total * CURVE_PRECISION / metaPool.get_virtual_price();\r\n        uint256 minimumMintAmount = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\r\n\r\n        uint256 value = amounts[uint256(MetaPoolAsset.ETH)];\r\n\r\n        // Ensure that the contract has the amount of ethereum required.\r\n        if (value > address(this).balance) weth.withdraw(value - address(this).balance);\r\n\r\n        // Add the liquidity to the pool.\r\n        minted = metaPool.add_liquidity{value: value}(amounts, minimumMintAmount);\r\n\r\n        emit MintMetaPoolTokens(amounts, minted);\r\n    }\r\n\r\n    /// @dev Mints meta pool tokens with an asset.\r\n    ///\r\n    /// @param asset  The asset to deposit into the meta pool.\r\n    /// @param amount The amount of the asset to deposit.\r\n    ///\r\n    /// @return minted The number of meta pool tokens minted.\r\n    function _mintMetaPoolTokens(\r\n        MetaPoolAsset asset,\r\n        uint256 amount\r\n    ) internal returns (uint256 minted) {\r\n        uint256[NUM_META_COINS] memory amounts;\r\n        amounts[uint256(asset)] = amount;\r\n\r\n        // Calculate the minimum amount of meta pool tokens that we are expecting out when\r\n        // adding liquidity for all of the assets. This value is based off the optimistic\r\n        // assumption that one of each token is approximately equal to one meta pool token.\r\n        uint256 minimumMintAmount = amount * metaPoolSlippage / SLIPPAGE_PRECISION;\r\n\r\n        // Set an approval if not working with ethereum.\r\n        if (asset != MetaPoolAsset.ETH) {\r\n            IERC20 token = getTokenForMetaPoolAsset(asset);\r\n\r\n            // For assets like USDT, the approval must be first set to zero before updating it.\r\n            SafeERC20.safeApprove(address(token), address(metaPool), 0);\r\n            SafeERC20.safeApprove(address(token), address(metaPool), amount);\r\n        }\r\n\r\n        uint256 value = asset == MetaPoolAsset.ETH\r\n            ? amounts[uint256(MetaPoolAsset.ETH)]\r\n            : 0;\r\n\r\n        // Ensure that the contract has the amount of ethereum required.\r\n        if (value > address(this).balance) weth.withdraw(value - address(this).balance);\r\n\r\n        // Add the liquidity to the pool.\r\n        minted = metaPool.add_liquidity{value: value}(amounts, minimumMintAmount);\r\n\r\n        emit MintMetaPoolTokens(asset, amount, minted);\r\n    }\r\n\r\n    /// @dev Burns meta pool tokens to withdraw an asset.\r\n    ///\r\n    /// @param asset  The asset to withdraw.\r\n    /// @param amount The amount of meta pool tokens to burn.\r\n    ///\r\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\r\n    function _burnMetaPoolTokens(\r\n        MetaPoolAsset asset,\r\n        uint256 amount\r\n    ) internal returns (uint256 withdrawn) {\r\n        uint256 index = uint256(asset);\r\n\r\n        // Calculate the minimum amount of the meta pool asset that we are expecting out when\r\n        // removing single sided liquidity. This value is based off the optimistic assumption that\r\n        // one of each token is approximately equal to one meta pool lp token.\r\n        uint256 expectedOutput   = amount * metaPool.get_virtual_price() / CURVE_PRECISION;\r\n        uint256 minimumAmountOut = expectedOutput * metaPoolSlippage / SLIPPAGE_PRECISION;\r\n\r\n        // Remove the liquidity from the pool.\r\n        withdrawn = metaPool.remove_liquidity_one_coin(\r\n            amount,\r\n            int128(uint128(index)),\r\n            minimumAmountOut\r\n        );\r\n\r\n        emit BurnMetaPoolTokens(asset, amount, withdrawn);\r\n    }\r\n\r\n    /// @dev Deposits and stakes meta pool tokens into convex.\r\n    ///\r\n    /// @param amount The amount of meta pool tokens to deposit.\r\n    ///\r\n    /// @return success If the tokens were successfully deposited.\r\n    function _depositMetaPoolTokens(uint256 amount) internal returns (bool success) {\r\n        SafeERC20.safeApprove(address(metaPool), address(convexBooster), 0);\r\n        SafeERC20.safeApprove(address(metaPool), address(convexBooster), amount);\r\n\r\n        success = convexBooster.deposit(convexPoolId, amount, true /* always stake into rewards */);\r\n\r\n        emit DepositMetaPoolTokens(amount, success);\r\n    }\r\n\r\n    /// @dev Withdraws and unwraps meta pool tokens from convex.\r\n    ///\r\n    /// @param amount The amount of meta pool tokens to withdraw.\r\n    ///\r\n    /// @return success If the tokens were successfully withdrawn.\r\n    function _withdrawMetaPoolTokens(uint256 amount) internal returns (bool success) {\r\n        success = convexRewards.withdrawAndUnwrap(amount, false /* never claim */);\r\n        emit WithdrawMetaPoolTokens(amount, success);\r\n    }\r\n\r\n    /// @dev Claims convex, curve, and auxiliary rewards.\r\n    ///\r\n    /// @return success If the claim was successful.\r\n    function _claimRewards() internal returns (bool success) {\r\n        success = convexRewards.getReward();\r\n\r\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\r\n        uint256 convexBalance = convexToken.balanceOf(address(this));\r\n\r\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\r\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\r\n\r\n        emit ClaimRewards(success, curveBalance, convexBalance);\r\n    }\r\n\r\n    /// @dev Gets the minimum of two integers.\r\n    ///\r\n    /// @param x The first integer.\r\n    /// @param y The second integer.\r\n    ///\r\n    /// @return The minimum value.\r\n    function min(uint256 x , uint256 y) private pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n\r\n    /// @dev Gets the absolute value of the difference of two integers.\r\n    ///\r\n    /// @param x The first integer.\r\n    /// @param y The second integer.\r\n    ///\r\n    /// @return The absolute value.\r\n    function abs(uint256 x , uint256 y) private pure returns (uint256) {\r\n        return x > y ? x - y : y - x;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"transmuterBuffer\",\"type\":\"address\"},{\"internalType\":\"contract IWETH9\",\"name\":\"weth\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"curveToken\",\"type\":\"address\"},{\"internalType\":\"contract IEthStableMetaPool\",\"name\":\"metaPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metaPoolSlippage\",\"type\":\"uint256\"},{\"internalType\":\"contract IConvexToken\",\"name\":\"convexToken\",\"type\":\"address\"},{\"internalType\":\"contract IConvexBooster\",\"name\":\"convexBooster\",\"type\":\"address\"},{\"internalType\":\"contract IConvexRewards\",\"name\":\"convexRewards\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"convexPoolId\",\"type\":\"uint256\"}],\"internalType\":\"struct InitializationParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC20CallFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"IllegalArgument\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"IllegalState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"name\":\"MulticallFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AdminUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum MetaPoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"name\":\"BurnMetaPoolTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountCurve\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountConvex\",\"type\":\"uint256\"}],\"name\":\"ClaimRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"DepositMetaPoolTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"metaPoolSlippage\",\"type\":\"uint256\"}],\"name\":\"MetaPoolSlippageUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedThreePoolTokens\",\"type\":\"uint256\"}],\"name\":\"MintMetaPoolTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum MetaPoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"}],\"name\":\"MintMetaPoolTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"PendingAdminUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReclaimEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardReceiver\",\"type\":\"address\"}],\"name\":\"RewardReceiverUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SweepEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SweepToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"transmuterBuffer\",\"type\":\"address\"}],\"name\":\"TransmuterBufferUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"WithdrawMetaPoolTokens\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MetaPoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnMetaPoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimableRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountCurve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountConvex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexBooster\",\"outputs\":[{\"internalType\":\"contract IConvexBooster\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexPoolId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexRewards\",\"outputs\":[{\"internalType\":\"contract IConvexRewards\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexToken\",\"outputs\":[{\"internalType\":\"contract IConvexToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositMetaPoolTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"}],\"name\":\"flush\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MetaPoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"flush\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MetaPoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"}],\"name\":\"getTokenForMetaPoolAsset\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metaPool\",\"outputs\":[{\"internalType\":\"contract IEthStableMetaPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MetaPoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"}],\"name\":\"metaPoolAssetReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metaPoolReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metaPoolSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MetaPoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintMetaPoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"}],\"name\":\"mintMetaPoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"onERC20Received\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recall\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reclaimEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMetaPoolSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setRewardReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setTransmuterBuffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sweepEth\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transmuterBuffer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH9\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawMetaPoolTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EthAssetManager", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008392f6669292fa56123f71949b52d883ae57e2250000000000000000000000009e2b6378ee8ad2a4a95fe481d63caba8fb0ebbf90000000000000000000000009e2b6378ee8ad2a4a95fe481d63caba8fb0ebbf9000000000000000000000000bc2fb245594a68c927c930fbe2d00680a8c90b9e000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000d533a949740bb3306d119cc777fa900ba034cd52000000000000000000000000c4c319e2d4d66cca4464c0c2b32c9bd23ebe784e00000000000000000000000000000000000000000000000000000000000026f20000000000000000000000004e3fbd56cd56c3e72c1403e103b45db9da5b9d2b000000000000000000000000f403c135812408bfbe8713b5a23a04b3d48aae3100000000000000000000000048bc302d8295fea1f8c3e7f57d4ddc9981fee4100000000000000000000000000000000000000000000000000000000000000031", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3f22db213652e39e26e3cb5b84c0ddc7783efcfe7957d77fdb68995cb9dbdf88"}]}