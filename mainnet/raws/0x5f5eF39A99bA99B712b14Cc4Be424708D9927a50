{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SvgParser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Utils.sol\\\";\\n\\ncontract SvgParser {\\n\\n    // Limits\\n    uint256 constant DEFAULT_THRESHOLD_COUNTER = 2500;\\n\\n    // Bits & Masks\\n    bytes1 constant tagBit            = bytes1(0x80);\\n    bytes1 constant startTagBit       = bytes1(0x40);\\n    bytes1 constant tagTypeMask       = bytes1(0x3F);\\n    bytes1 constant attributeTypeMask = bytes1(0x7F);\\n\\n    bytes1 constant dCommandBit       = bytes1(0x80);\\n    bytes1 constant percentageBit     = bytes1(0x40);\\n    bytes1 constant negativeBit       = bytes1(0x20);\\n    bytes1 constant decimalBit        = bytes1(0x10);\\n\\n    bytes1 constant numberMask        = bytes1(0x0F);\\n\\n    bytes1 constant filterInIdBit     = bytes1(0x80);\\n\\n    bytes1 constant filterInIdMask    = bytes1(0x7F);\\n\\n    // SVG tags\\n    bytes constant SVG_OPEN_TAG = bytes('<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><svg width=\\\"1320px\\\" height=\\\"1760px\\\" viewBox=\\\"0 0 1320 1760\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">');\\n    bytes constant SVG_CLOSE_TAG = bytes(\\\"</svg>\\\");\\n\\n    bytes[25] TAGS = [\\n        bytes(\\\"g\\\"),\\n        bytes(\\\"polygon\\\"),\\n        bytes(\\\"path\\\"),\\n        bytes(\\\"circle\\\"),\\n        bytes(\\\"defs\\\"),\\n        bytes(\\\"linearGradient\\\"),\\n        bytes(\\\"stop\\\"),\\n        bytes(\\\"rect\\\"),\\n        bytes(\\\"polyline\\\"),\\n        bytes(\\\"text\\\"),\\n        bytes(\\\"tspan\\\"),\\n        bytes(\\\"mask\\\"),\\n        bytes(\\\"use\\\"),\\n        bytes(\\\"ellipse\\\"),\\n        bytes(\\\"radialGradient\\\"),\\n        bytes(\\\"filter\\\"),\\n        bytes(\\\"feColorMatrix\\\"),\\n        bytes(\\\"feComposite\\\"),\\n        bytes(\\\"feGaussianBlur\\\"),\\n        bytes(\\\"feMorphology\\\"),\\n        bytes(\\\"feOffset\\\"),\\n        bytes(\\\"pattern\\\"),\\n        bytes(\\\"feMergeNode\\\"),\\n        bytes(\\\"feMerge\\\"),\\n        bytes(\\\"INVALIDTAG\\\")\\n    ];\\n\\n    bytes[54] ATTRIBUTES = [\\n        bytes(\\\"d\\\"),\\n        bytes(\\\"points\\\"),\\n        bytes(\\\"transform\\\"),\\n        bytes(\\\"cx\\\"),\\n        bytes(\\\"cy\\\"),\\n        bytes(\\\"r\\\"),\\n        bytes(\\\"stroke\\\"),\\n        bytes(\\\"stroke-width\\\"),\\n        bytes(\\\"fill\\\"),\\n        bytes(\\\"fill-opacity\\\"),\\n        bytes(\\\"translate\\\"),\\n        bytes(\\\"rotate\\\"),\\n        bytes(\\\"scale\\\"),\\n        bytes(\\\"x1\\\"),\\n        bytes(\\\"y1\\\"),\\n        bytes(\\\"x2\\\"),\\n        bytes(\\\"y2\\\"),\\n        bytes(\\\"stop-color\\\"),\\n        bytes(\\\"offset\\\"),\\n        bytes(\\\"stop-opacity\\\"),\\n        bytes(\\\"width\\\"),\\n        bytes(\\\"height\\\"),\\n        bytes(\\\"x\\\"),\\n        bytes(\\\"y\\\"),\\n        bytes(\\\"font-size\\\"),\\n        bytes(\\\"letter-spacing\\\"),\\n        bytes(\\\"opacity\\\"),\\n        bytes(\\\"id\\\"),\\n        bytes(\\\"xlink:href\\\"),\\n        bytes(\\\"rx\\\"),\\n        bytes(\\\"ry\\\"),\\n        bytes(\\\"mask\\\"),\\n        bytes(\\\"fx\\\"),\\n        bytes(\\\"fy\\\"),\\n        bytes(\\\"gradientTransform\\\"),\\n        bytes(\\\"filter\\\"),\\n        bytes(\\\"filterUnits\\\"),\\n        bytes(\\\"result\\\"),\\n        bytes(\\\"in\\\"),\\n        bytes(\\\"in2\\\"),\\n        bytes(\\\"type\\\"),\\n        bytes(\\\"values\\\"),\\n        bytes(\\\"operator\\\"),\\n        bytes(\\\"k1\\\"),\\n        bytes(\\\"k2\\\"),\\n        bytes(\\\"k3\\\"),\\n        bytes(\\\"k4\\\"),\\n        bytes(\\\"stdDeviation\\\"),\\n        bytes(\\\"edgeMode\\\"),\\n        bytes(\\\"radius\\\"),\\n        bytes(\\\"fill-rule\\\"),\\n        bytes(\\\"dx\\\"),\\n        bytes(\\\"dy\\\"),\\n        bytes(\\\"INVALIDATTRIBUTE\\\")\\n    ];\\n\\n    bytes[2] PAIR_NUMBER_SET_ATTRIBUTES = [\\n        bytes(\\\"translate\\\"),\\n        bytes(\\\"scale\\\")\\n    ];\\n\\n    bytes[4] PAIR_COLOR_ATTRIBUTES = [\\n        bytes(\\\"stroke\\\"),\\n        bytes(\\\"fill\\\"),\\n        bytes(\\\"stop-color\\\"),\\n        bytes(\\\"mask\\\")\\n    ];\\n\\n    bytes[23] SINGLE_NUMBER_SET_ATTRIBUTES = [\\n        bytes(\\\"cx\\\"),\\n        bytes(\\\"cy\\\"),\\n        bytes(\\\"r\\\"),\\n        bytes(\\\"rotate\\\"),\\n        bytes(\\\"x1\\\"),\\n        bytes(\\\"y1\\\"),\\n        bytes(\\\"x2\\\"),\\n        bytes(\\\"y2\\\"),\\n        bytes(\\\"offset\\\"),\\n        bytes(\\\"x\\\"),\\n        bytes(\\\"y\\\"),\\n        bytes(\\\"rx\\\"),\\n        bytes(\\\"ry\\\"),\\n        bytes(\\\"fx\\\"),\\n        bytes(\\\"fy\\\"),\\n        bytes(\\\"font-size\\\"),\\n        bytes(\\\"letter-spacing\\\"),\\n        bytes(\\\"stroke-width\\\"),\\n        bytes(\\\"width\\\"),\\n        bytes(\\\"height\\\"),\\n        bytes(\\\"fill-opacity\\\"),\\n        bytes(\\\"stop-opacity\\\"),\\n        bytes(\\\"opacity\\\")\\n    ];\\n\\n    bytes[20] D_COMMANDS = [\\n        bytes(\\\"M\\\"),\\n        bytes(\\\"m\\\"),\\n        bytes(\\\"L\\\"),\\n        bytes(\\\"l\\\"),\\n        bytes(\\\"H\\\"),\\n        bytes(\\\"h\\\"),\\n        bytes(\\\"V\\\"),\\n        bytes(\\\"v\\\"),\\n        bytes(\\\"C\\\"),\\n        bytes(\\\"c\\\"),\\n        bytes(\\\"S\\\"),\\n        bytes(\\\"s\\\"),\\n        bytes(\\\"Q\\\"),\\n        bytes(\\\"q\\\"),\\n        bytes(\\\"T\\\"),\\n        bytes(\\\"t\\\"),\\n        bytes(\\\"A\\\"),\\n        bytes(\\\"a\\\"),\\n        bytes(\\\"Z\\\"),\\n        bytes(\\\"z\\\")\\n    ];\\n\\n    bytes[2] FILL_RULE = [\\n        bytes(\\\"nonzero\\\"),\\n        bytes(\\\"evenodd\\\")\\n    ];\\n\\n    bytes[2] FILTER_UNIT = [\\n        bytes(\\\"userSpaceOnUse\\\"),\\n        bytes(\\\"objectBoundingBox\\\")\\n    ];\\n\\n    bytes[6] FILTER_IN = [\\n        bytes(\\\"SourceGraphic\\\"),\\n        bytes(\\\"SourceAlpha\\\"),\\n        bytes(\\\"BackgroundImage\\\"),\\n        bytes(\\\"BackgroundAlpha\\\"),\\n        bytes(\\\"FillPaint\\\"),\\n        bytes(\\\"StrokePaint\\\")\\n    ];\\n\\n    bytes[16] FILTER_TYPE = [\\n        bytes(\\\"translate\\\"),\\n        bytes(\\\"scale\\\"),\\n        bytes(\\\"rotate\\\"),\\n        bytes(\\\"skewX\\\"),\\n        bytes(\\\"skewY\\\"),\\n        bytes(\\\"matrix\\\"),\\n        bytes(\\\"saturate\\\"),\\n        bytes(\\\"hueRotate\\\"),\\n        bytes(\\\"luminanceToAlpha\\\"),\\n        bytes(\\\"identity\\\"),\\n        bytes(\\\"table\\\"),\\n        bytes(\\\"discrete\\\"),\\n        bytes(\\\"linear\\\"),\\n        bytes(\\\"gamma\\\"),\\n        bytes(\\\"fractalNoise\\\"),\\n        bytes(\\\"turbulence\\\")\\n    ];\\n\\n    bytes[9] FILTER_OPERATOR = [\\n        bytes(\\\"over\\\"),\\n        bytes(\\\"in\\\"),\\n        bytes(\\\"out\\\"),\\n        bytes(\\\"atop\\\"),\\n        bytes(\\\"xor\\\"),\\n        bytes(\\\"lighter\\\"),\\n        bytes(\\\"arithmetic\\\"),\\n        bytes(\\\"erode\\\"),\\n        bytes(\\\"dilate\\\")\\n    ];\\n\\n    bytes[3] FILTER_EDGEMODE = [\\n        bytes(\\\"duplicate\\\"),\\n        bytes(\\\"wrap\\\"),\\n        bytes(\\\"none\\\")\\n    ];\\n\\n\\n    function checkTag(bytes1 line) internal pure returns (bool) {\\n        return line & tagBit > 0;\\n    }\\n\\n    function checkStartTag(bytes1 line) internal pure returns (bool) {\\n        return line & startTagBit > 0;\\n    }\\n\\n    function getTag(bytes1 line) internal view returns (bytes memory) {\\n        uint8 key = uint8(line & tagTypeMask);\\n\\n        if (key >= TAGS.length - 1) {\\n            return TAGS[TAGS.length - 1];\\n        }\\n\\n        return TAGS[key];\\n    }\\n\\n    function getAttribute(bytes1 line) internal view returns (bytes memory) {\\n        uint8 key = uint8(line & attributeTypeMask);\\n\\n        if (key >= ATTRIBUTES.length - 1) {\\n            return ATTRIBUTES[ATTRIBUTES.length - 1];\\n        }\\n\\n        return ATTRIBUTES[key];\\n    }\\n\\n    function compareAttrib(bytes memory attrib, string memory compareTo) internal pure returns (bool) {\\n        return keccak256(attrib) == keccak256(bytes(compareTo));\\n    }\\n\\n    function compareAttrib(bytes memory attrib, bytes storage compareTo) internal pure returns (bool) {\\n        return keccak256(attrib) == keccak256(compareTo);\\n    }\\n\\n    function addOutput(bytes memory _output, uint256 _outputIdx, bytes memory _addendum) internal pure returns (uint256) {\\n        for (uint256 _idx; _idx < _addendum.length; _idx++) {\\n            _output[_outputIdx++] = _addendum[_idx];\\n        }\\n        return _outputIdx;\\n    }\\n\\n    function addOutput(bytes memory _output, uint256 _outputIdx, bytes memory _addendum1, bytes memory _addendum2)\\n        internal pure returns (uint256)\\n    {\\n        return addOutput(_output, addOutput(_output, _outputIdx, _addendum1), _addendum2);\\n    }\\n\\n    function addOutput(bytes memory _output, uint256 _outputIdx, bytes memory _addendum1, bytes memory _addendum2, bytes memory _addendum3)\\n        internal pure returns (uint256)\\n    {\\n        return addOutput(_output, addOutput(_output, addOutput(_output, _outputIdx, _addendum1), _addendum2), _addendum3);\\n    }\\n\\n    function addOutput(bytes memory _output, uint256 _outputIdx, bytes memory _addendum1, bytes memory _addendum2, bytes memory _addendum3, bytes memory _addendum4)\\n        internal pure returns (uint256)\\n    {\\n        return addOutput(_output, addOutput(_output, addOutput(_output, addOutput(_output, _outputIdx, _addendum1), _addendum2), _addendum3), _addendum4);\\n    }\\n\\n    function parse(bytes memory input, uint256 idx) public view returns (string memory, uint256) {\\n        return parse(input, idx, DEFAULT_THRESHOLD_COUNTER);\\n    }\\n\\n    function parse(bytes memory input, uint256 idx, uint256 thresholdCounter) public view returns (string memory, uint256) {\\n        // Keep track of what we're returning\\n        bytes memory output = new bytes(thresholdCounter * 15); // Plenty of padding\\n        uint256 outputIdx = 0;\\n\\n        bool isTagOpen = false;\\n        uint256 counter = idx;\\n\\n        // Start the output with SVG tags if needed\\n        if (idx == 0) {\\n            outputIdx = addOutput(output, outputIdx, SVG_OPEN_TAG);\\n        }\\n\\n        // Go through all bytes we want to review\\n        while (idx < input.length)\\n        {\\n            // Get the current byte\\n            bytes1 _b = bytes1(input[idx]);\\n\\n            // If this is a tag, determine if we're creating a new tag\\n            if (checkTag(_b)) {\\n                // Close the current tag\\n                bool closeTag = false;\\n                if (isTagOpen) {\\n                    closeTag = true;\\n                    isTagOpen = false;\\n\\n                    if ((idx - counter) >= thresholdCounter) {\\n                        outputIdx = addOutput(output, outputIdx, bytes(\\\">\\\"));\\n                        break;\\n                    }\\n                }\\n\\n                // Start the next tag\\n                if (checkStartTag(_b)) {\\n                    isTagOpen = true;\\n\\n                    if (closeTag) {\\n                        outputIdx = addOutput(output, outputIdx, bytes(\\\"><\\\"), getTag(_b));\\n                    } else {\\n                        outputIdx = addOutput(output, outputIdx, bytes(\\\"<\\\"), getTag(_b));\\n                    }\\n                } else {\\n                    // If needed, open and close an end tag\\n                    if (closeTag) {\\n                        outputIdx = addOutput(output, outputIdx, bytes(\\\"></\\\"), getTag(_b), bytes(\\\">\\\"));\\n                    } else {\\n                        outputIdx = addOutput(output, outputIdx, bytes(\\\"</\\\"), getTag(_b), bytes(\\\">\\\"));\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                // Attributes\\n                bytes memory attrib = getAttribute(_b);\\n\\n                if (compareAttrib(attrib, \\\"transform\\\") || compareAttrib(attrib, \\\"gradientTransform\\\")) {\\n                    // Keep track of which transform we're doing\\n                    bool isGradientTransform = compareAttrib(attrib, \\\"gradientTransform\\\");\\n\\n                    // Get the next byte & attribute\\n                    idx += 2;\\n                    _b = bytes1(input[idx]);\\n                    attrib = getAttribute(_b);\\n\\n                    outputIdx = addOutput(output, outputIdx, bytes(\\\" \\\"), isGradientTransform ? bytes('gradientTransform=\\\"') : bytes('transform=\\\"'));\\n                    while (compareAttrib(attrib, 'translate') || compareAttrib(attrib, 'rotate') || compareAttrib(attrib, 'scale')) {\\n                        outputIdx = addOutput(output, outputIdx, bytes(\\\" \\\"));\\n                        (idx, outputIdx) = parseAttributeValues(output, outputIdx, attrib, input, idx);\\n\\n                        // Get the next byte & attribute\\n                        idx += 2;\\n                        _b = bytes1(input[idx]);\\n                        attrib = getAttribute(_b);\\n                    }\\n\\n                    outputIdx = addOutput(output, outputIdx, bytes('\\\"'));\\n\\n                    // Undo the previous index increment\\n                    idx -= 2;\\n                }\\n                else if (compareAttrib(attrib, \\\"d\\\")) {\\n                    (idx, outputIdx) = packDPoints(output, outputIdx, input, idx);\\n                }\\n                else if (compareAttrib(attrib, \\\"points\\\"))\\n                {\\n                    (idx, outputIdx) = packPoints(output, outputIdx, input, idx, bytes(' points=\\\"'));\\n                }\\n                else if (compareAttrib(attrib, \\\"values\\\"))\\n                {\\n                    (idx, outputIdx) = packPoints(output, outputIdx, input, idx, bytes(' values=\\\"'));\\n                }\\n                else\\n                {\\n                    outputIdx = addOutput(output, outputIdx, bytes(\\\" \\\"));\\n                    (idx, outputIdx) = parseAttributeValues(output, outputIdx, attrib, input, idx);\\n                }\\n            }\\n\\n            idx += 2;\\n        }\\n\\n        if (idx >= input.length) {\\n            // Close out the SVG tags\\n            outputIdx = addOutput(output, outputIdx, SVG_CLOSE_TAG);\\n            idx = 0;\\n        }\\n\\n        // Pack everything down to the size that actually fits\\n        bytes memory finalOutput = new bytes(outputIdx);\\n        for (uint256 _idx; _idx < outputIdx; _idx++) {\\n            finalOutput[_idx] = output[_idx];\\n        }\\n\\n        return (string(finalOutput), idx);\\n    }\\n\\n    function packDPoints(bytes memory output, uint256 outputIdx, bytes memory input, uint256 idx) internal view returns (uint256, uint256) {\\n        outputIdx = addOutput(output, outputIdx, bytes(' d=\\\"'));\\n\\n        // Due to the open-ended nature of points, we concat directly to local_output\\n        idx += 2;\\n        uint256 count = uint256(uint8(input[idx + 1])) * 2**8 + uint256(uint8(input[idx]));\\n        for (uint256 countIdx = 0; countIdx < count; countIdx++) {\\n            idx += 2;\\n\\n            // Add the d command prior to any bits\\n            if (uint8(input[idx + 1] & dCommandBit) > 0) {\\n                outputIdx = addOutput(output, outputIdx, bytes(\\\" \\\"), D_COMMANDS[uint8(input[idx])]);\\n            }\\n            else\\n            {\\n                countIdx++;\\n                outputIdx = addOutput(output, outputIdx, bytes(\\\" \\\"), parseNumberSetValues(input[idx], input[idx + 1]), bytes(\\\",\\\"), parseNumberSetValues(input[idx + 2], input[idx + 3]));\\n                idx += 2;\\n            }\\n        }\\n\\n        outputIdx = addOutput(output, outputIdx, bytes('\\\"'));\\n\\n        return (idx, outputIdx);\\n    }\\n\\n    function packPoints(bytes memory output, uint256 outputIdx, bytes memory input, uint256 idx, bytes memory attributePreface) internal view returns (uint256, uint256) {\\n        outputIdx = addOutput(output, outputIdx, attributePreface);\\n\\n        // Due to the open-ended nature of points, we concat directly to local_output\\n        idx += 2;\\n        uint256 count = uint256(uint8(input[idx + 1])) * 2**8 + uint256(uint8(input[idx]));\\n        for (uint256 countIdx = 0; countIdx < count; countIdx++) {\\n            idx += 2;\\n            bytes memory numberSet = parseNumberSetValues(input[idx], input[idx + 1]);\\n\\n            if (countIdx > 0) {\\n                outputIdx = addOutput(output, outputIdx, bytes(\\\" \\\"), numberSet);\\n            } else {\\n                outputIdx = addOutput(output, outputIdx, numberSet);\\n            }\\n        }\\n\\n        outputIdx = addOutput(output, outputIdx, bytes('\\\"'));\\n\\n        return (idx, outputIdx);\\n    }\\n\\n    function parseAttributeValues(\\n        bytes memory output,\\n        uint256 outputIdx,\\n        bytes memory attrib,\\n        bytes memory input,\\n        uint256 idx\\n    )\\n        internal\\n        view\\n        returns (uint256, uint256)\\n    {\\n        // Handled in main function\\n        if (compareAttrib(attrib, \\\"d\\\") || compareAttrib(attrib, \\\"points\\\") || compareAttrib(attrib, \\\"values\\\") || compareAttrib(attrib, 'transform')) {\\n            return (idx + 2, outputIdx);\\n        }\\n\\n        if (compareAttrib(attrib, 'id') || compareAttrib(attrib, 'xlink:href') || compareAttrib(attrib, 'filter') || compareAttrib(attrib, 'result'))\\n        {\\n            bytes memory number = Utils.uint2bytes(uint256(uint8(input[idx + 3])) * 2**8 + uint256(uint8(input[idx + 2])));\\n\\n            if (compareAttrib(attrib, 'xlink:href')) {\\n                outputIdx = addOutput(output, outputIdx, attrib, bytes('=\\\"#id-'), number, bytes('\\\"'));\\n            } else if (compareAttrib(attrib, 'filter')) {\\n                outputIdx = addOutput(output, outputIdx, attrib, bytes('=\\\"url(#id-'), number, bytes(')\\\"'));\\n            } else {\\n                outputIdx = addOutput(output, outputIdx, attrib, bytes('=\\\"id-'), number, bytes('\\\"'));\\n            }\\n\\n            return (idx + 2, outputIdx);\\n        }\\n\\n        for (uint256 attribIdx = 0; attribIdx < PAIR_NUMBER_SET_ATTRIBUTES.length; attribIdx++) {\\n            if (compareAttrib(attrib, PAIR_NUMBER_SET_ATTRIBUTES[attribIdx])) {\\n                outputIdx = addOutput(output, outputIdx, attrib, bytes('('), parseNumberSetValues(input[idx + 2], input[idx + 3]), bytes(','));\\n                outputIdx = addOutput(output, outputIdx, parseNumberSetValues(input[idx + 4], input[idx + 5]), bytes(')'));\\n                return (idx + 4, outputIdx);\\n            }\\n        }\\n\\n        for (uint256 attribIdx = 0; attribIdx < PAIR_COLOR_ATTRIBUTES.length; attribIdx++) {\\n            if (compareAttrib(attrib, PAIR_COLOR_ATTRIBUTES[attribIdx])) {\\n                outputIdx = addOutput(output, outputIdx, attrib, bytes('=\\\"'), parseColorValues(input[idx + 2], input[idx + 3], input[idx + 4], input[idx + 5]), bytes('\\\"'));\\n                return (idx + 4, outputIdx);\\n            }\\n        }\\n\\n        if (compareAttrib(attrib, 'rotate')) {\\n            // Default, single number set values\\n            outputIdx = addOutput(output, outputIdx, attrib, bytes('('), parseNumberSetValues(input[idx + 2], input[idx + 3]), bytes(')'));\\n            return (idx + 2, outputIdx);\\n        }\\n\\n        // Dictionary lookups\\n        if (compareAttrib(attrib, 'in') || compareAttrib(attrib, 'in2')) {\\n            // Special case for the dictionary lookup for in & in2 => allow for ID lookup\\n            if (uint8(input[idx + 3] & filterInIdBit) > 0) {\\n                bytes memory number = Utils.uint2bytes(uint256(uint8(input[idx + 3] & filterInIdMask)) * 2**8 + uint256(uint8(input[idx + 2])));\\n                outputIdx = addOutput(output, outputIdx, attrib, bytes('=\\\"id-'), number, bytes('\\\"'));\\n            } else {\\n                outputIdx = addOutput(output, outputIdx, attrib, bytes('=\\\"'), FILTER_IN[uint8(input[idx + 2])], bytes('\\\"'));\\n            }\\n\\n            return (idx + 2, outputIdx);\\n        } else if (compareAttrib(attrib, 'type')) {\\n            outputIdx = addOutput(output, outputIdx, attrib, bytes('=\\\"'), FILTER_TYPE[uint8(input[idx + 2])], bytes('\\\"'));\\n            return (idx + 2, outputIdx);\\n        } else if (compareAttrib(attrib, 'operator')) {\\n            outputIdx = addOutput(output, outputIdx, attrib, bytes('=\\\"'), FILTER_OPERATOR[uint8(input[idx + 2])], bytes('\\\"'));\\n            return (idx + 2, outputIdx);\\n        } else if (compareAttrib(attrib, 'edgeMode')) {\\n            outputIdx = addOutput(output, outputIdx, attrib, bytes('=\\\"'), FILTER_EDGEMODE[uint8(input[idx + 2])], bytes('\\\"'));\\n            return (idx + 2, outputIdx);\\n        } else if (compareAttrib(attrib, 'fill-rule')) {\\n            outputIdx = addOutput(output, outputIdx, attrib, bytes('=\\\"'), FILL_RULE[uint8(input[idx + 2])], bytes('\\\"'));\\n            return (idx + 2, outputIdx);\\n        } else if (compareAttrib(attrib, 'filterUnits')) {\\n            outputIdx = addOutput(output, outputIdx, attrib, bytes('=\\\"'), FILTER_UNIT[uint8(input[idx + 2])], bytes('\\\"'));\\n            return (idx + 2, outputIdx);\\n        }\\n\\n        // Default, single number set values\\n        outputIdx = addOutput(output, outputIdx, attrib, bytes('=\\\"'), parseNumberSetValues(input[idx + 2], input[idx + 3]), bytes('\\\"'));\\n        return (idx + 2, outputIdx);\\n    }\\n\\n    function parseColorValues(bytes1 one, bytes1 two, bytes1 three, bytes1 four) internal pure returns (bytes memory) {\\n        if (uint8(two) == 0xFF && uint8(one) == 0 && uint8(four) == 0 && uint8(three) == 0) {\\n            // None identifier case\\n            return bytes(\\\"none\\\");\\n        }\\n        else if (uint8(two) == 0x80 && uint8(one) == 0)\\n        {\\n            // URL identifier case\\n            bytes memory number = Utils.uint2bytes(uint256(uint8(four)) * 2**8 + uint256(uint8(three)));\\n            return abi.encodePacked(\\\"url(#id-\\\", number, \\\")\\\");\\n        } else {\\n            return Utils.unpackHexColorValues(uint8(one), uint8(four), uint8(three));\\n        }\\n    }\\n\\n    function parseNumberSetValues(bytes1 one, bytes1 two) internal pure returns (bytes memory) {\\n        return Utils.unpackNumberSetValues(\\n            uint256(uint8(two & numberMask)) * 2**8 + uint256(uint8(one)), // number\\n            uint8(two & decimalBit) > 0, // decimal\\n            uint8(two & negativeBit) > 0, // negative\\n            uint8(two & percentageBit) > 0 // percent\\n        );\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Utils {\\n\\n  /**\\n   * From https://github.com/provable-things/ethereum-api/blob/master/oraclizeAPI_0.5.sol\\n   **/\\n\\n   function uint2bytes(uint _i) internal pure returns (bytes memory) {\\n    if (_i == 0) {\\n      return \\\"0\\\";\\n    }\\n    uint j = _i;\\n    uint len;\\n    while (j != 0) {\\n      len++;\\n      j /= 10;\\n    }\\n    bytes memory bstr = new bytes(len);\\n    uint k = len - 1;\\n    while (_i != 0) {\\n      unchecked {\\n        bstr[k--] = bytes1(uint8(48 + _i % 10));\\n      }\\n\\n      _i /= 10;\\n    }\\n    return bstr;\\n  }\\n\\n  function unpackNumberSetValues(uint _i, bool decimal, bool negative, bool percent) internal pure returns (bytes memory) {\\n    // Base case\\n    if (_i == 0) {\\n      if (percent) {\\n        return \\\"0%\\\";\\n      } else {\\n        return \\\"0\\\";\\n      }\\n    }\\n\\n    // Kick off length with the slots needed to make room for, considering certain bits\\n    uint j = _i;\\n    uint len = (negative ? 1 : 0) + (percent ? 1 : 0) + (decimal ? 2 : 0);\\n\\n    // See how many tens we need\\n    uint numTens;\\n    while (j != 0) {\\n      numTens++;\\n      j /= 10;\\n    }\\n\\n    // Expand length\\n    // Special case: if decimal & numTens is less than 3, need to pad by 3 since we'll left-pad zeroes\\n    if (decimal && numTens < 3) {\\n      len += 3;\\n    } else {\\n      len += numTens;\\n    }\\n\\n    // Now create the byte \\\"string\\\"\\n    bytes memory bstr = new bytes(len);\\n\\n    // Index from right-most to left-most\\n    uint k = len - 1;\\n\\n    // Percent character\\n    if (percent) {\\n      bstr[k--] = bytes1(\\\"%\\\");\\n    }\\n\\n    // The entire number\\n    while (_i != 0) {\\n      unchecked {\\n        bstr[k--] = bytes1(uint8(48 + _i % 10));\\n      }\\n\\n      _i /= 10;\\n    }\\n\\n    // If a decimal, we need to left-pad if the numTens isn't enough\\n    if (decimal) {\\n      while (numTens < 3) {\\n        bstr[k--] = bytes1(\\\"0\\\");\\n        numTens++;\\n      }\\n      bstr[k--] = bytes1(\\\".\\\");\\n\\n      unchecked {\\n        bstr[k--] = bytes1(\\\"0\\\");\\n      }\\n    }\\n\\n    // If negative, the last byte should be negative\\n    if (negative) {\\n      bstr[0] = bytes1(\\\"-\\\");\\n    }\\n\\n    return bstr;\\n  }\\n\\n  /**\\n   * Reference pulled from https://gist.github.com/okwme/f3a35193dc4eb9d1d0db65ccf3eb4034\\n   **/\\n\\n  function unpackHexColorValues(uint8 r, uint8 g, uint8 b) internal pure returns (bytes memory) {\\n    bytes memory rHex = Utils.uint2hexchar(r);\\n    bytes memory gHex = Utils.uint2hexchar(g);\\n    bytes memory bHex = Utils.uint2hexchar(b);\\n    bytes memory bstr = new bytes(7);\\n    bstr[6] = bHex[1];\\n    bstr[5] = bHex[0];\\n    bstr[4] = gHex[1];\\n    bstr[3] = gHex[0];\\n    bstr[2] = rHex[1];\\n    bstr[1] = rHex[0];\\n    bstr[0] = bytes1(\\\"#\\\");\\n    return bstr;\\n  }\\n\\n  function uint2hexchar(uint8 _i) internal pure returns (bytes memory) {\\n    uint8 mask = 15;\\n    bytes memory bstr = new bytes(2);\\n    bstr[1] = (_i & mask) > 9 ? bytes1(uint8(55 + (_i & mask))) : bytes1(uint8(48 + (_i & mask)));\\n    bstr[0] = ((_i >> 4) & mask) > 9 ? bytes1(uint8(55 + ((_i >> 4) & mask))) : bytes1(uint8(48 + ((_i >> 4) & mask)));\\n    return bstr;\\n  }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"input\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"thresholdCounter\",\"type\":\"uint256\"}],\"name\":\"parse\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"input\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"parse\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SvgParser", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}