{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.11;\r\n\r\n/*******************************************************\r\n *                      Interfaces\r\n *******************************************************/\r\ninterface IRegistry {\r\n  function isRegistered(address) external view returns (bool);\r\n\r\n  function numVaults(address) external view returns (uint256);\r\n\r\n  function vaults(address, uint256) external view returns (address);\r\n}\r\n\r\ninterface IRegistryAdapter {\r\n  function registryAddress() external view returns (address);\r\n}\r\n\r\ninterface IVault {\r\n  function token() external view returns (address);\r\n}\r\n\r\ninterface IAllowlistRegistry {\r\n  function protocolOwnerAddressByOriginName(string memory originName)\r\n    external\r\n    view\r\n    returns (address ownerAddress);\r\n}\r\n\r\ninterface IAddressesProvider {\r\n  function addressById(string memory) external view returns (address);\r\n}\r\n\r\n/*******************************************************\r\n *                      Implementation\r\n *******************************************************/\r\ncontract AllowlistImplementationYearnVaults {\r\n  string public constant protocolOriginName = \"yearn.finance\"; // Protocol owner name (must match the registered domain of the registered allowlist)\r\n  address public addressesProviderAddress; // Used to fetch current registry\r\n  address public allowlistRegistryAddress; // Used to fetch protocol owner\r\n  mapping(address => bool) public isZapInContract; // Used to test zap in contracts\r\n  mapping(address => bool) public isZapOutContract; // Used to test zap out contracts\r\n  mapping(address => bool) public isMigratorContract; // Used to test migrator contracts\r\n  mapping(address => bool) public isPickleJarContract; // Used to test the pickle jar zap\r\n\r\n  constructor(\r\n    address _addressesProviderAddress,\r\n    address _allowlistRegistryAddress\r\n  ) {\r\n    addressesProviderAddress = _addressesProviderAddress; // Set address provider address (can be updated by owner)\r\n    allowlistRegistryAddress = _allowlistRegistryAddress; // Set allowlist registry address (can only be set once)\r\n  }\r\n\r\n  /**\r\n   * @notice Only allow protocol owner to perform certain actions\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == ownerAddress(), \"Caller is not the protocol owner\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Fetch owner address from registry\r\n   */\r\n  function ownerAddress() public view returns (address protcolOwnerAddress) {\r\n    protcolOwnerAddress = IAllowlistRegistry(allowlistRegistryAddress)\r\n      .protocolOwnerAddressByOriginName(protocolOriginName);\r\n  }\r\n\r\n  /**\r\n   * @notice Set whether or not a contract is a valid zap in contract\r\n   * @param contractAddress Address of zap in contract\r\n   * @param allowed If true contract is a valid zap in contract, if false, contract is not\r\n   */\r\n  function setIsZapInContract(address contractAddress, bool allowed)\r\n    public\r\n    onlyOwner\r\n  {\r\n    isZapInContract[contractAddress] = allowed;\r\n  }\r\n\r\n  /**\r\n   * @notice Set whether or not a contract is a valid zap out contract\r\n   * @param contractAddress Address of zap out contract\r\n   * @param allowed If true contract is a valid zap out contract, if false, contract is not\r\n   */\r\n  function setIsZapOutContract(address contractAddress, bool allowed)\r\n    public\r\n    onlyOwner\r\n  {\r\n    isZapOutContract[contractAddress] = allowed;\r\n  }\r\n\r\n  /**\r\n   * @notice Set whether or not a contract is a valid migrator\r\n   * @param contractAddress Address of migrator contract\r\n   * @param allowed If true contract is a valid migrator, if false, contract is not\r\n   */\r\n  function setIsMigratorContract(address contractAddress, bool allowed)\r\n    public\r\n    onlyOwner\r\n  {\r\n    isMigratorContract[contractAddress] = allowed;\r\n  }\r\n\r\n  /**\r\n   * @notice Set whether or not a contract is a valid zap out contract\r\n   * @param contractAddress Address of zap out contract\r\n   * @param allowed If true contract is a valid zap out contract, if false, contract is not\r\n   */\r\n  function setIsPickleJarContract(address contractAddress, bool allowed)\r\n    public\r\n    onlyOwner\r\n  {\r\n    isPickleJarContract[contractAddress] = allowed;\r\n  }\r\n\r\n  /**\r\n   * @notice Determine whether or not a vault address is a valid vault\r\n   * @param tokenAddress The vault token address to test\r\n   * @return Returns true if the valid address is valid and false if not\r\n   */\r\n  function isVaultUnderlyingToken(address tokenAddress)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return registry().isRegistered(tokenAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice Determine whether or not a vault address is a valid vault\r\n   * @param vaultAddress The vault address to test\r\n   * @return Returns true if the valid address is valid and false if not\r\n   */\r\n  function isVault(address vaultAddress) public view returns (bool) {\r\n    IVault vault = IVault(vaultAddress);\r\n    address tokenAddress;\r\n    try vault.token() returns (address _tokenAddress) {\r\n      tokenAddress = _tokenAddress;\r\n    } catch {\r\n      return false;\r\n    }\r\n    uint256 numVaults = registry().numVaults(tokenAddress);\r\n    for (uint256 vaultIdx; vaultIdx < numVaults; vaultIdx++) {\r\n      address currentVaultAddress = registry().vaults(tokenAddress, vaultIdx);\r\n      if (currentVaultAddress == vaultAddress) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /*******************************************************\r\n   *                    Convienence methods\r\n   *******************************************************/\r\n\r\n  /**\r\n   * @dev Fetch registry adapter address\r\n   */\r\n  function registryAdapterAddress() public view returns (address) {\r\n    return\r\n      IAddressesProvider(addressesProviderAddress).addressById(\r\n        \"REGISTRY_ADAPTER_V2_VAULTS\"\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Fetch registry adapter interface\r\n   */\r\n  function registryAdapter() internal view returns (IRegistryAdapter) {\r\n    return IRegistryAdapter(registryAdapterAddress());\r\n  }\r\n\r\n  /**\r\n   * @dev Fetch registry address\r\n   */\r\n  function registryAddress() public view returns (address) {\r\n    return registryAdapter().registryAddress();\r\n  }\r\n\r\n  /**\r\n   * @dev Fetch registry interface\r\n   */\r\n  function registry() internal view returns (IRegistry) {\r\n    return IRegistry(registryAddress());\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressesProviderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_allowlistRegistryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"addressesProviderAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowlistRegistryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMigratorContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPickleJarContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"}],\"name\":\"isVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"isVaultUnderlyingToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isZapInContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isZapOutContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"protcolOwnerAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolOriginName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registryAdapterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setIsMigratorContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setIsPickleJarContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setIsZapInContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setIsZapOutContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AllowlistImplementationYearnVaults", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000e11dc9f2ab122dc5978eaca41483da0d7d7e6128000000000000000000000000b39c4ef6c7602f1888e3f3347f63f26c158c0336", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ec0592345819e950d44f66e53e914414cd7eb6ea5730ae7b85de9bbd08ef1f92"}]}