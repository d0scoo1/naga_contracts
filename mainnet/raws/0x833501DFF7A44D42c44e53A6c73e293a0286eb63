{"status": "1", "message": "OK", "result": [{"SourceCode": "/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: migrations/Migration_Mirach.sol\n*\n* Latest source (may be newer): https://github.com/Synthetixio/synthetix/blob/master/contracts/migrations/Migration_Mirach.sol\n* Docs: https://docs.synthetix.io/contracts/migrations/Migration_Mirach\n*\n* Contract Dependencies: \n*\t- BaseMigration\n*\t- ExchangeRates\n*\t- IAddressResolver\n*\t- IExchangeRates\n*\t- IExchangeState\n*\t- IIssuer\n*\t- IRewardEscrow\n*\t- IRewardsDistribution\n*\t- ISystemSettings\n*\t- ISystemStatus\n*\t- LegacyOwned\n*\t- MixinResolver\n*\t- MixinSystemSettings\n*\t- Owned\n*\t- State\n* Libraries: \n*\t- SafeCast\n*\t- SafeDecimalMath\n*\t- SafeMath\n*\t- SystemSettingsLib\n*\t- VestingEntries\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2022 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\n\n\npragma solidity ^0.5.16;\n\n// https://docs.synthetix.io/contracts/source/contracts/owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\ncontract BaseMigration is Owned {\n    constructor(address _owner) internal Owned(_owner) {}\n\n    // safety value to return ownership (anyone can invoke)\n    function returnOwnership(address forContract) public {\n        bytes memory payload = abi.encodeWithSignature(\"nominateNewOwner(address)\", owner);\n\n        // solhint-disable avoid-low-level-calls\n        (bool success, ) = forContract.call(payload);\n\n        if (!success) {\n            // then try legacy way\n            bytes memory legacyPayload = abi.encodeWithSignature(\"nominateOwner(address)\", owner);\n\n            // solhint-disable avoid-low-level-calls\n            (bool legacySuccess, ) = forContract.call(legacyPayload);\n\n            require(legacySuccess, \"Legacy nomination failed\");\n        }\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getSynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\ninterface ISynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferableSynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to Synthetix\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iissuer\ninterface IIssuer {\n    // Views\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function canBurnSynths(address account) external view returns (bool);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\n        external\n        view\n        returns (uint cratio, bool anyRateIsInvalid);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\n\n    function issuanceRatio() external view returns (uint);\n\n    function lastIssueEvent(address account) external view returns (uint);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function minimumStakeTime() external view returns (uint);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint);\n\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\n        external\n        view\n        returns (uint transferable, bool anyRateIsInvalid);\n\n    // Restricted: used internally to Synthetix\n    function issueSynths(address from, uint amount) external;\n\n    function issueSynthsOnBehalf(\n        address issueFor,\n        address from,\n        uint amount\n    ) external;\n\n    function issueMaxSynths(address from) external;\n\n    function issueMaxSynthsOnBehalf(address issueFor, address from) external;\n\n    function burnSynths(address from, uint amount) external;\n\n    function burnSynthsOnBehalf(\n        address burnForAddress,\n        address from,\n        uint amount\n    ) external;\n\n    function burnSynthsToTarget(address from) external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external;\n\n    function burnForRedemption(\n        address deprecatedSynthProxy,\n        address account,\n        uint balance\n    ) external;\n\n    function liquidateDelinquentAccount(\n        address account,\n        uint susdAmount,\n        address liquidator\n    ) external returns (uint totalRedeemed, uint amountToLiquidate);\n\n    function setCurrentPeriodId(uint128 periodId) external;\n\n    function issueSynthsWithoutDebt(\n        bytes32 currencyKey,\n        address to,\n        uint amount\n    ) external returns (bool rateInvalid);\n\n    function burnSynthsWithoutDebt(\n        bytes32 currencyKey,\n        address to,\n        uint amount\n    ) external returns (bool rateInvalid);\n}\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/mixinresolver\ncontract MixinResolver {\n    AddressResolver public resolver;\n\n    mapping(bytes32 => address) private addressCache;\n\n    constructor(address _resolver) internal {\n        resolver = AddressResolver(_resolver);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\n        internal\n        pure\n        returns (bytes32[] memory combination)\n    {\n        combination = new bytes32[](first.length + second.length);\n\n        for (uint i = 0; i < first.length; i++) {\n            combination[i] = first[i];\n        }\n\n        for (uint j = 0; j < second.length; j++) {\n            combination[first.length + j] = second[j];\n        }\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {}\n\n    function rebuildCache() public {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        // The resolver must call this function whenver it updates its state\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            address destination =\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\"Resolver missing target: \", name)));\n            addressCache[name] = destination;\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\n        address _foundAddress = addressCache[name];\n        require(_foundAddress != address(0), string(abi.encodePacked(\"Missing address: \", name)));\n        return _foundAddress;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event CacheUpdated(bytes32 name, address destination);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/addressresolver\ncontract AddressResolver is Owned, IAddressResolver {\n    mapping(bytes32 => address) public repository;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n        for (uint i = 0; i < names.length; i++) {\n            bytes32 name = names[i];\n            address destination = destinations[i];\n            repository[name] = destination;\n            emit AddressImported(name, destination);\n        }\n    }\n\n    /* ========= PUBLIC FUNCTIONS ========== */\n\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\n        for (uint i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\n        for (uint i = 0; i < names.length; i++) {\n            if (repository[names[i]] != destinations[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    function getSynth(bytes32 key) external view returns (address) {\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\n        return address(issuer.synths(key));\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AddressImported(bytes32 name, address destination);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/proxyable\ncontract Proxyable is Owned {\n    // This contract should be treated like an abstract contract\n\n    /* The proxy this contract exists behind. */\n    Proxy public proxy;\n\n    /* The caller of the proxy, passed through to this contract.\n     * Note that every function using this member must apply the onlyProxy or\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\n    address public messageSender;\n\n    constructor(address payable _proxy) internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setProxy(address payable _proxy) external onlyOwner {\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setMessageSender(address sender) external onlyProxy {\n        messageSender = sender;\n    }\n\n    modifier onlyProxy {\n        _onlyProxy();\n        _;\n    }\n\n    function _onlyProxy() private view {\n        require(Proxy(msg.sender) == proxy, \"Only the proxy can call\");\n    }\n\n    modifier optionalProxy {\n        _optionalProxy();\n        _;\n    }\n\n    function _optionalProxy() private {\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\n            messageSender = msg.sender;\n        }\n    }\n\n    modifier optionalProxy_onlyOwner {\n        _optionalProxy_onlyOwner();\n        _;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function _optionalProxy_onlyOwner() private {\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\n            messageSender = msg.sender;\n        }\n        require(messageSender == owner, \"Owner only function\");\n    }\n\n    event ProxyUpdated(address proxyAddress);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/proxy\ncontract Proxy is Owned {\n    Proxyable public target;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    function setTarget(Proxyable _target) external onlyOwner {\n        target = _target;\n        emit TargetUpdated(_target);\n    }\n\n    function _emit(\n        bytes calldata callData,\n        uint numTopics,\n        bytes32 topic1,\n        bytes32 topic2,\n        bytes32 topic3,\n        bytes32 topic4\n    ) external onlyTarget {\n        uint size = callData.length;\n        bytes memory _callData = callData;\n\n        assembly {\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\n             * This means moving call_data across 32 bytes guarantees we correctly access\n             * the data itself. */\n            switch numTopics\n                case 0 {\n                    log0(add(_callData, 32), size)\n                }\n                case 1 {\n                    log1(add(_callData, 32), size, topic1)\n                }\n                case 2 {\n                    log2(add(_callData, 32), size, topic1, topic2)\n                }\n                case 3 {\n                    log3(add(_callData, 32), size, topic1, topic2, topic3)\n                }\n                case 4 {\n                    log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\n                }\n        }\n    }\n\n    // solhint-disable no-complex-fallback\n    function() external payable {\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\n        target.setMessageSender(msg.sender);\n\n        assembly {\n            let free_ptr := mload(0x40)\n            calldatacopy(free_ptr, 0, calldatasize)\n\n            /* We must explicitly forward ether to the underlying contract as well. */\n            let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n            returndatacopy(free_ptr, 0, returndatasize)\n\n            if iszero(result) {\n                revert(free_ptr, returndatasize)\n            }\n            return(free_ptr, returndatasize)\n        }\n    }\n\n    modifier onlyTarget {\n        require(Proxyable(msg.sender) == target, \"Must be proxy target\");\n        _;\n    }\n\n    event TargetUpdated(Proxyable newTarget);\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/state\ncontract State is Owned {\n    // the address of the contract that can modify variables\n    // this can only be changed by the owner of this contract\n    address public associatedContract;\n\n    constructor(address _associatedContract) internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== SETTERS ========== */\n\n    // Change the associated contract to a new address\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyAssociatedContract {\n        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AssociatedContractUpdated(address associatedContract);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangestate\ninterface IExchangeState {\n    // Views\n    struct ExchangeEntry {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint amountReceived;\n        uint exchangeFeeRate;\n        uint timestamp;\n        uint roundIdForSrc;\n        uint roundIdForDest;\n    }\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint);\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        );\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint);\n\n    // Mutative functions\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external;\n\n    function removeEntries(address account, bytes32 currencyKey) external;\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/exchangestate\ncontract ExchangeState is Owned, State, IExchangeState {\n    mapping(address => mapping(bytes32 => IExchangeState.ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isystemstatus\ninterface ISystemStatus {\n    struct Status {\n        bool canSuspend;\n        bool canResume;\n    }\n\n    struct Suspension {\n        bool suspended;\n        // reason is an integer code,\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\n        uint248 reason;\n    }\n\n    // Views\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\n\n    function requireSystemActive() external view;\n\n    function systemSuspended() external view returns (bool);\n\n    function requireIssuanceActive() external view;\n\n    function requireExchangeActive() external view;\n\n    function requireFuturesActive() external view;\n\n    function requireFuturesMarketActive(bytes32 marketKey) external view;\n\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function requireSynthActive(bytes32 currencyKey) external view;\n\n    function synthSuspended(bytes32 currencyKey) external view returns (bool);\n\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function systemSuspension() external view returns (bool suspended, uint248 reason);\n\n    function issuanceSuspension() external view returns (bool suspended, uint248 reason);\n\n    function exchangeSuspension() external view returns (bool suspended, uint248 reason);\n\n    function futuresSuspension() external view returns (bool suspended, uint248 reason);\n\n    function synthExchangeSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    function synthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    function futuresMarketSuspension(bytes32 marketKey) external view returns (bool suspended, uint248 reason);\n\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons);\n\n    function getSynthSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons);\n\n    function getFuturesMarketSuspensions(bytes32[] calldata marketKeys)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons);\n\n    // Restricted functions\n    function suspendIssuance(uint256 reason) external;\n\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external;\n\n    function suspendFuturesMarket(bytes32 marketKey, uint256 reason) external;\n\n    function updateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) external;\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/systemstatus\ncontract SystemStatus is Owned, ISystemStatus {\n    mapping(bytes32 => mapping(address => Status)) public accessControl;\n\n    uint248 public constant SUSPENSION_REASON_UPGRADE = 1;\n\n    bytes32 public constant SECTION_SYSTEM = \"System\";\n    bytes32 public constant SECTION_ISSUANCE = \"Issuance\";\n    bytes32 public constant SECTION_EXCHANGE = \"Exchange\";\n    bytes32 public constant SECTION_FUTURES = \"Futures\";\n    bytes32 public constant SECTION_SYNTH_EXCHANGE = \"SynthExchange\";\n    bytes32 public constant SECTION_SYNTH = \"Synth\";\n\n    bytes32 public constant CONTRACT_NAME = \"SystemStatus\";\n\n    Suspension public systemSuspension;\n\n    Suspension public issuanceSuspension;\n\n    Suspension public exchangeSuspension;\n\n    Suspension public futuresSuspension;\n\n    mapping(bytes32 => Suspension) public synthExchangeSuspension;\n\n    mapping(bytes32 => Suspension) public synthSuspension;\n\n    mapping(bytes32 => Suspension) public futuresMarketSuspension;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== VIEWS ========== */\n    function requireSystemActive() external view {\n        _internalRequireSystemActive();\n    }\n\n    function systemSuspended() external view returns (bool) {\n        return systemSuspension.suspended;\n    }\n\n    function requireIssuanceActive() external view {\n        // Issuance requires the system be active\n        _internalRequireSystemActive();\n\n        // and issuance itself of course\n        _internalRequireIssuanceActive();\n    }\n\n    function requireExchangeActive() external view {\n        // Exchanging requires the system be active\n        _internalRequireSystemActive();\n\n        // and exchanging itself of course\n        _internalRequireExchangeActive();\n    }\n\n    function requireSynthExchangeActive(bytes32 currencyKey) external view {\n        // Synth exchange and transfer requires the system be active\n        _internalRequireSystemActive();\n        _internalRequireSynthExchangeActive(currencyKey);\n    }\n\n    function requireFuturesActive() external view {\n        _internalRequireSystemActive();\n        _internalRequireExchangeActive();\n        _internalRequireFuturesActive();\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function requireFuturesMarketActive(bytes32 marketKey) external view {\n        _internalRequireSystemActive();\n        _internalRequireExchangeActive(); // exchanging implicitely used\n        _internalRequireFuturesActive(); // futures global flag\n        _internalRequireFuturesMarketActive(marketKey); // specific futures market flag\n    }\n\n    function synthSuspended(bytes32 currencyKey) external view returns (bool) {\n        return systemSuspension.suspended || synthSuspension[currencyKey].suspended;\n    }\n\n    function requireSynthActive(bytes32 currencyKey) external view {\n        // Synth exchange and transfer requires the system be active\n        _internalRequireSystemActive();\n        _internalRequireSynthActive(currencyKey);\n    }\n\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view {\n        // Synth exchange and transfer requires the system be active\n        _internalRequireSystemActive();\n        _internalRequireSynthActive(sourceCurrencyKey);\n        _internalRequireSynthActive(destinationCurrencyKey);\n    }\n\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view {\n        // Synth exchange and transfer requires the system be active\n        _internalRequireSystemActive();\n\n        // and exchanging must be active\n        _internalRequireExchangeActive();\n\n        // and the synth exchanging between the synths must be active\n        _internalRequireSynthExchangeActive(sourceCurrencyKey);\n        _internalRequireSynthExchangeActive(destinationCurrencyKey);\n\n        // and finally, the synths cannot be suspended\n        _internalRequireSynthActive(sourceCurrencyKey);\n        _internalRequireSynthActive(destinationCurrencyKey);\n    }\n\n    function isSystemUpgrading() external view returns (bool) {\n        return systemSuspension.suspended && systemSuspension.reason == SUSPENSION_REASON_UPGRADE;\n    }\n\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons)\n    {\n        exchangeSuspensions = new bool[](synths.length);\n        reasons = new uint256[](synths.length);\n\n        for (uint i = 0; i < synths.length; i++) {\n            exchangeSuspensions[i] = synthExchangeSuspension[synths[i]].suspended;\n            reasons[i] = synthExchangeSuspension[synths[i]].reason;\n        }\n    }\n\n    function getSynthSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons)\n    {\n        suspensions = new bool[](synths.length);\n        reasons = new uint256[](synths.length);\n\n        for (uint i = 0; i < synths.length; i++) {\n            suspensions[i] = synthSuspension[synths[i]].suspended;\n            reasons[i] = synthSuspension[synths[i]].reason;\n        }\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function getFuturesMarketSuspensions(bytes32[] calldata marketKeys)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons)\n    {\n        suspensions = new bool[](marketKeys.length);\n        reasons = new uint256[](marketKeys.length);\n\n        for (uint i = 0; i < marketKeys.length; i++) {\n            suspensions[i] = futuresMarketSuspension[marketKeys[i]].suspended;\n            reasons[i] = futuresMarketSuspension[marketKeys[i]].reason;\n        }\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n    function updateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) external onlyOwner {\n        _internalUpdateAccessControl(section, account, canSuspend, canResume);\n    }\n\n    function updateAccessControls(\n        bytes32[] calldata sections,\n        address[] calldata accounts,\n        bool[] calldata canSuspends,\n        bool[] calldata canResumes\n    ) external onlyOwner {\n        require(\n            sections.length == accounts.length &&\n                accounts.length == canSuspends.length &&\n                canSuspends.length == canResumes.length,\n            \"Input array lengths must match\"\n        );\n        for (uint i = 0; i < sections.length; i++) {\n            _internalUpdateAccessControl(sections[i], accounts[i], canSuspends[i], canResumes[i]);\n        }\n    }\n\n    function suspendSystem(uint256 reason) external {\n        _requireAccessToSuspend(SECTION_SYSTEM);\n        systemSuspension.suspended = true;\n        systemSuspension.reason = uint248(reason);\n        emit SystemSuspended(systemSuspension.reason);\n    }\n\n    function resumeSystem() external {\n        _requireAccessToResume(SECTION_SYSTEM);\n        systemSuspension.suspended = false;\n        emit SystemResumed(uint256(systemSuspension.reason));\n        systemSuspension.reason = 0;\n    }\n\n    function suspendIssuance(uint256 reason) external {\n        _requireAccessToSuspend(SECTION_ISSUANCE);\n        issuanceSuspension.suspended = true;\n        issuanceSuspension.reason = uint248(reason);\n        emit IssuanceSuspended(reason);\n    }\n\n    function resumeIssuance() external {\n        _requireAccessToResume(SECTION_ISSUANCE);\n        issuanceSuspension.suspended = false;\n        emit IssuanceResumed(uint256(issuanceSuspension.reason));\n        issuanceSuspension.reason = 0;\n    }\n\n    function suspendExchange(uint256 reason) external {\n        _requireAccessToSuspend(SECTION_EXCHANGE);\n        exchangeSuspension.suspended = true;\n        exchangeSuspension.reason = uint248(reason);\n        emit ExchangeSuspended(reason);\n    }\n\n    function resumeExchange() external {\n        _requireAccessToResume(SECTION_EXCHANGE);\n        exchangeSuspension.suspended = false;\n        emit ExchangeResumed(uint256(exchangeSuspension.reason));\n        exchangeSuspension.reason = 0;\n    }\n\n    function suspendFutures(uint256 reason) external {\n        _requireAccessToSuspend(SECTION_FUTURES);\n        futuresSuspension.suspended = true;\n        futuresSuspension.reason = uint248(reason);\n        emit FuturesSuspended(reason);\n    }\n\n    function resumeFutures() external {\n        _requireAccessToResume(SECTION_FUTURES);\n        futuresSuspension.suspended = false;\n        emit FuturesResumed(uint256(futuresSuspension.reason));\n        futuresSuspension.reason = 0;\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function suspendFuturesMarket(bytes32 marketKey, uint256 reason) external {\n        bytes32[] memory marketKeys = new bytes32[](1);\n        marketKeys[0] = marketKey;\n        _internalSuspendFuturesMarkets(marketKeys, reason);\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function suspendFuturesMarkets(bytes32[] calldata marketKeys, uint256 reason) external {\n        _internalSuspendFuturesMarkets(marketKeys, reason);\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function resumeFuturesMarket(bytes32 marketKey) external {\n        bytes32[] memory marketKeys = new bytes32[](1);\n        marketKeys[0] = marketKey;\n        _internalResumeFuturesMarkets(marketKeys);\n    }\n\n    /// @notice marketKey doesn't necessarily correspond to asset key\n    function resumeFuturesMarkets(bytes32[] calldata marketKeys) external {\n        _internalResumeFuturesMarkets(marketKeys);\n    }\n\n    function suspendSynthExchange(bytes32 currencyKey, uint256 reason) external {\n        bytes32[] memory currencyKeys = new bytes32[](1);\n        currencyKeys[0] = currencyKey;\n        _internalSuspendSynthExchange(currencyKeys, reason);\n    }\n\n    function suspendSynthsExchange(bytes32[] calldata currencyKeys, uint256 reason) external {\n        _internalSuspendSynthExchange(currencyKeys, reason);\n    }\n\n    function resumeSynthExchange(bytes32 currencyKey) external {\n        bytes32[] memory currencyKeys = new bytes32[](1);\n        currencyKeys[0] = currencyKey;\n        _internalResumeSynthsExchange(currencyKeys);\n    }\n\n    function resumeSynthsExchange(bytes32[] calldata currencyKeys) external {\n        _internalResumeSynthsExchange(currencyKeys);\n    }\n\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external {\n        bytes32[] memory currencyKeys = new bytes32[](1);\n        currencyKeys[0] = currencyKey;\n        _internalSuspendSynths(currencyKeys, reason);\n    }\n\n    function suspendSynths(bytes32[] calldata currencyKeys, uint256 reason) external {\n        _internalSuspendSynths(currencyKeys, reason);\n    }\n\n    function resumeSynth(bytes32 currencyKey) external {\n        bytes32[] memory currencyKeys = new bytes32[](1);\n        currencyKeys[0] = currencyKey;\n        _internalResumeSynths(currencyKeys);\n    }\n\n    function resumeSynths(bytes32[] calldata currencyKeys) external {\n        _internalResumeSynths(currencyKeys);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _requireAccessToSuspend(bytes32 section) internal view {\n        require(accessControl[section][msg.sender].canSuspend, \"Restricted to access control list\");\n    }\n\n    function _requireAccessToResume(bytes32 section) internal view {\n        require(accessControl[section][msg.sender].canResume, \"Restricted to access control list\");\n    }\n\n    function _internalRequireSystemActive() internal view {\n        require(\n            !systemSuspension.suspended,\n            systemSuspension.reason == SUSPENSION_REASON_UPGRADE\n                ? \"Synthetix is suspended, upgrade in progress... please stand by\"\n                : \"Synthetix is suspended. Operation prohibited\"\n        );\n    }\n\n    function _internalRequireIssuanceActive() internal view {\n        require(!issuanceSuspension.suspended, \"Issuance is suspended. Operation prohibited\");\n    }\n\n    function _internalRequireExchangeActive() internal view {\n        require(!exchangeSuspension.suspended, \"Exchange is suspended. Operation prohibited\");\n    }\n\n    function _internalRequireFuturesActive() internal view {\n        require(!futuresSuspension.suspended, \"Futures markets are suspended. Operation prohibited\");\n    }\n\n    function _internalRequireSynthExchangeActive(bytes32 currencyKey) internal view {\n        require(!synthExchangeSuspension[currencyKey].suspended, \"Synth exchange suspended. Operation prohibited\");\n    }\n\n    function _internalRequireSynthActive(bytes32 currencyKey) internal view {\n        require(!synthSuspension[currencyKey].suspended, \"Synth is suspended. Operation prohibited\");\n    }\n\n    function _internalRequireFuturesMarketActive(bytes32 marketKey) internal view {\n        require(!futuresMarketSuspension[marketKey].suspended, \"Market suspended\");\n    }\n\n    function _internalSuspendSynths(bytes32[] memory currencyKeys, uint256 reason) internal {\n        _requireAccessToSuspend(SECTION_SYNTH);\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n            synthSuspension[currencyKey].suspended = true;\n            synthSuspension[currencyKey].reason = uint248(reason);\n            emit SynthSuspended(currencyKey, reason);\n        }\n    }\n\n    function _internalResumeSynths(bytes32[] memory currencyKeys) internal {\n        _requireAccessToResume(SECTION_SYNTH);\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n            emit SynthResumed(currencyKey, uint256(synthSuspension[currencyKey].reason));\n            delete synthSuspension[currencyKey];\n        }\n    }\n\n    function _internalSuspendSynthExchange(bytes32[] memory currencyKeys, uint256 reason) internal {\n        _requireAccessToSuspend(SECTION_SYNTH_EXCHANGE);\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n            synthExchangeSuspension[currencyKey].suspended = true;\n            synthExchangeSuspension[currencyKey].reason = uint248(reason);\n            emit SynthExchangeSuspended(currencyKey, reason);\n        }\n    }\n\n    function _internalResumeSynthsExchange(bytes32[] memory currencyKeys) internal {\n        _requireAccessToResume(SECTION_SYNTH_EXCHANGE);\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n            emit SynthExchangeResumed(currencyKey, uint256(synthExchangeSuspension[currencyKey].reason));\n            delete synthExchangeSuspension[currencyKey];\n        }\n    }\n\n    function _internalSuspendFuturesMarkets(bytes32[] memory marketKeys, uint256 reason) internal {\n        _requireAccessToSuspend(SECTION_FUTURES);\n        for (uint i = 0; i < marketKeys.length; i++) {\n            bytes32 marketKey = marketKeys[i];\n            futuresMarketSuspension[marketKey].suspended = true;\n            futuresMarketSuspension[marketKey].reason = uint248(reason);\n            emit FuturesMarketSuspended(marketKey, reason);\n        }\n    }\n\n    function _internalResumeFuturesMarkets(bytes32[] memory marketKeys) internal {\n        _requireAccessToResume(SECTION_FUTURES);\n        for (uint i = 0; i < marketKeys.length; i++) {\n            bytes32 marketKey = marketKeys[i];\n            emit FuturesMarketResumed(marketKey, uint256(futuresMarketSuspension[marketKey].reason));\n            delete futuresMarketSuspension[marketKey];\n        }\n    }\n\n    function _internalUpdateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) internal {\n        require(\n            section == SECTION_SYSTEM ||\n                section == SECTION_ISSUANCE ||\n                section == SECTION_EXCHANGE ||\n                section == SECTION_FUTURES ||\n                section == SECTION_SYNTH_EXCHANGE ||\n                section == SECTION_SYNTH,\n            \"Invalid section supplied\"\n        );\n        accessControl[section][account].canSuspend = canSuspend;\n        accessControl[section][account].canResume = canResume;\n        emit AccessControlUpdated(section, account, canSuspend, canResume);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SystemSuspended(uint256 reason);\n    event SystemResumed(uint256 reason);\n\n    event IssuanceSuspended(uint256 reason);\n    event IssuanceResumed(uint256 reason);\n\n    event ExchangeSuspended(uint256 reason);\n    event ExchangeResumed(uint256 reason);\n\n    event FuturesSuspended(uint256 reason);\n    event FuturesResumed(uint256 reason);\n\n    event SynthExchangeSuspended(bytes32 currencyKey, uint256 reason);\n    event SynthExchangeResumed(bytes32 currencyKey, uint256 reason);\n\n    event SynthSuspended(bytes32 currencyKey, uint256 reason);\n    event SynthResumed(bytes32 currencyKey, uint256 reason);\n\n    event FuturesMarketSuspended(bytes32 marketKey, uint256 reason);\n    event FuturesMarketResumed(bytes32 marketKey, uint256 reason);\n\n    event AccessControlUpdated(bytes32 indexed section, address indexed account, bool canSuspend, bool canResume);\n}\n\n\ncontract LegacyOwned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        owner = _owner;\n    }\n\n    function nominateOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner);\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\ncontract LegacyTokenState is LegacyOwned {\n    // the address of the contract that can modify balances and allowances\n    // this can only be changed by the owner of this contract\n    address public associatedContract;\n\n    // ERC20 fields.\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    constructor(address _owner, address _associatedContract) public LegacyOwned(_owner) {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== SETTERS ========== */\n\n    // Change the associated contract to a new address\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    function setAllowance(\n        address tokenOwner,\n        address spender,\n        uint value\n    ) external onlyAssociatedContract {\n        allowance[tokenOwner][spender] = value;\n    }\n\n    function setBalanceOf(address account, uint value) external onlyAssociatedContract {\n        balanceOf[account] = value;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyAssociatedContract {\n        require(msg.sender == associatedContract);\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AssociatedContractUpdated(address _associatedContract);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/irewardescrow\ninterface IRewardEscrow {\n    // Views\n    function balanceOf(address account) external view returns (uint);\n\n    function numVestingEntries(address account) external view returns (uint);\n\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\n\n    function totalVestedAccountBalance(address account) external view returns (uint);\n\n    function getVestingScheduleEntry(address account, uint index) external view returns (uint[2] memory);\n\n    function getNextVestingIndex(address account) external view returns (uint);\n\n    // Mutative functions\n    function appendVestingEntry(address account, uint quantity) external;\n\n    function vest() external;\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n// Libraries\n\n\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    // Computes `a - b`, setting the value to 0 if b > a.\n    function floorsub(uint a, uint b) internal pure returns (uint) {\n        return b >= a ? 0 : a - b;\n    }\n\n    /* ---------- Utilities ---------- */\n    /*\n     * Absolute value of the input, returned as a signed number.\n     */\n    function signedAbs(int x) internal pure returns (int) {\n        return x < 0 ? -x : x;\n    }\n\n    /*\n     * Absolute value of the input, returned as an unsigned number.\n     */\n    function abs(int x) internal pure returns (uint) {\n        return uint(signedAbs(x));\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ierc20\ninterface IERC20 {\n    // ERC20 Optional Views\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    // Views\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    // Mutative functions\n    function transfer(address to, uint value) external returns (bool);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ifeepool\ninterface IFeePool {\n    // Views\n\n    // solhint-disable-next-line func-name-mixedcase\n    function FEE_ADDRESS() external view returns (address);\n\n    function feesAvailable(address account) external view returns (uint, uint);\n\n    function feePeriodDuration() external view returns (uint);\n\n    function isFeesClaimable(address account) external view returns (bool);\n\n    function targetThreshold() external view returns (uint);\n\n    function totalFeesAvailable() external view returns (uint);\n\n    function totalRewardsAvailable() external view returns (uint);\n\n    // Mutative Functions\n    function claimFees() external returns (bool);\n\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\n\n    function closeCurrentFeePeriod() external;\n\n    function closeSecondary(uint snxBackedDebt, uint debtShareSupply) external;\n\n    function recordFeePaid(uint sUSDAmount) external;\n\n    function setRewardsToDistribute(uint amount) external;\n}\n\n\ninterface IVirtualSynth {\n    // Views\n    function balanceOfUnderlying(address account) external view returns (uint);\n\n    function rate() external view returns (uint);\n\n    function readyToSettle() external view returns (bool);\n\n    function secsLeftInWaitingPeriod() external view returns (uint);\n\n    function settled() external view returns (bool);\n\n    function synth() external view returns (ISynth);\n\n    // Mutative functions\n    function settle(address account) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetix\ninterface ISynthetix {\n    // Views\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\n\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);\n\n    function totalIssuedSynthsExcludeOtherCollateral(bytes32 currencyKey) external view returns (uint);\n\n    function transferableSynthetix(address account) external view returns (uint transferable);\n\n    // Mutative Functions\n    function burnSynths(uint amount) external;\n\n    function burnSynthsOnBehalf(address burnForAddress, uint amount) external;\n\n    function burnSynthsToTarget() external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\n\n    function exchange(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalf(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeWithTracking(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeWithTrackingForInitiator(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalfWithTracking(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeWithVirtual(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\n\n    function exchangeAtomically(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        bytes32 trackingCode,\n        uint minAmount\n    ) external returns (uint amountReceived);\n\n    function issueMaxSynths() external;\n\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\n\n    function issueSynths(uint amount) external;\n\n    function issueSynthsOnBehalf(address issueForAddress, uint amount) external;\n\n    function mint() external returns (bool);\n\n    function settle(bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntries\n        );\n\n    // Liquidations\n    function liquidateDelinquentAccount(address account, uint susdAmount) external returns (bool);\n\n    // Restricted Functions\n\n    function mintSecondary(address account, uint amount) external;\n\n    function mintSecondaryRewards(uint amount) external;\n\n    function burnSecondary(address account, uint amount) external;\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/rewardescrow\ncontract RewardEscrow is Owned, IRewardEscrow {\n    using SafeMath for uint;\n\n    /* The corresponding Synthetix contract. */\n    ISynthetix public synthetix;\n\n    IFeePool public feePool;\n\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\n     * These are the times at which each given quantity of SNX vests. */\n    mapping(address => uint[2][]) public vestingSchedules;\n\n    /* An account's total escrowed synthetix balance to save recomputing this for fee extraction purposes. */\n    mapping(address => uint) public totalEscrowedAccountBalance;\n\n    /* An account's total vested reward synthetix. */\n    mapping(address => uint) public totalVestedAccountBalance;\n\n    /* The total remaining escrowed balance, for verifying the actual synthetix balance of this contract against. */\n    uint public totalEscrowedBalance;\n\n    uint internal constant TIME_INDEX = 0;\n    uint internal constant QUANTITY_INDEX = 1;\n\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules.\n     * There are 5 years of the supply schedule */\n    uint public constant MAX_VESTING_ENTRIES = 52 * 5;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        ISynthetix _synthetix,\n        IFeePool _feePool\n    ) public Owned(_owner) {\n        synthetix = _synthetix;\n        feePool = _feePool;\n    }\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice set the synthetix contract address as we need to transfer SNX when the user vests\n     */\n    function setSynthetix(ISynthetix _synthetix) external onlyOwner {\n        synthetix = _synthetix;\n        emit SynthetixUpdated(address(_synthetix));\n    }\n\n    /**\n     * @notice set the FeePool contract as it is the only authority to be able to call\n     * appendVestingEntry with the onlyFeePool modifer\n     */\n    function setFeePool(IFeePool _feePool) external onlyOwner {\n        feePool = _feePool;\n        emit FeePoolUpdated(address(_feePool));\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\n     */\n    function balanceOf(address account) public view returns (uint) {\n        return totalEscrowedAccountBalance[account];\n    }\n\n    function _numVestingEntries(address account) internal view returns (uint) {\n        return vestingSchedules[account].length;\n    }\n\n    /**\n     * @notice The number of vesting dates in an account's schedule.\n     */\n    function numVestingEntries(address account) external view returns (uint) {\n        return vestingSchedules[account].length;\n    }\n\n    /**\n     * @notice Get a particular schedule entry for an account.\n     * @return A pair of uints: (timestamp, synthetix quantity).\n     */\n    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {\n        return vestingSchedules[account][index];\n    }\n\n    /**\n     * @notice Get the time at which a given schedule entry will vest.\n     */\n    function getVestingTime(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Get the quantity of SNX associated with a given schedule entry.\n     */\n    function getVestingQuantity(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\n     */\n    function getNextVestingIndex(address account) public view returns (uint) {\n        uint len = _numVestingEntries(account);\n        for (uint i = 0; i < len; i++) {\n            if (getVestingTime(account, i) != 0) {\n                return i;\n            }\n        }\n        return len;\n    }\n\n    /**\n     * @notice Obtain the next schedule entry that will vest for a given user.\n     * @return A pair of uints: (timestamp, synthetix quantity). */\n    function getNextVestingEntry(address account) public view returns (uint[2] memory) {\n        uint index = getNextVestingIndex(account);\n        if (index == _numVestingEntries(account)) {\n            return [uint(0), 0];\n        }\n        return getVestingScheduleEntry(account, index);\n    }\n\n    /**\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingTime(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingQuantity(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice return the full vesting schedule entries vest for a given user.\n     * @dev For DApps to display the vesting schedule for the\n     * inflationary supply over 5 years. Solidity cant return variable length arrays\n     * so this is returning pairs of data. Vesting Time at [0] and quantity at [1] and so on\n     */\n    function checkAccountSchedule(address account) public view returns (uint[520] memory) {\n        uint[520] memory _result;\n        uint schedules = _numVestingEntries(account);\n        for (uint i = 0; i < schedules; i++) {\n            uint[2] memory pair = getVestingScheduleEntry(account, i);\n            _result[i * 2] = pair[0];\n            _result[i * 2 + 1] = pair[1];\n        }\n        return _result;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function _appendVestingEntry(address account, uint quantity) internal {\n        /* No empty or already-passed vesting entries allowed. */\n        require(quantity != 0, \"Quantity cannot be zero\");\n\n        /* There must be enough balance in the contract to provide for the vesting entry. */\n        totalEscrowedBalance = totalEscrowedBalance.add(quantity);\n        require(\n            totalEscrowedBalance <= IERC20(address(synthetix)).balanceOf(address(this)),\n            \"Must be enough balance in the contract to provide for the vesting entry\"\n        );\n\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\n        uint scheduleLength = vestingSchedules[account].length;\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \"Vesting schedule is too long\");\n\n        /* Escrow the tokens for 1 year. */\n        uint time = now + 52 weeks;\n\n        if (scheduleLength == 0) {\n            totalEscrowedAccountBalance[account] = quantity;\n        } else {\n            /* Disallow adding new vested SNX earlier than the last one.\n             * Since entries are only appended, this means that no vesting date can be repeated. */\n            require(\n                getVestingTime(account, scheduleLength - 1) < time,\n                \"Cannot add new vested entries earlier than the last one\"\n            );\n            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(quantity);\n        }\n\n        vestingSchedules[account].push([time, quantity]);\n\n        emit VestingEntryCreated(account, now, quantity);\n    }\n\n    /**\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\n     * @dev A call to this should accompany a previous successful call to synthetix.transfer(rewardEscrow, amount),\n     * to ensure that when the funds are withdrawn, there is enough balance.\n     * Note; although this function could technically be used to produce unbounded\n     * arrays, it's only withinn the 4 year period of the weekly inflation schedule.\n     * @param account The account to append a new vesting entry to.\n     * @param quantity The quantity of SNX that will be escrowed.\n     */\n    function appendVestingEntry(address account, uint quantity) external onlyFeePool {\n        _appendVestingEntry(account, quantity);\n    }\n\n    /**\n     * @notice Allow a user to withdraw any SNX in their schedule that have vested.\n     */\n    function vest() external {\n        uint numEntries = _numVestingEntries(msg.sender);\n        uint total;\n        for (uint i = 0; i < numEntries; i++) {\n            uint time = getVestingTime(msg.sender, i);\n            /* The list is sorted; when we reach the first future time, bail out. */\n            if (time > now) {\n                break;\n            }\n            uint qty = getVestingQuantity(msg.sender, i);\n            if (qty > 0) {\n                vestingSchedules[msg.sender][i] = [0, 0];\n                total = total.add(qty);\n            }\n        }\n\n        if (total != 0) {\n            totalEscrowedBalance = totalEscrowedBalance.sub(total);\n            totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].sub(total);\n            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].add(total);\n            IERC20(address(synthetix)).transfer(msg.sender, total);\n            emit Vested(msg.sender, now, total);\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyFeePool() {\n        bool isFeePool = msg.sender == address(feePool);\n\n        require(isFeePool, \"Only the FeePool contracts can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SynthetixUpdated(address newSynthetix);\n\n    event FeePoolUpdated(address newFeePool);\n\n    event Vested(address indexed beneficiary, uint time, uint value);\n\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/irewardsdistribution\ninterface IRewardsDistribution {\n    // Structs\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    // Views\n    function authority() external view returns (address);\n\n    function distributions(uint index) external view returns (address destination, uint amount); // DistributionData\n\n    function distributionsLength() external view returns (uint);\n\n    // Mutative Functions\n    function distributeRewards(uint amount) external returns (bool);\n}\n\n\n// Inheritance\n\n\n// Libraires\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/rewardsdistribution\ncontract RewardsDistribution is Owned, IRewardsDistribution {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the authority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    function distributeRewards(uint amount) external returns (bool) {\n        require(amount > 0, \"Nothing to distribute\");\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(\n            IERC20(synthetixProxy).balanceOf(address(this)) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n\n                // solhint-disable avoid-low-level-calls\n                (bool success, ) = distributions[i].destination.call(payload);\n\n                if (!success) {\n                    // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n                }\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iflexiblestorage\ninterface IFlexibleStorage {\n    // Views\n    function getUIntValue(bytes32 contractName, bytes32 record) external view returns (uint);\n\n    function getUIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (uint[] memory);\n\n    function getIntValue(bytes32 contractName, bytes32 record) external view returns (int);\n\n    function getIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (int[] memory);\n\n    function getAddressValue(bytes32 contractName, bytes32 record) external view returns (address);\n\n    function getAddressValues(bytes32 contractName, bytes32[] calldata records) external view returns (address[] memory);\n\n    function getBoolValue(bytes32 contractName, bytes32 record) external view returns (bool);\n\n    function getBoolValues(bytes32 contractName, bytes32[] calldata records) external view returns (bool[] memory);\n\n    function getBytes32Value(bytes32 contractName, bytes32 record) external view returns (bytes32);\n\n    function getBytes32Values(bytes32 contractName, bytes32[] calldata records) external view returns (bytes32[] memory);\n\n    // Mutative functions\n    function deleteUIntValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteIntValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteAddressValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteBoolValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteBytes32Value(bytes32 contractName, bytes32 record) external;\n\n    function setUIntValue(\n        bytes32 contractName,\n        bytes32 record,\n        uint value\n    ) external;\n\n    function setUIntValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        uint[] calldata values\n    ) external;\n\n    function setIntValue(\n        bytes32 contractName,\n        bytes32 record,\n        int value\n    ) external;\n\n    function setIntValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        int[] calldata values\n    ) external;\n\n    function setAddressValue(\n        bytes32 contractName,\n        bytes32 record,\n        address value\n    ) external;\n\n    function setAddressValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        address[] calldata values\n    ) external;\n\n    function setBoolValue(\n        bytes32 contractName,\n        bytes32 record,\n        bool value\n    ) external;\n\n    function setBoolValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        bool[] calldata values\n    ) external;\n\n    function setBytes32Value(\n        bytes32 contractName,\n        bytes32 record,\n        bytes32 value\n    ) external;\n\n    function setBytes32Values(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        bytes32[] calldata values\n    ) external;\n}\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/mixinsystemsettings\ncontract MixinSystemSettings is MixinResolver {\n    // must match the one defined SystemSettingsLib, defined in both places due to sol v0.5 limitations\n    bytes32 internal constant SETTING_CONTRACT_NAME = \"SystemSettings\";\n\n    bytes32 internal constant SETTING_WAITING_PERIOD_SECS = \"waitingPeriodSecs\";\n    bytes32 internal constant SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR = \"priceDeviationThresholdFactor\";\n    bytes32 internal constant SETTING_ISSUANCE_RATIO = \"issuanceRatio\";\n    bytes32 internal constant SETTING_FEE_PERIOD_DURATION = \"feePeriodDuration\";\n    bytes32 internal constant SETTING_TARGET_THRESHOLD = \"targetThreshold\";\n    bytes32 internal constant SETTING_LIQUIDATION_DELAY = \"liquidationDelay\";\n    bytes32 internal constant SETTING_LIQUIDATION_RATIO = \"liquidationRatio\";\n    bytes32 internal constant SETTING_LIQUIDATION_PENALTY = \"liquidationPenalty\";\n    bytes32 internal constant SETTING_RATE_STALE_PERIOD = \"rateStalePeriod\";\n    /* ========== Exchange Fees Related ========== */\n    bytes32 internal constant SETTING_EXCHANGE_FEE_RATE = \"exchangeFeeRate\";\n    bytes32 internal constant SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD = \"exchangeDynamicFeeThreshold\";\n    bytes32 internal constant SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY = \"exchangeDynamicFeeWeightDecay\";\n    bytes32 internal constant SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS = \"exchangeDynamicFeeRounds\";\n    bytes32 internal constant SETTING_EXCHANGE_MAX_DYNAMIC_FEE = \"exchangeMaxDynamicFee\";\n    /* ========== End Exchange Fees Related ========== */\n    bytes32 internal constant SETTING_MINIMUM_STAKE_TIME = \"minimumStakeTime\";\n    bytes32 internal constant SETTING_AGGREGATOR_WARNING_FLAGS = \"aggregatorWarningFlags\";\n    bytes32 internal constant SETTING_TRADING_REWARDS_ENABLED = \"tradingRewardsEnabled\";\n    bytes32 internal constant SETTING_DEBT_SNAPSHOT_STALE_TIME = \"debtSnapshotStaleTime\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT = \"crossDomainDepositGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT = \"crossDomainEscrowGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT = \"crossDomainRewardGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT = \"crossDomainWithdrawalGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_FEE_PERIOD_CLOSE_GAS_LIMIT = \"crossDomainCloseGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT = \"crossDomainRelayGasLimit\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MAX_ETH = \"etherWrapperMaxETH\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MINT_FEE_RATE = \"etherWrapperMintFeeRate\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_BURN_FEE_RATE = \"etherWrapperBurnFeeRate\";\n    bytes32 internal constant SETTING_WRAPPER_MAX_TOKEN_AMOUNT = \"wrapperMaxTokens\";\n    bytes32 internal constant SETTING_WRAPPER_MINT_FEE_RATE = \"wrapperMintFeeRate\";\n    bytes32 internal constant SETTING_WRAPPER_BURN_FEE_RATE = \"wrapperBurnFeeRate\";\n    bytes32 internal constant SETTING_INTERACTION_DELAY = \"interactionDelay\";\n    bytes32 internal constant SETTING_COLLAPSE_FEE_RATE = \"collapseFeeRate\";\n    bytes32 internal constant SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK = \"atomicMaxVolumePerBlock\";\n    bytes32 internal constant SETTING_ATOMIC_TWAP_WINDOW = \"atomicTwapWindow\";\n    bytes32 internal constant SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING = \"atomicEquivalentForDexPricing\";\n    bytes32 internal constant SETTING_ATOMIC_EXCHANGE_FEE_RATE = \"atomicExchangeFeeRate\";\n    bytes32 internal constant SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = \"atomicVolConsiderationWindow\";\n    bytes32 internal constant SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD = \"atomicVolUpdateThreshold\";\n    bytes32 internal constant SETTING_PURE_CHAINLINK_PRICE_FOR_ATOMIC_SWAPS_ENABLED = \"pureChainlinkForAtomicsEnabled\";\n    bytes32 internal constant SETTING_CROSS_SYNTH_TRANSFER_ENABLED = \"crossChainSynthTransferEnabled\";\n\n    bytes32 internal constant CONTRACT_FLEXIBLESTORAGE = \"FlexibleStorage\";\n\n    enum CrossDomainMessageGasLimits {Deposit, Escrow, Reward, Withdrawal, CloseFeePeriod, Relay}\n\n    struct DynamicFeeConfig {\n        uint threshold;\n        uint weightDecay;\n        uint rounds;\n        uint maxFee;\n    }\n\n    constructor(address _resolver) internal MixinResolver(_resolver) {}\n\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        addresses = new bytes32[](1);\n        addresses[0] = CONTRACT_FLEXIBLESTORAGE;\n    }\n\n    function flexibleStorage() internal view returns (IFlexibleStorage) {\n        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));\n    }\n\n    function _getGasLimitSetting(CrossDomainMessageGasLimits gasLimitType) internal pure returns (bytes32) {\n        if (gasLimitType == CrossDomainMessageGasLimits.Deposit) {\n            return SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Escrow) {\n            return SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Reward) {\n            return SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Withdrawal) {\n            return SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Relay) {\n            return SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.CloseFeePeriod) {\n            return SETTING_CROSS_DOMAIN_FEE_PERIOD_CLOSE_GAS_LIMIT;\n        } else {\n            revert(\"Unknown gas limit type\");\n        }\n    }\n\n    function getCrossDomainMessageGasLimit(CrossDomainMessageGasLimits gasLimitType) internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, _getGasLimitSetting(gasLimitType));\n    }\n\n    function getTradingRewardsEnabled() internal view returns (bool) {\n        return flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME, SETTING_TRADING_REWARDS_ENABLED);\n    }\n\n    function getWaitingPeriodSecs() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_WAITING_PERIOD_SECS);\n    }\n\n    function getPriceDeviationThresholdFactor() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR);\n    }\n\n    function getIssuanceRatio() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ISSUANCE_RATIO);\n    }\n\n    function getFeePeriodDuration() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_FEE_PERIOD_DURATION);\n    }\n\n    function getTargetThreshold() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_TARGET_THRESHOLD);\n    }\n\n    function getLiquidationDelay() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_DELAY);\n    }\n\n    function getLiquidationRatio() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_RATIO);\n    }\n\n    function getLiquidationPenalty() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_PENALTY);\n    }\n\n    function getRateStalePeriod() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_RATE_STALE_PERIOD);\n    }\n\n    /* ========== Exchange Related Fees ========== */\n    function getExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE, currencyKey))\n            );\n    }\n\n    /// @notice Get exchange dynamic fee related keys\n    /// @return threshold, weight decay, rounds, and max fee\n    function getExchangeDynamicFeeConfig() internal view returns (DynamicFeeConfig memory) {\n        bytes32[] memory keys = new bytes32[](4);\n        keys[0] = SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD;\n        keys[1] = SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY;\n        keys[2] = SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS;\n        keys[3] = SETTING_EXCHANGE_MAX_DYNAMIC_FEE;\n        uint[] memory values = flexibleStorage().getUIntValues(SETTING_CONTRACT_NAME, keys);\n        return DynamicFeeConfig({threshold: values[0], weightDecay: values[1], rounds: values[2], maxFee: values[3]});\n    }\n\n    /* ========== End Exchange Related Fees ========== */\n\n    function getMinimumStakeTime() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MINIMUM_STAKE_TIME);\n    }\n\n    function getAggregatorWarningFlags() internal view returns (address) {\n        return flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME, SETTING_AGGREGATOR_WARNING_FLAGS);\n    }\n\n    function getDebtSnapshotStaleTime() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_DEBT_SNAPSHOT_STALE_TIME);\n    }\n\n    function getEtherWrapperMaxETH() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MAX_ETH);\n    }\n\n    function getEtherWrapperMintFeeRate() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MINT_FEE_RATE);\n    }\n\n    function getEtherWrapperBurnFeeRate() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_BURN_FEE_RATE);\n    }\n\n    function getWrapperMaxTokenAmount(address wrapper) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_WRAPPER_MAX_TOKEN_AMOUNT, wrapper))\n            );\n    }\n\n    function getWrapperMintFeeRate(address wrapper) internal view returns (int) {\n        return\n            flexibleStorage().getIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_WRAPPER_MINT_FEE_RATE, wrapper))\n            );\n    }\n\n    function getWrapperBurnFeeRate(address wrapper) internal view returns (int) {\n        return\n            flexibleStorage().getIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_WRAPPER_BURN_FEE_RATE, wrapper))\n            );\n    }\n\n    function getInteractionDelay(address collateral) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_INTERACTION_DELAY, collateral))\n            );\n    }\n\n    function getCollapseFeeRate(address collateral) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_COLLAPSE_FEE_RATE, collateral))\n            );\n    }\n\n    function getAtomicMaxVolumePerBlock() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK);\n    }\n\n    function getAtomicTwapWindow() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_TWAP_WINDOW);\n    }\n\n    function getAtomicEquivalentForDexPricing(bytes32 currencyKey) internal view returns (address) {\n        return\n            flexibleStorage().getAddressValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING, currencyKey))\n            );\n    }\n\n    function getAtomicExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_EXCHANGE_FEE_RATE, currencyKey))\n            );\n    }\n\n    function getAtomicVolatilityConsiderationWindow(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW, currencyKey))\n            );\n    }\n\n    function getAtomicVolatilityUpdateThreshold(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD, currencyKey))\n            );\n    }\n\n    function getPureChainlinkPriceForAtomicSwapsEnabled(bytes32 currencyKey) internal view returns (bool) {\n        return\n            flexibleStorage().getBoolValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_PURE_CHAINLINK_PRICE_FOR_ATOMIC_SWAPS_ENABLED, currencyKey))\n            );\n    }\n\n    function getCrossChainSynthTransferEnabled(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_CROSS_SYNTH_TRANSFER_ENABLED, currencyKey))\n            );\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangerates\ninterface IExchangeRates {\n    // Structs\n    struct RateAndUpdatedTime {\n        uint216 rate;\n        uint40 time;\n    }\n\n    // Views\n    function aggregators(bytes32 currencyKey) external view returns (address);\n\n    function aggregatorWarningFlags() external view returns (address);\n\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\n\n    function anyRateIsInvalidAtRound(bytes32[] calldata currencyKeys, uint[] calldata roundIds) external view returns (bool);\n\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\n\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint value);\n\n    function effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveValueAndRatesAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveAtomicValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint systemValue,\n            uint systemSourceRate,\n            uint systemDestinationRate\n        );\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint);\n\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\n\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\n\n    function rateStalePeriod() external view returns (uint);\n\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(\n        bytes32 currencyKey,\n        uint numRounds,\n        uint roundId\n    ) external view returns (uint[] memory rates, uint[] memory times);\n\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (uint[] memory rates, bool anyRateInvalid);\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\n\n    function synthTooVolatileForAtomicExchange(bytes32 currencyKey) external view returns (bool);\n}\n\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n\n\n/**\n * @title The V2 & V3 Aggregator Interface\n * @notice Solidity V0.5 does not allow interfaces to inherit from other\n * interfaces so this contract is a combination of v0.5 AggregatorInterface.sol\n * and v0.5 AggregatorV3Interface.sol.\n */\ninterface AggregatorV2V3Interface {\n  //\n  // V2 Interface:\n  //\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n\n  //\n  // V3 Interface:\n  //\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n\n\ninterface FlagsInterface {\n  function getFlag(address) external view returns (bool);\n  function getFlags(address[] calldata) external view returns (bool[] memory);\n  function raiseFlag(address) external;\n  function raiseFlags(address[] calldata) external;\n  function lowerFlags(address[] calldata) external;\n  function setRaisingAccessController(address) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/IExchangeCircuitBreaker\ninterface IExchangeCircuitBreaker {\n    // Views\n\n    function exchangeRates() external view returns (address);\n\n    function rateWithInvalid(bytes32 currencyKey) external view returns (uint, bool);\n\n    function priceDeviationThresholdFactor() external view returns (uint);\n\n    function isDeviationAboveThreshold(uint base, uint comparison) external view returns (bool);\n\n    function lastExchangeRate(bytes32 currencyKey) external view returns (uint);\n\n    // Mutative functions\n    function resetLastExchangeRate(bytes32[] calldata currencyKeys) external;\n\n    function rateWithBreakCircuit(bytes32 currencyKey) external returns (uint lastValidRate, bool circuitBroken);\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n// AggregatorInterface from Chainlink represents a decentralized pricing network for a single currency key\n\n// FlagsInterface from Chainlink addresses SIP-76\n\n\n// https://docs.synthetix.io/contracts/source/contracts/exchangerates\ncontract ExchangeRates is Owned, MixinSystemSettings, IExchangeRates {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    bytes32 public constant CONTRACT_NAME = \"ExchangeRates\";\n    //slither-disable-next-line naming-convention\n    bytes32 internal constant sUSD = \"sUSD\";\n\n    // Decentralized oracle networks that feed into pricing aggregators\n    mapping(bytes32 => AggregatorV2V3Interface) public aggregators;\n\n    mapping(bytes32 => uint8) public currencyKeyDecimals;\n\n    // List of aggregator keys for convenient iteration\n    bytes32[] public aggregatorKeys;\n\n    // ========== CONSTRUCTOR ==========\n\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinSystemSettings(_resolver) {}\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function addAggregator(bytes32 currencyKey, address aggregatorAddress) external onlyOwner {\n        AggregatorV2V3Interface aggregator = AggregatorV2V3Interface(aggregatorAddress);\n        // This check tries to make sure that a valid aggregator is being added.\n        // It checks if the aggregator is an existing smart contract that has implemented `latestTimestamp` function.\n\n        require(aggregator.latestRound() >= 0, \"Given Aggregator is invalid\");\n        uint8 decimals = aggregator.decimals();\n        require(decimals <= 18, \"Aggregator decimals should be lower or equal to 18\");\n        if (address(aggregators[currencyKey]) == address(0)) {\n            aggregatorKeys.push(currencyKey);\n        }\n        aggregators[currencyKey] = aggregator;\n        currencyKeyDecimals[currencyKey] = decimals;\n        emit AggregatorAdded(currencyKey, address(aggregator));\n    }\n\n    function removeAggregator(bytes32 currencyKey) external onlyOwner {\n        address aggregator = address(aggregators[currencyKey]);\n        require(aggregator != address(0), \"No aggregator exists for key\");\n        delete aggregators[currencyKey];\n        delete currencyKeyDecimals[currencyKey];\n\n        bool wasRemoved = removeFromArray(currencyKey, aggregatorKeys);\n\n        if (wasRemoved) {\n            emit AggregatorRemoved(currencyKey, aggregator);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory currencies) {\n        uint count = 0;\n        currencies = new bytes32[](aggregatorKeys.length);\n        for (uint i = 0; i < aggregatorKeys.length; i++) {\n            bytes32 currencyKey = aggregatorKeys[i];\n            if (address(aggregators[currencyKey]) == aggregator) {\n                currencies[count++] = currencyKey;\n            }\n        }\n    }\n\n    function rateStalePeriod() external view returns (uint) {\n        return getRateStalePeriod();\n    }\n\n    function aggregatorWarningFlags() external view returns (address) {\n        return getAggregatorWarningFlags();\n    }\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time) {\n        RateAndUpdatedTime memory rateAndTime = _getRateAndUpdatedTime(currencyKey);\n        return (rateAndTime.rate, rateAndTime.time);\n    }\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint) {\n        uint roundId = startingRoundId;\n        uint nextTimestamp = 0;\n        while (true) {\n            (, nextTimestamp) = _getRateAndTimestampAtRound(currencyKey, roundId + 1);\n            // if there's no new round, then the previous roundId was the latest\n            if (nextTimestamp == 0 || nextTimestamp > startingTimestamp + timediff) {\n                return roundId;\n            }\n            roundId++;\n        }\n        return roundId;\n    }\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint) {\n        return _getCurrentRoundId(currencyKey);\n    }\n\n    function effectiveValueAndRatesAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        )\n    {\n        (sourceRate, ) = _getRateAndTimestampAtRound(sourceCurrencyKey, roundIdForSrc);\n        // If there's no change in the currency, then just return the amount they gave us\n        if (sourceCurrencyKey == destinationCurrencyKey) {\n            destinationRate = sourceRate;\n            value = sourceAmount;\n        } else {\n            (destinationRate, ) = _getRateAndTimestampAtRound(destinationCurrencyKey, roundIdForDest);\n            // prevent divide-by 0 error (this happens if the dest is not a valid rate)\n            if (destinationRate > 0) {\n                // Calculate the effective value by going from source -> USD -> destination\n                value = sourceAmount.multiplyDecimalRound(sourceRate).divideDecimalRound(destinationRate);\n            }\n        }\n    }\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time) {\n        return _getRateAndTimestampAtRound(currencyKey, roundId);\n    }\n\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256) {\n        return _getUpdatedTime(currencyKey);\n    }\n\n    function lastRateUpdateTimesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory) {\n        uint[] memory lastUpdateTimes = new uint[](currencyKeys.length);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            lastUpdateTimes[i] = _getUpdatedTime(currencyKeys[i]);\n        }\n\n        return lastUpdateTimes;\n    }\n\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint value) {\n        (value, , ) = _effectiveValueAndRates(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);\n    }\n\n    function effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        )\n    {\n        return _effectiveValueAndRates(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);\n    }\n\n    // SIP-120 Atomic exchanges\n    function effectiveAtomicValueAndRates(\n        bytes32,\n        uint,\n        bytes32\n    )\n        external\n        view\n        returns (\n            uint,\n            uint,\n            uint,\n            uint\n        )\n    {\n        _notImplemented();\n    }\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint) {\n        return _getRateAndUpdatedTime(currencyKey).rate;\n    }\n\n    /// @notice getting N rounds of rates for a currency at a specific round\n    /// @param currencyKey the currency key\n    /// @param numRounds the number of rounds to get\n    /// @param roundId the round id\n    /// @return a list of rates and a list of times\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(\n        bytes32 currencyKey,\n        uint numRounds,\n        uint roundId\n    ) external view returns (uint[] memory rates, uint[] memory times) {\n        rates = new uint[](numRounds);\n        times = new uint[](numRounds);\n\n        roundId = roundId > 0 ? roundId : _getCurrentRoundId(currencyKey);\n        for (uint i = 0; i < numRounds; i++) {\n            // fetch the rate and treat is as current, so inverse limits if frozen will always be applied\n            // regardless of current rate\n            (rates[i], times[i]) = _getRateAndTimestampAtRound(currencyKey, roundId);\n\n            if (roundId == 0) {\n                // if we hit the last round, then return what we have\n                return (rates, times);\n            } else {\n                roundId--;\n            }\n        }\n    }\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory) {\n        uint[] memory _localRates = new uint[](currencyKeys.length);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            _localRates[i] = _getRate(currencyKeys[i]);\n        }\n\n        return _localRates;\n    }\n\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid) {\n        RateAndUpdatedTime memory rateAndTime = _getRateAndUpdatedTime(currencyKey);\n\n        if (currencyKey == sUSD) {\n            return (rateAndTime.rate, false);\n        }\n        return (\n            rateAndTime.rate,\n            _rateIsStaleWithTime(getRateStalePeriod(), rateAndTime.time) ||\n                _rateIsFlagged(currencyKey, FlagsInterface(getAggregatorWarningFlags()))\n        );\n    }\n\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (uint[] memory rates, bool anyRateInvalid)\n    {\n        rates = new uint[](currencyKeys.length);\n\n        uint256 _rateStalePeriod = getRateStalePeriod();\n\n        // fetch all flags at once\n        bool[] memory flagList = getFlagsForRates(currencyKeys);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            // do one lookup of the rate & time to minimize gas\n            RateAndUpdatedTime memory rateEntry = _getRateAndUpdatedTime(currencyKeys[i]);\n            rates[i] = rateEntry.rate;\n            if (!anyRateInvalid && currencyKeys[i] != sUSD) {\n                anyRateInvalid = flagList[i] || _rateIsStaleWithTime(_rateStalePeriod, rateEntry.time);\n            }\n        }\n    }\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool) {\n        return _rateIsStale(currencyKey, getRateStalePeriod());\n    }\n\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool) {\n        return\n            _rateIsStale(currencyKey, getRateStalePeriod()) ||\n            _rateIsFlagged(currencyKey, FlagsInterface(getAggregatorWarningFlags()));\n    }\n\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool) {\n        return _rateIsFlagged(currencyKey, FlagsInterface(getAggregatorWarningFlags()));\n    }\n\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool) {\n        // Loop through each key and check whether the data point is stale.\n\n        uint256 _rateStalePeriod = getRateStalePeriod();\n        bool[] memory flagList = getFlagsForRates(currencyKeys);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            if (flagList[i] || _rateIsStale(currencyKeys[i], _rateStalePeriod)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /// this method checks whether any rate is:\n    /// 1. flagged\n    /// 2. stale with respect to current time (now)\n    function anyRateIsInvalidAtRound(bytes32[] calldata currencyKeys, uint[] calldata roundIds)\n        external\n        view\n        returns (bool)\n    {\n        // Loop through each key and check whether the data point is stale.\n\n        require(roundIds.length == currencyKeys.length, \"roundIds must be the same length as currencyKeys\");\n\n        uint256 _rateStalePeriod = getRateStalePeriod();\n        bool[] memory flagList = getFlagsForRates(currencyKeys);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            if (flagList[i] || _rateIsStaleAtRound(currencyKeys[i], roundIds[i], _rateStalePeriod)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function synthTooVolatileForAtomicExchange(bytes32) external view returns (bool) {\n        _notImplemented();\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function getFlagsForRates(bytes32[] memory currencyKeys) internal view returns (bool[] memory flagList) {\n        FlagsInterface _flags = FlagsInterface(getAggregatorWarningFlags());\n\n        // fetch all flags at once\n        if (_flags != FlagsInterface(0)) {\n            address[] memory _aggregators = new address[](currencyKeys.length);\n\n            for (uint i = 0; i < currencyKeys.length; i++) {\n                _aggregators[i] = address(aggregators[currencyKeys[i]]);\n            }\n\n            flagList = _flags.getFlags(_aggregators);\n        } else {\n            flagList = new bool[](currencyKeys.length);\n        }\n    }\n\n    function removeFromArray(bytes32 entry, bytes32[] storage array) internal returns (bool) {\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == entry) {\n                delete array[i];\n\n                // Copy the last key into the place of the one we just deleted\n                // If there's only one key, this is array[0] = array[0].\n                // If we're deleting the last one, it's also a NOOP in the same way.\n                array[i] = array[array.length - 1];\n\n                // Decrease the size of the array by one.\n                array.length--;\n\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _formatAggregatorAnswer(bytes32 currencyKey, int256 rate) internal view returns (uint) {\n        require(rate >= 0, \"Negative rate not supported\");\n        if (currencyKeyDecimals[currencyKey] > 0) {\n            uint multiplier = 10**uint(SafeMath.sub(18, currencyKeyDecimals[currencyKey]));\n            return uint(uint(rate).mul(multiplier));\n        }\n        return uint(rate);\n    }\n\n    function _getRateAndUpdatedTime(bytes32 currencyKey) internal view returns (RateAndUpdatedTime memory) {\n        // sUSD rate is 1.0\n        if (currencyKey == sUSD) {\n            return RateAndUpdatedTime({rate: uint216(SafeDecimalMath.unit()), time: 0});\n        } else {\n            AggregatorV2V3Interface aggregator = aggregators[currencyKey];\n            if (aggregator != AggregatorV2V3Interface(0)) {\n                // this view from the aggregator is the most gas efficient but it can throw when there's no data,\n                // so let's call it low-level to suppress any reverts\n                bytes memory payload = abi.encodeWithSignature(\"latestRoundData()\");\n                // solhint-disable avoid-low-level-calls\n                // slither-disable-next-line low-level-calls\n                (bool success, bytes memory returnData) = address(aggregator).staticcall(payload);\n\n                if (success) {\n                    (, int256 answer, , uint256 updatedAt, ) =\n                        abi.decode(returnData, (uint80, int256, uint256, uint256, uint80));\n                    return\n                        RateAndUpdatedTime({\n                            rate: uint216(_formatAggregatorAnswer(currencyKey, answer)),\n                            time: uint40(updatedAt)\n                        });\n                } // else return defaults, to avoid reverting in views\n            } // else return defaults, to avoid reverting in views\n        }\n    }\n\n    function _getCurrentRoundId(bytes32 currencyKey) internal view returns (uint) {\n        if (currencyKey == sUSD) {\n            return 0;\n        }\n        AggregatorV2V3Interface aggregator = aggregators[currencyKey];\n        if (aggregator != AggregatorV2V3Interface(0)) {\n            return aggregator.latestRound();\n        } // else return defaults, to avoid reverting in views\n    }\n\n    function _getRateAndTimestampAtRound(bytes32 currencyKey, uint roundId) internal view returns (uint rate, uint time) {\n        // short circuit sUSD\n        if (currencyKey == sUSD) {\n            // sUSD has no rounds, and 0 time is preferrable for \"volatility\" heuristics\n            // which are used in atomic swaps and fee reclamation\n            return (SafeDecimalMath.unit(), 0);\n        } else {\n            AggregatorV2V3Interface aggregator = aggregators[currencyKey];\n            if (aggregator != AggregatorV2V3Interface(0)) {\n                // this view from the aggregator is the most gas efficient but it can throw when there's no data,\n                // so let's call it low-level to suppress any reverts\n                bytes memory payload = abi.encodeWithSignature(\"getRoundData(uint80)\", roundId);\n                // solhint-disable avoid-low-level-calls\n                (bool success, bytes memory returnData) = address(aggregator).staticcall(payload);\n\n                if (success) {\n                    (, int256 answer, , uint256 updatedAt, ) =\n                        abi.decode(returnData, (uint80, int256, uint256, uint256, uint80));\n                    return (_formatAggregatorAnswer(currencyKey, answer), updatedAt);\n                } // else return defaults, to avoid reverting in views\n            } // else return defaults, to avoid reverting in views\n        }\n    }\n\n    function _getRate(bytes32 currencyKey) internal view returns (uint256) {\n        return _getRateAndUpdatedTime(currencyKey).rate;\n    }\n\n    function _getUpdatedTime(bytes32 currencyKey) internal view returns (uint256) {\n        return _getRateAndUpdatedTime(currencyKey).time;\n    }\n\n    function _effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        internal\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        )\n    {\n        sourceRate = _getRate(sourceCurrencyKey);\n        // If there's no change in the currency, then just return the amount they gave us\n        if (sourceCurrencyKey == destinationCurrencyKey) {\n            destinationRate = sourceRate;\n            value = sourceAmount;\n        } else {\n            // Calculate the effective value by going from source -> USD -> destination\n            destinationRate = _getRate(destinationCurrencyKey);\n            // prevent divide-by 0 error (this happens if the dest is not a valid rate)\n            if (destinationRate > 0) {\n                value = sourceAmount.multiplyDecimalRound(sourceRate).divideDecimalRound(destinationRate);\n            }\n        }\n    }\n\n    function _rateIsStale(bytes32 currencyKey, uint _rateStalePeriod) internal view returns (bool) {\n        // sUSD is a special case and is never stale (check before an SLOAD of getRateAndUpdatedTime)\n        if (currencyKey == sUSD) {\n            return false;\n        }\n        return _rateIsStaleWithTime(_rateStalePeriod, _getUpdatedTime(currencyKey));\n    }\n\n    function _rateIsStaleAtRound(\n        bytes32 currencyKey,\n        uint roundId,\n        uint _rateStalePeriod\n    ) internal view returns (bool) {\n        // sUSD is a special case and is never stale (check before an SLOAD of getRateAndUpdatedTime)\n        if (currencyKey == sUSD) {\n            return false;\n        }\n        (, uint time) = _getRateAndTimestampAtRound(currencyKey, roundId);\n        return _rateIsStaleWithTime(_rateStalePeriod, time);\n    }\n\n    function _rateIsStaleWithTime(uint _rateStalePeriod, uint _time) internal view returns (bool) {\n        return _time.add(_rateStalePeriod) < now;\n    }\n\n    function _rateIsFlagged(bytes32 currencyKey, FlagsInterface flags) internal view returns (bool) {\n        // sUSD is a special case and is never invalid\n        if (currencyKey == sUSD) {\n            return false;\n        }\n        address aggregator = address(aggregators[currencyKey]);\n        // when no aggregator or when the flags haven't been setup\n        if (aggregator == address(0) || flags == FlagsInterface(0)) {\n            return false;\n        }\n        return flags.getFlag(aggregator);\n    }\n\n    function _notImplemented() internal pure {\n        // slither-disable-next-line dead-code\n        revert(\"Cannot be run on this layer\");\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AggregatorAdded(bytes32 currencyKey, address aggregator);\n    event AggregatorRemoved(bytes32 currencyKey, address aggregator);\n}\n\n\n// https://sips.synthetix.io/sips/sip-120/\n// Uniswap V3 based DecPriceAggregator (unaudited) e.g. https://etherscan.io/address/0xf120f029ac143633d1942e48ae2dfa2036c5786c#code\n// https://github.com/sohkai/uniswap-v3-spot-twap-oracle\n//  inteface: https://github.com/sohkai/uniswap-v3-spot-twap-oracle/blob/8f9777a6160a089c99f39f2ee297119ee293bc4b/contracts/interfaces/IDexPriceAggregator.sol\n//  implementation: https://github.com/sohkai/uniswap-v3-spot-twap-oracle/blob/8f9777a6160a089c99f39f2ee297119ee293bc4b/contracts/DexPriceAggregatorUniswapV3.sol\ninterface IDexPriceAggregator {\n    function assetToAsset(\n        address tokenIn,\n        uint amountIn,\n        address tokenOut,\n        uint twapPeriod\n    ) external view returns (uint amountOut);\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/exchangerateswithdexpricing\ncontract ExchangeRatesWithDexPricing is ExchangeRates {\n    bytes32 public constant CONTRACT_NAME = \"ExchangeRatesWithDexPricing\";\n\n    bytes32 internal constant SETTING_DEX_PRICE_AGGREGATOR = \"dexPriceAggregator\";\n\n    constructor(address _owner, address _resolver) public ExchangeRates(_owner, _resolver) {}\n\n    /* ========== SETTERS ========== */\n\n    function setDexPriceAggregator(IDexPriceAggregator _dexPriceAggregator) external onlyOwner {\n        flexibleStorage().setAddressValue(\n            ExchangeRates.CONTRACT_NAME,\n            SETTING_DEX_PRICE_AGGREGATOR,\n            address(_dexPriceAggregator)\n        );\n        emit DexPriceAggregatorUpdated(address(_dexPriceAggregator));\n    }\n\n    /* ========== VIEWS ========== */\n\n    function dexPriceAggregator() public view returns (IDexPriceAggregator) {\n        return\n            IDexPriceAggregator(\n                flexibleStorage().getAddressValue(ExchangeRates.CONTRACT_NAME, SETTING_DEX_PRICE_AGGREGATOR)\n            );\n    }\n\n    function atomicTwapWindow() external view returns (uint) {\n        return getAtomicTwapWindow();\n    }\n\n    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address) {\n        return getAtomicEquivalentForDexPricing(currencyKey);\n    }\n\n    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicVolatilityConsiderationWindow(currencyKey);\n    }\n\n    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicVolatilityUpdateThreshold(currencyKey);\n    }\n\n    // SIP-120 Atomic exchanges\n    // Note that the returned systemValue, systemSourceRate, and systemDestinationRate are based on\n    // the current system rate, which may not be the atomic rate derived from value / sourceAmount\n    function effectiveAtomicValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint systemValue,\n            uint systemSourceRate,\n            uint systemDestinationRate\n        )\n    {\n        (systemValue, systemSourceRate, systemDestinationRate) = _effectiveValueAndRates(\n            sourceCurrencyKey,\n            sourceAmount,\n            destinationCurrencyKey\n        );\n\n        bool usePureChainlinkPriceForSource = getPureChainlinkPriceForAtomicSwapsEnabled(sourceCurrencyKey);\n        bool usePureChainlinkPriceForDest = getPureChainlinkPriceForAtomicSwapsEnabled(destinationCurrencyKey);\n        uint sourceRate;\n        uint destRate;\n\n        // Handle the different scenarios that may arise when trading currencies with or without the PureChainlinkPrice set.\n        // outlined here: https://sips.synthetix.io/sips/sip-198/#computation-methodology-in-atomic-pricing\n        if (usePureChainlinkPriceForSource && usePureChainlinkPriceForDest) {\n            // SRC and DEST are both set to trade at the PureChainlinkPrice\n            sourceRate = systemSourceRate;\n            destRate = systemDestinationRate;\n        } else if (!usePureChainlinkPriceForSource && usePureChainlinkPriceForDest) {\n            // SRC is NOT set to PureChainlinkPrice and DEST is set to PureChainlinkPrice\n            sourceRate = _getMinValue(systemSourceRate, _getPriceFromDexAggregator(sourceCurrencyKey, sourceAmount));\n            destRate = systemDestinationRate;\n        } else if (usePureChainlinkPriceForSource && !usePureChainlinkPriceForDest) {\n            // SRC is set to PureChainlinkPrice and DEST is NOT set to PureChainlinkPrice\n            sourceRate = systemSourceRate;\n            destRate = _getMaxValue(systemDestinationRate, _getPriceFromDexAggregator(destinationCurrencyKey, sourceAmount));\n        } else {\n            // Otherwise, neither SRC nor DEST is set to PureChainlinkPrice.\n            sourceRate = _getMinValue(systemSourceRate, _getPriceFromDexAggregator(sourceCurrencyKey, sourceAmount));\n            destRate = _getMaxValue(systemDestinationRate, _getPriceFromDexAggregator(destinationCurrencyKey, sourceAmount));\n        }\n        value = sourceAmount.mul(sourceRate).div(destRate);\n    }\n\n    function _getMinValue(uint x, uint y) internal pure returns (uint) {\n        return x < y ? x : y;\n    }\n\n    function _getMaxValue(uint x, uint y) internal pure returns (uint) {\n        return x > y ? x : y;\n    }\n\n    /// @notice Retrieve the TWAP (time-weighted average price) of an asset from its Uniswap V3-equivalent pool\n    /// @dev By default, the TWAP oracle 'hops' through the wETH pool. This can be overridden. See DexPriceAggregator for more information.\n    /// @dev The TWAP oracle doesn't take into account variable slippage due to trade amounts, as Uniswap's OracleLibary doesn't cross ticks based on their liquidity. See: https://docs.uniswap.org/protocol/concepts/V3-overview/oracle#deriving-price-from-a-tick\n    /// @param currencyKey The currency key of the synth we're retrieving the price for\n    /// @param amount The amount of the asset we're interested in\n    /// @return The price of the asset\n    function _getPriceFromDexAggregator(bytes32 currencyKey, uint amount) internal view returns (uint) {\n        require(amount != 0, \"Amount must be greater than 0\");\n\n        IERC20 inputEquivalent = IERC20(getAtomicEquivalentForDexPricing(currencyKey));\n        require(address(inputEquivalent) != address(0), \"No atomic equivalent for input\");\n\n        IERC20 susdEquivalent = IERC20(getAtomicEquivalentForDexPricing(\"sUSD\"));\n        require(address(susdEquivalent) != address(0), \"No atomic equivalent for sUSD\");\n\n        uint result =\n            _dexPriceDestinationValue(inputEquivalent, susdEquivalent, amount).mul(SafeDecimalMath.unit()).div(amount);\n        require(result != 0, \"Result must be greater than 0\");\n\n        return result;\n    }\n\n    function _dexPriceDestinationValue(\n        IERC20 sourceEquivalent,\n        IERC20 destEquivalent,\n        uint sourceAmount\n    ) internal view returns (uint) {\n        // Normalize decimals in case equivalent asset uses different decimals from internal unit\n        uint sourceAmountInEquivalent =\n            (sourceAmount.mul(10**uint(sourceEquivalent.decimals()))).div(SafeDecimalMath.unit());\n\n        uint twapWindow = getAtomicTwapWindow();\n        require(twapWindow != 0, \"Uninitialized atomic twap window\");\n\n        uint twapValueInEquivalent =\n            dexPriceAggregator().assetToAsset(\n                address(sourceEquivalent),\n                sourceAmountInEquivalent,\n                address(destEquivalent),\n                twapWindow\n            );\n        require(twapValueInEquivalent > 0, \"dex price returned 0\");\n\n        // Similar to source amount, normalize decimals back to internal unit for output amount\n        return (twapValueInEquivalent.mul(SafeDecimalMath.unit())).div(10**uint(destEquivalent.decimals()));\n    }\n\n    function synthTooVolatileForAtomicExchange(bytes32 currencyKey) external view returns (bool) {\n        // sUSD is a special case and is never volatile\n        if (currencyKey == \"sUSD\") return false;\n\n        uint considerationWindow = getAtomicVolatilityConsiderationWindow(currencyKey);\n        uint updateThreshold = getAtomicVolatilityUpdateThreshold(currencyKey);\n\n        if (considerationWindow == 0 || updateThreshold == 0) {\n            // If either volatility setting is not set, never judge an asset to be volatile\n            return false;\n        }\n\n        // Go back through the historical oracle update rounds to see if there have been more\n        // updates in the consideration window than the allowed threshold.\n        // If there have, consider the asset volatile--by assumption that many close-by oracle\n        // updates is a good proxy for price volatility.\n        uint considerationWindowStart = block.timestamp.sub(considerationWindow);\n        uint roundId = _getCurrentRoundId(currencyKey);\n        for (updateThreshold; updateThreshold > 0; updateThreshold--) {\n            (uint rate, uint time) = _getRateAndTimestampAtRound(currencyKey, roundId);\n            if (time != 0 && time < considerationWindowStart) {\n                // Round was outside consideration window so we can stop querying further rounds\n                return false;\n            } else if (rate == 0 || time == 0) {\n                // Either entire round or a rate inside consideration window was not available\n                // Consider the asset volatile\n                break;\n            }\n\n            if (roundId == 0) {\n                // Not enough historical data to continue further\n                // Consider the asset volatile\n                break;\n            }\n            roundId--;\n        }\n\n        return true;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event DexPriceAggregatorUpdated(address newDexPriceAggregator);\n}\n\n\n// SPDX-License-Identifier: MIT\n\n\n/**\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetixdebtshare\ninterface ISynthetixDebtShare {\n    // Views\n\n    function currentPeriodId() external view returns (uint128);\n\n    function allowance(address account, address spender) external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function balanceOfOnPeriod(address account, uint periodId) external view returns (uint);\n\n    function totalSupply() external view returns (uint);\n\n    function sharePercent(address account) external view returns (uint);\n\n    function sharePercentOnPeriod(address account, uint periodId) external view returns (uint);\n\n    // Mutative functions\n\n    function takeSnapshot(uint128 id) external;\n\n    function mintShare(address account, uint256 amount) external;\n\n    function burnShare(address account, uint256 amount) external;\n\n    function approve(address, uint256) external pure returns (bool);\n\n    function transfer(address to, uint256 amount) external pure returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function addAuthorizedBroker(address target) external;\n\n    function removeAuthorizedBroker(address target) external;\n\n    function addAuthorizedToSnapshot(address target) external;\n\n    function removeAuthorizedToSnapshot(address target) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchanger\ninterface IExchanger {\n    struct ExchangeEntrySettlement {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint reclaim;\n        uint rebate;\n        uint srcRoundIdAtPeriodEnd;\n        uint destRoundIdAtPeriodEnd;\n        uint timestamp;\n    }\n\n    struct ExchangeEntry {\n        uint sourceRate;\n        uint destinationRate;\n        uint destinationAmount;\n        uint exchangeFeeRate;\n        uint exchangeDynamicFeeRate;\n        uint roundIdForSrc;\n        uint roundIdForDest;\n    }\n\n    // Views\n    function calculateAmountAfterSettlement(\n        address from,\n        bytes32 currencyKey,\n        uint amount,\n        uint refunded\n    ) external view returns (uint amountAfterSettlement);\n\n    function isSynthRateInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function maxSecsLeftInWaitingPeriod(address account, bytes32 currencyKey) external view returns (uint);\n\n    function settlementOwing(address account, bytes32 currencyKey)\n        external\n        view\n        returns (\n            uint reclaimAmount,\n            uint rebateAmount,\n            uint numEntries\n        );\n\n    function hasWaitingPeriodOrSettlementOwing(address account, bytes32 currencyKey) external view returns (bool);\n\n    function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view returns (uint);\n\n    function dynamicFeeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\n        external\n        view\n        returns (uint feeRate, bool tooVolatile);\n\n    function getAmountsForExchange(\n        uint sourceAmount,\n        bytes32 sourceCurrencyKey,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint amountReceived,\n            uint fee,\n            uint exchangeFeeRate\n        );\n\n    function priceDeviationThresholdFactor() external view returns (uint);\n\n    function waitingPeriodSecs() external view returns (uint);\n\n    function lastExchangeRate(bytes32 currencyKey) external view returns (uint);\n\n    // Mutative functions\n    function exchange(\n        address exchangeForAddress,\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bool virtualSynth,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\n\n    function exchangeAtomically(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bytes32 trackingCode,\n        uint minAmount\n    ) external returns (uint amountReceived);\n\n    function settle(address from, bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntries\n        );\n\n    function suspendSynthWithInvalidRate(bytes32 currencyKey) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/idelegateapprovals\ninterface IDelegateApprovals {\n    // Views\n    function canBurnFor(address authoriser, address delegate) external view returns (bool);\n\n    function canIssueFor(address authoriser, address delegate) external view returns (bool);\n\n    function canClaimFor(address authoriser, address delegate) external view returns (bool);\n\n    function canExchangeFor(address authoriser, address delegate) external view returns (bool);\n\n    // Mutative\n    function approveAllDelegatePowers(address delegate) external;\n\n    function removeAllDelegatePowers(address delegate) external;\n\n    function approveBurnOnBehalf(address delegate) external;\n\n    function removeBurnOnBehalf(address delegate) external;\n\n    function approveIssueOnBehalf(address delegate) external;\n\n    function removeIssueOnBehalf(address delegate) external;\n\n    function approveClaimOnBehalf(address delegate) external;\n\n    function removeClaimOnBehalf(address delegate) external;\n\n    function approveExchangeOnBehalf(address delegate) external;\n\n    function removeExchangeOnBehalf(address delegate) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ihasbalance\ninterface IHasBalance {\n    // Views\n    function balanceOf(address account) external view returns (uint);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iliquidations\ninterface ILiquidations {\n    // Views\n    function isOpenForLiquidation(address account) external view returns (bool);\n\n    function getLiquidationDeadlineForAccount(address account) external view returns (uint);\n\n    function isLiquidationDeadlinePassed(address account) external view returns (bool);\n\n    function liquidationDelay() external view returns (uint);\n\n    function liquidationRatio() external view returns (uint);\n\n    function liquidationPenalty() external view returns (uint);\n\n    function calculateAmountToFixCollateral(uint debtBalance, uint collateral) external view returns (uint);\n\n    // Mutative Functions\n    function flagAccountForLiquidation(address account) external;\n\n    // Restricted: used internally to Synthetix\n    function removeAccountInLiquidation(address account) external;\n\n    function checkAndRemoveAccountInLiquidation(address account) external;\n}\n\n\npragma experimental ABIEncoderV2;\n\nlibrary VestingEntries {\n    struct VestingEntry {\n        uint64 endTime;\n        uint256 escrowAmount;\n    }\n    struct VestingEntryWithID {\n        uint64 endTime;\n        uint256 escrowAmount;\n        uint256 entryID;\n    }\n}\n\ninterface IRewardEscrowV2 {\n    // Views\n    function balanceOf(address account) external view returns (uint);\n\n    function numVestingEntries(address account) external view returns (uint);\n\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\n\n    function totalVestedAccountBalance(address account) external view returns (uint);\n\n    function getVestingQuantity(address account, uint256[] calldata entryIDs) external view returns (uint);\n\n    function getVestingSchedules(\n        address account,\n        uint256 index,\n        uint256 pageSize\n    ) external view returns (VestingEntries.VestingEntryWithID[] memory);\n\n    function getAccountVestingEntryIDs(\n        address account,\n        uint256 index,\n        uint256 pageSize\n    ) external view returns (uint256[] memory);\n\n    function getVestingEntryClaimable(address account, uint256 entryID) external view returns (uint);\n\n    function getVestingEntry(address account, uint256 entryID) external view returns (uint64, uint256);\n\n    // Mutative functions\n    function vest(uint256[] calldata entryIDs) external;\n\n    function createEscrowEntry(\n        address beneficiary,\n        uint256 deposit,\n        uint256 duration\n    ) external;\n\n    function appendVestingEntry(\n        address account,\n        uint256 quantity,\n        uint256 duration\n    ) external;\n\n    function migrateVestingSchedule(address _addressToMigrate) external;\n\n    function migrateAccountEscrowBalances(\n        address[] calldata accounts,\n        uint256[] calldata escrowBalances,\n        uint256[] calldata vestedBalances\n    ) external;\n\n    // Account Merging\n    function startMergingWindow() external;\n\n    function mergeAccount(address accountToMerge, uint256[] calldata entryIDs) external;\n\n    function nominateAccountToMerge(address account) external;\n\n    function accountMergingIsOpen() external view returns (bool);\n\n    // L2 Migration\n    function importVestingEntries(\n        address account,\n        uint256 escrowedAmount,\n        VestingEntries.VestingEntry[] calldata vestingEntries\n    ) external;\n\n    // Return amount of SNX transfered to SynthetixBridgeToOptimism deposit contract\n    function burnForMigration(address account, uint256[] calldata entryIDs)\n        external\n        returns (uint256 escrowedAccountBalance, VestingEntries.VestingEntry[] memory vestingEntries);\n}\n\n\ninterface ISynthRedeemer {\n    // Rate of redemption - 0 for none\n    function redemptions(address synthProxy) external view returns (uint redeemRate);\n\n    // sUSD balance of deprecated token holder\n    function balanceOf(IERC20 synthProxy, address account) external view returns (uint balanceOfInsUSD);\n\n    // Full sUSD supply of token\n    function totalSupply(IERC20 synthProxy) external view returns (uint totalSupplyInsUSD);\n\n    function redeem(IERC20 synthProxy) external;\n\n    function redeemAll(IERC20[] calldata synthProxies) external;\n\n    function redeemPartial(IERC20 synthProxy, uint amountOfSynth) external;\n\n    // Restricted to Issuer\n    function deprecate(IERC20 synthProxy, uint rateToRedeem) external;\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\ninterface IProxy {\n    function target() external view returns (address);\n}\n\ninterface IIssuerInternalDebtCache {\n    function updateCachedSynthDebtWithRate(bytes32 currencyKey, uint currencyRate) external;\n\n    function updateCachedSynthDebtsWithRates(bytes32[] calldata currencyKeys, uint[] calldata currencyRates) external;\n\n    function updateDebtCacheValidity(bool currentlyInvalid) external;\n\n    function totalNonSnxBackedDebt() external view returns (uint excludedDebt, bool isInvalid);\n\n    function cacheInfo()\n        external\n        view\n        returns (\n            uint cachedDebt,\n            uint timestamp,\n            bool isInvalid,\n            bool isStale\n        );\n\n    function updateCachedsUSDDebt(int amount) external;\n}\n\n// https://docs.synthetix.io/contracts/source/contracts/issuer\ncontract Issuer is Owned, MixinSystemSettings, IIssuer {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    bytes32 public constant CONTRACT_NAME = \"Issuer\";\n\n    // SIP-165: Circuit breaker for Debt Synthesis\n    uint public constant CIRCUIT_BREAKER_SUSPENSION_REASON = 165;\n\n    // Available Synths which can be used with the system\n    ISynth[] public availableSynths;\n    mapping(bytes32 => ISynth) public synths;\n    mapping(address => bytes32) public synthsByAddress;\n\n    uint public lastDebtRatio;\n\n    /* ========== ENCODED NAMES ========== */\n\n    bytes32 internal constant sUSD = \"sUSD\";\n    bytes32 internal constant sETH = \"sETH\";\n    bytes32 internal constant SNX = \"SNX\";\n\n    // Flexible storage names\n\n    bytes32 internal constant LAST_ISSUE_EVENT = \"lastIssueEvent\";\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_SYNTHETIX = \"Synthetix\";\n    bytes32 private constant CONTRACT_EXCHANGER = \"Exchanger\";\n    bytes32 private constant CONTRACT_EXRATES = \"ExchangeRates\";\n    bytes32 private constant CONTRACT_SYNTHETIXDEBTSHARE = \"SynthetixDebtShare\";\n    bytes32 private constant CONTRACT_FEEPOOL = \"FeePool\";\n    bytes32 private constant CONTRACT_DELEGATEAPPROVALS = \"DelegateApprovals\";\n    bytes32 private constant CONTRACT_REWARDESCROW_V2 = \"RewardEscrowV2\";\n    bytes32 private constant CONTRACT_SYNTHETIXESCROW = \"SynthetixEscrow\";\n    bytes32 private constant CONTRACT_LIQUIDATIONS = \"Liquidations\";\n    bytes32 private constant CONTRACT_DEBTCACHE = \"DebtCache\";\n    bytes32 private constant CONTRACT_SYNTHREDEEMER = \"SynthRedeemer\";\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\n    bytes32 private constant CONTRACT_SYNTHETIXBRIDGETOOPTIMISM = \"SynthetixBridgeToOptimism\";\n    bytes32 private constant CONTRACT_SYNTHETIXBRIDGETOBASE = \"SynthetixBridgeToBase\";\n\n    bytes32 private constant CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS = \"ext:AggregatorIssuedSynths\";\n    bytes32 private constant CONTRACT_EXT_AGGREGATOR_DEBT_RATIO = \"ext:AggregatorDebtRatio\";\n\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinSystemSettings(_resolver) {}\n\n    /* ========== VIEWS ========== */\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();\n        bytes32[] memory newAddresses = new bytes32[](14);\n        newAddresses[0] = CONTRACT_SYNTHETIX;\n        newAddresses[1] = CONTRACT_EXCHANGER;\n        newAddresses[2] = CONTRACT_EXRATES;\n        newAddresses[3] = CONTRACT_SYNTHETIXDEBTSHARE;\n        newAddresses[4] = CONTRACT_FEEPOOL;\n        newAddresses[5] = CONTRACT_DELEGATEAPPROVALS;\n        newAddresses[6] = CONTRACT_REWARDESCROW_V2;\n        newAddresses[7] = CONTRACT_SYNTHETIXESCROW;\n        newAddresses[8] = CONTRACT_LIQUIDATIONS;\n        newAddresses[9] = CONTRACT_DEBTCACHE;\n        newAddresses[10] = CONTRACT_SYNTHREDEEMER;\n        newAddresses[11] = CONTRACT_SYSTEMSTATUS;\n        newAddresses[12] = CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS;\n        newAddresses[13] = CONTRACT_EXT_AGGREGATOR_DEBT_RATIO;\n        return combineArrays(existingAddresses, newAddresses);\n    }\n\n    function synthetix() internal view returns (ISynthetix) {\n        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));\n    }\n\n    function exchanger() internal view returns (IExchanger) {\n        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));\n    }\n\n    function exchangeRates() internal view returns (IExchangeRates) {\n        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));\n    }\n\n    function synthetixDebtShare() internal view returns (ISynthetixDebtShare) {\n        return ISynthetixDebtShare(requireAndGetAddress(CONTRACT_SYNTHETIXDEBTSHARE));\n    }\n\n    function feePool() internal view returns (IFeePool) {\n        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));\n    }\n\n    function liquidations() internal view returns (ILiquidations) {\n        return ILiquidations(requireAndGetAddress(CONTRACT_LIQUIDATIONS));\n    }\n\n    function delegateApprovals() internal view returns (IDelegateApprovals) {\n        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));\n    }\n\n    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {\n        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));\n    }\n\n    function synthetixEscrow() internal view returns (IHasBalance) {\n        return IHasBalance(requireAndGetAddress(CONTRACT_SYNTHETIXESCROW));\n    }\n\n    function debtCache() internal view returns (IIssuerInternalDebtCache) {\n        return IIssuerInternalDebtCache(requireAndGetAddress(CONTRACT_DEBTCACHE));\n    }\n\n    function synthRedeemer() internal view returns (ISynthRedeemer) {\n        return ISynthRedeemer(requireAndGetAddress(CONTRACT_SYNTHREDEEMER));\n    }\n\n    function systemStatus() internal view returns (ISystemStatus) {\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\n    }\n\n    function allNetworksDebtInfo()\n        public\n        view\n        returns (\n            uint256 debt,\n            uint256 sharesSupply,\n            bool isStale\n        )\n    {\n        (, int256 rawIssuedSynths, , uint issuedSynthsUpdatedAt, ) =\n            AggregatorV2V3Interface(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_ISSUED_SYNTHS)).latestRoundData();\n\n        (, int256 rawRatio, , uint ratioUpdatedAt, ) =\n            AggregatorV2V3Interface(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_DEBT_RATIO)).latestRoundData();\n\n        debt = uint(rawIssuedSynths);\n        sharesSupply = rawRatio == 0 ? 0 : debt.divideDecimalRoundPrecise(uint(rawRatio));\n        isStale =\n            block.timestamp - getRateStalePeriod() > issuedSynthsUpdatedAt ||\n            block.timestamp - getRateStalePeriod() > ratioUpdatedAt;\n    }\n\n    function issuanceRatio() external view returns (uint) {\n        return getIssuanceRatio();\n    }\n\n    function _sharesForDebt(uint debtAmount) internal view returns (uint) {\n        (, int256 rawRatio, , , ) =\n            AggregatorV2V3Interface(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_DEBT_RATIO)).latestRoundData();\n\n        return rawRatio == 0 ? 0 : debtAmount.divideDecimalRoundPrecise(uint(rawRatio));\n    }\n\n    function _debtForShares(uint sharesAmount) internal view returns (uint) {\n        (, int256 rawRatio, , , ) =\n            AggregatorV2V3Interface(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_DEBT_RATIO)).latestRoundData();\n\n        return sharesAmount.multiplyDecimalRoundPrecise(uint(rawRatio));\n    }\n\n    function _availableCurrencyKeysWithOptionalSNX(bool withSNX) internal view returns (bytes32[] memory) {\n        bytes32[] memory currencyKeys = new bytes32[](availableSynths.length + (withSNX ? 1 : 0));\n\n        for (uint i = 0; i < availableSynths.length; i++) {\n            currencyKeys[i] = synthsByAddress[address(availableSynths[i])];\n        }\n\n        if (withSNX) {\n            currencyKeys[availableSynths.length] = SNX;\n        }\n\n        return currencyKeys;\n    }\n\n    // Returns the total value of the debt pool in currency specified by `currencyKey`.\n    // To return only the SNX-backed debt, set `excludeCollateral` to true.\n    function _totalIssuedSynths(bytes32 currencyKey, bool excludeCollateral)\n        internal\n        view\n        returns (uint totalIssued, bool anyRateIsInvalid)\n    {\n        (uint debt, , bool cacheIsInvalid, bool cacheIsStale) = debtCache().cacheInfo();\n        anyRateIsInvalid = cacheIsInvalid || cacheIsStale;\n\n        IExchangeRates exRates = exchangeRates();\n\n        // Add total issued synths from non snx collateral back into the total if not excluded\n        if (!excludeCollateral) {\n            (uint nonSnxDebt, bool invalid) = debtCache().totalNonSnxBackedDebt();\n            debt = debt.add(nonSnxDebt);\n            anyRateIsInvalid = anyRateIsInvalid || invalid;\n        }\n\n        if (currencyKey == sUSD) {\n            return (debt, anyRateIsInvalid);\n        }\n\n        (uint currencyRate, bool currencyRateInvalid) = exRates.rateAndInvalid(currencyKey);\n        return (debt.divideDecimalRound(currencyRate), anyRateIsInvalid || currencyRateInvalid);\n    }\n\n    function _debtBalanceOfAndTotalDebt(uint debtShareBalance, bytes32 currencyKey)\n        internal\n        view\n        returns (\n            uint debtBalance,\n            uint totalSystemValue,\n            bool anyRateIsInvalid\n        )\n    {\n        // What's the total value of the system excluding ETH backed synths in their requested currency?\n        (uint snxBackedAmount, , bool debtInfoStale) = allNetworksDebtInfo();\n\n        if (debtShareBalance == 0) {\n            return (0, snxBackedAmount, debtInfoStale);\n        }\n\n        // existing functionality requires for us to convert into the exchange rate specified by `currencyKey`\n        (uint currencyRate, bool currencyRateInvalid) = exchangeRates().rateAndInvalid(currencyKey);\n\n        debtBalance = _debtForShares(debtShareBalance).divideDecimalRound(currencyRate);\n        totalSystemValue = snxBackedAmount;\n\n        anyRateIsInvalid = currencyRateInvalid || debtInfoStale;\n    }\n\n    function _canBurnSynths(address account) internal view returns (bool) {\n        return now >= _lastIssueEvent(account).add(getMinimumStakeTime());\n    }\n\n    function _lastIssueEvent(address account) internal view returns (uint) {\n        //  Get the timestamp of the last issue this account made\n        return flexibleStorage().getUIntValue(CONTRACT_NAME, keccak256(abi.encodePacked(LAST_ISSUE_EVENT, account)));\n    }\n\n    function _remainingIssuableSynths(address _issuer)\n        internal\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt,\n            bool anyRateIsInvalid\n        )\n    {\n        (alreadyIssued, totalSystemDebt, anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(\n            synthetixDebtShare().balanceOf(_issuer),\n            sUSD\n        );\n        (uint issuable, bool isInvalid) = _maxIssuableSynths(_issuer);\n        maxIssuable = issuable;\n        anyRateIsInvalid = anyRateIsInvalid || isInvalid;\n\n        if (alreadyIssued >= maxIssuable) {\n            maxIssuable = 0;\n        } else {\n            maxIssuable = maxIssuable.sub(alreadyIssued);\n        }\n    }\n\n    function _snxToUSD(uint amount, uint snxRate) internal pure returns (uint) {\n        return amount.multiplyDecimalRound(snxRate);\n    }\n\n    function _usdToSnx(uint amount, uint snxRate) internal pure returns (uint) {\n        return amount.divideDecimalRound(snxRate);\n    }\n\n    function _maxIssuableSynths(address _issuer) internal view returns (uint, bool) {\n        // What is the value of their SNX balance in sUSD\n        (uint snxRate, bool isInvalid) = exchangeRates().rateAndInvalid(SNX);\n        uint destinationValue = _snxToUSD(_collateral(_issuer), snxRate);\n\n        // They're allowed to issue up to issuanceRatio of that value\n        return (destinationValue.multiplyDecimal(getIssuanceRatio()), isInvalid);\n    }\n\n    function _collateralisationRatio(address _issuer) internal view returns (uint, bool) {\n        uint totalOwnedSynthetix = _collateral(_issuer);\n\n        (uint debtBalance, , bool anyRateIsInvalid) =\n            _debtBalanceOfAndTotalDebt(synthetixDebtShare().balanceOf(_issuer), SNX);\n\n        // it's more gas intensive to put this check here if they have 0 SNX, but it complies with the interface\n        if (totalOwnedSynthetix == 0) return (0, anyRateIsInvalid);\n\n        return (debtBalance.divideDecimalRound(totalOwnedSynthetix), anyRateIsInvalid);\n    }\n\n    function _collateral(address account) internal view returns (uint) {\n        uint balance = IERC20(address(synthetix())).balanceOf(account);\n\n        if (address(synthetixEscrow()) != address(0)) {\n            balance = balance.add(synthetixEscrow().balanceOf(account));\n        }\n\n        if (address(rewardEscrowV2()) != address(0)) {\n            balance = balance.add(rewardEscrowV2().balanceOf(account));\n        }\n\n        return balance;\n    }\n\n    function minimumStakeTime() external view returns (uint) {\n        return getMinimumStakeTime();\n    }\n\n    function canBurnSynths(address account) external view returns (bool) {\n        return _canBurnSynths(account);\n    }\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory) {\n        return _availableCurrencyKeysWithOptionalSNX(false);\n    }\n\n    function availableSynthCount() external view returns (uint) {\n        return availableSynths.length;\n    }\n\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid) {\n        (, anyRateInvalid) = exchangeRates().ratesAndInvalidForCurrencies(_availableCurrencyKeysWithOptionalSNX(true));\n    }\n\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint totalIssued) {\n        (totalIssued, ) = _totalIssuedSynths(currencyKey, excludeOtherCollateral);\n    }\n\n    function lastIssueEvent(address account) external view returns (uint) {\n        return _lastIssueEvent(account);\n    }\n\n    function collateralisationRatio(address _issuer) external view returns (uint cratio) {\n        (cratio, ) = _collateralisationRatio(_issuer);\n    }\n\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\n        external\n        view\n        returns (uint cratio, bool anyRateIsInvalid)\n    {\n        return _collateralisationRatio(_issuer);\n    }\n\n    function collateral(address account) external view returns (uint) {\n        return _collateral(account);\n    }\n\n    function debtBalanceOf(address _issuer, bytes32 currencyKey) external view returns (uint debtBalance) {\n        ISynthetixDebtShare sds = synthetixDebtShare();\n\n        // What was their initial debt ownership?\n        uint debtShareBalance = sds.balanceOf(_issuer);\n\n        // If it's zero, they haven't issued, and they have no debt.\n        if (debtShareBalance == 0) return 0;\n\n        (debtBalance, , ) = _debtBalanceOfAndTotalDebt(debtShareBalance, currencyKey);\n    }\n\n    function remainingIssuableSynths(address _issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        )\n    {\n        (maxIssuable, alreadyIssued, totalSystemDebt, ) = _remainingIssuableSynths(_issuer);\n    }\n\n    function maxIssuableSynths(address _issuer) external view returns (uint) {\n        (uint maxIssuable, ) = _maxIssuableSynths(_issuer);\n        return maxIssuable;\n    }\n\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\n        external\n        view\n        returns (uint transferable, bool anyRateIsInvalid)\n    {\n        // How many SNX do they have, excluding escrow?\n        // Note: We're excluding escrow here because we're interested in their transferable amount\n        // and escrowed SNX are not transferable.\n\n        // How many of those will be locked by the amount they've issued?\n        // Assuming issuance ratio is 20%, then issuing 20 SNX of value would require\n        // 100 SNX to be locked in their wallet to maintain their collateralisation ratio\n        // The locked synthetix value can exceed their balance.\n        uint debtBalance;\n        (debtBalance, , anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(synthetixDebtShare().balanceOf(account), SNX);\n        uint lockedSynthetixValue = debtBalance.divideDecimalRound(getIssuanceRatio());\n\n        // If we exceed the balance, no SNX are transferable, otherwise the difference is.\n        if (lockedSynthetixValue >= balance) {\n            transferable = 0;\n        } else {\n            transferable = balance.sub(lockedSynthetixValue);\n        }\n    }\n\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory) {\n        uint numKeys = currencyKeys.length;\n        ISynth[] memory addresses = new ISynth[](numKeys);\n\n        for (uint i = 0; i < numKeys; i++) {\n            addresses[i] = synths[currencyKeys[i]];\n        }\n\n        return addresses;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function _addSynth(ISynth synth) internal {\n        bytes32 currencyKey = synth.currencyKey();\n        require(synths[currencyKey] == ISynth(0), \"Synth exists\");\n        require(synthsByAddress[address(synth)] == bytes32(0), \"Synth address already exists\");\n\n        availableSynths.push(synth);\n        synths[currencyKey] = synth;\n        synthsByAddress[address(synth)] = currencyKey;\n\n        emit SynthAdded(currencyKey, address(synth));\n    }\n\n    function addSynth(ISynth synth) external onlyOwner {\n        _addSynth(synth);\n        // Invalidate the cache to force a snapshot to be recomputed. If a synth were to be added\n        // back to the system and it still somehow had cached debt, this would force the value to be\n        // updated.\n        debtCache().updateDebtCacheValidity(true);\n    }\n\n    function addSynths(ISynth[] calldata synthsToAdd) external onlyOwner {\n        uint numSynths = synthsToAdd.length;\n        for (uint i = 0; i < numSynths; i++) {\n            _addSynth(synthsToAdd[i]);\n        }\n\n        // Invalidate the cache to force a snapshot to be recomputed.\n        debtCache().updateDebtCacheValidity(true);\n    }\n\n    function _removeSynth(bytes32 currencyKey) internal {\n        address synthToRemove = address(synths[currencyKey]);\n        require(synthToRemove != address(0), \"Synth does not exist\");\n        require(currencyKey != sUSD, \"Cannot remove synth\");\n\n        uint synthSupply = IERC20(synthToRemove).totalSupply();\n\n        if (synthSupply > 0) {\n            (uint amountOfsUSD, uint rateToRedeem, ) =\n                exchangeRates().effectiveValueAndRates(currencyKey, synthSupply, \"sUSD\");\n            require(rateToRedeem > 0, \"Cannot remove synth to redeem without rate\");\n            ISynthRedeemer _synthRedeemer = synthRedeemer();\n            synths[sUSD].issue(address(_synthRedeemer), amountOfsUSD);\n            // ensure the debt cache is aware of the new sUSD issued\n            debtCache().updateCachedsUSDDebt(SafeCast.toInt256(amountOfsUSD));\n            _synthRedeemer.deprecate(IERC20(address(Proxyable(address(synthToRemove)).proxy())), rateToRedeem);\n        }\n\n        // Remove the synth from the availableSynths array.\n        for (uint i = 0; i < availableSynths.length; i++) {\n            if (address(availableSynths[i]) == synthToRemove) {\n                delete availableSynths[i];\n\n                // Copy the last synth into the place of the one we just deleted\n                // If there's only one synth, this is synths[0] = synths[0].\n                // If we're deleting the last one, it's also a NOOP in the same way.\n                availableSynths[i] = availableSynths[availableSynths.length - 1];\n\n                // Decrease the size of the array by one.\n                availableSynths.length--;\n\n                break;\n            }\n        }\n\n        // And remove it from the synths mapping\n        delete synthsByAddress[synthToRemove];\n        delete synths[currencyKey];\n\n        emit SynthRemoved(currencyKey, synthToRemove);\n    }\n\n    function removeSynth(bytes32 currencyKey) external onlyOwner {\n        // Remove its contribution from the debt pool snapshot, and\n        // invalidate the cache to force a new snapshot.\n        IIssuerInternalDebtCache cache = debtCache();\n        cache.updateCachedSynthDebtWithRate(currencyKey, 0);\n        cache.updateDebtCacheValidity(true);\n\n        _removeSynth(currencyKey);\n    }\n\n    function removeSynths(bytes32[] calldata currencyKeys) external onlyOwner {\n        uint numKeys = currencyKeys.length;\n\n        // Remove their contributions from the debt pool snapshot, and\n        // invalidate the cache to force a new snapshot.\n        IIssuerInternalDebtCache cache = debtCache();\n        uint[] memory zeroRates = new uint[](numKeys);\n        cache.updateCachedSynthDebtsWithRates(currencyKeys, zeroRates);\n        cache.updateDebtCacheValidity(true);\n\n        for (uint i = 0; i < numKeys; i++) {\n            _removeSynth(currencyKeys[i]);\n        }\n    }\n\n    function issueSynthsWithoutDebt(\n        bytes32 currencyKey,\n        address to,\n        uint amount\n    ) external onlyTrustedMinters returns (bool rateInvalid) {\n        require(address(synths[currencyKey]) != address(0), \"Issuer: synth doesn't exist\");\n        require(amount > 0, \"Issuer: cannot issue 0 synths\");\n\n        // record issue timestamp\n        _setLastIssueEvent(to);\n\n        // Create their synths\n        synths[currencyKey].issue(to, amount);\n\n        // Account for the issued debt in the cache\n        (uint rate, bool rateInvalid) = exchangeRates().rateAndInvalid(currencyKey);\n        debtCache().updateCachedsUSDDebt(SafeCast.toInt256(amount.multiplyDecimal(rate)));\n\n        // returned so that the caller can decide what to do if the rate is invalid\n        return rateInvalid;\n    }\n\n    function burnSynthsWithoutDebt(\n        bytes32 currencyKey,\n        address from,\n        uint amount\n    ) external onlyTrustedMinters returns (bool rateInvalid) {\n        require(address(synths[currencyKey]) != address(0), \"Issuer: synth doesn't exist\");\n        require(amount > 0, \"Issuer: cannot issue 0 synths\");\n\n        exchanger().settle(from, currencyKey);\n\n        // Burn some synths\n        synths[currencyKey].burn(from, amount);\n\n        // Account for the burnt debt in the cache. If rate is invalid, the user won't be able to exchange\n        (uint rate, bool rateInvalid) = exchangeRates().rateAndInvalid(currencyKey);\n        debtCache().updateCachedsUSDDebt(-SafeCast.toInt256(amount.multiplyDecimal(rate)));\n\n        // returned so that the caller can decide what to do if the rate is invalid\n        return rateInvalid;\n    }\n\n    function issueSynths(address from, uint amount) external onlySynthetix {\n        require(amount > 0, \"Issuer: cannot issue 0 synths\");\n\n        _issueSynths(from, amount, false);\n    }\n\n    function issueMaxSynths(address from) external onlySynthetix {\n        _issueSynths(from, 0, true);\n    }\n\n    function issueSynthsOnBehalf(\n        address issueForAddress,\n        address from,\n        uint amount\n    ) external onlySynthetix {\n        _requireCanIssueOnBehalf(issueForAddress, from);\n        _issueSynths(issueForAddress, amount, false);\n    }\n\n    function issueMaxSynthsOnBehalf(address issueForAddress, address from) external onlySynthetix {\n        _requireCanIssueOnBehalf(issueForAddress, from);\n        _issueSynths(issueForAddress, 0, true);\n    }\n\n    function burnSynths(address from, uint amount) external onlySynthetix {\n        _voluntaryBurnSynths(from, amount, false);\n    }\n\n    function burnSynthsOnBehalf(\n        address burnForAddress,\n        address from,\n        uint amount\n    ) external onlySynthetix {\n        _requireCanBurnOnBehalf(burnForAddress, from);\n        _voluntaryBurnSynths(burnForAddress, amount, false);\n    }\n\n    function burnSynthsToTarget(address from) external onlySynthetix {\n        _voluntaryBurnSynths(from, 0, true);\n    }\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external onlySynthetix {\n        _requireCanBurnOnBehalf(burnForAddress, from);\n        _voluntaryBurnSynths(burnForAddress, 0, true);\n    }\n\n    function burnForRedemption(\n        address deprecatedSynthProxy,\n        address account,\n        uint balance\n    ) external onlySynthRedeemer {\n        ISynth(IProxy(deprecatedSynthProxy).target()).burn(account, balance);\n    }\n\n    function liquidateDelinquentAccount(\n        address account,\n        uint susdAmount,\n        address liquidator\n    ) external onlySynthetix returns (uint totalRedeemed, uint amountToLiquidate) {\n        // Ensure waitingPeriod and sUSD balance is settled as burning impacts the size of debt pool\n        require(!exchanger().hasWaitingPeriodOrSettlementOwing(liquidator, sUSD), \"sUSD needs to be settled\");\n\n        // Check account is liquidation open\n        require(liquidations().isOpenForLiquidation(account), \"Account not open for liquidation\");\n\n        // require liquidator has enough sUSD\n        require(IERC20(address(synths[sUSD])).balanceOf(liquidator) >= susdAmount, \"Not enough sUSD\");\n\n        uint liquidationPenalty = liquidations().liquidationPenalty();\n\n        // What is their debt in sUSD?\n        (uint debtBalance, , bool anyRateIsInvalid) =\n            _debtBalanceOfAndTotalDebt(synthetixDebtShare().balanceOf(account), sUSD);\n        (uint snxRate, bool snxRateInvalid) = exchangeRates().rateAndInvalid(SNX);\n        _requireRatesNotInvalid(anyRateIsInvalid || snxRateInvalid);\n\n        uint collateralForAccount = _collateral(account);\n        uint amountToFixRatio =\n            liquidations().calculateAmountToFixCollateral(debtBalance, _snxToUSD(collateralForAccount, snxRate));\n\n        // Cap amount to liquidate to repair collateral ratio based on issuance ratio\n        amountToLiquidate = amountToFixRatio < susdAmount ? amountToFixRatio : susdAmount;\n\n        // what's the equivalent amount of snx for the amountToLiquidate?\n        uint snxRedeemed = _usdToSnx(amountToLiquidate, snxRate);\n\n        // Add penalty\n        totalRedeemed = snxRedeemed.multiplyDecimal(SafeDecimalMath.unit().add(liquidationPenalty));\n\n        // if total SNX to redeem is greater than account's collateral\n        // account is under collateralised, liquidate all collateral and reduce sUSD to burn\n        if (totalRedeemed > collateralForAccount) {\n            // set totalRedeemed to all transferable collateral\n            totalRedeemed = collateralForAccount;\n\n            // whats the equivalent sUSD to burn for all collateral less penalty\n            amountToLiquidate = _snxToUSD(\n                collateralForAccount.divideDecimal(SafeDecimalMath.unit().add(liquidationPenalty)),\n                snxRate\n            );\n        }\n\n        // burn sUSD from messageSender (liquidator) and reduce account's debt\n        _burnSynths(account, liquidator, amountToLiquidate, debtBalance);\n\n        // Remove liquidation flag if amount liquidated fixes ratio\n        if (amountToLiquidate == amountToFixRatio) {\n            // Remove liquidation\n            liquidations().removeAccountInLiquidation(account);\n        }\n    }\n\n    function setCurrentPeriodId(uint128 periodId) external {\n        require(msg.sender == address(feePool()), \"Must be fee pool\");\n\n        ISynthetixDebtShare sds = synthetixDebtShare();\n\n        if (sds.currentPeriodId() < periodId) {\n            sds.takeSnapshot(periodId);\n        }\n    }\n\n    function setLastDebtRatio(uint256 ratio) external onlyOwner {\n        lastDebtRatio = ratio;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _requireRatesNotInvalid(bool anyRateIsInvalid) internal pure {\n        require(!anyRateIsInvalid, \"A synth or SNX rate is invalid\");\n    }\n\n    function _requireCanIssueOnBehalf(address issueForAddress, address from) internal view {\n        require(delegateApprovals().canIssueFor(issueForAddress, from), \"Not approved to act on behalf\");\n    }\n\n    function _requireCanBurnOnBehalf(address burnForAddress, address from) internal view {\n        require(delegateApprovals().canBurnFor(burnForAddress, from), \"Not approved to act on behalf\");\n    }\n\n    function _issueSynths(\n        address from,\n        uint amount,\n        bool issueMax\n    ) internal {\n        // check breaker\n        if (!_verifyCircuitBreaker()) {\n            return;\n        }\n\n        (uint maxIssuable, , , bool anyRateIsInvalid) = _remainingIssuableSynths(from);\n        _requireRatesNotInvalid(anyRateIsInvalid);\n\n        if (!issueMax) {\n            require(amount <= maxIssuable, \"Amount too large\");\n        } else {\n            amount = maxIssuable;\n        }\n\n        // Keep track of the debt they're about to create\n        _addToDebtRegister(from, amount);\n\n        // record issue timestamp\n        _setLastIssueEvent(from);\n\n        // Create their synths\n        synths[sUSD].issue(from, amount);\n\n        // Account for the issued debt in the cache\n        debtCache().updateCachedsUSDDebt(SafeCast.toInt256(amount));\n    }\n\n    function _burnSynths(\n        address debtAccount,\n        address burnAccount,\n        uint amount,\n        uint existingDebt\n    ) internal returns (uint amountBurnt) {\n        // check breaker\n        if (!_verifyCircuitBreaker()) {\n            return 0;\n        }\n\n        // liquidation requires sUSD to be already settled / not in waiting period\n\n        // If they're trying to burn more debt than they actually owe, rather than fail the transaction, let's just\n        // clear their debt and leave them be.\n        amountBurnt = existingDebt < amount ? existingDebt : amount;\n\n        // Remove liquidated debt from the ledger\n        _removeFromDebtRegister(debtAccount, amountBurnt, existingDebt);\n\n        // synth.burn does a safe subtraction on balance (so it will revert if there are not enough synths).\n        synths[sUSD].burn(burnAccount, amountBurnt);\n\n        // Account for the burnt debt in the cache.\n        debtCache().updateCachedsUSDDebt(-SafeCast.toInt256(amountBurnt));\n    }\n\n    // If burning to target, `amount` is ignored, and the correct quantity of sUSD is burnt to reach the target\n    // c-ratio, allowing fees to be claimed. In this case, pending settlements will be skipped as the user\n    // will still have debt remaining after reaching their target.\n    function _voluntaryBurnSynths(\n        address from,\n        uint amount,\n        bool burnToTarget\n    ) internal {\n        // check breaker\n        if (!_verifyCircuitBreaker()) {\n            return;\n        }\n\n        if (!burnToTarget) {\n            // If not burning to target, then burning requires that the minimum stake time has elapsed.\n            require(_canBurnSynths(from), \"Minimum stake time not reached\");\n            // First settle anything pending into sUSD as burning or issuing impacts the size of the debt pool\n            (, uint refunded, uint numEntriesSettled) = exchanger().settle(from, sUSD);\n            if (numEntriesSettled > 0) {\n                amount = exchanger().calculateAmountAfterSettlement(from, sUSD, amount, refunded);\n            }\n        }\n\n        (uint existingDebt, , bool anyRateIsInvalid) =\n            _debtBalanceOfAndTotalDebt(synthetixDebtShare().balanceOf(from), sUSD);\n        (uint maxIssuableSynthsForAccount, bool snxRateInvalid) = _maxIssuableSynths(from);\n        _requireRatesNotInvalid(anyRateIsInvalid || snxRateInvalid);\n        require(existingDebt > 0, \"No debt to forgive\");\n\n        if (burnToTarget) {\n            amount = existingDebt.sub(maxIssuableSynthsForAccount);\n        }\n\n        uint amountBurnt = _burnSynths(from, from, amount, existingDebt);\n\n        // Check and remove liquidation if existingDebt after burning is <= maxIssuableSynths\n        // Issuance ratio is fixed so should remove any liquidations\n        if (existingDebt.sub(amountBurnt) <= maxIssuableSynthsForAccount) {\n            liquidations().removeAccountInLiquidation(from);\n        }\n    }\n\n    function _setLastIssueEvent(address account) internal {\n        // Set the timestamp of the last issueSynths\n        flexibleStorage().setUIntValue(\n            CONTRACT_NAME,\n            keccak256(abi.encodePacked(LAST_ISSUE_EVENT, account)),\n            block.timestamp\n        );\n    }\n\n    function _addToDebtRegister(address from, uint amount) internal {\n        ISynthetixDebtShare sds = synthetixDebtShare();\n\n        // it is possible (eg in tests, system initialized with extra debt) to have issued debt without any shares issued\n        // in which case, the first account to mint gets the debt. yw.\n        uint debtShares = _sharesForDebt(amount);\n        if (debtShares == 0) {\n            sds.mintShare(from, amount);\n        } else {\n            sds.mintShare(from, debtShares);\n        }\n    }\n\n    function _removeFromDebtRegister(\n        address from,\n        uint debtToRemove,\n        uint existingDebt\n    ) internal {\n        ISynthetixDebtShare sds = synthetixDebtShare();\n\n        uint currentDebtShare = sds.balanceOf(from);\n\n        if (debtToRemove == existingDebt) {\n            sds.burnShare(from, currentDebtShare);\n        } else {\n            uint sharesToRemove = _sharesForDebt(debtToRemove);\n            sds.burnShare(from, sharesToRemove < currentDebtShare ? sharesToRemove : currentDebtShare);\n        }\n    }\n\n    function _verifyCircuitBreaker() internal returns (bool) {\n        (, int256 rawRatio, , , ) =\n            AggregatorV2V3Interface(requireAndGetAddress(CONTRACT_EXT_AGGREGATOR_DEBT_RATIO)).latestRoundData();\n\n        uint deviation = _calculateDeviation(lastDebtRatio, uint(rawRatio));\n\n        if (deviation >= getPriceDeviationThresholdFactor()) {\n            systemStatus().suspendIssuance(CIRCUIT_BREAKER_SUSPENSION_REASON);\n            return false;\n        }\n        lastDebtRatio = uint(rawRatio);\n\n        return true;\n    }\n\n    function _calculateDeviation(uint last, uint fresh) internal pure returns (uint deviation) {\n        if (last == 0) {\n            deviation = 1;\n        } else if (fresh == 0) {\n            deviation = uint(-1);\n        } else if (last > fresh) {\n            deviation = last.divideDecimal(fresh);\n        } else {\n            deviation = fresh.divideDecimal(last);\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n    modifier onlySynthetix() {\n        require(msg.sender == address(synthetix()), \"Issuer: Only the synthetix contract can perform this action\");\n        _;\n    }\n\n    modifier onlyTrustedMinters() {\n        require(\n            msg.sender == resolver.getAddress(CONTRACT_SYNTHETIXBRIDGETOOPTIMISM) ||\n                msg.sender == resolver.getAddress(CONTRACT_SYNTHETIXBRIDGETOBASE),\n            \"Issuer: Only trusted minters can perform this action\"\n        );\n        _;\n    }\n\n    function _onlySynthRedeemer() internal view {\n        require(msg.sender == address(synthRedeemer()), \"Issuer: Only the SynthRedeemer contract can perform this action\");\n    }\n\n    modifier onlySynthRedeemer() {\n        _onlySynthRedeemer();\n        _;\n    }\n\n    modifier issuanceActive() {\n        _issuanceActive();\n        _;\n    }\n\n    function _issuanceActive() private {\n        systemStatus().requireIssuanceActive();\n    }\n\n    modifier synthActive(bytes32 currencyKey) {\n        _synthActive(currencyKey);\n        _;\n    }\n\n    function _synthActive(bytes32 currencyKey) private {\n        systemStatus().requireSynthActive(currencyKey);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SynthAdded(bytes32 currencyKey, address synth);\n    event SynthRemoved(bytes32 currencyKey, address synth);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isystemsettings\ninterface ISystemSettings {\n    // Views\n    function waitingPeriodSecs() external view returns (uint);\n\n    function priceDeviationThresholdFactor() external view returns (uint);\n\n    function issuanceRatio() external view returns (uint);\n\n    function feePeriodDuration() external view returns (uint);\n\n    function targetThreshold() external view returns (uint);\n\n    function liquidationDelay() external view returns (uint);\n\n    function liquidationRatio() external view returns (uint);\n\n    function liquidationPenalty() external view returns (uint);\n\n    function rateStalePeriod() external view returns (uint);\n\n    function exchangeFeeRate(bytes32 currencyKey) external view returns (uint);\n\n    function minimumStakeTime() external view returns (uint);\n\n    function debtSnapshotStaleTime() external view returns (uint);\n\n    function aggregatorWarningFlags() external view returns (address);\n\n    function tradingRewardsEnabled() external view returns (bool);\n\n    function wrapperMaxTokenAmount(address wrapper) external view returns (uint);\n\n    function wrapperMintFeeRate(address wrapper) external view returns (int);\n\n    function wrapperBurnFeeRate(address wrapper) external view returns (int);\n\n    function etherWrapperMaxETH() external view returns (uint);\n\n    function etherWrapperBurnFeeRate() external view returns (uint);\n\n    function etherWrapperMintFeeRate() external view returns (uint);\n\n    function interactionDelay(address collateral) external view returns (uint);\n\n    function atomicMaxVolumePerBlock() external view returns (uint);\n\n    function atomicTwapWindow() external view returns (uint);\n\n    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address);\n\n    function atomicExchangeFeeRate(bytes32 currencyKey) external view returns (uint);\n\n    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint);\n\n    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint);\n\n    function pureChainlinkPriceForAtomicSwapsEnabled(bytes32 currencyKey) external view returns (bool);\n}\n\n\n// Internal references\n\n\n// Libraries\n\n\n/// This library is to reduce SystemSettings contract size only and is not really\n/// a proper library - so it shares knowledge of implementation details\n/// Some of the setters were refactored into this library, and some setters remain in the\n/// contract itself (SystemSettings)\nlibrary SystemSettingsLib {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    bytes32 public constant SETTINGS_CONTRACT_NAME = \"SystemSettings\";\n\n    // No more synths may be issued than the value of SNX backing them.\n    uint public constant MAX_ISSUANCE_RATIO = 1e18;\n\n    // The fee period must be between 1 day and 60 days.\n    uint public constant MIN_FEE_PERIOD_DURATION = 1 days;\n    uint public constant MAX_FEE_PERIOD_DURATION = 60 days;\n\n    uint public constant MAX_TARGET_THRESHOLD = 50;\n\n    uint public constant MAX_LIQUIDATION_RATIO = 1e18; // 100% issuance ratio\n    uint public constant RATIO_FROM_TARGET_BUFFER = 2e18; // 200% - mininimum buffer between issuance ratio and liquidation ratio\n\n    uint public constant MAX_LIQUIDATION_PENALTY = 1e18 / 4; // Max 25% liquidation penalty / bonus\n\n    uint public constant MAX_LIQUIDATION_DELAY = 30 days;\n    uint public constant MIN_LIQUIDATION_DELAY = 1 days;\n\n    // Exchange fee may not exceed 10%.\n    uint public constant MAX_EXCHANGE_FEE_RATE = 1e18 / 10;\n\n    // Minimum Stake time may not exceed 1 weeks.\n    uint public constant MAX_MINIMUM_STAKE_TIME = 1 weeks;\n\n    uint public constant MAX_CROSS_DOMAIN_GAS_LIMIT = 8e6;\n    uint public constant MIN_CROSS_DOMAIN_GAS_LIMIT = 3e6;\n\n    int public constant MAX_WRAPPER_MINT_FEE_RATE = 1e18;\n\n    int public constant MAX_WRAPPER_BURN_FEE_RATE = 1e18;\n\n    // Atomic block volume limit is encoded as uint192.\n    uint public constant MAX_ATOMIC_VOLUME_PER_BLOCK = uint192(-1);\n\n    // TWAP window must be between 1 min and 1 day.\n    uint public constant MIN_ATOMIC_TWAP_WINDOW = 60;\n    uint public constant MAX_ATOMIC_TWAP_WINDOW = 86400;\n\n    // Volatility consideration window must be between 1 min and 1 day.\n    uint public constant MIN_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = 60;\n    uint public constant MAX_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = 86400;\n\n    // workaround for library not supporting public constants in sol v0.5\n    function contractName() external view returns (bytes32) {\n        return SETTINGS_CONTRACT_NAME;\n    }\n\n    function setCrossDomainMessageGasLimit(\n        IFlexibleStorage flexibleStorage,\n        bytes32 gasLimitSettings,\n        uint crossDomainMessageGasLimit\n    ) external {\n        require(\n            crossDomainMessageGasLimit >= MIN_CROSS_DOMAIN_GAS_LIMIT &&\n                crossDomainMessageGasLimit <= MAX_CROSS_DOMAIN_GAS_LIMIT,\n            \"Out of range xDomain gasLimit\"\n        );\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, gasLimitSettings, crossDomainMessageGasLimit);\n    }\n\n    function setIssuanceRatio(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint ratio\n    ) external {\n        require(ratio <= MAX_ISSUANCE_RATIO, \"New issuance ratio cannot exceed MAX_ISSUANCE_RATIO\");\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, ratio);\n    }\n\n    function setTradingRewardsEnabled(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        bool _tradingRewardsEnabled\n    ) external {\n        flexibleStorage.setBoolValue(SETTINGS_CONTRACT_NAME, settingName, _tradingRewardsEnabled);\n    }\n\n    function setWaitingPeriodSecs(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _waitingPeriodSecs\n    ) external {\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _waitingPeriodSecs);\n    }\n\n    function setPriceDeviationThresholdFactor(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _priceDeviationThresholdFactor\n    ) external {\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _priceDeviationThresholdFactor);\n    }\n\n    function setFeePeriodDuration(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _feePeriodDuration\n    ) external {\n        require(_feePeriodDuration >= MIN_FEE_PERIOD_DURATION, \"value < MIN_FEE_PERIOD_DURATION\");\n        require(_feePeriodDuration <= MAX_FEE_PERIOD_DURATION, \"value > MAX_FEE_PERIOD_DURATION\");\n\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _feePeriodDuration);\n    }\n\n    function setTargetThreshold(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint percent\n    ) external returns (uint threshold) {\n        require(percent <= MAX_TARGET_THRESHOLD, \"Threshold too high\");\n        threshold = percent.mul(SafeDecimalMath.unit()).div(100);\n\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, threshold);\n    }\n\n    function setLiquidationDelay(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint time\n    ) external {\n        require(time <= MAX_LIQUIDATION_DELAY, \"Must be less than 30 days\");\n        require(time >= MIN_LIQUIDATION_DELAY, \"Must be greater than 1 day\");\n\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, time);\n    }\n\n    function setLiquidationRatio(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _liquidationRatio,\n        uint getLiquidationPenalty,\n        uint getIssuanceRatio\n    ) external {\n        require(\n            _liquidationRatio <= MAX_LIQUIDATION_RATIO.divideDecimal(SafeDecimalMath.unit().add(getLiquidationPenalty)),\n            \"liquidationRatio > MAX_LIQUIDATION_RATIO / (1 + penalty)\"\n        );\n\n        // MIN_LIQUIDATION_RATIO is a product of target issuance ratio * RATIO_FROM_TARGET_BUFFER\n        // Ensures that liquidation ratio is set so that there is a buffer between the issuance ratio and liquidation ratio.\n        uint MIN_LIQUIDATION_RATIO = getIssuanceRatio.multiplyDecimal(RATIO_FROM_TARGET_BUFFER);\n        require(_liquidationRatio >= MIN_LIQUIDATION_RATIO, \"liquidationRatio < MIN_LIQUIDATION_RATIO\");\n\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _liquidationRatio);\n    }\n\n    function setLiquidationPenalty(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint penalty\n    ) external {\n        require(penalty <= MAX_LIQUIDATION_PENALTY, \"penalty > MAX_LIQUIDATION_PENALTY\");\n\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, penalty);\n    }\n\n    function setRateStalePeriod(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint period\n    ) external {\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, period);\n    }\n\n    function setExchangeFeeRateForSynths(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingExchangeFeeRate,\n        bytes32[] calldata synthKeys,\n        uint256[] calldata exchangeFeeRates\n    ) external {\n        require(synthKeys.length == exchangeFeeRates.length, \"Array lengths dont match\");\n        for (uint i = 0; i < synthKeys.length; i++) {\n            require(exchangeFeeRates[i] <= MAX_EXCHANGE_FEE_RATE, \"MAX_EXCHANGE_FEE_RATE exceeded\");\n            flexibleStorage.setUIntValue(\n                SETTINGS_CONTRACT_NAME,\n                keccak256(abi.encodePacked(settingExchangeFeeRate, synthKeys[i])),\n                exchangeFeeRates[i]\n            );\n        }\n    }\n\n    function setMinimumStakeTime(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _seconds\n    ) external {\n        require(_seconds <= MAX_MINIMUM_STAKE_TIME, \"stake time exceed maximum 1 week\");\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _seconds);\n    }\n\n    function setDebtSnapshotStaleTime(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _seconds\n    ) external {\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _seconds);\n    }\n\n    function setAggregatorWarningFlags(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        address _flags\n    ) external {\n        require(_flags != address(0), \"Valid address must be given\");\n        flexibleStorage.setAddressValue(SETTINGS_CONTRACT_NAME, settingName, _flags);\n    }\n\n    function setEtherWrapperMaxETH(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _maxETH\n    ) external {\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _maxETH);\n    }\n\n    function setEtherWrapperMintFeeRate(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _rate\n    ) external {\n        require(_rate <= uint(MAX_WRAPPER_MINT_FEE_RATE), \"rate > MAX_WRAPPER_MINT_FEE_RATE\");\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _rate);\n    }\n\n    function setEtherWrapperBurnFeeRate(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _rate\n    ) external {\n        require(_rate <= uint(MAX_WRAPPER_BURN_FEE_RATE), \"rate > MAX_WRAPPER_BURN_FEE_RATE\");\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _rate);\n    }\n\n    function setWrapperMaxTokenAmount(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        address _wrapper,\n        uint _maxTokenAmount\n    ) external {\n        flexibleStorage.setUIntValue(\n            SETTINGS_CONTRACT_NAME,\n            keccak256(abi.encodePacked(settingName, _wrapper)),\n            _maxTokenAmount\n        );\n    }\n\n    function setWrapperMintFeeRate(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        address _wrapper,\n        int _rate,\n        int getWrapperBurnFeeRate\n    ) external {\n        require(_rate <= MAX_WRAPPER_MINT_FEE_RATE, \"rate > MAX_WRAPPER_MINT_FEE_RATE\");\n        require(_rate >= -MAX_WRAPPER_MINT_FEE_RATE, \"rate < -MAX_WRAPPER_MINT_FEE_RATE\");\n\n        // if mint rate is negative, burn fee rate should be positive and at least equal in magnitude\n        // otherwise risk of flash loan attack\n        if (_rate < 0) {\n            require(-_rate <= getWrapperBurnFeeRate, \"-rate > wrapperBurnFeeRate\");\n        }\n\n        flexibleStorage.setIntValue(SETTINGS_CONTRACT_NAME, keccak256(abi.encodePacked(settingName, _wrapper)), _rate);\n    }\n\n    function setWrapperBurnFeeRate(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        address _wrapper,\n        int _rate,\n        int getWrapperMintFeeRate\n    ) external {\n        require(_rate <= MAX_WRAPPER_BURN_FEE_RATE, \"rate > MAX_WRAPPER_BURN_FEE_RATE\");\n        require(_rate >= -MAX_WRAPPER_BURN_FEE_RATE, \"rate < -MAX_WRAPPER_BURN_FEE_RATE\");\n\n        // if burn rate is negative, burn fee rate should be negative and at least equal in magnitude\n        // otherwise risk of flash loan attack\n        if (_rate < 0) {\n            require(-_rate <= getWrapperMintFeeRate, \"-rate > wrapperMintFeeRate\");\n        }\n\n        flexibleStorage.setIntValue(SETTINGS_CONTRACT_NAME, keccak256(abi.encodePacked(settingName, _wrapper)), _rate);\n    }\n\n    function setInteractionDelay(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        address _collateral,\n        uint _interactionDelay\n    ) external {\n        require(_interactionDelay <= SafeDecimalMath.unit() * 3600, \"Max 1 hour\");\n        flexibleStorage.setUIntValue(\n            SETTINGS_CONTRACT_NAME,\n            keccak256(abi.encodePacked(settingName, _collateral)),\n            _interactionDelay\n        );\n    }\n\n    function setCollapseFeeRate(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        address _collateral,\n        uint _collapseFeeRate\n    ) external {\n        flexibleStorage.setUIntValue(\n            SETTINGS_CONTRACT_NAME,\n            keccak256(abi.encodePacked(settingName, _collateral)),\n            _collapseFeeRate\n        );\n    }\n\n    function setAtomicMaxVolumePerBlock(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _maxVolume\n    ) external {\n        require(_maxVolume <= MAX_ATOMIC_VOLUME_PER_BLOCK, \"Atomic max volume exceed maximum uint192\");\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _maxVolume);\n    }\n\n    function setAtomicTwapWindow(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _window\n    ) external {\n        require(_window >= MIN_ATOMIC_TWAP_WINDOW, \"Atomic twap window under minimum 1 min\");\n        require(_window <= MAX_ATOMIC_TWAP_WINDOW, \"Atomic twap window exceed maximum 1 day\");\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _window);\n    }\n\n    function setAtomicEquivalentForDexPricing(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        bytes32 _currencyKey,\n        address _equivalent\n    ) external {\n        require(_equivalent != address(0), \"Atomic equivalent is 0 address\");\n        flexibleStorage.setAddressValue(\n            SETTINGS_CONTRACT_NAME,\n            keccak256(abi.encodePacked(settingName, _currencyKey)),\n            _equivalent\n        );\n    }\n\n    function setAtomicExchangeFeeRate(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        bytes32 _currencyKey,\n        uint _exchangeFeeRate\n    ) external {\n        require(_exchangeFeeRate <= MAX_EXCHANGE_FEE_RATE, \"MAX_EXCHANGE_FEE_RATE exceeded\");\n        flexibleStorage.setUIntValue(\n            SETTINGS_CONTRACT_NAME,\n            keccak256(abi.encodePacked(settingName, _currencyKey)),\n            _exchangeFeeRate\n        );\n    }\n\n    function setAtomicVolatilityConsiderationWindow(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        bytes32 _currencyKey,\n        uint _window\n    ) external {\n        if (_window != 0) {\n            require(\n                _window >= MIN_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,\n                \"Atomic volatility consideration window under minimum 1 min\"\n            );\n            require(\n                _window <= MAX_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,\n                \"Atomic volatility consideration window exceed maximum 1 day\"\n            );\n        }\n        flexibleStorage.setUIntValue(\n            SETTINGS_CONTRACT_NAME,\n            keccak256(abi.encodePacked(settingName, _currencyKey)),\n            _window\n        );\n    }\n\n    function setAtomicVolatilityUpdateThreshold(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        bytes32 _currencyKey,\n        uint _threshold\n    ) external {\n        flexibleStorage.setUIntValue(\n            SETTINGS_CONTRACT_NAME,\n            keccak256(abi.encodePacked(settingName, _currencyKey)),\n            _threshold\n        );\n    }\n\n    function setPureChainlinkPriceForAtomicSwapsEnabled(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        bytes32 _currencyKey,\n        bool _enabled\n    ) external {\n        flexibleStorage.setBoolValue(\n            SETTINGS_CONTRACT_NAME,\n            keccak256(abi.encodePacked(settingName, _currencyKey)),\n            _enabled\n        );\n    }\n\n    function setCrossChainSynthTransferEnabled(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        bytes32 _currencyKey,\n        uint _value\n    ) external {\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, keccak256(abi.encodePacked(settingName, _currencyKey)), _value);\n    }\n\n    function setExchangeMaxDynamicFee(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint maxFee\n    ) external {\n        require(maxFee != 0, \"Max dynamic fee cannot be 0\");\n        require(maxFee <= MAX_EXCHANGE_FEE_RATE, \"MAX_EXCHANGE_FEE_RATE exceeded\");\n\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, maxFee);\n    }\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/systemsettings\ncontract SystemSettings is Owned, MixinSystemSettings, ISystemSettings {\n    // SystemSettingsLib is a way to split out the setters to reduce contract size\n    using SystemSettingsLib for IFlexibleStorage;\n\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinSystemSettings(_resolver) {\n        // SETTING_CONTRACT_NAME is defined for the getters in MixinSystemSettings and\n        // SystemSettingsLib.contractName() is a view into SystemSettingsLib of the contract name\n        // that's used by the setters. They have to be equal.\n        require(SETTING_CONTRACT_NAME == SystemSettingsLib.contractName(), \"read and write keys not equal\");\n    }\n\n    // ========== VIEWS ==========\n\n    // backwards compatibility to having CONTRACT_NAME public constant\n    // solhint-disable-next-line func-name-mixedcase\n    function CONTRACT_NAME() external view returns (bytes32) {\n        return SystemSettingsLib.contractName();\n    }\n\n    // SIP-37 Fee Reclamation\n    // The number of seconds after an exchange is executed that must be waited\n    // before settlement.\n    function waitingPeriodSecs() external view returns (uint) {\n        return getWaitingPeriodSecs();\n    }\n\n    // SIP-65 Decentralized Circuit Breaker\n    // The factor amount expressed in decimal format\n    // E.g. 3e18 = factor 3, meaning movement up to 3x and above or down to 1/3x and below\n    function priceDeviationThresholdFactor() external view returns (uint) {\n        return getPriceDeviationThresholdFactor();\n    }\n\n    // The raio of collateral\n    // Expressed in 18 decimals. So 800% cratio is 100/800 = 0.125 (0.125e18)\n    function issuanceRatio() external view returns (uint) {\n        return getIssuanceRatio();\n    }\n\n    // How long a fee period lasts at a minimum. It is required for\n    // anyone to roll over the periods, so they are not guaranteed\n    // to roll over at exactly this duration, but the contract enforces\n    // that they cannot roll over any quicker than this duration.\n    function feePeriodDuration() external view returns (uint) {\n        return getFeePeriodDuration();\n    }\n\n    // Users are unable to claim fees if their collateralisation ratio drifts out of target threshold\n    function targetThreshold() external view returns (uint) {\n        return getTargetThreshold();\n    }\n\n    // SIP-15 Liquidations\n    // liquidation time delay after address flagged (seconds)\n    function liquidationDelay() external view returns (uint) {\n        return getLiquidationDelay();\n    }\n\n    // SIP-15 Liquidations\n    // issuance ratio when account can be flagged for liquidation (with 18 decimals), e.g 0.5 issuance ratio\n    // when flag means 1/0.5 = 200% cratio\n    function liquidationRatio() external view returns (uint) {\n        return getLiquidationRatio();\n    }\n\n    // SIP-15 Liquidations\n    // penalty taken away from target of liquidation (with 18 decimals). E.g. 10% is 0.1e18\n    function liquidationPenalty() external view returns (uint) {\n        return getLiquidationPenalty();\n    }\n\n    // How long will the ExchangeRates contract assume the rate of any asset is correct\n    function rateStalePeriod() external view returns (uint) {\n        return getRateStalePeriod();\n    }\n\n    /* ========== Exchange Related Fees ========== */\n    function exchangeFeeRate(bytes32 currencyKey) external view returns (uint) {\n        return getExchangeFeeRate(currencyKey);\n    }\n\n    // SIP-184 Dynamic Fee\n    /// @notice Get the dynamic fee threshold\n    /// @return The dynamic fee threshold\n    function exchangeDynamicFeeThreshold() external view returns (uint) {\n        return getExchangeDynamicFeeConfig().threshold;\n    }\n\n    /// @notice Get the dynamic fee weight decay per round\n    /// @return The dynamic fee weight decay per round\n    function exchangeDynamicFeeWeightDecay() external view returns (uint) {\n        return getExchangeDynamicFeeConfig().weightDecay;\n    }\n\n    /// @notice Get the dynamic fee total rounds for calculation\n    /// @return The dynamic fee total rounds for calculation\n    function exchangeDynamicFeeRounds() external view returns (uint) {\n        return getExchangeDynamicFeeConfig().rounds;\n    }\n\n    /// @notice Get the max dynamic fee\n    /// @return The max dynamic fee\n    function exchangeMaxDynamicFee() external view returns (uint) {\n        return getExchangeDynamicFeeConfig().maxFee;\n    }\n\n    /* ========== End Exchange Related Fees ========== */\n\n    function minimumStakeTime() external view returns (uint) {\n        return getMinimumStakeTime();\n    }\n\n    function debtSnapshotStaleTime() external view returns (uint) {\n        return getDebtSnapshotStaleTime();\n    }\n\n    function aggregatorWarningFlags() external view returns (address) {\n        return getAggregatorWarningFlags();\n    }\n\n    // SIP-63 Trading incentives\n    // determines if Exchanger records fee entries in TradingRewards\n    function tradingRewardsEnabled() external view returns (bool) {\n        return getTradingRewardsEnabled();\n    }\n\n    function crossDomainMessageGasLimit(CrossDomainMessageGasLimits gasLimitType) external view returns (uint) {\n        return getCrossDomainMessageGasLimit(gasLimitType);\n    }\n\n    // SIP 112: ETH Wrappr\n    // The maximum amount of ETH held by the EtherWrapper.\n    function etherWrapperMaxETH() external view returns (uint) {\n        return getEtherWrapperMaxETH();\n    }\n\n    // SIP 112: ETH Wrappr\n    // The fee for depositing ETH into the EtherWrapper.\n    function etherWrapperMintFeeRate() external view returns (uint) {\n        return getEtherWrapperMintFeeRate();\n    }\n\n    // SIP 112: ETH Wrappr\n    // The fee for burning sETH and releasing ETH from the EtherWrapper.\n    function etherWrapperBurnFeeRate() external view returns (uint) {\n        return getEtherWrapperBurnFeeRate();\n    }\n\n    // SIP 182: Wrapper Factory\n    // The maximum amount of token held by the Wrapper.\n    function wrapperMaxTokenAmount(address wrapper) external view returns (uint) {\n        return getWrapperMaxTokenAmount(wrapper);\n    }\n\n    // SIP 182: Wrapper Factory\n    // The fee for depositing token into the Wrapper.\n    function wrapperMintFeeRate(address wrapper) external view returns (int) {\n        return getWrapperMintFeeRate(wrapper);\n    }\n\n    // SIP 182: Wrapper Factory\n    // The fee for burning synth and releasing token from the Wrapper.\n    function wrapperBurnFeeRate(address wrapper) external view returns (int) {\n        return getWrapperBurnFeeRate(wrapper);\n    }\n\n    function interactionDelay(address collateral) external view returns (uint) {\n        return getInteractionDelay(collateral);\n    }\n\n    function collapseFeeRate(address collateral) external view returns (uint) {\n        return getCollapseFeeRate(collateral);\n    }\n\n    // SIP-120 Atomic exchanges\n    // max allowed volume per block for atomic exchanges\n    function atomicMaxVolumePerBlock() external view returns (uint) {\n        return getAtomicMaxVolumePerBlock();\n    }\n\n    // SIP-120 Atomic exchanges\n    // time window (in seconds) for TWAP prices when considered for atomic exchanges\n    function atomicTwapWindow() external view returns (uint) {\n        return getAtomicTwapWindow();\n    }\n\n    // SIP-120 Atomic exchanges\n    // equivalent asset to use for a synth when considering external prices for atomic exchanges\n    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address) {\n        return getAtomicEquivalentForDexPricing(currencyKey);\n    }\n\n    // SIP-120 Atomic exchanges\n    // fee rate override for atomic exchanges into a synth\n    function atomicExchangeFeeRate(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicExchangeFeeRate(currencyKey);\n    }\n\n    // SIP-120 Atomic exchanges\n    // consideration window for determining synth volatility\n    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicVolatilityConsiderationWindow(currencyKey);\n    }\n\n    // SIP-120 Atomic exchanges\n    // update threshold for determining synth volatility\n    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicVolatilityUpdateThreshold(currencyKey);\n    }\n\n    // SIP-198: Atomic Exchange At Pure Chainlink Price\n    // Whether to use the pure Chainlink price for a given currency key\n    function pureChainlinkPriceForAtomicSwapsEnabled(bytes32 currencyKey) external view returns (bool) {\n        return getPureChainlinkPriceForAtomicSwapsEnabled(currencyKey);\n    }\n\n    // SIP-229 Atomic exchanges\n    // enable/disable sending of synths cross chain\n    function crossChainSynthTransferEnabled(bytes32 currencyKey) external view returns (uint) {\n        return getCrossChainSynthTransferEnabled(currencyKey);\n    }\n\n    // ========== RESTRICTED ==========\n\n    function setCrossDomainMessageGasLimit(CrossDomainMessageGasLimits _gasLimitType, uint _crossDomainMessageGasLimit)\n        external\n        onlyOwner\n    {\n        flexibleStorage().setCrossDomainMessageGasLimit(_getGasLimitSetting(_gasLimitType), _crossDomainMessageGasLimit);\n        emit CrossDomainMessageGasLimitChanged(_gasLimitType, _crossDomainMessageGasLimit);\n    }\n\n    function setIssuanceRatio(uint ratio) external onlyOwner {\n        flexibleStorage().setIssuanceRatio(SETTING_ISSUANCE_RATIO, ratio);\n        emit IssuanceRatioUpdated(ratio);\n    }\n\n    function setTradingRewardsEnabled(bool _tradingRewardsEnabled) external onlyOwner {\n        flexibleStorage().setTradingRewardsEnabled(SETTING_TRADING_REWARDS_ENABLED, _tradingRewardsEnabled);\n        emit TradingRewardsEnabled(_tradingRewardsEnabled);\n    }\n\n    function setWaitingPeriodSecs(uint _waitingPeriodSecs) external onlyOwner {\n        flexibleStorage().setWaitingPeriodSecs(SETTING_WAITING_PERIOD_SECS, _waitingPeriodSecs);\n        emit WaitingPeriodSecsUpdated(_waitingPeriodSecs);\n    }\n\n    function setPriceDeviationThresholdFactor(uint _priceDeviationThresholdFactor) external onlyOwner {\n        flexibleStorage().setPriceDeviationThresholdFactor(\n            SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR,\n            _priceDeviationThresholdFactor\n        );\n        emit PriceDeviationThresholdUpdated(_priceDeviationThresholdFactor);\n    }\n\n    function setFeePeriodDuration(uint _feePeriodDuration) external onlyOwner {\n        flexibleStorage().setFeePeriodDuration(SETTING_FEE_PERIOD_DURATION, _feePeriodDuration);\n        emit FeePeriodDurationUpdated(_feePeriodDuration);\n    }\n\n    function setTargetThreshold(uint percent) external onlyOwner {\n        uint threshold = flexibleStorage().setTargetThreshold(SETTING_TARGET_THRESHOLD, percent);\n        emit TargetThresholdUpdated(threshold);\n    }\n\n    function setLiquidationDelay(uint time) external onlyOwner {\n        flexibleStorage().setLiquidationDelay(SETTING_LIQUIDATION_DELAY, time);\n        emit LiquidationDelayUpdated(time);\n    }\n\n    // The collateral / issuance ratio ( debt / collateral ) is higher when there is less collateral backing their debt\n    // Upper bound liquidationRatio is 1 + penalty (100% + 10% = 110%) to allow collateral value to cover debt and liquidation penalty\n    function setLiquidationRatio(uint _liquidationRatio) external onlyOwner {\n        flexibleStorage().setLiquidationRatio(\n            SETTING_LIQUIDATION_RATIO,\n            _liquidationRatio,\n            getLiquidationPenalty(),\n            getIssuanceRatio()\n        );\n        emit LiquidationRatioUpdated(_liquidationRatio);\n    }\n\n    function setLiquidationPenalty(uint penalty) external onlyOwner {\n        flexibleStorage().setLiquidationPenalty(SETTING_LIQUIDATION_PENALTY, penalty);\n        emit LiquidationPenaltyUpdated(penalty);\n    }\n\n    function setRateStalePeriod(uint period) external onlyOwner {\n        flexibleStorage().setRateStalePeriod(SETTING_RATE_STALE_PERIOD, period);\n        emit RateStalePeriodUpdated(period);\n    }\n\n    /* ========== Exchange Fees Related ========== */\n    function setExchangeFeeRateForSynths(bytes32[] calldata synthKeys, uint256[] calldata exchangeFeeRates)\n        external\n        onlyOwner\n    {\n        flexibleStorage().setExchangeFeeRateForSynths(SETTING_EXCHANGE_FEE_RATE, synthKeys, exchangeFeeRates);\n        for (uint i = 0; i < synthKeys.length; i++) {\n            emit ExchangeFeeUpdated(synthKeys[i], exchangeFeeRates[i]);\n        }\n    }\n\n    /// @notice Set exchange dynamic fee threshold constant in decimal ratio\n    /// @param threshold The exchange dynamic fee threshold\n    /// @return uint threshold constant\n    function setExchangeDynamicFeeThreshold(uint threshold) external onlyOwner {\n        require(threshold != 0, \"Threshold cannot be 0\");\n\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD, threshold);\n\n        emit ExchangeDynamicFeeThresholdUpdated(threshold);\n    }\n\n    /// @notice Set exchange dynamic fee weight decay constant\n    /// @param weightDecay The exchange dynamic fee weight decay\n    /// @return uint weight decay constant\n    function setExchangeDynamicFeeWeightDecay(uint weightDecay) external onlyOwner {\n        require(weightDecay != 0, \"Weight decay cannot be 0\");\n\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY, weightDecay);\n\n        emit ExchangeDynamicFeeWeightDecayUpdated(weightDecay);\n    }\n\n    /// @notice Set exchange dynamic fee last N rounds with minimum 2 rounds\n    /// @param rounds The exchange dynamic fee last N rounds\n    /// @return uint dynamic fee last N rounds\n    function setExchangeDynamicFeeRounds(uint rounds) external onlyOwner {\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS, rounds);\n\n        emit ExchangeDynamicFeeRoundsUpdated(rounds);\n    }\n\n    /// @notice Set max exchange dynamic fee\n    /// @param maxFee The max exchange dynamic fee\n    /// @return uint dynamic fee last N rounds\n    function setExchangeMaxDynamicFee(uint maxFee) external onlyOwner {\n        flexibleStorage().setExchangeMaxDynamicFee(SETTING_EXCHANGE_MAX_DYNAMIC_FEE, maxFee);\n        emit ExchangeMaxDynamicFeeUpdated(maxFee);\n    }\n\n    function setMinimumStakeTime(uint _seconds) external onlyOwner {\n        flexibleStorage().setMinimumStakeTime(SETTING_MINIMUM_STAKE_TIME, _seconds);\n        emit MinimumStakeTimeUpdated(_seconds);\n    }\n\n    function setDebtSnapshotStaleTime(uint _seconds) external onlyOwner {\n        flexibleStorage().setDebtSnapshotStaleTime(SETTING_DEBT_SNAPSHOT_STALE_TIME, _seconds);\n        emit DebtSnapshotStaleTimeUpdated(_seconds);\n    }\n\n    function setAggregatorWarningFlags(address _flags) external onlyOwner {\n        flexibleStorage().setAggregatorWarningFlags(SETTING_AGGREGATOR_WARNING_FLAGS, _flags);\n        emit AggregatorWarningFlagsUpdated(_flags);\n    }\n\n    function setEtherWrapperMaxETH(uint _maxETH) external onlyOwner {\n        flexibleStorage().setEtherWrapperMaxETH(SETTING_ETHER_WRAPPER_MAX_ETH, _maxETH);\n        emit EtherWrapperMaxETHUpdated(_maxETH);\n    }\n\n    function setEtherWrapperMintFeeRate(uint _rate) external onlyOwner {\n        flexibleStorage().setEtherWrapperMintFeeRate(SETTING_ETHER_WRAPPER_MINT_FEE_RATE, _rate);\n        emit EtherWrapperMintFeeRateUpdated(_rate);\n    }\n\n    function setEtherWrapperBurnFeeRate(uint _rate) external onlyOwner {\n        flexibleStorage().setEtherWrapperBurnFeeRate(SETTING_ETHER_WRAPPER_BURN_FEE_RATE, _rate);\n        emit EtherWrapperBurnFeeRateUpdated(_rate);\n    }\n\n    function setWrapperMaxTokenAmount(address _wrapper, uint _maxTokenAmount) external onlyOwner {\n        flexibleStorage().setWrapperMaxTokenAmount(SETTING_WRAPPER_MAX_TOKEN_AMOUNT, _wrapper, _maxTokenAmount);\n        emit WrapperMaxTokenAmountUpdated(_wrapper, _maxTokenAmount);\n    }\n\n    function setWrapperMintFeeRate(address _wrapper, int _rate) external onlyOwner {\n        flexibleStorage().setWrapperMintFeeRate(\n            SETTING_WRAPPER_MINT_FEE_RATE,\n            _wrapper,\n            _rate,\n            getWrapperBurnFeeRate(_wrapper)\n        );\n        emit WrapperMintFeeRateUpdated(_wrapper, _rate);\n    }\n\n    function setWrapperBurnFeeRate(address _wrapper, int _rate) external onlyOwner {\n        flexibleStorage().setWrapperBurnFeeRate(\n            SETTING_WRAPPER_BURN_FEE_RATE,\n            _wrapper,\n            _rate,\n            getWrapperMintFeeRate(_wrapper)\n        );\n        emit WrapperBurnFeeRateUpdated(_wrapper, _rate);\n    }\n\n    function setInteractionDelay(address _collateral, uint _interactionDelay) external onlyOwner {\n        flexibleStorage().setInteractionDelay(SETTING_INTERACTION_DELAY, _collateral, _interactionDelay);\n        emit InteractionDelayUpdated(_interactionDelay);\n    }\n\n    function setCollapseFeeRate(address _collateral, uint _collapseFeeRate) external onlyOwner {\n        flexibleStorage().setCollapseFeeRate(SETTING_COLLAPSE_FEE_RATE, _collateral, _collapseFeeRate);\n        emit CollapseFeeRateUpdated(_collapseFeeRate);\n    }\n\n    function setAtomicMaxVolumePerBlock(uint _maxVolume) external onlyOwner {\n        flexibleStorage().setAtomicMaxVolumePerBlock(SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK, _maxVolume);\n        emit AtomicMaxVolumePerBlockUpdated(_maxVolume);\n    }\n\n    function setAtomicTwapWindow(uint _window) external onlyOwner {\n        flexibleStorage().setAtomicTwapWindow(SETTING_ATOMIC_TWAP_WINDOW, _window);\n        emit AtomicTwapWindowUpdated(_window);\n    }\n\n    function setAtomicEquivalentForDexPricing(bytes32 _currencyKey, address _equivalent) external onlyOwner {\n        flexibleStorage().setAtomicEquivalentForDexPricing(\n            SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING,\n            _currencyKey,\n            _equivalent\n        );\n        emit AtomicEquivalentForDexPricingUpdated(_currencyKey, _equivalent);\n    }\n\n    function setAtomicExchangeFeeRate(bytes32 _currencyKey, uint256 _exchangeFeeRate) external onlyOwner {\n        flexibleStorage().setAtomicExchangeFeeRate(SETTING_ATOMIC_EXCHANGE_FEE_RATE, _currencyKey, _exchangeFeeRate);\n        emit AtomicExchangeFeeUpdated(_currencyKey, _exchangeFeeRate);\n    }\n\n    function setAtomicVolatilityConsiderationWindow(bytes32 _currencyKey, uint _window) external onlyOwner {\n        flexibleStorage().setAtomicVolatilityConsiderationWindow(\n            SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,\n            _currencyKey,\n            _window\n        );\n        emit AtomicVolatilityConsiderationWindowUpdated(_currencyKey, _window);\n    }\n\n    function setAtomicVolatilityUpdateThreshold(bytes32 _currencyKey, uint _threshold) external onlyOwner {\n        flexibleStorage().setAtomicVolatilityUpdateThreshold(\n            SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD,\n            _currencyKey,\n            _threshold\n        );\n        emit AtomicVolatilityUpdateThresholdUpdated(_currencyKey, _threshold);\n    }\n\n    function setPureChainlinkPriceForAtomicSwapsEnabled(bytes32 _currencyKey, bool _enabled) external onlyOwner {\n        flexibleStorage().setPureChainlinkPriceForAtomicSwapsEnabled(\n            SETTING_PURE_CHAINLINK_PRICE_FOR_ATOMIC_SWAPS_ENABLED,\n            _currencyKey,\n            _enabled\n        );\n        emit PureChainlinkPriceForAtomicSwapsEnabledUpdated(_currencyKey, _enabled);\n    }\n\n    function setCrossChainSynthTransferEnabled(bytes32 _currencyKey, uint _value) external onlyOwner {\n        flexibleStorage().setCrossChainSynthTransferEnabled(SETTING_CROSS_SYNTH_TRANSFER_ENABLED, _currencyKey, _value);\n        emit CrossChainSynthTransferEnabledUpdated(_currencyKey, _value);\n    }\n\n    // ========== EVENTS ==========\n    event CrossDomainMessageGasLimitChanged(CrossDomainMessageGasLimits gasLimitType, uint newLimit);\n    event IssuanceRatioUpdated(uint newRatio);\n    event TradingRewardsEnabled(bool enabled);\n    event WaitingPeriodSecsUpdated(uint waitingPeriodSecs);\n    event PriceDeviationThresholdUpdated(uint threshold);\n    event FeePeriodDurationUpdated(uint newFeePeriodDuration);\n    event TargetThresholdUpdated(uint newTargetThreshold);\n    event LiquidationDelayUpdated(uint newDelay);\n    event LiquidationRatioUpdated(uint newRatio);\n    event LiquidationPenaltyUpdated(uint newPenalty);\n    event RateStalePeriodUpdated(uint rateStalePeriod);\n    /* ========== Exchange Fees Related ========== */\n    event ExchangeFeeUpdated(bytes32 synthKey, uint newExchangeFeeRate);\n    event ExchangeDynamicFeeThresholdUpdated(uint dynamicFeeThreshold);\n    event ExchangeDynamicFeeWeightDecayUpdated(uint dynamicFeeWeightDecay);\n    event ExchangeDynamicFeeRoundsUpdated(uint dynamicFeeRounds);\n    event ExchangeMaxDynamicFeeUpdated(uint maxDynamicFee);\n    /* ========== End Exchange Fees Related ========== */\n    event MinimumStakeTimeUpdated(uint minimumStakeTime);\n    event DebtSnapshotStaleTimeUpdated(uint debtSnapshotStaleTime);\n    event AggregatorWarningFlagsUpdated(address flags);\n    event EtherWrapperMaxETHUpdated(uint maxETH);\n    event EtherWrapperMintFeeRateUpdated(uint rate);\n    event EtherWrapperBurnFeeRateUpdated(uint rate);\n    event WrapperMaxTokenAmountUpdated(address wrapper, uint maxTokenAmount);\n    event WrapperMintFeeRateUpdated(address wrapper, int rate);\n    event WrapperBurnFeeRateUpdated(address wrapper, int rate);\n    event InteractionDelayUpdated(uint interactionDelay);\n    event CollapseFeeRateUpdated(uint collapseFeeRate);\n    event AtomicMaxVolumePerBlockUpdated(uint newMaxVolume);\n    event AtomicTwapWindowUpdated(uint newWindow);\n    event AtomicEquivalentForDexPricingUpdated(bytes32 synthKey, address equivalent);\n    event AtomicExchangeFeeUpdated(bytes32 synthKey, uint newExchangeFeeRate);\n    event AtomicVolatilityConsiderationWindowUpdated(bytes32 synthKey, uint newVolatilityConsiderationWindow);\n    event AtomicVolatilityUpdateThresholdUpdated(bytes32 synthKey, uint newVolatilityUpdateThreshold);\n    event PureChainlinkPriceForAtomicSwapsEnabledUpdated(bytes32 synthKey, bool enabled);\n    event CrossChainSynthTransferEnabledUpdated(bytes32 synthKey, uint value);\n}\n\n\ninterface ISynthetixNamedContract {\n    // solhint-disable func-name-mixedcase\n    function CONTRACT_NAME() external view returns (bytes32);\n}\n\n// solhint-disable contract-name-camelcase\ncontract Migration_Mirach is BaseMigration {\n    // https://etherscan.io/address/0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\n    address public constant OWNER = 0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\n\n    // ----------------------------\n    // EXISTING SYNTHETIX CONTRACTS\n    // ----------------------------\n\n    // https://etherscan.io/address/0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83\n    AddressResolver public constant addressresolver_i = AddressResolver(0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83);\n    // https://etherscan.io/address/0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F\n    Proxy public constant proxysynthetix_i = Proxy(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F);\n    // https://etherscan.io/address/0x545973f28950f50fc6c7F52AAb4Ad214A27C0564\n    ExchangeState public constant exchangestate_i = ExchangeState(0x545973f28950f50fc6c7F52AAb4Ad214A27C0564);\n    // https://etherscan.io/address/0x696c905F8F8c006cA46e9808fE7e00049507798F\n    SystemStatus public constant systemstatus_i = SystemStatus(0x696c905F8F8c006cA46e9808fE7e00049507798F);\n    // https://etherscan.io/address/0x5b1b5fEa1b99D83aD479dF0C222F0492385381dD\n    LegacyTokenState public constant tokenstatesynthetix_i = LegacyTokenState(0x5b1b5fEa1b99D83aD479dF0C222F0492385381dD);\n    // https://etherscan.io/address/0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F\n    RewardEscrow public constant rewardescrow_i = RewardEscrow(0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F);\n    // https://etherscan.io/address/0x29C295B046a73Cde593f21f63091B072d407e3F2\n    RewardsDistribution public constant rewardsdistribution_i =\n        RewardsDistribution(0x29C295B046a73Cde593f21f63091B072d407e3F2);\n    // https://etherscan.io/address/0xb4dc5ced63C2918c89E491D19BF1C0e92845de7C\n    ExchangeRatesWithDexPricing public constant exchangerates_i =\n        ExchangeRatesWithDexPricing(0xb4dc5ced63C2918c89E491D19BF1C0e92845de7C);\n    // https://etherscan.io/address/0x7808bFD6e20AFE2d82b159590Ca5635b6263Db3F\n    Issuer public constant issuer_i = Issuer(0x7808bFD6e20AFE2d82b159590Ca5635b6263Db3F);\n    // https://etherscan.io/address/0xA4339a001c87e2C79B2d8A50D38c16cf12F3D6EE\n    SystemSettings public constant systemsettings_i = SystemSettings(0xA4339a001c87e2C79B2d8A50D38c16cf12F3D6EE);\n\n    // ----------------------------------\n    // NEW CONTRACTS DEPLOYED TO BE ADDED\n    // ----------------------------------\n\n    // https://etherscan.io/address/0xb4dc5ced63C2918c89E491D19BF1C0e92845de7C\n    address public constant new_ExchangeRates_contract = 0xb4dc5ced63C2918c89E491D19BF1C0e92845de7C;\n    // https://etherscan.io/address/0xA4339a001c87e2C79B2d8A50D38c16cf12F3D6EE\n    address public constant new_SystemSettings_contract = 0xA4339a001c87e2C79B2d8A50D38c16cf12F3D6EE;\n    // https://etherscan.io/address/0x639032d3900875a4cf4960aD6b9ee441657aA93C\n    address public constant new_Synthetix_contract = 0x639032d3900875a4cf4960aD6b9ee441657aA93C;\n    // https://etherscan.io/address/0x9aB91BdCE9ae5D66d7d925699743Fa3A503c8eb8\n    address public constant new_Exchanger_contract = 0x9aB91BdCE9ae5D66d7d925699743Fa3A503c8eb8;\n    // https://etherscan.io/address/0x7808bFD6e20AFE2d82b159590Ca5635b6263Db3F\n    address public constant new_Issuer_contract = 0x7808bFD6e20AFE2d82b159590Ca5635b6263Db3F;\n    // https://etherscan.io/address/0x39Ea01a0298C315d149a490E34B59Dbf2EC7e48F\n    address public constant new_SynthetixBridgeToOptimism_contract = 0x39Ea01a0298C315d149a490E34B59Dbf2EC7e48F;\n\n    constructor() public BaseMigration(OWNER) {}\n\n    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {\n        contracts = new address[](10);\n        contracts[0] = address(addressresolver_i);\n        contracts[1] = address(proxysynthetix_i);\n        contracts[2] = address(exchangestate_i);\n        contracts[3] = address(systemstatus_i);\n        contracts[4] = address(tokenstatesynthetix_i);\n        contracts[5] = address(rewardescrow_i);\n        contracts[6] = address(rewardsdistribution_i);\n        contracts[7] = address(exchangerates_i);\n        contracts[8] = address(issuer_i);\n        contracts[9] = address(systemsettings_i);\n    }\n\n    function migrate() external onlyOwner {\n        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes\n        acceptAll();\n\n        // MIGRATION\n        // Import all new contracts into the address resolver;\n        addressresolver_importAddresses_0();\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;\n        addressresolver_rebuildCaches_1();\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;\n        addressresolver_rebuildCaches_2();\n        // Ensure the SNX proxy has the correct Synthetix target set;\n        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));\n        // Ensure the Exchanger contract can write to its State;\n        exchangestate_i.setAssociatedContract(new_Exchanger_contract);\n        // Ensure Issuer contract can suspend issuance - see SIP-165;\n        systemstatus_i.updateAccessControl(\"Issuance\", new_Issuer_contract, true, false);\n        // Ensure the Synthetix contract can write to its TokenState contract;\n        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);\n        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;\n        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));\n        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;\n        rewardsdistribution_i.setAuthority(new_Synthetix_contract);\n        // Ensure the ExchangeRates contract has the standalone feed for SNX;\n        exchangerates_i.addAggregator(\"SNX\", 0xDC3EA94CD0AC27d9A86C180091e7f78C683d3699);\n        // Ensure the ExchangeRates contract has the standalone feed for ETH;\n        exchangerates_i.addAggregator(\"ETH\", 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n        // Ensure the ExchangeRates contract has the standalone feed for AAVE;\n        exchangerates_i.addAggregator(\"AAVE\", 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9);\n        // Ensure the ExchangeRates contract has the standalone feed for DOT;\n        exchangerates_i.addAggregator(\"DOT\", 0x1C07AFb8E2B827c5A4739C6d59Ae3A5035f28734);\n        // Ensure the ExchangeRates contract has the standalone feed for BTC;\n        exchangerates_i.addAggregator(\"BTC\", 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);\n        // Ensure the ExchangeRates contract has the standalone feed for LINK;\n        exchangerates_i.addAggregator(\"LINK\", 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c);\n        // Ensure the ExchangeRates contract has the standalone feed for ADA;\n        exchangerates_i.addAggregator(\"ADA\", 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55);\n        // Ensure the ExchangeRates contract has the standalone feed for DEFI;\n        exchangerates_i.addAggregator(\"DEFI\", 0xa8E875F94138B0C5b51d1e1d5dE35bbDdd28EA87);\n        // Ensure the ExchangeRates contract has the standalone feed for ETHBTC;\n        exchangerates_i.addAggregator(\"ETHBTC\", 0xAc559F25B1619171CbC396a50854A3240b6A4e99);\n        // Ensure the ExchangeRates contract has the standalone feed for EUR;\n        exchangerates_i.addAggregator(\"EUR\", 0xb49f677943BC038e9857d61E7d053CaA2C1734C1);\n        // Ensure the ExchangeRates contract has the standalone feed for JPY;\n        exchangerates_i.addAggregator(\"JPY\", 0xBcE206caE7f0ec07b545EddE332A47C2F75bbeb3);\n        // Ensure the ExchangeRates contract has the standalone feed for AUD;\n        exchangerates_i.addAggregator(\"AUD\", 0x77F9710E7d0A19669A13c055F62cd80d313dF022);\n        // Ensure the ExchangeRates contract has the standalone feed for GBP;\n        exchangerates_i.addAggregator(\"GBP\", 0x5c0Ab2d9b5a7ed9f470386e82BB36A3613cDd4b5);\n        // Ensure the ExchangeRates contract has the standalone feed for CHF;\n        exchangerates_i.addAggregator(\"CHF\", 0x449d117117838fFA61263B61dA6301AA2a88B13A);\n        // Ensure the ExchangeRates contract has the standalone feed for KRW;\n        exchangerates_i.addAggregator(\"KRW\", 0x01435677FB11763550905594A16B645847C1d0F3);\n        // Ensure the ExchangeRates contract has the feed for sEUR;\n        exchangerates_i.addAggregator(\"sEUR\", 0xb49f677943BC038e9857d61E7d053CaA2C1734C1);\n        // Ensure the ExchangeRates contract has the feed for sJPY;\n        exchangerates_i.addAggregator(\"sJPY\", 0xBcE206caE7f0ec07b545EddE332A47C2F75bbeb3);\n        // Ensure the ExchangeRates contract has the feed for sAUD;\n        exchangerates_i.addAggregator(\"sAUD\", 0x77F9710E7d0A19669A13c055F62cd80d313dF022);\n        // Ensure the ExchangeRates contract has the feed for sGBP;\n        exchangerates_i.addAggregator(\"sGBP\", 0x5c0Ab2d9b5a7ed9f470386e82BB36A3613cDd4b5);\n        // Ensure the ExchangeRates contract has the feed for sCHF;\n        exchangerates_i.addAggregator(\"sCHF\", 0x449d117117838fFA61263B61dA6301AA2a88B13A);\n        // Ensure the ExchangeRates contract has the feed for sKRW;\n        exchangerates_i.addAggregator(\"sKRW\", 0x01435677FB11763550905594A16B645847C1d0F3);\n        // Ensure the ExchangeRates contract has the feed for sBTC;\n        exchangerates_i.addAggregator(\"sBTC\", 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);\n        // Ensure the ExchangeRates contract has the feed for sETH;\n        exchangerates_i.addAggregator(\"sETH\", 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n        // Ensure the ExchangeRates contract has the feed for sLINK;\n        exchangerates_i.addAggregator(\"sLINK\", 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c);\n        // Ensure the ExchangeRates contract has the feed for sADA;\n        exchangerates_i.addAggregator(\"sADA\", 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55);\n        // Ensure the ExchangeRates contract has the feed for sAAVE;\n        exchangerates_i.addAggregator(\"sAAVE\", 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9);\n        // Ensure the ExchangeRates contract has the feed for sDOT;\n        exchangerates_i.addAggregator(\"sDOT\", 0x1C07AFb8E2B827c5A4739C6d59Ae3A5035f28734);\n        // Ensure the ExchangeRates contract has the feed for sETHBTC;\n        exchangerates_i.addAggregator(\"sETHBTC\", 0xAc559F25B1619171CbC396a50854A3240b6A4e99);\n        // Ensure the ExchangeRates contract has the feed for sDEFI;\n        exchangerates_i.addAggregator(\"sDEFI\", 0xa8E875F94138B0C5b51d1e1d5dE35bbDdd28EA87);\n        // Add synths to the Issuer contract - batch 1;\n        issuer_addSynths_44();\n        // Set the max amount of Ether allowed in the EtherWrapper (SIP-112);\n        systemsettings_i.setEtherWrapperMaxETH(5000000000000000000000);\n        // SIP-120 Set the DEX price aggregator (uniswap TWAP oracle reader);\n        exchangerates_i.setDexPriceAggregator(IDexPriceAggregator(0xf120F029Ac143633d1942e48aE2Dfa2036C5786c));\n\n        // NOMINATE OWNERSHIP back to owner for aforementioned contracts\n        nominateAll();\n    }\n\n    function acceptAll() internal {\n        address[] memory contracts = contractsRequiringOwnership();\n        for (uint i = 0; i < contracts.length; i++) {\n            Owned(contracts[i]).acceptOwnership();\n        }\n    }\n\n    function nominateAll() internal {\n        address[] memory contracts = contractsRequiringOwnership();\n        for (uint i = 0; i < contracts.length; i++) {\n            returnOwnership(contracts[i]);\n        }\n    }\n\n    function addressresolver_importAddresses_0() internal {\n        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](6);\n        addressresolver_importAddresses_names_0_0[0] = bytes32(\"ExchangeRates\");\n        addressresolver_importAddresses_names_0_0[1] = bytes32(\"SystemSettings\");\n        addressresolver_importAddresses_names_0_0[2] = bytes32(\"Synthetix\");\n        addressresolver_importAddresses_names_0_0[3] = bytes32(\"Exchanger\");\n        addressresolver_importAddresses_names_0_0[4] = bytes32(\"Issuer\");\n        addressresolver_importAddresses_names_0_0[5] = bytes32(\"SynthetixBridgeToOptimism\");\n        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](6);\n        addressresolver_importAddresses_destinations_0_1[0] = address(new_ExchangeRates_contract);\n        addressresolver_importAddresses_destinations_0_1[1] = address(new_SystemSettings_contract);\n        addressresolver_importAddresses_destinations_0_1[2] = address(new_Synthetix_contract);\n        addressresolver_importAddresses_destinations_0_1[3] = address(new_Exchanger_contract);\n        addressresolver_importAddresses_destinations_0_1[4] = address(new_Issuer_contract);\n        addressresolver_importAddresses_destinations_0_1[5] = address(new_SynthetixBridgeToOptimism_contract);\n        addressresolver_i.importAddresses(\n            addressresolver_importAddresses_names_0_0,\n            addressresolver_importAddresses_destinations_0_1\n        );\n    }\n\n    function addressresolver_rebuildCaches_1() internal {\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_1_0 = new MixinResolver[](20);\n        addressresolver_rebuildCaches_destinations_1_0[0] = MixinResolver(0xAD95C918af576c82Df740878C3E983CBD175daB6);\n        addressresolver_rebuildCaches_destinations_1_0[1] = MixinResolver(0x1620Aa736939597891C1940CF0d28b82566F9390);\n        addressresolver_rebuildCaches_destinations_1_0[2] = MixinResolver(new_Exchanger_contract);\n        addressresolver_rebuildCaches_destinations_1_0[3] = MixinResolver(0xeAcaEd9581294b1b5cfb6B941d4B8B81B2005437);\n        addressresolver_rebuildCaches_destinations_1_0[4] = MixinResolver(new_Issuer_contract);\n        addressresolver_rebuildCaches_destinations_1_0[5] = MixinResolver(new_SynthetixBridgeToOptimism_contract);\n        addressresolver_rebuildCaches_destinations_1_0[6] = MixinResolver(0xC1AAE9d18bBe386B102435a8632C8063d31e747C);\n        addressresolver_rebuildCaches_destinations_1_0[7] = MixinResolver(0x067e398605E84F2D0aEEC1806e62768C5110DCc6);\n        addressresolver_rebuildCaches_destinations_1_0[8] = MixinResolver(0x5c8344bcdC38F1aB5EB5C1d4a35DdEeA522B5DfA);\n        addressresolver_rebuildCaches_destinations_1_0[9] = MixinResolver(0xaa03aB31b55DceEeF845C8d17890CC61cD98eD04);\n        addressresolver_rebuildCaches_destinations_1_0[10] = MixinResolver(0x1F2c3a1046c32729862fcB038369696e3273a516);\n        addressresolver_rebuildCaches_destinations_1_0[11] = MixinResolver(0x7C22547779c8aa41bAE79E03E8383a0BefBCecf0);\n        addressresolver_rebuildCaches_destinations_1_0[12] = MixinResolver(new_ExchangeRates_contract);\n        addressresolver_rebuildCaches_destinations_1_0[13] = MixinResolver(new_SystemSettings_contract);\n        addressresolver_rebuildCaches_destinations_1_0[14] = MixinResolver(0xDA4eF8520b1A57D7d63f1E249606D1A459698876);\n        addressresolver_rebuildCaches_destinations_1_0[15] = MixinResolver(0x62922670313bf6b41C580143d1f6C173C5C20019);\n        addressresolver_rebuildCaches_destinations_1_0[16] = MixinResolver(new_Synthetix_contract);\n        addressresolver_rebuildCaches_destinations_1_0[17] = MixinResolver(0x3B2f389AeE480238A49E3A9985cd6815370712eB);\n        addressresolver_rebuildCaches_destinations_1_0[18] = MixinResolver(0x7df9b3f8f1C011D8BD707430e97E747479DD532a);\n        addressresolver_rebuildCaches_destinations_1_0[19] = MixinResolver(0x1b06a00Df0B27E7871E753720D4917a7D1aac68b);\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_1_0);\n    }\n\n    function addressresolver_rebuildCaches_2() internal {\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_2_0 = new MixinResolver[](15);\n        addressresolver_rebuildCaches_destinations_2_0[0] = MixinResolver(0xB82f11f3168Ece7D56fe6a5679567948090de7C5);\n        addressresolver_rebuildCaches_destinations_2_0[1] = MixinResolver(0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C);\n        addressresolver_rebuildCaches_destinations_2_0[2] = MixinResolver(0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf);\n        addressresolver_rebuildCaches_destinations_2_0[3] = MixinResolver(0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d);\n        addressresolver_rebuildCaches_destinations_2_0[4] = MixinResolver(0x527637bE27640d6C3e751d24DC67129A6d13E11C);\n        addressresolver_rebuildCaches_destinations_2_0[5] = MixinResolver(0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6);\n        addressresolver_rebuildCaches_destinations_2_0[6] = MixinResolver(0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6);\n        addressresolver_rebuildCaches_destinations_2_0[7] = MixinResolver(0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6);\n        addressresolver_rebuildCaches_destinations_2_0[8] = MixinResolver(0xB34F4d7c207D8979D05EDb0F63f174764Bd67825);\n        addressresolver_rebuildCaches_destinations_2_0[9] = MixinResolver(0x95aE43E5E96314E4afffcf19D9419111cd11169e);\n        addressresolver_rebuildCaches_destinations_2_0[10] = MixinResolver(0x27b45A4208b87A899009f45888139882477Acea5);\n        addressresolver_rebuildCaches_destinations_2_0[11] = MixinResolver(0x6DF798ec713b33BE823b917F27820f2aA0cf7662);\n        addressresolver_rebuildCaches_destinations_2_0[12] = MixinResolver(0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124);\n        addressresolver_rebuildCaches_destinations_2_0[13] = MixinResolver(0x89FCb32F29e509cc42d0C8b6f058C993013A843F);\n        addressresolver_rebuildCaches_destinations_2_0[14] = MixinResolver(0xe533139Af961c9747356D947838c98451015e234);\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_2_0);\n    }\n\n    function issuer_addSynths_44() internal {\n        ISynth[] memory issuer_addSynths_synthsToAdd_44_0 = new ISynth[](15);\n        issuer_addSynths_synthsToAdd_44_0[0] = ISynth(0x7df9b3f8f1C011D8BD707430e97E747479DD532a);\n        issuer_addSynths_synthsToAdd_44_0[1] = ISynth(0x1b06a00Df0B27E7871E753720D4917a7D1aac68b);\n        issuer_addSynths_synthsToAdd_44_0[2] = ISynth(0xB82f11f3168Ece7D56fe6a5679567948090de7C5);\n        issuer_addSynths_synthsToAdd_44_0[3] = ISynth(0xC4546bDd93cDAADA6994e84Fb6F2722C620B019C);\n        issuer_addSynths_synthsToAdd_44_0[4] = ISynth(0xAE7A2C1e326e59f2dB2132652115a59E8Adb5eBf);\n        issuer_addSynths_synthsToAdd_44_0[5] = ISynth(0xCC83a57B080a4c7C86F0bB892Bc180C8C7F8791d);\n        issuer_addSynths_synthsToAdd_44_0[6] = ISynth(0x527637bE27640d6C3e751d24DC67129A6d13E11C);\n        issuer_addSynths_synthsToAdd_44_0[7] = ISynth(0x18FcC34bdEaaF9E3b69D2500343527c0c995b1d6);\n        issuer_addSynths_synthsToAdd_44_0[8] = ISynth(0x4FB63c954Ef07EC74335Bb53835026C75DD91dC6);\n        issuer_addSynths_synthsToAdd_44_0[9] = ISynth(0xe08518bA3d2467F7cA50eFE68AA00C5f78D4f3D6);\n        issuer_addSynths_synthsToAdd_44_0[10] = ISynth(0xB34F4d7c207D8979D05EDb0F63f174764Bd67825);\n        issuer_addSynths_synthsToAdd_44_0[11] = ISynth(0x95aE43E5E96314E4afffcf19D9419111cd11169e);\n        issuer_addSynths_synthsToAdd_44_0[12] = ISynth(0x27b45A4208b87A899009f45888139882477Acea5);\n        issuer_addSynths_synthsToAdd_44_0[13] = ISynth(0x6DF798ec713b33BE823b917F27820f2aA0cf7662);\n        issuer_addSynths_synthsToAdd_44_0[14] = ISynth(0xf533aeEe48f0e04E30c2F6A1f19FbB675469a124);\n        issuer_i.addSynths(issuer_addSynths_synthsToAdd_44_0);\n    }\n}\n\n    ", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"OWNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressresolver_i\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractsRequiringOwnership\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangerates_i\",\"outputs\":[{\"internalType\":\"contract ExchangeRatesWithDexPricing\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangestate_i\",\"outputs\":[{\"internalType\":\"contract ExchangeState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuer_i\",\"outputs\":[{\"internalType\":\"contract Issuer\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_ExchangeRates_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_Exchanger_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_Issuer_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthetixBridgeToOptimism_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_Synthetix_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SystemSettings_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysynthetix_i\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"forContract\",\"type\":\"address\"}],\"name\":\"returnOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardescrow_i\",\"outputs\":[{\"internalType\":\"contract RewardEscrow\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsdistribution_i\",\"outputs\":[{\"internalType\":\"contract RewardsDistribution\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemsettings_i\",\"outputs\":[{\"internalType\":\"contract SystemSettings\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemstatus_i\",\"outputs\":[{\"internalType\":\"contract SystemStatus\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesynthetix_i\",\"outputs\":[{\"internalType\":\"contract LegacyTokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Migration_Mirach", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}