{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.23;\r\n\r\ninterface IERC721 {\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n}\r\n\r\ninterface IERC1155 {\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, uint256 amount, bytes data) external;\r\n}\r\n\r\n/// @title MerkleValidator enables matching trait-based and collection-based orders for ERC721 and ERC1155 tokens.\r\n/// @author 0age\r\n/// @dev This contract is intended to be called during atomicMatch_ via DELEGATECALL.\r\ncontract MerkleValidator {\r\n\r\n    /// @dev Match an ERC721 order, ensuring that the supplied proof demonstrates inclusion of the tokenId in the associated merkle root.\r\n    /// @param from The account to transfer the ERC721 token from \u2014 this token must first be approved on the seller's AuthenticatedProxy contract.\r\n    /// @param to The account to transfer the ERC721 token to.\r\n    /// @param token The ERC721 token to transfer.\r\n    /// @param tokenId The ERC721 tokenId to transfer.\r\n    /// @param root A merkle root derived from each valid tokenId \u2014 set to 0 to indicate a collection-level or tokenId-specific order.\r\n    /// @param proof A proof that the supplied tokenId is contained within the associated merkle root. Must be length 0 if root is not set.\r\n    /// @return A boolean indicating a successful match and transfer.\r\n    function matchERC721UsingCriteria(\r\n        address from,\r\n        address to,\r\n        IERC721 token,\r\n        uint256 tokenId,\r\n        bytes32 root,\r\n        bytes32[] proof\r\n    ) external returns (bool) {\r\n    \t// Proof verification is performed when there's a non-zero root.\r\n    \tif (root != bytes32(0)) {\r\n    \t\t_verifyProof(tokenId, root, proof);\r\n    \t} else if (proof.length != 0) {\r\n    \t\t// A root of zero should never have a proof.\r\n    \t\trevert(\"UnnecessaryProof\");\r\n    \t}\r\n\r\n    \t// Transfer the token.\r\n        token.transferFrom(from, to, tokenId);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Match an ERC721 order using `safeTransferFrom`, ensuring that the supplied proof demonstrates inclusion of the tokenId in the associated merkle root.\r\n    /// @param from The account to transfer the ERC721 token from \u2014 this token must first be approved on the seller's AuthenticatedProxy contract.\r\n    /// @param to The account to transfer the ERC721 token to.\r\n    /// @param token The ERC721 token to transfer.\r\n    /// @param tokenId The ERC721 tokenId to transfer.\r\n    /// @param root A merkle root derived from each valid tokenId \u2014 set to 0 to indicate a collection-level or tokenId-specific order.\r\n    /// @param proof A proof that the supplied tokenId is contained within the associated merkle root. Must be length 0 if root is not set.\r\n    /// @return A boolean indicating a successful match and transfer.\r\n    function matchERC721WithSafeTransferUsingCriteria(\r\n        address from,\r\n        address to,\r\n        IERC721 token,\r\n        uint256 tokenId,\r\n        bytes32 root,\r\n        bytes32[] proof\r\n    ) external returns (bool) {\r\n        // Proof verification is performed when there's a non-zero root.\r\n        if (root != bytes32(0)) {\r\n            _verifyProof(tokenId, root, proof);\r\n        } else if (proof.length != 0) {\r\n            // A root of zero should never have a proof.\r\n            revert(\"UnnecessaryProof\");\r\n        }\r\n\r\n        // Transfer the token.\r\n        token.safeTransferFrom(from, to, tokenId);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Match an ERC1155 order, ensuring that the supplied proof demonstrates inclusion of the tokenId in the associated merkle root.\r\n    /// @param from The account to transfer the ERC1155 token from \u2014 this token must first be approved on the seller's AuthenticatedProxy contract.\r\n    /// @param to The account to transfer the ERC1155 token to.\r\n    /// @param token The ERC1155 token to transfer.\r\n    /// @param tokenId The ERC1155 tokenId to transfer.\r\n    /// @param amount The amount of ERC1155 tokens with the given tokenId to transfer.\r\n    /// @param root A merkle root derived from each valid tokenId \u2014 set to 0 to indicate a collection-level or tokenId-specific order.\r\n    /// @param proof A proof that the supplied tokenId is contained within the associated merkle root. Must be length 0 if root is not set.\r\n    /// @return A boolean indicating a successful match and transfer.\r\n    function matchERC1155UsingCriteria(\r\n        address from,\r\n        address to,\r\n        IERC1155 token,\r\n        uint256 tokenId,\r\n        uint256 amount,\r\n        bytes32 root,\r\n        bytes32[] proof\r\n    ) external returns (bool) {\r\n        // Proof verification is performed when there's a non-zero root.\r\n        if (root != bytes32(0)) {\r\n            _verifyProof(tokenId, root, proof);\r\n        } else if (proof.length != 0) {\r\n            // A root of zero should never have a proof.\r\n            revert(\"UnnecessaryProof\");\r\n        }\r\n\r\n        // Transfer the token.\r\n        token.safeTransferFrom(from, to, tokenId, amount, \"\");\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Ensure that a given tokenId is contained within a supplied merkle root using a supplied proof.\r\n    /// @param leaf The tokenId.\r\n    /// @param root A merkle root derived from each valid tokenId.\r\n    /// @param proof A proof that the supplied tokenId is contained within the associated merkle root.\r\n    function _verifyProof(\r\n        uint256 leaf,\r\n        bytes32 root,\r\n        bytes32[] memory proof\r\n    ) private pure {\r\n        bytes32 computedHash = bytes32(leaf);\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = _efficientHash(computedHash, proofElement);\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = _efficientHash(proofElement, computedHash);\r\n            }\r\n        }\r\n        if (computedHash != root) {\r\n            revert(\"InvalidProof\");\r\n        }\r\n    }\r\n\r\n    /// @dev Efficiently hash two bytes32 elements using memory scratch space.\r\n    /// @param a The first element included in the hash.\r\n    /// @param b The second element included in the hash.\r\n    /// @return value The resultant hash of the two bytes32 elements.\r\n    function _efficientHash(\r\n        bytes32 a,\r\n        bytes32 b\r\n    ) private pure returns (bytes32 value) {\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"root\",\"type\":\"bytes32\"},{\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"matchERC1155UsingCriteria\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"root\",\"type\":\"bytes32\"},{\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"matchERC721WithSafeTransferUsingCriteria\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"root\",\"type\":\"bytes32\"},{\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"matchERC721UsingCriteria\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MerkleValidator", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://89e6cfc2d51cd09144702b37b3739a8e0b47780b658a46002322768dc6252759"}]}