{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.9;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastvalue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastvalue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        return _values(set._inner);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\ninterface IMerge {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function massOf(uint256 tokenId) external view returns (uint256);\r\n    function tokenOf(address account) external view returns (uint256);\r\n    function getValueOf(uint256 tokenId) external view returns (uint256);\r\n    function decodeClass(uint256 value) external view returns (uint256);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function isWhitelisted(address account) external view returns (bool);\r\n    function isBlacklisted(address account) external view returns (bool);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\ninterface IERC20Mintable {\r\n    function mint(address to, uint256 amount) external;\r\n}\r\n\r\ninterface IWalletProxyManager {\r\n    function indexToWallet(uint256 class, uint256 index) external view returns (address);\r\n    function currentIndex(uint256 class) external view returns (uint256);\r\n}\r\n\r\ninterface IWalletProxyFactory {\r\n    function createWallet(uint256 class) external returns (address);\r\n}\r\n\r\ncontract Router is Ownable {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    /**\r\n     * @dev Emitted when `account` contributes `tokenId` with `mass` to DAO.\r\n     */\r\n    event Contribute(address indexed account, address indexed wallet, uint256 tokenId, uint256 class, uint256 weight);\r\n\r\n    uint256 public totalWeight;  // The cumulative weight of contributed NFTs\r\n\r\n    address public merge;  // The Merge contract\r\n\r\n    address public gToken;  // Governance token\r\n\r\n    address public manager;  // Wallet proxy manager\r\n\r\n    address public factory;  // factory contract address\r\n\r\n    address public contender;  // AlphaMass contender wallet, only tier 1 NFTs are sent to this AlphaMass wallet\r\n\r\n    address public red;  // red wallet for tier 4\r\n\r\n    address public yellow;  // yellow wallet for tier 3\r\n\r\n    address public blue;  // blue wallet for tier 2\r\n\r\n    uint256 public constant WEIGHT_MULTIPLIER = 10_000 * 1e9;  // a multiplier to a weight\r\n\r\n    uint256 public BONUS_MULTIPLIER;  // a bonus multiplier in percentage\r\n\r\n    uint256 public cap;  // The soft cap for a wallet of a certain classId\r\n\r\n    bool public isEnded; // a bool indicator on whether the game has ended.\r\n\r\n    mapping(address => mapping(uint256 => uint256)) public weights;  // weights of each contributor by class\r\n\r\n    mapping(address => uint256[]) public contributedClasses;  // Contributed classes\r\n\r\n    mapping(uint256 => uint256) public contributionsOfEachClass;  // num of contributions for each class\r\n\r\n    mapping(address => bool) public specialWallets;  // DAO, contender, blue, red, yellow are all special wallets\r\n\r\n    EnumerableSet.AddressSet contributors;  // Contributors to this DAO\r\n\r\n    /**\r\n     * @param merge_ address contract address of merge\r\n     * @param gToken_ address contract address of governance token\r\n     * @param manager_ address contract address for wallet manager\r\n     * @param factory_ address contract address for wallet factory\r\n     * @param contender_ address AlphaMass Contender wallet\r\n     * @param blue_ address wallet for tier blue\r\n     * @param yellow_ address wallet for tier yellow\r\n     * @param red_ address wallet for tier red\r\n     */\r\n    constructor(\r\n        address merge_,\r\n        address gToken_,\r\n        address manager_,\r\n        address factory_,\r\n        address contender_,\r\n        address blue_,\r\n        address yellow_,\r\n        address red_)\r\n    {\r\n        if (merge_ == address(0) ||\r\n            gToken_ == address(0) ||\r\n            manager_ == address(0) ||\r\n            factory_ == address(0) ||\r\n            contender_ == address(0) ||\r\n            blue_ == address(0) ||\r\n            yellow_ == address(0) ||\r\n            red_ == address(0)) revert(\"Invalid address\");\r\n\r\n        cap = 50;  // soft cap\r\n        BONUS_MULTIPLIER = 120;\r\n\r\n        merge = merge_;\r\n        gToken = gToken_;\r\n        manager = manager_;\r\n        factory = factory_;\r\n        contender = contender_;\r\n        blue = blue_;\r\n        yellow = yellow_;\r\n        red = red_;\r\n\r\n        specialWallets[contender] = true;\r\n        specialWallets[blue] = true;\r\n        specialWallets[yellow] = true;\r\n        specialWallets[red] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Make a contribution with the nft in the caller's wallet.\r\n     */\r\n    function contribute() external {\r\n        require(!isEnded, \"Already ended\");\r\n        address account = _msgSender();\r\n        require(!_validateAccount(account), \"Invalid caller\");\r\n\r\n        _contribute(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Toggle the special status of a wallet between true and false.\r\n     */\r\n    function toggleSpecialWalletStatus(address wallet) external onlyOwner {\r\n        specialWallets[wallet] = !specialWallets[wallet];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer NFTs if there is any in this contract to address `to`.\r\n     */\r\n    function transfer(address to) external onlyOwner {\r\n        require(isEnded, \"Not ended\");\r\n        uint256 tokenId = _tokenOf(address(this));\r\n        require(tokenId != 0, \"No token to be transferred in this contract\");\r\n        require(specialWallets[to], \"Must transfer to a special wallet\");\r\n\r\n        _transfer(address(this), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Required by {IERC721-safeTransferFrom}.\r\n     */\r\n    function onERC721Received(address, address, uint256, bytes memory) external pure returns (bytes4) {\r\n        return IERC721Receiver.onERC721Received.selector;\r\n    }\r\n\r\n    /**\r\n     * @dev End the game of competing in Pak Merge.\r\n     */\r\n    function endGame() external onlyOwner {\r\n        require(!isEnded, \"Already ended\");\r\n        isEnded = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the soft cap for each wallet.\r\n     */\r\n    function setCap(uint256 cap_) external onlyOwner {\r\n        cap = cap_;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the wallet `contender_` for AlphaMass contentder.\r\n     */\r\n    function setContenderWallet(address contender_) external onlyOwner {\r\n        contender = contender_;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the wallet `red_` for red tier.\r\n     */\r\n    function setRed(address red_) external onlyOwner {\r\n        red = red_;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the wallet `yellow_` for yellow tier.\r\n     */\r\n    function setYellow(address yellow_) external onlyOwner {\r\n        yellow = yellow_;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the wallet `blue_` for blue tier.\r\n     */\r\n    function setBlue(address blue_) external onlyOwner {\r\n        blue = blue_;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the `multiplier_` for BONUS_MULTIPLIER.\r\n     */\r\n    function setBonusMultiplier(uint256 multiplier_) external onlyOwner {\r\n        if (multiplier_ < 100 || multiplier_ >= 200) revert(\"Out of range\");\r\n\r\n        BONUS_MULTIPLIER = multiplier_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns if a given `account` is a contributor.\r\n     */\r\n    function isContributor(address account) external view returns (bool) {\r\n        return contributors.contains(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current active `tokenId` for a given `class`.\r\n     */\r\n    function getTokenIdForClass(uint256 class) external view returns (uint256) {\r\n        return _tokenOf(_getWalletByClass(class));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns all `tokenId`s for a given `class`.\r\n     */\r\n    function getTokenIdsForClass(uint256 class) external view returns (uint256[] memory) {\r\n        uint256 index = _getClassIndex(class);\r\n        uint256[] memory tokenIds = new uint256[](index+1);\r\n        if (index == 0) {\r\n            tokenIds[0] = _tokenOf(_getWalletByClass(class));\r\n            return tokenIds;\r\n        } else {\r\n            for (uint256 i = 0; i < index+1; i++) {\r\n                tokenIds[i] = _tokenOf(_getWalletByIndex(class, i));\r\n            }\r\n            return tokenIds;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the mass for `tokenId`.\r\n     */\r\n    function massOf(uint256 tokenId) external view returns (uint256) {\r\n        return _massOf(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of contributors to this contract.\r\n     */\r\n    function getNumOfContributors() external view returns (uint256) {\r\n        return contributors.length();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total weight of `account` across all classes.\r\n     */\r\n    function getWeightForAccount(address account) external view returns (uint256 weight) {\r\n        uint256[] memory classes = contributedClasses[account];\r\n        for (uint256 i = 0; i < classes.length; i++) {\r\n            weight += weights[account][classes[i]];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Execute the logic of making a contribution by `account`.\r\n     */\r\n    function _contribute(address account) private {\r\n        uint256 tokenId = _tokenOf(account);\r\n        uint256 weight = _massOf(tokenId);\r\n        (address targetWallet, uint256 class) = _getTargetWallet(tokenId);\r\n\r\n        _transfer(account, targetWallet, tokenId);\r\n        _mint(account, weight);\r\n        _updateInfo(account, class, weight);\r\n\r\n        emit Contribute(account, targetWallet, tokenId, class, weight);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the wallet address for given `class` and `index`.\r\n     */\r\n    function _getWalletByIndex(uint256 class, uint256 index) private view returns (address) {\r\n        return IWalletProxyManager(manager).indexToWallet(class, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the currently active wallet address by `class`.\r\n     */\r\n    function _getClassIndex(uint256 class) private view returns (uint256) {\r\n        return IWalletProxyManager(manager).currentIndex(class);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the target wallet address by `class` and `tokenId`.\r\n     */\r\n    function _getTargetWallet(uint256 tokenId) private returns (address wallet, uint256 class) {\r\n        uint256 tier = _tierOf(tokenId);\r\n        class = _classOf(tokenId);\r\n\r\n        if (tier == 4) {\r\n            wallet = red;\r\n        } else if (tier == 3) {\r\n            wallet = yellow;\r\n        } else if (tier == 2) {\r\n            wallet = blue;\r\n        } else if (tier == 1) {\r\n            if (_massOf(tokenId) >= cap) {\r\n                wallet = contender;\r\n            } else {\r\n                wallet = _getWalletByClass(class);\r\n\r\n                // No wallet for this class has been created yet.\r\n                if (wallet == address(0)) {\r\n                    wallet = _createWalletByClass(class);\r\n                    require(wallet == _getWalletByClass(class), \"Mismatch\");\r\n                } else {\r\n                    uint256 _tokenId = _tokenOf(wallet);\r\n                    if (_tokenId != 0) {\r\n                        if (_massOf(_tokenId) >= cap) {  // Current wallet has reached the cap\r\n                            wallet = _createWalletByClass(class);\r\n                            require(wallet == _getWalletByClass(class), \"Mismatch\");\r\n                        } else {\r\n                            if (_classOf(_tokenId) != class) {\r\n                                wallet = _createWalletByClass(class);\r\n                                require(wallet == _getWalletByClass(class), \"Mismatch\");\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a new wallet for a given `class`.\r\n     */\r\n    function _createWalletByClass(uint256 class) private returns (address) {\r\n        return IWalletProxyFactory(factory).createWallet(class);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the currently active wallet address by `class`.\r\n     */\r\n    function _getWalletByClass(uint256 class) private view returns (address) {\r\n        uint256 index = _getClassIndex(class);\r\n        return IWalletProxyManager(manager).indexToWallet(class, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Mint governance tokens based on the weight of NFT the caller contributed\r\n     */\r\n    function _mint(address to, uint256 weight) private {\r\n        IERC20Mintable(gToken).mint(to, weight * WEIGHT_MULTIPLIER * BONUS_MULTIPLIER / 100);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer NFT with `tokenId` from address `from` to address `to`.\r\n     * Checking if address `to` is valid is built in the function safeTransferFrom.\r\n     */\r\n    function _transfer(address from, address to, uint256 tokenId) private {\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n        IMerge(merge).safeTransferFrom(from, to, tokenId);\r\n        _afterTokenTransfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev A hook function checking if the mass of the NFT in the `to` wallet\r\n     * has reached the soft cap before it is being transferred.\r\n     */\r\n    function _beforeTokenTransfer(address, address to, uint256) private view {\r\n        if (!specialWallets[to]) {\r\n            if (_tokenOf(to) != 0) {  // a non-existent token\r\n                require(_massOf(_tokenOf(to)) < cap, \"Exceeding cap\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev A hook function creates a new wallet with the same class to `tokenId`\r\n     * if the `to` wallet has reached the soft cap.\r\n     */\r\n    function _afterTokenTransfer(address, address to, uint256 tokenId) private {\r\n        if (!specialWallets[to]) {\r\n            if (_massOf(_tokenOf(to)) >= cap) {\r\n                _createWalletByClass(_classOf(tokenId));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Update info for `account` and `tokenId` with `weight`\r\n     */\r\n    function _updateInfo(address account, uint256 class, uint256 weight) private {\r\n        if (weights[account][class] == 0) {\r\n            contributors.add(account);\r\n            weights[account][class] = weight;\r\n            contributedClasses[account].push(class);\r\n        } else {\r\n            weights[account][class] += weight;\r\n        }\r\n\r\n        totalWeight += weight;\r\n        contributionsOfEachClass[class]++;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns if a given account is whitelisted or blacklisted, or does not\r\n     * have a Merge NFT.\r\n     */\r\n    function _validateAccount(address account) private view returns (bool) {\r\n        bool cond1 = IMerge(merge).isWhitelisted(account);\r\n        bool cond2 = IMerge(merge).isBlacklisted(account);\r\n        bool cond3 = _balanceOf(account) == 0;\r\n        return cond1 || cond2 || cond3;\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves the class/tier of token with `tokenId`.\r\n     */\r\n    function _tierOf(uint256 tokenId) private view returns (uint256) {\r\n        return IMerge(merge).decodeClass(_valueOf(tokenId));\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves the class of token with `tokenId`, i.e., the last two digits\r\n     * of `tokenId`.\r\n     */\r\n    function _classOf(uint256 tokenId) private pure returns (uint256) {\r\n        return tokenId % 100;\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves the value of token with `tokenId`.\r\n     */\r\n    function _valueOf(uint256 tokenId) private view returns (uint256) {\r\n        return IMerge(merge).getValueOf(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the `tokenId` held by `account`. Returns 0 if `account`\r\n     * does not have a token.\r\n     */\r\n    function _tokenOf(address account) private view returns (uint256) {\r\n        return IMerge(merge).tokenOf(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the `mass` of a token given `tokenId`.\r\n     */\r\n    function _massOf(uint256 tokenId) private view returns (uint256) {\r\n        return IMerge(merge).massOf(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the balance of an `account`, either 0 or 1.\r\n     */\r\n    function _balanceOf(address account) private view returns (uint256) {\r\n        return IMerge(merge).balanceOf(account);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"merge_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contender_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"blue_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"yellow_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"red_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"class\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"Contribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONUS_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WEIGHT_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blue\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contributedClasses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contributionsOfEachClass\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumOfContributors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"class\",\"type\":\"uint256\"}],\"name\":\"getTokenIdForClass\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"class\",\"type\":\"uint256\"}],\"name\":\"getTokenIdsForClass\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getWeightForAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isContributor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"massOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"red\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"blue_\",\"type\":\"address\"}],\"name\":\"setBlue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"multiplier_\",\"type\":\"uint256\"}],\"name\":\"setBonusMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cap_\",\"type\":\"uint256\"}],\"name\":\"setCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contender_\",\"type\":\"address\"}],\"name\":\"setContenderWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"red_\",\"type\":\"address\"}],\"name\":\"setRed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"yellow_\",\"type\":\"address\"}],\"name\":\"setYellow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"specialWallets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"toggleSpecialWalletStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"weights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yellow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Router", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c3f8a0f5841abff777d3eefa5047e8d413a1c9ab0000000000000000000000001e3974b1562c84c7de5462f1fc2dd2616b80a076000000000000000000000000d3570ff80a4d62e8c3c3384afe76157bbc18d4cb000000000000000000000000eaacaaacd693f1fef309368560d537208c31d784000000000000000000000000bea5efda12f246a25d81b3325e7d164fecdda2d500000000000000000000000078c4c7562f103726a365993a5fed595697f5acd60000000000000000000000005203b9222b7d9161299a6e4921c79e1ba6d0abcc0000000000000000000000005f2005ca9f7d3cf6f6d82b1764334b197e181230", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8533868b2c4a46aef94c1b81d2429b24eb0e3ea165a09e877899c7a9aced12a5"}]}