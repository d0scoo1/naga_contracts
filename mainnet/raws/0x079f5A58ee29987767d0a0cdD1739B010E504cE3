{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/testStakingSet_220613/TestUSDTStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\nimport \\\"./INftContract.sol\\\";\\r\\nimport \\\"./IRewardContract.sol\\\";\\r\\nimport \\\"./IUSDTStaking.sol\\\";\\r\\n\\r\\n/* \\r\\n    ERR-001 : You are not the owner of the token.\\r\\n    ERR-002 : You do not have rights to that token.\\r\\n    ERR-003 : Token already received.\\r\\n    ERR-004 : The billing period has expired.\\r\\n    ERR-005 : It's not the claim period yet.\\r\\n*/\\r\\ncontract TestUSDTStaking is Ownable, Pausable, IUSDTStaking {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    struct PlanStructure {\\r\\n        uint256 earn;    // \ud558\ub8e8\ub2f9 \ubcf4\uc0c1\\r\\n        uint256 duration;    // staking \uae30\uac04 (flexible\uc758 \uacbd\uc6b0 0)\\r\\n    }\\r\\n    struct StakingStructure {\\r\\n        uint256[] tokenIdArr;           // \uc801\uc6a9\ud560 tokenArr\\r\\n        uint256 planIndex;              // \uc801\uc6a9\ud560 planIndex\\r\\n        uint256 stakingStartTime;       // staking \uc2dc\uc791 \uc2dc\uac04\\r\\n        uint256 stakingExpiredTime;     // claim \uac00\ub2a5 \uc2dc\uac04\\r\\n        uint256 stakingClaimDueDate;    // \ubcf4\uc0c1\uc9c0\uae09 \ub9cc\ub8cc \uae30\uac04\\r\\n        bool claimStatus;               // \uc9c0\uae09 \uc644\ub8cc \uc720\ubb34 \uccb4\ud06c\\r\\n    }\\r\\n\\r\\n    uint8 public ERAN_DECIMAL;      // \ubcf4\uc0c1 earn decimal\\r\\n    uint8 public REWARD_DECIMAL;    // TAVA : 18, USDT : 6\\r\\n\\r\\n    uint256 totalStakingCnt = 0;\\r\\n    IRewardContract private rewardContract;\\r\\n    INftContract private NftContract;\\r\\n    mapping (uint256 => PlanStructure) private infoPlan;\\r\\n    mapping (address => StakingStructure[]) private infoUserStaking; // (account => (tokenid => StakingStructure))\\r\\n\\r\\n    // nft \uc18c\uc720\uc790 \ud655\uc778\\r\\n    modifier VerifyToken(uint256[] calldata _tokenIdArr) {\\r\\n        for (uint256 i = 0; i < _tokenIdArr.length; i++) {\\r\\n            require(NftContract.ownerOf(_tokenIdArr[i]) == _msgSender(), \\\"ERR-001\\\");\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // nft \uad8c\ud55c \uc2b9\uc778 \ud655\uc778\\r\\n    modifier VerifyTokenApproved(uint256[] calldata _tokenIdArr) {\\r\\n        for (uint256 i = 0; i < _tokenIdArr.length; i++) {\\r\\n            require(NftContract.isApprovedForAll(_msgSender(), address(this)), \\\"ERR-002\\\");\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor (address _RewardContract, address _NFTAddress, uint8 _REWARD_DECIMAL, uint8 _ERAN_DECIMAL) {\\r\\n        rewardContract = IRewardContract(_RewardContract);\\r\\n        NftContract = INftContract(_NFTAddress);\\r\\n        REWARD_DECIMAL = _REWARD_DECIMAL;\\r\\n        ERAN_DECIMAL = _ERAN_DECIMAL;\\r\\n    }\\r\\n\\r\\n    // plan \uc0dd\uc131, \uc218\uc815\\r\\n    function SetPlan(uint256 _planIndex, uint256 _earn, uint256 _duration) external override onlyOwner {\\r\\n        infoPlan[_planIndex].earn = _earn;\\r\\n        infoPlan[_planIndex].duration = _duration;\\r\\n        emit PlanCreated(_earn, _duration, _planIndex);\\r\\n    }\\r\\n\\r\\n    // plan \uc815\ubcf4 \uc870\ud68c\\r\\n    function GetInfoPlan(uint256 _planIndex) external override view onlyOwner returns(uint256, uint256){\\r\\n        return (infoPlan[_planIndex].earn, infoPlan[_planIndex].duration);\\r\\n    }\\r\\n\\r\\n    // staking \uc2dc\uc791\\r\\n    function SetInfoStaking (uint256[] calldata _tokenIdArr, uint256 _planIndex) external override whenNotPaused VerifyToken(_tokenIdArr) VerifyTokenApproved(_tokenIdArr) {\\r\\n        uint256 _stakingStartTime = block.timestamp;\\r\\n        uint256 _stakingExpiredTime = _stakingStartTime + infoPlan[_planIndex].duration * 1 seconds;\\r\\n        uint256 _stakingClaimDueDate = _stakingExpiredTime + 365 days;\\r\\n        infoUserStaking[_msgSender()].push(StakingStructure(_tokenIdArr, _planIndex, _stakingStartTime, _stakingExpiredTime, _stakingClaimDueDate, false));\\r\\n        for (uint256 i = 0; i < _tokenIdArr.length; i++) {\\r\\n            NftContract.transferFrom(_msgSender(), address(this), _tokenIdArr[i]);\\r\\n        }\\r\\n        totalStakingCnt++;\\r\\n        emit Staked(_msgSender());\\r\\n    }\\r\\n\\r\\n    // staking \uc815\ubcf4 \uc870\ud68c\\r\\n    function GetInfoStaking(address _account, uint256 _stakingIndex) external override view returns (uint256 _earn, uint256 _duration, uint256 _startTime, uint256 _endTime){\\r\\n        uint256 PlanIndex = infoUserStaking[_account][_stakingIndex].planIndex;\\r\\n        _startTime = infoUserStaking[_account][_stakingIndex].stakingStartTime;\\r\\n        _endTime = infoUserStaking[_account][_stakingIndex].stakingExpiredTime;\\r\\n        _earn = infoPlan[PlanIndex].earn;\\r\\n        _duration = infoPlan[PlanIndex].duration;          \\r\\n    }\\r\\n\\r\\n    // \ucd1d staking \ub41c \uc218\ub7c9 \ud45c\uae30\\r\\n    function GetStakingOfAddressLength(address _account) public view returns(uint256){\\r\\n        return infoUserStaking[_account].length;\\r\\n    }\\r\\n\\r\\n    // \ubcf4\uc0c1\ubc1b\uc744 contract \uc218\uc815\\r\\n    function SetRewardContract(address _newRewardContract) external onlyOwner {\\r\\n        rewardContract = IRewardContract(_newRewardContract);\\r\\n    }\\r\\n\\r\\n    // \uc5f0\uacb0\ud560 Nft contract \uc218\uc815\\r\\n    function SetNftContract(address _newNftContract) external onlyOwner {\\r\\n        NftContract = INftContract(_newNftContract);\\r\\n    }\\r\\n\\r\\n    // \ubcf4\uc0c1 \uc9c0\uae09\\r\\n    function Claim(uint256 _stakingIndex) external override whenNotPaused {\\r\\n        // \ubcf4\uc0c1 \uc9c0\uae09 \ub9cc\ub8cc \uae30\uac04 \ud655\uc778\\r\\n        StakingStructure memory _infoUserStaking = infoUserStaking[_msgSender()][_stakingIndex];\\r\\n\\r\\n        require(!_infoUserStaking.claimStatus, \\\"ERR-003\\\");\\r\\n        require(infoUserStaking[_msgSender()][_stakingIndex].stakingClaimDueDate > block.timestamp, \\\"ERR-004\\\"); \\r\\n        require(block.timestamp > infoUserStaking[_msgSender()][_stakingIndex].stakingExpiredTime, \\\"ERR-005\\\"); \\r\\n\\r\\n        uint256[] memory _tokenIdArr = _infoUserStaking.tokenIdArr;\\r\\n        uint256 planIndex = _infoUserStaking.planIndex;\\r\\n\\r\\n        // \ubcf4\uc0c1 \uc9c0\uae09 & nft \uc804\ub2ec\\r\\n        for (uint256 i = 0; i < _tokenIdArr.length; i++) {\\r\\n            uint256 earn = infoPlan[planIndex].earn;\\r\\n            uint256 duration = infoPlan[planIndex].duration;\\r\\n            NftContract.transferFrom(address(this), _msgSender(), _tokenIdArr[i]);\\r\\n            rewardContract.transferFrom(address(this), _msgSender(), ((earn.mul(duration)).div(10**ERAN_DECIMAL)).mul(10**REWARD_DECIMAL) );\\r\\n        }\\r\\n        infoUserStaking[_msgSender()][_stakingIndex].claimStatus = true;\\r\\n        totalStakingCnt--;\\r\\n        emit Claimed(_msgSender());\\r\\n    }\\r\\n    \\r\\n    // contract \ub0b4\ubd80\uc758 ERC20 token \uc804\ub7c9 \ud68c\uc218\\r\\n    function RetrieveToken() external override onlyOwner returns (uint256){\\r\\n        rewardContract.transferFrom(address(this), _msgSender(), ERC20TokenBalance());\\r\\n        return ERC20TokenBalance();\\r\\n    }\\r\\n\\r\\n    // contract \ub0b4\ubd80\uc758 ERC20 token \ud68c\uc218\\r\\n    function OwnerClaim (uint256 amount) external onlyOwner {\\r\\n        rewardContract.transfer(address(this), amount);\\r\\n    }\\r\\n\\r\\n    // contract \ub0b4\ubd80\uc758 ERC20 \uc794\uc561 \ud45c\uc2dc\\r\\n    function ERC20TokenBalance() view override public returns (uint256){\\r\\n        return rewardContract.balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    // \ubcf4\uc0c1\uc9c0\uae09 \uad8c\ud55c \ubd80\uc5ec\\r\\n    function ClaimApprove() public {\\r\\n        rewardContract.approve(address(this), ERC20TokenBalance());\\r\\n    }\\r\\n\\r\\n    // earn decimal \uc218\uc815\\r\\n    function SetEarnDecimal(uint8 _ERAN_DECIMAL) external onlyOwner {\\r\\n        ERAN_DECIMAL = _ERAN_DECIMAL;\\r\\n    }\\r\\n\\r\\n    // reward decimal \uc218\uc815\\r\\n    function SetRewardDecimal(uint8 _REWARD_DECIMAL) external onlyOwner {\\r\\n        REWARD_DECIMAL = _REWARD_DECIMAL;\\r\\n    }\\r\\n\\r\\n    // \uc2a4\ud14c\uc774\ud0b9, \ubcf4\uc0c1\uc9c0\uae09 \uae30\ub2a5 \uc7a0\uae08\\r\\n    function Pause() external onlyOwner {\\r\\n        super._pause();\\r\\n    }\\r\\n\\r\\n    // \uc2a4\ud14c\uc774\ud0b9, \ubcf4\uc0c1\uc9c0\uae09 \uae30\ub2a5 \uc7a0\uae08 \ud574\uc81c\\r\\n    function Unpause() external onlyOwner {\\r\\n        super._unpause();\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/testStakingSet_220613/INftContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.9;\\r\\n\\r\\ninterface INftContract {\\r\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\\r\\n    function ownerOf(uint256 _tokenId) external view returns (address _owner);\\r\\n    function getApproved(uint256 _tokenId) external returns (address _account);\\r\\n    function approve(address _approved, uint256 _tokenId) external returns (address _account);\\r\\n    function isApprovedForAll(address owner, address operator) external returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/testStakingSet_220613/IRewardContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.9;\\r\\n\\r\\ninterface IRewardContract {\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/testStakingSet_220613/IUSDTStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.9;\\r\\n\\r\\ninterface IUSDTStaking {\\r\\n    function SetPlan(uint256 _planIndex, uint256 _earn, uint256 _duration) external;\\r\\n    function GetInfoPlan(uint256 _planIndex) view external returns(uint256, uint256);\\r\\n    function SetInfoStaking (uint256[] calldata _tokenIdArr, uint256 _planIndex) external;\\r\\n    function GetInfoStaking(address _account, uint256 _tokenId) view external returns (uint256, uint256, uint256, uint256);\\r\\n    function Claim(uint256 _stakingIndex) external;\\r\\n    function RetrieveToken() external returns (uint256);\\r\\n    function ERC20TokenBalance() external returns (uint256);\\r\\n\\r\\n    event PlanCreated(uint256 _earn, uint256 _duration, uint256 _planIndex );\\r\\n    event Staked(address account);\\r\\n    event Claimed(address account);\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_RewardContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_NFTAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_REWARD_DECIMAL\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_ERAN_DECIMAL\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_earn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_planIndex\",\"type\":\"uint256\"}],\"name\":\"PlanCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakingIndex\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ClaimApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERAN_DECIMAL\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERC20TokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_planIndex\",\"type\":\"uint256\"}],\"name\":\"GetInfoPlan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakingIndex\",\"type\":\"uint256\"}],\"name\":\"GetInfoStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_earn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"GetStakingOfAddressLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OwnerClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD_DECIMAL\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RetrieveToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_ERAN_DECIMAL\",\"type\":\"uint8\"}],\"name\":\"SetEarnDecimal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIdArr\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_planIndex\",\"type\":\"uint256\"}],\"name\":\"SetInfoStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newNftContract\",\"type\":\"address\"}],\"name\":\"SetNftContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_planIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_earn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"SetPlan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRewardContract\",\"type\":\"address\"}],\"name\":\"SetRewardContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_REWARD_DECIMAL\",\"type\":\"uint8\"}],\"name\":\"SetRewardDecimal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TestUSDTStaking", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec700000000000000000000000082f371b47cc5b9cf23af60a9a31a9e7a6bef8a2d00000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000002", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}