{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\",\r\n          \"stackAllocation\": true\r\n        }\r\n      },\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Refinery.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\r\\nimport \\\"./interfaces/IERC1155TokenReceiver.sol\\\";\\r\\nimport \\\"./interfaces/IRefinery.sol\\\";\\r\\nimport \\\"./interfaces/IImperialGuild.sol\\\";\\r\\nimport \\\"./interfaces/IEON.sol\\\";\\r\\nimport \\\"./interfaces/IRAW.sol\\\";\\r\\n\\r\\ncontract Refinery is IRefinery, IERC1155TokenReceiver, Pausable {\\r\\n    struct UserInfo {\\r\\n        uint256 amount; // how many raw materials has this user added\\r\\n        uint256 refineEndBlock; // block your refining will be refined\\r\\n        uint256 lastClaimBlock; // block of your last claim\\r\\n    }\\r\\n\\r\\n    /* ERC1155 Refineries what they take in and what they output at what rate\\r\\n\\r\\n    struct RefineryInfo {\\r\\n        uint8 inputType; // raw input typeID\\r\\n        uint8 outputType; // refined resourse typeID\\r\\n        uint8 burnRate; // rate of input burn to refined per block\\r\\n        uint8 refineRate; // rate cut of raw to refined\\r\\n    }\\r\\n*/\\r\\n    uint256 public constant multiplier = 10**18;\\r\\n\\r\\n    // keys for each refinery in operation\\r\\n    RefineryInfo[] public refineryInfo;\\r\\n\\r\\n    address public auth;\\r\\n\\r\\n    // mapping(uint256 => Refinery) public RefineryInfo;\\r\\n    //maps refineries to users\\r\\n    mapping(uint256 => mapping(address => UserInfo)) public userRefines;\\r\\n\\r\\n    // address => allowedToCallFunctions\\r\\n    mapping(address => bool) private admins;\\r\\n\\r\\n    // Deposits to specified refinery\\r\\n    event DepositRaw(address indexed user, uint256 indexed rid, uint256 amount);\\r\\n\\r\\n    // Withdraws of unrefined\\r\\n    event WithdrawRaw(\\r\\n        address indexed user,\\r\\n        uint256 indexed rid,\\r\\n        uint256 amount\\r\\n    );\\r\\n    event EmergencyWithdrawRaw(\\r\\n        address indexed user,\\r\\n        uint256 indexed rid,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    IRAW public raw;\\r\\n\\r\\n    IEON public eon;\\r\\n\\r\\n    // emergency withdraw to allow removing unrefined without no care for the refined amount\\r\\n    bool public emergencyActivated;\\r\\n\\r\\n    constructor() {\\r\\n        _pause();\\r\\n        auth = msg.sender;\\r\\n        admins[msg.sender] = true;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == auth);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier requireContractsSet() {\\r\\n        require(\\r\\n            address(raw) != address(0) && address(eon) != address(0),\\r\\n            \\\"Contracts not set\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier noCheaters() {\\r\\n        uint256 size = 0;\\r\\n        address acc = msg.sender;\\r\\n        assembly {\\r\\n            size := extcodesize(acc)\\r\\n        }\\r\\n\\r\\n        require(\\r\\n            admins[msg.sender] || (msg.sender == tx.origin && size == 0),\\r\\n            \\\"you're trying to cheat!\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setContracts(address _raw, address _eon) external onlyOwner {\\r\\n        raw = IRAW(_raw);\\r\\n        eon = IEON(_eon);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n   * store information on the types of refineries\\r\\n   * available to this refinery\\r\\n   @param _inputType the RAW ERC1155 typeId resource\\r\\n   @param _outputType refined output typeId\\r\\n   * ATTENTION reserve outputType 0 for EON ERC20\\r\\n   * non 0 outputType points to RAW ERC1155\\r\\n   @param _burnRate inputType burn rate multiplied by block time dif\\r\\n   @param _refineRate outputType rate\\r\\n   */\\r\\n    function addRefinery(\\r\\n        uint8 _inputType,\\r\\n        uint8 _outputType,\\r\\n        uint8 _burnRate,\\r\\n        uint8 _refineRate\\r\\n    ) external onlyOwner {\\r\\n        refineryInfo.push(\\r\\n            RefineryInfo({\\r\\n                inputType: _inputType,\\r\\n                outputType: _outputType,\\r\\n                burnRate: _burnRate,\\r\\n                refineRate: _refineRate\\r\\n            })\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // update a refinery if needed\\r\\n    function updateRefineryInfo(\\r\\n        uint8 _rid,\\r\\n        uint8 _inputType,\\r\\n        uint8 _outputType,\\r\\n        uint8 _burnRate,\\r\\n        uint8 _refineRate\\r\\n    ) external onlyOwner {\\r\\n        refineryInfo[_rid].inputType = _inputType;\\r\\n        refineryInfo[_rid].outputType = _outputType;\\r\\n        refineryInfo[_rid].burnRate = _burnRate;\\r\\n        refineryInfo[_rid].refineRate = _refineRate;\\r\\n    }\\r\\n\\r\\n    function getRefineryInfo(uint256 _rid)\\r\\n        external\\r\\n        view\\r\\n        returns (RefineryInfo memory)\\r\\n    {\\r\\n        return refineryInfo[_rid];\\r\\n    }\\r\\n\\r\\n    // how long has the raw resource been refining for\\r\\n    function getTimeDif(uint256 _current, uint256 _lastClaim)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return (_current - _lastClaim);\\r\\n    }\\r\\n\\r\\n    // how much of the raw resource has been refined thus far\\r\\n    // and what is the expected output of the refined\\r\\n    function pendingRefine(uint256 _rid, address _user)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 refining, uint256 refined)\\r\\n    {\\r\\n        RefineryInfo memory refinery = refineryInfo[_rid];\\r\\n        UserInfo storage user = userRefines[_rid][_user];\\r\\n\\r\\n        if (block.number < user.refineEndBlock) {\\r\\n            uint256 timeDif = getTimeDif(block.number, user.lastClaimBlock);\\r\\n            uint256 burnAmt = refinery.burnRate * timeDif;\\r\\n            uint256 remaining = user.amount - burnAmt;\\r\\n            uint256 refineRateCut = (refinery.refineRate * burnAmt) / 100;\\r\\n            uint256 userRefined = (burnAmt - refineRateCut);\\r\\n            return (remaining, userRefined);\\r\\n        } else if (block.number > user.refineEndBlock) {\\r\\n            uint256 burnAmt = user.amount;\\r\\n            uint256 refineRateCut = (refinery.refineRate * burnAmt) / 100;\\r\\n            uint256 userRefined = (burnAmt - refineRateCut);\\r\\n            return (0, userRefined);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // updating a refinery to check amounts still refining and\\r\\n    // the output of the refined, this function is called any time\\r\\n    // a deposit or claim is made by the user\\r\\n    function updateRefined(\\r\\n        uint256 _rid,\\r\\n        uint256 _amount,\\r\\n        address refiner\\r\\n    ) private returns (uint256 burn, uint256 refined) {\\r\\n        RefineryInfo memory refinery = refineryInfo[_rid];\\r\\n        UserInfo storage user = userRefines[_rid][refiner];\\r\\n        if (block.number < user.refineEndBlock) {\\r\\n            uint256 timeDif = getTimeDif(block.number, user.lastClaimBlock);\\r\\n            uint256 burnAmt = refinery.burnRate * timeDif;\\r\\n            uint256 refineRateCut = (refinery.refineRate * burnAmt) / 100;\\r\\n            uint256 refinedAmt = (burnAmt - refineRateCut);\\r\\n            uint256 updatedRefining = (user.amount - burnAmt) + _amount;\\r\\n            user.lastClaimBlock = block.number;\\r\\n            user.refineEndBlock =\\r\\n                (updatedRefining / refinery.burnRate) +\\r\\n                block.number;\\r\\n            user.amount = updatedRefining;\\r\\n            return (burnAmt, refinedAmt);\\r\\n        } else if (block.number > user.refineEndBlock && user.amount != 0) {\\r\\n            uint256 burnAmt = user.amount;\\r\\n            uint256 refineRateCut = ((refinery.refineRate * burnAmt) / 100);\\r\\n            uint256 refinedAmt = (burnAmt - refineRateCut);\\r\\n            user.lastClaimBlock = block.number;\\r\\n            user.amount = _amount;\\r\\n            user.refineEndBlock = (_amount / refinery.burnRate) + block.number;\\r\\n            return (burnAmt, refinedAmt);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /* Deposit ERC1155s to the refinery\\r\\n     * Claims any already refined amounts for user\\r\\n     * within this refinery id (_rid)\\r\\n     * token id needs to be the raw.typeId of the input\\r\\n     */\\r\\n    function depositRaw(\\r\\n        uint256 _rid,\\r\\n        uint256 _tokenId,\\r\\n        uint256 _amount\\r\\n    ) external whenNotPaused noCheaters {\\r\\n        require(tx.origin == msg.sender, \\\"Only EOA\\\");\\r\\n        RefineryInfo memory refinery = refineryInfo[_rid];\\r\\n        UserInfo storage user = userRefines[_rid][msg.sender];\\r\\n        uint256 typeId = refinery.inputType;\\r\\n        uint256 outputId = refinery.outputType;\\r\\n         raw.updateOriginAccess(msg.sender);\\r\\n        //claim\\r\\n        if (user.amount > 0) {\\r\\n            (uint256 burnAmt, uint256 refinedAmt) = updateRefined(\\r\\n                _rid,\\r\\n                _amount,\\r\\n                msg.sender\\r\\n            );\\r\\n            raw.burn(typeId, burnAmt, address(this));\\r\\n            if ((outputId == 0)) {\\r\\n                uint256 mint = refinedAmt * multiplier;\\r\\n                eon.mint(msg.sender, mint);\\r\\n            } else {\\r\\n                raw.mint(outputId, refinedAmt, msg.sender);\\r\\n            }\\r\\n        }\\r\\n        require(_tokenId == refinery.inputType);\\r\\n        //transfer the raw ERC1155s to this contract\\r\\n        raw.safeTransferFrom(\\r\\n            address(msg.sender),\\r\\n            address(this),\\r\\n            (refinery.inputType),\\r\\n            _amount,\\r\\n            \\\"\\\"\\r\\n        );\\r\\n\\r\\n        //Initiate Deposit\\r\\n        if (user.amount == 0) {\\r\\n            // if the first depoist\\r\\n            user.refineEndBlock = (_amount / refinery.burnRate) + block.number;\\r\\n            user.lastClaimBlock = block.number;\\r\\n            user.amount += _amount;\\r\\n        }\\r\\n        emit DepositRaw(msg.sender, _rid, _amount);\\r\\n    }\\r\\n\\r\\n    /* withdraw UNREFINED erc1155s\\r\\n     * will withdraw the full unrefined input of user\\r\\n     * will also claim all refined\\r\\n     */\\r\\n    function withdrawRaw(uint256 _rid) external whenNotPaused noCheaters {\\r\\n        require(tx.origin == msg.sender, \\\"Only EOA\\\");\\r\\n        RefineryInfo memory refinery = refineryInfo[_rid];\\r\\n        UserInfo storage user = userRefines[_rid][msg.sender];\\r\\n        uint256 typeId = refinery.inputType;\\r\\n        uint256 outputId = refinery.outputType;\\r\\n        uint8 eonType = 0;\\r\\n        if (user.amount > 0) {\\r\\n            (uint256 burnAmt, uint256 refinedAmt) = updateRefined(\\r\\n                _rid,\\r\\n                0,\\r\\n                msg.sender\\r\\n            );\\r\\n            uint256 unrefined = (user.amount - burnAmt);\\r\\n            user.amount = 0;\\r\\n            raw.safeTransferFrom(\\r\\n                address(this),\\r\\n                msg.sender,\\r\\n                typeId,\\r\\n                unrefined,\\r\\n                \\\"\\\"\\r\\n            );\\r\\n            if (burnAmt > 0 && refinedAmt > 0) {\\r\\n                raw.burn(typeId, burnAmt, address(this));\\r\\n                if ((outputId == eonType)) {\\r\\n                    eon.mint(msg.sender, refinedAmt);\\r\\n                } else {\\r\\n                    raw.mint(outputId, refinedAmt, msg.sender);\\r\\n                }\\r\\n            }\\r\\n            emit WithdrawRaw(msg.sender, _rid, unrefined);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Withdraw RAW resources without caring about the refined amount. EMERGENCY ONLY\\r\\n    // Add a rescue pause enabled modifier\\r\\n    function emergencyWithdraw(uint256 _rid) external {\\r\\n        require(emergencyActivated, \\\"THIS IS NOT AN EMERGENCY SITUATION\\\");\\r\\n        RefineryInfo memory refinery = refineryInfo[_rid];\\r\\n        UserInfo storage user = userRefines[_rid][msg.sender];\\r\\n        uint256 typeId = refinery.inputType;\\r\\n        uint256 unrefined = user.amount;\\r\\n\\r\\n        raw.safeTransferFrom(address(this), msg.sender, typeId, unrefined, \\\"\\\");\\r\\n        // user.amount.safeTransfer(address(msg.sender), user.amount);\\r\\n        user.amount = 0;\\r\\n        user.lastClaimBlock = block.number;\\r\\n    }\\r\\n\\r\\n    /** admin\\r\\n     * enables owner to active \\\"emergency mode\\\"\\r\\n     * thus allow users to withdraw unrefined resouces without the refined gained\\r\\n     */\\r\\n\\r\\n    function activateEmergency(bool _enabled) external onlyOwner {\\r\\n        emergencyActivated = _enabled;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * enables owner to pause / unpause minting\\r\\n     */\\r\\n    function setPaused(bool _paused) external requireContractsSet onlyOwner {\\r\\n        if (_paused) _pause();\\r\\n        else _unpause();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * enables an address to mint / burn\\r\\n     * @param addr the address to enable\\r\\n     */\\r\\n    function addAdmin(address addr) external onlyOwner {\\r\\n        admins[addr] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * disables an address from minting / burning\\r\\n     * @param addr the address to disbale\\r\\n     */\\r\\n    function removeAdmin(address addr) external onlyOwner {\\r\\n        admins[addr] = false;\\r\\n    }\\r\\n\\r\\n    function onERC1155Received(\\r\\n        address,\\r\\n        address,\\r\\n        uint256,\\r\\n        uint256,\\r\\n        bytes calldata\\r\\n    ) external pure override returns (bytes4) {\\r\\n        return IERC1155TokenReceiver.onERC1155Received.selector;\\r\\n    }\\r\\n\\r\\n    function onERC1155BatchReceived(\\r\\n        address,\\r\\n        address,\\r\\n        uint256[] calldata,\\r\\n        uint256[] calldata,\\r\\n        bytes calldata\\r\\n    ) external pure override returns (bytes4) {\\r\\n        return IERC1155TokenReceiver.onERC1155Received.selector;\\r\\n    }\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\\r\\n        return\\r\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\r\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\r\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IEON.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IEON {\\r\\n    function mint(address to, uint256 amount) external;\\r\\n\\r\\n    function burn(address from, uint256 amount) external;\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC1155TokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\npragma solidity >=0.8.0;\\n\\ninterface IERC1155TokenReceiver {\\n   \\n   function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n   }\"\r\n    },\r\n    \"contracts/interfaces/IImperialGuild.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IImperialGuild {\\r\\n\\r\\n    function getBalance(\\r\\n        address account,\\r\\n        uint256 id\\r\\n    ) external returns(uint256);\\r\\n\\r\\n    function mint(\\r\\n        uint256 typeId,\\r\\n        uint256 paymentId,\\r\\n        uint16 qty,\\r\\n        address recipient\\r\\n    ) external;\\r\\n\\r\\n    function burn(\\r\\n        uint256 typeId,\\r\\n        uint16 qty,\\r\\n        address burnFrom\\r\\n    ) external;\\r\\n\\r\\n    function handlePayment(uint256 amount) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IRAW.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\npragma solidity ^0.8.0;\\n\\ninterface IRAW {\\n\\n    function updateOriginAccess(address user) external;\\n\\n\\n    function balanceOf(\\n        address account,\\n        uint256 id\\n    ) external returns(uint256);\\n\\n    function mint(\\n        uint256 typeId,\\n        uint256 qty,\\n        address recipient\\n    ) external;\\n\\n    function burn(\\n        uint256 typeId,\\n        uint256 qty,\\n        address burnFrom\\n    ) external;\\n\\n    function updateMintBurns(\\n        uint256 typeId,\\n        uint256 mintQty,\\n        uint256 burnQty\\n    ) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRefinery.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\npragma solidity ^0.8.0;\\n\\ninterface IRefinery {\\n    \\n     struct RefineryInfo {\\n        uint8 inputType; // raw input typeID\\n        uint8 outputType; // refined resourse typeID\\n        uint8 burnRate; // rate of input burn to refined per block\\n        uint8 refineRate; // rate cut of raw to refined\\n    }\\n    \\n    function getRefineryInfo(uint256 _rid) \\n    external \\n    view \\n    returns(RefineryInfo memory);\\n\\n    function pendingRefine(uint256 _rid, address _user)\\n        external\\n        returns (uint256 refining, uint256 refined);\\n\\n    function depositRaw(\\n        uint256 _rid,\\n        uint256 _tokenId,\\n        uint256 _amount\\n    ) external;\\n\\n    function withdrawRaw(uint256 _rid) external;\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositRaw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdrawRaw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawRaw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"activateEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_inputType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_outputType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_burnRate\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_refineRate\",\"type\":\"uint8\"}],\"name\":\"addRefinery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositRaw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyActivated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eon\",\"outputs\":[{\"internalType\":\"contract IEON\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rid\",\"type\":\"uint256\"}],\"name\":\"getRefineryInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"inputType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"outputType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"burnRate\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"refineRate\",\"type\":\"uint8\"}],\"internalType\":\"struct IRefinery.RefineryInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingRefine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"refining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refined\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raw\",\"outputs\":[{\"internalType\":\"contract IRAW\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refineryInfo\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"inputType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"outputType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"burnRate\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"refineRate\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_raw\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_eon\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_rid\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_inputType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_outputType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_burnRate\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_refineRate\",\"type\":\"uint8\"}],\"name\":\"updateRefineryInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRefines\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refineEndBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rid\",\"type\":\"uint256\"}],\"name\":\"withdrawRaw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Refinery", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}