{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/CowProtocolVirtualToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"./mixins/NonTransferrableErc20.sol\\\";\\nimport \\\"./mixins/Vesting.sol\\\";\\nimport \\\"./mixins/Claiming.sol\\\";\\nimport \\\"./mixins/MerkleDistributor.sol\\\";\\nimport \\\"./vendored/mixins/StorageAccessible.sol\\\";\\n\\n/// @dev The token that manages how the CoW Protocol governance token is\\n/// distributed to all different types of investors.\\n/// @title CoW Protocol Virtual Token\\n/// @author CoW Protocol Developers\\ncontract CowProtocolVirtualToken is\\n    NonTransferrableErc20,\\n    Vesting,\\n    Claiming,\\n    MerkleDistributor,\\n    StorageAccessible\\n{\\n    string private constant ERC20_SYMBOL = \\\"vCOW\\\";\\n    string private constant ERC20_NAME = \\\"CoW Protocol Virtual Token\\\";\\n\\n    constructor(\\n        bytes32 merkleRoot,\\n        address cowToken,\\n        address payable communityFundsTarget,\\n        address investorFundsTarget,\\n        address usdcToken,\\n        uint256 usdcPrice,\\n        address gnoToken,\\n        uint256 gnoPrice,\\n        address wrappedNativeToken,\\n        uint256 nativeTokenPrice,\\n        address teamController\\n    )\\n        NonTransferrableErc20(ERC20_NAME, ERC20_SYMBOL)\\n        Claiming(\\n            cowToken,\\n            communityFundsTarget,\\n            investorFundsTarget,\\n            usdcToken,\\n            usdcPrice,\\n            gnoToken,\\n            gnoPrice,\\n            wrappedNativeToken,\\n            nativeTokenPrice,\\n            teamController\\n        )\\n        MerkleDistributor(merkleRoot)\\n    // solhint-disable-next-line no-empty-blocks\\n    {\\n\\n    }\\n\\n    /// @dev Returns the sum of tokens that are either held as\\n    /// instantlySwappableBalance or will be vested in the future\\n    /// @param user The user for whom the balance is calculated\\n    /// @return Balance of the user\\n    function balanceOf(address user) public view returns (uint256) {\\n        return\\n            instantlySwappableBalance[user] +\\n            fullAllocation[user] -\\n            vestedAllocation[user];\\n    }\\n\\n    /// @dev Returns the balance of a user assuming all vested tokens would\\n    /// have been converted into virtual tokens\\n    /// @param user The user for whom the balance is calculated\\n    /// @return Balance the user would have after calling `swapAll`\\n    function swappableBalanceOf(address user) public view returns (uint256) {\\n        return instantlySwappableBalance[user] + newlyVestedBalance(user);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/mixins/NonTransferrableErc20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"../vendored/interfaces/IERC20.sol\\\";\\n\\n/// @dev A contract of an ERC20 token that cannot be transferred.\\n/// @title Non-Transferrable ERC20\\n/// @author CoW Protocol Developers\\nabstract contract NonTransferrableErc20 is IERC20 {\\n    /// @dev The ERC20 name of the token\\n    string public name;\\n    /// @dev The ERC20 symbol of the token\\n    string public symbol;\\n    /// @dev The ERC20 number of decimals of the token\\n    uint8 public constant decimals = 18; // solhint-disable const-name-snakecase\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /// @dev This error is fired when trying to perform an action that is not\\n    /// supported by the contract, like transfers and approvals. These actions\\n    /// will never be supported.\\n    error NotSupported();\\n\\n    /// @dev All types of transfers are permanently disabled.\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) public pure returns (bool) {\\n        revert NotSupported();\\n    }\\n\\n    /// @dev All types of transfers are permanently disabled.\\n    function transfer(address, uint256) public pure returns (bool) {\\n        revert NotSupported();\\n    }\\n\\n    /// @dev All types of approvals are permanently disabled to reduce code\\n    /// size.\\n    function approve(address, uint256) public pure returns (bool) {\\n        revert NotSupported();\\n    }\\n\\n    /// @dev Approvals cannot be set, so allowances are always zero.\\n    function allowance(address, address) public pure returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/mixins/Vesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\\"../vendored/libraries/Math.sol\\\";\\n\\nimport \\\"../interfaces/VestingInterface.sol\\\";\\n\\n/// @dev The vesting logic for distributing the COW token\\n/// @title Vesting Logic\\n/// @author CoW Protocol Developers\\ncontract Vesting is VestingInterface {\\n    /// @dev The timestamp of the official vesting start. This value is shared\\n    /// between all participants.\\n    uint256 public immutable vestingStart;\\n    /// @dev How long it will take for all vesting to be completed. It is set to\\n    /// four years.\\n    uint256 public constant VESTING_PERIOD_IN_SECONDS = 4 * 365 days + 1 days;\\n\\n    /// @dev Stores the amount of vesting that the user has already vested.\\n    mapping(address => uint256) public vestedAllocation;\\n    /// @dev Stores the maximum amount of vesting available to each user. This\\n    /// is exactly the total amount of vesting that can be converted after the\\n    /// vesting period is completed.\\n    mapping(address => uint256) public fullAllocation;\\n\\n    /// @dev Stores a bit indicating whether a vesting is cancelable\\n    /// Important: This implementaiton implies that there can not be a\\n    /// cancelable and non-cancelable vesting in parallel\\n    mapping(address => bool) public isCancelable;\\n\\n    /// @dev Event emitted when a new vesting position is added. The amount is\\n    /// the additional amount that can be vested at the end of the\\n    /// claiming period.\\n    event VestingAdded(address indexed user, uint256 amount, bool isCancelable);\\n    /// @dev Event emitted when a vesting position is canceled. The amount is\\n    /// the number of remaining vesting that will be given to the beneficiary.\\n    event VestingStopped(\\n        address indexed user,\\n        address freedVestingBeneficiary,\\n        uint256 amount\\n    );\\n    /// @dev Event emitted when the users claims (also partially) a vesting\\n    /// position.\\n    event Vested(address indexed user, uint256 amount);\\n\\n    /// @dev Error returned when trying to stop a claim that is not cancelable.\\n    error VestingNotCancelable();\\n\\n    constructor() {\\n        vestingStart = block.timestamp; // solhint-disable-line not-rely-on-time\\n    }\\n\\n    /// @inheritdoc VestingInterface\\n    function addVesting(\\n        address user,\\n        uint256 vestingAmount,\\n        bool isCancelableFlag\\n    ) internal override {\\n        if (isCancelableFlag) {\\n            // if one cancelable vesting is made, it converts all vestings into cancelable ones\\n            isCancelable[user] = isCancelableFlag;\\n        }\\n        fullAllocation[user] += vestingAmount;\\n        emit VestingAdded(user, vestingAmount, isCancelableFlag);\\n    }\\n\\n    /// @inheritdoc VestingInterface\\n    function shiftVesting(address user, address freedVestingBeneficiary)\\n        internal\\n        override\\n        returns (uint256 accruedVesting)\\n    {\\n        if (!isCancelable[user]) {\\n            revert VestingNotCancelable();\\n        }\\n        accruedVesting = vest(user);\\n        uint256 userFullAllocation = fullAllocation[user];\\n        uint256 userVestedAllocation = vestedAllocation[user];\\n        fullAllocation[user] = 0;\\n        vestedAllocation[user] = 0;\\n        fullAllocation[freedVestingBeneficiary] += userFullAllocation;\\n        vestedAllocation[freedVestingBeneficiary] += userVestedAllocation;\\n        emit VestingStopped(\\n            user,\\n            freedVestingBeneficiary,\\n            userFullAllocation - userVestedAllocation\\n        );\\n    }\\n\\n    /// @inheritdoc VestingInterface\\n    function vest(address user)\\n        internal\\n        override\\n        returns (uint256 newlyVested)\\n    {\\n        newlyVested = newlyVestedBalance(user);\\n        vestedAllocation[user] += newlyVested;\\n        emit Vested(user, newlyVested);\\n    }\\n\\n    /// @dev Assuming no conversions has been done by the user, calculates how\\n    /// much vesting can be converted at this point in time.\\n    /// @param user The user for whom the result is being calculated.\\n    /// @return How much vesting can be converted if no conversions had been\\n    /// done before.\\n    function cumulativeVestedBalance(address user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            (Math.min(\\n                block.timestamp - vestingStart, // solhint-disable-line not-rely-on-time\\n                VESTING_PERIOD_IN_SECONDS\\n            ) * fullAllocation[user]) / (VESTING_PERIOD_IN_SECONDS);\\n    }\\n\\n    /// @dev Calculates how much vesting can be converted at this point in time.\\n    /// Unlike `cumulativeVestedBalance`, this function keeps track of previous\\n    /// conversions.\\n    /// @param user The user for whom the result is being calculated.\\n    /// @return How much vesting can be converted.\\n    function newlyVestedBalance(address user) public view returns (uint256) {\\n        return cumulativeVestedBalance(user) - vestedAllocation[user];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/mixins/Claiming.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"../vendored/interfaces/IERC20.sol\\\";\\nimport \\\"../vendored/libraries/SafeERC20.sol\\\";\\n\\nimport \\\"../interfaces/ClaimingInterface.sol\\\";\\nimport \\\"../interfaces/VestingInterface.sol\\\";\\n\\n/// @dev The logic behind the claiming of virtual tokens and the swapping to\\n/// real tokens.\\n/// @title COW Virtual Token Claiming Logic\\n/// @author CoW Protocol Developers\\nabstract contract Claiming is ClaimingInterface, VestingInterface, IERC20 {\\n    using SafeERC20 for IERC20;\\n\\n    /// @dev Prices are represented as fractions. For readability, the\\n    /// denominator is one unit of the virtual token (assuming it has 18\\n    /// decimals), in this way the numerator of a price is the number of atoms\\n    /// that have the same value as a unit of virtual token.\\n    uint256 internal constant PRICE_DENOMINATOR = 10**18;\\n    /// @dev Price numerator for the COW/USDC price. This is the number of USDC\\n    /// atoms required to obtain a full unit of virtual token from an option.\\n    uint256 public immutable usdcPrice;\\n    /// @dev Price numerator for the COW/GNO price. This is the number of GNO\\n    /// atoms required to obtain a full unit of virtual token from an option.\\n    uint256 public immutable gnoPrice;\\n    /// @dev Price numerator for the COW/native-token price. This is the number\\n    /// of native token wei required to obtain a full unit of virtual token from\\n    /// an option.\\n    uint256 public immutable nativeTokenPrice;\\n\\n    /// @dev The proceeds from selling options to the community will be sent to,\\n    /// this address.\\n    address payable public immutable communityFundsTarget;\\n    /// @dev All proceeds from known investors will be sent to this address.\\n    address public immutable investorFundsTarget;\\n\\n    /// @dev Address of the real COW token. Tokens claimed by this contract can\\n    /// be converted to this token if this contract stores some balance of it.\\n    IERC20 public immutable cowToken;\\n    /// @dev Address of the USDC token. It is a form of payment for investors.\\n    IERC20 public immutable usdcToken;\\n    /// @dev Address of the GNO token. It is a form of payment for users who\\n    /// claim the options derived from holding GNO.\\n    IERC20 public immutable gnoToken;\\n    /// @dev Address of the wrapped native token. It is a form of payment for\\n    /// users who claim the options derived from being users of the CoW\\n    /// Protocol.\\n    IERC20 public immutable wrappedNativeToken;\\n\\n    /// @dev Address representing the CoW Protocol/CowSwap team. It is the only\\n    /// address that is allowed to stop the vesting of a claim, and exclusively\\n    /// for team claims.\\n    address public immutable teamController;\\n\\n    /// @dev Time at which this contract was deployed.\\n    uint256 public immutable deploymentTimestamp;\\n\\n    /// @dev Returns the amount of virtual tokens in existence, including those\\n    /// that have yet to be vested.\\n    uint256 public totalSupply;\\n\\n    /// @dev How many tokens can be immediately swapped in exchange for real\\n    /// tokens for each user.\\n    mapping(address => uint256) public instantlySwappableBalance;\\n\\n    /// @dev Error presented to a user trying to claim virtual tokens after the\\n    /// claiming period has ended.\\n    error ClaimingExpired();\\n    /// @dev Error presented to anyone but the team controller to stop a\\n    /// cancelable vesting position (i.e., only team vesting).\\n    error OnlyTeamController();\\n    /// @dev Error resulting from sending an incorrect amount of native to the\\n    /// contract.\\n    error InvalidNativeTokenAmount();\\n    /// @dev Error caused by an unsuccessful attempt to transfer native tokens.\\n    error FailedNativeTokenTransfer();\\n    /// @dev Error resulting from sending native tokens for a claim that cannot\\n    /// be redeemed with native tokens.\\n    error CannotSendNativeToken();\\n\\n    constructor(\\n        address _cowToken,\\n        address payable _communityFundsTarget,\\n        address _investorFundsTarget,\\n        address _usdcToken,\\n        uint256 _usdcPrice,\\n        address _gnoToken,\\n        uint256 _gnoPrice,\\n        address _wrappedNativeToken,\\n        uint256 _nativeTokenPrice,\\n        address _teamController\\n    ) {\\n        cowToken = IERC20(_cowToken);\\n        communityFundsTarget = _communityFundsTarget;\\n        investorFundsTarget = _investorFundsTarget;\\n        usdcToken = IERC20(_usdcToken);\\n        usdcPrice = _usdcPrice;\\n        gnoToken = IERC20(_gnoToken);\\n        gnoPrice = _gnoPrice;\\n        wrappedNativeToken = IERC20(_wrappedNativeToken);\\n        nativeTokenPrice = _nativeTokenPrice;\\n        teamController = _teamController;\\n\\n        // solhint-disable-next-line not-rely-on-time\\n        deploymentTimestamp = block.timestamp;\\n    }\\n\\n    /// @dev Allows the decorated function only to be executed before the\\n    /// contract deployment date plus the input amount of seconds.\\n    /// @param durationSinceDeployment Number of seconds after contract\\n    /// deployment before which the function can be executed anymore. The\\n    /// function reverts afterwards.\\n    modifier before(uint256 durationSinceDeployment) {\\n        // solhint-disable-next-line not-rely-on-time\\n        if (block.timestamp > deploymentTimestamp + durationSinceDeployment) {\\n            revert ClaimingExpired();\\n        }\\n        _;\\n    }\\n\\n    /// @dev The decorated function can only be executed by the team controller.\\n    modifier onlyTeamController() {\\n        if (msg.sender != teamController) {\\n            revert OnlyTeamController();\\n        }\\n        _;\\n    }\\n\\n    /// @inheritdoc ClaimingInterface\\n    function performClaim(\\n        ClaimType claimType,\\n        address payer,\\n        address claimant,\\n        uint256 amount,\\n        uint256 sentNativeTokens\\n    ) internal override {\\n        if (claimType == ClaimType.Airdrop) {\\n            claimAirdrop(claimant, amount, sentNativeTokens);\\n        } else if (claimType == ClaimType.GnoOption) {\\n            claimGnoOption(claimant, amount, payer, sentNativeTokens);\\n        } else if (claimType == ClaimType.UserOption) {\\n            claimUserOption(claimant, amount, payer, sentNativeTokens);\\n        } else if (claimType == ClaimType.Investor) {\\n            claimInvestor(claimant, amount, payer, sentNativeTokens);\\n        } else if (claimType == ClaimType.Team) {\\n            claimTeam(claimant, amount, sentNativeTokens);\\n        } else {\\n            // claimType == ClaimType.Advisor\\n            claimAdvisor(claimant, amount, sentNativeTokens);\\n        }\\n\\n        // Each claiming operation results in the creation of `amount` virtual\\n        // tokens.\\n        totalSupply += amount;\\n        emit Transfer(address(0), claimant, amount);\\n    }\\n\\n    /// @dev Stops all vesting claims of a user. This is only applicable for\\n    /// claims that are cancellable, i.e., team claims.\\n    /// @param user The user whose vesting claims should be canceled.\\n    function stopClaim(address user) external onlyTeamController {\\n        uint256 accruedVesting = shiftVesting(user, teamController);\\n        instantlySwappableBalance[user] += accruedVesting;\\n    }\\n\\n    /// @dev Transfers all ETH stored in the contract to the community funds\\n    // target.\\n    function withdrawEth() external {\\n        // We transfer ETH using .call instead of .transfer as not to restrict\\n        // the amount of gas sent to the target address during the transfer.\\n        // This is particularly relevant for sending ETH to smart contracts:\\n        // since EIP 2929, if a contract sends eth using `.transfer` then the\\n        // transaction proposed to the node needs to specify an _access list_,\\n        // which is currently not well supported by some wallet implementations.\\n        // There is no reentrancy risk as this call does not touch any storage\\n        // slot and the contract balance is not used in other logic.\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = communityFundsTarget.call{\\n            value: address(this).balance\\n        }(\\\"\\\");\\n        if (!success) {\\n            revert FailedNativeTokenTransfer();\\n        }\\n    }\\n\\n    /// @dev Performs an airdrop-type claim for the user.\\n    /// @param account The user for which the claim is performed.\\n    /// @param amount The full amount claimed by the user.\\n    /// @param sentNativeTokens Amount of ETH sent along to the transaction.\\n    function claimAirdrop(\\n        address account,\\n        uint256 amount,\\n        uint256 sentNativeTokens\\n    ) private before(6 weeks) {\\n        if (sentNativeTokens != 0) {\\n            revert CannotSendNativeToken();\\n        }\\n        instantlySwappableBalance[account] += amount;\\n    }\\n\\n    /// @dev Claims a Gno option for the user.\\n    /// @param account The user for which the claim is performed.\\n    /// @param amount The full amount claimed by the user after vesting.\\n    /// @param payer The address that pays the amount required by the claim.\\n    /// @param sentNativeTokens Amount of ETH sent along to the transaction.\\n    function claimGnoOption(\\n        address account,\\n        uint256 amount,\\n        address payer,\\n        uint256 sentNativeTokens\\n    ) private before(2 weeks) {\\n        if (sentNativeTokens != 0) {\\n            revert CannotSendNativeToken();\\n        }\\n        collectPayment(gnoToken, gnoPrice, payer, communityFundsTarget, amount);\\n        addVesting(account, amount, false);\\n    }\\n\\n    /// @dev Claims a native-token-based option for the user.\\n    /// @param account The user for which the claim is performed.\\n    /// @param amount The full amount claimed by the user after vesting.\\n    /// @param payer The address that pays the amount required by the claim.\\n    /// @param sentNativeTokens Amount of ETH sent along to the transaction.\\n    function claimUserOption(\\n        address account,\\n        uint256 amount,\\n        address payer,\\n        uint256 sentNativeTokens\\n    ) private before(2 weeks) {\\n        if (sentNativeTokens != 0) {\\n            collectNativeTokenPayment(amount, sentNativeTokens);\\n        } else {\\n            collectPayment(\\n                wrappedNativeToken,\\n                nativeTokenPrice,\\n                payer,\\n                communityFundsTarget,\\n                amount\\n            );\\n        }\\n        addVesting(account, amount, false);\\n    }\\n\\n    /// @dev Claims an investor option.\\n    /// @param account The user for which the claim is performed.\\n    /// @param amount The full amount claimed by the user after vesting.\\n    /// @param payer The address that pays the amount required by the claim.\\n    /// @param sentNativeTokens Amount of ETH sent along to the transaction.\\n    function claimInvestor(\\n        address account,\\n        uint256 amount,\\n        address payer,\\n        uint256 sentNativeTokens\\n    ) private before(2 weeks) {\\n        if (sentNativeTokens != 0) {\\n            revert CannotSendNativeToken();\\n        }\\n        collectPayment(\\n            usdcToken,\\n            usdcPrice,\\n            payer,\\n            investorFundsTarget,\\n            amount\\n        );\\n        addVesting(account, amount, false);\\n    }\\n\\n    /// @dev Claims a team option. Team options are granted without any payment\\n    /// but can be canceled.\\n    /// @param account The user for which the claim is performed.\\n    /// @param amount The full amount claimed by the user after vesting.\\n    /// @param sentNativeTokens Amount of ETH sent along to the transaction.\\n    function claimTeam(\\n        address account,\\n        uint256 amount,\\n        uint256 sentNativeTokens\\n    ) private before(6 weeks) {\\n        if (sentNativeTokens != 0) {\\n            revert CannotSendNativeToken();\\n        }\\n        addVesting(account, amount, true);\\n    }\\n\\n    /// @dev Claims an adviser option. Team options are granted without any\\n    /// payment and cannot be canceled.\\n    /// @param account The user for which the claim is performed.\\n    /// @param amount The full amount claimed by the user after vesting.\\n    /// @param sentNativeTokens Amount of ETH sent along to the transaction.\\n    function claimAdvisor(\\n        address account,\\n        uint256 amount,\\n        uint256 sentNativeTokens\\n    ) private before(6 weeks) {\\n        if (sentNativeTokens != 0) {\\n            revert CannotSendNativeToken();\\n        }\\n        addVesting(account, amount, false);\\n    }\\n\\n    /// @dev Executes a transfer from the user to the target. The transfered\\n    /// amount is based on the input COW price and amount of COW bought.\\n    /// @param token The token used for the payment.\\n    /// @param price The number of atoms of the input token that are equivalent\\n    /// to one atom of COW multiplied by PRICE_DENOMINATOR.\\n    /// @param from The address from which to take the funds.\\n    /// @param to The address to which to send the funds.\\n    /// @param amount The amount of COW atoms that will be paid for.\\n    function collectPayment(\\n        IERC20 token,\\n        uint256 price,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) private {\\n        uint256 tokenEquivalent = convertCowAmountAtPrice(amount, price);\\n        token.safeTransferFrom(from, to, tokenEquivalent);\\n    }\\n\\n    /// @dev Transfers native tokens from this contract to the target, assuming\\n    /// that the amount of native tokens sent coincides with the expected amount\\n    /// of native tokens. This amount is based on the price of the native token\\n    /// and amount of COW bought.\\n    /// @param amount The amount of COW atoms that will be paid for.\\n    /// @param sentNativeTokens Amount of ETH sent along to the transaction.\\n    function collectNativeTokenPayment(uint256 amount, uint256 sentNativeTokens)\\n        private\\n        view\\n    {\\n        uint256 nativeTokenEquivalent = convertCowAmountAtPrice(\\n            amount,\\n            nativeTokenPrice\\n        );\\n        if (sentNativeTokens != nativeTokenEquivalent) {\\n            revert InvalidNativeTokenAmount();\\n        }\\n    }\\n\\n    /// @dev Converts input amount in COW token atoms to an amount in token\\n    /// atoms at the specified price.\\n    /// @param amount Amount of tokens to convert.\\n    /// @param price The number of atoms of the input token that are equivalent\\n    /// to one atom of COW *multiplied by PRICE_DENOMINATOR*.\\n    function convertCowAmountAtPrice(uint256 amount, uint256 price)\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return (amount * price) / PRICE_DENOMINATOR;\\n    }\\n\\n    /// @dev Converts an amount of (virtual) tokens from this contract to real\\n    /// tokens based on the claims previously performed by the caller.\\n    /// @param amount How many virtual tokens to convert into real tokens.\\n    function swap(uint256 amount) external {\\n        makeVestingSwappable();\\n        _swap(amount);\\n    }\\n\\n    /// @dev Converts all available (virtual) tokens from this contract to real\\n    /// tokens based on the claims previously performed by the caller.\\n    /// @return swappedBalance The full amount that was swapped (i.e., virtual\\n    /// tokens burnt as well as real tokens received).\\n    function swapAll() external returns (uint256 swappedBalance) {\\n        swappedBalance = makeVestingSwappable();\\n        _swap(swappedBalance);\\n    }\\n\\n    /// @dev Transfers real tokens to the message sender and reduces the balance\\n    /// of virtual tokens available. Note that this function assumes that the\\n    /// current contract stores enough real tokens to fulfill this swap request.\\n    /// @param amount How many virtual tokens to convert into real tokens.\\n    function _swap(uint256 amount) private {\\n        instantlySwappableBalance[msg.sender] -= amount;\\n        totalSupply -= amount;\\n        cowToken.safeTransfer(msg.sender, amount);\\n        emit Transfer(msg.sender, address(0), amount);\\n    }\\n\\n    /// @dev Adds the currently vested amount to the immediately swappable\\n    /// balance.\\n    /// @return swappableBalance The maximum balance that can be swapped at\\n    /// this point in time by the caller.\\n    function makeVestingSwappable() private returns (uint256 swappableBalance) {\\n        swappableBalance =\\n            instantlySwappableBalance[msg.sender] +\\n            vest(msg.sender);\\n        instantlySwappableBalance[msg.sender] = swappableBalance;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/mixins/MerkleDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\n\\n// This contract is based on Uniswap's MekleDistributor, which can be found at:\\n// https://github.com/Uniswap/merkle-distributor/blob/0d478d722da2e5d95b7292fd8cbdb363d98e9a93/contracts/MerkleDistributor.sol\\n//\\n// The changes between the original contract and this are:\\n//  - the claim function doesn't trigger a transfer on a successful proof, but\\n//    it executes a dedicated (virtual) function.\\n//  - added a claimMany function for bundling multiple claims in a transaction\\n//  - supported sending an amount of native tokens along with the claim\\n//  - added the option of claiming less than the maximum amount\\n//  - gas optimizations in the packing and unpacking of the claimed bit\\n//  - bumped Solidity version\\n//  - code formatting\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"../vendored/interfaces/IERC20.sol\\\";\\nimport \\\"../vendored/libraries/MerkleProof.sol\\\";\\n\\nimport \\\"../interfaces/ClaimingInterface.sol\\\";\\n\\nabstract contract MerkleDistributor is ClaimingInterface {\\n    bytes32 public immutable merkleRoot;\\n\\n    /// @dev Event fired if a claim was successfully performed.\\n    event Claimed(\\n        uint256 index,\\n        ClaimType claimType,\\n        address claimant,\\n        uint256 claimableAmount,\\n        uint256 claimedAmount\\n    );\\n\\n    /// @dev Error caused by a user trying to call the claim function for a\\n    /// claim that has already been used before.\\n    error AlreadyClaimed();\\n    /// @dev Error caused by a user trying to claim a larger amount than the\\n    /// maximum allowed in the claim.\\n    error ClaimingMoreThanMaximum();\\n    /// @dev Error caused by the caller trying to perform a partial claim while\\n    /// not being the owner of the claim.\\n    error OnlyOwnerCanClaimPartially();\\n    /// @dev Error caused by calling the claim function with an invalid proof.\\n    error InvalidProof();\\n    /// @dev Error caused by calling claimMany with a transaction value that is\\n    /// different from the required one.\\n    error InvalidNativeTokenValue();\\n\\n    /// @dev Packed array of booleans that stores if a claim is available.\\n    mapping(uint256 => uint256) private claimedBitMap;\\n\\n    constructor(bytes32 merkleRoot_) {\\n        merkleRoot = merkleRoot_;\\n    }\\n\\n    /// @dev Checks if the claim at the provided index has already been claimed.\\n    /// @param index The index to check.\\n    /// @return Whether the claim at the given index has already been claimed.\\n    function isClaimed(uint256 index) public view returns (bool) {\\n        uint256 claimedWordIndex = index >> 8;\\n        uint256 claimedBitIndex = index & 0xff;\\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\\n        uint256 mask = (1 << claimedBitIndex);\\n        return claimedWord & mask != 0;\\n    }\\n\\n    /// @dev Mark the provided index as having been claimed.\\n    /// @param index The index that was claimed.\\n    function _setClaimed(uint256 index) private {\\n        uint256 claimedWordIndex = index >> 8;\\n        uint256 claimedBitIndex = index & 0xff;\\n        claimedBitMap[claimedWordIndex] =\\n            claimedBitMap[claimedWordIndex] |\\n            (1 << claimedBitIndex);\\n    }\\n\\n    /// @dev This function verifies the provided input proof based on the\\n    /// provided input. If the proof is valid, the function [`performClaim`] is\\n    /// called for the claimed amount.\\n    /// @param index The index that identifies the input claim.\\n    /// @param claimType See [`performClaim`].\\n    /// @param claimant See [`performClaim`].\\n    /// @param claimableAmount The maximum amount that the claimant can claim\\n    /// for this claim. Should not be smaller than claimedAmount.\\n    /// @param claimedAmount See [`performClaim`].\\n    /// @param merkleProof A proof that the input claim belongs to the unique\\n    /// Merkle root associated to this contract.\\n    function claim(\\n        uint256 index,\\n        ClaimType claimType,\\n        address claimant,\\n        uint256 claimableAmount,\\n        uint256 claimedAmount,\\n        bytes32[] calldata merkleProof\\n    ) external payable {\\n        _claim(\\n            index,\\n            claimType,\\n            claimant,\\n            claimableAmount,\\n            claimedAmount,\\n            merkleProof,\\n            msg.value\\n        );\\n    }\\n\\n    /// @dev This function verifies and executes multiple claims in the same\\n    /// transaction.\\n    /// @param indices A vector of indices. See [`claim`] for details.\\n    /// @param claimTypes A vector of claim types. See [`performClaim`] for\\n    /// details.\\n    /// @param claimants A vector of claimants. See [`performClaim`] for\\n    /// details.\\n    /// @param claimableAmounts A vector of claimable amounts. See [`claim`] for\\n    /// details.\\n    /// @param claimedAmounts A vector of claimed amounts. See [`performClaim`]\\n    /// for details.\\n    /// @param merkleProofs A vector of merkle proofs. See [`claim`] for\\n    /// details.\\n    /// @param sentNativeTokens A vector of native token amounts. See\\n    /// [`performClaim`] for details.\\n    function claimMany(\\n        uint256[] memory indices,\\n        ClaimType[] memory claimTypes,\\n        address[] calldata claimants,\\n        uint256[] calldata claimableAmounts,\\n        uint256[] calldata claimedAmounts,\\n        bytes32[][] calldata merkleProofs,\\n        uint256[] calldata sentNativeTokens\\n    ) external payable {\\n        uint256 sumSentNativeTokens;\\n        for (uint256 i = 0; i < indices.length; i++) {\\n            sumSentNativeTokens += sentNativeTokens[i];\\n            _claim(\\n                indices[i],\\n                claimTypes[i],\\n                claimants[i],\\n                claimableAmounts[i],\\n                claimedAmounts[i],\\n                merkleProofs[i],\\n                sentNativeTokens[i]\\n            );\\n        }\\n        if (sumSentNativeTokens != msg.value) {\\n            revert InvalidNativeTokenValue();\\n        }\\n    }\\n\\n    /// @dev This function verifies the provided input proof based on the\\n    /// provided input. If the proof is valid, the function [`performClaim`] is\\n    /// called for the claimed amount.\\n    /// @param index See [`claim`].\\n    /// @param claimType See [`performClaim`].\\n    /// @param claimant See [`performClaim`].\\n    /// @param claimableAmount See [`claim`].\\n    /// @param claimedAmount See [`performClaim`].\\n    /// @param merkleProof See [`claim`].\\n    /// @param sentNativeTokens See [`performClaim`].\\n    function _claim(\\n        uint256 index,\\n        ClaimType claimType,\\n        address claimant,\\n        uint256 claimableAmount,\\n        uint256 claimedAmount,\\n        bytes32[] calldata merkleProof,\\n        uint256 sentNativeTokens\\n    ) private {\\n        if (isClaimed(index)) {\\n            revert AlreadyClaimed();\\n        }\\n        if (claimedAmount > claimableAmount) {\\n            revert ClaimingMoreThanMaximum();\\n        }\\n        if ((claimedAmount < claimableAmount) && (msg.sender != claimant)) {\\n            revert OnlyOwnerCanClaimPartially();\\n        }\\n\\n        // Note: all types used inside `encodePacked` should have fixed length,\\n        // otherwise the same proof could be used in different claims.\\n        bytes32 node = keccak256(\\n            abi.encodePacked(index, claimType, claimant, claimableAmount)\\n        );\\n        if (!MerkleProof.verify(merkleProof, merkleRoot, node)) {\\n            revert InvalidProof();\\n        }\\n\\n        _setClaimed(index);\\n\\n        performClaim(\\n            claimType,\\n            msg.sender,\\n            claimant,\\n            claimedAmount,\\n            sentNativeTokens\\n        );\\n\\n        emit Claimed(\\n            index,\\n            claimType,\\n            claimant,\\n            claimableAmount,\\n            claimedAmount\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/vendored/mixins/StorageAccessible.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n\\n// Vendored from Gnosis utility contracts, see:\\n// <https://raw.githubusercontent.com/gnosis/gp-v2-contracts/40c349d52d14f8f3c9f787fe2fca5a496bb10ea9/src/contracts/mixins/StorageAccessible.sol>\\n// The following changes were made:\\n// - Modified Solidity version\\n// - Formatted code\\n\\npragma solidity ^0.8.10;\\n\\n/// @title ViewStorageAccessible - Interface on top of StorageAccessible base class to allow simulations from view functions\\ninterface ViewStorageAccessible {\\n    /**\\n     * @dev Same as `simulateDelegatecall` on StorageAccessible. Marked as view so that it can be called from external contracts\\n     * that want to run simulations from within view functions. Will revert if the invoked simulation attempts to change state.\\n     */\\n    function simulateDelegatecall(\\n        address targetContract,\\n        bytes memory calldataPayload\\n    ) external view returns (bytes memory);\\n\\n    /**\\n     * @dev Same as `getStorageAt` on StorageAccessible. This method allows reading aribtrary ranges of storage.\\n     */\\n    function getStorageAt(uint256 offset, uint256 length)\\n        external\\n        view\\n        returns (bytes memory);\\n}\\n\\n/// @title StorageAccessible - generic base contract that allows callers to access all internal storage.\\ncontract StorageAccessible {\\n    /**\\n     * @dev Reads `length` bytes of storage in the currents contract\\n     * @param offset - the offset in the current contract's storage in words to start reading from\\n     * @param length - the number of words (32 bytes) of data to read\\n     * @return the bytes that were read.\\n     */\\n    function getStorageAt(uint256 offset, uint256 length)\\n        external\\n        view\\n        returns (bytes memory)\\n    {\\n        bytes memory result = new bytes(length * 32);\\n        for (uint256 index = 0; index < length; index++) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                let word := sload(add(offset, index))\\n                mstore(add(add(result, 0x20), mul(index, 0x20)), word)\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Performs a delegetecall on a targetContract in the context of self.\\n     * Internally reverts execution to avoid side effects (making it static). Catches revert and returns encoded result as bytes.\\n     * @param targetContract Address of the contract containing the code to execute.\\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\\n     */\\n    function simulateDelegatecall(\\n        address targetContract,\\n        bytes memory calldataPayload\\n    ) public returns (bytes memory response) {\\n        bytes memory innerCall = abi.encodeWithSelector(\\n            this.simulateDelegatecallInternal.selector,\\n            targetContract,\\n            calldataPayload\\n        );\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (, response) = address(this).call(innerCall);\\n        bool innerSuccess = response[response.length - 1] == 0x01;\\n        setLength(response, response.length - 1);\\n        if (innerSuccess) {\\n            return response;\\n        } else {\\n            revertWith(response);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a delegetecall on a targetContract in the context of self.\\n     * Internally reverts execution to avoid side effects (making it static). Returns encoded result as revert message\\n     * concatenated with the success flag of the inner call as a last byte.\\n     * @param targetContract Address of the contract containing the code to execute.\\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\\n     */\\n    function simulateDelegatecallInternal(\\n        address targetContract,\\n        bytes memory calldataPayload\\n    ) external returns (bytes memory response) {\\n        bool success;\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (success, response) = targetContract.delegatecall(calldataPayload);\\n        revertWith(abi.encodePacked(response, success));\\n    }\\n\\n    function revertWith(bytes memory response) internal pure {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            revert(add(response, 0x20), mload(response))\\n        }\\n    }\\n\\n    function setLength(bytes memory buffer, uint256 length) internal pure {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            mstore(buffer, length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/vendored/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// Vendored from OpenZeppelin Contracts v4.4.0, see:\\n// <https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.4.0/contracts/token/ERC20/IERC20.sol>\\n\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"src/contracts/vendored/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// Vendored from OpenZeppelin Contracts v4.4.0, see:\\n// <https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.4.0/contracts/utils/math/Math.sol>\\n\\n// OpenZeppelin Contracts v4.4.0 (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/VestingInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\n\\npragma solidity ^0.8.10;\\n\\n/// @dev The contract functions that are shared between the `Vesting` and\\n/// `Claiming` contracts. The two components are handled and tested\\n/// separately and are linked to each other by the functions in this contract.\\n/// This contracs is for all intents and purposes an interface, however actual\\n/// interfaces cannot declare internal functions.\\n/// @title COW token vesting interface.\\n/// @author CoW Protocol Developers\\nabstract contract VestingInterface {\\n    /// @dev Adds an amount that will be vested over time.\\n    /// Should be called from the parent contract on redeeming a vested claim.\\n    /// @param user The user for whom the vesting is performed.\\n    /// @param vestingAmount The (added) amount to be vested in time.\\n    /// @param isCancelableFlag Flag whether the vesting is cancelable\\n    function addVesting(\\n        address user,\\n        uint256 vestingAmount,\\n        bool isCancelableFlag\\n    ) internal virtual;\\n\\n    /// @dev Computes the current vesting from the total vested amount and marks\\n    /// that amount as converted. This is called by the parent contract every\\n    /// time virtual tokens from a vested claim are swapped into real tokens.\\n    /// @param user The user for which the amount is vested.\\n    /// @return Amount converted.\\n    function vest(address user) internal virtual returns (uint256);\\n\\n    /// @dev Transfers a cancelable vesting of a user to another address.\\n    /// Returns the amount of token that is not yet converted.\\n    /// @param user The user for whom the vesting is removed.\\n    /// @param freedVestingBeneficiary The address to which to assign the amount\\n    /// that remains to be vested.\\n    /// @return accruedVesting The total number of tokens that remain to be\\n    /// converted\\n    function shiftVesting(address user, address freedVestingBeneficiary)\\n        internal\\n        virtual\\n        returns (uint256 accruedVesting);\\n}\\n\"\r\n    },\r\n    \"src/contracts/vendored/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\n\\n// Vendored from GPv2 contracts v1.1.2, see:\\n// <https://raw.githubusercontent.com/gnosis/gp-v2-contracts/7fb88982021e9a274d631ffb598694e6d9b30089/src/contracts/libraries/GPv2SafeERC20.sol>\\n// The following changes were made:\\n// - Bumped up Solidity version and checked that the assembly is still valid.\\n// - Use own vendored IERC20 instead of custom implementation.\\n// - Removed \\\"GPv2\\\" from contract name.\\n// - Modified revert messages, including length.\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Safe ERC20 Transfer Library\\n/// @author Gnosis Developers\\n/// @dev Gas-efficient version of Openzeppelin's SafeERC20 contract.\\nlibrary SafeERC20 {\\n    /// @dev Wrapper around a call to the ERC20 function `transfer` that reverts\\n    /// also when the token returns `false`.\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        bytes4 selector_ = token.transfer.selector;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            mstore(freeMemoryPointer, selector_)\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            )\\n            mstore(add(freeMemoryPointer, 36), value)\\n\\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        require(getLastTransferResult(token), \\\"SafeERC20: failed transfer\\\");\\n    }\\n\\n    /// @dev Wrapper around a call to the ERC20 function `transferFrom` that\\n    /// reverts also when the token returns `false`.\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        bytes4 selector_ = token.transferFrom.selector;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            mstore(freeMemoryPointer, selector_)\\n            mstore(\\n                add(freeMemoryPointer, 4),\\n                and(from, 0xffffffffffffffffffffffffffffffffffffffff)\\n            )\\n            mstore(\\n                add(freeMemoryPointer, 36),\\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\\n            )\\n            mstore(add(freeMemoryPointer, 68), value)\\n\\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        require(getLastTransferResult(token), \\\"SafeERC20: failed transferFrom\\\");\\n    }\\n\\n    /// @dev Verifies that the last return was a successful `transfer*` call.\\n    /// This is done by checking that the return data is either empty, or\\n    /// is a valid ABI encoded boolean.\\n    function getLastTransferResult(IERC20 token)\\n        private\\n        view\\n        returns (bool success)\\n    {\\n        // NOTE: Inspecting previous return data requires assembly. Note that\\n        // we write the return data to memory 0 in the case where the return\\n        // data size is 32, this is OK since the first 64 bytes of memory are\\n        // reserved by Solidy as a scratch space that can be used within\\n        // assembly blocks.\\n        // <https://docs.soliditylang.org/en/v0.8.10/internals/layout_in_memory.html>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            /// @dev Revert with an ABI encoded Solidity error with a message\\n            /// that fits into 32-bytes.\\n            ///\\n            /// An ABI encoded Solidity error has the following memory layout:\\n            ///\\n            /// ------------+----------------------------------\\n            ///  byte range | value\\n            /// ------------+----------------------------------\\n            ///  0x00..0x04 |        selector(\\\"Error(string)\\\")\\n            ///  0x04..0x24 |      string offset (always 0x20)\\n            ///  0x24..0x44 |                    string length\\n            ///  0x44..0x64 | string value, padded to 32-bytes\\n            function revertWithMessage(length, message) {\\n                mstore(0x00, \\\"\\\\x08\\\\xc3\\\\x79\\\\xa0\\\")\\n                mstore(0x04, 0x20)\\n                mstore(0x24, length)\\n                mstore(0x44, message)\\n                revert(0x00, 0x64)\\n            }\\n\\n            switch returndatasize()\\n            // Non-standard ERC20 transfer without return.\\n            case 0 {\\n                // NOTE: When the return data size is 0, verify that there\\n                // is code at the address. This is done in order to maintain\\n                // compatibility with Solidity calling conventions.\\n                // <https://docs.soliditylang.org/en/v0.8.10/control-structures.html#external-function-calls>\\n                if iszero(extcodesize(token)) {\\n                    revertWithMessage(25, \\\"SafeERC20: not a contract\\\")\\n                }\\n\\n                success := 1\\n            }\\n            // Standard ERC20 transfer returning boolean success value.\\n            case 32 {\\n                returndatacopy(0, 0, returndatasize())\\n\\n                // NOTE: For ABI encoding v1, any non-zero value is accepted\\n                // as `true` for a boolean. In order to stay compatible with\\n                // OpenZeppelin's `SafeERC20` library which is known to work\\n                // with the existing ERC20 implementation we care about,\\n                // make sure we return success for any non-zero return value\\n                // from the `transfer*` call.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            default {\\n                revertWithMessage(30, \\\"SafeERC20: bad transfer result\\\")\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/ClaimingInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\n\\npragma solidity ^0.8.10;\\n\\n/// @dev The contract functions that are shared between the `Claiming` and\\n/// `MerkleDistributor` contracts. The two components are handled and tested\\n/// separately and are linked to each other by the functions in this contract.\\n/// This contracs is for all intents and purposes an interface, however actual\\n/// interfaces cannot declare internal functions.\\n/// @title COW token claiming interface.\\n/// @author CoW Protocol Developers\\nabstract contract ClaimingInterface {\\n    /// @dev Exhaustive list of the different branches of the claiming logic.\\n    enum ClaimType {\\n        Airdrop,\\n        GnoOption,\\n        UserOption,\\n        Investor,\\n        Team,\\n        Advisor\\n    }\\n\\n    /// @dev This function is executed when a valid proof of the claim is\\n    /// provided and executes all steps required for each claim type.\\n    /// @param claimType Which claim will be performed. See [`ClaimType`] for\\n    /// an exausting list.\\n    /// @param payer The address that will pay if the claim to be performed\\n    /// requires a payment.\\n    /// @param claimant The account to which the claim is assigned and which\\n    /// will receive the corresponding virtual tokens.\\n    /// @param claimedAmount The amount that the user decided to claim (after\\n    /// vesting if it applies).\\n    /// @param sentNativeTokens The amount of native tokens that the user sent\\n    /// along with the transaction.\\n    function performClaim(\\n        ClaimType claimType,\\n        address payer,\\n        address claimant,\\n        uint256 claimedAmount,\\n        uint256 sentNativeTokens\\n    ) internal virtual;\\n}\\n\"\r\n    },\r\n    \"src/contracts/vendored/libraries/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// Vendored from OpenZeppelin Contracts v4.4.0, see:\\n// <https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v4.4.0/contracts/utils/cryptography/MerkleProof.sol>\\n\\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(\\n                    abi.encodePacked(computedHash, proofElement)\\n                );\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(\\n                    abi.encodePacked(proofElement, computedHash)\\n                );\\n            }\\n        }\\n        return computedHash;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"cowToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"communityFundsTarget\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"investorFundsTarget\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdcToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usdcPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gnoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gnoPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wrappedNativeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nativeTokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"teamController\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSendNativeToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ClaimingExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ClaimingMoreThanMaximum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedNativeTokenTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNativeTokenAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNativeTokenValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotSupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwnerCanClaimPartially\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyTeamController\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VestingNotCancelable\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum ClaimingInterface.ClaimType\",\"name\":\"claimType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimableAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Vested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isCancelable\",\"type\":\"bool\"}],\"name\":\"VestingAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"freedVestingBeneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VestingStopped\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VESTING_PERIOD_IN_SECONDS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"enum ClaimingInterface.ClaimType\",\"name\":\"claimType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"claimant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"claimableAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"indices\",\"type\":\"uint256[]\"},{\"internalType\":\"enum ClaimingInterface.ClaimType[]\",\"name\":\"claimTypes\",\"type\":\"uint8[]\"},{\"internalType\":\"address[]\",\"name\":\"claimants\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"claimableAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"claimedAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"merkleProofs\",\"type\":\"bytes32[][]\"},{\"internalType\":\"uint256[]\",\"name\":\"sentNativeTokens\",\"type\":\"uint256[]\"}],\"name\":\"claimMany\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"communityFundsTarget\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cowToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"cumulativeVestedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploymentTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"fullAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"getStorageAt\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gnoPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gnoToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"instantlySwappableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investorFundsTarget\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCancelable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"newlyVestedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"calldataPayload\",\"type\":\"bytes\"}],\"name\":\"simulateDelegatecall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"calldataPayload\",\"type\":\"bytes\"}],\"name\":\"simulateDelegatecallInternal\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"stopClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swappedBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"swappableBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdcPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdcToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vestedAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedNativeToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CowProtocolVirtualToken", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "246660bd35bfe8e312c39a601894f9874534ff967263b79f0a3196f50b431583000000000000000000000000def1ca1fb7fbcdc777520aa7f396b4e015f497ab000000000000000000000000ca771eda0c70aa7d053ab1b25004559b918fe662000000000000000000000000a1cb7762f40318ee0260f53e15de835ff001cb7e000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000000000000000000000000000000000000000249f00000000000000000000000006810e776880c02933d47db1b9fc05908e5386b96000000000000000000000000000000000000000000000000000214e8348c4f00000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000000000000000000000000000000039257389bb3e000000000000000000000000ca07eaa4253638d286cad71cbceec11803f2709a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}