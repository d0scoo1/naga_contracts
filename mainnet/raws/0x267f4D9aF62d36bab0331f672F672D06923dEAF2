{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Test.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.6.12;\\n\\n//import \\\"hardhat/console.sol\\\";\\nimport \\\"./lib/SafeMath.sol\\\";\\n\\ncontract Test {\\n  using SafeMath for uint256;\\n\\n  event MigratedToNodePack(address indexed entity, uint128 fromNodeId, uint toPackId, uint nodeSeconds, uint totalSeconds);\\n  event Created(address indexed entity, uint packType, uint nodesCount, bool usedCredit, uint timestamp, address migratedFrom, uint lastPaidAt);\\n\\n  uint constant public secondsPerBlock = 13;\\n\\n  mapping(address => uint128) public entityNodeCount;\\n  mapping(bytes => uint256) public entityNodePaidOnBlock;\\n  mapping(bytes => uint256) public entityNodeClaimedTotal;\\n\\n  function getNodeId(address entity, uint128 nodeId) public view returns (bytes memory) {\\n    uint128 id = nodeId != 0 ? nodeId : entityNodeCount[entity] + 1;\\n    return abi.encodePacked(entity, id);\\n  }\\n\\n  function getRewardAll(address entity, uint256 blockNumber) public view returns (uint256) {\\n    return 0;\\n//    uint256 rewardsAll = 0;\\n//\\n//    for (uint128 i = 1; i <= entityNodeCount[entity]; i++) {\\n//      rewardsAll = rewardsAll.add(getRewardByBlock(entity, i, blockNumber > 0 ? blockNumber : block.number));\\n//    }\\n//\\n//    return rewardsAll;\\n  }\\n\\n  function setup() external {\\n    entityNodeCount[msg.sender] = 5;\\n    entityNodePaidOnBlock[getNodeId(msg.sender, 1)] = 14848087;\\n    entityNodePaidOnBlock[getNodeId(msg.sender, 2)] = 14945039;\\n    entityNodePaidOnBlock[getNodeId(msg.sender, 3)] = 14851391;\\n    entityNodePaidOnBlock[getNodeId(msg.sender, 4)] = 14982358;\\n    entityNodePaidOnBlock[getNodeId(msg.sender, 5)] = 14936284;\\n  }\\n\\n  function migrateAll() external payable {\\n//    uint256 blockNumber = 14969712;\\n//    uint256 blockTimestamp = 1655328937;\\n//    uint256 blockNumber = block.number;\\n//    uint256 blockTimestamp = block.timestamp;\\n\\n    uint256 totalClaimed = 0;\\n    uint128 migratedNodes = 0;\\n    uint256 totalSeconds = 0;\\n    uint256 rewardsDue = getRewardAll(msg.sender, 0);\\n\\n    for (uint128 nodeId = 1; nodeId <= entityNodeCount[msg.sender]; nodeId++) {\\n      bytes memory id = getNodeId(msg.sender, nodeId);\\n      bool migrated = true;\\n      if (migrated) {\\n        migratedNodes += 1;\\n        totalClaimed = totalClaimed.add(entityNodeClaimedTotal[id]);\\n        totalSeconds = totalSeconds.add(block.timestamp - ((block.number - entityNodePaidOnBlock[id]) * secondsPerBlock));\\n        emit MigratedToNodePack(msg.sender, nodeId, 1, block.timestamp - ((block.number - entityNodePaidOnBlock[id]) * secondsPerBlock), totalSeconds);\\n      }\\n    }\\n\\n//    console.log(\\\"block.number: \\\", block.number);\\n//    console.log(\\\"block.timestamp: \\\", block.timestamp);\\n//    console.log(\\\"totalSeconds: \\\", totalSeconds);\\n//    console.log(\\\"totalSeconds / migratedNodes: \\\", totalSeconds / migratedNodes);\\n//    console.log(\\\"totalSeconds.div(migratedNodes): \\\", totalSeconds.div(migratedNodes));\\n\\n    require(migratedNodes > 0, \\\"nothing to migrate\\\");\\n\\n//    entityNodeDeactivatedCount[msg.sender] += migratedNodes;\\n    migrateNodes(msg.sender, 1, migratedNodes, totalSeconds / migratedNodes, rewardsDue, totalClaimed);\\n  }\\n\\n  function migrateNodes(address _entity, uint _packType, uint _nodeCount, uint _lastPaidAt, uint _rewardsDue, uint _totalClaimed) public returns (bool) {\\n    emit Created(_entity, _packType, _nodeCount, false, block.timestamp, msg.sender, _lastPaidAt);\\n\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n    uint256 c = a + b;\\n    if (c < a) return (false, 0);\\n    return (true, c);\\n  }\\n\\n  /**\\n   * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n    if (b > a) return (false, 0);\\n    return (true, a - b);\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) return (true, 0);\\n    uint256 c = a * b;\\n    if (c / a != b) return (false, 0);\\n    return (true, c);\\n  }\\n\\n  /**\\n   * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n    if (b == 0) return (false, 0);\\n    return (true, a / b);\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n    if (b == 0) return (false, 0);\\n    return (true, a % b);\\n  }\\n\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, \\\"SafeMath: addition overflow\\\");\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n    return a - b;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) return 0;\\n    uint256 c = a * b;\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers, reverting on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   *\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b > 0, \\\"SafeMath: division by zero\\\");\\n    return a / b;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * reverting when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   *\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n    return a % b;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\\n   * message unnecessarily. For custom revert reasons use {trySub}.\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    return a - b;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\\n   * message unnecessarily. For custom revert reasons use {tryDiv}.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   *\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    require(b > 0, errorMessage);\\n    return a / b;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * reverting with custom message when dividing by zero.\\n   *\\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\\n   * message unnecessarily. For custom revert reasons use {tryMod}.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   *\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    require(b > 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodesCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"usedCredit\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"migratedFrom\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastPaidAt\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"entity\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"fromNodeId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toPackId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nodeSeconds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSeconds\",\"type\":\"uint256\"}],\"name\":\"MigratedToNodePack\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"entityNodeClaimedTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"entityNodeCount\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"entityNodePaidOnBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"entity\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"nodeId\",\"type\":\"uint128\"}],\"name\":\"getNodeId\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getRewardAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrateAll\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_packType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nodeCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastPaidAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardsDue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalClaimed\",\"type\":\"uint256\"}],\"name\":\"migrateNodes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondsPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Test", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}