{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./ERC20Basic.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ERC20 interface\\r\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\r\\n */\\r\\ncontract ERC20  {\\r\\n     /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    \\r\\n    event Deposit(address indexed from, uint256 value);\\r\\n    \\r\\n    event Withdraw(address indexed to, uint256 value);\\r\\n    \\r\\n}\\r\\n\"},\"ERC20Basic.sol\":{\"content\":\"pragma solidity ^0.5.17;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ERC20Basic\\r\\n * @dev Simpler version of ERC20 interface\\r\\n * @dev see https://github.com/ethereum/EIPs/issues/179\\r\\n */\\r\\ncontract ERC20Basic {\\r\\n  /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    \\r\\n    event Deposit(address indexed from, uint256 value);\\r\\n    \\r\\n    event Withdraw(address indexed to, uint256 value);\\r\\n    \\r\\n}\\r\\n\"},\"FavorCoinCrowdsale.sol\":{\"content\":\"pragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./ERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @title FavorCoinCrowdsale\\r\\n * @dev Crowdsale is a base contract for managing a token crowdsale,\\r\\n * allowing investors to purchase tokens with ether. This contract implements\\r\\n * such functionality in its most fundamental form and can be extended to provide additional\\r\\n * functionality and/or custom behavior.\\r\\n * The external interface represents the basic interface for purchasing tokens, and conform\\r\\n * the base architecture for crowdsales. They are *not* intended to be modified / overriden.\\r\\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\\r\\n * the methods to add functionality. Consider using \\u0027super\\u0027 where appropiate to concatenate\\r\\n * behavior.\\r\\n */\\r\\ncontract FavorCoinCrowdsale is Ownable {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  // The token being sold\\r\\n  ERC20 public token;\\r\\n\\r\\n  // Address where funds are collected\\r\\n  address payable public wallet;\\r\\n\\r\\n  // How many token units a buyer gets per wei\\r\\n  uint256 public rate;\\r\\n\\r\\n  // Amount of wei raised\\r\\n  uint256 public weiRaised;\\r\\n  \\r\\n  uint256 public FEE = 1;\\r\\n  \\r\\n  uint256 public tokensSold;\\r\\n\\r\\n  /**\\r\\n   * Event for token purchase logging\\r\\n   * @param purchaser who paid for the tokens\\r\\n   * @param beneficiary who got the tokens\\r\\n   * @param value weis paid for purchase\\r\\n   * @param amount amount of tokens purchased\\r\\n   */\\r\\n  event TokenPurchase(\\r\\n    address indexed purchaser,\\r\\n    address indexed beneficiary,\\r\\n    uint256 value,\\r\\n    uint256 amount\\r\\n  );\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    \\r\\n    event FeeUpdated(uint256 newFee);\\r\\n    \\r\\n    event Deposit(address indexed from, uint256 value);\\r\\n  /**\\r\\n   * @param _rate Number of token units a buyer gets per wei\\r\\n   * @param _wallet Address where collected funds will be forwarded to\\r\\n   * @param _token Address of the token being sold\\r\\n   */\\r\\n  constructor(uint256 _rate, address payable  _wallet, address _token) public {\\r\\n    require(_rate \\u003e 0);\\r\\n    require(_wallet != address(0));\\r\\n    require(_token != address(0));\\r\\n\\r\\n    rate = _rate;\\r\\n    wallet = _wallet;\\r\\n    token = ERC20(_token);\\r\\n  }\\r\\n\\r\\n  // -----------------------------------------\\r\\n  // Crowdsale external interface\\r\\n  // -----------------------------------------\\r\\n\\r\\n  /**\\r\\n   * @dev fallback function ***DO NOT OVERRIDE***\\r\\n   */\\r\\n  function () external payable {\\r\\n    \\r\\n    buyTokens(msg.sender);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev low level token purchase ***DO NOT OVERRIDE***\\r\\n   * @param _beneficiary Address performing the token purchase\\r\\n   */\\r\\n  function buyTokens(address payable  _beneficiary) public payable {\\r\\n    require(msg.value != 0);\\r\\n    uint256 amountTobuy = msg.value;\\r\\n    uint256 dexBalance = token.balanceOf(address(this));\\r\\n    require(amountTobuy \\u003e 0, \\\"You need to send some ether\\\");\\r\\n    \\r\\n     _preValidatePurchase(_beneficiary, amountTobuy);\\r\\n    uint256 _fee = SafeMath.wdiv((SafeMath.wmul(amountTobuy,FEE)),1000);\\r\\n    uint256 _amountTobuy = SafeMath.sub(amountTobuy,_fee);\\r\\n     \\r\\n    // calculate token amount to be created\\r\\n    uint256 tokens = _getTokenAmount(_amountTobuy);\\r\\n    require(tokens \\u003c= dexBalance, \\\"Not enough tokens in the reserve\\\");\\r\\n \\r\\n    tokensSold = tokensSold.add(tokens);\\r\\n    // update state\\r\\n    weiRaised = weiRaised.add(amountTobuy);\\r\\n    emit Deposit(_beneficiary,tokens);\\r\\n    ERC20(token).transfer(address(_beneficiary), tokens);\\r\\n    emit Transfer(address(0),_beneficiary,tokens);\\r\\n    \\r\\n    emit TokenPurchase(\\r\\n      msg.sender,\\r\\n      _beneficiary,\\r\\n      amountTobuy,\\r\\n      tokens\\r\\n    );\\r\\n    \\r\\n\\r\\n    _updatePurchasingState(_beneficiary, amountTobuy);\\r\\n    \\r\\n     (bool success, bytes memory mem) = address(wallet).call.value(msg.value).gas(21000)(\\u0027\\u0027);\\r\\n        require(success);\\r\\n        \\r\\n  \\r\\n    _postValidatePurchase(_beneficiary, amountTobuy);\\r\\n  }\\r\\n  \\r\\n  function sendEther(address payable receiverAddr, uint256 _amount)  external onlyOwner {\\r\\n      if (!address(receiverAddr).send(_amount)) {\\r\\n          revert();\\r\\n      }\\r\\n  }\\r\\n\\r\\n  function sendETHMasterWallet(uint256 _amount) external onlyOwner {\\r\\n      (bool success, bytes memory mem) = address(wallet).call.value(_amount).gas(21000)(\\u0027\\u0027);\\r\\n        require(success);\\r\\n  }\\r\\n\\r\\n function setFee(uint _fee) external onlyOwner{\\r\\n        FEE = _fee;\\r\\n        emit FeeUpdated(FEE);\\r\\n    }\\r\\nfunction setWallet(address payable _wallet) external onlyOwner{\\r\\n    wallet = _wallet;\\r\\n    emit FeeUpdated(FEE);\\r\\n}\\r\\n  function tokensRemaining() public view returns (uint256){\\r\\n      return token.balanceOf(address(this));\\r\\n  }\\r\\n  \\r\\n\\r\\n  // -----------------------------------------\\r\\n  // Internal interface (extensible)\\r\\n  // -----------------------------------------\\r\\n\\r\\n  /**\\r\\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\\r\\n   * @param _beneficiary Address performing the token purchase\\r\\n   * @param _weiAmount Value in wei involved in the purchase\\r\\n   */\\r\\n  function _preValidatePurchase(\\r\\n    address _beneficiary,\\r\\n    uint256 _weiAmount\\r\\n  )\\r\\n    internal\\r\\n  {\\r\\n    require(_beneficiary != address(0));\\r\\n    require(_weiAmount != 0);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\\r\\n   * @param _beneficiary Address performing the token purchase\\r\\n   * @param _weiAmount Value in wei involved in the purchase\\r\\n   */\\r\\n  function _postValidatePurchase(\\r\\n    address _beneficiary,\\r\\n    uint256 _weiAmount\\r\\n  )\\r\\n    internal\\r\\n  {\\r\\n    // optional override\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\\r\\n   * @param _beneficiary Address performing the token purchase\\r\\n   * @param _tokenAmount Number of tokens to be emitted\\r\\n   */\\r\\n  function _deliverTokens(\\r\\n    address _beneficiary,\\r\\n    uint256 _tokenAmount\\r\\n  )\\r\\n    internal\\r\\n  {\\r\\n    token.transfer(_beneficiary, _tokenAmount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\\r\\n   * @param _beneficiary Address receiving the tokens\\r\\n   * @param _tokenAmount Number of tokens to be purchased\\r\\n   */\\r\\n  function _processPurchase(\\r\\n    address _beneficiary,\\r\\n    uint256 _tokenAmount\\r\\n  )\\r\\n    internal\\r\\n  {\\r\\n    _deliverTokens(_beneficiary, _tokenAmount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\\r\\n   * @param _beneficiary Address receiving the tokens\\r\\n   * @param _weiAmount Value in wei involved in the purchase\\r\\n   */\\r\\n  function _updatePurchasingState(\\r\\n    address _beneficiary,\\r\\n    uint256 _weiAmount\\r\\n  )\\r\\n    internal\\r\\n  {\\r\\n    // optional override\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Override to extend the way in which ether is converted to tokens.\\r\\n   * @param _weiAmount Value in wei to be converted into tokens\\r\\n   * @return Number of tokens that can be purchased with the specified _weiAmount\\r\\n   */\\r\\n  function _getTokenAmount(uint256 _weiAmount)\\r\\n    internal view returns (uint256)\\r\\n  {\\r\\n    return _weiAmount.div(rate);\\r\\n  }\\r\\n\\r\\n  \\r\\n}\\r\\n\"},\"FAVRSale.sol\":{\"content\":\"/**\\r\\n * \\r\\n * \\r\\n /$$$$$$$$ /$$$$$$  /$$    /$$  /$$$$$$  /$$$$$$$         /$$$$$$   /$$$$$$  /$$$$$$ /$$   /$$        /$$$$$$   /$$$$$$  /$$       /$$$$$$$$\\r\\n| $$_____//$$__  $$| $$   | $$ /$$__  $$| $$__  $$       /$$__  $$ /$$__  $$|_  $$_/| $$$ | $$       /$$__  $$ /$$__  $$| $$      | $$_____/\\r\\n| $$     | $$  \\\\ $$| $$   | $$| $$  \\\\ $$| $$  \\\\ $$      | $$  \\\\__/| $$  \\\\ $$  | $$  | $$$$| $$      | $$  \\\\__/| $$  \\\\ $$| $$      | $$      \\r\\n| $$$$$  | $$$$$$$$|  $$ / $$/| $$  | $$| $$$$$$$/      | $$      | $$  | $$  | $$  | $$ $$ $$      |  $$$$$$ | $$$$$$$$| $$      | $$$$$   \\r\\n| $$__/  | $$__  $$ \\\\  $$ $$/ | $$  | $$| $$__  $$      | $$      | $$  | $$  | $$  | $$  $$$$       \\\\____  $$| $$__  $$| $$      | $$__/   \\r\\n| $$     | $$  | $$  \\\\  $$$/  | $$  | $$| $$  \\\\ $$      | $$    $$| $$  | $$  | $$  | $$\\\\  $$$       /$$  \\\\ $$| $$  | $$| $$      | $$      \\r\\n| $$     | $$  | $$   \\\\  $/   |  $$$$$$/| $$  | $$      |  $$$$$$/|  $$$$$$/ /$$$$$$| $$ \\\\  $$      |  $$$$$$/| $$  | $$| $$$$$$$$| $$$$$$$$\\r\\n|__/     |__/  |__/    \\\\_/     \\\\______/ |__/  |__/       \\\\______/  \\\\______/ |______/|__/  \\\\__/       \\\\______/ |__/  |__/|________/|________/\\r\\n                                                                                                                                            \\r\\n                                                                  \u03b5\u0256\u0256\u03af\u03b5 \u0ab0\u03b5\u0122\u0122\u03af\u03b5 \u0135\u0398\u03b5\\r\\n * \\r\\n * \\r\\n\\r\\n *\\r\\n *\\r\\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\\r\\n */\\r\\n\\r\\n\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./IncreasingPriceCrowdsale.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./ERC20.sol\\\";\\r\\n\\r\\ncontract FavorCoinSale is IncreasingPriceCrowdsale {\\r\\n  uint256 public defaultCap;\\r\\n  mapping(address =\\u003e uint256) public contributions;\\r\\n  mapping(address =\\u003e uint256) public caps;\\r\\n\\r\\n  address  private ownerwallet;\\r\\n  constructor (\\r\\n    uint256 _openingTime,\\r\\n    uint256 _closingTime,\\r\\n    address payable _wallet,\\r\\n    address _token,\\r\\n    uint256 _initialRate,\\r\\n    uint256 _finalRate,\\r\\n    uint256 _walletCap\\r\\n  )\\r\\n    public\\r\\n    FavorCoinCrowdsale(_initialRate, _wallet, _token)\\r\\n    TimedCrowdsale(_openingTime, _closingTime)\\r\\n    IncreasingPriceCrowdsale(_initialRate, _finalRate)\\r\\n  {\\r\\n      ownerwallet=_wallet;\\r\\n      defaultCap = _walletCap;\\r\\n  }\\r\\n  \\r\\n  function closeSale() onlyOwner payable public{\\r\\n      uint256 contractTokenBalance = tokensRemaining();\\r\\n     \\r\\n      if(contractTokenBalance\\u003e0){\\r\\n        ERC20(token).transfer(ownerwallet,contractTokenBalance);  \\r\\n        emit Transfer(address(0),address(ownerwallet),contractTokenBalance);\\r\\n      }\\r\\n      (bool success, bytes memory mem) = address(wallet).call.value(address(this).balance).gas(21000)(\\u0027\\u0027);\\r\\n        require(success);\\r\\n     \\r\\n  }\\r\\n\\r\\n/**\\r\\n   * @dev Sets default user\\u0027s maximum contribution.\\r\\n   * @param _cap Wei limit for individual contribution\\r\\n   */\\r\\n  function setDefaultCap( uint256 _cap) external onlyOwner {\\r\\n      defaultCap = _cap;\\r\\n  }\\r\\n/**\\r\\n   * @dev Sets a specific user\\u0027s maximum contribution.\\r\\n   * @param _beneficiary Address to be capped\\r\\n   * @param _cap Wei limit for individual contribution\\r\\n   */\\r\\n  function setUserCap(address _beneficiary, uint256 _cap) external onlyOwner {\\r\\n    caps[_beneficiary] = _cap;\\r\\n  }\\r\\n/**\\r\\n   * Called from invest() to confirm if the curret investment does not break our cap rule.\\r\\n   */\\r\\n  function isBreakingCap(uint tokenAmount) public view  returns (bool limitBroken) {\\r\\n    if(tokenAmount \\u003e getTokensLeft()) {\\r\\n      return true;\\r\\n    } else {\\r\\n      return false;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * We are sold out when our approve pool becomes empty.\\r\\n   */\\r\\n  function isCrowdsaleFull() public view returns (bool) {\\r\\n    return getTokensLeft() == 0;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Get the amount of unsold tokens allocated to this contract;\\r\\n   */\\r\\n  function getTokensLeft() public view returns (uint) {\\r\\n    return token.allowance(owner, address(this));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Transfer tokens from approve() pool to the buyer.\\r\\n   *\\r\\n   * Use approve() given to this crowdsale to distribute the tokens.\\r\\n   */\\r\\n  function assignTokens(address receiver, uint tokenAmount) public onlyOwner {\\r\\n    if(!token.transferFrom(address(0), receiver, tokenAmount)) revert();\\r\\n  }\\r\\n  /**\\r\\n   * @dev Sets a group of users\\u0027 maximum contribution.\\r\\n   * @param _beneficiaries List of addresses to be capped\\r\\n   * @param _cap Wei limit for individual contribution\\r\\n   */\\r\\n  function setGroupCap(\\r\\n    address[] calldata  _beneficiaries,\\r\\n    uint256 _cap\\r\\n  )\\r\\n    external\\r\\n    onlyOwner\\r\\n  {\\r\\n    for (uint256 i = 0; i \\u003c _beneficiaries.length; i++) {\\r\\n      caps[_beneficiaries[i]] = _cap;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the cap of a specific user.\\r\\n   * @param _beneficiary Address whose cap is to be checked\\r\\n   * @return Current cap for individual user\\r\\n   */\\r\\n  function getUserCap(address _beneficiary) public view returns (uint256) {\\r\\n    return caps[_beneficiary];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the amount contributed so far by a sepecific user.\\r\\n   * @param _beneficiary Address of contributor\\r\\n   * @return User contribution so far\\r\\n   */\\r\\n  function getUserContribution(address _beneficiary)\\r\\n    public view returns (uint256)\\r\\n  {\\r\\n    return contributions[_beneficiary];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Extend parent behavior requiring purchase to respect the user\\u0027s funding cap.\\r\\n   * @param _beneficiary Token purchaser\\r\\n   * @param _weiAmount Amount of wei contributed\\r\\n   */\\r\\n  function _preValidatePurchase(\\r\\n    address _beneficiary,\\r\\n    uint256 _weiAmount\\r\\n  )\\r\\n    internal\\r\\n  {\\r\\n    super._preValidatePurchase(_beneficiary, _weiAmount);\\r\\n    if(caps[_beneficiary]==0){\\r\\n      caps[_beneficiary] = defaultCap;\\r\\n    }\\r\\n    require(contributions[_beneficiary].add(_weiAmount) \\u003c= caps[_beneficiary]);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Extend parent behavior to update user contributions\\r\\n   * @param _beneficiary Token purchaser\\r\\n   * @param _weiAmount Amount of wei contributed\\r\\n   */\\r\\n  function _updatePurchasingState(\\r\\n    address _beneficiary,\\r\\n    uint256 _weiAmount\\r\\n  )\\r\\n    internal\\r\\n  {\\r\\n    super._updatePurchasingState(_beneficiary, _weiAmount);\\r\\n    contributions[_beneficiary] = contributions[_beneficiary].add(_weiAmount);\\r\\n  }\\r\\n\\r\\n}\"},\"IncreasingPriceCrowdsale.sol\":{\"content\":\"pragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./TimedCrowdsale.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @title IncreasingPriceCrowdsale\\r\\n * @dev Extension of Crowdsale contract that increases the price of tokens linearly in time.\\r\\n * Note that what should be provided to the constructor is the initial and final _rates_, that is,\\r\\n * the amount of tokens per wei contributed. Thus, the initial rate must be greater than the final rate.\\r\\n */\\r\\ncontract IncreasingPriceCrowdsale is TimedCrowdsale {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  uint256 public initialRate;\\r\\n  uint256 public finalRate;\\r\\n\\r\\n  /**\\r\\n   * @dev Constructor, takes intial and final rates of tokens received per wei contributed.\\r\\n   * @param _initialRate Number of tokens a buyer gets per wei at the start of the crowdsale\\r\\n   * @param _finalRate Number of tokens a buyer gets per wei at the end of the crowdsale\\r\\n   */\\r\\n  constructor(uint256 _initialRate, uint256 _finalRate) public {\\r\\n    require(_initialRate \\u003e= _finalRate);\\r\\n    require(_finalRate \\u003e 0);\\r\\n    initialRate = _initialRate;\\r\\n    finalRate = _finalRate;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the rate of tokens per wei at the present time.\\r\\n   * Note that, as price _increases_ with time, the rate _decreases_.\\r\\n   * @return The number of tokens a buyer gets per wei at a given time\\r\\n   */\\r\\n  function getCurrentRate() public view returns (uint256) {\\r\\n    // solium-disable-next-line security/no-block-members\\r\\n    uint256 elapsedTime = block.timestamp.sub(openingTime);\\r\\n    uint256 timeRange = closingTime.sub(openingTime);\\r\\n    uint256 rateRange = initialRate.sub(finalRate);\\r\\n    return initialRate.sub(elapsedTime.mul(rateRange).div(timeRange));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Overrides parent method taking into account variable rate.\\r\\n   * @param _weiAmount The value in wei to be converted into tokens\\r\\n   * @return The number of tokens _weiAmount wei will buy at present time\\r\\n   */\\r\\n  function _getTokenAmount(uint256 _weiAmount)\\r\\n    internal view returns (uint256)\\r\\n  {\\r\\n    uint256 currentRate = getCurrentRate();\\r\\n    return (_weiAmount.div(currentRate)).mul(1 ether);\\r\\n  }\\r\\n\\r\\n}\\r\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.17;\\r\\n\\r\\n/**\\r\\n * @title Ownable\\r\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\r\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\r\\n */\\r\\ncontract Ownable {\\r\\n  address public owner;\\r\\n\\r\\n\\r\\n  event OwnershipRenounced(address indexed previousOwner);\\r\\n  event OwnershipTransferred(\\r\\n    address indexed previousOwner,\\r\\n    address indexed newOwner\\r\\n  );\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\r\\n   * account.\\r\\n   */\\r\\n  constructor() public {\\r\\n    owner = msg.sender;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev revert()s if called by any account other than the owner.\\r\\n   */\\r\\n  modifier onlyOwner() {\\r\\n    require(msg.sender == owner);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n   * @param newOwner The address to transfer ownership to.\\r\\n   */\\r\\n  function transferOwnership(address newOwner) public onlyOwner {\\r\\n    require(newOwner != address(0));\\r\\n    emit OwnershipTransferred(owner, newOwner);\\r\\n    owner = newOwner;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Allows the current owner to relinquish control of the contract.\\r\\n   */\\r\\n  function renounceOwnership() public onlyOwner {\\r\\n    emit OwnershipRenounced(owner);\\r\\n    owner = address(0);\\r\\n  }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.17;\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeMath\\r\\n * @dev Math operations with safety checks that throw on error\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\r\\n  /**\\r\\n  * @dev Multiplies two numbers, throws on overflow.\\r\\n  */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n    c = a * b;\\r\\n    assert(c / a == b);\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Integer division of two numbers, truncating the quotient.\\r\\n  */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\r\\n    // uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n    return a / b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\r\\n  */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    assert(b \\u003c= a);\\r\\n    return a - b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Adds two numbers, throws on overflow.\\r\\n  */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n    c = a + b;\\r\\n    assert(c \\u003e= a);\\r\\n    return c;\\r\\n  }\\r\\n  uint constant WAD = 10 ** 18;\\r\\n    uint constant RAY = 10 ** 27;\\r\\n\\r\\n    function rmul(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = add(mul(x, y), RAY / 2) / RAY;\\r\\n    }\\r\\n\\r\\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = add(mul(x, RAY), y / 2) / y;\\r\\n    }\\r\\n\\r\\n    function wmul(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = add(mul(x, y), WAD / 2) / WAD;\\r\\n    }\\r\\n\\r\\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\\r\\n        z = add(mul(x, WAD), y / 2) / y;\\r\\n    }\\r\\n    \\r\\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\\r\\n        uint256 c = add(a,m);\\r\\n        uint256 d = sub(c,1);\\r\\n        return mul(div(d,m),m);\\r\\n    }\\r\\n}\\r\\n\"},\"TimedCrowdsale.sol\":{\"content\":\"pragma solidity ^0.5.17;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./FavorCoinCrowdsale.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @title TimedCrowdsale\\r\\n * @dev Crowdsale accepting contributions only within a time frame.\\r\\n */\\r\\ncontract TimedCrowdsale is FavorCoinCrowdsale {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  uint256 public openingTime;\\r\\n  uint256 public closingTime;\\r\\n\\r\\n  /**\\r\\n   * @dev Reverts if not in crowdsale time range.\\r\\n   */\\r\\n  modifier onlyWhileOpen {\\r\\n    // solium-disable-next-line security/no-block-members\\r\\n    require(block.timestamp \\u003e= openingTime \\u0026\\u0026 block.timestamp \\u003c= closingTime);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Constructor, takes crowdsale opening and closing times.\\r\\n   * @param _openingTime Crowdsale opening time\\r\\n   * @param _closingTime Crowdsale closing time\\r\\n   */\\r\\n  constructor(uint256 _openingTime, uint256 _closingTime) public {\\r\\n    // solium-disable-next-line security/no-block-members\\r\\n    require(_openingTime \\u003e= block.timestamp);\\r\\n    require(_closingTime \\u003e= _openingTime);\\r\\n\\r\\n    openingTime = _openingTime;\\r\\n    closingTime = _closingTime;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\\r\\n   * @return Whether crowdsale period has elapsed\\r\\n   */\\r\\n  function hasClosed() public view returns (bool) {\\r\\n    // solium-disable-next-line security/no-block-members\\r\\n    return block.timestamp \\u003e closingTime;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Extend parent behavior requiring to be within contributing period\\r\\n   * @param _beneficiary Token purchaser\\r\\n   * @param _weiAmount Amount of wei contributed\\r\\n   */\\r\\n  function _preValidatePurchase(\\r\\n    address _beneficiary,\\r\\n    uint256 _weiAmount\\r\\n  )\\r\\n    internal\\r\\n    onlyWhileOpen\\r\\n  {\\r\\n    super._preValidatePurchase(_beneficiary, _weiAmount);\\r\\n  }\\r\\n\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_openingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initialRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_finalRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_walletCap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"FeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"assignTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"caps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeSale\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokensLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getUserCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getUserContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"isBreakingCap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"limitBroken\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCrowdsaleFull\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendETHMasterWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiverAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setDefaultCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_beneficiaries\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setGroupCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setUserCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FavorCoinSale", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000062438c270000000000000000000000000000000000000000000000000000000062e45f690000000000000000000000004b591c34d907020ebe37543aed1906d17f08b0e90000000000000000000000002e875a18060a00c4c3470b824e6cd22dfdf6ff0100000000000000000000000000000000000000000000000000000d7bd403f2a700000000000000000000000000000000000000000000000000000d7bd403f2a700000000000000000000000000000000000000000001ac806e7f06fea8180000", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://52d2a0fc055a1757000d0a5213aae706059160078477be10c825d1615863e629"}]}