{"status": "1", "message": "OK", "result": [{"SourceCode": "// Sources flattened with hardhat v2.6.1 https://hardhat.org\r\n\r\n// File contracts/interfaces/dao/ISmartWalletChecker.sol\r\n\r\n\r\n\r\npragma solidity 0.8.10;\r\n\r\ninterface ISmartWalletChecker {\r\n    function check(address _addr) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/interfaces/dao/ICollateralManager.sol\r\n\r\n\r\n\r\npragma solidity 0.8.10;\r\n\r\ninterface ICollateralManager {\r\n    function checkStatus(address _addr) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/interfaces/pool/IOwnership.sol\r\n\r\npragma solidity 0.8.10;\r\n\r\ninterface IOwnership {\r\n    function owner() external view returns (address);\r\n\r\n    function futureOwner() external view returns (address);\r\n\r\n    function commitTransferOwnership(address newOwner) external;\r\n\r\n    function acceptTransferOwnership() external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.4.1\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/security/ReentrancyGuard.sol@v4.4.1\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/VotingEscrow.sol\r\n\r\npragma solidity 0.8.10;\r\n\r\n/***\r\n *@title VotingEscrow\r\n *@author InsureDAO\r\n * SPDX-License-Identifier: MIT\r\n *@notice Votes have a weight depending on time, so that users are\r\n *        committed to the future of (whatever they are voting for)\r\n *@dev Vote weight decays linearly over time. Lock time cannot be\r\n *     more than `MAXTIME` (4 years).\r\n */\r\n\r\n// Voting escrow to have time-weighted votes\r\n// Votes have a weight depending on time, so that users are committed\r\n// to the future of (whatever they are voting for).\r\n// The weight in this implementation is linear, and lock cannot be more than maxtime\r\n// w ^\r\n// 1 +        /\r\n//   |      /\r\n//   |    /\r\n//   |  /\r\n//   |/\r\n// 0 +--------+------> time\r\n//       maxtime (4 years?)\r\n\r\n// Interface for checking whether address belongs to a whitelisted\r\n// type of a smart wallet.\r\n// When new types are added - the whole contract is changed\r\n// The check() method is modifying to be able to use caching\r\n// for individual wallet addresses\r\n\r\n\r\n//libraries\r\n\r\n\r\ncontract VotingEscrow is ReentrancyGuard {\r\n    struct Point {\r\n        int256 bias;\r\n        int256 slope; // - dweight / dt\r\n        uint256 ts; //timestamp\r\n        uint256 blk; // block\r\n    }\r\n    // We cannot really do block numbers per se b/c slope is per time, not per block\r\n    // and per block could be fairly bad b/c Ethereum changes blocktimes.\r\n    // What we can do is to extrapolate ***At functions\r\n\r\n    struct LockedBalance {\r\n        int256 amount;\r\n        uint256 end;\r\n    }\r\n\r\n    int256 constant DEPOSIT_FOR_TYPE = 0;\r\n    int256 constant CREATE_LOCK_TYPE = 1;\r\n    int256 constant INCREASE_LOCK_AMOUNT = 2;\r\n    int256 constant INCREASE_UNLOCK_TIME = 3;\r\n\r\n    event Deposit(\r\n        address indexed provider,\r\n        uint256 value,\r\n        uint256 indexed locktime,\r\n        int256 _type,\r\n        uint256 ts\r\n    );\r\n    event Withdraw(address indexed provider, uint256 value, uint256 ts);\r\n    event ForceUnlock(address target, uint256 value, uint256 ts);\r\n\r\n    event Supply(uint256 prevSupply, uint256 supply);\r\n\r\n    event commitWallet(address newSmartWalletChecker);\r\n    event applyWallet(address newSmartWalletChecker);\r\n    event commitCollateralManager(address newCollateralManager);\r\n    event applyCollateralManager(address newCollateralManager);\r\n\r\n    uint256 constant WEEK = 7 * 86400; // all future times are rounded by week\r\n    uint256 constant MAXTIME = 4 * 365 * 86400; // 4 years\r\n    uint256 constant MULTIPLIER = 10 ** 18;\r\n\r\n    address public token;\r\n    uint256 public supply;\r\n\r\n    mapping(address => LockedBalance) public locked;\r\n\r\n    //everytime user deposit/withdraw/change_locktime, these values will be updated;\r\n    uint256 public epoch;\r\n    Point[100000000000000000000000000000] public point_history; // epoch -> unsigned point.\r\n    mapping(address => Point[1000000000]) public user_point_history; // user -> Point[user_epoch]\r\n    mapping(address => uint256) public user_point_epoch;\r\n    mapping(uint256 => int256) public slope_changes; // time -> signed slope change\r\n\r\n    // Aragon's view methods for compatibility\r\n    address public controller;\r\n    bool public transfersEnabled;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    string public version;\r\n    uint256 public constant decimals = 18;\r\n\r\n    // Checker for whitelisted (smart contract) wallets which are allowed to deposit\r\n    // The goal is to prevent tokenizing the escrow\r\n    address public future_smart_wallet_checker;\r\n    address public smart_wallet_checker;\r\n\r\n    address public collateral_manager;\r\n    address public future_collateral_manager;\r\n\r\n    IOwnership public immutable ownership;\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            ownership.owner() == msg.sender,\r\n            \"Caller is not allowed to operate\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier checkStatus() {\r\n        if (collateral_manager != address(0)) {\r\n            require(\r\n                ICollateralManager(collateral_manager).checkStatus(msg.sender),\r\n                \"rejected by collateral manager\"\r\n            );\r\n        }\r\n        _;\r\n    }\r\n\r\n    /***\r\n     *@notice Contract constructor\r\n     *@param token_addr `InsureToken` token address\r\n     *@param _name Token name\r\n     *@param _symbol Token symbol\r\n     *@param _version Contract version - required for Aragon compatibility\r\n     */\r\n    constructor(\r\n        address _token_addr,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory _version,\r\n        address _ownership\r\n    ) {\r\n        ownership = IOwnership(_ownership);\r\n        token = _token_addr;\r\n        point_history[0].blk = block.number;\r\n        point_history[0].ts = block.timestamp;\r\n        controller = msg.sender;\r\n        transfersEnabled = true;\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n        version = _version;\r\n    }\r\n\r\n    /***\r\n     *@notice Check if the call is from a whitelisted smart contract, revert if not\r\n     *@param _addr Address to be checked\r\n     */\r\n    function assert_not_contract(address _addr) internal {\r\n        if (_addr != tx.origin) {\r\n            address checker = smart_wallet_checker; //not going to be deployed at the moment of launch.\r\n            if (checker != address(0)) {\r\n                if (ISmartWalletChecker(checker).check(_addr)) {\r\n                    return;\r\n                }\r\n            }\r\n            revert(\"contract depositors not allowed\");\r\n        }\r\n    }\r\n\r\n    /***\r\n     *@notice Get the most recently recorded rate of voting power decrease for `_addr`\r\n     *@param _addr Address of the user wallet\r\n     *@return Value of the slope\r\n     */\r\n    function get_last_user_slope(address _addr)\r\n    external\r\n    view\r\n    returns(uint256) {\r\n        uint256 uepoch = user_point_epoch[_addr];\r\n        return uint256(user_point_history[_addr][uepoch].slope);\r\n    }\r\n\r\n    /***\r\n     *@notice Get the timestamp for checkpoint `_idx` for `_addr`\r\n     *@param _addr User wallet address\r\n     *@param _idx User epoch number\r\n     *@return Epoch time of the checkpoint\r\n     */\r\n    function user_point_history__ts(address _addr, uint256 _idx)\r\n    external\r\n    view\r\n    returns(uint256) {\r\n        return user_point_history[_addr][_idx].ts;\r\n    }\r\n\r\n    /***\r\n     *@notice Get timestamp when `_addr`'s lock finishes\r\n     *@param _addr User wallet\r\n     *@return Epoch time of the lock end\r\n     */\r\n    function locked__end(address _addr) external view returns(uint256) {\r\n        return locked[_addr].end;\r\n    }\r\n\r\n    /***\r\n     *@notice Record global and per-user data to checkpoint\r\n     *@param _addr User's wallet address. No user checkpoint if 0x0\r\n     *@param _old_locked Pevious locked amount / end lock time for the user\r\n     *@param _new_locked New locked amount / end lock time for the user\r\n     */\r\n    function _checkpoint(\r\n        address _addr,\r\n        LockedBalance memory _old_locked,\r\n        LockedBalance memory _new_locked\r\n    ) internal {\r\n        Point memory _u_old;\r\n        Point memory _u_new;\r\n        int256 _old_dslope = 0;\r\n        int256 _new_dslope = 0;\r\n        uint256 _epoch = epoch;\r\n\r\n        if (_addr != address(0)) {\r\n            // Calculate slopes and biases\r\n            // Kept at zero when they have to\r\n            if (_old_locked.end > block.timestamp && _old_locked.amount > 0) {\r\n                unchecked {\r\n                    _u_old.slope = _old_locked.amount / int256(MAXTIME);\r\n                }\r\n                _u_old.bias =\r\n                    _u_old.slope *\r\n                    int256(_old_locked.end - block.timestamp);\r\n            }\r\n            if (_new_locked.end > block.timestamp && _new_locked.amount > 0) {\r\n                unchecked {\r\n                    _u_new.slope = _new_locked.amount / int256(MAXTIME);\r\n                }\r\n                _u_new.bias =\r\n                    _u_new.slope *\r\n                    int256(_new_locked.end - block.timestamp);\r\n            }\r\n\r\n            // Read values of scheduled changes in the slope\r\n            // _old_locked.end can be in the past and in the future\r\n            // _new_locked.end can ONLY by in the FUTURE unless everything expired than zeros\r\n            _old_dslope = slope_changes[_old_locked.end];\r\n            if (_new_locked.end != 0) {\r\n                if (_new_locked.end == _old_locked.end) {\r\n                    _new_dslope = _old_dslope;\r\n                } else {\r\n                    _new_dslope = slope_changes[_new_locked.end];\r\n                }\r\n            }\r\n        }\r\n        Point memory _last_point = Point({\r\n            bias: 0,\r\n            slope: 0,\r\n            ts: block.timestamp,\r\n            blk: block.number\r\n        });\r\n        if (_epoch > 0) {\r\n            _last_point = point_history[_epoch];\r\n        }\r\n        uint256 _last_checkpoint = _last_point.ts;\r\n        // _initial_last_point is used for extrapolation to calculate block number\r\n        // (approximately, for *At methods) and save them\r\n        // as we cannot figure that out exactly from inside the contract\r\n        Point memory _initial_last_point = _last_point;\r\n        uint256 _block_slope = 0; // dblock/dt\r\n        if (block.timestamp > _last_point.ts) {\r\n            _block_slope =\r\n                (MULTIPLIER * (block.number - _last_point.blk)) /\r\n                (block.timestamp - _last_point.ts);\r\n        }\r\n        // If last point is already recorded in this block, slope=0\r\n        // But that's ok b/c we know the block in such case\r\n\r\n        // Go over weeks to fill history and calculate what the current point is\r\n        uint256 _t_i;\r\n        unchecked {\r\n            _t_i = (_last_checkpoint / WEEK) * WEEK;\r\n        }\r\n        for (uint256 i; i < 255;) {\r\n            // Hopefully it won't happen that this won't get used in 5 years!\r\n            // If it does, users will be able to withdraw but vote weight will be broken\r\n            _t_i += WEEK;\r\n            int256 d_slope = 0;\r\n            if (_t_i > block.timestamp) {\r\n                _t_i = block.timestamp;\r\n            } else {\r\n                d_slope = slope_changes[_t_i];\r\n            }\r\n            _last_point.bias =\r\n                _last_point.bias -\r\n                _last_point.slope *\r\n                int256(_t_i - _last_checkpoint);\r\n            _last_point.slope += d_slope;\r\n            if (_last_point.bias < 0) {\r\n                // This can happen\r\n                _last_point.bias = 0;\r\n            }\r\n            if (_last_point.slope < 0) {\r\n                // This cannot happen - just in case\r\n                _last_point.slope = 0;\r\n            }\r\n            _last_checkpoint = _t_i;\r\n            _last_point.ts = _t_i;\r\n            _last_point.blk =\r\n                _initial_last_point.blk +\r\n                ((_block_slope * (_t_i - _initial_last_point.ts)) / MULTIPLIER);\r\n            _epoch += 1;\r\n            if (_t_i == block.timestamp) {\r\n                _last_point.blk = block.number;\r\n                break;\r\n            } else {\r\n                point_history[_epoch] = _last_point;\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        epoch = _epoch;\r\n        // Now point_history is filled until t=now\r\n\r\n        if (_addr != address(0)) {\r\n            // If last point was in this block, the slope change has been applied already\r\n            // But in such case we have 0 slope(s)\r\n            _last_point.slope += _u_new.slope - _u_old.slope;\r\n            _last_point.bias += _u_new.bias - _u_old.bias;\r\n            if (_last_point.slope < 0) {\r\n                _last_point.slope = 0;\r\n            }\r\n            if (_last_point.bias < 0) {\r\n                _last_point.bias = 0;\r\n            }\r\n        }\r\n        // Record the changed point into history\r\n        point_history[_epoch] = _last_point;\r\n\r\n        address _addr2 = _addr; //To avoid being \"Stack Too Deep\"\r\n\r\n        if (_addr2 != address(0)) {\r\n            // Schedule the slope changes (slope is going down)\r\n            // We subtract new_user_slope from [_new_locked.end]\r\n            // and add old_user_slope to [_old_locked.end]\r\n            if (_old_locked.end > block.timestamp) {\r\n                // _old_dslope was <something> - _u_old.slope, so we cancel that\r\n                _old_dslope += _u_old.slope;\r\n                if (_new_locked.end == _old_locked.end) {\r\n                    _old_dslope -= _u_new.slope; // It was a new deposit, not extension\r\n                }\r\n                slope_changes[_old_locked.end] = _old_dslope;\r\n            }\r\n            if (_new_locked.end > block.timestamp) {\r\n                if (_new_locked.end > _old_locked.end) {\r\n                    _new_dslope -= _u_new.slope; // old slope disappeared at this point\r\n                    slope_changes[_new_locked.end] = _new_dslope;\r\n                }\r\n                // else we recorded it already in _old_dslope\r\n            }\r\n\r\n            // Now handle user history\r\n            uint256 _user_epoch;\r\n            unchecked {\r\n                _user_epoch = user_point_epoch[_addr2] + 1;\r\n            }\r\n\r\n            user_point_epoch[_addr2] = _user_epoch;\r\n            _u_new.ts = block.timestamp;\r\n            _u_new.blk = block.number;\r\n            user_point_history[_addr2][_user_epoch] = _u_new;\r\n        }\r\n    }\r\n\r\n    /***\r\n     *@notice Deposit and lock tokens for a user\r\n     *@param _depositor Spender's wallet address\r\n     *@param _beneficiary Beneficiary's wallet address\r\n     *@param _value Amount to deposit\r\n     *@param _unlock_time New time when to unlock the tokens, or 0 if unchanged\r\n     *@param _locked_balance Previous locked amount / timestamp\r\n     */\r\n    function _deposit_for(\r\n        address _depositor,\r\n        address _beneficiary,\r\n        uint256 _value,\r\n        uint256 _unlock_time,\r\n        LockedBalance memory _locked_balance,\r\n        int256 _type\r\n    ) internal {\r\n        LockedBalance memory _locked = LockedBalance(\r\n            _locked_balance.amount,\r\n            _locked_balance.end\r\n        );\r\n        LockedBalance memory _old_locked = LockedBalance(\r\n            _locked_balance.amount,\r\n            _locked_balance.end\r\n        );\r\n\r\n        uint256 _supply_before = supply;\r\n        supply = _supply_before + _value;\r\n        //Adding to existing lock, or if a lock is expired - creating a new one\r\n        _locked.amount = _locked.amount + int256(_value);\r\n        if (_unlock_time != 0) {\r\n            _locked.end = _unlock_time;\r\n        }\r\n        locked[_beneficiary] = _locked;\r\n\r\n        // Possibilities\r\n        // Both _old_locked.end could be current or expired (>/< block.timestamp)\r\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\r\n        // _locked.end > block.timestamp (always)\r\n\r\n        _checkpoint(_beneficiary, _old_locked, _locked);\r\n\r\n        if (_value != 0) {\r\n            require(IERC20(token).transferFrom(_depositor, address(this), _value));\r\n        }\r\n\r\n        emit Deposit(_beneficiary, _value, _locked.end, _type, block.timestamp);\r\n        emit Supply(_supply_before, _supply_before + _value);\r\n    }\r\n\r\n    function checkpoint() public {\r\n        /***\r\n         *@notice Record global data to checkpoint\r\n         */\r\n        LockedBalance memory _a;\r\n        LockedBalance memory _b;\r\n        _checkpoint(address(0), _a, _b);\r\n    }\r\n\r\n    /***\r\n     *@notice Deposit `_value` tokens for `_addr` and add to the lock\r\n     *@dev Anyone (even a smart contract) can deposit for someone else, but\r\n     *    cannot extend their locktime and deposit for a brand new user\r\n     *@param _addr User's wallet address\r\n     *@param _value Amount to add to user's lock\r\n     */\r\n    function deposit_for(address _addr, uint256 _value) external nonReentrant {\r\n        LockedBalance memory _locked = locked[_addr];\r\n\r\n        require(_value > 0, \"dev: need non-zero value\");\r\n        require(_locked.amount > 0, \"No existing lock found\");\r\n        require(\r\n            _locked.end > block.timestamp,\r\n            \"Cannot add to expired lock.\"\r\n        );\r\n\r\n        _deposit_for(msg.sender, _addr, _value, 0, _locked, DEPOSIT_FOR_TYPE);\r\n    }\r\n\r\n    /***\r\n     *@notice Deposit `_value` tokens for `msg.sender` and lock until `_unlock_time`\r\n     *@param _value Amount to deposit\r\n     *@param _unlock_time Epoch time when tokens unlock, rounded down to whole weeks\r\n     */\r\n    function create_lock(uint256 _value, uint256 _unlock_time)external nonReentrant {\r\n        assert_not_contract(msg.sender);\r\n        _unlock_time = (_unlock_time / WEEK) * WEEK; // Locktime is rounded down to weeks\r\n        LockedBalance memory _locked = locked[msg.sender];\r\n\r\n        require(_value > 0, \"dev: need non-zero value\");\r\n        require(_locked.amount == 0, \"Withdraw old tokens first\");\r\n        require(\r\n            _unlock_time > block.timestamp,\r\n            \"Can lock until time in future\"\r\n        );\r\n        require(\r\n            _unlock_time <= block.timestamp + MAXTIME,\r\n            \"Voting lock can be 4 years max\"\r\n        );\r\n\r\n        _deposit_for(\r\n            msg.sender,\r\n            msg.sender,\r\n            _value,\r\n            _unlock_time,\r\n            _locked,\r\n            CREATE_LOCK_TYPE\r\n        );\r\n    }\r\n\r\n    /***\r\n     *@notice Deposit `_value` additional tokens for `msg.sender`\r\n     *        without modifying the unlock time\r\n     *@param _value Amount of tokens to deposit and add to the lock\r\n     */\r\n    function increase_amount(uint256 _value) external nonReentrant {\r\n        assert_not_contract(msg.sender);\r\n        LockedBalance memory _locked = locked[msg.sender];\r\n\r\n        require(_value > 0);\r\n        require(_locked.amount > 0, \"No existing lock found\");\r\n        require(\r\n            _locked.end > block.timestamp,\r\n            \"Cannot add to expired lock.\"\r\n        );\r\n\r\n        _deposit_for(msg.sender, msg.sender, _value, 0, _locked, INCREASE_LOCK_AMOUNT);\r\n    }\r\n\r\n    /***\r\n     *@notice Extend the unlock time for `msg.sender` to `_unlock_time`\r\n     *@param _unlock_time New epoch time for unlocking\r\n     */\r\n    function increase_unlock_time(uint256 _unlock_time) external nonReentrant {\r\n        assert_not_contract(msg.sender); //@shun: need to convert to solidity\r\n        LockedBalance memory _locked = locked[msg.sender];\r\n        unchecked {\r\n            _unlock_time = (_unlock_time / WEEK) * WEEK; // Locktime is rounded down to weeks\r\n        }\r\n\r\n        require(_locked.end > block.timestamp, \"Lock expired\");\r\n        require(_locked.amount > 0, \"Nothing is locked\");\r\n        require(_unlock_time > _locked.end, \"Can only increase lock duration\");\r\n        require(\r\n            _unlock_time <= block.timestamp + MAXTIME,\r\n            \"Voting lock can be 4 years max\"\r\n        );\r\n\r\n        _deposit_for(\r\n            msg.sender,\r\n            msg.sender,\r\n            0,\r\n            _unlock_time,\r\n            _locked,\r\n            INCREASE_UNLOCK_TIME\r\n        );\r\n    }\r\n\r\n    /***\r\n     *@notice Withdraw all tokens for `msg.sender`\r\n     *@dev Only possible if the lock has expired\r\n     */\r\n    function withdraw() external checkStatus nonReentrant {\r\n        LockedBalance memory _locked = LockedBalance(\r\n            locked[msg.sender].amount,\r\n            locked[msg.sender].end\r\n        );\r\n\r\n        require(block.timestamp >= _locked.end, \"The lock didn't expire\");\r\n        uint256 _value = uint256(_locked.amount);\r\n\r\n        LockedBalance memory _old_locked = LockedBalance(\r\n            locked[msg.sender].amount,\r\n            locked[msg.sender].end\r\n        );\r\n\r\n        _locked.end = 0;\r\n        _locked.amount = 0;\r\n        locked[msg.sender] = _locked;\r\n        uint256 _supply_before = supply;\r\n        supply = _supply_before - _value;\r\n\r\n        // _old_locked can have either expired <= timestamp or zero end\r\n        // _locked has only 0 end\r\n        // Both can have >= 0 amount\r\n        _checkpoint(msg.sender, _old_locked, _locked);\r\n\r\n        require(IERC20(token).transfer(msg.sender, _value));\r\n\r\n        emit Withdraw(msg.sender, _value, block.timestamp);\r\n        emit Supply(_supply_before, _supply_before - _value);\r\n    }\r\n\r\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\r\n    // They measure the weights for the purpose of voting, so they don't represent\r\n    // real coins.\r\n\r\n    /***\r\n     *@notice Binary search to estimate timestamp for block number\r\n     *@param _block Block to find\r\n     *@param _max_epoch Don't go beyond this epoch\r\n     *@return Approximate timestamp for block\r\n     */\r\n    function find_block_epoch(uint256 _block, uint256 _max_epoch) internal view returns(uint256) {\r\n        // Binary search\r\n        uint256 _min = 0;\r\n        uint256 _max = _max_epoch;\r\n        unchecked {\r\n            for (uint256 i; i <= 128; i++) {\r\n                // Will be always enough for 128-bit numbers\r\n                if (_min >= _max) {\r\n                    break;\r\n                }\r\n                uint256 _mid = (_min + _max + 1) / 2;\r\n                if (point_history[_mid].blk <= _block) {\r\n                    _min = _mid;\r\n                } else {\r\n                    _max = _mid - 1;\r\n                }\r\n            }\r\n        }\r\n        return _min;\r\n    }\r\n\r\n    /***\r\n     *@notice Get the current voting power for `msg.sender`\r\n     *@dev Adheres to the ERC20 `balanceOf` interface for Metamask & Snapshot compatibility\r\n     *@param _addr User wallet address\r\n     *@return User's present voting power\r\n     */\r\n    function balanceOf(address _addr) external view returns(uint256) {\r\n\r\n        uint256 _t = block.timestamp;\r\n\r\n        uint256 _epoch = user_point_epoch[_addr];\r\n        if (_epoch == 0) {\r\n            return 0;\r\n        } else {\r\n            Point memory _last_point = user_point_history[_addr][_epoch];\r\n            _last_point.bias -= _last_point.slope * int256(_t - _last_point.ts);\r\n            if (_last_point.bias < 0) {\r\n                _last_point.bias = 0;\r\n            }\r\n            return uint256(_last_point.bias);\r\n        }\r\n    }\r\n\r\n    /***\r\n     *@notice Get the current voting power for `msg.sender`\r\n     *@dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\r\n     *@param _addr User wallet address\r\n     *@param _t Epoch time to return voting power at\r\n     *@return User voting power\r\n     *@dev return the present voting power if _t is 0\r\n     */\r\n    function balanceOf(address _addr, uint256 _t) external view returns(uint256) {\r\n        if (_t == 0) {\r\n            _t = block.timestamp;\r\n        }\r\n\r\n        uint256 _epoch = user_point_epoch[_addr];\r\n        if (_epoch == 0) {\r\n            return 0;\r\n        } else {\r\n            Point memory _last_point = user_point_history[_addr][_epoch];\r\n            _last_point.bias -= _last_point.slope * int256(_t - _last_point.ts);\r\n            if (_last_point.bias < 0) {\r\n                _last_point.bias = 0;\r\n            }\r\n            return uint256(_last_point.bias);\r\n        }\r\n    }\r\n\r\n    //Struct to avoid \"Stack Too Deep\"\r\n    struct Parameters {\r\n        uint256 min;\r\n        uint256 max;\r\n        uint256 max_epoch;\r\n        uint256 d_block;\r\n        uint256 d_t;\r\n    }\r\n\r\n    /***\r\n     *@notice Measure voting power of `_addr` at block height `_block`\r\n     *@dev Adheres to MiniMe `balanceOfAt` interface https//github.com/Giveth/minime\r\n     *@param _addr User's wallet address\r\n     *@param _block Block to calculate the voting power at\r\n     *@return Voting power\r\n     */\r\n    function balanceOfAt(address _addr, uint256 _block) external view returns(uint256) {\r\n        // Copying and pasting totalSupply code because Vyper cannot pass by\r\n        // reference yet\r\n        require(_block <= block.number);\r\n\r\n        Parameters memory _st;\r\n\r\n        // Binary search\r\n        _st.min = 0;\r\n        _st.max = user_point_epoch[_addr];\r\n        unchecked {\r\n            for (uint256 i; i <= 128; i++) {\r\n                // Will be always enough for 128-bit numbers\r\n                if (_st.min >= _st.max) {\r\n                    break;\r\n                }\r\n                uint256 _mid = (_st.min + _st.max + 1) / 2;\r\n                if (user_point_history[_addr][_mid].blk <= _block) {\r\n                    _st.min = _mid;\r\n                } else {\r\n                    _st.max = _mid - 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        Point memory _upoint = user_point_history[_addr][_st.min];\r\n\r\n        _st.max_epoch = epoch;\r\n        uint256 _epoch = find_block_epoch(_block, _st.max_epoch);\r\n        Point memory _point_0 = point_history[_epoch];\r\n        _st.d_block = 0;\r\n        _st.d_t = 0;\r\n        if (_epoch < _st.max_epoch) {\r\n            Point memory _point_1 = point_history[_epoch + 1];\r\n            _st.d_block = _point_1.blk - _point_0.blk;\r\n            _st.d_t = _point_1.ts - _point_0.ts;\r\n        } else {\r\n            _st.d_block = block.number - _point_0.blk;\r\n            _st.d_t = block.timestamp - _point_0.ts;\r\n        }\r\n        uint256 block_time = _point_0.ts;\r\n        if (_st.d_block != 0) {\r\n            block_time += (_st.d_t * (_block - _point_0.blk)) / _st.d_block;\r\n        }\r\n\r\n        _upoint.bias -= _upoint.slope * int256(block_time - _upoint.ts);\r\n        if (_upoint.bias >= 0) {\r\n            return uint256(_upoint.bias);\r\n        }\r\n    }\r\n\r\n    /***\r\n     *@notice Calculate total voting power at some point in the past\r\n     *@param point The point (bias/slope) to start search from\r\n     *@param t Time to calculate the total voting power at\r\n     *@return Total voting power at that time\r\n     */\r\n    function supply_at(Point memory point, uint256 t) internal view returns(uint256) {\r\n        Point memory _last_point = point;\r\n        uint256 _t_i;\r\n        unchecked {\r\n            _t_i = (_last_point.ts / WEEK) * WEEK;\r\n        }\r\n        for (uint256 i; i < 255;) {\r\n            _t_i += WEEK;\r\n            int256 d_slope = 0;\r\n\r\n            if (_t_i > t) {\r\n                _t_i = t;\r\n            } else {\r\n                d_slope = slope_changes[_t_i];\r\n            }\r\n            _last_point.bias -=\r\n                _last_point.slope *\r\n                int256(_t_i - _last_point.ts);\r\n\r\n            if (_t_i == t) {\r\n                break;\r\n            }\r\n            _last_point.slope += d_slope;\r\n            _last_point.ts = _t_i;\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        if (_last_point.bias < 0) {\r\n            _last_point.bias = 0;\r\n        }\r\n        return uint256(_last_point.bias);\r\n    }\r\n\r\n    /***\r\n     *@notice Calculate total voting power\r\n     *@dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\r\n     *@return Total voting power\r\n     */\r\n\r\n    function totalSupply() external view returns(uint256) {\r\n        uint256 _epoch = epoch;\r\n        Point memory _last_point = point_history[_epoch];\r\n\r\n        return supply_at(_last_point, block.timestamp);\r\n    }\r\n\r\n    /***\r\n     *@notice Calculate total voting power\r\n     *@dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\r\n     *@return Total voting power\r\n     */\r\n    function totalSupply(uint256 _t) external view returns(uint256) {\r\n        if (_t == 0) {\r\n            _t = block.timestamp;\r\n        }\r\n\r\n        uint256 _epoch = epoch;\r\n        Point memory _last_point = point_history[_epoch];\r\n\r\n        return supply_at(_last_point, _t);\r\n    }\r\n\r\n    /***\r\n     *@notice Calculate total voting power at some point in the past\r\n     *@param _block Block to calculate the total voting power at\r\n     *@return Total voting power at `_block`\r\n     */\r\n    function totalSupplyAt(uint256 _block) external view returns(uint256) {\r\n        require(_block <= block.number);\r\n        uint256 _epoch = epoch;\r\n        uint256 _target_epoch = find_block_epoch(_block, _epoch);\r\n\r\n        Point memory _point = point_history[_target_epoch];\r\n        uint256 dt = 0;\r\n        if (_target_epoch < _epoch) {\r\n            Point memory _point_next = point_history[_target_epoch + 1];\r\n            if (_point.blk != _point_next.blk) {\r\n                dt =\r\n                    ((_block - _point.blk) * (_point_next.ts - _point.ts)) /\r\n                    (_point_next.blk - _point.blk);\r\n            }\r\n        } else {\r\n            if (_point.blk != block.number) {\r\n                dt =\r\n                    ((_block - _point.blk) * (block.timestamp - _point.ts)) /\r\n                    (block.number - _point.blk);\r\n            }\r\n        }\r\n        // Now dt contains info on how far are we beyond point\r\n\r\n        return supply_at(_point, _point.ts + dt);\r\n    }\r\n\r\n    /***\r\n     *@dev Dummy method required for Aragon compatibility\r\n     */\r\n    function changeController(address _newController) external {\r\n        require(msg.sender == controller);\r\n        controller = _newController;\r\n    }\r\n\r\n    function get_user_point_epoch(address _user)\r\n    external\r\n    view\r\n    returns(uint256) {\r\n        return user_point_epoch[_user];\r\n    }\r\n\r\n    //----------------------Investment module----------------------//\r\n\r\n    /***\r\n     *@notice unlock INSURE token without waiting for its end time.\r\n     *@param _target address of being unlocked.\r\n     *@return\r\n     */\r\n    function force_unlock(address _target) external returns(bool) {\r\n        require(\r\n            msg.sender == collateral_manager,\r\n            \"only collateral manager allowed\"\r\n        );\r\n\r\n        //withdraw\r\n        LockedBalance memory _locked = LockedBalance(\r\n            locked[_target].amount,\r\n            locked[_target].end\r\n        );\r\n        LockedBalance memory _old_locked = LockedBalance(\r\n            locked[_target].amount,\r\n            locked[_target].end\r\n        );\r\n\r\n        uint256 value = uint256(_locked.amount);\r\n\r\n        //there must be locked INSURE\r\n        require(value != 0, \"There is no locked INSURE\");\r\n\r\n        _locked.end = 0;\r\n        _locked.amount = 0;\r\n        locked[_target] = _locked;\r\n        uint256 _supply_before = supply;\r\n        supply = _supply_before - value;\r\n\r\n        _checkpoint(_target, _old_locked, _locked);\r\n\r\n        //transfer INSURE to collateral_manager\r\n        require(IERC20(token).transfer(collateral_manager, value));\r\n\r\n        emit ForceUnlock(_target, value, block.timestamp);\r\n        emit Supply(_supply_before, _supply_before - value);\r\n\r\n        return true;\r\n    }\r\n\r\n    //---------------------- Admin Only ----------------------//\r\n    /***\r\n     *@notice Set an external contract to check for approved smart contract wallets\r\n     *@param _addr Address of Smart contract checker\r\n     */\r\n    function commit_smart_wallet_checker(address _addr) external onlyOwner {\r\n        future_smart_wallet_checker = _addr;\r\n\r\n        emit commitWallet(_addr);\r\n    }\r\n\r\n    /***\r\n     *@notice Apply setting external contract to check approved smart contract wallets\r\n     */\r\n    function apply_smart_wallet_checker() external onlyOwner {\r\n        address _future_smart_wallet_checker = future_smart_wallet_checker;\r\n        smart_wallet_checker = _future_smart_wallet_checker;\r\n\r\n        emit commitWallet(_future_smart_wallet_checker);\r\n    }\r\n\r\n    /***\r\n     *@notice Commit setting external contract to check user's collateral status\r\n     */\r\n    function commit_collateral_manager(address _new_collateral_manager) external onlyOwner {\r\n        future_collateral_manager = _new_collateral_manager;\r\n\r\n        emit commitCollateralManager(_new_collateral_manager);\r\n    }\r\n\r\n    /***\r\n     *@notice Apply setting external contract to check user's collateral status\r\n     */\r\n    function apply_collateral_manager() external onlyOwner {\r\n        address _future_collateral_manager = future_collateral_manager;\r\n        collateral_manager = _future_collateral_manager;\r\n\r\n        emit applyCollateralManager(_future_collateral_manager);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token_addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_version\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_ownership\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"locktime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"_type\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"ForceUnlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"Supply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCollateralManager\",\"type\":\"address\"}],\"name\":\"applyCollateralManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSmartWalletChecker\",\"type\":\"address\"}],\"name\":\"applyWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCollateralManager\",\"type\":\"address\"}],\"name\":\"commitCollateralManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSmartWalletChecker\",\"type\":\"address\"}],\"name\":\"commitWallet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"apply_collateral_manager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"apply_smart_wallet_checker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_t\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"changeController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateral_manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new_collateral_manager\",\"type\":\"address\"}],\"name\":\"commit_collateral_manager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"commit_smart_wallet_checker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unlock_time\",\"type\":\"uint256\"}],\"name\":\"create_lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"deposit_for\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"force_unlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"future_collateral_manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"future_smart_wallet_checker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"get_last_user_slope\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"get_user_point_epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"increase_amount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_unlock_time\",\"type\":\"uint256\"}],\"name\":\"increase_unlock_time\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"locked__end\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownership\",\"outputs\":[{\"internalType\":\"contract IOwnership\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"point_history\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"bias\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"slope\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blk\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"slope_changes\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smart_wallet_checker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_t\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"totalSupplyAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transfersEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user_point_epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"user_point_history\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"bias\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"slope\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blk\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"user_point_history__ts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "VotingEscrow", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d83ae04c9ed29d6d3e6bf720c71bc7beb424393e00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000056246e83f3148b05ce2d90b44fbb4e9fa9eaf5bb0000000000000000000000000000000000000000000000000000000000000014566f74652d657363726f77656420494e5355524500000000000000000000000000000000000000000000000000000000000000000000000000000000000000087665494e53555245000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e7665494e535552455f312e302e30000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://88ab34ec02e763bc916ab97f571f78b9a3d33e371fb4e9af9b42ae08d100e739"}]}