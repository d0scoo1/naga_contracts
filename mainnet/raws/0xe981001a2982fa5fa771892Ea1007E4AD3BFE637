{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libraries/PeriodStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// (C) Florence Finance, 2022 - https://florence.finance/\\npragma solidity 0.8.9;\\n\\nimport \\\"./Util.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\n/// @title Period staking contract\\n/// @dev this library contains all funcionality related to the period staking mechanism\\n/// Lending Pool Token (LPT) owner stake their LPTs within an active staking period (e.g. staking period could be three months)\\n/// The LPTs can remain staked over several consecutive periods while accumulating staking rewards (currently USDC token).\\n/// The amount of staking rewards depends on the total staking score per staking period of the LPT owner address and\\n/// on the total amount of rewards distrubuted for this staking period\\n/// E.g. Staking period is 90 days and total staking rewards is 900 USDC\\n/// LPT staker 1 stakes 100 LPTs during the whole 90 days\\n/// LPT staker 2 starts staking after 45 days and stakes 100 LPTs until the end of the staking period\\n/// staker 1 staking score is 600 and staker 2 staking score is 300\\n/// staker 1 claims 600 USDC after staking period is completed\\n/// staker 2 claims 300 USDC after staking period is completed\\n/// the staking rewards need to be claimed actively after each staking period is completed and the total rewards have been deposited to the contract by the Borrower\\n\\nlibrary PeriodStaking {\\n    event StakedPeriod(address indexed staker, IERC20 indexed stakableToken, uint256 amount);\\n    event UnstakedPeriod(address indexed unstaker, IERC20 indexed stakedToken, uint256 amount, uint256 totalStakedBalance);\\n    event ClaimedRewardsPeriod(address indexed claimer, IERC20 stakedToken, IERC20 rewardToken, uint256 amount);\\n    event ChangedEndRewardPeriod(uint256 indexed _periodId, uint256 _periodStart, uint256 _periodEnd);\\n\\n    struct PeriodStakingStorage {\\n        mapping(uint256 => RewardPeriod) rewardPeriods;\\n        mapping(address => WalletStakingState) walletStakedAmounts;\\n        mapping(uint256 => mapping(address => uint256)) walletStakingScores;\\n        uint256 currentRewardPeriodId;\\n        uint256 duration;\\n        IERC20 rewardToken;\\n        mapping(uint256 => mapping(address => uint256)) walletRewardableCapital;\\n    }\\n\\n    struct RewardPeriod {\\n        uint256 id;\\n        uint256 start;\\n        uint256 end;\\n        uint256 totalRewards;\\n        uint256 totalStakingScore;\\n        uint256 finalStakedAmount;\\n        IERC20 rewardToken;\\n    }\\n\\n    struct WalletStakingState {\\n        uint256 stakedBalance;\\n        uint256 lastUpdate;\\n        mapping(IERC20 => uint256) outstandingRewards;\\n    }\\n\\n    /// @dev Get the struct/info of all reward periods\\n    /// @param periodStakingStorage pointer to period staking storage struct\\n    /// @return returns the array including all reward period structs\\n    function getRewardPeriods(PeriodStakingStorage storage periodStakingStorage) external view returns (RewardPeriod[] memory) {\\n        RewardPeriod[] memory rewardPeriodsArray = new RewardPeriod[](periodStakingStorage.currentRewardPeriodId);\\n\\n        for (uint256 i = 1; i <= periodStakingStorage.currentRewardPeriodId; i++) {\\n            RewardPeriod storage rewardPeriod = periodStakingStorage.rewardPeriods[i];\\n            rewardPeriodsArray[i - 1] = rewardPeriod;\\n        }\\n        return rewardPeriodsArray;\\n    }\\n\\n    /// @dev End the current reward period\\n    /// @param periodEnd block number of new end of the current reward period\\n    /// periodEnd == 0 sets current reward period end to current block number\\n    function setEndRewardPeriod(PeriodStakingStorage storage periodStakingStorage, uint256 periodEnd) external {\\n        RewardPeriod storage currentRewardPeriod = periodStakingStorage.rewardPeriods[periodStakingStorage.currentRewardPeriodId];\\n        require(currentRewardPeriod.id > 0, \\\"no reward periods\\\");\\n        require(currentRewardPeriod.start < block.number && currentRewardPeriod.end > block.number, \\\"not inside any reward period\\\");\\n\\n        if (periodEnd == 0) {\\n            currentRewardPeriod.end = block.number;\\n        } else {\\n            require(periodEnd >= block.number, \\\"end of period in the past\\\");\\n            currentRewardPeriod.end = periodEnd;\\n        }\\n        emit ChangedEndRewardPeriod(currentRewardPeriod.id, currentRewardPeriod.start, currentRewardPeriod.end);\\n    }\\n\\n    /// @dev Start the next reward period\\n    /// @param periodStakingStorage pointer to period staking storage struct\\n    /// @param periodStart start block of the period, 0 == follow previous period, 1 == start at current block, >1 use passed value\\n    function startNextRewardPeriod(PeriodStakingStorage storage periodStakingStorage, uint256 periodStart) external {\\n        require(periodStakingStorage.duration > 0 && address(periodStakingStorage.rewardToken) != address(0), \\\"duration and/or rewardToken not configured\\\");\\n\\n        RewardPeriod storage currentRewardPeriod = periodStakingStorage.rewardPeriods[periodStakingStorage.currentRewardPeriodId];\\n        if (periodStakingStorage.currentRewardPeriodId > 0) {\\n            require(currentRewardPeriod.end > 0 && currentRewardPeriod.end < block.number, \\\"current period has not ended yet\\\");\\n        }\\n        periodStakingStorage.currentRewardPeriodId += 1;\\n        RewardPeriod storage nextRewardPeriod = periodStakingStorage.rewardPeriods[periodStakingStorage.currentRewardPeriodId];\\n        nextRewardPeriod.rewardToken = periodStakingStorage.rewardToken;\\n\\n        nextRewardPeriod.id = periodStakingStorage.currentRewardPeriodId;\\n\\n        if (periodStart == 0) {\\n            nextRewardPeriod.start = currentRewardPeriod.end != 0 ? currentRewardPeriod.end : block.number;\\n        } else if (periodStart == 1) {\\n            nextRewardPeriod.start = block.number;\\n        } else {\\n            nextRewardPeriod.start = periodStart;\\n        }\\n\\n        nextRewardPeriod.end = nextRewardPeriod.start + periodStakingStorage.duration;\\n        nextRewardPeriod.finalStakedAmount = currentRewardPeriod.finalStakedAmount;\\n        nextRewardPeriod.totalStakingScore = currentRewardPeriod.finalStakedAmount * (nextRewardPeriod.end - nextRewardPeriod.start);\\n    }\\n\\n    /// @dev Deposit the rewards (USDC token) for a reward period\\n    /// @param periodStakingStorage pointer to period staking storage struct\\n    /// @param rewardPeriodId The ID of the reward period\\n    /// @param _totalRewards total amount of period rewards to deposit\\n    function depositRewardPeriodRewards(\\n        PeriodStakingStorage storage periodStakingStorage,\\n        uint256 rewardPeriodId,\\n        uint256 _totalRewards\\n    ) public {\\n        RewardPeriod storage rewardPeriod = periodStakingStorage.rewardPeriods[rewardPeriodId];\\n\\n        require(rewardPeriod.end > 0 && rewardPeriod.end < block.number, \\\"period has not ended\\\");\\n\\n        periodStakingStorage.rewardPeriods[rewardPeriodId].totalRewards = Util.checkedTransferFrom(rewardPeriod.rewardToken, msg.sender, address(this), _totalRewards);\\n    }\\n\\n    /// @dev Updates the staking score for a wallet over all staking periods\\n    /// @param periodStakingStorage pointer to period staking storage struct\\n    function updatePeriod(PeriodStakingStorage storage periodStakingStorage) internal {\\n        WalletStakingState storage walletStakedAmount = periodStakingStorage.walletStakedAmounts[msg.sender];\\n        if (walletStakedAmount.stakedBalance > 0 && walletStakedAmount.lastUpdate < periodStakingStorage.currentRewardPeriodId && walletStakedAmount.lastUpdate > 0) {\\n            uint256 i = walletStakedAmount.lastUpdate + 1;\\n            for (; i <= periodStakingStorage.currentRewardPeriodId; i++) {\\n                RewardPeriod storage rewardPeriod = periodStakingStorage.rewardPeriods[i];\\n                periodStakingStorage.walletStakingScores[i][msg.sender] = walletStakedAmount.stakedBalance * (rewardPeriod.end - rewardPeriod.start);\\n                periodStakingStorage.walletRewardableCapital[i][msg.sender] = walletStakedAmount.stakedBalance;\\n            }\\n        }\\n        walletStakedAmount.lastUpdate = periodStakingStorage.currentRewardPeriodId;\\n    }\\n\\n    /// @dev Calculate the staking score for a wallet for a given rewards period\\n    /// @param periodStakingStorage pointer to period staking storage struct\\n    /// @param wallet wallet address\\n    /// @param period period ID for which to calculate the staking rewards\\n    /// @return wallet staking score for a given rewards period\\n    function getWalletRewardPeriodStakingScore(\\n        PeriodStakingStorage storage periodStakingStorage,\\n        address wallet,\\n        uint256 period\\n    ) public view returns (uint256) {\\n        WalletStakingState storage walletStakedAmount = periodStakingStorage.walletStakedAmounts[wallet];\\n        RewardPeriod storage rewardPeriod = periodStakingStorage.rewardPeriods[period];\\n        if (walletStakedAmount.lastUpdate > 0 && walletStakedAmount.lastUpdate < period) {\\n            return walletStakedAmount.stakedBalance * (rewardPeriod.end - rewardPeriod.start);\\n        } else {\\n            return periodStakingStorage.walletStakingScores[period][wallet];\\n        }\\n    }\\n\\n    /// @dev Stake Lending Pool Token in current rewards period\\n    /// @notice emits event StakedPeriod\\n    /// @param periodStakingStorage pointer to period staking storage struct\\n    /// @param amount amount of LPT to stake\\n    /// @param lendingPoolToken Lending Pool Token address\\n    function stakeRewardPeriod(\\n        PeriodStakingStorage storage periodStakingStorage,\\n        uint256 amount,\\n        IERC20 lendingPoolToken\\n    ) external {\\n        RewardPeriod storage currentRewardPeriod = periodStakingStorage.rewardPeriods[periodStakingStorage.currentRewardPeriodId];\\n        require(currentRewardPeriod.start <= block.number && currentRewardPeriod.end > block.number, \\\"no active period\\\");\\n\\n        updatePeriod(periodStakingStorage);\\n\\n        amount = Util.checkedTransferFrom(lendingPoolToken, msg.sender, address(this), amount);\\n        emit StakedPeriod(msg.sender, lendingPoolToken, amount);\\n\\n        periodStakingStorage.walletStakedAmounts[msg.sender].stakedBalance += amount;\\n\\n        currentRewardPeriod.finalStakedAmount += amount;\\n\\n        currentRewardPeriod.totalStakingScore += (currentRewardPeriod.end - block.number) * amount;\\n\\n        periodStakingStorage.walletStakingScores[periodStakingStorage.currentRewardPeriodId][msg.sender] += (currentRewardPeriod.end - block.number) * amount;\\n        uint256 value = calculateRewardableCapital(currentRewardPeriod, amount, false);\\n        periodStakingStorage.walletRewardableCapital[periodStakingStorage.currentRewardPeriodId][msg.sender] += value;\\n    }\\n\\n    /// @dev Unstake Lending Pool Token\\n    /// @notice emits event UnstakedPeriod\\n    /// @param periodStakingStorage pointer to period staking storage struct\\n    /// @param amount amount of LPT to unstake\\n    /// @param lendingPoolToken Lending Pool Token address\\n    function unstakeRewardPeriod(\\n        PeriodStakingStorage storage periodStakingStorage,\\n        uint256 amount,\\n        IERC20 lendingPoolToken\\n    ) external {\\n        require(amount <= periodStakingStorage.walletStakedAmounts[msg.sender].stakedBalance, \\\"amount greater than staked amount\\\");\\n        updatePeriod(periodStakingStorage);\\n\\n        RewardPeriod storage currentRewardPeriod = periodStakingStorage.rewardPeriods[periodStakingStorage.currentRewardPeriodId];\\n\\n        periodStakingStorage.walletStakedAmounts[msg.sender].stakedBalance -= amount;\\n        currentRewardPeriod.finalStakedAmount -= amount;\\n        if (currentRewardPeriod.end > block.number) {\\n            currentRewardPeriod.totalStakingScore -= (currentRewardPeriod.end - block.number) * amount;\\n            periodStakingStorage.walletStakingScores[periodStakingStorage.currentRewardPeriodId][msg.sender] -= (currentRewardPeriod.end - block.number) * amount;\\n            uint256 value = calculateRewardableCapital(currentRewardPeriod, amount, false);\\n            periodStakingStorage.walletRewardableCapital[periodStakingStorage.currentRewardPeriodId][msg.sender] -= value;\\n        }\\n        lendingPoolToken.transfer(msg.sender, amount);\\n        emit UnstakedPeriod(msg.sender, lendingPoolToken, amount, periodStakingStorage.walletStakedAmounts[msg.sender].stakedBalance);\\n    }\\n\\n    /// @dev Claim rewards (USDC) for a certain staking period\\n    /// @notice emits event ClaimedRewardsPeriod\\n    /// @param periodStakingStorage pointer to period staking storage struct\\n    /// @param rewardPeriodId period ID of which to claim staking rewards\\n    /// @param lendingPoolToken Lending Pool Token address\\n    function claimRewardPeriod(\\n        PeriodStakingStorage storage periodStakingStorage,\\n        uint256 rewardPeriodId,\\n        IERC20 lendingPoolToken\\n    ) external {\\n        RewardPeriod storage rewardPeriod = periodStakingStorage.rewardPeriods[rewardPeriodId];\\n        require(rewardPeriod.end > 0 && rewardPeriod.end < block.number && rewardPeriod.totalRewards > 0, \\\"period not ready for claiming\\\");\\n        updatePeriod(periodStakingStorage);\\n\\n        require(periodStakingStorage.walletStakingScores[rewardPeriodId][msg.sender] > 0, \\\"no rewards to claim\\\");\\n\\n        uint256 payableRewardAmount = calculatePeriodRewards(\\n            rewardPeriod.rewardToken,\\n            rewardPeriod.totalRewards,\\n            rewardPeriod.totalStakingScore,\\n            periodStakingStorage.walletStakingScores[rewardPeriodId][msg.sender]\\n        );\\n        periodStakingStorage.walletStakingScores[rewardPeriodId][msg.sender] = 0;\\n\\n        // This condition can never be true, because:\\n        // calculateRewardsPeriod can never have a walletStakingScore > totalPeriodStakingScore\\n        // require(payableRewardAmount > 0, \\\"no rewards to claim\\\");\\n\\n        rewardPeriod.rewardToken.transfer(msg.sender, payableRewardAmount);\\n        emit ClaimedRewardsPeriod(msg.sender, lendingPoolToken, rewardPeriod.rewardToken, payableRewardAmount);\\n    }\\n\\n    /// @dev Calculate the staking rewards of a staking period for a wallet address\\n    /// @param periodStakingStorage pointer to period staking storage struct\\n    /// @param rewardPeriodId period ID for which to calculate the rewards\\n    /// @param projectedTotalRewards The amount of total rewards which is planned to be deposited at the end of the staking period\\n    /// @return returns the amount of staking rewards for a wallet address for a certain staking period\\n    function calculateWalletRewardsPeriod(\\n        PeriodStakingStorage storage periodStakingStorage,\\n        address wallet,\\n        uint256 rewardPeriodId,\\n        uint256 projectedTotalRewards\\n    ) public view returns (uint256) {\\n        RewardPeriod storage rewardPeriod = periodStakingStorage.rewardPeriods[rewardPeriodId];\\n        if (projectedTotalRewards == 0) {\\n            projectedTotalRewards = rewardPeriod.totalRewards;\\n        }\\n        return\\n            calculatePeriodRewards(\\n                rewardPeriod.rewardToken,\\n                projectedTotalRewards,\\n                rewardPeriod.totalStakingScore,\\n                getWalletRewardPeriodStakingScore(periodStakingStorage, wallet, rewardPeriodId)\\n            );\\n    }\\n\\n    function calculateWalletRewardsYieldPeriod(\\n        PeriodStakingStorage storage periodStakingStorage,\\n        address wallet,\\n        uint256 rewardPeriodId,\\n        uint256 yieldPeriod,\\n        IERC20 lendingPoolToken\\n    ) public view returns (uint256) {\\n        RewardPeriod storage rewardPeriod = periodStakingStorage.rewardPeriods[rewardPeriodId];\\n        if (rewardPeriod.id == 0) return 0; // request for non-existent periodID\\n\\n        if (rewardPeriod.totalRewards != 0) {\\n            return calculateWalletRewardsPeriod(periodStakingStorage, wallet, rewardPeriodId, rewardPeriod.totalRewards);\\n        }\\n\\n        uint256 walletRewardableCapital = periodStakingStorage.walletRewardableCapital[rewardPeriod.id][wallet];\\n        uint256 currentStakedBalance = periodStakingStorage.walletStakedAmounts[wallet].stakedBalance;\\n\\n        if (currentStakedBalance != 0 && walletRewardableCapital == 0) {\\n            walletRewardableCapital = calculateRewardableCapital(rewardPeriod, currentStakedBalance, true);\\n        } else if (rewardPeriod.end > block.number) {\\n            walletRewardableCapital -= calculateRewardableCapital(rewardPeriod, currentStakedBalance, false);\\n        }\\n\\n        uint256 walletRewards18 = (walletRewardableCapital * yieldPeriod) / 10000 / 100;\\n        return Util.convertDecimalsERC20(walletRewards18, lendingPoolToken, rewardPeriod.rewardToken);\\n    }\\n\\n    /// @dev Calculate the total amount of payable rewards\\n    /// @param rewardToken The reward token (e.g. USDC)\\n    /// @param totalPeriodRewards The total amount of rewards for a certain period\\n    /// @param totalPeriodStakingScore The total staking score (of all wallet addresses during a certain staking period)\\n    /// @param walletStakingScore The total staking score (of one wallet address during a certain staking period)\\n    /// @return returns the total payable amount of staking rewards\\n    function calculatePeriodRewards(\\n        IERC20 rewardToken,\\n        uint256 totalPeriodRewards,\\n        uint256 totalPeriodStakingScore,\\n        uint256 walletStakingScore\\n    ) public view returns (uint256) {\\n        if (totalPeriodStakingScore == 0) {\\n            return 0;\\n        }\\n        uint256 rewardTokenDecimals = Util.getERC20Decimals(rewardToken);\\n\\n        uint256 _numerator = (walletStakingScore * totalPeriodRewards) * 10**(rewardTokenDecimals + 1);\\n        // with rounding of last digit\\n        uint256 payableRewardAmount = ((_numerator / totalPeriodStakingScore) + 5) / 10;\\n\\n        return payableRewardAmount / (uint256(10)**rewardTokenDecimals);\\n    }\\n\\n    function calculateRewardableCapital(\\n        RewardPeriod memory rewardPeriod,\\n        uint256 amount,\\n        bool invert\\n    ) internal view returns (uint256) {\\n        uint256 blockNumber = block.number;\\n        if (block.number > rewardPeriod.end) {\\n            // if (invert) {\\n            blockNumber = rewardPeriod.end;\\n            // } else {\\n            //     blockNumber = rewardPeriod.start;\\n            // }\\n        }\\n        uint256 stakingDuration;\\n        if (invert) {\\n            stakingDuration = (blockNumber - rewardPeriod.start) * 10**18;\\n        } else {\\n            stakingDuration = (rewardPeriod.end - blockNumber) * 10**18;\\n        }\\n        uint256 periodDuration = (rewardPeriod.end - rewardPeriod.start);\\n\\n        if (periodDuration == 0 || stakingDuration == 0 || amount == 0) {\\n            return 0;\\n        }\\n        return (amount * (stakingDuration / periodDuration)) / 10**18;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Util.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// (C) Florence Finance, 2022 - https://florence.finance/\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nlibrary Util {\\n    /// @dev Return the decimals of an ERC20 token (if the implementations offers it)\\n    /// @param _token (IERC20) the ERC20 token\\n    /// @return  (uint8) the decimals\\n    function getERC20Decimals(IERC20 _token) internal view returns (uint8) {\\n        return IERC20Metadata(address(_token)).decimals();\\n    }\\n\\n    function checkedTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        require(amount > 0, \\\"checkedTransferFrom: amount zero\\\");\\n        uint256 balanceBefore = token.balanceOf(to);\\n        token.transferFrom(from, to, amount);\\n        uint256 receivedAmount = token.balanceOf(to) - balanceBefore;\\n        require(receivedAmount == amount, \\\"checkedTransferFrom: not amount\\\");\\n        return receivedAmount;\\n    }\\n\\n    /// @dev A checked Token transfer; raises if the token transfer amount is not equal to the transferred amount\\n    /// this might happen if the token ERC20 contract is hacked\\n    /// @param token (address) the address of the ERC20 token to transfer\\n    /// @param to (address) receiver address\\n    /// @param amount (uint256) the desired amount to transfer\\n    /// @return  (uint256) the received amount that was transferred\\n    /// IMPORTANT: the return value will only be returned to another smart contract,\\n    /// but never to the testing environment, because if the transaction goes through,\\n    /// a receipt is returned and not a (uint256)\\n    function checkedTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        require(amount > 0, \\\"checkedTransfer: amount zero\\\");\\n        uint256 balanceBefore = token.balanceOf(to);\\n        token.transfer(to, amount);\\n        uint256 receivedAmount = token.balanceOf(to) - balanceBefore;\\n        require(receivedAmount == amount, \\\"checkedTransfer: not amount\\\");\\n        return receivedAmount;\\n    }\\n\\n    /// @dev Converts a number from one decimal precision to the other\\n    /// @param _number (uint256) the number\\n    /// @param _currentDecimals (uint256) the current decimals of the number\\n    /// @param _targetDecimals (uint256) the desired decimals for the number\\n    /// @return  (uint256) the number with _targetDecimals decimals\\n    function convertDecimals(\\n        uint256 _number,\\n        uint256 _currentDecimals,\\n        uint256 _targetDecimals\\n    ) internal pure returns (uint256) {\\n        uint256 diffDecimals;\\n\\n        uint256 amountCorrected = _number;\\n\\n        if (_targetDecimals < _currentDecimals) {\\n            diffDecimals = _currentDecimals - _targetDecimals;\\n            amountCorrected = _number / (uint256(10)**diffDecimals);\\n        } else if (_targetDecimals > _currentDecimals) {\\n            diffDecimals = _targetDecimals - _currentDecimals;\\n            amountCorrected = _number * (uint256(10)**diffDecimals);\\n        }\\n\\n        return (amountCorrected);\\n    }\\n\\n    /// @dev Converts a number from one decimal precision to the other based on two ERC20 Tokens\\n    /// @param _number (uint256) the number\\n    /// @param _sourceToken (address) the source ERC20 Token\\n    /// @param _targetToken (address) the target ERC20 Token\\n    /// @return  (uint256) the number with _targetDecimals decimals\\n    function convertDecimalsERC20(\\n        uint256 _number,\\n        IERC20 _sourceToken,\\n        IERC20 _targetToken\\n    ) internal view returns (uint256) {\\n        return convertDecimals(_number, getERC20Decimals(_sourceToken), getERC20Decimals(_targetToken));\\n    }\\n\\n    function removeValueFromArray(IERC20 value, IERC20[] storage array) internal {\\n        bool shift = false;\\n        uint256 i = 0;\\n        while (i < array.length - 1) {\\n            if (array[i] == value) shift = true;\\n            if (shift) {\\n                array[i] = array[i + 1];\\n            }\\n            i++;\\n        }\\n        array.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_periodId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_periodStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_periodEnd\",\"type\":\"uint256\"}],\"name\":\"ChangedEndRewardPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"stakedToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedRewardsPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"stakableToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakedPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"unstaker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"stakedToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakedBalance\",\"type\":\"uint256\"}],\"name\":\"UnstakedPeriod\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"rewardToken\",\"type\":\"IERC20\"},{\"internalType\":\"uint256\",\"name\":\"totalPeriodRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPeriodStakingScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"walletStakingScore\",\"type\":\"uint256\"}],\"name\":\"calculatePeriodRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PeriodStaking", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "500", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}