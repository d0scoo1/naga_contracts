{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: contracts/Interfaces/IStake.sol\r\n\r\n\r\n\r\npragma solidity >=0.8.4;\r\n\r\ninterface IStake {\r\n\r\n    struct Deposit {\r\n    uint256 amount;\r\n    uint40 time;\r\n    }\r\n\r\n    struct Staker {\r\n    uint256 dividend_amount;\r\n    uint40 last_payout;\r\n    uint256 total_invested_amount;\r\n    uint256 total_withdrawn_amount;\r\n    Deposit[] deposits;\r\n    }\r\n    \r\n    event NewDeposit(address indexed addr, uint256 amount);\r\n    event Withdraw(address indexed addr, uint256 amount);\r\n\r\n    function withdraw(uint256 amountToWithdraw, uint40 timestamp)  external;\r\n\r\n    function withdrawAmount(address _addr) external returns(uint256) ;\r\n}\r\n\r\ninterface IMStake {\r\n\r\n    // struct Deposit {\r\n    // uint256 amount;\r\n    // uint40 time;\r\n    // }\r\n\r\n    struct Staker {\r\n    uint256 dividend_amount;\r\n    uint40 last_payout;\r\n    uint256 total_invested_amount;\r\n    uint256 total_withdrawn_amount;\r\n    uint256 amount;\r\n    uint40 time;\r\n    }\r\n    \r\n    event NewDeposit(address indexed addr, uint256 amount);\r\n    event Withdraw(address indexed addr, uint256 amount);\r\n\r\n    function withdraw(uint256 amountToWithdraw)  external;\r\n\r\n    function withdrawAmount(address _addr) external returns(uint256) ;\r\n}\r\n// File: contracts/Interfaces/ITokenERC20.sol\r\n\r\n\r\n\r\npragma solidity >=0.8.4;\r\n\r\ninterface ITokenERC20 {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    event FrozenFunds(address target, bool frozen);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) external returns (bool success);\r\n\r\n    function burn(uint256 _value) external returns (bool success);\r\n\r\n    function burnFrom(address _from, uint256 _value) external returns (bool success);\r\n\r\n    \r\n}\r\n// File: contracts/Owned.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Caller should be Owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/TokenERC20.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; }\r\n\r\ncontract TokenERC20 is ITokenERC20, owned{\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply;\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n\r\n    constructor(\r\n        uint256 initialSupply,\r\n        string memory tokenName,\r\n        string memory tokenSymbol\r\n    ) {\r\n        totalSupply = initialSupply * 10 ** uint256(decimals);  \r\n        balanceOf[msg.sender] = totalSupply;            \r\n        name = tokenName;                        \r\n        symbol = tokenSymbol;           \r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n\r\n        require(_to != address(0x0), \"should Transfer to correct address\");\r\n\r\n        require(balanceOf[_from] >= _value, \"Not enough balance from the sender\");\r\n\r\n        require(balanceOf[_to] + _value > balanceOf[_to], \"overflows\");\r\n\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n\r\n        balanceOf[_from] -= _value;\r\n\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n\r\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender], \"You are not allowed to transfer passed amount\");    \r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function approve(address _spender, uint256 _value) public override\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\r\n        public override\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n\r\n    function burn(uint256 _value) public override returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value, \"Not enough balance of tokens to burn\");  \r\n        balanceOf[msg.sender] -= _value;            \r\n        totalSupply -= _value;               \r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n   \r\n    function burnFrom(address _from, uint256 _value) public override returns (bool success) {\r\n        require(balanceOf[_from] >= _value, \"Not enough balance of tokens to burn\");               \r\n        require(_value <= allowance[_from][msg.sender], \"Not allowed to burn such amount of tokens\");\r\n        balanceOf[_from] -= _value;                     \r\n        allowance[_from][msg.sender] -= _value;             \r\n        totalSupply -= _value;         \r\n        emit Burn(_from, _value);\r\n        return true;\r\n    }\r\n}\r\n// File: @openzeppelin/contracts/utils/math/SafeMath.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/MSPaceStakeContract.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\n\r\ncontract MSpaceStake is owned, IMStake {\r\n\tusing SafeMath for uint256;\r\n\tusing SafeMath for uint40;\r\n    // using SafeERC20 for IERC20;\r\n\r\n    uint256 public invested_amount;\r\n    uint256 public withdrawn_amount;\r\n    \r\n    TokenERC20 public MSPACE;\r\n\r\n    mapping(address => Staker) public stakers;\r\n    \r\n\taddress public gameDevWallet;\r\n    address public coinAddress;\r\n\r\n\r\n    constructor(address _gameDevWallet, address _coinAddress) {\r\n        require(!isContract(gameDevWallet));\r\n\t\tgameDevWallet = _gameDevWallet;\r\n        coinAddress = _coinAddress;\r\n        MSPACE = TokenERC20(_coinAddress);\r\n        \r\n    }\r\n\r\n\r\n    function updateGameDevWallet(address _newGameDevWallet) public onlyOwner {\r\n        gameDevWallet = _newGameDevWallet;\r\n    }\r\n\r\n    function updateCoinAddress(address _coinAddress) public onlyOwner {\r\n        coinAddress = _coinAddress;\r\n    }\r\n\r\n    function _withdrawAmount(address _addr) private {\r\n        uint256 amount = this.withdrawAmount(_addr);\r\n\r\n        if(amount > 0) {\r\n            stakers[_addr].last_payout = uint40(block.timestamp);\r\n            stakers[_addr].dividend_amount += amount;\r\n        }\r\n    }\r\n\r\n    function deposit(uint256 amount) external {\r\n        require(amount > 0, \"deposit is invalid\");\r\n\r\n        uint256 newAmount = this.withdrawAmount(msg.sender) + amount;\r\n\r\n        MSPACE.transferFrom(msg.sender, gameDevWallet, amount);\r\n        Staker storage staker = stakers[msg.sender];\r\n\r\n        staker.total_invested_amount+= amount;\r\n        staker.amount = newAmount;\r\n        staker.time = uint40(block.timestamp);\r\n        invested_amount+= amount;\r\n        \r\n        emit NewDeposit(msg.sender, amount);\r\n    }\r\n    \r\n    function withdraw(uint256 amountToWithdraw) external override{\r\n        Staker storage staker = stakers[msg.sender];\r\n\r\n        _withdrawAmount(msg.sender);\r\n\r\n        require(staker.amount > amountToWithdraw, \"Not enough balance to withdraw\");\r\n\r\n        require(staker.dividend_amount > 0, \"Zero amount\");\r\n\r\n        uint256 amount = staker.dividend_amount;\r\n\r\n        uint256 newAmount = staker.dividend_amount - amountToWithdraw;\r\n\r\n        staker.amount = newAmount;\r\n        staker.dividend_amount = 0;\r\n        staker.total_withdrawn_amount += amountToWithdraw;\r\n        staker.time = uint40(block.timestamp);\r\n        withdrawn_amount += amountToWithdraw;\r\n\r\n        MSPACE.transferFrom(gameDevWallet, msg.sender, amountToWithdraw);\r\n        \r\n        emit Withdraw(msg.sender, amount);\r\n    }\r\n\r\n    function withdrawAmount(address _addr) view external override returns(uint256) {\r\n        Staker storage staker = stakers[_addr];\r\n        uint256 value = 0;\r\n        \r\n        uint daysDeposited = (uint40(block.timestamp) - staker.time) / 60;\r\n\r\n        if(daysDeposited >= 3 && daysDeposited < 9){\r\n                value += (((staker.amount) * daysDeposited * 111 /200) / 100) + staker.amount; // 1/3\r\n        }\r\n\r\n        else if(daysDeposited >= 9 && daysDeposited < 18){\r\n            value += (((staker.amount) * daysDeposited * 833 / 1000) / 100)+ staker.amount; // 1/2\r\n        }\r\n        else if(daysDeposited >= 18) {\r\n            value += (((staker.amount) * daysDeposited * 1667 / 1000) / 100)+ staker.amount; // 1\r\n        }\r\n        else{\r\n            value += 0;\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    \r\n    function addressDetails(address _addr) view external returns(uint256 for_withdraw, uint256 total_invested_amount, uint256 total_withdrawn_amount) {\r\n        Staker storage staker = stakers[_addr];\r\n\r\n        uint256 amount = this.withdrawAmount(_addr);\r\n\r\n        return (\r\n            amount + staker.dividend_amount,\r\n            staker.total_invested_amount,\r\n            staker.total_withdrawn_amount\r\n        );\r\n    }\r\n\r\n    function contractDetails() view external returns(uint256 _invested_amount, uint256 _withdrawn_amount) {\r\n        return (invested_amount, withdrawn_amount);\r\n    }\r\n\r\n\tfunction isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gameDevWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_coinAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MSPACE\",\"outputs\":[{\"internalType\":\"contract TokenERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addressDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"for_withdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_invested_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_withdrawn_amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coinAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_invested_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawn_amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameDevWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"invested_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dividend_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"last_payout\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"total_invested_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_withdrawn_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"time\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coinAddress\",\"type\":\"address\"}],\"name\":\"updateCoinAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGameDevWallet\",\"type\":\"address\"}],\"name\":\"updateGameDevWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToWithdraw\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"withdrawAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawn_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MSpaceStake", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000cf5cd60f628b8d9249acb3a165cfe5a9a5b6ed000000000000000000000000003f5919205a01fa0c44e8f4c4ba897629b26b076a", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://39f5557e6bd98d131b5a7e5351c883464e0be8a8b97e2ccc6b9d0c7a0e5229f5"}]}