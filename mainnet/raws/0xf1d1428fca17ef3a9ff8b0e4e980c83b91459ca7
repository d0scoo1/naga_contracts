{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: localhost/SetExchange/common/StaticCaller.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n/**\r\n * @title StaticCaller\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract StaticCaller {\r\n\r\n    function staticCall(address target, bytes memory data) internal view returns (bool result)\r\n    {\r\n        assembly {\r\n            result := staticcall(gas(), target, add(data, 0x20), mload(data), mload(0x40), 0)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function staticCallUint(address target, bytes memory data) internal view returns (uint ret)\r\n    {\r\n        bool result;\r\n        assembly {\r\n            let size := 0x20\r\n            let free := mload(0x40)\r\n            result := staticcall(gas(), target, add(data, 0x20), mload(data), free, size)\r\n            ret := mload(free)\r\n        }\r\n        require(result, \"Static call failed\");\r\n        return ret;\r\n    }\r\n\r\n}\r\n\r\n// File: localhost/SetExchange/@openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: localhost/SetExchange/common/TokenRecipient.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\ncontract TokenRecipient{\r\n    event ReceivedEther(address indexed sender, uint amount);\r\n    event ReceivedTokens(address indexed from, uint256 value, address indexed token, bytes extraData);\r\n\r\n    function receiveApproval(address from, uint256 value, address token, bytes memory extraData) public {\r\n        IERC20 t = IERC20(token);\r\n        require(t.transferFrom(from, address(this), value), \"ERC20 token transfer failed\");\r\n        emit ReceivedTokens(from, value, token, extraData);\r\n    }\r\n   \r\n    fallback () payable external {\r\n        emit ReceivedEther(msg.sender, msg.value);\r\n    }\r\n    receive () payable external {\r\n        emit ReceivedEther(msg.sender, msg.value);\r\n    }\r\n}\r\n// File: localhost/SetExchange/registry/proxy/OwnedUpgradeabilityStorage.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\ncontract OwnedUpgradeabilityStorage {\r\n\r\n    address internal _implementation;\r\n    address private _upgradeabilityOwner;\r\n    \r\n    function upgradeabilityOwner() public view returns (address) {\r\n        return _upgradeabilityOwner;\r\n    }\r\n\r\n    function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {\r\n        _upgradeabilityOwner = newUpgradeabilityOwner;\r\n    }\r\n}\r\n\r\n// File: localhost/SetExchange/registry/proxy/Proxy.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\nabstract contract Proxy {\r\n  \r\n    function implementation() virtual public view returns (address);\r\n    function proxyType() virtual public pure returns (uint256 proxyTypeId);\r\n    \r\n    function _fallback() private{\r\n        \r\n        address _impl = implementation();\r\n        require(_impl != address(0), \"Proxy implementation required\");\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n    \r\n    \r\n    fallback () payable external{\r\n      _fallback();\r\n    }\r\n    \r\n    receive() payable external{\r\n        _fallback();\r\n    }\r\n    \r\n}\r\n\r\n// File: localhost/SetExchange/registry/proxy/OwnedUpgradeabilityProxy.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\n\r\ncontract OwnedUpgradeabilityProxy is Proxy, OwnedUpgradeabilityStorage {\r\n    \r\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n    event Upgraded(address indexed implementation);\r\n    \r\n    function implementation() override public view returns (address) {\r\n        return _implementation;\r\n    }\r\n   \r\n    function proxyType() override public pure returns (uint256 proxyTypeId) {\r\n        return 2;\r\n    }\r\n    \r\n    function _upgradeTo(address implem) internal {\r\n        require(_implementation != implem, \"Proxy already uses this implementation\");\r\n        _implementation = implem;\r\n        emit Upgraded(implem);\r\n    }\r\n    \r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner(), \"Only the proxy owner can call this method\");\r\n        _;\r\n    }\r\n    \r\n    function proxyOwner() public view returns (address) {\r\n        return upgradeabilityOwner();\r\n    }\r\n   \r\n    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\r\n        require(newOwner != address(0), \"New owner cannot be the null address\");\r\n        emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\r\n        setUpgradeabilityOwner(newOwner);\r\n    }\r\n   \r\n    //\u91cd\u70b9\u662f\u4e0b\u9762\u7684 \r\n   \r\n    function upgradeTo(address implem) public onlyProxyOwner {\r\n        _upgradeTo(implem);\r\n    }\r\n   \r\n    function upgradeToAndCall(address implem, bytes memory data) payable public onlyProxyOwner {\r\n        upgradeTo(implem);\r\n        (bool success,) = address(this).delegatecall(data);\r\n        require(success, \"Call failed after proxy upgrade\");\r\n    }\r\n}\r\n\r\n// File: localhost/SetExchange/registry/OwnableDelegateProxy.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\ncontract OwnableDelegateProxy is OwnedUpgradeabilityProxy {\r\n\r\n\r\n    constructor(address owner, address initialImplementation, bytes memory data)  {\r\n        setUpgradeabilityOwner(owner);\r\n        _upgradeTo(initialImplementation);\r\n        (bool success,) = initialImplementation.delegatecall(data);\r\n        require(success, \"OwnableDelegateProxy failed implementation\");\r\n    }\r\n    \r\n\r\n}\r\n// File: localhost/SetExchange/registry/ProxyRegistryInterface.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\ninterface ProxyRegistryInterface {\r\n    function delegateProxyImplementation() external returns (address);\r\n    function proxies(address owner) external returns (OwnableDelegateProxy);\r\n}\r\n\r\n// File: localhost/SetExchange/@openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: localhost/SetExchange/@openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: localhost/SetExchange/registry/ProxyRegistry.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\n\r\n\r\ncontract ProxyRegistry is Ownable, ProxyRegistryInterface {\r\n    \r\n    address public override delegateProxyImplementation;\r\n    mapping(address => OwnableDelegateProxy) public override proxies;\r\n    //Contracts pending access. \r\n    mapping(address => uint) public pending;\r\n    //Contracts allowed to call those proxies. \r\n    mapping(address => bool) public contracts;\r\n    uint public DELAY_PERIOD = 2 weeks;\r\n\r\n    function startGrantAuthentication (address addr) public onlyOwner{\r\n        require(!contracts[addr] && pending[addr] == 0, \"Contract is already allowed in registry, or pending\");\r\n        pending[addr] = block.timestamp;\r\n    }\r\n\r\n    function endGrantAuthentication (address addr) public onlyOwner{\r\n        require(!contracts[addr] && pending[addr] != 0 && ((pending[addr] + DELAY_PERIOD) < block.timestamp), \"Contract is no longer pending or has already been approved by registry\");\r\n        pending[addr] = 0;\r\n        contracts[addr] = true;\r\n    }\r\n\r\n    function revokeAuthentication (address addr) public onlyOwner{\r\n        contracts[addr] = false;\r\n    }\r\n    \r\n     function grantAuthentication (address addr) public onlyOwner{\r\n        contracts[addr] = true;\r\n    }\r\n   \r\n    function registerProxyOverride() public returns (OwnableDelegateProxy proxy){\r\n        proxy = new OwnableDelegateProxy(msg.sender, delegateProxyImplementation, abi.encodeWithSignature(\"initialize(address,address)\", msg.sender, address(this)));\r\n        proxies[msg.sender] = proxy;\r\n        return proxy;\r\n    }\r\n    \r\n    function registerProxyFor(address user) public returns (OwnableDelegateProxy proxy){\r\n        require(address(proxies[user]) == address(0), \"User already has a proxy\");\r\n        proxy = new OwnableDelegateProxy(user, delegateProxyImplementation, abi.encodeWithSignature(\"initialize(address,address)\", user, address(this)));\r\n        proxies[user] = proxy;\r\n        return proxy;\r\n    }\r\n    \r\n     function registerProxy() public returns (OwnableDelegateProxy proxy){\r\n        return registerProxyFor(msg.sender);\r\n    }\r\n\r\n    function transferAccessTo(address from, address to) public{\r\n        OwnableDelegateProxy proxy = proxies[from];\r\n        /* CHECKS */\r\n        require(msg.sender == from, \"Proxy transfer can only be called by the proxy\");\r\n        require(address(proxies[to]) == address(0), \"Proxy transfer has existing proxy as destination\");\r\n        /* EFFECTS */\r\n        delete proxies[from];\r\n        proxies[to] = proxy;\r\n    }\r\n\r\n}\r\n// File: localhost/SetExchange/registry/AuthenticatedProxy.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\n\r\n\r\ncontract AuthenticatedProxy is TokenRecipient, OwnedUpgradeabilityStorage {\r\n\r\n    bool initialized = false;\r\n    address public user;\r\n    ProxyRegistry public registry;\r\n    bool public revoked;\r\n    enum HowToCall { Call, DelegateCall }\r\n    event Revoked(bool revoked);\r\n    function initialize (address addrUser, ProxyRegistry addrRegistry) public {\r\n        require(!initialized, \"Authenticated proxy already initialized\");\r\n        initialized = true;\r\n        user = addrUser;\r\n        registry = addrRegistry;\r\n    }\r\n   //Set the revoked flag (allows a user to revoke ProxyRegistry access)\r\n    function setRevoke(bool revoke) public{\r\n        require(msg.sender == user, \"Authenticated proxy can only be revoked by its user\");\r\n        revoked = revoke;\r\n        emit Revoked(revoke);\r\n    }\r\n    //Execute a message call from the proxy contract\r\n    function proxy(address dest, HowToCall howToCall, bytes memory data) public  returns (bool result){\r\n        require(msg.sender == user || (!revoked && registry.contracts(msg.sender)), \"Authenticated proxy can only be called by its user, or by a contract authorized by the registry as long as the user has not revoked access\");\r\n        bytes memory ret;\r\n        if (howToCall == HowToCall.Call) {\r\n            (result, ret) = dest.call(data);\r\n        } else if (howToCall == HowToCall.DelegateCall) {\r\n            (result, ret) = dest.delegatecall(data);\r\n        }\r\n        return result;\r\n    }\r\n    //Execute a message call and assert success\r\n    function proxyAssert(address dest, HowToCall howToCall, bytes memory data) public{\r\n        require(proxy(dest, howToCall, data), \"Proxy assertion failed\");\r\n    }\r\n\r\n}\r\n\r\n// File: localhost/SetExchange/@openzeppelin/contracts/utils/math/SafeMath.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File: localhost/SetExchange/common/ArrayUtils.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\nlibrary ArrayUtils {\r\n\r\n    function guardedArrayReplace(bytes memory array, bytes memory desired, bytes memory mask)  internal  pure{\r\n        require(array.length == desired.length, \"Arrays have different lengths\");\r\n        require(array.length == mask.length, \"Array and mask have different lengths\");\r\n\r\n        uint words = array.length / 0x20;\r\n        uint index = words * 0x20;\r\n        assert(index / 0x20 == words);\r\n        uint i;\r\n\r\n        for (i = 0; i < words; i++) {\r\n            /* Conceptually: array[i] = (!mask[i] && array[i]) || (mask[i] && desired[i]), bitwise in word chunks. */\r\n            assembly {\r\n                let commonIndex := mul(0x20, add(1, i))\r\n                let maskValue := mload(add(mask, commonIndex))\r\n                mstore(add(array, commonIndex), or(and(not(maskValue), mload(add(array, commonIndex))), and(maskValue, mload(add(desired, commonIndex)))))\r\n            }\r\n        }\r\n\r\n        /* Deal with the last section of the byte array. */\r\n        if (words > 0) {\r\n            /* This overlaps with bytes already set but is still more efficient than iterating through each of the remaining bytes individually. */\r\n            i = words;\r\n            assembly {\r\n                let commonIndex := mul(0x20, add(1, i))\r\n                let maskValue := mload(add(mask, commonIndex))\r\n                mstore(add(array, commonIndex), or(and(not(maskValue), mload(add(array, commonIndex))), and(maskValue, mload(add(desired, commonIndex)))))\r\n            }\r\n        } else {\r\n            /* If the byte array is shorter than a word, we must unfortunately do the whole thing bytewise.\r\n               (bounds checks could still probably be optimized away in assembly, but this is a rare case) */\r\n            for (i = index; i < array.length; i++) {\r\n                array[i] = ((mask[i] ^ 0xff) & array[i]) | (mask[i] & desired[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function arrayEq(bytes memory a, bytes memory b) internal  pure  returns (bool){\r\n        bool success = true;\r\n        assembly {\r\n            let length := mload(a)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(b))\r\n            case 1 {\r\n                // cb is a circuit breaker in the for loop since there's\r\n                //  no said feature for inline assembly loops\r\n                // cb = 1 - don't breaker\r\n                // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(a, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(b, 0x20)\r\n                // the next line is the loop condition:\r\n                // while(uint(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function arrayDrop(bytes memory _bytes, uint _start) internal  pure  returns (bytes memory){\r\n\r\n        uint _length = SafeMath.sub(_bytes.length, _start);\r\n        return arraySlice(_bytes, _start, _length);\r\n    }\r\n\r\n    function arrayTake(bytes memory _bytes, uint _length) internal pure returns (bytes memory){\r\n\r\n        return arraySlice(_bytes, 0, _length);\r\n    }\r\n\r\n    function arraySlice(bytes memory _bytes, uint _start, uint _length) internal pure returns (bytes memory){\r\n\r\n        bytes memory tempBytes;\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function unsafeWriteBytes(uint index, bytes memory source) internal pure returns (uint){\r\n        if (source.length > 0) {\r\n            assembly {\r\n                let length := mload(source)\r\n                let end := add(source, add(0x20, length))\r\n                let arrIndex := add(source, 0x20)\r\n                let tempIndex := index\r\n                for { } eq(lt(arrIndex, end), 1) {\r\n                    arrIndex := add(arrIndex, 0x20)\r\n                    tempIndex := add(tempIndex, 0x20)\r\n                } {\r\n                    mstore(tempIndex, mload(arrIndex))\r\n                }\r\n                index := add(index, length)\r\n            }\r\n        }\r\n        return index;\r\n    }\r\n    \r\n     function unsafeWriteAddress(uint index, address source) internal pure returns (uint){\r\n        uint conv = uint(uint160(source)) << 0x60;\r\n        assembly {\r\n            mstore(index, conv)\r\n            index := add(index, 0x14)\r\n        }\r\n        return index;\r\n    }\r\n\r\n    function unsafeWriteUint(uint index, uint source) internal  pure returns (uint){\r\n        assembly {\r\n            mstore(index, source)\r\n            index := add(index, 0x20)\r\n        }\r\n        return index;\r\n    }\r\n   \r\n    function unsafeWriteUint8(uint index, uint8 source) internal pure  returns (uint){\r\n        assembly {\r\n            mstore8(index, source)\r\n            index := add(index, 0x1)\r\n        }\r\n        return index;\r\n    }\r\n\r\n}\r\n\r\n\r\n// File: localhost/SetExchange/static/StaticUtil.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\n\r\n\r\ncontract StaticUtil is StaticCaller {\r\n\r\n    address public atomicizer;\r\n\r\n    function any(bytes memory, address[7] memory, AuthenticatedProxy.HowToCall[2] memory, uint[6] memory, bytes memory, bytes memory)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        /*\r\n           Accept any call.\r\n           Useful e.g. for matching-by-transaction, where you authorize the counter-call by sending the transaction and don't need to re-check it.\r\n           Return fill \"1\".\r\n        */\r\n\r\n        return 1;\r\n    }\r\n\r\n    function anySingle(bytes memory,  address[7] memory, AuthenticatedProxy.HowToCall, uint[6] memory, bytes memory)\r\n        public\r\n        pure\r\n    {\r\n        /* No checks. */\r\n    }\r\n\r\n    function anyNoFill(bytes memory, address[7] memory, AuthenticatedProxy.HowToCall[2] memory, uint[6] memory, bytes memory, bytes memory)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        /*\r\n           Accept any call.\r\n           Useful e.g. for matching-by-transaction, where you authorize the counter-call by sending the transaction and don't need to re-check it.\r\n           Return fill \"0\".\r\n        */\r\n\r\n        return 0;\r\n    }\r\n\r\n    function anyAddOne(bytes memory, address[7] memory, AuthenticatedProxy.HowToCall[2] memory, uint[6] memory uints, bytes memory, bytes memory)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        /*\r\n           Accept any call.\r\n           Useful e.g. for matching-by-transaction, where you authorize the counter-call by sending the transaction and don't need to re-check it.\r\n           Return the current fill plus 1.\r\n        */\r\n\r\n        return uints[5] + 1;\r\n    }\r\n\r\n    function split(bytes memory extra,\r\n                   address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n                   bytes memory data, bytes memory counterdata)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        (address[2] memory targets, bytes4[2] memory selectors, bytes memory firstExtradata, bytes memory secondExtradata) = abi.decode(extra, (address[2], bytes4[2], bytes, bytes));\r\n\r\n        /* Split into two static calls: one for the call, one for the counter-call, both with metadata. */\r\n\r\n        /* Static call to check the call. */\r\n        require(staticCall(targets[0], abi.encodeWithSelector(selectors[0], firstExtradata, addresses, howToCalls[0], uints, data)));\r\n\r\n        /* Static call to check the counter-call. */\r\n        require(staticCall(targets[1], abi.encodeWithSelector(selectors[1], secondExtradata, [addresses[3], addresses[4], addresses[5], addresses[0], addresses[1], addresses[2], addresses[6]], howToCalls[1], uints, counterdata)));\r\n\r\n        return 1;\r\n    }\r\n\r\n    function splitAddOne(bytes memory extra,\r\n                   address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n                   bytes memory data, bytes memory counterdata)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        split(extra,addresses,howToCalls,uints,data,counterdata);\r\n        return uints[5] + 1;\r\n    }\r\n\r\n    function and(bytes memory extra,\r\n                 address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n                 bytes memory data, bytes memory counterdata)\r\n        public\r\n        view\r\n    {\r\n        (address[] memory addrs, bytes4[] memory selectors, uint[] memory extradataLengths, bytes memory extradatas) = abi.decode(extra, (address[], bytes4[], uint[], bytes));\r\n\r\n        require(addrs.length == extradataLengths.length);\r\n        \r\n        uint j = 0;\r\n        for (uint i = 0; i < addrs.length; i++) {\r\n            bytes memory extradata = new bytes(extradataLengths[i]);\r\n            for (uint k = 0; k < extradataLengths[i]; k++) {\r\n                extradata[k] = extradatas[j];\r\n                j++;\r\n            }\r\n            require(staticCall(addrs[i], abi.encodeWithSelector(selectors[i], extradata, addresses, howToCalls, uints, data, counterdata)));\r\n        }\r\n    }\r\n\r\n    function or(bytes memory extra,\r\n                address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n                bytes memory data, bytes memory counterdata)\r\n        public\r\n        view\r\n    {\r\n        (address[] memory addrs, bytes4[] memory selectors, uint[] memory extradataLengths, bytes memory extradatas) = abi.decode(extra, (address[], bytes4[], uint[], bytes));\r\n\r\n        require(addrs.length == extradataLengths.length, \"Different number of static call addresses and extradatas\");\r\n        \r\n        uint j = 0;\r\n        for (uint i = 0; i < addrs.length; i++) {\r\n            bytes memory extradata = new bytes(extradataLengths[i]);\r\n            for (uint k = 0; k < extradataLengths[i]; k++) {\r\n                extradata[k] = extradatas[j];\r\n                j++;\r\n            }\r\n            if (staticCall(addrs[i], abi.encodeWithSelector(selectors[i], extradata, addresses, howToCalls, uints, data, counterdata))) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        revert(\"No static calls succeeded\");\r\n    }\r\n\r\n    function sequenceExact(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall howToCall, uint[6] memory uints,\r\n        bytes memory cdata)\r\n        public\r\n        view\r\n    {\r\n        (address[] memory addrs, uint[] memory extradataLengths, bytes4[] memory selectors, bytes memory extradatas) = abi.decode(extra, (address[], uint[], bytes4[], bytes));\r\n\r\n        /* Assert DELEGATECALL to atomicizer library with given call sequence, split up predicates accordingly.\r\n           e.g. transferring two CryptoKitties in sequence. */\r\n\r\n        require(addrs.length == extradataLengths.length);\r\n\r\n        (address[] memory caddrs, uint[] memory cvals, uint[] memory clengths, bytes memory calldatas) = abi.decode(ArrayUtils.arrayDrop(cdata, 4), (address[], uint[], uint[], bytes));\r\n\r\n        require(addresses[2] == atomicizer);\r\n        require(howToCall == AuthenticatedProxy.HowToCall.DelegateCall);\r\n        require(addrs.length == caddrs.length); // Exact calls only\r\n\r\n        for (uint i = 0; i < addrs.length; i++) {\r\n            require(cvals[i] == 0);\r\n        }\r\n\r\n        sequence(caddrs, clengths, calldatas, addresses, uints, addrs, extradataLengths, selectors, extradatas);\r\n    }\r\n\r\n    function dumbSequenceExact(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n        bytes memory cdata, bytes memory)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        sequenceExact(extra, addresses, howToCalls[0], uints, cdata);\r\n\r\n        return 1;\r\n    }\r\n\r\n    function sequenceAnyAfter(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall howToCall, uint[6] memory uints,\r\n        bytes memory cdata)\r\n        public\r\n        view\r\n    {\r\n        (address[] memory addrs, uint[] memory extradataLengths, bytes4[] memory selectors, bytes memory extradatas) = abi.decode(extra, (address[], uint[], bytes4[], bytes));\r\n\r\n        /* Assert DELEGATECALL to atomicizer library with given call sequence, split up predicates accordingly.\r\n           e.g. transferring two CryptoKitties in sequence. */\r\n\r\n        require(addrs.length == extradataLengths.length);\r\n\r\n        (address[] memory caddrs, uint[] memory cvals, uint[] memory clengths, bytes memory calldatas) = abi.decode(ArrayUtils.arrayDrop(cdata, 4), (address[], uint[], uint[], bytes));\r\n\r\n        require(addresses[2] == atomicizer);\r\n        require(howToCall == AuthenticatedProxy.HowToCall.DelegateCall);\r\n        require(addrs.length <= caddrs.length); // Extra calls OK\r\n\r\n        for (uint i = 0; i < addrs.length; i++) {\r\n            require(cvals[i] == 0);\r\n        }\r\n\r\n        sequence(caddrs, clengths, calldatas, addresses, uints, addrs, extradataLengths, selectors, extradatas);\r\n    }\r\n\r\n    function sequence(\r\n        address[] memory caddrs, uint[] memory clengths, bytes memory calldatas,\r\n        address[7] memory addresses, uint[6] memory uints,\r\n        address[] memory addrs, uint[] memory extradataLengths, bytes4[] memory selectors, bytes memory extradatas)\r\n        internal\r\n        view\r\n    {\r\n        uint j = 0;\r\n        uint l = 0;\r\n        for (uint i = 0; i < addrs.length; i++) {\r\n            bytes memory extradata = new bytes(extradataLengths[i]);\r\n            for (uint k = 0; k < extradataLengths[i]; k++) {\r\n                extradata[k] = extradatas[j];\r\n                j++;\r\n            }\r\n            bytes memory data = new bytes(clengths[i]);\r\n            for (uint m = 0; m < clengths[i]; m++) {\r\n                data[m] = calldatas[l];\r\n                l++;\r\n            }\r\n            addresses[2] = caddrs[i];\r\n            require(staticCall(addrs[i], abi.encodeWithSelector(selectors[i], extradata, addresses, AuthenticatedProxy.HowToCall.Call, uints, data)));\r\n        }\r\n        require(j == extradatas.length);\r\n    }\r\n\r\n}\r\n\r\n// File: localhost/SetExchange/static/StaticERC1155.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\n\r\n\r\ncontract StaticERC1155 {\r\n\r\nfunction transferERC1155Exact(bytes memory extra,\r\n\taddress[7] memory addresses, AuthenticatedProxy.HowToCall howToCall, uint[6] memory,\r\n\tbytes memory data)\r\n\tpublic\r\n\tpure\r\n{\r\n\t// Decode extradata\r\n\t(address token, uint256 tokenId, uint256 amount) = abi.decode(extra, (address, uint256, uint256));\r\n\r\n\t// Call target = token to give\r\n\trequire(addresses[2] == token);\r\n\t// Call type = call\r\n\trequire(howToCall == AuthenticatedProxy.HowToCall.Call);\r\n\t// Assert calldata\r\n\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[1], addresses[4], tokenId, amount, \"\")));\r\n}\r\n\r\nfunction swapOneForOneERC1155(bytes memory extra,\r\n\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n\tbytes memory data, bytes memory counterdata)\r\n\tpublic\r\n\tpure\r\n\treturns (uint)\r\n{\r\n\t// Zero-value\r\n\trequire(uints[0] == 0);\r\n\r\n\t// Decode extradata\r\n\t(address[2] memory tokenGiveGet, uint256[2] memory nftGiveGet, uint256[2] memory nftAmounts) = abi.decode(extra, (address[2], uint256[2], uint256[2]));\r\n\r\n\t// Call target = token to give\r\n\trequire(addresses[2] == tokenGiveGet[0], \"ERC1155: call target must equal address of token to give\");\r\n\t// Assert more than zero\r\n\trequire(nftAmounts[0] > 0,\"ERC1155: give amount must be larger than zero\");\r\n\t// Call type = call\r\n\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC1155: call must be a direct call\");\r\n\t// Assert calldata\r\n\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[1], addresses[4], nftGiveGet[0], nftAmounts[0], \"\")));\r\n\r\n\t// Countercall target = token to get\r\n\trequire(addresses[5] == tokenGiveGet[1], \"ERC1155: countercall target must equal address of token to get\");\r\n\t// Assert more than zero\r\n\trequire(nftAmounts[1] > 0,\"ERC1155: take amount must be larger than zero\");\r\n\t// Countercall type = call\r\n\trequire(howToCalls[1] == AuthenticatedProxy.HowToCall.Call, \"ERC1155: countercall must be a direct call\");\r\n\t// Assert countercalldata\r\n\trequire(ArrayUtils.arrayEq(counterdata, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[4], addresses[1], nftGiveGet[1], nftAmounts[1], \"\")));\r\n\r\n\t// Mark filled\r\n\treturn 1;\r\n}\r\n\r\nfunction swapOneForOneERC1155Decoding(bytes memory extra,\r\n\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n\tbytes memory data, bytes memory counterdata)\r\n\tpublic\r\n\tpure\r\n\treturns (uint)\r\n{\r\n\t// Calculate function signature\r\n\tbytes memory sig = ArrayUtils.arrayTake(abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\"), 4);\r\n\r\n\t// Zero-value\r\n\trequire(uints[0] == 0);\r\n\r\n\t// Decode extradata\r\n\t(address[2] memory tokenGiveGet, uint256[2] memory nftGiveGet, uint256[2] memory nftAmounts) = abi.decode(extra, (address[2],uint256[2],uint256[2]));\r\n\r\n\t// Call target = token to give\r\n\trequire(addresses[2] == tokenGiveGet[0], \"ERC1155: call target must equal address of token to give\");\r\n\t// Call type = call\r\n\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC1155: call must be a direct call\");\r\n\t// Assert signature\r\n\trequire(ArrayUtils.arrayEq(sig, ArrayUtils.arrayTake(data, 4)));\r\n\t// Decode and assert calldata\t\r\n\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[1], addresses[4], nftGiveGet[0], nftAmounts[0], \"\")));\r\n\t// Decode and assert countercalldata\r\n\trequire(ArrayUtils.arrayEq(counterdata, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[4], addresses[1], nftGiveGet[1], nftAmounts[1], \"\")));\r\n\r\n\t// Mark filled\r\n\treturn 1;\r\n}\r\n\r\n}\r\n\r\n// File: localhost/SetExchange/static/StaticERC721.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\n\r\n\r\ncontract StaticERC721 {\r\n\r\n    function transferERC721Exact(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall howToCall, uint[6] memory,\r\n        bytes memory data)\r\n        public\r\n        pure\r\n    {\r\n        // Decode extradata\r\n        (address token, uint tokenId) = abi.decode(extra, (address, uint));\r\n\r\n        // Call target = token to give\r\n        require(addresses[2] == token);\r\n        // Call type = call\r\n        require(howToCall == AuthenticatedProxy.HowToCall.Call);\r\n        // Assert calldata\r\n        require(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[1], addresses[4], tokenId)));\r\n    }\r\n\r\n    function swapOneForOneERC721(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n        bytes memory data, bytes memory counterdata)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        // Zero-value\r\n        require(uints[0] == 0);\r\n\r\n        // Decode extradata\r\n        (address[2] memory tokenGiveGet, uint[2] memory nftGiveGet) = abi.decode(extra, (address[2],uint[2]));\r\n\r\n        // Call target = token to give\r\n        require(addresses[2] == tokenGiveGet[0], \"ERC721: call target must equal address of token to give\");\r\n        // Call type = call\r\n        require(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC721: call must be a direct call\");\r\n        // Assert calldata\r\n        require(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[1], addresses[4], nftGiveGet[0])));\r\n\r\n        // Countercall target = token to get\r\n        require(addresses[5] == tokenGiveGet[1], \"ERC721: countercall target must equal address of token to get\");\r\n        // Countercall type = call\r\n        require(howToCalls[1] == AuthenticatedProxy.HowToCall.Call, \"ERC721: countercall must be a direct call\");\r\n        // Assert countercalldata\r\n        require(ArrayUtils.arrayEq(counterdata, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[4], addresses[1], nftGiveGet[1])));\r\n\r\n        // Mark filled\r\n        return 1;\r\n    }\r\n\r\n    function swapOneForOneERC721Decoding(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n        bytes memory data, bytes memory counterdata)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        // Calculate function signature\r\n        bytes memory sig = ArrayUtils.arrayTake(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\"), 4);\r\n\r\n        // Zero-value\r\n        require(uints[0] == 0);\r\n\r\n        // Decode extradata\r\n        (address[2] memory tokenGiveGet, uint[2] memory nftGiveGet) = abi.decode(extra, (address[2],uint[2]));\r\n\r\n        // Call target = token to give\r\n        require(addresses[2] == tokenGiveGet[0], \"ERC721: call target must equal address of token to give\");\r\n        // Call type = call\r\n        require(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC721: call must be a direct call\");\r\n        // Assert signature\r\n        require(ArrayUtils.arrayEq(sig, ArrayUtils.arrayTake(data, 4)));\r\n        // Decode calldata\r\n        (address callFrom, address callTo, uint256 nftGive) = abi.decode(ArrayUtils.arrayDrop(data, 4), (address, address, uint256));\r\n        // Assert from\r\n        require(callFrom == addresses[1]);\r\n        // Assert to\r\n        require(callTo == addresses[4]);\r\n        // Assert NFT\r\n        require(nftGive == nftGiveGet[0]);\r\n\r\n        // Countercall target = token to get\r\n        require(addresses[5] == tokenGiveGet[1], \"ERC721: countercall target must equal address of token to get\");\r\n        // Countercall type = call\r\n        require(howToCalls[1] == AuthenticatedProxy.HowToCall.Call, \"ERC721: countercall must be a direct call\");\r\n        // Assert signature\r\n        require(ArrayUtils.arrayEq(sig, ArrayUtils.arrayTake(counterdata, 4)));\r\n        // Decode countercalldata\r\n        (address countercallFrom, address countercallTo, uint256 nftGet) = abi.decode(ArrayUtils.arrayDrop(counterdata, 4), (address, address, uint256));\r\n        // Assert from\r\n        require(countercallFrom == addresses[4]);\r\n        // Assert to\r\n        require(countercallTo == addresses[1]);\r\n        // Assert NFT\r\n        require(nftGet == nftGiveGet[1]);\r\n\r\n        // Mark filled\r\n        return 1;\r\n    }\r\n\r\n}\r\n\r\n// File: localhost/SetExchange/static/StaticERC20.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\n\r\n\r\ncontract StaticERC20 {\r\n\r\n    function transferERC20Exact(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall howToCall, uint[6] memory,\r\n        bytes memory data)\r\n        public\r\n        pure\r\n    {\r\n        // Decode extradata\r\n        (address token, uint amount) = abi.decode(extra, (address, uint));\r\n\r\n        // Call target = token to give\r\n        require(addresses[2] == token);\r\n        // Call type = call\r\n        require(howToCall == AuthenticatedProxy.HowToCall.Call);\r\n        // Assert calldata\r\n        require(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[1], addresses[4], amount)));\r\n    }\r\n\r\n    function swapExact(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n        bytes memory data, bytes memory counterdata)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        // Zero-value\r\n        require(uints[0] == 0);\r\n\r\n        // Decode extradata\r\n        (address[2] memory tokenGiveGet, uint[2] memory amountGiveGet) = abi.decode(extra, (address[2], uint[2]));\r\n\r\n        // Call target = token to give\r\n        require(addresses[2] == tokenGiveGet[0]);\r\n        // Call type = call\r\n        require(howToCalls[0] == AuthenticatedProxy.HowToCall.Call);\r\n        // Assert calldata\r\n        require(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[1], addresses[4], amountGiveGet[0])));\r\n\r\n        require(addresses[5] == tokenGiveGet[1]);\r\n        // Countercall type = call\r\n        require(howToCalls[1] == AuthenticatedProxy.HowToCall.Call);\r\n        // Assert countercalldata\r\n        require(ArrayUtils.arrayEq(counterdata, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[4], addresses[1], amountGiveGet[1])));\r\n\r\n        // Mark filled.\r\n        return 1;\r\n    }\r\n\r\n    function swapForever(bytes memory extra,\r\n        address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\r\n        bytes memory data, bytes memory counterdata)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        // Calculate function signature\r\n        bytes memory sig = ArrayUtils.arrayTake(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\"), 4);\r\n\r\n        // Zero-value\r\n        require(uints[0] == 0);\r\n\r\n        // Decode extradata\r\n        (address[2] memory tokenGiveGet, uint[2] memory numeratorDenominator) = abi.decode(extra, (address[2], uint[2]));\r\n\r\n        // Call target = token to give\r\n        require(addresses[2] == tokenGiveGet[0]);\r\n        // Call type = call\r\n        require(howToCalls[0] == AuthenticatedProxy.HowToCall.Call);\r\n        // Check signature\r\n        require(ArrayUtils.arrayEq(sig, ArrayUtils.arrayTake(data, 4)));\r\n        // Decode calldata\r\n        (address callFrom, address callTo, uint256 amountGive) = abi.decode(ArrayUtils.arrayDrop(data, 4), (address, address, uint256));\r\n        // Assert from\r\n        require(callFrom == addresses[1]);\r\n        // Assert to\r\n        require(callTo == addresses[4]);\r\n\r\n        // Countercall target = token to get\r\n        require(addresses[5] == tokenGiveGet[1]);\r\n        // Countercall type = call\r\n        require(howToCalls[1] == AuthenticatedProxy.HowToCall.Call);\r\n        // Check signature\r\n        require(ArrayUtils.arrayEq(sig, ArrayUtils.arrayTake(counterdata, 4)));\r\n        // Decode countercalldata\r\n        (address countercallFrom, address countercallTo, uint256 amountGet) = abi.decode(ArrayUtils.arrayDrop(counterdata, 4), (address, address, uint256));\r\n        // Assert from\r\n        require(countercallFrom == addresses[4]);\r\n        // Assert to\r\n        require(countercallTo == addresses[1]);\r\n\r\n        // Assert ratio\r\n        // ratio = min get/give\r\n        require(SafeMath.mul(amountGet, numeratorDenominator[1]) >= SafeMath.mul(amountGive, numeratorDenominator[0]));\r\n\r\n        // Order will be set with maximumFill = 2 (to allow signature caching)\r\n        return 1;\r\n    }\r\n\r\n\r\n}\r\n\r\n// File: localhost/SetExchange/WyvernStatic.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title WyvernStatic\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract WyvernStatic is StaticERC20, StaticERC721, StaticERC1155, StaticUtil {\r\n\r\n    string public constant name = \"Wyvern Static\";\r\n\r\n    constructor (address atomicizerAddress){\r\n        atomicizer = atomicizerAddress;\r\n    }\r\n\r\n    function test () \r\n        public\r\n        pure\r\n    {\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"atomicizerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"addresses\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall[2]\",\"name\":\"howToCalls\",\"type\":\"uint8[2]\"},{\"internalType\":\"uint256[6]\",\"name\":\"uints\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"counterdata\",\"type\":\"bytes\"}],\"name\":\"and\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall[2]\",\"name\":\"\",\"type\":\"uint8[2]\"},{\"internalType\":\"uint256[6]\",\"name\":\"\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"any\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall[2]\",\"name\":\"\",\"type\":\"uint8[2]\"},{\"internalType\":\"uint256[6]\",\"name\":\"uints\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"anyAddOne\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall[2]\",\"name\":\"\",\"type\":\"uint8[2]\"},{\"internalType\":\"uint256[6]\",\"name\":\"\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"anyNoFill\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256[6]\",\"name\":\"\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"anySingle\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"atomicizer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"addresses\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall[2]\",\"name\":\"howToCalls\",\"type\":\"uint8[2]\"},{\"internalType\":\"uint256[6]\",\"name\":\"uints\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"cdata\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"dumbSequenceExact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"addresses\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall[2]\",\"name\":\"howToCalls\",\"type\":\"uint8[2]\"},{\"internalType\":\"uint256[6]\",\"name\":\"uints\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"counterdata\",\"type\":\"bytes\"}],\"name\":\"or\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"addresses\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall\",\"name\":\"howToCall\",\"type\":\"uint8\"},{\"internalType\":\"uint256[6]\",\"name\":\"uints\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"cdata\",\"type\":\"bytes\"}],\"name\":\"sequenceAnyAfter\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"addresses\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall\",\"name\":\"howToCall\",\"type\":\"uint8\"},{\"internalType\":\"uint256[6]\",\"name\":\"uints\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"cdata\",\"type\":\"bytes\"}],\"name\":\"sequenceExact\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"addresses\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall[2]\",\"name\":\"howToCalls\",\"type\":\"uint8[2]\"},{\"internalType\":\"uint256[6]\",\"name\":\"uints\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"counterdata\",\"type\":\"bytes\"}],\"name\":\"split\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"addresses\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall[2]\",\"name\":\"howToCalls\",\"type\":\"uint8[2]\"},{\"internalType\":\"uint256[6]\",\"name\":\"uints\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"counterdata\",\"type\":\"bytes\"}],\"name\":\"splitAddOne\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"addresses\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall[2]\",\"name\":\"howToCalls\",\"type\":\"uint8[2]\"},{\"internalType\":\"uint256[6]\",\"name\":\"uints\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"counterdata\",\"type\":\"bytes\"}],\"name\":\"swapExact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"addresses\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall[2]\",\"name\":\"howToCalls\",\"type\":\"uint8[2]\"},{\"internalType\":\"uint256[6]\",\"name\":\"uints\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"counterdata\",\"type\":\"bytes\"}],\"name\":\"swapForever\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"addresses\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall[2]\",\"name\":\"howToCalls\",\"type\":\"uint8[2]\"},{\"internalType\":\"uint256[6]\",\"name\":\"uints\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"counterdata\",\"type\":\"bytes\"}],\"name\":\"swapOneForOneERC1155\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"addresses\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall[2]\",\"name\":\"howToCalls\",\"type\":\"uint8[2]\"},{\"internalType\":\"uint256[6]\",\"name\":\"uints\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"counterdata\",\"type\":\"bytes\"}],\"name\":\"swapOneForOneERC1155Decoding\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"addresses\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall[2]\",\"name\":\"howToCalls\",\"type\":\"uint8[2]\"},{\"internalType\":\"uint256[6]\",\"name\":\"uints\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"counterdata\",\"type\":\"bytes\"}],\"name\":\"swapOneForOneERC721\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"addresses\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall[2]\",\"name\":\"howToCalls\",\"type\":\"uint8[2]\"},{\"internalType\":\"uint256[6]\",\"name\":\"uints\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"counterdata\",\"type\":\"bytes\"}],\"name\":\"swapOneForOneERC721Decoding\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"test\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"addresses\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall\",\"name\":\"howToCall\",\"type\":\"uint8\"},{\"internalType\":\"uint256[6]\",\"name\":\"\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferERC1155Exact\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"addresses\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall\",\"name\":\"howToCall\",\"type\":\"uint8\"},{\"internalType\":\"uint256[6]\",\"name\":\"\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferERC20Exact\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extra\",\"type\":\"bytes\"},{\"internalType\":\"address[7]\",\"name\":\"addresses\",\"type\":\"address[7]\"},{\"internalType\":\"enum AuthenticatedProxy.HowToCall\",\"name\":\"howToCall\",\"type\":\"uint8\"},{\"internalType\":\"uint256[6]\",\"name\":\"\",\"type\":\"uint256[6]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferERC721Exact\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "WyvernStatic", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000db6423fb0f4105bf5aca03b44720a7287bbd4543", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5f87c4785ebdc99aec401b0397adb84ad0c1e49d3ab38a84ba625edb6b24d376"}]}