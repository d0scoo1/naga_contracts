{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/council/features/Timelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\nimport \\\"../libraries/Authorizable.sol\\\";\\nimport \\\"../libraries/ReentrancyBlock.sol\\\";\\n\\n// Allows a call to be executed after a waiting period, also allows a call to\\n// be canceled within a waiting period.\\n\\ncontract Timelock is Authorizable, ReentrancyBlock {\\n    // Amount of time for the waiting period\\n    uint256 public waitTime;\\n\\n    // Mapping of call hashes to block timestamps\\n    mapping(bytes32 => uint256) public callTimestamps;\\n    // Mapping from a call hash to its status of once allowed time increase\\n    mapping(bytes32 => bool) public timeIncreases;\\n\\n    /// @notice Constructs this contract and sets state variables\\n    /// @param _waitTime amount of time for the waiting period\\n    /// @param _governance governance\\n    /// @param _gsc governance steering committee contract.\\n    constructor(\\n        uint256 _waitTime,\\n        address _governance,\\n        address _gsc\\n    ) Authorizable() {\\n        _authorize(_gsc);\\n        waitTime = _waitTime;\\n        setOwner(_governance);\\n    }\\n\\n    /// @notice Stores at the callHash the current block timestamp\\n    /// @param callHash The hash to map the timestamp to\\n    function registerCall(bytes32 callHash) external onlyOwner {\\n        // We only want to register a call which is not already active\\n        require(callTimestamps[callHash] == 0, \\\"already registered\\\");\\n        // Set the timestamp for this call package to be the current time\\n        callTimestamps[callHash] = block.timestamp;\\n    }\\n\\n    /// @notice Removes stored callHash data\\n    /// @param callHash Which entry of the mapping to remove\\n    function stopCall(bytes32 callHash) external onlyOwner {\\n        // We only want this to actually execute when a real thing is deleted to\\n        // prevent re-ordering attacks\\n        require(callTimestamps[callHash] != 0, \\\"No call to be removed\\\");\\n        // Do the actual deletion\\n        delete callTimestamps[callHash];\\n        delete timeIncreases[callHash];\\n    }\\n\\n    /// @notice Execute the call if past the waiting period\\n    /// @param targets List of target addresses the timelock contract will interact with\\n    /// @param calldatas Execution calldata for each target\\n    function execute(address[] memory targets, bytes[] calldata calldatas)\\n        public\\n        nonReentrant\\n    {\\n        // hash provided data to access the mapping\\n        bytes32 callHash = keccak256(abi.encode(targets, calldatas));\\n        // call defaults to zero and cannot be executed before it is registered\\n        require(callTimestamps[callHash] != 0, \\\"call has not been initialized\\\");\\n        // call cannot be executed before the waiting period has passed\\n        require(\\n            callTimestamps[callHash] + waitTime < block.timestamp,\\n            \\\"not enough time has passed\\\"\\n        );\\n        // Gives a revert string to a revert that would occur anyway when the array is accessed\\n        require(targets.length == calldatas.length, \\\"invalid formatting\\\");\\n        // execute a package of low level calls\\n        for (uint256 i = 0; i < targets.length; i++) {\\n            (bool success, ) = targets[i].call(calldatas[i]);\\n            // revert if a single call fails\\n            require(success == true, \\\"call reverted\\\");\\n        }\\n        // restore state after successful execution\\n        delete callTimestamps[callHash];\\n        delete timeIncreases[callHash];\\n    }\\n\\n    /// @notice Allow a call from this contract to reset the wait time storage variable\\n    /// @param _waitTime New wait time to set to\\n    function setWaitTime(uint256 _waitTime) public {\\n        require(msg.sender == address(this), \\\"contract must be self\\\");\\n        waitTime = _waitTime;\\n    }\\n\\n    /// @notice Allow an increase in wait time for a given call\\n    /// can only be executed once for each call\\n    /// @param timeValue Amount of time to increase by\\n    /// @param callHash The mapping entry to increase time\\n    function increaseTime(uint256 timeValue, bytes32 callHash)\\n        external\\n        onlyAuthorized\\n    {\\n        require(\\n            timeIncreases[callHash] == false,\\n            \\\"value can only be changed once\\\"\\n        );\\n        require(\\n            callTimestamps[callHash] != 0,\\n            \\\"must have been previously registered\\\"\\n        );\\n        // Increases the time till the call can be executed\\n        callTimestamps[callHash] += timeValue;\\n        // set mapping to indicate call has been changed\\n        timeIncreases[callHash] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/council/libraries/Authorizable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.7.0;\\n\\ncontract Authorizable {\\n    // This contract allows a flexible authorization scheme\\n\\n    // The owner who can change authorization status\\n    address public owner;\\n    // A mapping from an address to its authorization status\\n    mapping(address => bool) public authorized;\\n\\n    /// @dev We set the deployer to the owner\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    /// @dev This modifier checks if the msg.sender is the owner\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Sender not owner\\\");\\n        _;\\n    }\\n\\n    /// @dev This modifier checks if an address is authorized\\n    modifier onlyAuthorized() {\\n        require(isAuthorized(msg.sender), \\\"Sender not Authorized\\\");\\n        _;\\n    }\\n\\n    /// @dev Returns true if an address is authorized\\n    /// @param who the address to check\\n    /// @return true if authorized false if not\\n    function isAuthorized(address who) public view returns (bool) {\\n        return authorized[who];\\n    }\\n\\n    /// @dev Privileged function authorize an address\\n    /// @param who the address to authorize\\n    function authorize(address who) external onlyOwner() {\\n        _authorize(who);\\n    }\\n\\n    /// @dev Privileged function to de authorize an address\\n    /// @param who The address to remove authorization from\\n    function deauthorize(address who) external onlyOwner() {\\n        authorized[who] = false;\\n    }\\n\\n    /// @dev Function to change owner\\n    /// @param who The new owner address\\n    function setOwner(address who) public onlyOwner() {\\n        owner = who;\\n    }\\n\\n    /// @dev Inheritable function which authorizes someone\\n    /// @param who the address to authorize\\n    function _authorize(address who) internal {\\n        authorized[who] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/council/libraries/ReentrancyBlock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\ncontract ReentrancyBlock {\\n    // A storage slot for the reentrancy flag\\n    bool private _entered;\\n    // Will use a state flag to prevent this function from being called back into\\n    modifier nonReentrant() {\\n        // Check the state variable before the call is entered\\n        require(!_entered, \\\"Reentrancy\\\");\\n        // Store that the function has been entered\\n        _entered = true;\\n        // Run the function code\\n        _;\\n        // Clear the state\\n        _entered = false;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_waitTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gsc\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"callTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"deauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"calldatas\",\"type\":\"bytes[]\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"callHash\",\"type\":\"bytes32\"}],\"name\":\"increaseTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"callHash\",\"type\":\"bytes32\"}],\"name\":\"registerCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_waitTime\",\"type\":\"uint256\"}],\"name\":\"setWaitTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"callHash\",\"type\":\"bytes32\"}],\"name\":\"stopCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"timeIncreases\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"waitTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Timelock", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000422494292e7a9dda8778bb4ea05c2779a3d60f5d000000000000000000000000422494292e7a9dda8778bb4ea05c2779a3d60f5d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}