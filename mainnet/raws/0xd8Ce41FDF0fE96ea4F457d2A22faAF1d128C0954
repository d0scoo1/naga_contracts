{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/hyphen/token/TokenManager.sol\": {\r\n      \"content\": \"// $$$$$$$$\\\\        $$\\\\                                 $$\\\\      $$\\\\\\n// \\\\__$$  __|       $$ |                                $$$\\\\    $$$ |\\n//    $$ | $$$$$$\\\\  $$ |  $$\\\\  $$$$$$\\\\  $$$$$$$\\\\        $$$$\\\\  $$$$ | $$$$$$\\\\  $$$$$$$\\\\   $$$$$$\\\\   $$$$$$\\\\   $$$$$$\\\\   $$$$$$\\\\\\n//    $$ |$$  __$$\\\\ $$ | $$  |$$  __$$\\\\ $$  __$$\\\\       $$\\\\$$\\\\$$ $$ | \\\\____$$\\\\ $$  __$$\\\\  \\\\____$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$  __$$\\\\\\n//    $$ |$$ /  $$ |$$$$$$  / $$$$$$$$ |$$ |  $$ |      $$ \\\\$$$  $$ | $$$$$$$ |$$ |  $$ | $$$$$$$ |$$ /  $$ |$$$$$$$$ |$$ |  \\\\__|\\n//    $$ |$$ |  $$ |$$  _$$<  $$   ____|$$ |  $$ |      $$ |\\\\$  /$$ |$$  __$$ |$$ |  $$ |$$  __$$ |$$ |  $$ |$$   ____|$$ |\\n//    $$ |\\\\$$$$$$  |$$ | \\\\$$\\\\ \\\\$$$$$$$\\\\ $$ |  $$ |      $$ | \\\\_/ $$ |\\\\$$$$$$$ |$$ |  $$ |\\\\$$$$$$$ |\\\\$$$$$$$ |\\\\$$$$$$$\\\\ $$ |\\n//    \\\\__| \\\\______/ \\\\__|  \\\\__| \\\\_______|\\\\__|  \\\\__|      \\\\__|     \\\\__| \\\\_______|\\\\__|  \\\\__| \\\\_______| \\\\____$$ | \\\\_______|\\\\__|\\n//                                                                                                 $$\\\\   $$ |\\n//                                                                                                 \\\\$$$$$$  |\\n//                                                                                                  \\\\______/\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"../metatx/ERC2771Context.sol\\\";\\nimport \\\"../interfaces/ITokenManager.sol\\\";\\n\\ncontract TokenManager is ITokenManager, ERC2771Context, Ownable, Pausable {\\n    mapping(address => TokenInfo) public override tokensInfo;\\n\\n    event FeeChanged(address indexed tokenAddress, uint256 indexed equilibriumFee, uint256 indexed maxFee);\\n\\n    modifier tokenChecks(address tokenAddress) {\\n        require(tokenAddress != address(0), \\\"Token address cannot be 0\\\");\\n        require(tokensInfo[tokenAddress].supportedToken, \\\"Token not supported\\\");\\n\\n        _;\\n    }\\n\\n    /**\\n     * First key is toChainId and second key is token address being deposited on current chain\\n     */\\n    mapping(uint256 => mapping(address => TokenConfig)) public depositConfig;\\n\\n    /**\\n     * Store min/max amount of token to transfer based on token address\\n     */\\n    mapping(address => TokenConfig) public transferConfig;\\n\\n    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) Ownable() Pausable() {\\n        // Empty Constructor\\n    }\\n\\n    function getEquilibriumFee(address tokenAddress) public view override returns (uint256) {\\n        return tokensInfo[tokenAddress].equilibriumFee;\\n    }\\n\\n    function getMaxFee(address tokenAddress) public view override returns (uint256) {\\n        return tokensInfo[tokenAddress].maxFee;\\n    }\\n\\n    function changeFee(\\n        address tokenAddress,\\n        uint256 _equilibriumFee,\\n        uint256 _maxFee\\n    ) external override onlyOwner whenNotPaused {\\n        require(_equilibriumFee != 0, \\\"Equilibrium Fee cannot be 0\\\");\\n        require(_maxFee != 0, \\\"Max Fee cannot be 0\\\");\\n        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;\\n        tokensInfo[tokenAddress].maxFee = _maxFee;\\n        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);\\n    }\\n\\n    function setTokenTransferOverhead(address tokenAddress, uint256 gasOverhead)\\n        external\\n        tokenChecks(tokenAddress)\\n        onlyOwner\\n    {\\n        tokensInfo[tokenAddress].transferOverhead = gasOverhead;\\n    }\\n\\n    /**\\n     * Set DepositConfig for the given combination of toChainId, tokenAddress.\\n     * This is used while depositing token in Liquidity Pool. Based on the destination chainid\\n     * min and max deposit amount is checked.\\n     */\\n    function setDepositConfig(\\n        uint256[] memory toChainId,\\n        address[] memory tokenAddresses,\\n        TokenConfig[] memory tokenConfig\\n    ) external onlyOwner {\\n        require(\\n            (toChainId.length == tokenAddresses.length) && (tokenAddresses.length == tokenConfig.length),\\n            \\\" ERR_ARRAY_LENGTH_MISMATCH\\\"\\n        );\\n        uint256 length = tokenConfig.length;\\n        for (uint256 index; index < length; ) {\\n            depositConfig[toChainId[index]][tokenAddresses[index]].min = tokenConfig[index].min;\\n            depositConfig[toChainId[index]][tokenAddresses[index]].max = tokenConfig[index].max;\\n            unchecked {\\n                ++index;\\n            }\\n        }\\n    }\\n\\n    function addSupportedToken(\\n        address tokenAddress,\\n        uint256 minCapLimit,\\n        uint256 maxCapLimit,\\n        uint256 equilibriumFee,\\n        uint256 maxFee,\\n        uint256 transferOverhead\\n    ) external onlyOwner {\\n        require(tokenAddress != address(0), \\\"Token address cannot be 0\\\");\\n        require(maxCapLimit > minCapLimit, \\\"maxCapLimit > minCapLimit\\\");\\n        tokensInfo[tokenAddress].supportedToken = true;\\n        transferConfig[tokenAddress].min = minCapLimit;\\n        transferConfig[tokenAddress].max = maxCapLimit;\\n        tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];\\n        tokensInfo[tokenAddress].equilibriumFee = equilibriumFee;\\n        tokensInfo[tokenAddress].maxFee = maxFee;\\n        tokensInfo[tokenAddress].transferOverhead = transferOverhead;\\n    }\\n\\n    function removeSupportedToken(address tokenAddress) external tokenChecks(tokenAddress) onlyOwner {\\n        tokensInfo[tokenAddress].supportedToken = false;\\n    }\\n\\n    function updateTokenCap(\\n        address tokenAddress,\\n        uint256 minCapLimit,\\n        uint256 maxCapLimit\\n    ) external tokenChecks(tokenAddress) onlyOwner {\\n        require(maxCapLimit > minCapLimit, \\\"maxCapLimit > minCapLimit\\\");\\n        transferConfig[tokenAddress].min = minCapLimit;\\n        transferConfig[tokenAddress].max = maxCapLimit;\\n    }\\n\\n    function getTokensInfo(address tokenAddress) public view override returns (TokenInfo memory) {\\n        TokenInfo memory tokenInfo = TokenInfo(\\n            tokensInfo[tokenAddress].transferOverhead,\\n            tokensInfo[tokenAddress].supportedToken,\\n            tokensInfo[tokenAddress].equilibriumFee,\\n            tokensInfo[tokenAddress].maxFee,\\n            transferConfig[tokenAddress]\\n        );\\n        return tokenInfo;\\n    }\\n\\n    function getDepositConfig(uint256 toChainId, address tokenAddress)\\n        public\\n        view\\n        override\\n        returns (TokenConfig memory)\\n    {\\n        return depositConfig[toChainId][tokenAddress];\\n    }\\n\\n    function getTransferConfig(address tokenAddress) public view override returns (TokenConfig memory) {\\n        return transferConfig[tokenAddress];\\n    }\\n\\n    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address sender) {\\n        return ERC2771Context._msgSender();\\n    }\\n\\n    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {\\n        return ERC2771Context._msgData();\\n    }\\n\\n    function pause() external onlyOwner {\\n        _pause();\\n    }\\n\\n    function unpause() external onlyOwner {\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/hyphen/metatx/ERC2771Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support.\\n */\\nabstract contract ERC2771Context is Context {\\n    address internal _trustedForwarder;\\n\\n    constructor(address trustedForwarder) {\\n        _trustedForwarder = trustedForwarder;\\n    }\\n\\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\\n        return forwarder == _trustedForwarder;\\n    }\\n\\n    function _msgSender() internal view virtual override returns (address sender) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return super._msgSender();\\n        }\\n    }\\n\\n    function _msgData() internal view virtual override returns (bytes calldata) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return super._msgData();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/hyphen/interfaces/ITokenManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport \\\"../structures/TokenConfig.sol\\\";\\n\\ninterface ITokenManager {\\n    function getEquilibriumFee(address tokenAddress) external view returns (uint256);\\n\\n    function getMaxFee(address tokenAddress) external view returns (uint256);\\n\\n    function changeFee(\\n        address tokenAddress,\\n        uint256 _equilibriumFee,\\n        uint256 _maxFee\\n    ) external;\\n\\n    function tokensInfo(address tokenAddress)\\n        external\\n        view\\n        returns (\\n            uint256 transferOverhead,\\n            bool supportedToken,\\n            uint256 equilibriumFee,\\n            uint256 maxFee,\\n            TokenConfig memory config\\n        );\\n\\n    function getTokensInfo(address tokenAddress) external view returns (TokenInfo memory);\\n\\n    function getDepositConfig(uint256 toChainId, address tokenAddress) external view returns (TokenConfig memory);\\n\\n    function getTransferConfig(address tokenAddress) external view returns (TokenConfig memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/hyphen/structures/TokenConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nstruct TokenInfo {\\n    uint256 transferOverhead;\\n    bool supportedToken;\\n    uint256 equilibriumFee; // Percentage fee Represented in basis points\\n    uint256 maxFee; // Percentage fee Represented in basis points\\n    TokenConfig tokenConfig;\\n}\\n\\nstruct TokenConfig {\\n    uint256 min;\\n    uint256 max;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trustedForwarder\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"equilibriumFee\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"}],\"name\":\"FeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minCapLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxCapLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"equilibriumFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferOverhead\",\"type\":\"uint256\"}],\"name\":\"addSupportedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_equilibriumFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxFee\",\"type\":\"uint256\"}],\"name\":\"changeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getDepositConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getEquilibriumFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getMaxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getTokensInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"transferOverhead\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"supportedToken\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"equilibriumFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenConfig\",\"name\":\"tokenConfig\",\"type\":\"tuple\"}],\"internalType\":\"struct TokenInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getTransferConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"removeSupportedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"toChainId\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenConfig[]\",\"name\":\"tokenConfig\",\"type\":\"tuple[]\"}],\"name\":\"setDepositConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasOverhead\",\"type\":\"uint256\"}],\"name\":\"setTokenTransferOverhead\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"transferOverhead\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"supportedToken\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"equilibriumFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenConfig\",\"name\":\"tokenConfig\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minCapLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxCapLimit\",\"type\":\"uint256\"}],\"name\":\"updateTokenCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenManager", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000084a0856b038eaad1cc7e297cf34a7e72685a8693", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}