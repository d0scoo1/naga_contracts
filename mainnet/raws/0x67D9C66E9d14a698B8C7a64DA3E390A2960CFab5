{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/ExchangeRates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// Inheritance\\nimport \\\"./OwnedwManager.sol\\\";\\nimport \\\"./SelfDestructible.sol\\\";\\n\\n// Libraries\\nimport \\\"./SafeDecimalMath.sol\\\";\\n\\n// Internal references\\n// AggregatorInterface from Chainlink represents a decentralized pricing network for a single currency key\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n  function latestTimestamp() external view returns (uint256);\\n  function latestRound() external view returns (uint256);\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\\ncontract ExchangeRates is OwnedwManager, SelfDestructible {\\n    using SafeMath for uint;\\n    using SafeDecimalMath for uint;\\n\\n    struct RateAndUpdatedTime {\\n        uint216 rate;\\n        uint40 time;\\n    }\\n\\n    // Exchange rates and update times stored by currency code, e.g. 'OKS', or 'USD'\\n    mapping(bytes32 => mapping(uint => RateAndUpdatedTime)) private _rates;\\n\\n    // The address of the oracle which pushes rate updates to this contract\\n    address public oracle;\\n\\n    // Decentralized oracle networks that feed into pricing aggregators\\n    mapping(bytes32 => AggregatorInterface) public aggregators;\\n\\n    // List of aggregator keys for convenient iteration\\n    bytes32[] public aggregatorKeys;\\n\\n    // Do not allow the oracle to submit times any further forward into the future than this constant.\\n    uint private constant ORACLE_FUTURE_LIMIT = 10 minutes;\\n\\n    // How long will the contract assume the rate of any asset is correct\\n    uint public rateStalePeriod = 3 hours;\\n\\n    // For inverted prices, keep a mapping of their entry, limits and frozen status\\n    struct InversePricing {\\n        uint entryPoint;\\n        uint upperLimit;\\n        uint lowerLimit;\\n        bool frozen;\\n    }\\n    mapping(bytes32 => InversePricing) public inversePricing;\\n    bytes32[] public invertedKeys;\\n\\n    mapping(bytes32 => uint) public currentRoundForRate;\\n\\n    //\\n    // ========== CONSTRUCTOR ==========\\n\\n    constructor(\\n        address _owner,\\n        address _oracle,\\n        bytes32[] memory _currencyKeys,\\n        uint[] memory _newRates\\n    ) OwnedwManager(_owner, _owner) SelfDestructible() {\\n        require(_currencyKeys.length == _newRates.length, \\\"Currency key length and rate length must match.\\\");\\n\\n        oracle = _oracle;\\n \\n        internalUpdateRates(_currencyKeys, _newRates, block.timestamp);\\n    }\\n\\n    /* ========== SETTERS ========== */\\n\\n    function setOracle(address _oracle) external onlyOwner {\\n        oracle = _oracle;\\n        emit OracleUpdated(oracle);\\n    }\\n\\n    function setRateStalePeriod(uint _time) external onlyOwner {\\n        rateStalePeriod = _time;\\n        emit RateStalePeriodUpdated(rateStalePeriod);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function updateRates(\\n        bytes32[] calldata currencyKeys,\\n        uint[] calldata newRates,\\n        uint timeSent\\n    ) external onlyOracle returns (bool) {\\n        return internalUpdateRates(currencyKeys, newRates, timeSent);\\n    }\\n\\n    function deleteRate(bytes32 currencyKey) external onlyOracle {\\n        require(_getRate(currencyKey) > 0, \\\"Rate is zero\\\");\\n\\n        delete _rates[currencyKey][currentRoundForRate[currencyKey]];\\n\\n        currentRoundForRate[currencyKey]--;\\n\\n        emit RateDeleted(currencyKey);\\n    }\\n\\n    function setInversePricing(\\n        bytes32 currencyKey,\\n        uint entryPoint,\\n        uint upperLimit,\\n        uint lowerLimit,\\n        bool freeze,\\n        bool freezeAtUpperLimit\\n    ) external onlyOwner {\\n        // 0 < lowerLimit < entryPoint => 0 < entryPoint\\n        require(lowerLimit > 0, \\\"lowerLimit must be above 0\\\");\\n        require(upperLimit > entryPoint, \\\"upperLimit must be above the entryPoint\\\");\\n        require(upperLimit < entryPoint.mul(2), \\\"upperLimit must be less than double entryPoint\\\");\\n        require(lowerLimit < entryPoint, \\\"lowerLimit must be below the entryPoint\\\");\\n\\n        if (inversePricing[currencyKey].entryPoint <= 0) {\\n            // then we are adding a new inverse pricing, so add this\\n            invertedKeys.push(currencyKey);\\n        }\\n        inversePricing[currencyKey].entryPoint = entryPoint;\\n        inversePricing[currencyKey].upperLimit = upperLimit;\\n        inversePricing[currencyKey].lowerLimit = lowerLimit;\\n        inversePricing[currencyKey].frozen = freeze;\\n\\n        emit InversePriceConfigured(currencyKey, entryPoint, upperLimit, lowerLimit);\\n\\n        // When indicating to freeze, we need to know the rate to freeze it at - either upper or lower\\n        // this is useful in situations where ExchangeRates is updated and there are existing inverted\\n        // rates already frozen in the current contract that need persisting across the upgrade\\n        if (freeze) {\\n            emit InversePriceFrozen(currencyKey);\\n\\n            _setRate(currencyKey, freezeAtUpperLimit ? upperLimit : lowerLimit, block.timestamp);\\n        }\\n    }\\n\\n    function removeInversePricing(bytes32 currencyKey) external onlyOwner {\\n        require(inversePricing[currencyKey].entryPoint > 0, \\\"No inverted price exists\\\");\\n\\n        inversePricing[currencyKey].entryPoint = 0;\\n        inversePricing[currencyKey].upperLimit = 0;\\n        inversePricing[currencyKey].lowerLimit = 0;\\n        inversePricing[currencyKey].frozen = false;\\n\\n        // block.timestamp remove inverted key from array\\n        bool wasRemoved = removeFromArray(currencyKey, invertedKeys);\\n\\n        if (wasRemoved) {\\n            emit InversePriceConfigured(currencyKey, 0, 0, 0);\\n        }\\n    }\\n\\n    function addAggregator(bytes32 currencyKey, address aggregatorAddress) external onlyOwner {\\n        AggregatorInterface aggregator = AggregatorInterface(aggregatorAddress);\\n        // This check tries to make sure that a valid aggregator is being added.\\n        // It checks if the aggregator is an existing smart contract that has implemented `latestTimestamp` function.\\n        require(aggregator.latestTimestamp() >= 0, \\\"Given Aggregator is invalid\\\");\\n        if (address(aggregators[currencyKey]) == address(0)) {\\n            aggregatorKeys.push(currencyKey);\\n        }\\n        aggregators[currencyKey] = aggregator;\\n        emit AggregatorAdded(currencyKey, address(aggregator));\\n    }\\n\\n    function removeAggregator(bytes32 currencyKey) external onlyOwner {\\n        address aggregator = address(aggregators[currencyKey]);\\n        require(aggregator != address(0), \\\"No aggregator exists for key\\\");\\n        delete aggregators[currencyKey];\\n\\n        bool wasRemoved = removeFromArray(currencyKey, aggregatorKeys);\\n\\n        if (wasRemoved) {\\n            emit AggregatorRemoved(currencyKey, aggregator);\\n        }\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time) {\\n        RateAndUpdatedTime memory rateAndTime = _getRateAndUpdatedTime(currencyKey);\\n        return (rateAndTime.rate, rateAndTime.time);\\n    }\\n\\n    function getLastRoundIdBeforeElapsedSecs(\\n        bytes32 currencyKey,\\n        uint startingRoundId,\\n        uint startingTimestamp,\\n        uint timediff\\n    ) external view returns (uint) {\\n        uint roundId = startingRoundId;\\n        uint nextTimestamp = 0;\\n        while (true) {\\n            (, nextTimestamp) = _getRateAndTimestampAtRound(currencyKey, roundId + 1);\\n            // if there's no new round, then the previous roundId was the latest\\n            if (nextTimestamp == 0 || nextTimestamp > startingTimestamp + timediff) {\\n                return roundId;\\n            }\\n            roundId++;\\n        }\\n        return roundId;\\n    }\\n\\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint) {\\n        return _getCurrentRoundId(currencyKey);\\n    }\\n\\n    function effectiveValueAtRound(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey,\\n        uint roundIdForSrc,\\n        uint roundIdForDest\\n    ) external view returns (uint value) {\\n        // If there's no change in the currency, then just return the amount they gave us\\n        if (sourceCurrencyKey == destinationCurrencyKey) return sourceAmount;\\n\\n        (uint srcRate, ) = _getRateAndTimestampAtRound(sourceCurrencyKey, roundIdForSrc);\\n        (uint destRate, ) = _getRateAndTimestampAtRound(destinationCurrencyKey, roundIdForDest);\\n        // Calculate the effective value by going from source -> USD -> destination\\n        value = sourceAmount.multiplyDecimalRound(srcRate).divideDecimalRound(destRate);\\n    }\\n\\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time) {\\n        return _getRateAndTimestampAtRound(currencyKey, roundId);\\n    }\\n\\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256) {\\n        return _getUpdatedTime(currencyKey);\\n    }\\n\\n    function lastRateUpdateTimesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory) {\\n        uint[] memory lastUpdateTimes = new uint[](currencyKeys.length);\\n\\n        for (uint i = 0; i < currencyKeys.length; i++) {\\n            lastUpdateTimes[i] = _getUpdatedTime(currencyKeys[i]);\\n        }\\n\\n        return lastUpdateTimes;\\n    }\\n\\n    function effectiveValue(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    ) external view returns (uint value) {\\n        (value, , ) = _effectiveValueAndRates(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);\\n    }\\n\\n    function effectiveValueAndRates(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    )\\n        external\\n        view\\n        returns (\\n            uint value,\\n            uint sourceRate,\\n            uint destinationRate\\n        )\\n    {\\n        return _effectiveValueAndRates(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);\\n    }\\n\\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint) {\\n        return _getRateAndUpdatedTime(currencyKey).rate;\\n    }\\n\\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(bytes32 currencyKey, uint numRounds)\\n        external\\n        view\\n        returns (uint[] memory rates, uint[] memory times)\\n    {\\n        rates = new uint[](numRounds);\\n        times = new uint[](numRounds);\\n\\n        uint roundId = _getCurrentRoundId(currencyKey);\\n        for (uint i = 0; i < numRounds; i++) {\\n            (rates[i], times[i]) = _getRateAndTimestampAtRound(currencyKey, roundId);\\n            if (roundId == 0) {\\n                // if we hit the last round, then return what we have\\n                return (rates, times);\\n            } else {\\n                roundId--;\\n            }\\n        }\\n    }\\n\\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory) {\\n        uint[] memory _localRates = new uint[](currencyKeys.length);\\n\\n        for (uint i = 0; i < currencyKeys.length; i++) {\\n            _localRates[i] = _getRate(currencyKeys[i]);\\n        }\\n\\n        return _localRates;\\n    }\\n\\n    function ratesAndStaleForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory, bool) {\\n        uint[] memory _localRates = new uint[](currencyKeys.length);\\n\\n        bool anyRateStale = false;\\n        uint period = rateStalePeriod;\\n        for (uint i = 0; i < currencyKeys.length; i++) {\\n            RateAndUpdatedTime memory rateAndUpdateTime = _getRateAndUpdatedTime(currencyKeys[i]);\\n            _localRates[i] = uint256(rateAndUpdateTime.rate);\\n            if (!anyRateStale) {\\n                anyRateStale = (currencyKeys[i] != \\\"USD\\\" && uint256(rateAndUpdateTime.time).add(period) < block.timestamp);\\n            }\\n        }\\n\\n        return (_localRates, anyRateStale);\\n    }\\n\\n    function rateIsStale(bytes32 currencyKey) external view returns (bool) {\\n        // USD is a special case and is never stale.\\n        if (currencyKey == \\\"USD\\\") return false;\\n\\n        return _getUpdatedTime(currencyKey).add(rateStalePeriod) < block.timestamp;\\n    }\\n\\n    function rateIsFrozen(bytes32 currencyKey) external view returns (bool) {\\n        return inversePricing[currencyKey].frozen;\\n    }\\n\\n    function anyRateIsStale(bytes32[] calldata currencyKeys) external view returns (bool) {\\n        // Loop through each key and check whether the data point is stale.\\n        uint256 i = 0;\\n\\n        while (i < currencyKeys.length) {\\n            // USD is a special case and is never false\\n            if (currencyKeys[i] != \\\"USD\\\" && _getUpdatedTime(currencyKeys[i]).add(rateStalePeriod) < block.timestamp) {\\n                return true;\\n            }\\n            i += 1;\\n        }\\n\\n        return false;\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    function _setRate(\\n        bytes32 currencyKey,\\n        uint256 rate,\\n        uint256 time\\n    ) internal {\\n        // Note: this will effectively start the rounds at 1, which matches Chainlink's Agggregators\\n        currentRoundForRate[currencyKey]++;\\n\\n        _rates[currencyKey][currentRoundForRate[currencyKey]] = RateAndUpdatedTime({\\n            rate: uint216(rate),\\n            time: uint40(time)\\n        });\\n    }\\n\\n    function internalUpdateRates(\\n        bytes32[] memory currencyKeys,\\n        uint[] memory newRates,\\n        uint timeSent\\n    ) internal returns (bool) {\\n        require(currencyKeys.length == newRates.length, \\\"Currency key array length must match rates array length.\\\");\\n        //require(timeSent < (block.timestamp + ORACLE_FUTURE_LIMIT), \\\"Time is too far into the future\\\");\\n\\n        // Loop through each key and perform update.\\n        for (uint i = 0; i < currencyKeys.length; i++) {\\n            bytes32 currencyKey = currencyKeys[i];\\n\\n            // Should not set any rate to zero ever, as no asset will ever be\\n            // truely worthless and still valid. In this scenario, we should\\n            // delete the rate and remove it from the system.\\n            require(newRates[i] != 0, \\\"Zero is not a valid rate, please call deleteRate instead.\\\");\\n            //require(currencyKey != \\\"USD\\\", \\\"Rate of USD cannot be updated, it's always UNIT.\\\");\\n\\n            // We should only update the rate if it's at least the same age as the last rate we've got.\\n            if (timeSent < _getUpdatedTime(currencyKey)) {\\n                continue;\\n            }\\n\\n            newRates[i] = rateOrInverted(currencyKey, newRates[i]);\\n\\n            // Ok, go ahead with the update.\\n            _setRate(currencyKey, newRates[i], timeSent);\\n        }\\n\\n        emit RatesUpdated(currencyKeys, newRates);\\n\\n        return true;\\n    }\\n\\n    function rateOrInverted(bytes32 currencyKey, uint rate) internal returns (uint) {\\n        // if an inverse mapping exists, adjust the price accordingly\\n        InversePricing storage inverse = inversePricing[currencyKey];\\n        if (inverse.entryPoint <= 0) {\\n            return rate;\\n        }\\n\\n        // set the rate to the current rate initially (if it's frozen, this is what will be returned)\\n        uint newInverseRate = _getRate(currencyKey);\\n\\n        // get the new inverted rate if not frozen\\n        if (!inverse.frozen) {\\n            uint doubleEntryPoint = inverse.entryPoint.mul(2);\\n            if (doubleEntryPoint <= rate) {\\n                // avoid negative numbers for unsigned ints, so set this to 0\\n                // which by the requirement that lowerLimit be > 0 will\\n                // cause this to freeze the price to the lowerLimit\\n                newInverseRate = 0;\\n            } else {\\n                newInverseRate = doubleEntryPoint.sub(rate);\\n            }\\n\\n            // block.timestamp if new rate hits our limits, set it to the limit and freeze\\n            if (newInverseRate >= inverse.upperLimit) {\\n                newInverseRate = inverse.upperLimit;\\n            } else if (newInverseRate <= inverse.lowerLimit) {\\n                newInverseRate = inverse.lowerLimit;\\n            }\\n\\n            if (newInverseRate == inverse.upperLimit || newInverseRate == inverse.lowerLimit) {\\n                inverse.frozen = true;\\n                emit InversePriceFrozen(currencyKey);\\n            }\\n        }\\n\\n        return newInverseRate;\\n    }\\n\\n    function removeFromArray(bytes32 entry, bytes32[] storage array) internal returns (bool) {\\n        for (uint i = 0; i < array.length; i++) {\\n            if (array[i] == entry) {\\n                delete array[i];\\n\\n                // Copy the last key into the place of the one we just deleted\\n                // If there's only one key, this is array[0] = array[0].\\n                // If we're deleting the last one, it's also a NOOP in the same way.\\n                array[i] = array[array.length - 1];\\n\\n                // Decrease the size of the array by one.\\n                array.pop();\\n\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function _getRateAndUpdatedTime(bytes32 currencyKey) internal view returns (RateAndUpdatedTime memory) {\\n        if (address(aggregators[currencyKey]) != address(0)) {\\n            return\\n                RateAndUpdatedTime({\\n                    rate: uint216(aggregators[currencyKey].latestAnswer() * 1e10),\\n                    time: uint40(aggregators[currencyKey].latestTimestamp())\\n                });\\n        } else {\\n            return _rates[currencyKey][currentRoundForRate[currencyKey]];\\n        }\\n    }\\n\\n    function _getCurrentRoundId(bytes32 currencyKey) internal view returns (uint) {\\n        if (address(aggregators[currencyKey]) != address(0)) {\\n            AggregatorInterface aggregator = aggregators[currencyKey];\\n            return aggregator.latestRound();\\n        } else {\\n            return currentRoundForRate[currencyKey];\\n        }\\n    }\\n\\n    function _getRateAndTimestampAtRound(bytes32 currencyKey, uint roundId) internal view returns (uint rate, uint time) {\\n        if (address(aggregators[currencyKey]) != address(0)) {\\n            AggregatorInterface aggregator = aggregators[currencyKey];\\n            return (uint(aggregator.getAnswer(roundId) * 1e10), aggregator.getTimestamp(roundId));\\n        } else {\\n            RateAndUpdatedTime storage update = _rates[currencyKey][roundId];\\n            return (update.rate, update.time);\\n        }\\n    }\\n\\n    function _getRate(bytes32 currencyKey) internal view returns (uint256) {\\n        return _getRateAndUpdatedTime(currencyKey).rate;\\n    }\\n\\n    function _getUpdatedTime(bytes32 currencyKey) internal view returns (uint256) {\\n        return _getRateAndUpdatedTime(currencyKey).time;\\n    }\\n\\n    function _effectiveValueAndRates(\\n        bytes32 sourceCurrencyKey,\\n        uint sourceAmount,\\n        bytes32 destinationCurrencyKey\\n    )\\n        internal\\n        view\\n        returns (\\n            uint value,\\n            uint sourceRate,\\n            uint destinationRate\\n        )\\n    {\\n        sourceRate = _getRate(sourceCurrencyKey);\\n        // If there's no change in the currency, then just return the amount they gave us\\n        if (sourceCurrencyKey == destinationCurrencyKey) {\\n            destinationRate = sourceRate;\\n            value = sourceAmount;\\n        } else {\\n            // Calculate the effective value by going from source -> USD -> destination\\n            destinationRate = _getRate(destinationCurrencyKey);\\n            value = sourceAmount.multiplyDecimalRound(sourceRate).divideDecimalRound(destinationRate);\\n        }\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyOracle {\\n        require(msg.sender == oracle, \\\"Only the oracle can perform this action\\\");\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event OracleUpdated(address newOracle);\\n    event RateStalePeriodUpdated(uint rateStalePeriod);\\n    event RatesUpdated(bytes32[] currencyKeys, uint[] newRates);\\n    event RateDeleted(bytes32 currencyKey);\\n    event InversePriceConfigured(bytes32 currencyKey, uint entryPoint, uint upperLimit, uint lowerLimit);\\n    event InversePriceFrozen(bytes32 currencyKey);\\n    event AggregatorAdded(bytes32 currencyKey, address aggregator);\\n    event AggregatorRemoved(bytes32 currencyKey, address aggregator);\\n}\\n\"\r\n    },\r\n    \"/contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n\\n// TODO(zx): Replace all instances of SafeMath with OZ implementation\\nlibrary SafeMath {\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    // Only used in the  BondingCalculator.sol\\n    function sqrrt(uint256 a) internal pure returns (uint c) {\\n        if (a > 3) {\\n            c = a;\\n            uint b = add( div( a, 2), 1 );\\n            while (b < c) {\\n                c = b;\\n                b = div( add( div( a, b ), b), 2 );\\n            }\\n        } else if (a != 0) {\\n            c = 1;\\n        }\\n    }\\n\\n}\"\r\n    },\r\n    \"/contracts/SelfDestructible.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// Inheritance\\nimport \\\"./OwnedwManager.sol\\\";\\n\\n\\n// https://docs.elysian.cash/contracts/SelfDestructible\\nabstract contract SelfDestructible is OwnedwManager {\\n    uint public constant SELFDESTRUCT_DELAY = 4 weeks; \\n\\n    uint public initiationTime;\\n    bool public selfDestructInitiated;\\n\\n    address public selfDestructBeneficiary;\\n\\n    constructor() {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), \\\"Owner must be set\\\");\\n        selfDestructBeneficiary = owner;\\n        emit SelfDestructBeneficiaryUpdated(owner);\\n    }\\n\\n    /**\\n     * @notice Set the beneficiary address of this contract.\\n     * @dev Only the contract owner may call this. The provided beneficiary must be non-null.\\n     * @param _beneficiary The address to pay any eth contained in this contract to upon self-destruction.\\n     */\\n    function setSelfDestructBeneficiary(address payable _beneficiary) external onlyOwner {\\n        require(_beneficiary != address(0), \\\"Beneficiary must not be zero\\\");\\n        selfDestructBeneficiary = _beneficiary;\\n        emit SelfDestructBeneficiaryUpdated(_beneficiary);\\n    }\\n\\n    /**\\n     * @notice Begin the self-destruction counter of this contract.\\n     * Once the delay has elapsed, the contract may be self-destructed.\\n     * @dev Only the contract owner may call this.\\n     */\\n    function initiateSelfDestruct() external onlyOwner {\\n        initiationTime = block.timestamp;\\n        selfDestructInitiated = true;\\n        emit SelfDestructInitiated(SELFDESTRUCT_DELAY);\\n    }  \\n\\n    /**\\n     * @notice Terminate and reset the self-destruction timer.\\n     * @dev Only the contract owner may call this.\\n     */\\n    function terminateSelfDestruct() external onlyOwner {\\n        initiationTime = 0;\\n        selfDestructInitiated = false;\\n        emit SelfDestructTerminated();\\n    }\\n\\n    /**\\n     * @notice If the self-destruction delay has elapsed, destroy this contract and\\n     * remit any ether it owns to the beneficiary address.\\n     * @dev Only the contract owner may call this.\\n     */\\n    function selfDestruct() external onlyOwner {\\n        require(selfDestructInitiated, \\\"Self Destruct not yet initiated\\\");\\n        require(initiationTime + SELFDESTRUCT_DELAY < block.timestamp, \\\"Self destruct delay not met\\\");\\n        emit SelfDestructed(selfDestructBeneficiary);\\n        selfdestruct(address(uint160(selfDestructBeneficiary)));\\n    }\\n\\n    event SelfDestructTerminated();\\n    event SelfDestructed(address beneficiary);\\n    event SelfDestructInitiated(uint selfDestructDelay);\\n    event SelfDestructBeneficiaryUpdated(address newBeneficiary);\\n}\\n\"\r\n    },\r\n    \"/contracts/SafeDecimalMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// Libraries\\n// TODO(zx): Replace all instances of SafeMath with OZ implementation\\nimport \\\"./libraries/SafeMath.sol\\\";  \\n    \\nlibrary SafeDecimalMath {\\n    using SafeMath for uint;\\n\\n    /* Number of decimal places in the representations. */\\n    uint8 public constant decimals = 9;\\n    uint8 public constant highPrecisionDecimals = 27;\\n\\n    /* The number representing 1.0. */\\n    uint public constant UNIT = 10**uint(decimals);\\n\\n    /* The number representing 1.0 for higher fidelity numbers. */\\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\\n\\n    /**\\n     * @return Provides an interface to UNIT.\\n     */\\n    function unit() external pure returns (uint) {\\n        return UNIT;\\n    }\\n\\n    /**\\n     * @return Provides an interface to PRECISE_UNIT.\\n     */\\n    function preciseUnit() external pure returns (uint) {\\n        return PRECISE_UNIT;\\n    }\\n\\n    /**\\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\\n     * decimals.\\n     *\\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\\n     * so that product must be less than 2**256. As this is an integer division,\\n     * the internal division always rounds down. This helps save on gas. Rounding\\n     * is more expensive on gas.\\n     */\\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        return x.mul(y) / UNIT;\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of the specified precision unit.\\n     *\\n     * @dev The operands should be in the form of a the specified unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function _multiplyDecimalRound(\\n        uint x,\\n        uint y,\\n        uint precisionUnit\\n    ) private pure returns (uint) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\\n\\n        if (quotientTimesTen % 10 >= 5) {\\n            quotientTimesTen += 10;\\n        }\\n\\n        return quotientTimesTen / 10;\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of a precise unit.\\n     *\\n     * @dev The operands should be in the precise unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of a standard unit.\\n     *\\n     * @dev The operands should be in the standard unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\\n        return _multiplyDecimalRound(x, y, UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is a high\\n     * precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the standard precision unit\\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\\n     * this is an integer division, the result is always rounded down.\\n     * This helps save on gas. Rounding is more expensive on gas.\\n     */\\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\\n        /* Reintroduce the UNIT factor that will be divided out by y. */\\n        return x.mul(UNIT).div(y);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * decimal in the precision unit specified in the parameter.\\n     *\\n     * @dev y is divided after the product of x and the specified precision unit\\n     * is evaluated, so the product of x and the specified precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function _divideDecimalRound(\\n        uint x,\\n        uint y,\\n        uint precisionUnit\\n    ) private pure returns (uint) {\\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\\n\\n        if (resultTimesTen % 10 >= 5) {\\n            resultTimesTen += 10;\\n        }\\n\\n        return resultTimesTen / 10;\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * standard precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the standard precision unit\\n     * is evaluated, so the product of x and the standard precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\\n        return _divideDecimalRound(x, y, UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * high precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the high precision unit\\n     * is evaluated, so the product of x and the high precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\\n    }\\n\\n    /**\\n     * @dev Convert a standard decimal representation to a high precision one.\\n     */\\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\\n    }\\n\\n    /**\\n     * @dev Convert a high precision decimal to a standard decimal representation.\\n     */\\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\\n\\n        if (quotientTimesTen % 10 >= 5) {\\n            quotientTimesTen += 10;\\n        }\\n\\n        return quotientTimesTen / 10;\\n    }\\n\\n    // Computes `a - b`, setting the value to 0 if b > a.\\n    function floorsub(uint a, uint b) internal pure returns (uint) {\\n        return b >= a ? 0 : a - b;\\n    }\\n\\n    /* ---------- Utilities ---------- */\\n    /*\\n     * Absolute value of the input, returned as a signed number.\\n     */\\n    function signedAbs(int x) internal pure returns (int) {\\n        return x < 0 ? -x : x;\\n    }\\n\\n    /*\\n     * Absolute value of the input, returned as an unsigned number.\\n     */\\n    function abs(int x) internal pure returns (uint) {\\n        return uint(signedAbs(x));\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/OwnedwManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\ncontract OwnedwManager {\\n    address public owner;\\n    address public manager;\\n\\n    address public nominatedOwner;\\n\\n    constructor(address _owner, address _manager) {\\n        require(_owner != address(0), \\\"Owner address cannot be 0\\\");\\n        owner = _owner;\\n        manager = _manager;\\n        emit OwnerChanged(address(0), _owner);\\n        emit ManagerChanged(_manager);\\n    }\\n\\n    function nominateNewOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOwner, \\\"You must be nominated before you can accept ownership\\\");\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    modifier onlyManager {\\n        _onlyManager();\\n        _;\\n    }\\n    \\n    function _onlyOwner() private view {\\n        require(msg.sender == owner, \\\"Only the contract owner may perform this action\\\");\\n    }\\n\\n    function _onlyManager() private view {\\n        require(msg.sender == manager, \\\"Only the contract owner may perform this action\\\");\\n    }\\n\\n    function setManager(address _manager) external onlyOwner {\\n        manager = _manager;\\n        emit ManagerChanged(_manager);\\n    }\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n    event ManagerChanged(address newManager);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"_currencyKeys\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_newRates\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"AggregatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"}],\"name\":\"AggregatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"entryPoint\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"upperLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lowerLimit\",\"type\":\"uint256\"}],\"name\":\"InversePriceConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"InversePriceFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"OracleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"RateDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rateStalePeriod\",\"type\":\"uint256\"}],\"name\":\"RateStalePeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"currencyKeys\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"newRates\",\"type\":\"uint256[]\"}],\"name\":\"RatesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"SelfDestructBeneficiaryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"selfDestructDelay\",\"type\":\"uint256\"}],\"name\":\"SelfDestructInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SelfDestructTerminated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"SelfDestructed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SELFDESTRUCT_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"aggregatorAddress\",\"type\":\"address\"}],\"name\":\"addAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"aggregatorKeys\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"aggregators\",\"outputs\":[{\"internalType\":\"contract AggregatorInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"currencyKeys\",\"type\":\"bytes32[]\"}],\"name\":\"anyRateIsStale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"currentRoundForRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"deleteRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"}],\"name\":\"effectiveValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"}],\"name\":\"effectiveValueAndRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sourceRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"roundIdForSrc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roundIdForDest\",\"type\":\"uint256\"}],\"name\":\"effectiveValueAtRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"getCurrentRoundId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"startingRoundId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timediff\",\"type\":\"uint256\"}],\"name\":\"getLastRoundIdBeforeElapsedSecs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initiateSelfDestruct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initiationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"inversePricing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"entryPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upperLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lowerLimit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"frozen\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"invertedKeys\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"lastRateUpdateTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"currencyKeys\",\"type\":\"bytes32[]\"}],\"name\":\"lastRateUpdateTimesForCurrencies\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"rateAndTimestampAtRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"rateAndUpdatedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"rateForCurrency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"rateIsFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"rateIsStale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateStalePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"currencyKeys\",\"type\":\"bytes32[]\"}],\"name\":\"ratesAndStaleForCurrencies\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"numRounds\",\"type\":\"uint256\"}],\"name\":\"ratesAndUpdatedTimeForCurrencyLastNRounds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"rates\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"times\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"currencyKeys\",\"type\":\"bytes32[]\"}],\"name\":\"ratesForCurrencies\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"removeAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"removeInversePricing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selfDestruct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selfDestructBeneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selfDestructInitiated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"entryPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upperLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lowerLimit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"freeze\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"freezeAtUpperLimit\",\"type\":\"bool\"}],\"name\":\"setInversePricing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setRateStalePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setSelfDestructBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"terminateSelfDestruct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"currencyKeys\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newRates\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"timeSent\",\"type\":\"uint256\"}],\"name\":\"updateRates\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ExchangeRates", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000d02522de79947c76add6d324f27f816b70230e85000000000000000000000000d02522de79947c76add6d324f27f816b70230e85000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000001555344000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}