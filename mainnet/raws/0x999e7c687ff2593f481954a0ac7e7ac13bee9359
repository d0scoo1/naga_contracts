{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.12;\r\ninterface ERC20 {\r\n  function transfer(address _to, uint256 _value) external;\r\n  function approve(address _spender, uint256 _value) external;\r\n  function balanceOf(address _owner) external view returns (uint256);\r\n}\r\ninterface IWETH {\r\n  function withdraw(uint256 _value) external;\r\n}\r\ninterface IUniswapV2Pair {\r\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\ninterface VM {\r\n    function prank(address) external;\r\n    function expectRevert(bytes calldata) external;\r\n}\r\n\r\nstruct Trade {\r\n  address token;\r\n  uint96 amount;\r\n  address pair;\r\n  uint96 wethAmount;\r\n}\r\n/// @title Clone\r\n/// @author zefram.eth\r\n/// @notice Provides helper functions for reading immutable args from calldata\r\ncontract Clone {\r\n    /// @notice Reads an immutable arg with type address\r\n    /// @param argOffset The offset of the arg in the packed data\r\n    /// @return arg The arg value\r\n    function _getArgAddress(uint256 argOffset)\r\n        internal\r\n        pure\r\n        returns (address arg)\r\n    {\r\n        uint256 offset = _getImmutableArgsOffset();\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            arg := shr(0x60, calldataload(add(offset, argOffset)))\r\n        }\r\n    }\r\n\r\n    /// @notice Reads an immutable arg with type uint256\r\n    /// @param argOffset The offset of the arg in the packed data\r\n    /// @return arg The arg value\r\n    function _getArgUint256(uint256 argOffset)\r\n        internal\r\n        pure\r\n        returns (uint256 arg)\r\n    {\r\n        uint256 offset = _getImmutableArgsOffset();\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            arg := calldataload(add(offset, argOffset))\r\n        }\r\n    }\r\n\r\n    /// @notice Reads a uint256 array stored in the immutable args.\r\n    /// @param argOffset The offset of the arg in the packed data\r\n    /// @param arrLen Number of elements in the array\r\n    /// @return arr The array\r\n    function _getArgUint256Array(uint256 argOffset, uint64 arrLen)\r\n        internal\r\n        pure\r\n      returns (uint256[] memory arr)\r\n    {\r\n      uint256 offset = _getImmutableArgsOffset();\r\n      uint256 el;\r\n      arr = new uint256[](arrLen);\r\n      for (uint64 i = 0; i < arrLen; i++) {\r\n        assembly {\r\n          // solhint-disable-next-line no-inline-assembly\r\n          el := calldataload(add(add(offset, argOffset), mul(i, 32)))\r\n        }\r\n        arr[i] = el;\r\n      }\r\n      return arr;\r\n    }\r\n\r\n    /// @notice Reads an immutable arg with type uint64\r\n    /// @param argOffset The offset of the arg in the packed data\r\n    /// @return arg The arg value\r\n    function _getArgUint64(uint256 argOffset)\r\n        internal\r\n        pure\r\n        returns (uint64 arg)\r\n    {\r\n        uint256 offset = _getImmutableArgsOffset();\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            arg := shr(0xc0, calldataload(add(offset, argOffset)))\r\n        }\r\n    }\r\n\r\n    /// @notice Reads an immutable arg with type uint8\r\n    /// @param argOffset The offset of the arg in the packed data\r\n    /// @return arg The arg value\r\n    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\r\n        uint256 offset = _getImmutableArgsOffset();\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            arg := shr(0xf8, calldataload(add(offset, argOffset)))\r\n        }\r\n    }\r\n\r\n    /// @return offset The offset of the packed immutable args in calldata\r\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            offset := sub(\r\n                calldatasize(),\r\n                add(shr(240, calldataload(sub(calldatasize(), 2))), 2)\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\ncontract Dumper is Clone {\r\n  address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n  // @notice send ERC20 to this contract before calling dump to sell them on uniswap v2 for ETH\r\n  // @param _trades array of Trade\r\n  function dump(Trade[] calldata _trades) external payable {\r\n    address owner = _getArgAddress(0);\r\n    require(msg.sender == owner, '1');\r\n    Trade memory _trade;\r\n    ERC20 _tok;\r\n    uint256 _totWeth;\r\n    for (uint256 i = 0; i < _trades.length;) {\r\n      _trade = _trades[i];\r\n      _tok = ERC20(_trade.token);\r\n      _tok.transfer(_trade.pair, _trade.amount);\r\n      IUniswapV2Pair(_trade.pair).swap(\r\n        0, _trade.wethAmount, address(this), new bytes(0)\r\n      );\r\n      unchecked { \r\n        _totWeth += _trade.wethAmount;\r\n        i++; \r\n      }\r\n    }\r\n    IWETH(WETH).withdraw(_totWeth);\r\n    selfdestruct(payable(owner));\r\n  }\r\n\r\n  function nah(ERC20[] calldata _tokens) external payable {\r\n    // owner should be msg.sender\r\n    require(msg.sender == _getArgAddress(0), '1');\r\n    // transfer all balance in the contract of each token to msg.sender\r\n    for (uint256 i = 0; i < _tokens.length;) {\r\n      ERC20 _tok = _tokens[i];\r\n      _tok.transfer(msg.sender, _tok.balanceOf(address(this)));\r\n      unchecked {\r\n        i++;\r\n      }\r\n    }\r\n  }\r\n\r\n  // @notice using fallback instead of `receive` to be compatible with clones-with-immutable-args\r\n  // more info -> https://github.com/wighawag/clones-with-immutable-args/issues/6\r\n  fallback() external payable {}\r\n}", "ABI": "[{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"wethAmount\",\"type\":\"uint96\"}],\"internalType\":\"struct Trade[]\",\"name\":\"_trades\",\"type\":\"tuple[]\"}],\"name\":\"dump\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"nah\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "Dumper", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://76ab493091c80c8db79e33c5e23b17ddd96f955accf56601c7fb80010396cef9"}]}