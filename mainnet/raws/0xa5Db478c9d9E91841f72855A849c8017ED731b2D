{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BondDepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"./interfaces/IBondCalculator.sol\\\";\\r\\nimport \\\"./interfaces/IERC20Extended.sol\\\";\\r\\nimport \\\"./interfaces/IStaking.sol\\\";\\r\\nimport \\\"./interfaces/ITreasury.sol\\\";\\r\\nimport \\\"./libraries/FixedPoint.sol\\\";\\r\\nimport \\\"./libraries/SafeMathExtended.sol\\\";\\r\\n\\r\\n\\r\\ncontract BondDepository is Ownable {\\r\\n\\r\\n    using FixedPoint for *;\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeMathExtended for uint;\\r\\n    using SafeMathExtended for uint32;\\r\\n\\r\\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\\r\\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\\r\\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\\r\\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\\r\\n\\r\\n    /* ======== STATE VARIABLES ======== */\\r\\n\\r\\n    address public immutable KEEPER; // token given as payment for bond\\r\\n    address public immutable principle; // token used to create bond\\r\\n    address public immutable treasury; // mints KEEPER when receives principle\\r\\n    address public immutable DAO; // receives profit share from bond\\r\\n\\r\\n    address public immutable bondCalculator; // calculates value of LP tokens\\r\\n    bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\\r\\n\\r\\n    address public staking; // to auto-stake payout\\r\\n    Terms public terms; // stores terms for new bonds\\r\\n    Adjust public adjustment; // stores adjustment to BCV data\\r\\n\\r\\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\\r\\n\\r\\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\\r\\n    uint32 public lastDecay; // reference time for debt decay\\r\\n\\r\\n    /* ======== STRUCTS ======== */\\r\\n\\r\\n    // Info for creating new bonds\\r\\n    struct Terms {\\r\\n        uint controlVariable; // scaling variable for price\\r\\n        uint minimumPrice; // vs principle value\\r\\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\\r\\n        uint fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)\\r\\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\\r\\n        uint32 vestingTerm; // in seconds\\r\\n    }\\r\\n\\r\\n    // Info for bond holder\\r\\n    struct Bond {\\r\\n        uint payout; // KEEPER remaining to be paid\\r\\n        uint pricePaid; // In DAI, for front end viewing\\r\\n        uint32 vesting; // seconds left to vest\\r\\n        uint32 lastTime; // Last interaction\\r\\n    }\\r\\n\\r\\n    // Info for incremental adjustments to control variable \\r\\n    struct Adjust {\\r\\n        bool add; // addition or subtraction\\r\\n        uint rate; // increment\\r\\n        uint target; // BCV when adjustment finished\\r\\n        uint32 buffer; // minimum length (in seconds) between adjustments\\r\\n        uint32 lastTime; // timestamp when last adjustment made\\r\\n    }\\r\\n\\r\\n    constructor ( address _KEEPER, address _principle, address _staking, address _treasury, address _DAO, address _bondCalculator) {\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = _KEEPER;\\r\\n        require( _principle != address(0) );\\r\\n        principle = _principle;\\r\\n        require( _treasury != address(0) );\\r\\n        treasury = _treasury;\\r\\n        require( _DAO != address(0) );\\r\\n        DAO = _DAO;\\r\\n        require( _staking != address(0) );\\r\\n        staking = _staking;\\r\\n        // bondCalculator should be address(0) if not LP bond\\r\\n        bondCalculator = _bondCalculator;\\r\\n        isLiquidityBond = ( _bondCalculator != address(0) );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice initializes bond parameters\\r\\n     *  @param _controlVariable uint\\r\\n     *  @param _vestingTerm uint\\r\\n     *  @param _minimumPrice uint\\r\\n     *  @param _maxPayout uint\\r\\n     *  @param _fee uint\\r\\n     *  @param _maxDebt uint\\r\\n     *  @param _initialDebt uint\\r\\n     */\\r\\n    function initializeBondTerms(uint _controlVariable, uint32 _vestingTerm, uint _minimumPrice, uint _maxPayout,\\r\\n                                 uint _fee, uint _maxDebt, uint _initialDebt)\\r\\n    external onlyOwner() {\\r\\n        require( terms.controlVariable == 0 && terms.vestingTerm == 0, \\\"Bonds must be initialized from 0\\\" );\\r\\n        terms = Terms ({\\r\\n            controlVariable: _controlVariable,\\r\\n            vestingTerm: _vestingTerm,\\r\\n            minimumPrice: _minimumPrice,\\r\\n            maxPayout: _maxPayout,\\r\\n            fee: _fee,\\r\\n            maxDebt: _maxDebt\\r\\n        });\\r\\n        totalDebt = _initialDebt;\\r\\n        lastDecay = uint32(block.timestamp);\\r\\n    }\\r\\n\\r\\n    /* ======== POLICY FUNCTIONS ======== */\\r\\n\\r\\n    enum PARAMETER { VESTING, PAYOUT, FEE, DEBT, MINPRICE }\\r\\n    /**\\r\\n     *  @notice set parameters for new bonds\\r\\n     *  @param _parameter PARAMETER\\r\\n     *  @param _input uint\\r\\n     */\\r\\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyOwner() {\\r\\n        if ( _parameter == PARAMETER.VESTING ) { // 0\\r\\n            require( _input >= 129600, \\\"Vesting must be longer than 36 hours\\\" );\\r\\n            decayDebt();\\r\\n            require( totalDebt == 0, \\\"Debt should be 0.\\\" );\\r\\n            terms.vestingTerm = uint32(_input);\\r\\n        }\\r\\n        else if ( _parameter == PARAMETER.PAYOUT ) { // 1\\r\\n            require( _input <= 1000, \\\"Payout cannot be above 1 percent\\\" );\\r\\n            terms.maxPayout = _input;\\r\\n        } else if ( _parameter == PARAMETER.FEE ) { // 2\\r\\n            require( _input <= 10000, \\\"DAO fee cannot exceed payout\\\" );\\r\\n            terms.fee = _input;\\r\\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\\r\\n            terms.maxDebt = _input;\\r\\n        } else if ( _parameter == PARAMETER.MINPRICE ) { // 4\\r\\n            terms.minimumPrice = _input;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice set control variable adjustment\\r\\n     *  @param _addition bool\\r\\n     *  @param _increment uint\\r\\n     *  @param _target uint\\r\\n     *  @param _buffer uint\\r\\n     */\\r\\n    function setAdjustment ( bool _addition, uint _increment, uint _target, uint32 _buffer) external onlyOwner() {\\r\\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \\\"Increment too large\\\" );\\r\\n\\r\\n        adjustment = Adjust({\\r\\n            add: _addition,\\r\\n            rate: _increment,\\r\\n            target: _target,\\r\\n            buffer: _buffer,\\r\\n            lastTime: uint32(block.timestamp)\\r\\n        });\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice set contract for auto stake\\r\\n     *  @param _staking address\\r\\n     */\\r\\n    // function setStaking( address _staking ) external onlyOwner() {\\r\\n    //     require( _staking != address(0) );\\r\\n    //     staking = _staking;\\r\\n    // }\\r\\n\\r\\n\\r\\n    /* ======== USER FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice deposit bond\\r\\n     *  @param _amount uint\\r\\n     *  @param _maxPrice uint\\r\\n     *  @param _depositor address\\r\\n     *  @return uint\\r\\n     */\\r\\n    function deposit( uint _amount, uint _maxPrice, address _depositor) external returns ( uint ) {\\r\\n        require( _depositor != address(0), \\\"Invalid address\\\" );\\r\\n        decayDebt();\\r\\n        \\r\\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\\r\\n        uint nativePrice = _bondPrice();\\r\\n\\r\\n        require( _maxPrice >= nativePrice, \\\"Slippage limit: more than max price\\\" ); // slippage protection\\r\\n\\r\\n        uint value = ITreasury( treasury ).valueOfToken( principle, _amount );\\r\\n        uint payout = payoutFor( value ); // payout to bonder is computed\\r\\n\\r\\n        require( payout >= 10000000, \\\"Bond too small\\\" ); // must be > 0.01 KEEPER ( underflow protection )\\r\\n        require( payout <= maxPayout(), \\\"Bond too large\\\"); // size protection because there is no slippage\\r\\n\\r\\n        // profits are calculated\\r\\n        uint fee = payout.mul( terms.fee ).div( 10000 );\\r\\n        uint profit = value.sub( payout ).sub( fee );\\r\\n\\r\\n        /**\\r\\n            principle is transferred in\\r\\n            approved and\\r\\n            deposited into the treasury, returning (_amount - profit) KEEPER\\r\\n         */\\r\\n        IERC20( principle ).safeTransferFrom( msg.sender, address(this), _amount );\\r\\n        IERC20( principle ).approve( address( treasury ), _amount );\\r\\n        ITreasury( treasury ).deposit( _amount, principle, profit );\\r\\n        \\r\\n        if ( fee != 0 ) { // fee is transferred to dao \\r\\n            IERC20( KEEPER ).safeTransfer( DAO, fee ); \\r\\n        }\\r\\n        \\r\\n        // total debt is increased\\r\\n        totalDebt = totalDebt.add( value ); \\r\\n        require( totalDebt <= terms.maxDebt, \\\"Max capacity reached\\\" );\\r\\n                \\r\\n        // depositor info is stored\\r\\n        bondInfo[ _depositor ] = Bond({ \\r\\n            payout: bondInfo[ _depositor ].payout.add( payout ),\\r\\n            vesting: terms.vestingTerm,\\r\\n            lastTime: uint32(block.timestamp),\\r\\n            pricePaid: priceInUSD\\r\\n        });\\r\\n\\r\\n        // indexed events are emitted\\r\\n        emit BondCreated( _amount, payout, block.timestamp.add( terms.vestingTerm ), priceInUSD );\\r\\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\\r\\n\\r\\n        adjust(); // control variable is adjusted\\r\\n        return payout; \\r\\n    }\\r\\n\\r\\n    /** \\r\\n     *  @notice redeem bond for user\\r\\n     *  @param _recipient address\\r\\n     *  @param _stake bool\\r\\n     *  @return uint\\r\\n     */ \\r\\n    function redeem( address _recipient, bool _stake, bool _wrap ) external returns ( uint ) {        \\r\\n        Bond memory info = bondInfo[ _recipient ];\\r\\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\\r\\n\\r\\n        if ( percentVested >= 10000 ) { // if fully vested\\r\\n            delete bondInfo[ _recipient ]; // delete user info\\r\\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\\r\\n            return stakeOrSend( _recipient, _stake, _wrap, info.payout ); // pay user everything due\\r\\n\\r\\n        } else { // if unfinished\\r\\n            // calculate payout vested\\r\\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\\r\\n\\r\\n            // store updated deposit info\\r\\n            bondInfo[ _recipient ] = Bond({\\r\\n                payout: info.payout.sub( payout ),\\r\\n                vesting: info.vesting.sub32( uint32(block.timestamp).sub32( info.lastTime ) ),\\r\\n                lastTime: uint32(block.timestamp),\\r\\n                pricePaid: info.pricePaid\\r\\n            });\\r\\n\\r\\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\\r\\n            return stakeOrSend( _recipient, _stake, _wrap, payout );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    \\r\\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice allow user to stake payout automatically\\r\\n     *  @param _stake bool\\r\\n     *  @param _amount uint\\r\\n     *  @return uint\\r\\n     */\\r\\n    function stakeOrSend( address _recipient, bool _stake, bool _wrap, uint _amount ) internal returns ( uint ) {\\r\\n        if ( !_stake ) { // if user does not want to stake\\r\\n            IERC20( KEEPER ).transfer( _recipient, _amount ); // send payout\\r\\n        } else { // if user wants to stake\\r\\n            IERC20( KEEPER ).approve( staking, _amount );\\r\\n            IStaking( staking ).stake( _amount, _recipient, _wrap );\\r\\n        }\\r\\n        return _amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice makes incremental adjustment to control variable\\r\\n     */\\r\\n    function adjust() internal {\\r\\n        uint timeCanAdjust = adjustment.lastTime.add( adjustment.buffer );\\r\\n        if( adjustment.rate != 0 && block.timestamp >= timeCanAdjust ) {\\r\\n            uint initial = terms.controlVariable;\\r\\n            if ( adjustment.add ) {\\r\\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\\r\\n                if ( terms.controlVariable >= adjustment.target ) {\\r\\n                    adjustment.rate = 0;\\r\\n                }\\r\\n            } else {\\r\\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\\r\\n                if ( terms.controlVariable <= adjustment.target || terms.controlVariable < adjustment.rate ) {\\r\\n                    adjustment.rate = 0;\\r\\n                }\\r\\n            }\\r\\n            adjustment.lastTime = uint32(block.timestamp);\\r\\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice reduce total debt\\r\\n     */\\r\\n    function decayDebt() internal {\\r\\n        totalDebt = totalDebt.sub( debtDecay() );\\r\\n        lastDecay = uint32(block.timestamp);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    /* ======== VIEW FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice determine maximum bond size\\r\\n     *  @return uint\\r\\n     */\\r\\n    function maxPayout() public view returns ( uint ) {\\r\\n        return IERC20( KEEPER ).totalSupply().mul( terms.maxPayout ).div( 100000 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate interest due for new bond\\r\\n     *  @param _value uint\\r\\n     *  @return uint\\r\\n     */\\r\\n    function payoutFor( uint _value ) public view returns ( uint ) {\\r\\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e16 );\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current bond premium\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function bondPrice() public view returns ( uint price_ ) {        \\r\\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\\r\\n        if ( price_ < terms.minimumPrice ) {\\r\\n            price_ = terms.minimumPrice;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current bond price and remove floor if above\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function _bondPrice() internal returns ( uint price_ ) {\\r\\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\\r\\n        if ( price_ < terms.minimumPrice ) {\\r\\n            price_ = terms.minimumPrice;        \\r\\n        } else if ( terms.minimumPrice != 0 ) {\\r\\n            terms.minimumPrice = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice converts bond price to DAI value\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function bondPriceInUSD() public view returns ( uint price_ ) {\\r\\n        if( isLiquidityBond ) {\\r\\n            price_ = bondPrice().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 100 );\\r\\n        } else {\\r\\n            price_ = bondPrice().mul( 10 ** IERC20Extended( principle ).decimals() ).div( 100 );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current ratio of debt to KEEPER supply\\r\\n     *  @return debtRatio_ uint\\r\\n     */\\r\\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \\r\\n        uint supply = IERC20( KEEPER ).totalSupply();\\r\\n        debtRatio_ = FixedPoint.fraction( \\r\\n            currentDebt().mul( 1e9 ), \\r\\n            supply\\r\\n        ).decode112with18().div( 1e18 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice debt ratio in same terms for reserve or liquidity bonds\\r\\n     *  @return uint\\r\\n     */\\r\\n    function standardizedDebtRatio() external view returns ( uint ) {\\r\\n        if ( isLiquidityBond ) {\\r\\n            return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\\r\\n        } else {\\r\\n            return debtRatio();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate debt factoring in decay\\r\\n     *  @return uint\\r\\n     */\\r\\n    function currentDebt() public view returns ( uint ) {\\r\\n        return totalDebt.sub( debtDecay() );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice amount to decay total debt by\\r\\n     *  @return decay_ uint\\r\\n     */\\r\\n    function debtDecay() public view returns ( uint decay_ ) {\\r\\n        uint32 timeSinceLast = uint32(block.timestamp).sub32( lastDecay );\\r\\n        decay_ = totalDebt.mul( timeSinceLast ).div( terms.vestingTerm );\\r\\n        if ( decay_ > totalDebt ) {\\r\\n            decay_ = totalDebt;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate how far into vesting a depositor is\\r\\n     *  @param _depositor address\\r\\n     *  @return percentVested_ uint\\r\\n     */\\r\\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\\r\\n        Bond memory bond = bondInfo[ _depositor ];\\r\\n        uint timeSinceLast = uint32(block.timestamp).sub( bond.lastTime );\\r\\n        uint vesting = bond.vesting;\\r\\n\\r\\n        if ( vesting > 0 ) {\\r\\n            percentVested_ = timeSinceLast.mul( 10000 ).div( vesting );\\r\\n        } else {\\r\\n            percentVested_ = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate amount of KEEPER available for claim by depositor\\r\\n     *  @param _depositor address\\r\\n     *  @return pendingPayout_ uint\\r\\n     */\\r\\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\\r\\n        uint percentVested = percentVestedFor( _depositor );\\r\\n        uint payout = bondInfo[ _depositor ].payout;\\r\\n\\r\\n        if ( percentVested >= 10000 ) {\\r\\n            pendingPayout_ = payout;\\r\\n        } else {\\r\\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    /* ======= AUXILLIARY ======= */\\r\\n\\r\\n    /**\\r\\n     *  @notice allow anyone to send lost tokens (excluding principle or KEEPER) to the DAO\\r\\n     *  @return bool\\r\\n     */\\r\\n    function recoverLostToken( address _token ) external returns ( bool ) {\\r\\n        require( _token != KEEPER );\\r\\n        require( _token != principle );\\r\\n        IERC20( _token ).safeTransfer( DAO, IERC20( _token ).balanceOf( address(this) ) );\\r\\n        return true;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBondCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\ninterface IBondCalculator {\\r\\n    function markdown( address _LP ) external view returns ( uint );\\r\\n\\r\\n    function valuation( address pair_, uint amount_ ) external view returns ( uint _value );\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC20Extended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IERC20Extended is IERC20 {\\r\\n    function decimals() external view returns (uint8);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\ninterface IStaking {\\r\\n    function stake( uint _amount, address _recipient, bool _wrap ) external returns ( uint );\\r\\n\\r\\n    function claim ( address _recipient ) external returns ( uint );\\r\\n\\r\\n    function forfeit() external returns ( uint );\\r\\n\\r\\n    function toggleLock() external;\\r\\n\\r\\n    function unstake( uint _amount, bool _trigger ) external returns ( uint );\\r\\n\\r\\n    function rebase() external;\\r\\n\\r\\n    function index() external view returns ( uint );\\r\\n\\r\\n    function contractBalance() external view returns ( uint );\\r\\n\\r\\n    function totalStaked() external view returns ( uint );\\r\\n\\r\\n    function supplyInWarmup() external view returns ( uint );\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\n\\r\\ninterface ITreasury {\\r\\n\\r\\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( uint );\\r\\n    \\r\\n    function withdraw( uint _amount, address _token ) external;\\r\\n\\r\\n    function valueOfToken( address _token, uint _amount ) external view returns ( uint value_ );\\r\\n  \\r\\n    function mint( address _recipient, uint _amount ) external;\\r\\n\\r\\n    function mintRewards( address _recipient, uint _amount ) external;\\r\\n\\r\\n    function incurDebt( uint amount_, address token_ ) external;\\r\\n    \\r\\n    function repayDebtWithReserve( uint amount_, address token_ ) external;\\r\\n}\"\r\n    },\r\n    \"contracts/libraries/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity >=0.5.0 <0.8.0;\\r\\n\\r\\nimport \\\"./FullMath.sol\\\";\\r\\n\\r\\n\\r\\nlibrary Babylonian {\\r\\n\\r\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\r\\n        if (x == 0) return 0;\\r\\n\\r\\n        uint256 xx = x;\\r\\n        uint256 r = 1;\\r\\n        if (xx >= 0x100000000000000000000000000000000) {\\r\\n            xx >>= 128;\\r\\n            r <<= 64;\\r\\n        }\\r\\n        if (xx >= 0x10000000000000000) {\\r\\n            xx >>= 64;\\r\\n            r <<= 32;\\r\\n        }\\r\\n        if (xx >= 0x100000000) {\\r\\n            xx >>= 32;\\r\\n            r <<= 16;\\r\\n        }\\r\\n        if (xx >= 0x10000) {\\r\\n            xx >>= 16;\\r\\n            r <<= 8;\\r\\n        }\\r\\n        if (xx >= 0x100) {\\r\\n            xx >>= 8;\\r\\n            r <<= 4;\\r\\n        }\\r\\n        if (xx >= 0x10) {\\r\\n            xx >>= 4;\\r\\n            r <<= 2;\\r\\n        }\\r\\n        if (xx >= 0x8) {\\r\\n            r <<= 1;\\r\\n        }\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\r\\n        uint256 r1 = x / r;\\r\\n        return (r < r1 ? r : r1);\\r\\n    }\\r\\n}\\r\\n\\r\\nlibrary BitMath {\\r\\n\\r\\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\\r\\n        require(x > 0, 'BitMath::mostSignificantBit: zero');\\r\\n\\r\\n        if (x >= 0x100000000000000000000000000000000) {\\r\\n            x >>= 128;\\r\\n            r += 128;\\r\\n        }\\r\\n        if (x >= 0x10000000000000000) {\\r\\n            x >>= 64;\\r\\n            r += 64;\\r\\n        }\\r\\n        if (x >= 0x100000000) {\\r\\n            x >>= 32;\\r\\n            r += 32;\\r\\n        }\\r\\n        if (x >= 0x10000) {\\r\\n            x >>= 16;\\r\\n            r += 16;\\r\\n        }\\r\\n        if (x >= 0x100) {\\r\\n            x >>= 8;\\r\\n            r += 8;\\r\\n        }\\r\\n        if (x >= 0x10) {\\r\\n            x >>= 4;\\r\\n            r += 4;\\r\\n        }\\r\\n        if (x >= 0x4) {\\r\\n            x >>= 2;\\r\\n            r += 2;\\r\\n        }\\r\\n        if (x >= 0x2) r += 1;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\nlibrary FixedPoint {\\r\\n\\r\\n    struct uq112x112 {\\r\\n        uint224 _x;\\r\\n    }\\r\\n\\r\\n    struct uq144x112 {\\r\\n        uint256 _x;\\r\\n    }\\r\\n\\r\\n    uint8 private constant RESOLUTION = 112;\\r\\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\\r\\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\\r\\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\\r\\n\\r\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\r\\n        return uint112(self._x >> RESOLUTION);\\r\\n    }\\r\\n\\r\\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\\r\\n\\r\\n        return uint(self._x) / 5192296858534827;\\r\\n    }\\r\\n\\r\\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\\r\\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\\r\\n        if (numerator == 0) return FixedPoint.uq112x112(0);\\r\\n\\r\\n        if (numerator <= uint144(-1)) {\\r\\n            uint256 result = (numerator << RESOLUTION) / denominator;\\r\\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\\r\\n            return uq112x112(uint224(result));\\r\\n        } else {\\r\\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\\r\\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\\r\\n            return uq112x112(uint224(result));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // square root of a UQ112x112\\r\\n    // lossy between 0/1 and 40 bits\\r\\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\r\\n        if (self._x <= uint144(-1)) {\\r\\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\\r\\n        }\\r\\n\\r\\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\\r\\n        safeShiftBits -= safeShiftBits % 2;\\r\\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/libraries/SafeMathExtended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nlibrary SafeMathExtended {\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function add32(uint32 a, uint32 b) internal pure returns (uint32) {\\r\\n        uint32 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub32(uint32 a, uint32 b) internal pure returns (uint32) {\\r\\n        return sub32(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub32(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint32 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul32(uint32 a, uint32 b) internal pure returns (uint32) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint32 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity >=0.5.0 <0.8.0;\\r\\n\\r\\nlibrary FullMath {\\r\\n    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\\r\\n        uint256 mm = mulmod(x, y, uint256(-1));\\r\\n        l = x * y;\\r\\n        h = mm - l;\\r\\n        if (mm < l) h -= 1;\\r\\n    }\\r\\n\\r\\n    function fullDiv(\\r\\n        uint256 l,\\r\\n        uint256 h,\\r\\n        uint256 d\\r\\n    ) private pure returns (uint256) {\\r\\n        uint256 pow2 = d & -d;\\r\\n        d /= pow2;\\r\\n        l /= pow2;\\r\\n        l += h * ((-pow2) / pow2 + 1);\\r\\n        uint256 r = 1;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        return l * r;\\r\\n    }\\r\\n\\r\\n    function mulDiv(\\r\\n        uint256 x,\\r\\n        uint256 y,\\r\\n        uint256 d\\r\\n    ) internal pure returns (uint256) {\\r\\n        (uint256 l, uint256 h) = fullMul(x, y);\\r\\n        uint256 mm = mulmod(x, y, d);\\r\\n        if (mm > l) h -= 1;\\r\\n        l -= mm;\\r\\n        require(h < d, 'FullMath::mulDiv: overflow');\\r\\n        return fullDiv(l, h, d);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/VLPBondStakeDepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"./interfaces/IBondCalculator.sol\\\";\\r\\nimport \\\"./interfaces/AggregateV3Interface.sol\\\";\\r\\nimport \\\"./interfaces/ITreasury.sol\\\";\\r\\nimport \\\"./interfaces/IsKEEPER.sol\\\";\\r\\nimport \\\"./interfaces/IwTROVE.sol\\\";\\r\\nimport \\\"./interfaces/IStaking.sol\\\";\\r\\nimport \\\"./libraries/FixedPoint.sol\\\";\\r\\nimport \\\"./libraries/SafeMathExtended.sol\\\";\\r\\n\\r\\n\\r\\ncontract VLPBondStakeDepository is Ownable {\\r\\n    using FixedPoint for *;\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeMathExtended for uint;\\r\\n    using SafeMathExtended for uint32;\\r\\n\\r\\n    /* ======== EVENTS ======== */\\r\\n\\r\\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\\r\\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\\r\\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\\r\\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\\r\\n\\r\\n    /* ======== STATE VARIABLES ======== */\\r\\n\\r\\n    address public immutable KEEPER; // token given as payment for bond\\r\\n    address public immutable sKEEPER; // token given as payment for bond\\r\\n    address public immutable wTROVE; // Wrap sKEEPER\\r\\n    address public immutable principle; // token used to create bond\\r\\n    address public immutable treasury; // mints KEEPER when receives principle\\r\\n\\r\\n    address public immutable bondCalculator; // calculates value of LP tokens\\r\\n\\r\\n    AggregatorV3Interface internal priceFeed;\\r\\n\\r\\n    address public staking; // to auto-stake payout\\r\\n\\r\\n    Terms public terms; // stores terms for new bonds\\r\\n    Adjust public adjustment; // stores adjustment to BCV data\\r\\n\\r\\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\\r\\n\\r\\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\\r\\n    uint32 public lastDecay; // reference block for debt decay\\r\\n\\r\\n\\r\\n    /* ======== STRUCTS ======== */\\r\\n\\r\\n    // Info for creating new bonds\\r\\n    struct Terms {\\r\\n        uint32 vestingTerm; // in seconds\\r\\n        uint controlVariable; // scaling variable for price\\r\\n        uint minimumPrice; // vs principle value. 4 decimals (1500 = 0.15)\\r\\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\\r\\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\\r\\n    }\\r\\n\\r\\n    // Info for bond holder\\r\\n    struct Bond {\\r\\n        uint32 vesting; // seconds left to vest\\r\\n        uint32 lastTime; // Last interaction\\r\\n        uint gonsPayout; // KEEPER remaining to be paid\\r\\n        uint pricePaid; // In DAI, for front end viewing\\r\\n    }\\r\\n\\r\\n    // Info for incremental adjustments to control variable \\r\\n    struct Adjust {\\r\\n        bool add; // addition or subtraction\\r\\n        uint rate; // increment\\r\\n        uint target; // BCV when adjustment finished\\r\\n        uint32 buffer; // minimum length (in blocks) between adjustments\\r\\n        uint32 lastTime; // block when last adjustment made\\r\\n    }\\r\\n\\r\\n    /* ======== INITIALIZATION ======== */\\r\\n\\r\\n    constructor ( address _KEEPER, address _sKEEPER, address _wTROVE, address _principle, address _staking, address _treasury, address _bondCalculator, address _feed) {\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = _KEEPER;\\r\\n        require( _sKEEPER != address(0) );\\r\\n        sKEEPER = _sKEEPER;\\r\\n        require( _wTROVE != address(0) );\\r\\n        wTROVE = _wTROVE;\\r\\n        require( _principle != address(0) );\\r\\n        principle = _principle;\\r\\n        require( _treasury != address(0) );\\r\\n        treasury = _treasury;\\r\\n        require( _staking != address(0) );\\r\\n        staking = _staking;\\r\\n        require( _bondCalculator != address(0) );\\r\\n        bondCalculator = _bondCalculator;\\r\\n        require( _feed != address(0) );\\r\\n        priceFeed = AggregatorV3Interface( _feed );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice initializes bond parameters\\r\\n     *  @param _controlVariable uint\\r\\n     *  @param _vestingTerm uint\\r\\n     *  @param _minimumPrice uint\\r\\n     *  @param _maxPayout uint\\r\\n     *  @param _maxDebt uint\\r\\n     *  @param _initialDebt uint\\r\\n     */\\r\\n    function initializeBondTerms(uint _controlVariable, uint32 _vestingTerm, uint _minimumPrice, uint _maxPayout,\\r\\n                                 uint _maxDebt, uint _initialDebt) external onlyOwner() {\\r\\n        require( terms.controlVariable == 0 && terms.vestingTerm == 0, \\\"Bonds must be initialized from 0\\\" );\\r\\n        terms = Terms ({\\r\\n            controlVariable: _controlVariable,\\r\\n            vestingTerm: _vestingTerm,\\r\\n            minimumPrice: _minimumPrice,\\r\\n            maxPayout: _maxPayout,\\r\\n            maxDebt: _maxDebt\\r\\n        });\\r\\n        totalDebt = _initialDebt;\\r\\n        lastDecay = uint32(block.timestamp);\\r\\n    }\\r\\n\\r\\n\\r\\n    \\r\\n    /* ======== POLICY FUNCTIONS ======== */\\r\\n\\r\\n    enum PARAMETER { VESTING, PAYOUT, DEBT, MINPRICE }\\r\\n    /**\\r\\n     *  @notice set parameters for new bonds\\r\\n     *  @param _parameter PARAMETER\\r\\n     *  @param _input uint\\r\\n     */\\r\\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyOwner() {\\r\\n        if ( _parameter == PARAMETER.VESTING ) { // 0\\r\\n            require( _input >= 129600, \\\"Vesting must be longer than 36 hours\\\" );\\r\\n            require( currentDebt() == 0, \\\"Debt should be 0.\\\" );\\r\\n            terms.vestingTerm = uint32(_input);\\r\\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\\r\\n            require( _input <= 1000, \\\"Payout cannot be above 1 percent\\\" );\\r\\n            terms.maxPayout = _input;\\r\\n        } else if ( _parameter == PARAMETER.DEBT ) { // 2\\r\\n            terms.maxDebt = _input;\\r\\n        } else if ( _parameter == PARAMETER.MINPRICE ) { // 3\\r\\n            terms.minimumPrice = _input;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice set control variable adjustment\\r\\n     *  @param _addition bool\\r\\n     *  @param _increment uint\\r\\n     *  @param _target uint\\r\\n     *  @param _buffer uint\\r\\n     */\\r\\n    function setAdjustment ( bool _addition, uint _increment, uint _target, uint32 _buffer ) external onlyOwner() {\\r\\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \\\"Increment too large\\\" );\\r\\n\\r\\n        adjustment = Adjust({\\r\\n            add: _addition,\\r\\n            rate: _increment,\\r\\n            target: _target,\\r\\n            buffer: _buffer,\\r\\n            lastTime: uint32(block.timestamp)\\r\\n        });\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice set contract for auto stake\\r\\n     *  @param _staking address\\r\\n     */\\r\\n    // function setStaking( address _staking ) external onlyOwner() {\\r\\n    //     require( _staking != address(0) );\\r\\n    //     staking = _staking;\\r\\n    // }\\r\\n\\r\\n\\r\\n    /* ======== USER FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice deposit bond\\r\\n     *  @param _amount uint\\r\\n     *  @param _maxPrice uint\\r\\n     *  @param _depositor address\\r\\n     *  @return uint\\r\\n     */\\r\\n    function deposit( uint _amount, uint _maxPrice, address _depositor) external returns ( uint ) {\\r\\n        require( _depositor != address(0), \\\"Invalid address\\\" );\\r\\n        decayDebt();\\r\\n        \\r\\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\\r\\n        uint nativePrice = _bondPrice();\\r\\n\\r\\n        require( _maxPrice >= nativePrice, \\\"Slippage limit: more than max price\\\" ); // slippage protection\\r\\n\\r\\n        uint value = ITreasury( treasury ).valueOfToken( principle, _amount );\\r\\n        uint payout = payoutFor( value ); // payout to bonder is computed\\r\\n\\r\\n        require( payout >= 10000000, \\\"Bond too small\\\" ); // must be > 0.01 KEEPER ( underflow protection )\\r\\n        require( payout <= maxPayout(), \\\"Bond too large\\\"); // size protection because there is no slippage\\r\\n\\r\\n        /**\\r\\n            asset carries risk and is not minted against\\r\\n            asset transfered to treasury and rewards minted as payout\\r\\n         */\\r\\n        IERC20( principle ).safeTransferFrom( msg.sender, treasury, _amount );\\r\\n        ITreasury( treasury ).mintRewards( address(this), payout );\\r\\n        \\r\\n        // total debt is increased\\r\\n        totalDebt = totalDebt.add( value ); \\r\\n        require( totalDebt <= terms.maxDebt, \\\"Max capacity reached\\\" );\\r\\n                \\r\\n        IERC20( KEEPER ).approve( staking, payout );\\r\\n        IStaking( staking ).stake( payout, address(this), false );\\r\\n        IStaking( staking ).claim( address(this) );\\r\\n        uint stakeGons = IsKEEPER(sKEEPER).gonsForBalance(payout);\\r\\n                \\r\\n        // depositor info is stored\\r\\n        bondInfo[ _depositor ] = Bond({ \\r\\n            gonsPayout: bondInfo[ _depositor ].gonsPayout.add( stakeGons ),\\r\\n            vesting: terms.vestingTerm,\\r\\n            lastTime: uint32(block.timestamp),\\r\\n            pricePaid: priceInUSD\\r\\n        });\\r\\n\\r\\n        // indexed events are emitted\\r\\n        emit BondCreated( _amount, payout, block.timestamp.add( terms.vestingTerm ), priceInUSD );\\r\\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\\r\\n\\r\\n        adjust(); // control variable is adjusted\\r\\n        return payout; \\r\\n    }\\r\\n\\r\\n    /** \\r\\n     *  @notice redeem bond for user\\r\\n     *  @param _recipient address\\r\\n     *  @param _stake bool\\r\\n     *  @return uint\\r\\n     */ \\r\\n    function redeem( address _recipient, bool _stake, bool _wrap ) external returns ( uint ) {        \\r\\n        Bond memory info = bondInfo[ _recipient ];\\r\\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\\r\\n\\r\\n        if ( percentVested >= 10000 ) { // if fully vested\\r\\n            delete bondInfo[ _recipient ]; // delete user info\\r\\n            uint _amount = IsKEEPER(sKEEPER).balanceForGons(info.gonsPayout);\\r\\n            emit BondRedeemed( _recipient, _amount, 0 ); // emit bond data\\r\\n            return sendOrWrap( _recipient, _wrap, _amount ); // pay user everything due\\r\\n\\r\\n        } else { // if unfinished\\r\\n            // calculate payout vested\\r\\n            uint gonsPayout = info.gonsPayout.mul( percentVested ).div( 10000 );\\r\\n            // store updated deposit info\\r\\n            bondInfo[ _recipient ] = Bond({\\r\\n                gonsPayout: info.gonsPayout.sub( gonsPayout ),\\r\\n                vesting: info.vesting.sub32( uint32(block.timestamp).sub32( info.lastTime ) ),\\r\\n                lastTime: uint32(block.timestamp),\\r\\n                pricePaid: info.pricePaid\\r\\n            });\\r\\n\\r\\n            uint _amount = IsKEEPER(sKEEPER).balanceForGons(gonsPayout);\\r\\n            uint _remainingAmount = IsKEEPER(sKEEPER).balanceForGons(bondInfo[_recipient].gonsPayout);\\r\\n            emit BondRedeemed( _recipient, _amount, _remainingAmount );\\r\\n            return sendOrWrap( _recipient, _wrap, _amount );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    \\r\\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice allow user to wrap payout automatically\\r\\n     *  @param _wrap bool\\r\\n     *  @param _amount uint\\r\\n     *  @return uint\\r\\n     */\\r\\n    function sendOrWrap( address _recipient, bool _wrap, uint _amount ) internal returns ( uint ) {\\r\\n        if ( _wrap ) { // if user wants to wrap\\r\\n            IERC20(sKEEPER).approve( wTROVE, _amount );\\r\\n            uint wrapValue = IwTROVE(wTROVE).wrap( _amount );\\r\\n            IwTROVE(wTROVE).transfer( _recipient, wrapValue );\\r\\n        } else { // if user wants to stake\\r\\n            IERC20( sKEEPER ).transfer( _recipient, _amount ); // send payout\\r\\n        }\\r\\n        return _amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice makes incremental adjustment to control variable\\r\\n     */\\r\\n    function adjust() internal {\\r\\n        uint timeCanAdjust = adjustment.lastTime.add( adjustment.buffer );\\r\\n        if( adjustment.rate != 0 && block.timestamp >= timeCanAdjust ) {\\r\\n            uint initial = terms.controlVariable;\\r\\n            if ( adjustment.add ) {\\r\\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\\r\\n                if ( terms.controlVariable >= adjustment.target ) {\\r\\n                    adjustment.rate = 0;\\r\\n                }\\r\\n            } else {\\r\\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\\r\\n                if ( terms.controlVariable <= adjustment.target || terms.controlVariable < adjustment.rate ) {\\r\\n                    adjustment.rate = 0;\\r\\n                }\\r\\n            }\\r\\n            adjustment.lastTime = uint32(block.timestamp);\\r\\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice reduce total debt\\r\\n     */\\r\\n    function decayDebt() internal {\\r\\n        totalDebt = totalDebt.sub( debtDecay() );\\r\\n        lastDecay = uint32(block.timestamp);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    /* ======== VIEW FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice determine maximum bond size\\r\\n     *  @return uint\\r\\n     */\\r\\n    function maxPayout() public view returns ( uint ) {\\r\\n        return IERC20( KEEPER ).totalSupply().mul( terms.maxPayout ).div( 100000 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate interest due for new bond\\r\\n     *  @param _value uint\\r\\n     *  @return uint\\r\\n     */\\r\\n    function payoutFor( uint _value ) public view returns ( uint ) {\\r\\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e14 );\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current bond premium\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function bondPrice() public view returns ( uint price_ ) {        \\r\\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\\r\\n        if ( price_ < terms.minimumPrice ) {\\r\\n            price_ = terms.minimumPrice;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current bond price and remove floor if above\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function _bondPrice() internal returns ( uint price_ ) {\\r\\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\\r\\n        if ( price_ < terms.minimumPrice ) {\\r\\n            price_ = terms.minimumPrice;        \\r\\n        } else if ( terms.minimumPrice != 0 ) {\\r\\n            terms.minimumPrice = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice get asset price from chainlink\\r\\n     */\\r\\n    function assetPrice() public view returns (int) {\\r\\n        ( , int price, , , ) = priceFeed.latestRoundData();\\r\\n        return price;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice converts bond price to DAI value\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function bondPriceInUSD() public view returns ( uint price_ ) {\\r\\n        price_ = bondPrice()\\r\\n                    .mul( IBondCalculator( bondCalculator ).markdown( principle ) )\\r\\n                    .mul( uint( assetPrice() ) )\\r\\n                    .div( 1e12 );\\r\\n    }\\r\\n\\r\\n    function getBondInfo(address _depositor) public view returns ( uint payout, uint vesting, uint lastTime, uint pricePaid ) {\\r\\n        Bond memory info = bondInfo[ _depositor ];\\r\\n        payout = IsKEEPER(sKEEPER).balanceForGons(info.gonsPayout);\\r\\n        vesting = info.vesting;\\r\\n        lastTime = info.lastTime;\\r\\n        pricePaid = info.pricePaid;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current ratio of debt to KEEPER supply\\r\\n     *  @return debtRatio_ uint\\r\\n     */\\r\\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \\r\\n        uint supply = IERC20( KEEPER ).totalSupply();\\r\\n        debtRatio_ = FixedPoint.fraction( \\r\\n            currentDebt().mul( 1e9 ), \\r\\n            supply\\r\\n        ).decode112with18().div( 1e18 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice debt ratio in same terms as reserve bonds\\r\\n     *  @return uint\\r\\n     */\\r\\n    function standardizedDebtRatio() external view returns ( uint ) {\\r\\n        return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate debt factoring in decay\\r\\n     *  @return uint\\r\\n     */\\r\\n    function currentDebt() public view returns ( uint ) {\\r\\n        return totalDebt.sub( debtDecay() );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice amount to decay total debt by\\r\\n     *  @return decay_ uint\\r\\n     */\\r\\n    function debtDecay() public view returns ( uint decay_ ) {\\r\\n        uint32 timeSinceLast = uint32(block.timestamp).sub32( lastDecay );\\r\\n        decay_ = totalDebt.mul( timeSinceLast ).div( terms.vestingTerm );\\r\\n        if ( decay_ > totalDebt ) {\\r\\n            decay_ = totalDebt;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate how far into vesting a depositor is\\r\\n     *  @param _depositor address\\r\\n     *  @return percentVested_ uint\\r\\n     */\\r\\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\\r\\n        Bond memory bond = bondInfo[ _depositor ];\\r\\n        uint timeSinceLast = uint32(block.timestamp).sub( bond.lastTime );\\r\\n        uint vesting = bond.vesting;\\r\\n\\r\\n        if ( vesting > 0 ) {\\r\\n            percentVested_ = timeSinceLast.mul( 10000 ).div( vesting );\\r\\n        } else {\\r\\n            percentVested_ = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate amount of KEEPER available for claim by depositor\\r\\n     *  @param _depositor address\\r\\n     *  @return pendingPayout_ uint\\r\\n     */\\r\\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\\r\\n        uint percentVested = percentVestedFor( _depositor );\\r\\n        uint payout = IsKEEPER(sKEEPER).balanceForGons(bondInfo[ _depositor ].gonsPayout);\\r\\n\\r\\n        if ( percentVested >= 10000 ) {\\r\\n            pendingPayout_ = payout;\\r\\n        } else {\\r\\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/AggregateV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.5;\\r\\n\\r\\ninterface AggregatorV3Interface {\\r\\n  function decimals() external view returns (uint8);\\r\\n\\r\\n  function description() external view returns (string memory);\\r\\n\\r\\n  function version() external view returns (uint256);\\r\\n\\r\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\r\\n  // if they do not have data to report, instead of returning unset values\\r\\n  // which could be misinterpreted as actual reported values.\\r\\n  function getRoundData(uint80 _roundId)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n\\r\\n  function latestRoundData()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IsKEEPER.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IsKEEPER is IERC20 {\\r\\n    function rebase( uint256 profit_, uint epoch_) external returns (uint256);\\r\\n\\r\\n    function circulatingSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address who) external override view returns (uint256);\\r\\n\\r\\n    function gonsForBalance( uint amount ) external view returns ( uint );\\r\\n\\r\\n    function balanceForGons( uint gons ) external view returns ( uint );\\r\\n    \\r\\n    function index() external view returns ( uint );\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IwTROVE.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IwTROVE is IERC20 {\\r\\n    function wrap(uint _amount) external returns (uint);\\r\\n\\r\\n    function unwrap(uint _amount) external returns (uint);\\r\\n}\"\r\n    },\r\n    \"contracts/VLPBondDepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"./interfaces/IBondCalculator.sol\\\";\\r\\nimport \\\"./interfaces/AggregateV3Interface.sol\\\";\\r\\nimport \\\"./interfaces/ITreasury.sol\\\";\\r\\nimport \\\"./interfaces/IStaking.sol\\\";\\r\\nimport \\\"./libraries/FixedPoint.sol\\\";\\r\\nimport \\\"./libraries/SafeMathExtended.sol\\\";\\r\\n\\r\\n\\r\\ncontract VLPBondDepository is Ownable {\\r\\n    using FixedPoint for *;\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeMathExtended for uint;\\r\\n    using SafeMathExtended for uint32;\\r\\n\\r\\n    /* ======== EVENTS ======== */\\r\\n\\r\\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\\r\\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\\r\\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\\r\\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\\r\\n\\r\\n    /* ======== STATE VARIABLES ======== */\\r\\n\\r\\n    address public immutable KEEPER; // token given as payment for bond\\r\\n    address public immutable principle; // token used to create bond\\r\\n    address public immutable treasury; // mints KEEPER when receives principle\\r\\n\\r\\n    address public immutable bondCalculator; // calculates value of LP tokens\\r\\n\\r\\n    AggregatorV3Interface internal priceFeed;\\r\\n\\r\\n    address public staking; // to auto-stake payout\\r\\n\\r\\n    Terms public terms; // stores terms for new bonds\\r\\n    Adjust public adjustment; // stores adjustment to BCV data\\r\\n\\r\\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\\r\\n\\r\\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\\r\\n    uint32 public lastDecay; // reference block for debt decay\\r\\n\\r\\n\\r\\n    /* ======== STRUCTS ======== */\\r\\n\\r\\n    // Info for creating new bonds\\r\\n    struct Terms {\\r\\n        uint32 vestingTerm; // in seconds\\r\\n        uint controlVariable; // scaling variable for price\\r\\n        uint minimumPrice; // vs principle value. 4 decimals (1500 = 0.15)\\r\\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\\r\\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\\r\\n    }\\r\\n\\r\\n    // Info for bond holder\\r\\n    struct Bond {\\r\\n        uint32 vesting; // seconds left to vest\\r\\n        uint32 lastTime; // Last interaction\\r\\n        uint payout; // KEEPER remaining to be paid\\r\\n        uint pricePaid; // In DAI, for front end viewing\\r\\n    }\\r\\n\\r\\n    // Info for incremental adjustments to control variable \\r\\n    struct Adjust {\\r\\n        bool add; // addition or subtraction\\r\\n        uint rate; // increment\\r\\n        uint target; // BCV when adjustment finished\\r\\n        uint32 buffer; // minimum length (in blocks) between adjustments\\r\\n        uint32 lastTime; // block when last adjustment made\\r\\n    }\\r\\n\\r\\n    /* ======== INITIALIZATION ======== */\\r\\n\\r\\n    constructor ( address _KEEPER, address _principle, address _staking, address _treasury, address _bondCalculator, address _feed) {\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = _KEEPER;\\r\\n        require( _principle != address(0) );\\r\\n        principle = _principle;\\r\\n        require( _treasury != address(0) );\\r\\n        treasury = _treasury;\\r\\n        require( _staking != address(0) );\\r\\n        staking = _staking;\\r\\n        require( _bondCalculator != address(0) );\\r\\n        bondCalculator = _bondCalculator;\\r\\n        require( _feed != address(0) );\\r\\n        priceFeed = AggregatorV3Interface( _feed );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice initializes bond parameters\\r\\n     *  @param _controlVariable uint\\r\\n     *  @param _vestingTerm uint\\r\\n     *  @param _minimumPrice uint\\r\\n     *  @param _maxPayout uint\\r\\n     *  @param _maxDebt uint\\r\\n     *  @param _initialDebt uint\\r\\n     */\\r\\n    function initializeBondTerms(uint _controlVariable, uint32 _vestingTerm, uint _minimumPrice, uint _maxPayout,\\r\\n                                 uint _maxDebt, uint _initialDebt) external onlyOwner() {\\r\\n        require( terms.controlVariable == 0 && terms.vestingTerm == 0, \\\"Bonds must be initialized from 0\\\" );\\r\\n        terms = Terms ({\\r\\n            controlVariable: _controlVariable,\\r\\n            vestingTerm: _vestingTerm,\\r\\n            minimumPrice: _minimumPrice,\\r\\n            maxPayout: _maxPayout,\\r\\n            maxDebt: _maxDebt\\r\\n        });\\r\\n        totalDebt = _initialDebt;\\r\\n        lastDecay = uint32(block.timestamp);\\r\\n    }\\r\\n\\r\\n\\r\\n    \\r\\n    /* ======== POLICY FUNCTIONS ======== */\\r\\n\\r\\n    enum PARAMETER { VESTING, PAYOUT, DEBT, MINPRICE }\\r\\n    /**\\r\\n     *  @notice set parameters for new bonds\\r\\n     *  @param _parameter PARAMETER\\r\\n     *  @param _input uint\\r\\n     */\\r\\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyOwner() {\\r\\n        if ( _parameter == PARAMETER.VESTING ) { // 0\\r\\n            require( _input >= 129600, \\\"Vesting must be longer than 36 hours\\\" );\\r\\n            decayDebt();\\r\\n            require( totalDebt == 0, \\\"Debt should be 0.\\\" );\\r\\n            terms.vestingTerm = uint32(_input);\\r\\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\\r\\n            require( _input <= 1000, \\\"Payout cannot be above 1 percent\\\" );\\r\\n            terms.maxPayout = _input;\\r\\n        } else if ( _parameter == PARAMETER.DEBT ) { // 2\\r\\n            terms.maxDebt = _input;\\r\\n        } else if ( _parameter == PARAMETER.MINPRICE ) { // 3\\r\\n            terms.minimumPrice = _input;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice set control variable adjustment\\r\\n     *  @param _addition bool\\r\\n     *  @param _increment uint\\r\\n     *  @param _target uint\\r\\n     *  @param _buffer uint\\r\\n     */\\r\\n    function setAdjustment ( bool _addition, uint _increment, uint _target, uint32 _buffer ) external onlyOwner() {\\r\\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \\\"Increment too large\\\" );\\r\\n\\r\\n        adjustment = Adjust({\\r\\n            add: _addition,\\r\\n            rate: _increment,\\r\\n            target: _target,\\r\\n            buffer: _buffer,\\r\\n            lastTime: uint32(block.timestamp)\\r\\n        });\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice set contract for auto stake\\r\\n     *  @param _staking address\\r\\n     */\\r\\n    // function setStaking( address _staking ) external onlyOwner() {\\r\\n    //     require( _staking != address(0) );\\r\\n    //     staking = _staking;\\r\\n    // }\\r\\n\\r\\n\\r\\n    /* ======== USER FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice deposit bond\\r\\n     *  @param _amount uint\\r\\n     *  @param _maxPrice uint\\r\\n     *  @param _depositor address\\r\\n     *  @return uint\\r\\n     */\\r\\n    function deposit( uint _amount, uint _maxPrice, address _depositor) external returns ( uint ) {\\r\\n        require( _depositor != address(0), \\\"Invalid address\\\" );\\r\\n        decayDebt();\\r\\n        \\r\\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\\r\\n        uint nativePrice = _bondPrice();\\r\\n\\r\\n        require( _maxPrice >= nativePrice, \\\"Slippage limit: more than max price\\\" ); // slippage protection\\r\\n\\r\\n        uint value = ITreasury( treasury ).valueOfToken( principle, _amount );\\r\\n        uint payout = payoutFor( value ); // payout to bonder is computed\\r\\n\\r\\n        require( payout >= 10000000, \\\"Bond too small\\\" ); // must be > 0.01 KEEPER ( underflow protection )\\r\\n        require( payout <= maxPayout(), \\\"Bond too large\\\"); // size protection because there is no slippage\\r\\n\\r\\n        /**\\r\\n            asset carries risk and is not minted against\\r\\n            asset transfered to treasury and rewards minted as payout\\r\\n         */\\r\\n        IERC20( principle ).safeTransferFrom( msg.sender, treasury, _amount );\\r\\n        ITreasury( treasury ).mintRewards( address(this), payout );\\r\\n        \\r\\n        // total debt is increased\\r\\n        totalDebt = totalDebt.add( value ); \\r\\n        require( totalDebt <= terms.maxDebt, \\\"Max capacity reached\\\" );\\r\\n                \\r\\n        // depositor info is stored\\r\\n        bondInfo[ _depositor ] = Bond({ \\r\\n            payout: bondInfo[ _depositor ].payout.add( payout ),\\r\\n            vesting: terms.vestingTerm,\\r\\n            lastTime: uint32(block.timestamp),\\r\\n            pricePaid: priceInUSD\\r\\n        });\\r\\n\\r\\n        // indexed events are emitted\\r\\n        emit BondCreated( _amount, payout, block.timestamp.add( terms.vestingTerm ), priceInUSD );\\r\\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\\r\\n\\r\\n        adjust(); // control variable is adjusted\\r\\n        return payout; \\r\\n    }\\r\\n\\r\\n    /** \\r\\n     *  @notice redeem bond for user\\r\\n     *  @param _recipient address\\r\\n     *  @param _stake bool\\r\\n     *  @return uint\\r\\n     */ \\r\\n    function redeem( address _recipient, bool _stake, bool _wrap ) external returns ( uint ) {        \\r\\n        Bond memory info = bondInfo[ _recipient ];\\r\\n        uint percentVested = percentVestedFor( _recipient ); // (seconds since last interaction / vesting term remaining)\\r\\n\\r\\n        if ( percentVested >= 10000 ) { // if fully vested\\r\\n            delete bondInfo[ _recipient ]; // delete user info\\r\\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\\r\\n            return stakeOrSend( _recipient, _stake, _wrap, info.payout ); // pay user everything due\\r\\n\\r\\n        } else { // if unfinished\\r\\n            // calculate payout vested\\r\\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\\r\\n\\r\\n            // store updated deposit info\\r\\n            bondInfo[ _recipient ] = Bond({\\r\\n                payout: info.payout.sub( payout ),\\r\\n                vesting: info.vesting.sub32( uint32(block.timestamp).sub32( info.lastTime ) ),\\r\\n                lastTime: uint32(block.timestamp),\\r\\n                pricePaid: info.pricePaid\\r\\n            });\\r\\n\\r\\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\\r\\n            return stakeOrSend( _recipient, _stake, _wrap, payout );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    \\r\\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice allow user to stake payout automatically\\r\\n     *  @param _stake bool\\r\\n     *  @param _amount uint\\r\\n     *  @return uint\\r\\n     */\\r\\n    function stakeOrSend( address _recipient, bool _stake, bool _wrap, uint _amount ) internal returns ( uint ) {\\r\\n        if ( !_stake ) { // if user does not want to stake\\r\\n            IERC20( KEEPER ).transfer( _recipient, _amount ); // send payout\\r\\n        } else { // if user wants to stake\\r\\n            IERC20( KEEPER ).approve( staking, _amount );\\r\\n            IStaking( staking ).stake( _amount, _recipient, _wrap );\\r\\n        }\\r\\n        return _amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice makes incremental adjustment to control variable\\r\\n     */\\r\\n    function adjust() internal {\\r\\n        uint timeCanAdjust = adjustment.lastTime.add( adjustment.buffer );\\r\\n        if( adjustment.rate != 0 && block.timestamp >= timeCanAdjust ) {\\r\\n            uint initial = terms.controlVariable;\\r\\n            if ( adjustment.add ) {\\r\\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\\r\\n                if ( terms.controlVariable >= adjustment.target ) {\\r\\n                    adjustment.rate = 0;\\r\\n                }\\r\\n            } else {\\r\\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\\r\\n                if ( terms.controlVariable <= adjustment.target || terms.controlVariable < adjustment.rate ) {\\r\\n                    adjustment.rate = 0;\\r\\n                }\\r\\n            }\\r\\n            adjustment.lastTime = uint32(block.timestamp);\\r\\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice reduce total debt\\r\\n     */\\r\\n    function decayDebt() internal {\\r\\n        totalDebt = totalDebt.sub( debtDecay() );\\r\\n        lastDecay = uint32(block.timestamp);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    /* ======== VIEW FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice determine maximum bond size\\r\\n     *  @return uint\\r\\n     */\\r\\n    function maxPayout() public view returns ( uint ) {\\r\\n        return IERC20( KEEPER ).totalSupply().mul( terms.maxPayout ).div( 100000 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate interest due for new bond\\r\\n     *  @param _value uint\\r\\n     *  @return uint\\r\\n     */\\r\\n    function payoutFor( uint _value ) public view returns ( uint ) {\\r\\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e14 );\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current bond premium\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function bondPrice() public view returns ( uint price_ ) {        \\r\\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\\r\\n        if ( price_ < terms.minimumPrice ) {\\r\\n            price_ = terms.minimumPrice;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current bond price and remove floor if above\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function _bondPrice() internal returns ( uint price_ ) {\\r\\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\\r\\n        if ( price_ < terms.minimumPrice ) {\\r\\n            price_ = terms.minimumPrice;        \\r\\n        } else if ( terms.minimumPrice != 0 ) {\\r\\n            terms.minimumPrice = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice get asset price from chainlink\\r\\n     */\\r\\n    function assetPrice() public view returns (int) {\\r\\n        ( , int price, , , ) = priceFeed.latestRoundData();\\r\\n        return price;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice converts bond price to DAI value\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function bondPriceInUSD() public view returns ( uint price_ ) {\\r\\n        price_ = bondPrice()\\r\\n                    .mul( IBondCalculator( bondCalculator ).markdown( principle ) )\\r\\n                    .mul( uint( assetPrice() ) )\\r\\n                    .div( 1e12 );\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current ratio of debt to KEEPER supply\\r\\n     *  @return debtRatio_ uint\\r\\n     */\\r\\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \\r\\n        uint supply = IERC20( KEEPER ).totalSupply();\\r\\n        debtRatio_ = FixedPoint.fraction( \\r\\n            currentDebt().mul( 1e9 ), \\r\\n            supply\\r\\n        ).decode112with18().div( 1e18 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice debt ratio in same terms as reserve bonds\\r\\n     *  @return uint\\r\\n     */\\r\\n    function standardizedDebtRatio() external view returns ( uint ) {\\r\\n        return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate debt factoring in decay\\r\\n     *  @return uint\\r\\n     */\\r\\n    function currentDebt() public view returns ( uint ) {\\r\\n        return totalDebt.sub( debtDecay() );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice amount to decay total debt by\\r\\n     *  @return decay_ uint\\r\\n     */\\r\\n    function debtDecay() public view returns ( uint decay_ ) {\\r\\n        uint32 timeSinceLast = uint32(block.timestamp).sub32( lastDecay );\\r\\n        decay_ = totalDebt.mul( timeSinceLast ).div( terms.vestingTerm );\\r\\n        if ( decay_ > totalDebt ) {\\r\\n            decay_ = totalDebt;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate how far into vesting a depositor is\\r\\n     *  @param _depositor address\\r\\n     *  @return percentVested_ uint\\r\\n     */\\r\\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\\r\\n        Bond memory bond = bondInfo[ _depositor ];\\r\\n        uint timeSinceLast = uint32(block.timestamp).sub( bond.lastTime );\\r\\n        uint vesting = bond.vesting;\\r\\n\\r\\n        if ( vesting > 0 ) {\\r\\n            percentVested_ = timeSinceLast.mul( 10000 ).div( vesting );\\r\\n        } else {\\r\\n            percentVested_ = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate amount of KEEPER available for claim by depositor\\r\\n     *  @param _depositor address\\r\\n     *  @return pendingPayout_ uint\\r\\n     */\\r\\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\\r\\n        uint percentVested = percentVestedFor( _depositor );\\r\\n        uint payout = bondInfo[ _depositor ].payout;\\r\\n\\r\\n        if ( percentVested >= 10000 ) {\\r\\n            pendingPayout_ = payout;\\r\\n        } else {\\r\\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/VBondDepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"./interfaces/AggregateV3Interface.sol\\\";\\r\\nimport \\\"./interfaces/ITreasury.sol\\\";\\r\\nimport \\\"./interfaces/IStaking.sol\\\";\\r\\nimport \\\"./libraries/FixedPoint.sol\\\";\\r\\nimport \\\"./libraries/SafeMathExtended.sol\\\";\\r\\n\\r\\n\\r\\ncontract VBondDepository is Ownable {\\r\\n    using FixedPoint for *;\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeMathExtended for uint;\\r\\n    using SafeMathExtended for uint32;\\r\\n\\r\\n    /* ======== EVENTS ======== */\\r\\n\\r\\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\\r\\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\\r\\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\\r\\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\\r\\n\\r\\n    /* ======== STATE VARIABLES ======== */\\r\\n\\r\\n    address public immutable KEEPER; // token given as payment for bond\\r\\n    address public immutable principle; // token used to create bond\\r\\n    address public immutable treasury; // mints KEEPER when receives principle\\r\\n    address public immutable DAO; // receives profit share from bond\\r\\n\\r\\n    AggregatorV3Interface internal priceFeed;\\r\\n\\r\\n    address public staking; // to auto-stake payout\\r\\n\\r\\n    Terms public terms; // stores terms for new bonds\\r\\n    Adjust public adjustment; // stores adjustment to BCV data\\r\\n\\r\\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\\r\\n\\r\\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\\r\\n    uint32 public lastDecay; // reference block for debt decay\\r\\n\\r\\n\\r\\n    /* ======== STRUCTS ======== */\\r\\n\\r\\n    // Info for creating new bonds\\r\\n    struct Terms {\\r\\n        uint32 vestingTerm; // in seconds\\r\\n        uint controlVariable; // scaling variable for price\\r\\n        uint minimumPrice; // vs principle value. 4 decimals (1500 = 0.15)\\r\\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\\r\\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\\r\\n    }\\r\\n\\r\\n    // Info for bond holder\\r\\n    struct Bond {\\r\\n        uint32 vesting; // seconds left to vest\\r\\n        uint32 lastTime; // Last interaction\\r\\n        uint payout; // KEEPER remaining to be paid\\r\\n        uint pricePaid; // In DAI, for front end viewing\\r\\n    }\\r\\n\\r\\n    // Info for incremental adjustments to control variable \\r\\n    struct Adjust {\\r\\n        bool add; // addition or subtraction\\r\\n        uint rate; // increment\\r\\n        uint target; // BCV when adjustment finished\\r\\n        uint32 buffer; // minimum length (in blocks) between adjustments\\r\\n        uint32 lastTime; // block when last adjustment made\\r\\n    }\\r\\n\\r\\n    /* ======== INITIALIZATION ======== */\\r\\n\\r\\n    constructor ( address _KEEPER, address _principle, address _staking, address _treasury, address _DAO, address _feed) {\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = _KEEPER;\\r\\n        require( _principle != address(0) );\\r\\n        principle = _principle;\\r\\n        require( _treasury != address(0) );\\r\\n        treasury = _treasury;\\r\\n        require( _DAO != address(0) );\\r\\n        DAO = _DAO;\\r\\n        require( _staking != address(0) );\\r\\n        staking = _staking;\\r\\n        require( _feed != address(0) );\\r\\n        priceFeed = AggregatorV3Interface( _feed );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice initializes bond parameters\\r\\n     *  @param _controlVariable uint\\r\\n     *  @param _vestingTerm uint\\r\\n     *  @param _minimumPrice uint\\r\\n     *  @param _maxPayout uint\\r\\n     *  @param _maxDebt uint\\r\\n     *  @param _initialDebt uint\\r\\n     */\\r\\n    function initializeBondTerms(uint _controlVariable, uint32 _vestingTerm, uint _minimumPrice, uint _maxPayout,\\r\\n                                 uint _maxDebt, uint _initialDebt) external onlyOwner() {\\r\\n        require( terms.controlVariable == 0 && terms.vestingTerm == 0, \\\"Bonds must be initialized from 0\\\" );\\r\\n        terms = Terms ({\\r\\n            controlVariable: _controlVariable,\\r\\n            vestingTerm: _vestingTerm,\\r\\n            minimumPrice: _minimumPrice,\\r\\n            maxPayout: _maxPayout,\\r\\n            maxDebt: _maxDebt\\r\\n        });\\r\\n        totalDebt = _initialDebt;\\r\\n        lastDecay = uint32(block.timestamp);\\r\\n    }\\r\\n\\r\\n\\r\\n    \\r\\n    /* ======== POLICY FUNCTIONS ======== */\\r\\n\\r\\n    enum PARAMETER { VESTING, PAYOUT, DEBT, MINPRICE }\\r\\n    /**\\r\\n     *  @notice set parameters for new bonds\\r\\n     *  @param _parameter PARAMETER\\r\\n     *  @param _input uint\\r\\n     */\\r\\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyOwner() {\\r\\n        if ( _parameter == PARAMETER.VESTING ) { // 0\\r\\n            require( _input >= 129600, \\\"Vesting must be longer than 36 hours\\\" );\\r\\n            require( currentDebt() == 0, \\\"Debt should be 0.\\\" );\\r\\n            terms.vestingTerm = uint32(_input);\\r\\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\\r\\n            require( _input <= 1000, \\\"Payout cannot be above 1 percent\\\" );\\r\\n            terms.maxPayout = _input;\\r\\n        } else if ( _parameter == PARAMETER.DEBT ) { // 2\\r\\n            terms.maxDebt = _input;\\r\\n        } else if ( _parameter == PARAMETER.MINPRICE ) { // 3\\r\\n            terms.minimumPrice = _input;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice set control variable adjustment\\r\\n     *  @param _addition bool\\r\\n     *  @param _increment uint\\r\\n     *  @param _target uint\\r\\n     *  @param _buffer uint\\r\\n     */\\r\\n    function setAdjustment ( bool _addition, uint _increment, uint _target, uint32 _buffer ) external onlyOwner() {\\r\\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \\\"Increment too large\\\" );\\r\\n\\r\\n        adjustment = Adjust({\\r\\n            add: _addition,\\r\\n            rate: _increment,\\r\\n            target: _target,\\r\\n            buffer: _buffer,\\r\\n            lastTime: uint32(block.timestamp)\\r\\n        });\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice set contract for auto stake\\r\\n     *  @param _staking address\\r\\n     */\\r\\n    // function setStaking( address _staking ) external onlyOwner() {\\r\\n    //     require( _staking != address(0) );\\r\\n    //     staking = _staking;\\r\\n    // }\\r\\n\\r\\n\\r\\n    /* ======== USER FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice deposit bond\\r\\n     *  @param _amount uint\\r\\n     *  @param _maxPrice uint\\r\\n     *  @param _depositor address\\r\\n     *  @return uint\\r\\n     */\\r\\n    function deposit( uint _amount, uint _maxPrice, address _depositor) external returns ( uint ) {\\r\\n        require( _depositor != address(0), \\\"Invalid address\\\" );\\r\\n        decayDebt();\\r\\n        \\r\\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\\r\\n        uint nativePrice = _bondPrice();\\r\\n\\r\\n        require( _maxPrice >= nativePrice, \\\"Slippage limit: more than max price\\\" ); // slippage protection\\r\\n\\r\\n        uint value = ITreasury( treasury ).valueOfToken( principle, _amount );\\r\\n        uint payout = payoutFor( value ); // payout to bonder is computed\\r\\n\\r\\n        require( payout >= 10000000, \\\"Bond too small\\\" ); // must be > 0.01 KEEPER ( underflow protection )\\r\\n        require( payout <= maxPayout(), \\\"Bond too large\\\"); // size protection because there is no slippage\\r\\n\\r\\n        /**\\r\\n            asset carries risk and is not minted against\\r\\n            asset transfered to treasury and rewards minted as payout\\r\\n         */\\r\\n        IERC20( principle ).safeTransferFrom( msg.sender, treasury, _amount );\\r\\n        ITreasury( treasury ).mintRewards( address(this), payout );\\r\\n        \\r\\n        // total debt is increased\\r\\n        totalDebt = totalDebt.add( value ); \\r\\n        require( totalDebt <= terms.maxDebt, \\\"Max capacity reached\\\" );\\r\\n                \\r\\n        // depositor info is stored\\r\\n        bondInfo[ _depositor ] = Bond({ \\r\\n            payout: bondInfo[ _depositor ].payout.add( payout ),\\r\\n            vesting: terms.vestingTerm,\\r\\n            lastTime: uint32(block.timestamp),\\r\\n            pricePaid: priceInUSD\\r\\n        });\\r\\n\\r\\n        // indexed events are emitted\\r\\n        emit BondCreated( _amount, payout, block.timestamp.add( terms.vestingTerm ), priceInUSD );\\r\\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\\r\\n\\r\\n        adjust(); // control variable is adjusted\\r\\n        return payout; \\r\\n    }\\r\\n\\r\\n    /** \\r\\n     *  @notice redeem bond for user\\r\\n     *  @param _recipient address\\r\\n     *  @param _stake bool\\r\\n     *  @return uint\\r\\n     */ \\r\\n    function redeem( address _recipient, bool _stake, bool _wrap ) external returns ( uint ) {        \\r\\n        Bond memory info = bondInfo[ _recipient ];\\r\\n        uint percentVested = percentVestedFor( _recipient ); // (seconds since last interaction / vesting term remaining)\\r\\n\\r\\n        if ( percentVested >= 10000 ) { // if fully vested\\r\\n            delete bondInfo[ _recipient ]; // delete user info\\r\\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\\r\\n            return stakeOrSend( _recipient, _stake, _wrap, info.payout ); // pay user everything due\\r\\n\\r\\n        } else { // if unfinished\\r\\n            // calculate payout vested\\r\\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\\r\\n\\r\\n            // store updated deposit info\\r\\n            bondInfo[ _recipient ] = Bond({\\r\\n                payout: info.payout.sub( payout ),\\r\\n                vesting: info.vesting.sub32( uint32(block.timestamp).sub32( info.lastTime ) ),\\r\\n                lastTime: uint32(block.timestamp),\\r\\n                pricePaid: info.pricePaid\\r\\n            });\\r\\n\\r\\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\\r\\n            return stakeOrSend( _recipient, _stake, _wrap, payout );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    \\r\\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice allow user to stake payout automatically\\r\\n     *  @param _stake bool\\r\\n     *  @param _amount uint\\r\\n     *  @return uint\\r\\n     */\\r\\n    function stakeOrSend( address _recipient, bool _stake, bool _wrap, uint _amount ) internal returns ( uint ) {\\r\\n        if ( !_stake ) { // if user does not want to stake\\r\\n            IERC20( KEEPER ).transfer( _recipient, _amount ); // send payout\\r\\n        } else { // if user wants to stake\\r\\n            IERC20( KEEPER ).approve( staking, _amount );\\r\\n            IStaking( staking ).stake( _amount, _recipient, _wrap );\\r\\n        }\\r\\n        return _amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice makes incremental adjustment to control variable\\r\\n     */\\r\\n    function adjust() internal {\\r\\n        uint timeCanAdjust = adjustment.lastTime.add( adjustment.buffer );\\r\\n        if( adjustment.rate != 0 && block.timestamp >= timeCanAdjust ) {\\r\\n            uint initial = terms.controlVariable;\\r\\n            if ( adjustment.add ) {\\r\\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\\r\\n                if ( terms.controlVariable >= adjustment.target ) {\\r\\n                    adjustment.rate = 0;\\r\\n                }\\r\\n            } else {\\r\\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\\r\\n                if ( terms.controlVariable <= adjustment.target || terms.controlVariable < adjustment.rate ) {\\r\\n                    adjustment.rate = 0;\\r\\n                }\\r\\n            }\\r\\n            adjustment.lastTime = uint32(block.timestamp);\\r\\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice reduce total debt\\r\\n     */\\r\\n    function decayDebt() internal {\\r\\n        totalDebt = totalDebt.sub( debtDecay() );\\r\\n        lastDecay = uint32(block.timestamp);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    /* ======== VIEW FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice determine maximum bond size\\r\\n     *  @return uint\\r\\n     */\\r\\n    function maxPayout() public view returns ( uint ) {\\r\\n        return IERC20( KEEPER ).totalSupply().mul( terms.maxPayout ).div( 100000 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate interest due for new bond\\r\\n     *  @param _value uint\\r\\n     *  @return uint\\r\\n     */\\r\\n    function payoutFor( uint _value ) public view returns ( uint ) {\\r\\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e14 );\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current bond premium\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function bondPrice() public view returns ( uint price_ ) {        \\r\\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\\r\\n        if ( price_ < terms.minimumPrice ) {\\r\\n            price_ = terms.minimumPrice;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current bond price and remove floor if above\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function _bondPrice() internal returns ( uint price_ ) {\\r\\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\\r\\n        if ( price_ < terms.minimumPrice ) {\\r\\n            price_ = terms.minimumPrice;        \\r\\n        } else if ( terms.minimumPrice != 0 ) {\\r\\n            terms.minimumPrice = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice get asset price from chainlink\\r\\n     */\\r\\n    function assetPrice() public view returns (int) {\\r\\n        ( , int price, , , ) = priceFeed.latestRoundData();\\r\\n        return price;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice converts bond price to DAI value\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function bondPriceInUSD() public view returns ( uint price_ ) {\\r\\n        price_ = bondPrice().mul( uint( assetPrice() ) ).mul( 1e6 );\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current ratio of debt to KEEPER supply\\r\\n     *  @return debtRatio_ uint\\r\\n     */\\r\\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \\r\\n        uint supply = IERC20( KEEPER ).totalSupply();\\r\\n        debtRatio_ = FixedPoint.fraction( \\r\\n            currentDebt().mul( 1e9 ), \\r\\n            supply\\r\\n        ).decode112with18().div( 1e18 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice debt ratio in same terms as reserve bonds\\r\\n     *  @return uint\\r\\n     */\\r\\n    function standardizedDebtRatio() external view returns ( uint ) {\\r\\n        return debtRatio().mul( uint( assetPrice() ) ).div( 1e8 ); // ETH feed is 8 decimals\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate debt factoring in decay\\r\\n     *  @return uint\\r\\n     */\\r\\n    function currentDebt() public view returns ( uint ) {\\r\\n        return totalDebt.sub( debtDecay() );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice amount to decay total debt by\\r\\n     *  @return decay_ uint\\r\\n     */\\r\\n    function debtDecay() public view returns ( uint decay_ ) {\\r\\n        uint32 timeSinceLast = uint32(block.timestamp).sub32( lastDecay );\\r\\n        decay_ = totalDebt.mul( timeSinceLast ).div( terms.vestingTerm );\\r\\n        if ( decay_ > totalDebt ) {\\r\\n            decay_ = totalDebt;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate how far into vesting a depositor is\\r\\n     *  @param _depositor address\\r\\n     *  @return percentVested_ uint\\r\\n     */\\r\\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\\r\\n        Bond memory bond = bondInfo[ _depositor ];\\r\\n        uint timeSinceLast = uint32(block.timestamp).sub( bond.lastTime );\\r\\n        uint vesting = bond.vesting;\\r\\n\\r\\n        if ( vesting > 0 ) {\\r\\n            percentVested_ = timeSinceLast.mul( 10000 ).div( vesting );\\r\\n        } else {\\r\\n            percentVested_ = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate amount of KEEPER available for claim by depositor\\r\\n     *  @param _depositor address\\r\\n     *  @return pendingPayout_ uint\\r\\n     */\\r\\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\\r\\n        uint percentVested = percentVestedFor( _depositor );\\r\\n        uint payout = bondInfo[ _depositor ].payout;\\r\\n\\r\\n        if ( percentVested >= 10000 ) {\\r\\n            pendingPayout_ = payout;\\r\\n        } else {\\r\\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    /* ======= AUXILLIARY ======= */\\r\\n\\r\\n    /**\\r\\n     *  @notice allow anyone to send lost tokens (excluding principle or KEEPER) to the DAO\\r\\n     *  @return bool\\r\\n     */\\r\\n    function recoverLostToken( address _token ) external returns ( bool ) {\\r\\n        require( _token != KEEPER );\\r\\n        require( _token != principle );\\r\\n        IERC20( _token ).safeTransfer( DAO, IERC20( _token ).balanceOf( address(this) ) );\\r\\n        return true;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/StakingDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"./interfaces/ITreasury.sol\\\";\\r\\nimport \\\"./libraries/SafeMathExtended.sol\\\";\\r\\n\\r\\ncontract StakingDistributor is Ownable {\\r\\n    \\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeMathExtended for uint256;\\r\\n    using SafeMathExtended for uint32;\\r\\n    \\r\\n    IERC20 immutable KEEPER;\\r\\n    ITreasury immutable treasury;\\r\\n    \\r\\n    uint32 public immutable epochLength;\\r\\n    uint32 public nextEpochTime;\\r\\n    \\r\\n    mapping( uint => Adjust ) public adjustments;\\r\\n\\r\\n    /* ====== STRUCTS ====== */\\r\\n        \\r\\n    struct Info {\\r\\n        uint rate; // in ten-thousandths ( 5000 = 0.5% )\\r\\n        address recipient;\\r\\n    }\\r\\n    Info[] public info;\\r\\n    \\r\\n    struct Adjust {\\r\\n        bool add;\\r\\n        uint rate;\\r\\n        uint target;\\r\\n    }\\r\\n\\r\\n    constructor( address _treasury, address _KEEPER, uint32 _epochLength, uint32 _nextEpochTime ) {        \\r\\n        require( _treasury != address(0) );\\r\\n        treasury = ITreasury( _treasury );\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = IERC20( _KEEPER );\\r\\n        epochLength = _epochLength;\\r\\n        nextEpochTime = _nextEpochTime;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice send epoch reward to staking contract\\r\\n     */\\r\\n    function distribute() external returns (bool) {\\r\\n        if ( nextEpochTime <= uint32(block.timestamp) ) {\\r\\n            nextEpochTime = nextEpochTime.add32( epochLength ); // set next epoch block\\r\\n            // distribute rewards to each recipient\\r\\n            for ( uint i = 0; i < info.length; i++ ) {\\r\\n                if ( info[ i ].rate > 0 ) {\\r\\n                    treasury.mintRewards( // mint and send from treasury\\r\\n                        info[ i ].recipient, \\r\\n                        nextRewardAt( info[ i ].rate ) \\r\\n                    );\\r\\n                    adjust( i ); // check for adjustment\\r\\n                }\\r\\n            }\\r\\n            return true;\\r\\n        }\\r\\n        else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice increment reward rate for collector\\r\\n     */\\r\\n    function adjust( uint _index ) internal {\\r\\n        Adjust memory adjustment = adjustments[ _index ];\\r\\n        if ( adjustment.rate != 0 ) {\\r\\n            if ( adjustment.add ) { // if rate should increase\\r\\n                info[ _index ].rate = info[ _index ].rate.add( adjustment.rate ); // raise rate\\r\\n                if ( info[ _index ].rate >= adjustment.target ) { // if target met\\r\\n                    adjustments[ _index ].rate = 0; // turn off adjustment\\r\\n                }\\r\\n            } else { // if rate should decrease\\r\\n                info[ _index ].rate = info[ _index ].rate.sub( adjustment.rate ); // lower rate\\r\\n                if ( info[ _index ].rate <= adjustment.target || info[ _index ].rate < adjustment.rate) { // if target met\\r\\n                    adjustments[ _index ].rate = 0; // turn off adjustment\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /* ====== VIEW FUNCTIONS ====== */\\r\\n\\r\\n    /**\\r\\n        @notice view function for next reward at given rate\\r\\n        @param _rate uint\\r\\n        @return uint\\r\\n     */\\r\\n    function nextRewardAt( uint _rate ) public view returns ( uint ) {\\r\\n        return KEEPER.totalSupply().mul( _rate ).div( 1000000 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice view function for next reward for specified address\\r\\n        @param _recipient address\\r\\n        @return uint\\r\\n     */\\r\\n    function nextRewardFor( address _recipient ) public view returns ( uint ) {\\r\\n        uint reward;\\r\\n        for ( uint i = 0; i < info.length; i++ ) {\\r\\n            if ( info[ i ].recipient == _recipient ) {\\r\\n                reward = nextRewardAt( info[ i ].rate );\\r\\n            }\\r\\n        }\\r\\n        return reward;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    \\r\\n    /* ====== POLICY FUNCTIONS ====== */\\r\\n\\r\\n    /**\\r\\n        @notice adds recipient for distributions\\r\\n        @param _recipient address\\r\\n        @param _rewardRate uint\\r\\n     */\\r\\n    function addRecipient( address _recipient, uint _rewardRate ) external onlyOwner() {\\r\\n        require( _recipient != address(0) );\\r\\n        info.push( Info({\\r\\n            recipient: _recipient,\\r\\n            rate: _rewardRate\\r\\n        }));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice removes recipient for distributions\\r\\n        @param _index uint\\r\\n        @param _recipient address\\r\\n     */\\r\\n    function removeRecipient( uint _index, address _recipient ) external onlyOwner() {\\r\\n        require( _recipient == info[ _index ].recipient );\\r\\n        info[ _index ] = info[info.length-1];\\r\\n        info.pop();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice set adjustment info for a collector's reward rate\\r\\n        @param _index uint\\r\\n        @param _add bool\\r\\n        @param _rate uint\\r\\n        @param _target uint\\r\\n     */\\r\\n    function setAdjustment( uint _index, bool _add, uint _rate, uint _target ) external onlyOwner() {\\r\\n        require(_add || info[ _index ].rate >= _rate, \\\"Negative adjustment rate cannot be more than current rate.\\\");\\r\\n        adjustments[ _index ] = Adjust({\\r\\n            add: _add,\\r\\n            rate: _rate,\\r\\n            target: _target\\r\\n        });\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/Treasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"./interfaces/IBondCalculator.sol\\\";\\r\\nimport \\\"./interfaces/IERC20Extended.sol\\\";\\r\\nimport \\\"./interfaces/IKeplerERC20.sol\\\";\\r\\n\\r\\ncontract oldTreasury is Ownable {\\r\\n    \\r\\n    using SafeERC20 for IERC20Extended;\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    event Deposit( address indexed token, uint amount, uint value );\\r\\n    event Withdrawal( address indexed token, uint amount, uint value );\\r\\n    event CreateDebt( address indexed debtor, address indexed token, uint amount, uint value );\\r\\n    event RepayDebt( address indexed debtor, address indexed token, uint amount, uint value );\\r\\n    event ReservesManaged( address indexed token, uint amount );\\r\\n    event ReservesUpdated( uint indexed totalReserves );\\r\\n    event ReservesAudited( uint indexed totalReserves );\\r\\n    event RewardsMinted( address indexed caller, address indexed recipient, uint amount );\\r\\n    event ChangeQueued( MANAGING indexed managing, address queued );\\r\\n    event ChangeActivated( MANAGING indexed managing, address activated, bool result );\\r\\n\\r\\n    enum MANAGING { RESERVEDEPOSITOR, RESERVESPENDER, RESERVETOKEN, RESERVEMANAGER, LIQUIDITYDEPOSITOR, LIQUIDITYTOKEN, LIQUIDITYMANAGER, DEBTOR, REWARDMANAGER, SKEEPER }\\r\\n\\r\\n    IKeplerERC20 immutable KEEPER;\\r\\n    uint public immutable secondsNeededForQueue;\\r\\n    uint public constant keeperDecimals = 9;\\r\\n\\r\\n    address[] public reserveTokens; // Push only, beware false-positives.\\r\\n    mapping( address => bool ) public isReserveToken;\\r\\n    mapping( address => uint ) public reserveTokenQueue; // Delays changes to mapping.\\r\\n\\r\\n    address[] public reserveDepositors; // Push only, beware false-positives. Only for viewing.\\r\\n    mapping( address => bool ) public isReserveDepositor;\\r\\n    mapping( address => uint ) public reserveDepositorQueue; // Delays changes to mapping.\\r\\n\\r\\n    address[] public reserveSpenders; // Push only, beware false-positives. Only for viewing.\\r\\n    mapping( address => bool ) public isReserveSpender;\\r\\n    mapping( address => uint ) public reserveSpenderQueue; // Delays changes to mapping.\\r\\n\\r\\n    address[] public liquidityTokens; // Push only, beware false-positives.\\r\\n    mapping( address => bool ) public isLiquidityToken;\\r\\n    mapping( address => uint ) public LiquidityTokenQueue; // Delays changes to mapping.\\r\\n\\r\\n    address[] public liquidityDepositors; // Push only, beware false-positives. Only for viewing.\\r\\n    mapping( address => bool ) public isLiquidityDepositor;\\r\\n    mapping( address => uint ) public LiquidityDepositorQueue; // Delays changes to mapping.\\r\\n\\r\\n    mapping( address => address ) public bondCalculator; // bond calculator for liquidity token\\r\\n\\r\\n    address[] public reserveManagers; // Push only, beware false-positives. Only for viewing.\\r\\n    mapping( address => bool ) public isReserveManager;\\r\\n    mapping( address => uint ) public ReserveManagerQueue; // Delays changes to mapping.\\r\\n\\r\\n    address[] public liquidityManagers; // Push only, beware false-positives. Only for viewing.\\r\\n    mapping( address => bool ) public isLiquidityManager;\\r\\n    mapping( address => uint ) public LiquidityManagerQueue; // Delays changes to mapping.\\r\\n\\r\\n    address[] public debtors; // Push only, beware false-positives. Only for viewing.\\r\\n    mapping( address => bool ) public isDebtor;\\r\\n    mapping( address => uint ) public debtorQueue; // Delays changes to mapping.\\r\\n    mapping( address => uint ) public debtorBalance;\\r\\n\\r\\n    address[] public rewardManagers; // Push only, beware false-positives. Only for viewing.\\r\\n    mapping( address => bool ) public isRewardManager;\\r\\n    mapping( address => uint ) public rewardManagerQueue; // Delays changes to mapping.\\r\\n\\r\\n    address public sKEEPER;\\r\\n    uint public sKEEPERQueue; // Delays change to sKEEPER address\\r\\n    \\r\\n    uint public totalReserves; // Risk-free value of all assets\\r\\n    uint public totalDebt;\\r\\n\\r\\n    constructor (address _KEEPER, address _USDC, address _DAI, uint _secondsNeededForQueue) {\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = IKeplerERC20(_KEEPER);\\r\\n\\r\\n        isReserveToken[ _USDC] = true;\\r\\n        reserveTokens.push( _USDC );\\r\\n        isReserveToken[ _DAI ] = true;\\r\\n        reserveTokens.push( _DAI );\\r\\n        // isLiquidityToken[ _KEEPERDAI ] = true;\\r\\n        // liquidityTokens.push( _KEEPERDAI );\\r\\n\\r\\n        secondsNeededForQueue = _secondsNeededForQueue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice allow approved address to deposit an asset for KEEPER\\r\\n        @param _amount uint\\r\\n        @param _token address\\r\\n        @param _profit uint\\r\\n        @return send_ uint\\r\\n     */\\r\\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( uint send_ ) {\\r\\n        require( isReserveToken[ _token ] || isLiquidityToken[ _token ], \\\"Not accepted\\\" );\\r\\n        IERC20Extended( _token ).safeTransferFrom( msg.sender, address(this), _amount );\\r\\n\\r\\n        if ( isReserveToken[ _token ] ) {\\r\\n            require( isReserveDepositor[ msg.sender ], \\\"Not approved\\\" );\\r\\n        } else {\\r\\n            require( isLiquidityDepositor[ msg.sender ], \\\"Not approved\\\" );\\r\\n        }\\r\\n\\r\\n        uint value = valueOfToken(_token, _amount);\\r\\n        // mint KEEPER needed and store amount of rewards for distribution\\r\\n        send_ = value.sub( _profit );\\r\\n        KEEPER.mint( msg.sender, send_ );\\r\\n\\r\\n        totalReserves = totalReserves.add( value );\\r\\n        emit ReservesUpdated( totalReserves );\\r\\n        emit Deposit( _token, _amount, value );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice allow approved address to burn KEEPER for reserves\\r\\n        @param _amount uint\\r\\n        @param _token address\\r\\n     */\\r\\n    function withdraw( uint _amount, address _token ) external {\\r\\n        require( isReserveToken[ _token ], \\\"Not accepted\\\" ); // Only reserves can be used for redemptions\\r\\n        require( isReserveSpender[ msg.sender ] == true, \\\"Not approved\\\" );\\r\\n\\r\\n        uint value = valueOfToken( _token, _amount );\\r\\n        KEEPER.burnFrom( msg.sender, value );\\r\\n\\r\\n        totalReserves = totalReserves.sub( value );\\r\\n        emit ReservesUpdated( totalReserves );\\r\\n\\r\\n        IERC20Extended( _token ).safeTransfer( msg.sender, _amount );\\r\\n\\r\\n        emit Withdrawal( _token, _amount, value );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice allow approved address to borrow reserves\\r\\n        @param _amount uint\\r\\n        @param _token address\\r\\n     */\\r\\n    function incurDebt( uint _amount, address _token ) external {\\r\\n        require( isDebtor[ msg.sender ], \\\"Not approved\\\" );\\r\\n        require( isReserveToken[ _token ], \\\"Not accepted\\\" );\\r\\n\\r\\n        uint value = valueOfToken( _token, _amount );\\r\\n\\r\\n        uint maximumDebt = IERC20Extended( sKEEPER ).balanceOf( msg.sender ); // Can only borrow against sKEEPER held\\r\\n        uint availableDebt = maximumDebt.sub( debtorBalance[ msg.sender ] );\\r\\n        require( value <= availableDebt, \\\"Exceeds debt limit\\\" );\\r\\n\\r\\n        debtorBalance[ msg.sender ] = debtorBalance[ msg.sender ].add( value );\\r\\n        totalDebt = totalDebt.add( value );\\r\\n\\r\\n        totalReserves = totalReserves.sub( value );\\r\\n        emit ReservesUpdated( totalReserves );\\r\\n        IERC20Extended( _token ).transfer( msg.sender, _amount );\\r\\n        emit CreateDebt( msg.sender, _token, _amount, value );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice allow approved address to repay borrowed reserves with reserves\\r\\n        @param _amount uint\\r\\n        @param _token address\\r\\n     */\\r\\n    function repayDebtWithReserve( uint _amount, address _token ) external {\\r\\n        require( isDebtor[ msg.sender ], \\\"Not approved\\\" );\\r\\n        require( isReserveToken[ _token ], \\\"Not accepted\\\" );\\r\\n\\r\\n        IERC20Extended( _token ).safeTransferFrom( msg.sender, address(this), _amount );\\r\\n\\r\\n        uint value = valueOfToken( _token, _amount );\\r\\n        debtorBalance[ msg.sender ] = debtorBalance[ msg.sender ].sub( value );\\r\\n        totalDebt = totalDebt.sub( value );\\r\\n\\r\\n        totalReserves = totalReserves.add( value );\\r\\n        emit ReservesUpdated( totalReserves );\\r\\n\\r\\n        emit RepayDebt( msg.sender, _token, _amount, value );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice allow approved address to repay borrowed reserves with KEEPER\\r\\n        @param _amount uint\\r\\n     */\\r\\n    function repayDebtWithKEEPER( uint _amount ) external {\\r\\n        require( isDebtor[ msg.sender ], \\\"Not approved\\\" );\\r\\n        KEEPER.burnFrom( msg.sender, _amount );\\r\\n        debtorBalance[ msg.sender ] = debtorBalance[ msg.sender ].sub( _amount );\\r\\n        totalDebt = totalDebt.sub( _amount );\\r\\n        emit RepayDebt( msg.sender, address(KEEPER), _amount, _amount );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice allow approved address to withdraw assets\\r\\n        @param _token address\\r\\n        @param _amount uint\\r\\n     */\\r\\n    function manage( address _token, uint _amount ) external {\\r\\n        if( isLiquidityToken[ _token ] ) {\\r\\n            require( isLiquidityManager[ msg.sender ], \\\"Not approved\\\" );\\r\\n        } else {\\r\\n            require( isReserveManager[ msg.sender ], \\\"Not approved\\\" );\\r\\n        }\\r\\n\\r\\n        uint value = valueOfToken(_token, _amount);\\r\\n        require( value <= excessReserves(), \\\"Insufficient reserves\\\" );\\r\\n\\r\\n        totalReserves = totalReserves.sub( value );\\r\\n        emit ReservesUpdated( totalReserves );\\r\\n        IERC20Extended( _token ).safeTransfer( msg.sender, _amount );\\r\\n        emit ReservesManaged( _token, _amount );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice send epoch reward to staking contract\\r\\n     */\\r\\n    function mintRewards( address _recipient, uint _amount ) external {\\r\\n        require( isRewardManager[ msg.sender ], \\\"Not approved\\\" );\\r\\n        require( _amount <= excessReserves(), \\\"Insufficient reserves\\\" );\\r\\n\\r\\n        KEEPER.mint( _recipient, _amount );\\r\\n\\r\\n        emit RewardsMinted( msg.sender, _recipient, _amount );\\r\\n    } \\r\\n\\r\\n    /**\\r\\n        @notice returns excess reserves not backing tokens\\r\\n        @return uint\\r\\n     */\\r\\n    function excessReserves() public view returns ( uint ) {\\r\\n        return totalReserves.sub( KEEPER.totalSupply().sub( totalDebt ) );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice takes inventory of all tracked assets\\r\\n        @notice always consolidate to recognized reserves before audit\\r\\n     */\\r\\n    function auditReserves() external onlyOwner() {\\r\\n        uint reserves;\\r\\n        for( uint i = 0; i < reserveTokens.length; i++ ) {\\r\\n            reserves = reserves.add ( \\r\\n                valueOfToken( reserveTokens[ i ], IERC20Extended( reserveTokens[ i ] ).balanceOf( address(this) ) )\\r\\n            );\\r\\n        }\\r\\n        for( uint i = 0; i < liquidityTokens.length; i++ ) {\\r\\n            reserves = reserves.add (\\r\\n                valueOfToken( liquidityTokens[ i ], IERC20Extended( liquidityTokens[ i ] ).balanceOf( address(this) ) )\\r\\n            );\\r\\n        }\\r\\n        totalReserves = reserves;\\r\\n        emit ReservesUpdated( reserves );\\r\\n        emit ReservesAudited( reserves );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice returns KEEPER valuation of asset\\r\\n        @param _token address\\r\\n        @param _amount uint\\r\\n        @return value_ uint\\r\\n     */\\r\\n    function valueOfToken( address _token, uint _amount ) public view returns ( uint value_ ) {\\r\\n        if ( isReserveToken[ _token ] ) {\\r\\n            // convert amount to match KEEPER decimals\\r\\n            value_ = _amount.mul( 10 ** keeperDecimals ).div( 10 ** IERC20Extended( _token ).decimals() );\\r\\n        } else if ( isLiquidityToken[ _token ] ) {\\r\\n            value_ = IBondCalculator( bondCalculator[ _token ] ).valuation( _token, _amount );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice queue address to change boolean in mapping\\r\\n        @param _managing MANAGING\\r\\n        @param _address address\\r\\n        @return bool\\r\\n     */\\r\\n    function queue( MANAGING _managing, address _address ) external onlyOwner() returns ( bool ) {\\r\\n        require( _address != address(0) );\\r\\n        if ( _managing == MANAGING.RESERVEDEPOSITOR ) { // 0\\r\\n            reserveDepositorQueue[ _address ] = block.timestamp.add( secondsNeededForQueue );\\r\\n        } else if ( _managing == MANAGING.RESERVESPENDER ) { // 1\\r\\n            reserveSpenderQueue[ _address ] = block.timestamp.add( secondsNeededForQueue );\\r\\n        } else if ( _managing == MANAGING.RESERVETOKEN ) { // 2\\r\\n            reserveTokenQueue[ _address ] = block.timestamp.add( secondsNeededForQueue );\\r\\n        } else if ( _managing == MANAGING.RESERVEMANAGER ) { // 3\\r\\n            ReserveManagerQueue[ _address ] = block.timestamp.add( secondsNeededForQueue.mul( 2 ) );\\r\\n        } else if ( _managing == MANAGING.LIQUIDITYDEPOSITOR ) { // 4\\r\\n            LiquidityDepositorQueue[ _address ] = block.timestamp.add( secondsNeededForQueue );\\r\\n        } else if ( _managing == MANAGING.LIQUIDITYTOKEN ) { // 5\\r\\n            LiquidityTokenQueue[ _address ] = block.timestamp.add( secondsNeededForQueue );\\r\\n        } else if ( _managing == MANAGING.LIQUIDITYMANAGER ) { // 6\\r\\n            LiquidityManagerQueue[ _address ] = block.timestamp.add( secondsNeededForQueue.mul( 2 ) );\\r\\n        } else if ( _managing == MANAGING.DEBTOR ) { // 7\\r\\n            debtorQueue[ _address ] = block.timestamp.add( secondsNeededForQueue );\\r\\n        } else if ( _managing == MANAGING.REWARDMANAGER ) { // 8\\r\\n            rewardManagerQueue[ _address ] = block.timestamp.add( secondsNeededForQueue );\\r\\n        } else if ( _managing == MANAGING.SKEEPER ) { // 9\\r\\n            sKEEPERQueue = block.timestamp.add( secondsNeededForQueue );\\r\\n        } else return false;\\r\\n\\r\\n        emit ChangeQueued( _managing, _address );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice verify queue then set boolean in mapping\\r\\n        @param _managing MANAGING\\r\\n        @param _address address\\r\\n        @param _calculator address\\r\\n        @return bool\\r\\n     */\\r\\n    function toggle( MANAGING _managing, address _address, address _calculator ) external onlyOwner() returns ( bool ) {\\r\\n        require( _address != address(0) );\\r\\n        bool result;\\r\\n        if ( _managing == MANAGING.RESERVEDEPOSITOR ) { // 0\\r\\n            if ( requirements( reserveDepositorQueue, isReserveDepositor, _address ) ) {\\r\\n                reserveDepositorQueue[ _address ] = 0;\\r\\n                if( !listContains( reserveDepositors, _address ) ) {\\r\\n                    reserveDepositors.push( _address );\\r\\n                }\\r\\n            }\\r\\n            result = !isReserveDepositor[ _address ];\\r\\n            isReserveDepositor[ _address ] = result;\\r\\n            \\r\\n        } else if ( _managing == MANAGING.RESERVESPENDER ) { // 1\\r\\n            if ( requirements( reserveSpenderQueue, isReserveSpender, _address ) ) {\\r\\n                reserveSpenderQueue[ _address ] = 0;\\r\\n                if( !listContains( reserveSpenders, _address ) ) {\\r\\n                    reserveSpenders.push( _address );\\r\\n                }\\r\\n            }\\r\\n            result = !isReserveSpender[ _address ];\\r\\n            isReserveSpender[ _address ] = result;\\r\\n\\r\\n        } else if ( _managing == MANAGING.RESERVETOKEN ) { // 2\\r\\n            if ( requirements( reserveTokenQueue, isReserveToken, _address ) ) {\\r\\n                reserveTokenQueue[ _address ] = 0;\\r\\n                if( !listContains( reserveTokens, _address ) ) {\\r\\n                    reserveTokens.push( _address );\\r\\n                }\\r\\n            }\\r\\n            result = !isReserveToken[ _address ];\\r\\n            isReserveToken[ _address ] = result;\\r\\n\\r\\n        } else if ( _managing == MANAGING.RESERVEMANAGER ) { // 3\\r\\n            if ( requirements( ReserveManagerQueue, isReserveManager, _address ) ) {\\r\\n                reserveManagers.push( _address );\\r\\n                ReserveManagerQueue[ _address ] = 0;\\r\\n                if( !listContains( reserveManagers, _address ) ) {\\r\\n                    reserveManagers.push( _address );\\r\\n                }\\r\\n            }\\r\\n            result = !isReserveManager[ _address ];\\r\\n            isReserveManager[ _address ] = result;\\r\\n\\r\\n        } else if ( _managing == MANAGING.LIQUIDITYDEPOSITOR ) { // 4\\r\\n            if ( requirements( LiquidityDepositorQueue, isLiquidityDepositor, _address ) ) {\\r\\n                liquidityDepositors.push( _address );\\r\\n                LiquidityDepositorQueue[ _address ] = 0;\\r\\n                if( !listContains( liquidityDepositors, _address ) ) {\\r\\n                    liquidityDepositors.push( _address );\\r\\n                }\\r\\n            }\\r\\n            result = !isLiquidityDepositor[ _address ];\\r\\n            isLiquidityDepositor[ _address ] = result;\\r\\n\\r\\n        } else if ( _managing == MANAGING.LIQUIDITYTOKEN ) { // 5\\r\\n            if ( requirements( LiquidityTokenQueue, isLiquidityToken, _address ) ) {\\r\\n                LiquidityTokenQueue[ _address ] = 0;\\r\\n                if( !listContains( liquidityTokens, _address ) ) {\\r\\n                    liquidityTokens.push( _address );\\r\\n                }\\r\\n            }\\r\\n            result = !isLiquidityToken[ _address ];\\r\\n            isLiquidityToken[ _address ] = result;\\r\\n            bondCalculator[ _address ] = _calculator;\\r\\n\\r\\n        } else if ( _managing == MANAGING.LIQUIDITYMANAGER ) { // 6\\r\\n            if ( requirements( LiquidityManagerQueue, isLiquidityManager, _address ) ) {\\r\\n                LiquidityManagerQueue[ _address ] = 0;\\r\\n                if( !listContains( liquidityManagers, _address ) ) {\\r\\n                    liquidityManagers.push( _address );\\r\\n                }\\r\\n            }\\r\\n            result = !isLiquidityManager[ _address ];\\r\\n            isLiquidityManager[ _address ] = result;\\r\\n\\r\\n        } else if ( _managing == MANAGING.DEBTOR ) { // 7\\r\\n            if ( requirements( debtorQueue, isDebtor, _address ) ) {\\r\\n                debtorQueue[ _address ] = 0;\\r\\n                if( !listContains( debtors, _address ) ) {\\r\\n                    debtors.push( _address );\\r\\n                }\\r\\n            }\\r\\n            result = !isDebtor[ _address ];\\r\\n            isDebtor[ _address ] = result;\\r\\n\\r\\n        } else if ( _managing == MANAGING.REWARDMANAGER ) { // 8\\r\\n            if ( requirements( rewardManagerQueue, isRewardManager, _address ) ) {\\r\\n                rewardManagerQueue[ _address ] = 0;\\r\\n                if( !listContains( rewardManagers, _address ) ) {\\r\\n                    rewardManagers.push( _address );\\r\\n                }\\r\\n            }\\r\\n            result = !isRewardManager[ _address ];\\r\\n            isRewardManager[ _address ] = result;\\r\\n\\r\\n        } else if ( _managing == MANAGING.SKEEPER ) { // 9\\r\\n            sKEEPERQueue = 0;\\r\\n            sKEEPER = _address;\\r\\n            result = true;\\r\\n\\r\\n        } else return false;\\r\\n\\r\\n        emit ChangeActivated( _managing, _address, result );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice checks requirements and returns altered structs\\r\\n        @param queue_ mapping( address => uint )\\r\\n        @param status_ mapping( address => bool )\\r\\n        @param _address address\\r\\n        @return bool \\r\\n     */\\r\\n    function requirements( \\r\\n        mapping( address => uint ) storage queue_, \\r\\n        mapping( address => bool ) storage status_, \\r\\n        address _address \\r\\n    ) internal view returns ( bool ) {\\r\\n        if ( !status_[ _address ] ) {\\r\\n            require( queue_[ _address ] != 0, \\\"Must queue\\\" );\\r\\n            require( queue_[ _address ] <= block.timestamp, \\\"Queue not expired\\\" );\\r\\n            return true;\\r\\n        } return false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice checks array to ensure against duplicate\\r\\n        @param _list address[]\\r\\n        @param _token address\\r\\n        @return bool\\r\\n     */\\r\\n    function listContains( address[] storage _list, address _token ) internal view returns ( bool ) {\\r\\n        for( uint i = 0; i < _list.length; i++ ) {\\r\\n            if( _list[ i ] == _token ) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IKeplerERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IKeplerERC20 is IERC20 {\\r\\n\\r\\n  function decimals() external view returns (uint8);\\r\\n\\r\\n  function mint(uint256 amount_) external;\\r\\n\\r\\n  function mint(address account_, uint256 ammount_) external;\\r\\n\\r\\n  function burnFrom(address account_, uint256 amount_) external;\\r\\n\\r\\n  function vault() external returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/StakingHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"./interfaces/IStaking.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ncontract StakingHelper {\\r\\n\\r\\n    address public immutable staking;\\r\\n    address public immutable KEEPER;\\r\\n\\r\\n    constructor ( address _staking, address _KEEPER ) {\\r\\n        require( _staking != address(0) );\\r\\n        staking = _staking;\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = _KEEPER;\\r\\n    }\\r\\n\\r\\n    function stake( uint _amount, bool _wrap ) external {\\r\\n        IERC20( KEEPER ).transferFrom( msg.sender, address(this), _amount );\\r\\n        IERC20( KEEPER ).approve( staking, _amount );\\r\\n        IStaking( staking ).stake( _amount, msg.sender, _wrap );\\r\\n        IStaking( staking ).claim( msg.sender );\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"./interfaces/IDistributor.sol\\\";\\r\\nimport \\\"./interfaces/IiKEEPER.sol\\\";\\r\\nimport \\\"./interfaces/IsKEEPER.sol\\\";\\r\\nimport \\\"./interfaces/IwTROVE.sol\\\";\\r\\nimport \\\"./libraries/SafeMathExtended.sol\\\";\\r\\n\\r\\ncontract oldStaking is Ownable {\\r\\n    \\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeERC20 for IsKEEPER;\\r\\n    using SafeMathExtended for uint256;\\r\\n    using SafeMathExtended for uint32;\\r\\n\\r\\n    event DistributorSet( address distributor );\\r\\n    event WarmupSet( uint warmup );\\r\\n    event IKeeperSet( address iKEEPER );\\r\\n\\r\\n    struct Epoch {\\r\\n        uint32 length;\\r\\n        uint32 endTime;\\r\\n        uint32 number;\\r\\n        uint distribute;\\r\\n    }\\r\\n\\r\\n    struct Claim {\\r\\n        uint deposit;\\r\\n        uint gons;\\r\\n        uint expiry;\\r\\n        bool lock; // prevents malicious delays\\r\\n    }\\r\\n\\r\\n    IERC20 public immutable KEEPER;\\r\\n    IsKEEPER public immutable sKEEPER;\\r\\n    IwTROVE public immutable wTROVE;\\r\\n    Epoch public epoch;\\r\\n    address public distributor;\\r\\n    address public iKEEPER;\\r\\n    mapping( address => Claim ) public warmupInfo;\\r\\n    uint32 public warmupPeriod;\\r\\n    uint gonsInWarmup;\\r\\n\\r\\n\\r\\n    constructor (address _KEEPER, address _sKEEPER, address _wTROVE, uint32 _epochLength, uint32 _firstEpochNumber, uint32 _firstEpochTime) {\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = IERC20( _KEEPER );\\r\\n        require( _sKEEPER != address(0) );\\r\\n        sKEEPER = IsKEEPER( _sKEEPER );\\r\\n        require( _wTROVE != address(0) );\\r\\n        wTROVE = IwTROVE( _wTROVE );\\r\\n        epoch = Epoch({\\r\\n            length: _epochLength,\\r\\n            number: _firstEpochNumber,\\r\\n            endTime: _firstEpochTime,\\r\\n            distribute: 0\\r\\n        });\\r\\n    }\\r\\n\\r\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice stake KEEPER to enter warmup\\r\\n     * @param _amount uint\\r\\n     * @param _recipient address\\r\\n     */\\r\\n    function stake( uint _amount, address _recipient, bool _wrap ) external returns ( uint ) {\\r\\n        rebase();\\r\\n\\r\\n        KEEPER.safeTransferFrom( msg.sender, address(this), _amount );\\r\\n\\r\\n        if ( warmupPeriod == 0 ) {\\r\\n            return _send( _recipient, _amount, _wrap );\\r\\n        }\\r\\n        else {\\r\\n            Claim memory info = warmupInfo[ _recipient ];\\r\\n            if ( !info.lock ) {\\r\\n                require( _recipient == msg.sender, \\\"External deposits for account are locked\\\" );\\r\\n            }\\r\\n\\r\\n            uint sKeeperGons = sKEEPER.gonsForBalance( _amount );\\r\\n            warmupInfo[ _recipient ] = Claim ({\\r\\n                deposit: info.deposit.add(_amount),\\r\\n                gons: info.gons.add(sKeeperGons),\\r\\n                expiry: epoch.number.add32(warmupPeriod),\\r\\n                lock: info.lock\\r\\n            });\\r\\n\\r\\n            gonsInWarmup = gonsInWarmup.add(sKeeperGons);\\r\\n            return _amount;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function stakeInvest( uint _stakeAmount, uint _investAmount, address _recipient, bool _wrap ) external {\\r\\n        rebase();\\r\\n        uint keeperAmount = _stakeAmount.add(_investAmount.div(1e9));\\r\\n        KEEPER.safeTransferFrom( msg.sender, address(this), keeperAmount );\\r\\n        _send( _recipient, _stakeAmount, _wrap );\\r\\n        sKEEPER.approve(iKEEPER, _investAmount);\\r\\n        IiKEEPER(iKEEPER).wrap(_investAmount, _recipient);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice retrieve stake from warmup\\r\\n     * @param _recipient address\\r\\n     */\\r\\n    function claim ( address _recipient ) public returns ( uint ) {\\r\\n        Claim memory info = warmupInfo[ _recipient ];\\r\\n        if ( epoch.number >= info.expiry && info.expiry != 0 ) {\\r\\n            delete warmupInfo[ _recipient ];\\r\\n            gonsInWarmup = gonsInWarmup.sub(info.gons);\\r\\n            return _send( _recipient, sKEEPER.balanceForGons( info.gons ), false);\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice forfeit stake and retrieve KEEPER\\r\\n     */\\r\\n    function forfeit() external returns ( uint ) {\\r\\n        Claim memory info = warmupInfo[ msg.sender ];\\r\\n        delete warmupInfo[ msg.sender ];\\r\\n        gonsInWarmup = gonsInWarmup.sub(info.gons);\\r\\n        KEEPER.safeTransfer( msg.sender, info.deposit );\\r\\n        return info.deposit;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice prevent new deposits or claims from ext. address (protection from malicious activity)\\r\\n     */\\r\\n    function toggleLock() external {\\r\\n        warmupInfo[ msg.sender ].lock = !warmupInfo[ msg.sender ].lock;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice redeem sKEEPER for KEEPER\\r\\n     * @param _amount uint\\r\\n     * @param _trigger bool\\r\\n     */\\r\\n    function unstake( uint _amount, bool _trigger ) external returns ( uint ) {\\r\\n        if ( _trigger ) {\\r\\n            rebase();\\r\\n        }\\r\\n        uint amount = _amount;\\r\\n        sKEEPER.safeTransferFrom( msg.sender, address(this), _amount );\\r\\n        KEEPER.safeTransfer( msg.sender, amount );\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice trigger rebase if epoch over\\r\\n     */\\r\\n    function rebase() public {\\r\\n        if( epoch.endTime <= uint32(block.timestamp) ) {\\r\\n            sKEEPER.rebase( epoch.distribute, epoch.number );\\r\\n            epoch.endTime = epoch.endTime.add32(epoch.length);\\r\\n            epoch.number++;            \\r\\n            if ( distributor != address(0) ) {\\r\\n                IDistributor( distributor ).distribute();\\r\\n            }\\r\\n\\r\\n            uint contractBalanceVal = contractBalance();\\r\\n            uint totalStakedVal = totalStaked();\\r\\n            if( contractBalanceVal <= totalStakedVal ) {\\r\\n                epoch.distribute = 0;\\r\\n            }\\r\\n            else {\\r\\n                epoch.distribute = contractBalanceVal.sub(totalStakedVal);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /* ========== INTERNAL FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice send staker their amount as sKEEPER or gKEEPER\\r\\n     * @param _recipient address\\r\\n     * @param _amount uint\\r\\n     */\\r\\n    function _send( address _recipient, uint _amount, bool _wrap ) internal returns ( uint ) {\\r\\n        if (_wrap) {\\r\\n            sKEEPER.approve( address( wTROVE ), _amount );\\r\\n            uint wrapValue = wTROVE.wrap( _amount );\\r\\n            wTROVE.transfer( _recipient, wrapValue );\\r\\n        } else {\\r\\n            sKEEPER.safeTransfer( _recipient, _amount ); // send as sKEEPER (equal unit as KEEPER)\\r\\n        }\\r\\n        return _amount;\\r\\n    }\\r\\n\\r\\n    /* ========== VIEW FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n        @notice returns the sKEEPER index, which tracks rebase growth\\r\\n        @return uint\\r\\n     */\\r\\n    function index() public view returns ( uint ) {\\r\\n        return sKEEPER.index();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice returns contract KEEPER holdings, including bonuses provided\\r\\n        @return uint\\r\\n     */\\r\\n    function contractBalance() public view returns ( uint ) {\\r\\n        return KEEPER.balanceOf( address(this) );\\r\\n    }\\r\\n\\r\\n    function totalStaked() public view returns ( uint ) {\\r\\n        return sKEEPER.circulatingSupply();\\r\\n    }\\r\\n\\r\\n    function supplyInWarmup() public view returns ( uint ) {\\r\\n        return sKEEPER.balanceForGons( gonsInWarmup );\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    /* ========== MANAGERIAL FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n        @notice sets the contract address for LP staking\\r\\n        @param _address address\\r\\n     */\\r\\n    function setDistributor( address _address ) external onlyOwner() {\\r\\n        distributor = _address;\\r\\n        emit DistributorSet( _address );\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @notice set warmup period for new stakers\\r\\n     * @param _warmupPeriod uint\\r\\n     */\\r\\n    function setWarmup( uint32 _warmupPeriod ) external onlyOwner() {\\r\\n        warmupPeriod = _warmupPeriod;\\r\\n        emit WarmupSet( _warmupPeriod );\\r\\n    }\\r\\n\\r\\n\\r\\n    function setIKeeper( address _iKEEPER ) external onlyOwner() {\\r\\n        iKEEPER = _iKEEPER;\\r\\n        emit IKeeperSet( _iKEEPER );\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\ninterface IDistributor {\\r\\n    function distribute() external returns ( bool );\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IiKEEPER.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IiKEEPER is IERC20 {\\r\\n    function wrap(uint _amount, address _recipient) external;\\r\\n\\r\\n    function unwrap(uint _amount) external;\\r\\n}\"\r\n    },\r\n    \"contracts/EthBondStakeDepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"./interfaces/AggregateV3Interface.sol\\\";\\r\\nimport \\\"./interfaces/IWETH9.sol\\\";\\r\\nimport \\\"./interfaces/ITreasury.sol\\\";\\r\\nimport \\\"./interfaces/IsKEEPER.sol\\\";\\r\\nimport \\\"./interfaces/IwTROVE.sol\\\";\\r\\nimport \\\"./interfaces/IStaking.sol\\\";\\r\\nimport \\\"./libraries/FixedPoint.sol\\\";\\r\\nimport \\\"./libraries/SafeMathExtended.sol\\\";\\r\\n\\r\\n\\r\\ncontract EthBondStakeDepository is Ownable {\\r\\n    using FixedPoint for *;\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeMathExtended for uint;\\r\\n    using SafeMathExtended for uint32;\\r\\n\\r\\n    /* ======== EVENTS ======== */\\r\\n\\r\\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\\r\\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\\r\\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\\r\\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\\r\\n\\r\\n    /* ======== STATE VARIABLES ======== */\\r\\n\\r\\n    address public immutable KEEPER; // token given as payment for bond\\r\\n    address public immutable sKEEPER; // token given as payment for bond\\r\\n    address public immutable wTROVE; // Wrap sKEEPER\\r\\n    address public immutable principle; // token used to create bond\\r\\n    address public immutable treasury; // mints KEEPER when receives principle\\r\\n    address public immutable DAO; // receives profit share from bond\\r\\n\\r\\n    AggregatorV3Interface internal priceFeed;\\r\\n\\r\\n    address public staking; // to auto-stake payout\\r\\n\\r\\n    Terms public terms; // stores terms for new bonds\\r\\n    Adjust public adjustment; // stores adjustment to BCV data\\r\\n\\r\\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\\r\\n\\r\\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\\r\\n    uint32 public lastDecay; // reference block for debt decay\\r\\n\\r\\n\\r\\n    /* ======== STRUCTS ======== */\\r\\n\\r\\n    // Info for creating new bonds\\r\\n    struct Terms {\\r\\n        uint32 vestingTerm; // in seconds\\r\\n        uint controlVariable; // scaling variable for price\\r\\n        uint minimumPrice; // vs principle value. 4 decimals (1500 = 0.15)\\r\\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\\r\\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\\r\\n    }\\r\\n\\r\\n    // Info for bond holder\\r\\n    struct Bond {\\r\\n        uint32 vesting; // seconds left to vest\\r\\n        uint32 lastTime; // Last interaction\\r\\n        uint gonsPayout; // KEEPER remaining to be paid\\r\\n        uint pricePaid; // In DAI, for front end viewing\\r\\n    }\\r\\n\\r\\n    // Info for incremental adjustments to control variable \\r\\n    struct Adjust {\\r\\n        bool add; // addition or subtraction\\r\\n        uint rate; // increment\\r\\n        uint target; // BCV when adjustment finished\\r\\n        uint32 buffer; // minimum length (in blocks) between adjustments\\r\\n        uint32 lastTime; // block when last adjustment made\\r\\n    }\\r\\n\\r\\n    /* ======== INITIALIZATION ======== */\\r\\n\\r\\n    constructor ( address _KEEPER, address _sKEEPER, address _wTROVE, address _principle, address _staking, address _treasury, address _DAO, address _feed) {\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = _KEEPER;\\r\\n        require( _sKEEPER != address(0) );\\r\\n        sKEEPER = _sKEEPER;\\r\\n        require( _wTROVE != address(0) );\\r\\n        wTROVE = _wTROVE;\\r\\n        require( _principle != address(0) );\\r\\n        principle = _principle;\\r\\n        require( _treasury != address(0) );\\r\\n        treasury = _treasury;\\r\\n        require( _DAO != address(0) );\\r\\n        DAO = _DAO;\\r\\n        require( _staking != address(0) );\\r\\n        staking = _staking;\\r\\n        require( _feed != address(0) );\\r\\n        priceFeed = AggregatorV3Interface( _feed );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice initializes bond parameters\\r\\n     *  @param _controlVariable uint\\r\\n     *  @param _vestingTerm uint\\r\\n     *  @param _minimumPrice uint\\r\\n     *  @param _maxPayout uint\\r\\n     *  @param _maxDebt uint\\r\\n     *  @param _initialDebt uint\\r\\n     */\\r\\n    function initializeBondTerms(uint _controlVariable, uint32 _vestingTerm, uint _minimumPrice, uint _maxPayout,\\r\\n                                 uint _maxDebt, uint _initialDebt) external onlyOwner() {\\r\\n        require( terms.controlVariable == 0 && terms.vestingTerm == 0, \\\"Bonds must be initialized from 0\\\" );\\r\\n        terms = Terms ({\\r\\n            controlVariable: _controlVariable,\\r\\n            vestingTerm: _vestingTerm,\\r\\n            minimumPrice: _minimumPrice,\\r\\n            maxPayout: _maxPayout,\\r\\n            maxDebt: _maxDebt\\r\\n        });\\r\\n        totalDebt = _initialDebt;\\r\\n        lastDecay = uint32(block.timestamp);\\r\\n    }\\r\\n\\r\\n\\r\\n    \\r\\n    /* ======== POLICY FUNCTIONS ======== */\\r\\n\\r\\n    enum PARAMETER { VESTING, PAYOUT, DEBT, MINPRICE }\\r\\n    /**\\r\\n     *  @notice set parameters for new bonds\\r\\n     *  @param _parameter PARAMETER\\r\\n     *  @param _input uint\\r\\n     */\\r\\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyOwner() {\\r\\n        if ( _parameter == PARAMETER.VESTING ) { // 0\\r\\n            require( _input >= 129600, \\\"Vesting must be longer than 36 hours\\\" );\\r\\n            require( currentDebt() == 0, \\\"Debt should be 0.\\\" );\\r\\n            terms.vestingTerm = uint32(_input);\\r\\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\\r\\n            require( _input <= 1000, \\\"Payout cannot be above 1 percent\\\" );\\r\\n            terms.maxPayout = _input;\\r\\n        } else if ( _parameter == PARAMETER.DEBT ) { // 2\\r\\n            terms.maxDebt = _input;\\r\\n        } else if ( _parameter == PARAMETER.MINPRICE ) { // 3\\r\\n            terms.minimumPrice = _input;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice set control variable adjustment\\r\\n     *  @param _addition bool\\r\\n     *  @param _increment uint\\r\\n     *  @param _target uint\\r\\n     *  @param _buffer uint\\r\\n     */\\r\\n    function setAdjustment ( bool _addition, uint _increment, uint _target, uint32 _buffer ) external onlyOwner() {\\r\\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \\\"Increment too large\\\" );\\r\\n\\r\\n        adjustment = Adjust({\\r\\n            add: _addition,\\r\\n            rate: _increment,\\r\\n            target: _target,\\r\\n            buffer: _buffer,\\r\\n            lastTime: uint32(block.timestamp)\\r\\n        });\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice set contract for auto stake\\r\\n     *  @param _staking address\\r\\n     */\\r\\n    // function setStaking( address _staking ) external onlyOwner() {\\r\\n    //     require( _staking != address(0) );\\r\\n    //     staking = _staking;\\r\\n    // }\\r\\n\\r\\n\\r\\n    /* ======== USER FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice deposit bond\\r\\n     *  @param _amount uint\\r\\n     *  @param _maxPrice uint\\r\\n     *  @param _depositor address\\r\\n     *  @return uint\\r\\n     */\\r\\n    function deposit( uint _amount, uint _maxPrice, address _depositor) external payable returns ( uint ) {\\r\\n        require( _depositor != address(0), \\\"Invalid address\\\" );\\r\\n        decayDebt();\\r\\n        \\r\\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\\r\\n        uint nativePrice = _bondPrice();\\r\\n\\r\\n        require( _maxPrice >= nativePrice, \\\"Slippage limit: more than max price\\\" ); // slippage protection\\r\\n\\r\\n        uint value = ITreasury( treasury ).valueOfToken( principle, _amount );\\r\\n        uint payout = payoutFor( value ); // payout to bonder is computed\\r\\n\\r\\n        require( payout >= 10000000, \\\"Bond too small\\\" ); // must be > 0.01 KEEPER ( underflow protection )\\r\\n        require( payout <= maxPayout(), \\\"Bond too large\\\"); // size protection because there is no slippage\\r\\n\\r\\n        /**\\r\\n            asset carries risk and is not minted against\\r\\n            asset transfered to treasury and rewards minted as payout\\r\\n         */\\r\\n        if (address(this).balance >= _amount) {\\r\\n            // pay with WETH9\\r\\n            IWETH9(principle).deposit{value: _amount}(); // wrap only what is needed to pay\\r\\n            IWETH9(principle).transfer(treasury, _amount);\\r\\n        } else {\\r\\n            IERC20( principle ).safeTransferFrom( msg.sender, treasury, _amount );\\r\\n        }\\r\\n\\r\\n        ITreasury( treasury ).mintRewards( address(this), payout );\\r\\n        \\r\\n        // total debt is increased\\r\\n        totalDebt = totalDebt.add( value );\\r\\n        require( totalDebt <= terms.maxDebt, \\\"Max capacity reached\\\" );\\r\\n\\r\\n        IERC20( KEEPER ).approve( staking, payout );\\r\\n        IStaking( staking ).stake( payout, address(this), false );\\r\\n        IStaking( staking ).claim( address(this) );\\r\\n        uint stakeGons = IsKEEPER(sKEEPER).gonsForBalance(payout);\\r\\n                \\r\\n        // depositor info is stored\\r\\n        bondInfo[ _depositor ] = Bond({ \\r\\n            gonsPayout: bondInfo[ _depositor ].gonsPayout.add( stakeGons ),\\r\\n            vesting: terms.vestingTerm,\\r\\n            lastTime: uint32(block.timestamp),\\r\\n            pricePaid: priceInUSD\\r\\n        });\\r\\n\\r\\n        // indexed events are emitted\\r\\n        emit BondCreated( _amount, payout, block.timestamp.add( terms.vestingTerm ), priceInUSD );\\r\\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\\r\\n\\r\\n        adjust(); // control variable is adjusted\\r\\n        refundETH(); //refund user if needed\\r\\n        return payout; \\r\\n    }\\r\\n\\r\\n    /** \\r\\n     *  @notice redeem bond for user\\r\\n     *  @param _recipient address\\r\\n     *  @param _stake bool\\r\\n     *  @return uint\\r\\n     */ \\r\\n    function redeem( address _recipient, bool _stake, bool _wrap ) external returns ( uint ) {        \\r\\n        Bond memory info = bondInfo[ _recipient ];\\r\\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\\r\\n\\r\\n        if ( percentVested >= 10000 ) { // if fully vested\\r\\n            delete bondInfo[ _recipient ]; // delete user info\\r\\n            uint _amount = IsKEEPER(sKEEPER).balanceForGons(info.gonsPayout);\\r\\n            emit BondRedeemed( _recipient, _amount, 0 ); // emit bond data\\r\\n            return sendOrWrap( _recipient, _wrap, _amount ); // pay user everything due\\r\\n\\r\\n        } else { // if unfinished\\r\\n            // calculate payout vested\\r\\n            uint gonsPayout = info.gonsPayout.mul( percentVested ).div( 10000 );\\r\\n            // store updated deposit info\\r\\n            bondInfo[ _recipient ] = Bond({\\r\\n                gonsPayout: info.gonsPayout.sub( gonsPayout ),\\r\\n                vesting: info.vesting.sub32( uint32(block.timestamp).sub32( info.lastTime ) ),\\r\\n                lastTime: uint32(block.timestamp),\\r\\n                pricePaid: info.pricePaid\\r\\n            });\\r\\n\\r\\n            uint _amount = IsKEEPER(sKEEPER).balanceForGons(gonsPayout);\\r\\n            uint _remainingAmount = IsKEEPER(sKEEPER).balanceForGons(bondInfo[_recipient].gonsPayout);\\r\\n            emit BondRedeemed( _recipient, _amount, _remainingAmount );\\r\\n            return sendOrWrap( _recipient, _wrap, _amount );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    \\r\\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice allow user to wrap payout automatically\\r\\n     *  @param _wrap bool\\r\\n     *  @param _amount uint\\r\\n     *  @return uint\\r\\n     */\\r\\n    function sendOrWrap( address _recipient, bool _wrap, uint _amount ) internal returns ( uint ) {\\r\\n        if ( _wrap ) { // if user wants to wrap\\r\\n            IERC20(sKEEPER).approve( wTROVE, _amount );\\r\\n            uint wrapValue = IwTROVE(wTROVE).wrap( _amount );\\r\\n            IwTROVE(wTROVE).transfer( _recipient, wrapValue );\\r\\n        } else { // if user wants to stake\\r\\n            IERC20( sKEEPER ).transfer( _recipient, _amount ); // send payout\\r\\n        }\\r\\n        return _amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice makes incremental adjustment to control variable\\r\\n     */\\r\\n    function adjust() internal {\\r\\n        uint timeCanAdjust = adjustment.lastTime.add( adjustment.buffer );\\r\\n        if( adjustment.rate != 0 && block.timestamp >= timeCanAdjust ) {\\r\\n            uint initial = terms.controlVariable;\\r\\n            if ( adjustment.add ) {\\r\\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\\r\\n                if ( terms.controlVariable >= adjustment.target ) {\\r\\n                    adjustment.rate = 0;\\r\\n                }\\r\\n            } else {\\r\\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\\r\\n                if ( terms.controlVariable <= adjustment.target || terms.controlVariable < adjustment.rate ) {\\r\\n                    adjustment.rate = 0;\\r\\n                }\\r\\n            }\\r\\n            adjustment.lastTime = uint32(block.timestamp);\\r\\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice reduce total debt\\r\\n     */\\r\\n    function decayDebt() internal {\\r\\n        totalDebt = totalDebt.sub( debtDecay() );\\r\\n        lastDecay = uint32(block.timestamp);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    /* ======== VIEW FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice determine maximum bond size\\r\\n     *  @return uint\\r\\n     */\\r\\n    function maxPayout() public view returns ( uint ) {\\r\\n        return IERC20( KEEPER ).totalSupply().mul( terms.maxPayout ).div( 100000 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate interest due for new bond\\r\\n     *  @param _value uint\\r\\n     *  @return uint\\r\\n     */\\r\\n    function payoutFor( uint _value ) public view returns ( uint ) {\\r\\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e14 );\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current bond premium\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function bondPrice() public view returns ( uint price_ ) {        \\r\\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\\r\\n        if ( price_ < terms.minimumPrice ) {\\r\\n            price_ = terms.minimumPrice;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current bond price and remove floor if above\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function _bondPrice() internal returns ( uint price_ ) {\\r\\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\\r\\n        if ( price_ < terms.minimumPrice ) {\\r\\n            price_ = terms.minimumPrice;        \\r\\n        } else if ( terms.minimumPrice != 0 ) {\\r\\n            terms.minimumPrice = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice get asset price from chainlink\\r\\n     */\\r\\n    function assetPrice() public view returns (int) {\\r\\n        ( , int price, , , ) = priceFeed.latestRoundData();\\r\\n        return price;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice converts bond price to DAI value\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function bondPriceInUSD() public view returns ( uint price_ ) {\\r\\n        price_ = bondPrice().mul( uint( assetPrice() ) ).mul( 1e6 );\\r\\n    }\\r\\n\\r\\n    function getBondInfo(address _depositor) public view returns ( uint payout, uint vesting, uint lastTime, uint pricePaid ) {\\r\\n        Bond memory info = bondInfo[ _depositor ];\\r\\n        payout = IsKEEPER(sKEEPER).balanceForGons(info.gonsPayout);\\r\\n        vesting = info.vesting;\\r\\n        lastTime = info.lastTime;\\r\\n        pricePaid = info.pricePaid;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current ratio of debt to KEEPER supply\\r\\n     *  @return debtRatio_ uint\\r\\n     */\\r\\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \\r\\n        uint supply = IERC20( KEEPER ).totalSupply();\\r\\n        debtRatio_ = FixedPoint.fraction( \\r\\n            currentDebt().mul( 1e9 ), \\r\\n            supply\\r\\n        ).decode112with18().div( 1e18 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice debt ratio in same terms as reserve bonds\\r\\n     *  @return uint\\r\\n     */\\r\\n    function standardizedDebtRatio() external view returns ( uint ) {\\r\\n        return debtRatio().mul( uint( assetPrice() ) ).div( 1e8 ); // ETH feed is 8 decimals\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate debt factoring in decay\\r\\n     *  @return uint\\r\\n     */\\r\\n    function currentDebt() public view returns ( uint ) {\\r\\n        return totalDebt.sub( debtDecay() );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice amount to decay total debt by\\r\\n     *  @return decay_ uint\\r\\n     */\\r\\n    function debtDecay() public view returns ( uint decay_ ) {\\r\\n        uint32 timeSinceLast = uint32(block.timestamp).sub32( lastDecay );\\r\\n        decay_ = totalDebt.mul( timeSinceLast ).div( terms.vestingTerm );\\r\\n        if ( decay_ > totalDebt ) {\\r\\n            decay_ = totalDebt;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate how far into vesting a depositor is\\r\\n     *  @param _depositor address\\r\\n     *  @return percentVested_ uint\\r\\n     */\\r\\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\\r\\n        Bond memory bond = bondInfo[ _depositor ];\\r\\n        uint timeSinceLast = uint32(block.timestamp).sub( bond.lastTime );\\r\\n        uint vesting = bond.vesting;\\r\\n\\r\\n        if ( vesting > 0 ) {\\r\\n            percentVested_ = timeSinceLast.mul( 10000 ).div( vesting );\\r\\n        } else {\\r\\n            percentVested_ = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate amount of KEEPER available for claim by depositor\\r\\n     *  @param _depositor address\\r\\n     *  @return pendingPayout_ uint\\r\\n     */\\r\\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\\r\\n        uint percentVested = percentVestedFor( _depositor );\\r\\n        uint payout = IsKEEPER(sKEEPER).balanceForGons(bondInfo[ _depositor ].gonsPayout);\\r\\n\\r\\n        if ( percentVested >= 10000 ) {\\r\\n            pendingPayout_ = payout;\\r\\n        } else {\\r\\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    /* ======= AUXILLIARY ======= */\\r\\n\\r\\n    /**\\r\\n     *  @notice allow anyone to send lost tokens (excluding principle or KEEPER) to the DAO\\r\\n     *  @return bool\\r\\n     */\\r\\n    function recoverLostToken( address _token ) external returns ( bool ) {\\r\\n        require( _token != KEEPER );\\r\\n        require( _token != sKEEPER );\\r\\n        require( _token != principle );\\r\\n        IERC20( _token ).safeTransfer( DAO, IERC20( _token ).balanceOf( address(this) ) );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function refundETH() internal {\\r\\n        if (address(this).balance > 0) safeTransferETH(DAO, address(this).balance);\\r\\n    }\\r\\n\\r\\n    /// @notice Transfers ETH to the recipient address\\r\\n    /// @dev Fails with `STE`\\r\\n    /// @param to The destination of the transfer\\r\\n    /// @param value The value to be transferred\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n        require(success, 'STE');\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IWETH9.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IWETH9 is IERC20 {\\r\\n    /// @notice Deposit ether to get wrapped ether\\r\\n    function deposit() external payable;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/wTROVE.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"./interfaces/IsKEEPER.sol\\\";\\r\\n\\r\\n\\r\\ncontract wTROVE is ERC20 {\\r\\n\\r\\n    using SafeMath for uint;\\r\\n    address public immutable TROVE;\\r\\n\\r\\n\\r\\n    constructor(address _TROVE) ERC20(\\\"Wrapped Trove\\\", \\\"wTROVE\\\") {\\r\\n        require(_TROVE != address(0));\\r\\n        TROVE = _TROVE;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice wrap TROVE\\r\\n        @param _amount uint\\r\\n        @return uint\\r\\n     */\\r\\n    function wrap( uint _amount ) external returns ( uint ) {\\r\\n        IsKEEPER( TROVE ).transferFrom( msg.sender, address(this), _amount );\\r\\n        \\r\\n        uint value = TROVETowTROVE( _amount );\\r\\n        _mint( msg.sender, value );\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice unwrap TROVE\\r\\n        @param _amount uint\\r\\n        @return uint\\r\\n     */\\r\\n    function unwrap( uint _amount ) external returns ( uint ) {\\r\\n        _burn( msg.sender, _amount );\\r\\n\\r\\n        uint value = wTROVEToTROVE( _amount );\\r\\n        IsKEEPER( TROVE ).transfer( msg.sender, value );\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice converts wTROVE amount to TROVE\\r\\n        @param _amount uint\\r\\n        @return uint\\r\\n     */\\r\\n    function wTROVEToTROVE( uint _amount ) public view returns ( uint ) {\\r\\n        return _amount.mul( IsKEEPER( TROVE ).index() ).div( 10 ** decimals() );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice converts TROVE amount to wTROVE\\r\\n        @param _amount uint\\r\\n        @return uint\\r\\n     */\\r\\n    function TROVETowTROVE( uint _amount ) public view returns ( uint ) {\\r\\n        return _amount.mul( 10 ** decimals() ).div( IsKEEPER( TROVE ).index() );\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"contracts/USDC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\n\\r\\ncontract USDC is ERC20, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    constructor() ERC20(\\\"USDC\\\", \\\"USDC\\\") {\\r\\n    }\\r\\n\\r\\n    function mint(address account_, uint256 amount_) external onlyOwner() {\\r\\n        _mint(account_, amount_);\\r\\n    }\\r\\n\\r\\n    function burn(uint256 amount) public virtual {\\r\\n        _burn(msg.sender, amount);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/sKeplerERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"./interfaces/IStaking.sol\\\";\\r\\n\\r\\ncontract sKeplerERC20 is ERC20 {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    event StakingContractUpdated(address stakingContract);\\r\\n    event LogSupply(uint256 indexed epoch, uint256 timestamp, uint256 totalSupply);\\r\\n    event LogRebase(uint256 indexed epoch, uint256 rebase, uint256 index);\\r\\n\\r\\n    address initializer;\\r\\n    address public stakingContract; // balance used to calc rebase\\r\\n\\r\\n    uint8 private constant _tokenDecimals = 9;\\r\\n    uint INDEX; // Index Gons - tracks rebase growth\\r\\n    uint _totalSupply;\\r\\n\\r\\n    uint256 private constant MAX_UINT256 = ~uint256(0);\\r\\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 5000000 * 10**_tokenDecimals;\\r\\n\\r\\n    // TOTAL_GONS is a multiple of INITIAL_FRAGMENTS_SUPPLY so that _gonsPerFragment is an integer.\\r\\n    // Use the highest value that fits in a uint256 for max granularity.\\r\\n    uint256 private constant TOTAL_GONS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\\r\\n\\r\\n    // MAX_SUPPLY = maximum integer < (sqrt(4*TOTAL_GONS + 1) - 1) / 2\\r\\n    uint256 private constant MAX_SUPPLY = ~uint128(0);  // (2^128) - 1\\r\\n\\r\\n    uint256 private _gonsPerFragment;\\r\\n    mapping(address => uint256) private _gonBalances;\\r\\n    mapping (address => mapping (address => uint256)) private _allowedValue;\\r\\n\\r\\n    struct Rebase {\\r\\n        uint epoch;\\r\\n        uint rebase; // 18 decimals\\r\\n        uint totalStakedBefore;\\r\\n        uint totalStakedAfter;\\r\\n        uint amountRebased;\\r\\n        uint index;\\r\\n        uint timeOccured;\\r\\n    }\\r\\n\\r\\n    Rebase[] public rebases; // past rebase data    \\r\\n\\r\\n    modifier onlyStakingContract() {\\r\\n        require(msg.sender == stakingContract);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor() ERC20(\\\"Staked Keeper\\\", \\\"TROVE\\\") {\\r\\n        _setupDecimals(_tokenDecimals);\\r\\n        initializer = msg.sender;\\r\\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\\r\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\r\\n    }\\r\\n\\r\\n    function setIndex(uint _INDEX) external {\\r\\n        require(msg.sender == initializer);\\r\\n        require(INDEX == 0);\\r\\n        require(_INDEX != 0);\\r\\n        INDEX = gonsForBalance(_INDEX);\\r\\n    }\\r\\n\\r\\n    // do this last\\r\\n    function initialize(address _stakingContract) external {\\r\\n        require(msg.sender == initializer);\\r\\n        require(_stakingContract != address(0));\\r\\n        stakingContract = _stakingContract;\\r\\n        _gonBalances[ stakingContract ] = TOTAL_GONS;\\r\\n\\r\\n        emit Transfer(address(0x0), stakingContract, _totalSupply);\\r\\n        emit StakingContractUpdated(_stakingContract);\\r\\n        \\r\\n        initializer = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice increases sKEEPER supply to increase staking balances relative to _profit\\r\\n        @param _profit uint256\\r\\n        @return uint256\\r\\n    */\\r\\n    function rebase(uint256 _profit, uint _epoch) public onlyStakingContract() returns (uint256) {\\r\\n        uint256 rebaseAmount;\\r\\n        uint256 _circulatingSupply = circulatingSupply();\\r\\n\\r\\n        if (_profit == 0) {\\r\\n            emit LogSupply(_epoch, block.timestamp, _totalSupply);\\r\\n            emit LogRebase(_epoch, 0, index());\\r\\n            return _totalSupply;\\r\\n        }\\r\\n        else if (_circulatingSupply > 0) {\\r\\n            rebaseAmount = _profit.mul(_totalSupply).div(_circulatingSupply);\\r\\n        }\\r\\n        else {\\r\\n            rebaseAmount = _profit;\\r\\n        }\\r\\n\\r\\n        _totalSupply = _totalSupply.add(rebaseAmount);\\r\\n        if (_totalSupply > MAX_SUPPLY) {\\r\\n            _totalSupply = MAX_SUPPLY;\\r\\n        }\\r\\n\\r\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\r\\n        _storeRebase(_circulatingSupply, _profit, _epoch);\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice emits event with data about rebase\\r\\n        @param _previousCirculating uint\\r\\n        @param _profit uint\\r\\n        @param _epoch uint\\r\\n        @return bool\\r\\n    */\\r\\n    function _storeRebase(uint _previousCirculating, uint _profit, uint _epoch) internal returns (bool) {\\r\\n        uint rebasePercent = _profit.mul(1e18).div(_previousCirculating);\\r\\n\\r\\n        rebases.push(Rebase ({\\r\\n            epoch: _epoch,\\r\\n            rebase: rebasePercent, // 18 decimals\\r\\n            totalStakedBefore: _previousCirculating,\\r\\n            totalStakedAfter: circulatingSupply(),\\r\\n            amountRebased: _profit,\\r\\n            index: index(),\\r\\n            timeOccured: uint32(block.timestamp)\\r\\n        }));\\r\\n        \\r\\n        emit LogSupply(_epoch, block.timestamp, _totalSupply);\\r\\n        emit LogRebase(_epoch, rebasePercent, index());\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /* =================================== VIEW FUNCTIONS ========================== */\\r\\n\\r\\n    /**\\r\\n     * @param who The address to query.\\r\\n     * @return The balance of the specified address.\\r\\n     */\\r\\n    function balanceOf(address who) public view override returns (uint256) {\\r\\n        return _gonBalances[ who ].div(_gonsPerFragment);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param who The address to query.\\r\\n     * @return The gon balance of the specified address.\\r\\n     */\\r\\n    function scaledBalanceOf(address who) external view returns (uint256) {\\r\\n        return _gonBalances[who];\\r\\n    }\\r\\n\\r\\n    function gonsForBalance(uint amount) public view returns (uint) {\\r\\n        return amount * _gonsPerFragment;\\r\\n    }\\r\\n\\r\\n    function balanceForGons(uint gons) public view returns (uint) {\\r\\n        return gons / _gonsPerFragment;\\r\\n    }\\r\\n\\r\\n    // Staking contract holds excess sKEEPER\\r\\n    function circulatingSupply() public view returns (uint) {\\r\\n        return _totalSupply.sub(balanceOf(stakingContract)).add(IStaking(stakingContract).supplyInWarmup());\\r\\n    }\\r\\n\\r\\n    function index() public view returns (uint) {\\r\\n        return balanceForGons(INDEX);\\r\\n    }\\r\\n\\r\\n    function allowance(address owner_, address spender) public view override returns (uint256) {\\r\\n        return _allowedValue[ owner_ ][ spender ];\\r\\n    }\\r\\n\\r\\n    /* ================================= MUTATIVE FUNCTIONS ====================== */\\r\\n\\r\\n    function transfer(address to, uint256 value) public override returns (bool) {\\r\\n        uint256 gonValue = value.mul(_gonsPerFragment);\\r\\n        _gonBalances[ msg.sender ] = _gonBalances[ msg.sender ].sub(gonValue);\\r\\n        _gonBalances[ to ] = _gonBalances[ to ].add(gonValue);\\r\\n        emit Transfer(msg.sender, to, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 value) public override returns (bool) {\\r\\n       _allowedValue[ from ][ msg.sender ] = _allowedValue[ from ][ msg.sender ].sub(value);\\r\\n       emit Approval(from, msg.sender,  _allowedValue[ from ][ msg.sender ]);\\r\\n\\r\\n        uint256 gonValue = gonsForBalance(value);\\r\\n        _gonBalances[ from ] = _gonBalances[from].sub(gonValue);\\r\\n        _gonBalances[ to ] = _gonBalances[to].add(gonValue);\\r\\n        emit Transfer(from, to, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _approve(address owner, address spender, uint256 value) internal override virtual {\\r\\n        _allowedValue[owner][spender] = value;\\r\\n        emit Approval(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 value) public override returns (bool) {\\r\\n         _allowedValue[ msg.sender ][ spender ] = value;\\r\\n         emit Approval(msg.sender, spender, value);\\r\\n         return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public override returns (bool) {\\r\\n        _allowedValue[ msg.sender ][ spender ] = _allowedValue[ msg.sender ][ spender ].add(addedValue);\\r\\n        emit Approval(msg.sender, spender, _allowedValue[ msg.sender ][ spender ]);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public override returns (bool) {\\r\\n        uint256 oldValue = _allowedValue[ msg.sender ][ spender ];\\r\\n        if (subtractedValue >= oldValue) {\\r\\n            _allowedValue[ msg.sender ][ spender ] = 0;\\r\\n        } else {\\r\\n            _allowedValue[ msg.sender ][ spender ] = oldValue.sub(subtractedValue);\\r\\n        }\\r\\n        emit Approval(msg.sender, spender, _allowedValue[ msg.sender ][ spender ]);\\r\\n        return true;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/other/cKEEPER.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\n\\r\\ncontract cKEEPER is ERC20, Ownable {\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    bool public requireSellerApproval;\\r\\n\\r\\n    mapping( address => bool ) public isApprovedSeller;\\r\\n    \\r\\n    constructor() ERC20(\\\"Call Keeper\\\", \\\"cKEEPER\\\") {\\r\\n        uint initSupply = 500000000 * 1e18;\\r\\n        _addApprovedSeller( address(this) );\\r\\n        _addApprovedSeller( msg.sender );\\r\\n        _mint( msg.sender, initSupply );\\r\\n        requireSellerApproval = true;\\r\\n    }\\r\\n\\r\\n    function allowOpenTrading() external onlyOwner() returns ( bool ) {\\r\\n        requireSellerApproval = false;\\r\\n        return requireSellerApproval;\\r\\n    }\\r\\n\\r\\n    function _addApprovedSeller( address approvedSeller_ ) internal {\\r\\n        isApprovedSeller[approvedSeller_] = true;\\r\\n    }\\r\\n\\r\\n    function addApprovedSeller( address approvedSeller_ ) external onlyOwner() returns ( bool ) {\\r\\n        _addApprovedSeller( approvedSeller_ );\\r\\n        return isApprovedSeller[approvedSeller_];\\r\\n    }\\r\\n\\r\\n    function addApprovedSellers( address[] calldata approvedSellers_ ) external onlyOwner() returns ( bool ) {\\r\\n        for( uint iteration_; iteration_ < approvedSellers_.length; iteration_++ ) {\\r\\n          _addApprovedSeller( approvedSellers_[iteration_] );\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _removeApprovedSeller( address disapprovedSeller_ ) internal {\\r\\n        isApprovedSeller[disapprovedSeller_] = false;\\r\\n    }\\r\\n\\r\\n    function removeApprovedSeller( address disapprovedSeller_ ) external onlyOwner() returns ( bool ) {\\r\\n        _removeApprovedSeller( disapprovedSeller_ );\\r\\n        return isApprovedSeller[disapprovedSeller_];\\r\\n    }\\r\\n\\r\\n    function removeApprovedSellers( address[] calldata disapprovedSellers_ ) external onlyOwner() returns ( bool ) {\\r\\n        for( uint iteration_; iteration_ < disapprovedSellers_.length; iteration_++ ) {\\r\\n            _removeApprovedSeller( disapprovedSellers_[iteration_] );\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(address from_, address to_, uint256 amount_ ) internal override {\\r\\n        require( (balanceOf(to_) > 0 || isApprovedSeller[from_] == true || !requireSellerApproval), \\\"Account not approved to transfer cKEEPER.\\\" );\\r\\n    }\\r\\n\\r\\n    function burn(uint256 amount_) public virtual {\\r\\n        _burn( msg.sender, amount_ );\\r\\n    }\\r\\n\\r\\n    function burnFrom( address account_, uint256 amount_ ) public virtual {\\r\\n        _burnFrom( account_, amount_ );\\r\\n    }\\r\\n\\r\\n    function _burnFrom( address account_, uint256 amount_ ) internal virtual {\\r\\n        uint256 decreasedAllowance_ = allowance( account_, msg.sender ).sub( amount_, \\\"ERC20: burn amount exceeds allowance\\\");\\r\\n        _approve( account_, msg.sender, decreasedAllowance_ );\\r\\n        _burn( account_, amount_ );\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/RedeemHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\n\\r\\ninterface IBond {\\r\\n    function redeem( address _recipient, bool _stake ) external returns ( uint );\\r\\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ );\\r\\n}\\r\\n\\r\\ncontract RedeemHelper is Ownable {\\r\\n\\r\\n    address[] public bonds;\\r\\n\\r\\n    function redeemAll( address _recipient, bool _stake ) external {\\r\\n        for( uint i = 0; i < bonds.length; i++ ) {\\r\\n            if ( bonds[i] != address(0) ) {\\r\\n                if ( IBond( bonds[i] ).pendingPayoutFor( _recipient ) > 0 ) {\\r\\n                    IBond( bonds[i] ).redeem( _recipient, _stake );\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addBondContract( address _bond ) external onlyOwner() {\\r\\n        require( _bond != address(0) );\\r\\n        bonds.push( _bond );\\r\\n    }\\r\\n\\r\\n    function removeBondContract( uint _index ) external onlyOwner() {\\r\\n        bonds[ _index ] = address(0);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/other/old_KEEPERCircSupply.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ncontract KEEPERCircSupply is Ownable {\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    address public KEEPER;\\r\\n    address[] public nonCirculatingKEEPERAddresses;\\r\\n\\r\\n    constructor (address _KEEPER) {\\r\\n        KEEPER = _KEEPER;\\r\\n    }\\r\\n\\r\\n    function KEEPERCirculatingSupply() external view returns (uint) {\\r\\n        uint _totalSupply = IERC20( KEEPER ).totalSupply();\\r\\n        uint _circulatingSupply = _totalSupply.sub( getNonCirculatingKEEPER() );\\r\\n        return _circulatingSupply;\\r\\n    }\\r\\n\\r\\n    function getNonCirculatingKEEPER() public view returns ( uint ) {\\r\\n        uint _nonCirculatingKEEPER;\\r\\n        for( uint i=0; i < nonCirculatingKEEPERAddresses.length; i = i.add( 1 ) ) {\\r\\n            _nonCirculatingKEEPER = _nonCirculatingKEEPER.add( IERC20( KEEPER ).balanceOf( nonCirculatingKEEPERAddresses[i] ) );\\r\\n        }\\r\\n        return _nonCirculatingKEEPER;\\r\\n    }\\r\\n\\r\\n    function setNonCirculatingKEEPERAddresses( address[] calldata _nonCirculatingAddresses ) external onlyOwner() returns ( bool ) {\\r\\n        nonCirculatingKEEPERAddresses = _nonCirculatingAddresses;\\r\\n        return true;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/other/cKeeperExercise.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"../interfaces/ITreasury.sol\\\";\\r\\nimport \\\"../interfaces/IStaking.sol\\\";\\r\\n\\r\\n\\r\\ninterface IcKEEPER {\\r\\n    function burnFrom( address account_, uint256 amount_ ) external;\\r\\n}\\r\\n\\r\\n\\r\\ncontract cKeeperExercise is Ownable {\\r\\n    using SafeMath for uint;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    address public immutable cKEEPER;\\r\\n    address public immutable KEEPER;\\r\\n    address public immutable USDC;\\r\\n    address public immutable treasury;\\r\\n\\r\\n    address public staking;\\r\\n    uint private constant CLIFF = 250000 * 10**9;   // Minimum KEEPER supply to exercise\\r\\n    uint private constant TOUCHDOWN = 5000000 * 10**9;    // Maximum KEEPER supply for percent increase\\r\\n    uint private constant Y_INCREASE = 35000;    // Increase from CLIFF to TOUCHDOWN is 3.5%. 4 decimals used\\r\\n\\r\\n    // uint private constant SLOPE = Y_INCREASE.div(TOUCHDOWN.sub(CLIFF));  // m = (y2 - y1) / (x2 - x1)\\r\\n\\r\\n    struct Term {\\r\\n        uint initPercent; // 4 decimals ( 5000 = 0.5% )\\r\\n        uint claimed;\\r\\n        uint max;\\r\\n    }\\r\\n    mapping(address => Term) public terms;\\r\\n    mapping(address => address) public walletChange;\\r\\n\\r\\n\\r\\n    constructor( address _cKEEPER, address _KEEPER, address _USDC, address _treasury, address _staking ) {\\r\\n        require( _cKEEPER != address(0) );\\r\\n        cKEEPER = _cKEEPER;\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = _KEEPER;\\r\\n        require( _USDC != address(0) );\\r\\n        USDC = _USDC;\\r\\n        require( _treasury != address(0) );\\r\\n        treasury = _treasury;\\r\\n        require( _staking != address(0) );\\r\\n        staking = _staking;\\r\\n    }\\r\\n\\r\\n    function setStaking( address _staking ) external onlyOwner() {\\r\\n        require( _staking != address(0) );\\r\\n        staking = _staking;\\r\\n    }\\r\\n\\r\\n    // Sets terms for a new wallet\\r\\n    function setTerms(address _vester, uint _amountCanClaim, uint _rate ) external onlyOwner() returns ( bool ) {\\r\\n        terms[_vester].max = _amountCanClaim;\\r\\n        terms[_vester].initPercent = _rate;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Sets terms for multiple wallets\\r\\n    function setTermsMultiple(address[] calldata _vesters, uint[] calldata _amountCanClaims, uint[] calldata _rates ) external onlyOwner() returns ( bool ) {\\r\\n        for (uint i=0; i < _vesters.length; i++) {\\r\\n            terms[_vesters[i]].max = _amountCanClaims[i];\\r\\n            terms[_vesters[i]].initPercent = _rates[i];\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Allows wallet to redeem cKEEPER for KEEPER\\r\\n    function exercise( uint _amount, bool _stake, bool _wrap ) external returns ( bool ) {\\r\\n        Term memory info = terms[ msg.sender ];\\r\\n        require( redeemable( info ) >= _amount, 'Not enough vested' );\\r\\n        require( info.max.sub( info.claimed ) >= _amount, 'Claimed over max' );\\r\\n\\r\\n        uint usdcAmount = _amount.div(1e12);\\r\\n        IERC20( USDC ).safeTransferFrom( msg.sender, address( this ), usdcAmount );\\r\\n        IcKEEPER( cKEEPER ).burnFrom( msg.sender, _amount );\\r\\n\\r\\n        IERC20( USDC ).approve( treasury, usdcAmount );\\r\\n        uint KEEPERToSend = ITreasury( treasury ).deposit( usdcAmount, USDC, 0 );\\r\\n\\r\\n        terms[ msg.sender ].claimed = info.claimed.add( _amount );\\r\\n\\r\\n        if ( _stake ) {\\r\\n            IERC20( KEEPER ).approve( staking, KEEPERToSend );\\r\\n            IStaking( staking ).stake( KEEPERToSend, msg.sender, _wrap );\\r\\n        } else {\\r\\n            IERC20( KEEPER ).safeTransfer( msg.sender, KEEPERToSend );\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Allows wallet owner to transfer rights to a new address\\r\\n    function pushWalletChange( address _newWallet ) external returns ( bool ) {\\r\\n        require( terms[ msg.sender ].initPercent != 0 );\\r\\n        walletChange[ msg.sender ] = _newWallet;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Allows wallet to pull rights from an old address\\r\\n    function pullWalletChange( address _oldWallet ) external returns ( bool ) {\\r\\n        require( walletChange[ _oldWallet ] == msg.sender, \\\"wallet did not push\\\" );\\r\\n        walletChange[ _oldWallet ] = address(0);\\r\\n        terms[ msg.sender ] = terms[ _oldWallet ];\\r\\n        delete terms[ _oldWallet ];\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Amount a wallet can redeem based on current supply\\r\\n    function redeemableFor( address _vester ) public view returns (uint) {\\r\\n        return redeemable( terms[ _vester ]);\\r\\n    }\\r\\n\\r\\n    function redeemable( Term memory _info ) internal view returns ( uint ) {\\r\\n        if ( _info.initPercent == 0 ) {\\r\\n            return 0;\\r\\n        }\\r\\n        uint keeperSupply = IERC20( KEEPER ).totalSupply();\\r\\n        if (keeperSupply < CLIFF) {\\r\\n            return 0;\\r\\n        } else if (keeperSupply > TOUCHDOWN) {\\r\\n            keeperSupply = TOUCHDOWN;\\r\\n        }\\r\\n        uint percent = Y_INCREASE.mul(keeperSupply.sub(CLIFF)).div(TOUCHDOWN.sub(CLIFF)).add(_info.initPercent);\\r\\n        return ( keeperSupply.mul( percent ).mul( 1000 ) ).sub( _info.claimed );\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/other/aKeeperStake2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"../interfaces/IStaking.sol\\\";\\r\\n\\r\\n\\r\\ncontract aKeeperStake2 is Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    IERC20 public aKEEPER;\\r\\n    IERC20 public KEEPER;\\r\\n    address public staking;\\r\\n    mapping( address => uint ) public depositInfo;\\r\\n\\r\\n    uint public depositDeadline;\\r\\n    uint public withdrawStart;\\r\\n    uint public withdrawDeadline;\\r\\n\\r\\n    \\r\\n    constructor(address _aKEEPER, uint _depositDeadline, uint _withdrawStart, uint _withdrawDeadline) {\\r\\n        require( _aKEEPER != address(0) );\\r\\n        aKEEPER = IERC20(_aKEEPER);\\r\\n        depositDeadline = _depositDeadline;\\r\\n        withdrawStart = _withdrawStart;\\r\\n        withdrawDeadline = _withdrawDeadline;\\r\\n    }\\r\\n\\r\\n    function setDepositDeadline(uint _depositDeadline) external onlyOwner() {\\r\\n        depositDeadline = _depositDeadline;\\r\\n    }\\r\\n\\r\\n    function setWithdrawStart(uint _withdrawStart) external onlyOwner() {\\r\\n        withdrawStart = _withdrawStart;\\r\\n    }\\r\\n\\r\\n    function setWithdrawDeadline(uint _withdrawDeadline) external onlyOwner() {\\r\\n        withdrawDeadline = _withdrawDeadline;\\r\\n    }\\r\\n\\r\\n    function setKeeperStaking(address _KEEPER, address _staking) external onlyOwner() {\\r\\n        KEEPER = IERC20(_KEEPER);\\r\\n        staking = _staking;\\r\\n    }\\r\\n\\r\\n    function depositaKeeper(uint amount) external {\\r\\n        require(block.timestamp < depositDeadline, \\\"Deadline passed.\\\");\\r\\n        aKEEPER.transferFrom(msg.sender, address(this), amount);\\r\\n        depositInfo[msg.sender] = depositInfo[msg.sender].add(amount);\\r\\n    }\\r\\n\\r\\n    // function withdrawaKeeper() external {\\r\\n    //     require(block.timestamp > withdrawStart, \\\"Not started.\\\");\\r\\n    //     uint amount = depositInfo[msg.sender].mul(110).div(100);\\r\\n    //     require(amount > 0, \\\"No deposit present.\\\");\\r\\n    //     delete depositInfo[msg.sender];\\r\\n    //     aKEEPER.transfer(msg.sender, amount);\\r\\n    // }\\r\\n\\r\\n    function migrate() external {\\r\\n        require(block.timestamp > withdrawStart, \\\"Not started.\\\");\\r\\n        require( address(KEEPER) != address(0) );\\r\\n        uint amount = depositInfo[msg.sender].mul(110).div(100);\\r\\n        require(amount > 0, \\\"No deposit present.\\\");\\r\\n        delete depositInfo[msg.sender];\\r\\n        KEEPER.transfer(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function migrateTrove(bool _wrap) external {\\r\\n        require(block.timestamp > withdrawStart, \\\"Not started.\\\");\\r\\n        require( staking != address(0) );\\r\\n        uint amount = depositInfo[msg.sender].mul(110).div(100);\\r\\n        require(amount > 0, \\\"No deposit present.\\\");\\r\\n        delete depositInfo[msg.sender];\\r\\n        KEEPER.approve( staking, amount );\\r\\n        IStaking( staking ).stake( amount, msg.sender, _wrap );\\r\\n    }\\r\\n\\r\\n    function withdrawAll() external onlyOwner() {\\r\\n        require(block.timestamp > withdrawDeadline, \\\"Deadline not yet passed.\\\");\\r\\n        uint256 Keeperamount = KEEPER.balanceOf(address(this));\\r\\n        KEEPER.transfer(msg.sender, Keeperamount);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/other/aKeeperStake.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"../interfaces/IStaking.sol\\\";\\r\\n\\r\\n\\r\\ncontract aKeeperStake is Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    IERC20 public aKEEPER;\\r\\n    IERC20 public KEEPER;\\r\\n    address public staking;\\r\\n    mapping( address => uint ) public depositInfo;\\r\\n\\r\\n    uint public depositDeadline;\\r\\n    uint public withdrawStart;\\r\\n    uint public withdrawDeadline;\\r\\n\\r\\n    \\r\\n    constructor(address _aKEEPER, uint _depositDeadline, uint _withdrawStart, uint _withdrawDeadline) {\\r\\n        require( _aKEEPER != address(0) );\\r\\n        aKEEPER = IERC20(_aKEEPER);\\r\\n        depositDeadline = _depositDeadline;\\r\\n        withdrawStart = _withdrawStart;\\r\\n        withdrawDeadline = _withdrawDeadline;\\r\\n    }\\r\\n\\r\\n    function setDepositDeadline(uint _depositDeadline) external onlyOwner() {\\r\\n        depositDeadline = _depositDeadline;\\r\\n    }\\r\\n\\r\\n    function setWithdrawStart(uint _withdrawStart) external onlyOwner() {\\r\\n        withdrawStart = _withdrawStart;\\r\\n    }\\r\\n\\r\\n    function setWithdrawDeadline(uint _withdrawDeadline) external onlyOwner() {\\r\\n        withdrawDeadline = _withdrawDeadline;\\r\\n    }\\r\\n\\r\\n    function setKeeperStaking(address _KEEPER, address _staking) external onlyOwner() {\\r\\n        KEEPER = IERC20(_KEEPER);\\r\\n        staking = _staking;\\r\\n    }\\r\\n\\r\\n    function depositaKeeper(uint amount) external {\\r\\n        require(block.timestamp < depositDeadline, \\\"Deadline passed.\\\");\\r\\n        aKEEPER.transferFrom(msg.sender, address(this), amount);\\r\\n        depositInfo[msg.sender] = depositInfo[msg.sender].add(amount);\\r\\n    }\\r\\n\\r\\n    function withdrawaKeeper() external {\\r\\n        require(block.timestamp > withdrawStart, \\\"Not started.\\\");\\r\\n        uint amount = depositInfo[msg.sender].mul(125).div(100);\\r\\n        require(amount > 0, \\\"No deposit present.\\\");\\r\\n        delete depositInfo[msg.sender];\\r\\n        aKEEPER.transfer(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function migrate() external {\\r\\n        require( address(KEEPER) != address(0) );\\r\\n        uint amount = depositInfo[msg.sender].mul(125).div(100);\\r\\n        require(amount > 0, \\\"No deposit present.\\\");\\r\\n        delete depositInfo[msg.sender];\\r\\n        KEEPER.transfer(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function migrateTrove(bool _wrap) external {\\r\\n        require( staking != address(0) );\\r\\n        uint amount = depositInfo[msg.sender].mul(125).div(100);\\r\\n        require(amount > 0, \\\"No deposit present.\\\");\\r\\n        delete depositInfo[msg.sender];\\r\\n        KEEPER.approve( staking, amount );\\r\\n        IStaking( staking ).stake( amount, msg.sender, _wrap );\\r\\n    }\\r\\n\\r\\n    function withdrawAll() external onlyOwner() {\\r\\n        require(block.timestamp > withdrawDeadline, \\\"Deadline not yet passed.\\\");\\r\\n        uint256 Keeperamount = KEEPER.balanceOf(address(this));\\r\\n        KEEPER.transfer(msg.sender, Keeperamount);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/other/aKeeperRedeem.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"../interfaces/IStaking.sol\\\";\\r\\n\\r\\n\\r\\ncontract oldaKeeperRedeem is Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    IERC20 public KEEPER;\\r\\n    IERC20 public aKEEPER;\\r\\n    address public staking;\\r\\n\\r\\n    event KeeperRedeemed(address tokenOwner, uint256 amount);\\r\\n    event TroveRedeemed(address tokenOwner, uint256 amount);\\r\\n    \\r\\n    constructor(address _KEEPER, address _aKEEPER, address _staking) {\\r\\n        require( _KEEPER != address(0) );\\r\\n        require( _aKEEPER != address(0) );\\r\\n        require( _staking != address(0) );\\r\\n        KEEPER = IERC20(_KEEPER);\\r\\n        aKEEPER = IERC20(_aKEEPER);\\r\\n        staking = _staking;\\r\\n    }\\r\\n\\r\\n    function setStaking(address _staking) external onlyOwner() {\\r\\n        require( _staking != address(0) );\\r\\n        staking = _staking;\\r\\n    }\\r\\n\\r\\n    function migrate(uint256 amount) public {\\r\\n        require(aKEEPER.balanceOf(msg.sender) >= amount, \\\"Cannot Redeem more than balance\\\");\\r\\n        aKEEPER.transferFrom(msg.sender, address(this), amount);\\r\\n        KEEPER.transfer(msg.sender, amount);\\r\\n        emit KeeperRedeemed(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function migrateTrove(uint256 amount, bool _wrap) public {\\r\\n        require(aKEEPER.balanceOf(msg.sender) >= amount, \\\"Cannot Redeem more than balance\\\");\\r\\n        aKEEPER.transferFrom(msg.sender, address(this), amount);\\r\\n        IERC20( KEEPER ).approve( staking, amount );\\r\\n        IStaking( staking ).stake( amount, msg.sender, _wrap );\\r\\n        emit TroveRedeemed(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function withdraw() external onlyOwner() {\\r\\n        uint256 amount = KEEPER.balanceOf(address(this));\\r\\n        KEEPER.transfer(msg.sender, amount);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/other/aKeeperPresale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"../interfaces/AggregateV3Interface.sol\\\";\\r\\n\\r\\n\\r\\ncontract aKeeperPresale is Ownable {\\r\\n    using SafeMath for uint;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    IERC20 public aKEEPER;\\r\\n    address public USDC;\\r\\n    address public USDT;\\r\\n    address public DAI;\\r\\n    address public wBTC;\\r\\n    address public gnosisSafe;\\r\\n    mapping( address => uint ) public amountInfo;\\r\\n    uint deadline;\\r\\n    \\r\\n    AggregatorV3Interface internal ethPriceFeed;\\r\\n    AggregatorV3Interface internal btcPriceFeed;\\r\\n\\r\\n    event aKeeperRedeemed(address tokenOwner, uint amount);\\r\\n\\r\\n    constructor(address _aKEEPER, address _USDC, address _USDT, address _DAI, address _wBTC, address _ethFeed, address _btcFeed, address _gnosisSafe, uint _deadline) {\\r\\n        require( _aKEEPER != address(0) );\\r\\n        require( _USDC != address(0) );\\r\\n        require( _USDT != address(0) );\\r\\n        require( _DAI != address(0) );\\r\\n        require( _wBTC != address(0) );\\r\\n        require( _ethFeed != address(0) );\\r\\n        require( _btcFeed != address(0) );\\r\\n        aKEEPER = IERC20(_aKEEPER);\\r\\n        USDC = _USDC;\\r\\n        USDT = _USDT;\\r\\n        DAI = _DAI;\\r\\n        wBTC = _wBTC;\\r\\n        gnosisSafe = _gnosisSafe;\\r\\n        deadline = _deadline;\\r\\n        ethPriceFeed = AggregatorV3Interface( _ethFeed );\\r\\n        btcPriceFeed = AggregatorV3Interface( _btcFeed );\\r\\n    }\\r\\n\\r\\n    function setDeadline(uint _deadline) external onlyOwner() {\\r\\n        deadline = _deadline;\\r\\n    }\\r\\n\\r\\n    function ethAssetPrice() public view returns (int) {\\r\\n        ( , int price, , , ) = ethPriceFeed.latestRoundData();\\r\\n        return price;\\r\\n    }\\r\\n\\r\\n    function btcAssetPrice() public view returns (int) {\\r\\n        ( , int price, , , ) = btcPriceFeed.latestRoundData();\\r\\n        return price;\\r\\n    }\\r\\n\\r\\n    function maxAmount() internal pure returns (uint) {\\r\\n        return 100000000000;\\r\\n    }\\r\\n\\r\\n    function getTokens(address principle, uint amount) external {\\r\\n        require(block.timestamp < deadline, \\\"Deadline has passed.\\\");\\r\\n        require(principle == USDC || principle == USDT || principle == DAI || principle == wBTC, \\\"Token is not acceptable.\\\");\\r\\n        require(IERC20(principle).balanceOf(msg.sender) >= amount, \\\"Not enough token amount.\\\");\\r\\n        // Get aKeeper amount. aKeeper is 9 decimals and 1 aKeeper = $100\\r\\n        uint aKeeperAmount;\\r\\n        if (principle == DAI) {\\r\\n            aKeeperAmount = amount.div(1e11);\\r\\n        }\\r\\n        else if (principle == wBTC) {\\r\\n            aKeeperAmount = amount.mul(uint(btcAssetPrice())).div(1e9);\\r\\n        }\\r\\n        else {\\r\\n            aKeeperAmount = amount.mul(1e1);\\r\\n        }\\r\\n\\r\\n        require(maxAmount().sub(amountInfo[msg.sender]) >= aKeeperAmount, \\\"You can only get a maximum of $10000 worth of tokens.\\\");\\r\\n\\r\\n        IERC20(principle).safeTransferFrom(msg.sender, gnosisSafe, amount);\\r\\n        aKEEPER.transfer(msg.sender, aKeeperAmount);\\r\\n        amountInfo[msg.sender] = amountInfo[msg.sender].add(aKeeperAmount);\\r\\n        emit aKeeperRedeemed(msg.sender, aKeeperAmount);\\r\\n    }\\r\\n\\r\\n    function getTokensEth() external payable {\\r\\n        require(block.timestamp < deadline, \\\"Deadline has passed.\\\");\\r\\n        uint amount = msg.value;\\r\\n        // Get aKeeper amount. aKeeper is 9 decimals and 1 aKeeper = $100\\r\\n        uint aKeeperAmount = amount.mul(uint(ethAssetPrice())).div(1e19);\\r\\n        require(maxAmount().sub(amountInfo[msg.sender]) >= aKeeperAmount, \\\"You can only get a maximum of $10000 worth of tokens.\\\");\\r\\n\\r\\n        safeTransferETH(gnosisSafe, amount);\\r\\n        aKEEPER.transfer(msg.sender, aKeeperAmount);\\r\\n        amountInfo[msg.sender] = amountInfo[msg.sender].add(aKeeperAmount);\\r\\n        emit aKeeperRedeemed(msg.sender, aKeeperAmount);\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n        require(success, 'STE');\\r\\n    }\\r\\n\\r\\n    function withdraw() external onlyOwner() {\\r\\n        uint256 amount = aKEEPER.balanceOf(address(this));\\r\\n        aKEEPER.transfer(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function withdrawEth() external onlyOwner() {\\r\\n        safeTransferETH(gnosisSafe, address(this).balance);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/EthBondDepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"./interfaces/AggregateV3Interface.sol\\\";\\r\\nimport \\\"./interfaces/IWETH9.sol\\\";\\r\\nimport \\\"./interfaces/ITreasury.sol\\\";\\r\\nimport \\\"./interfaces/IStaking.sol\\\";\\r\\nimport \\\"./libraries/FixedPoint.sol\\\";\\r\\nimport \\\"./libraries/SafeMathExtended.sol\\\";\\r\\n\\r\\n\\r\\ncontract EthBondDepository is Ownable {\\r\\n    using FixedPoint for *;\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeMathExtended for uint;\\r\\n    using SafeMathExtended for uint32;\\r\\n\\r\\n    /* ======== EVENTS ======== */\\r\\n\\r\\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\\r\\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\\r\\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\\r\\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\\r\\n\\r\\n    /* ======== STATE VARIABLES ======== */\\r\\n\\r\\n    address public immutable KEEPER; // token given as payment for bond\\r\\n    address public immutable principle; // token used to create bond\\r\\n    address public immutable treasury; // mints KEEPER when receives principle\\r\\n    address public immutable DAO; // receives profit share from bond\\r\\n\\r\\n    AggregatorV3Interface internal priceFeed;\\r\\n\\r\\n    address public staking; // to auto-stake payout\\r\\n\\r\\n    Terms public terms; // stores terms for new bonds\\r\\n    Adjust public adjustment; // stores adjustment to BCV data\\r\\n\\r\\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\\r\\n\\r\\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\\r\\n    uint32 public lastDecay; // reference block for debt decay\\r\\n\\r\\n\\r\\n    /* ======== STRUCTS ======== */\\r\\n\\r\\n    // Info for creating new bonds\\r\\n    struct Terms {\\r\\n        uint32 vestingTerm; // in seconds\\r\\n        uint controlVariable; // scaling variable for price\\r\\n        uint minimumPrice; // vs principle value. 4 decimals (1500 = 0.15)\\r\\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\\r\\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\\r\\n    }\\r\\n\\r\\n    // Info for bond holder\\r\\n    struct Bond {\\r\\n        uint32 vesting; // seconds left to vest\\r\\n        uint32 lastTime; // Last interaction\\r\\n        uint payout; // KEEPER remaining to be paid\\r\\n        uint pricePaid; // In DAI, for front end viewing\\r\\n    }\\r\\n\\r\\n    // Info for incremental adjustments to control variable \\r\\n    struct Adjust {\\r\\n        bool add; // addition or subtraction\\r\\n        uint rate; // increment\\r\\n        uint target; // BCV when adjustment finished\\r\\n        uint32 buffer; // minimum length (in blocks) between adjustments\\r\\n        uint32 lastTime; // block when last adjustment made\\r\\n    }\\r\\n\\r\\n    /* ======== INITIALIZATION ======== */\\r\\n\\r\\n    constructor ( address _KEEPER, address _principle, address _staking, address _treasury, address _DAO, address _feed) {\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = _KEEPER;\\r\\n        require( _principle != address(0) );\\r\\n        principle = _principle;\\r\\n        require( _treasury != address(0) );\\r\\n        treasury = _treasury;\\r\\n        require( _DAO != address(0) );\\r\\n        DAO = _DAO;\\r\\n        require( _staking != address(0) );\\r\\n        staking = _staking;\\r\\n        require( _feed != address(0) );\\r\\n        priceFeed = AggregatorV3Interface( _feed );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice initializes bond parameters\\r\\n     *  @param _controlVariable uint\\r\\n     *  @param _vestingTerm uint\\r\\n     *  @param _minimumPrice uint\\r\\n     *  @param _maxPayout uint\\r\\n     *  @param _maxDebt uint\\r\\n     *  @param _initialDebt uint\\r\\n     */\\r\\n    function initializeBondTerms(uint _controlVariable, uint32 _vestingTerm, uint _minimumPrice, uint _maxPayout,\\r\\n                                 uint _maxDebt, uint _initialDebt) external onlyOwner() {\\r\\n        require( terms.controlVariable == 0 && terms.vestingTerm == 0, \\\"Bonds must be initialized from 0\\\" );\\r\\n        terms = Terms ({\\r\\n            controlVariable: _controlVariable,\\r\\n            vestingTerm: _vestingTerm,\\r\\n            minimumPrice: _minimumPrice,\\r\\n            maxPayout: _maxPayout,\\r\\n            maxDebt: _maxDebt\\r\\n        });\\r\\n        totalDebt = _initialDebt;\\r\\n        lastDecay = uint32(block.timestamp);\\r\\n    }\\r\\n\\r\\n\\r\\n    \\r\\n    /* ======== POLICY FUNCTIONS ======== */\\r\\n\\r\\n    enum PARAMETER { VESTING, PAYOUT, DEBT, MINPRICE }\\r\\n    /**\\r\\n     *  @notice set parameters for new bonds\\r\\n     *  @param _parameter PARAMETER\\r\\n     *  @param _input uint\\r\\n     */\\r\\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyOwner() {\\r\\n        if ( _parameter == PARAMETER.VESTING ) { // 0\\r\\n            require( _input >= 129600, \\\"Vesting must be longer than 36 hours\\\" );\\r\\n            decayDebt();\\r\\n            require( totalDebt == 0, \\\"Debt should be 0.\\\" );\\r\\n            terms.vestingTerm = uint32(_input);\\r\\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\\r\\n            require( _input <= 1000, \\\"Payout cannot be above 1 percent\\\" );\\r\\n            terms.maxPayout = _input;\\r\\n        } else if ( _parameter == PARAMETER.DEBT ) { // 2\\r\\n            terms.maxDebt = _input;\\r\\n        } else if ( _parameter == PARAMETER.MINPRICE ) { // 3\\r\\n            terms.minimumPrice = _input;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice set control variable adjustment\\r\\n     *  @param _addition bool\\r\\n     *  @param _increment uint\\r\\n     *  @param _target uint\\r\\n     *  @param _buffer uint\\r\\n     */\\r\\n    function setAdjustment ( bool _addition, uint _increment, uint _target, uint32 _buffer ) external onlyOwner() {\\r\\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \\\"Increment too large\\\" );\\r\\n\\r\\n        adjustment = Adjust({\\r\\n            add: _addition,\\r\\n            rate: _increment,\\r\\n            target: _target,\\r\\n            buffer: _buffer,\\r\\n            lastTime: uint32(block.timestamp)\\r\\n        });\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice set contract for auto stake\\r\\n     *  @param _staking address\\r\\n     */\\r\\n    // function setStaking( address _staking ) external onlyOwner() {\\r\\n    //     require( _staking != address(0) );\\r\\n    //     staking = _staking;\\r\\n    // }\\r\\n\\r\\n\\r\\n    /* ======== USER FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice deposit bond\\r\\n     *  @param _amount uint\\r\\n     *  @param _maxPrice uint\\r\\n     *  @param _depositor address\\r\\n     *  @return uint\\r\\n     */\\r\\n    function deposit( uint _amount, uint _maxPrice, address _depositor) external payable returns ( uint ) {\\r\\n        require( _depositor != address(0), \\\"Invalid address\\\" );\\r\\n        require( msg.value == 0 || _amount == msg.value, \\\"Amount should be equal to ETH transferred\\\");\\r\\n        decayDebt();\\r\\n        \\r\\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\\r\\n        uint nativePrice = _bondPrice();\\r\\n\\r\\n        require( _maxPrice >= nativePrice, \\\"Slippage limit: more than max price\\\" ); // slippage protection\\r\\n\\r\\n        uint value = ITreasury( treasury ).valueOfToken( principle, _amount );\\r\\n        uint payout = payoutFor( value ); // payout to bonder is computed\\r\\n\\r\\n        require( payout >= 10000000, \\\"Bond too small\\\" ); // must be > 0.01 KEEPER ( underflow protection )\\r\\n        require( payout <= maxPayout(), \\\"Bond too large\\\"); // size protection because there is no slippage\\r\\n\\r\\n        /**\\r\\n            asset carries risk and is not minted against\\r\\n            asset transfered to treasury and rewards minted as payout\\r\\n         */\\r\\n        if (address(this).balance >= _amount) {\\r\\n            // pay with WETH9\\r\\n            IWETH9(principle).deposit{value: _amount}(); // wrap only what is needed to pay\\r\\n            IWETH9(principle).transfer(treasury, _amount);\\r\\n        } else {\\r\\n            IERC20( principle ).safeTransferFrom( msg.sender, treasury, _amount );\\r\\n        }\\r\\n\\r\\n        ITreasury( treasury ).mintRewards( address(this), payout );\\r\\n        \\r\\n        // total debt is increased\\r\\n        totalDebt = totalDebt.add( value ); \\r\\n        require( totalDebt <= terms.maxDebt, \\\"Max capacity reached\\\" );\\r\\n                \\r\\n        // depositor info is stored\\r\\n        bondInfo[ _depositor ] = Bond({ \\r\\n            payout: bondInfo[ _depositor ].payout.add( payout ),\\r\\n            vesting: terms.vestingTerm,\\r\\n            lastTime: uint32(block.timestamp),\\r\\n            pricePaid: priceInUSD\\r\\n        });\\r\\n\\r\\n        // indexed events are emitted\\r\\n        emit BondCreated( _amount, payout, block.timestamp.add( terms.vestingTerm ), priceInUSD );\\r\\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\\r\\n\\r\\n        adjust(); // control variable is adjusted\\r\\n        refundETH(); //refund user if needed\\r\\n        return payout; \\r\\n    }\\r\\n\\r\\n    /** \\r\\n     *  @notice redeem bond for user\\r\\n     *  @param _recipient address\\r\\n     *  @param _stake bool\\r\\n     *  @return uint\\r\\n     */ \\r\\n    function redeem( address _recipient, bool _stake, bool _wrap ) external returns ( uint ) {        \\r\\n        Bond memory info = bondInfo[ _recipient ];\\r\\n        uint percentVested = percentVestedFor( _recipient ); // (seconds since last interaction / vesting term remaining)\\r\\n\\r\\n        if ( percentVested >= 10000 ) { // if fully vested\\r\\n            delete bondInfo[ _recipient ]; // delete user info\\r\\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\\r\\n            return stakeOrSend( _recipient, _stake, _wrap, info.payout ); // pay user everything due\\r\\n\\r\\n        } else { // if unfinished\\r\\n            // calculate payout vested\\r\\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\\r\\n\\r\\n            // store updated deposit info\\r\\n            bondInfo[ _recipient ] = Bond({\\r\\n                payout: info.payout.sub( payout ),\\r\\n                vesting: info.vesting.sub32( uint32(block.timestamp).sub32( info.lastTime ) ),\\r\\n                lastTime: uint32(block.timestamp),\\r\\n                pricePaid: info.pricePaid\\r\\n            });\\r\\n\\r\\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\\r\\n            return stakeOrSend( _recipient, _stake, _wrap, payout );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    \\r\\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice allow user to stake payout automatically\\r\\n     *  @param _stake bool\\r\\n     *  @param _amount uint\\r\\n     *  @return uint\\r\\n     */\\r\\n    function stakeOrSend( address _recipient, bool _stake, bool _wrap, uint _amount ) internal returns ( uint ) {\\r\\n        if ( !_stake ) { // if user does not want to stake\\r\\n            IERC20( KEEPER ).transfer( _recipient, _amount ); // send payout\\r\\n        } else { // if user wants to stake\\r\\n            IERC20( KEEPER ).approve( staking, _amount );\\r\\n            IStaking( staking ).stake( _amount, _recipient, _wrap );\\r\\n        }\\r\\n        return _amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice makes incremental adjustment to control variable\\r\\n     */\\r\\n    function adjust() internal {\\r\\n        uint timeCanAdjust = adjustment.lastTime.add( adjustment.buffer );\\r\\n        if( adjustment.rate != 0 && block.timestamp >= timeCanAdjust ) {\\r\\n            uint initial = terms.controlVariable;\\r\\n            if ( adjustment.add ) {\\r\\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\\r\\n                if ( terms.controlVariable >= adjustment.target ) {\\r\\n                    adjustment.rate = 0;\\r\\n                }\\r\\n            } else {\\r\\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\\r\\n                if ( terms.controlVariable <= adjustment.target || terms.controlVariable < adjustment.rate ) {\\r\\n                    adjustment.rate = 0;\\r\\n                }\\r\\n            }\\r\\n            adjustment.lastTime = uint32(block.timestamp);\\r\\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice reduce total debt\\r\\n     */\\r\\n    function decayDebt() internal {\\r\\n        totalDebt = totalDebt.sub( debtDecay() );\\r\\n        lastDecay = uint32(block.timestamp);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    /* ======== VIEW FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice determine maximum bond size\\r\\n     *  @return uint\\r\\n     */\\r\\n    function maxPayout() public view returns ( uint ) {\\r\\n        return IERC20( KEEPER ).totalSupply().mul( terms.maxPayout ).div( 100000 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate interest due for new bond\\r\\n     *  @param _value uint\\r\\n     *  @return uint\\r\\n     */\\r\\n    function payoutFor( uint _value ) public view returns ( uint ) {\\r\\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e14 );\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current bond premium\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function bondPrice() public view returns ( uint price_ ) {        \\r\\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\\r\\n        if ( price_ < terms.minimumPrice ) {\\r\\n            price_ = terms.minimumPrice;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current bond price and remove floor if above\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function _bondPrice() internal returns ( uint price_ ) {\\r\\n        price_ = terms.controlVariable.mul( debtRatio() ).div( 1e5 );\\r\\n        if ( price_ < terms.minimumPrice ) {\\r\\n            price_ = terms.minimumPrice;        \\r\\n        } else if ( terms.minimumPrice != 0 ) {\\r\\n            terms.minimumPrice = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice get asset price from chainlink\\r\\n     */\\r\\n    function assetPrice() public view returns (int) {\\r\\n        ( , int price, , , ) = priceFeed.latestRoundData();\\r\\n        return price;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice converts bond price to DAI value\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function bondPriceInUSD() public view returns ( uint price_ ) {\\r\\n        price_ = bondPrice().mul( uint( assetPrice() ) ).mul( 1e6 );\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current ratio of debt to KEEPER supply\\r\\n     *  @return debtRatio_ uint\\r\\n     */\\r\\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \\r\\n        uint supply = IERC20( KEEPER ).totalSupply();\\r\\n        debtRatio_ = FixedPoint.fraction( \\r\\n            currentDebt().mul( 1e9 ), \\r\\n            supply\\r\\n        ).decode112with18().div( 1e18 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice debt ratio in same terms as reserve bonds\\r\\n     *  @return uint\\r\\n     */\\r\\n    function standardizedDebtRatio() external view returns ( uint ) {\\r\\n        return debtRatio().mul( uint( assetPrice() ) ).div( 1e8 ); // ETH feed is 8 decimals\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate debt factoring in decay\\r\\n     *  @return uint\\r\\n     */\\r\\n    function currentDebt() public view returns ( uint ) {\\r\\n        return totalDebt.sub( debtDecay() );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice amount to decay total debt by\\r\\n     *  @return decay_ uint\\r\\n     */\\r\\n    function debtDecay() public view returns ( uint decay_ ) {\\r\\n        uint32 timeSinceLast = uint32(block.timestamp).sub32( lastDecay );\\r\\n        decay_ = totalDebt.mul( timeSinceLast ).div( terms.vestingTerm );\\r\\n        if ( decay_ > totalDebt ) {\\r\\n            decay_ = totalDebt;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate how far into vesting a depositor is\\r\\n     *  @param _depositor address\\r\\n     *  @return percentVested_ uint\\r\\n     */\\r\\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\\r\\n        Bond memory bond = bondInfo[ _depositor ];\\r\\n        uint timeSinceLast = uint32(block.timestamp).sub( bond.lastTime );\\r\\n        uint vesting = bond.vesting;\\r\\n\\r\\n        if ( vesting > 0 ) {\\r\\n            percentVested_ = timeSinceLast.mul( 10000 ).div( vesting );\\r\\n        } else {\\r\\n            percentVested_ = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate amount of KEEPER available for claim by depositor\\r\\n     *  @param _depositor address\\r\\n     *  @return pendingPayout_ uint\\r\\n     */\\r\\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\\r\\n        uint percentVested = percentVestedFor( _depositor );\\r\\n        uint payout = bondInfo[ _depositor ].payout;\\r\\n\\r\\n        if ( percentVested >= 10000 ) {\\r\\n            pendingPayout_ = payout;\\r\\n        } else {\\r\\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    /* ======= AUXILLIARY ======= */\\r\\n\\r\\n    /**\\r\\n     *  @notice allow anyone to send lost tokens (excluding principle or KEEPER) to the DAO\\r\\n     *  @return bool\\r\\n     */\\r\\n    function recoverLostToken( address _token ) external returns ( bool ) {\\r\\n        require( _token != KEEPER );\\r\\n        require( _token != principle );\\r\\n        IERC20( _token ).safeTransfer( DAO, IERC20( _token ).balanceOf( address(this) ) );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function refundETH() internal {\\r\\n        if (address(this).balance > 0) safeTransferETH(DAO, address(this).balance);\\r\\n    }\\r\\n\\r\\n    /// @notice Transfers ETH to the recipient address\\r\\n    /// @dev Fails with `STE`\\r\\n    /// @param to The destination of the transfer\\r\\n    /// @param value The value to be transferred\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n        require(success, 'STE');\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/other/aKeeperAirdrop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\n\\r\\ncontract aKeeperAirdrop is Ownable {\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    IERC20 public aKEEPER;\\r\\n    IERC20 public USDC;\\r\\n    address public gnosisSafe;\\r\\n    \\r\\n    constructor(address _aKEEPER, address _USDC, address _gnosisSafe) {\\r\\n        require( _aKEEPER != address(0) );\\r\\n        require( _USDC != address(0) );\\r\\n        aKEEPER = IERC20(_aKEEPER);\\r\\n        USDC = IERC20(_USDC);\\r\\n        gnosisSafe = _gnosisSafe;\\r\\n    }\\r\\n\\r\\n    receive() external payable { }\\r\\n\\r\\n    function airdropTokens(address[] calldata _recipients, uint[] calldata _amounts) external onlyOwner() {\\r\\n        for (uint i=0; i < _recipients.length; i++) {\\r\\n            aKEEPER.transfer(_recipients[i], _amounts[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function refundUsdcTokens(address[] calldata _recipients, uint[] calldata _amounts) external onlyOwner() {\\r\\n        for (uint i=0; i < _recipients.length; i++) {\\r\\n            USDC.transfer(_recipients[i], _amounts[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function refundEth(address[] calldata _recipients, uint[] calldata _amounts) external onlyOwner() {\\r\\n        for (uint i=0; i < _recipients.length; i++) {\\r\\n            safeTransferETH(_recipients[i], _amounts[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n        require(success, 'STE');\\r\\n    }\\r\\n\\r\\n    function withdraw() external onlyOwner() {\\r\\n        uint256 amount = aKEEPER.balanceOf(address(this));\\r\\n        aKEEPER.transfer(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function withdrawUsdc() external onlyOwner() {\\r\\n        uint256 amount = USDC.balanceOf(address(this));\\r\\n        USDC.transfer(gnosisSafe, amount);\\r\\n    }\\r\\n\\r\\n    function withdrawEth() external onlyOwner() {\\r\\n        safeTransferETH(gnosisSafe, address(this).balance);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/new/Treasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"./interfaces/AggregateV3Interface.sol\\\";\\r\\nimport \\\"./interfaces/ILPCalculator.sol\\\";\\r\\nimport \\\"./interfaces/IERC20Extended.sol\\\";\\r\\nimport \\\"./interfaces/IKeplerERC20.sol\\\";\\r\\nimport \\\"./interfaces/ISPV.sol\\\";\\r\\nimport \\\"./interfaces/IStaking.sol\\\";\\r\\n\\r\\n\\r\\ncontract Treasury is Ownable {\\r\\n    \\r\\n    using SafeERC20 for IERC20Extended;\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    event Deposit( address indexed token, uint amount, uint value );\\r\\n    event DepositEth( uint amount, uint value );\\r\\n    event Sell( address indexed token, uint indexed amount, uint indexed price );\\r\\n    event SellEth( uint indexed amount, uint indexed price );\\r\\n    event ReservesWithdrawn( address indexed caller, address indexed token, uint amount );\\r\\n    event ReservesUpdated( uint indexed totalReserves );\\r\\n    event ReservesAudited( uint indexed totalReserves );\\r\\n    event ChangeActivated( MANAGING indexed managing, address activated, bool result );\\r\\n    event SPVUpdated( address indexed spv );\\r\\n\\r\\n    enum MANAGING { RESERVETOKEN, LIQUIDITYTOKEN, VARIABLETOKEN }\\r\\n    struct PriceFeed {\\r\\n        address feed;\\r\\n        uint decimals;\\r\\n    }\\r\\n\\r\\n    IKeplerERC20 immutable KEEPER;\\r\\n    uint public constant keeperDecimals = 9;\\r\\n    uint public immutable priceAdjust;  // 4 decimals. 1000 = 0.1\\r\\n\\r\\n    address[] public reserveTokens;\\r\\n    mapping( address => bool ) public isReserveToken;\\r\\n\\r\\n    address[] public variableTokens;\\r\\n    mapping( address => bool ) public isVariableToken;\\r\\n\\r\\n    address[] public liquidityTokens;\\r\\n    mapping( address => bool ) public isLiquidityToken;\\r\\n\\r\\n    mapping( address => address ) public lpCalculator; // bond calculator for liquidity token\\r\\n    mapping( address => PriceFeed ) public priceFeeds; // price feeds for variable token\\r\\n\\r\\n    uint public totalReserves;\\r\\n    uint public spvDebt;\\r\\n    uint public daoDebt;\\r\\n    uint public ownerDebt;\\r\\n    uint public reserveLastAudited;\\r\\n    AggregatorV3Interface internal ethPriceFeed;\\r\\n\\r\\n    address public staking;\\r\\n    address public vesting;\\r\\n    address public SPV;\\r\\n    address public immutable DAO;\\r\\n\\r\\n    uint public daoRatio;   // 4 decimals. 1000 = 0.1\\r\\n    uint public spvRatio;   // 4 decimals. 7000 = 0.7\\r\\n    uint public vestingRatio;   // 4 decimals. 1000 = 0.1\\r\\n    uint public stakeRatio;    // 4 decimals. 9000 = 0.9\\r\\n    uint public lcv;    // 4 decimals. 1000 = 0.1\\r\\n    \\r\\n    uint public keeperSold;\\r\\n    uint public initPrice;  // To deposit initial reserves when price is undefined (Keeper supply = 0)\\r\\n\\r\\n\\r\\n    constructor (address _KEEPER, address _USDC, address _USDT, address _DAI, address _DAO, address _vesting, address _ethPriceFeed, uint _priceAdjust, uint _initPrice) {\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = IKeplerERC20(_KEEPER);\\r\\n        require( _DAO != address(0) );\\r\\n        DAO = _DAO;\\r\\n        require( _vesting != address(0) );\\r\\n        vesting = _vesting;\\r\\n\\r\\n        isReserveToken[ _USDC] = true;\\r\\n        reserveTokens.push( _USDC );\\r\\n        isReserveToken[ _USDT] = true;\\r\\n        reserveTokens.push( _USDT );\\r\\n        isReserveToken[ _DAI ] = true;\\r\\n        reserveTokens.push( _DAI );\\r\\n\\r\\n        ethPriceFeed = AggregatorV3Interface( _ethPriceFeed );\\r\\n        priceAdjust = _priceAdjust;\\r\\n        initPrice = _initPrice;\\r\\n    }\\r\\n\\r\\n\\r\\n    function treasuryInitialized() external onlyOwner() {\\r\\n        initPrice = 0;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setSPV(address _SPV) external onlyOwner() {\\r\\n        require( _SPV != address(0), \\\"Cannot be 0\\\");\\r\\n        SPV = _SPV;\\r\\n        emit SPVUpdated( SPV );\\r\\n    }\\r\\n\\r\\n\\r\\n    function setVesting(address _vesting) external onlyOwner() {\\r\\n        require( _vesting != address(0), \\\"Cannot be 0\\\");\\r\\n        vesting = _vesting;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setStaking(address _staking) external onlyOwner() {\\r\\n        require( _staking != address(0), \\\"Cannot be 0\\\");\\r\\n        staking = _staking;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setLcv(uint _lcv) external onlyOwner() {\\r\\n        require( lcv == 0 || _lcv <= lcv.mul(3).div(2), \\\"LCV cannot change sharp\\\" );\\r\\n        lcv = _lcv;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setTreasuryRatio(uint _daoRatio, uint _spvRatio, uint _vestingRatio, uint _stakeRatio) external onlyOwner() {\\r\\n        require( _daoRatio <= 1000, \\\"DAO more than 10%\\\" );\\r\\n        require( _spvRatio <= 7000, \\\"SPV more than 70%\\\" );\\r\\n        require( _vestingRatio <= 2000, \\\"Vesting more than 20%\\\" );\\r\\n        require( _stakeRatio >= 1000 && _stakeRatio <= 10000, \\\"Stake ratio error\\\" );\\r\\n        daoRatio = _daoRatio;\\r\\n        spvRatio = _spvRatio;\\r\\n        vestingRatio = _vestingRatio;\\r\\n        stakeRatio = _stakeRatio;\\r\\n    }\\r\\n\\r\\n\\r\\n    function getPremium(uint _price) public view returns (uint) {\\r\\n        return _price.mul( lcv ).mul( keeperSold ).div( KEEPER.totalSupply().sub( KEEPER.balanceOf(vesting) ) ).div( 1e4 );\\r\\n    }\\r\\n\\r\\n\\r\\n    function getPrice() public view returns ( uint ) {\\r\\n        if (initPrice != 0) {\\r\\n            return initPrice;\\r\\n        } else {\\r\\n            return totalReserves.add(ownerDebt).add( ISPV(SPV).totalValue() ).add( priceAdjust ).mul(10 ** keeperDecimals).div( KEEPER.totalSupply().sub( KEEPER.balanceOf(vesting) ) );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function ethAssetPrice() public view returns (uint) {\\r\\n        ( , int price, , , ) = ethPriceFeed.latestRoundData();\\r\\n        return uint(price).mul( 10 ** keeperDecimals ).div( 1e8 );\\r\\n    }\\r\\n\\r\\n\\r\\n    function variableAssetPrice(address _address, uint _decimals) public view returns (uint) {\\r\\n        ( , int price, , , ) = AggregatorV3Interface(_address).latestRoundData();\\r\\n        return uint(price).mul( 10 ** keeperDecimals ).div( 10 ** _decimals );\\r\\n    }\\r\\n\\r\\n\\r\\n    function EthToUSD( uint _amount ) internal view returns ( uint ) {\\r\\n        return _amount.mul( ethAssetPrice() ).div( 1e18 );\\r\\n    }\\r\\n\\r\\n\\r\\n    function auditTotalReserves() public {\\r\\n        uint reserves;\\r\\n        for( uint i = 0; i < reserveTokens.length; i++ ) {\\r\\n            reserves = reserves.add ( \\r\\n                valueOfToken( reserveTokens[ i ], IERC20Extended( reserveTokens[ i ] ).balanceOf( address(this) ) )\\r\\n            );\\r\\n        }\\r\\n        for( uint i = 0; i < liquidityTokens.length; i++ ) {\\r\\n            reserves = reserves.add (\\r\\n                valueOfToken( liquidityTokens[ i ], IERC20Extended( liquidityTokens[ i ] ).balanceOf( address(this) ) )\\r\\n            );\\r\\n        }\\r\\n        for( uint i = 0; i < variableTokens.length; i++ ) {\\r\\n            reserves = reserves.add (\\r\\n                valueOfToken( variableTokens[ i ], IERC20Extended( variableTokens[ i ] ).balanceOf( address(this) ) )\\r\\n            );\\r\\n        }\\r\\n        reserves = reserves.add( EthToUSD(address(this).balance) );\\r\\n        totalReserves = reserves;\\r\\n        reserveLastAudited = block.timestamp;\\r\\n        emit ReservesUpdated( reserves );\\r\\n        emit ReservesAudited( reserves );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice allow depositing an asset for KEEPER\\r\\n        @param _amount uint\\r\\n        @param _token address\\r\\n        @return send_ uint\\r\\n     */\\r\\n    function deposit( uint _amount, address _token, bool _stake ) external returns ( uint send_ ) {\\r\\n        require( isReserveToken[ _token ] || isLiquidityToken[ _token ] || isVariableToken[ _token ], \\\"Not accepted\\\" );\\r\\n        IERC20Extended( _token ).safeTransferFrom( msg.sender, address(this), _amount );\\r\\n\\r\\n        // uint daoAmount = _amount.mul(daoRatio).div(1e4);\\r\\n        // IERC20Extended( _token ).safeTransfer( DAO, daoAmount );\\r\\n        \\r\\n        uint value = valueOfToken(_token, _amount);\\r\\n        // uint daoValue = value.mul(daoRatio).div(1e4);\\r\\n        // mint KEEPER needed and store amount of rewards for distribution\\r\\n\\r\\n        totalReserves = totalReserves.add( value );\\r\\n        send_ = sendOrStake(msg.sender, value, _stake);\\r\\n\\r\\n        emit ReservesUpdated( totalReserves );\\r\\n        emit Deposit( _token, _amount, value );\\r\\n    }\\r\\n\\r\\n\\r\\n    function depositEth( uint _amount, bool _stake ) external payable returns ( uint send_ ) {\\r\\n        require( _amount == msg.value, \\\"Amount should be equal to ETH transferred\\\");\\r\\n\\r\\n        // uint daoAmount = _amount.mul(daoRatio).div(1e4);\\r\\n        // safeTransferETH(DAO, daoAmount);\\r\\n\\r\\n        uint value = EthToUSD( _amount );\\r\\n        // uint daoValue = value.mul(daoRatio).div(1e4);\\r\\n        // mint KEEPER needed and store amount of rewards for distribution\\r\\n        totalReserves = totalReserves.add( value );\\r\\n        send_ = sendOrStake(msg.sender, value, _stake);\\r\\n\\r\\n        emit ReservesUpdated( totalReserves );\\r\\n        emit DepositEth( _amount, value );\\r\\n    }\\r\\n\\r\\n\\r\\n    function sendOrStake(address _recipient, uint _value, bool _stake) internal returns (uint send_) {\\r\\n        send_ = _value.mul( 10 ** keeperDecimals ).div( getPrice() );\\r\\n        if ( _stake ) {\\r\\n            KEEPER.mint( address(this), send_ );\\r\\n            KEEPER.approve( staking, send_ );\\r\\n            IStaking( staking ).stake( send_, _recipient, false );\\r\\n        } else {\\r\\n            KEEPER.mint( _recipient, send_ );\\r\\n        }\\r\\n        uint vestingAmount = send_.mul(vestingRatio).div(1e4);\\r\\n        KEEPER.mint( vesting, vestingAmount );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice allow to burn KEEPER for reserves\\r\\n        @param _amount uint of keeper\\r\\n        @param _token address\\r\\n     */\\r\\n    function sell( uint _amount, address _token ) external {\\r\\n        require( isReserveToken[ _token ], \\\"Not accepted\\\" ); // Only reserves can be used for redemptions\\r\\n\\r\\n        (uint price, uint premium, uint sellPrice) = sellKeeperBurn(msg.sender, _amount);\\r\\n\\r\\n        uint actualPrice = price.sub( premium.mul(stakeRatio).div(1e4) );\\r\\n        uint reserveLoss = _amount.mul( actualPrice ).div( 10 ** keeperDecimals );\\r\\n        uint tokenAmount = reserveLoss.mul( 10 ** IERC20Extended( _token ).decimals() ).div( 10 ** keeperDecimals );\\r\\n        totalReserves = totalReserves.sub( reserveLoss );\\r\\n        emit ReservesUpdated( totalReserves );\\r\\n\\r\\n        uint sellAmount = tokenAmount.mul(sellPrice).div(actualPrice);\\r\\n        uint daoAmount = tokenAmount.sub(sellAmount);\\r\\n        IERC20Extended(_token).safeTransfer(msg.sender, sellAmount);\\r\\n        IERC20Extended(_token).safeTransfer(DAO, daoAmount);\\r\\n\\r\\n        emit Sell( _token, _amount, sellPrice );\\r\\n    }\\r\\n\\r\\n\\r\\n    function sellEth( uint _amount ) external {\\r\\n        (uint price, uint premium, uint sellPrice) = sellKeeperBurn(msg.sender, _amount);\\r\\n\\r\\n        uint actualPrice = price.sub( premium.mul(stakeRatio).div(1e4) );\\r\\n        uint reserveLoss = _amount.mul( actualPrice ).div( 10 ** keeperDecimals );\\r\\n        uint tokenAmount = reserveLoss.mul(10 ** 18).div( ethAssetPrice() );\\r\\n        totalReserves = totalReserves.sub( reserveLoss );\\r\\n        emit ReservesUpdated( totalReserves );\\r\\n\\r\\n        uint sellAmount = tokenAmount.mul(sellPrice).div(actualPrice);\\r\\n        uint daoAmount = tokenAmount.sub(sellAmount);\\r\\n        safeTransferETH(msg.sender, sellAmount);\\r\\n        safeTransferETH(DAO, daoAmount);\\r\\n\\r\\n        emit SellEth( _amount, sellPrice );\\r\\n    }\\r\\n\\r\\n\\r\\n    function sellKeeperBurn(address _sender, uint _amount) internal returns (uint price, uint premium, uint sellPrice) {\\r\\n        price = getPrice();\\r\\n        premium = getPremium(price);\\r\\n        sellPrice = price.sub(premium);\\r\\n\\r\\n        KEEPER.burnFrom( _sender, _amount );\\r\\n        keeperSold = keeperSold.add( _amount );\\r\\n        uint stakeRewards = _amount.mul(stakeRatio).mul(premium).div(price).div(1e4);\\r\\n        KEEPER.mint( address(this), stakeRewards );\\r\\n        KEEPER.approve( staking, stakeRewards );\\r\\n        IStaking( staking ).addRebaseReward( stakeRewards );\\r\\n    }\\r\\n\\r\\n\\r\\n    function unstakeMint(uint _amount) external {\\r\\n        require( msg.sender == staking, \\\"Not allowed.\\\" );\\r\\n        KEEPER.mint(msg.sender, _amount);\\r\\n    }\\r\\n\\r\\n\\r\\n    function initDeposit( address _token, uint _amount ) external payable onlyOwner() {\\r\\n        require( initPrice != 0, \\\"Already initialized\\\" );\\r\\n        uint value;\\r\\n        if ( _token == address(0) && msg.value != 0 ) {\\r\\n            require( _amount == msg.value, \\\"Amount mismatch\\\" );\\r\\n            value = EthToUSD( _amount );\\r\\n        } else {\\r\\n            IERC20Extended( _token ).safeTransferFrom( msg.sender, address(this), _amount );\\r\\n            value = valueOfToken(_token, _amount);\\r\\n        }\\r\\n        totalReserves = totalReserves.add( value );\\r\\n        uint send_ = value.mul( 10 ** keeperDecimals ).div( getPrice() );\\r\\n        KEEPER.mint( msg.sender, send_ );\\r\\n    } \\r\\n\\r\\n    /**\\r\\n        @notice allow owner multisig to withdraw assets on debt (for safe investments)\\r\\n        @param _token address\\r\\n        @param _amount uint\\r\\n     */\\r\\n    function incurDebt( address _token, uint _amount, bool isEth ) external onlyOwner() {\\r\\n        uint value;\\r\\n        if ( _token == address(0) && isEth ) {\\r\\n            safeTransferETH(msg.sender, _amount);\\r\\n            value = EthToUSD( _amount );\\r\\n        } else {\\r\\n            IERC20Extended( _token ).safeTransfer( msg.sender, _amount );\\r\\n            value = valueOfToken(_token, _amount);\\r\\n        }\\r\\n        totalReserves = totalReserves.sub( value );\\r\\n        ownerDebt = ownerDebt.add(value);\\r\\n        emit ReservesUpdated( totalReserves );\\r\\n        emit ReservesWithdrawn( msg.sender, _token, _amount );\\r\\n    }\\r\\n\\r\\n\\r\\n    function repayDebt( address _token, uint _amount, bool isEth ) external payable onlyOwner() {\\r\\n        uint value;\\r\\n        if ( isEth ) {\\r\\n            require( msg.value == _amount, \\\"Amount mismatch\\\" );\\r\\n            value = EthToUSD( _amount );\\r\\n        } else {\\r\\n            require( isReserveToken[ _token ] || isLiquidityToken[ _token ] || isVariableToken[ _token ], \\\"Not accepted\\\" );\\r\\n            IERC20Extended( _token ).safeTransferFrom( msg.sender, address(this), _amount );\\r\\n            value = valueOfToken(_token, _amount);\\r\\n        }\\r\\n        totalReserves = totalReserves.add( value );\\r\\n        if ( value > ownerDebt ) {\\r\\n            uint daoProfit = _amount.mul( daoRatio ).mul( value.sub(ownerDebt) ).div( value ).div(1e4);\\r\\n            if ( isEth ) {\\r\\n                safeTransferETH( DAO, daoProfit );\\r\\n            } else {\\r\\n                IERC20Extended( _token ).safeTransfer( DAO, daoProfit );\\r\\n            }\\r\\n            value = ownerDebt;\\r\\n        }\\r\\n        ownerDebt = ownerDebt.sub(value);\\r\\n        emit ReservesUpdated( totalReserves );\\r\\n    }\\r\\n\\r\\n\\r\\n    function SPVDeposit( address _token, uint _amount ) external {\\r\\n        require( isReserveToken[ _token ] || isLiquidityToken[ _token ] || isVariableToken[ _token ], \\\"Not accepted\\\" );\\r\\n        IERC20Extended( _token ).safeTransferFrom( msg.sender, address(this), _amount );\\r\\n        uint value = valueOfToken(_token, _amount);\\r\\n        totalReserves = totalReserves.add( value );\\r\\n        if ( value > spvDebt ) {\\r\\n            value = spvDebt;\\r\\n        }\\r\\n        spvDebt = spvDebt.sub(value);\\r\\n        emit ReservesUpdated( totalReserves );\\r\\n    }\\r\\n\\r\\n\\r\\n    function SPVWithdraw( address _token, uint _amount ) external {\\r\\n        require( msg.sender == SPV, \\\"Only SPV\\\" );\\r\\n        address SPVWallet = ISPV( SPV ).SPVWallet();\\r\\n        uint value = valueOfToken(_token, _amount);\\r\\n        uint totalValue = totalReserves.add( ISPV(SPV).totalValue() ).add( ownerDebt );\\r\\n        require( spvDebt.add(value) < totalValue.mul(spvRatio).div(1e4), \\\"Debt exceeded\\\" );\\r\\n        spvDebt = spvDebt.add(value);\\r\\n        totalReserves = totalReserves.sub( value );\\r\\n        emit ReservesUpdated( totalReserves );\\r\\n        IERC20Extended( _token ).safeTransfer( SPVWallet, _amount );\\r\\n    }\\r\\n\\r\\n\\r\\n    function DAOWithdraw( address _token, uint _amount, bool isEth ) external {\\r\\n        require( msg.sender == DAO, \\\"Only DAO Allowed\\\" );\\r\\n        uint value;\\r\\n        if ( _token == address(0) && isEth ) {\\r\\n            value = EthToUSD( _amount );\\r\\n        } else {\\r\\n            value = valueOfToken(_token, _amount);\\r\\n        }\\r\\n        uint daoProfit = ISPV( SPV ).totalProfit().mul( daoRatio ).div(1e4);\\r\\n        require( daoDebt.add(value) <= daoProfit, \\\"Too much\\\" );\\r\\n        if ( _token == address(0) && isEth ) {\\r\\n            safeTransferETH(DAO, _amount);\\r\\n        } else {\\r\\n            IERC20Extended( _token ).safeTransfer( DAO, _amount );\\r\\n        }\\r\\n        totalReserves = totalReserves.sub( value );\\r\\n        daoDebt = daoDebt.add(value);\\r\\n        emit ReservesUpdated( totalReserves );\\r\\n        emit ReservesWithdrawn( DAO, _token, _amount );\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n        @notice returns KEEPER valuation of asset\\r\\n        @param _token address\\r\\n        @param _amount uint\\r\\n        @return value_ uint\\r\\n     */\\r\\n    function valueOfToken( address _token, uint _amount ) public view returns ( uint value_ ) {\\r\\n        if ( isReserveToken[ _token ] ) {\\r\\n            // convert amount to match KEEPER decimals\\r\\n            value_ = _amount.mul( 10 ** keeperDecimals ).div( 10 ** IERC20Extended( _token ).decimals() );\\r\\n        } else if ( isLiquidityToken[ _token ] ) {\\r\\n            value_ = ILPCalculator( lpCalculator[ _token ] ).valuationUSD( _token, _amount );\\r\\n        } else if ( isVariableToken[ _token ] ) {\\r\\n            value_ = _amount.mul(variableAssetPrice( priceFeeds[_token].feed, priceFeeds[_token].decimals )).div( 10 ** IERC20Extended( _token ).decimals() );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n        @notice verify queue then set boolean in mapping\\r\\n        @param _managing MANAGING\\r\\n        @param _address address\\r\\n        @param _calculatorFeed address\\r\\n        @return bool\\r\\n     */\\r\\n    function toggle( MANAGING _managing, address _address, address _calculatorFeed, uint decimals ) external onlyOwner() returns ( bool ) {\\r\\n        require( _address != address(0) );\\r\\n        bool result;\\r\\n        if ( _managing == MANAGING.RESERVETOKEN ) { // 0\\r\\n            if( !listContains( reserveTokens, _address ) ) {\\r\\n                reserveTokens.push( _address );\\r\\n            }\\r\\n            result = !isReserveToken[ _address ];\\r\\n            isReserveToken[ _address ] = result;\\r\\n\\r\\n        } else if ( _managing == MANAGING.LIQUIDITYTOKEN ) { // 1\\r\\n            if( !listContains( liquidityTokens, _address ) ) {\\r\\n                liquidityTokens.push( _address );\\r\\n            }\\r\\n            result = !isLiquidityToken[ _address ];\\r\\n            isLiquidityToken[ _address ] = result;\\r\\n            lpCalculator[ _address ] = _calculatorFeed;\\r\\n\\r\\n        } else if ( _managing == MANAGING.VARIABLETOKEN ) { // 2\\r\\n            if( !listContains( variableTokens, _address ) ) {\\r\\n                variableTokens.push( _address );\\r\\n            }\\r\\n            result = !isVariableToken[ _address ];\\r\\n            isVariableToken[ _address ] = result;\\r\\n            priceFeeds[ _address ] = PriceFeed({\\r\\n                feed: _calculatorFeed,\\r\\n                decimals: decimals\\r\\n            });\\r\\n\\r\\n        } else return false;\\r\\n\\r\\n        emit ChangeActivated( _managing, _address, result );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n        @notice checks array to ensure against duplicate\\r\\n        @param _list address[]\\r\\n        @param _token address\\r\\n        @return bool\\r\\n     */\\r\\n    function listContains( address[] storage _list, address _token ) internal view returns ( bool ) {\\r\\n        for( uint i = 0; i < _list.length; i++ ) {\\r\\n            if( _list[ i ] == _token ) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n        require(success, 'STE');\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/new/interfaces/AggregateV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.7.5;\\r\\n\\r\\ninterface AggregatorV3Interface {\\r\\n  function decimals() external view returns (uint8);\\r\\n\\r\\n  function description() external view returns (string memory);\\r\\n\\r\\n  function version() external view returns (uint256);\\r\\n\\r\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\r\\n  // if they do not have data to report, instead of returning unset values\\r\\n  // which could be misinterpreted as actual reported values.\\r\\n  function getRoundData(uint80 _roundId)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n\\r\\n  function latestRoundData()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n}\"\r\n    },\r\n    \"contracts/new/interfaces/ILPCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\ninterface ILPCalculator {\\r\\n    function valuationUSD( address _token, uint _amount ) external view returns ( uint );\\r\\n}\"\r\n    },\r\n    \"contracts/new/interfaces/IERC20Extended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IERC20Extended is IERC20 {\\r\\n    function decimals() external view returns (uint8);\\r\\n}\"\r\n    },\r\n    \"contracts/new/interfaces/IKeplerERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface IKeplerERC20 is IERC20 {\\r\\n\\r\\n  function decimals() external view returns (uint8);\\r\\n\\r\\n  function mint(address account_, uint256 ammount_) external;\\r\\n\\r\\n  function burn(uint256 amount_) external;\\r\\n\\r\\n  function burnFrom(address account_, uint256 amount_) external;\\r\\n\\r\\n  function vault() external returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/new/interfaces/ISPV.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\ninterface ISPV {\\r\\n    function SPVWallet() external view returns ( address );\\r\\n\\r\\n    function totalValue() external view returns ( uint );\\r\\n\\r\\n    function totalProfit() external view returns ( uint );\\r\\n}\"\r\n    },\r\n    \"contracts/new/interfaces/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\ninterface IStaking {\\r\\n    function stake(uint _amount, address _recipient, bool _wrap) external;\\r\\n\\r\\n    function addRebaseReward( uint _amount ) external;\\r\\n}\"\r\n    },\r\n    \"contracts/new/aKeeperRedeem.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"./interfaces/IStaking.sol\\\";\\r\\n\\r\\n\\r\\ncontract aKeeperRedeem is Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    IERC20 public KEEPER;\\r\\n    IERC20 public aKEEPER;\\r\\n    address public staking;\\r\\n    uint public multiplier; // multiplier is 4 decimals i.e. 1000 = 0.1\\r\\n\\r\\n    event KeeperRedeemed(address tokenOwner, uint256 amount);\\r\\n    \\r\\n\\r\\n    constructor(address _aKEEPER, address _KEEPER, address _staking, uint _multiplier) {\\r\\n        require( _aKEEPER != address(0) );\\r\\n        require( _KEEPER != address(0) );\\r\\n        require( _multiplier != 0 );\\r\\n        aKEEPER = IERC20(_aKEEPER);\\r\\n        KEEPER = IERC20(_KEEPER);\\r\\n        staking = _staking;\\r\\n        multiplier = _multiplier;\\r\\n        // reduce gas fees of migrate-stake by pre-approving large amount\\r\\n        KEEPER.approve( staking, 1e25);\\r\\n    }\\r\\n\\r\\n    function migrate(uint256 amount, bool _stake, bool _wrap) public {\\r\\n        aKEEPER.transferFrom(msg.sender, address(this), amount);\\r\\n        uint keeperAmount = amount.mul(multiplier).div(1e4);\\r\\n        if ( _stake && staking != address( 0 ) ) {\\r\\n            IStaking( staking ).stake( keeperAmount, msg.sender, _wrap );\\r\\n        } else {\\r\\n            KEEPER.transfer(msg.sender, keeperAmount);\\r\\n        }\\r\\n        emit KeeperRedeemed(msg.sender, keeperAmount);\\r\\n    }\\r\\n\\r\\n    function withdraw() external onlyOwner() {\\r\\n        uint256 amount = KEEPER.balanceOf(address(this));\\r\\n        KEEPER.transfer(msg.sender, amount);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/new/SPV.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"./interfaces/AggregateV3Interface.sol\\\";\\r\\nimport \\\"./interfaces/IERC20Extended.sol\\\";\\r\\nimport \\\"./interfaces/IKeplerERC20.sol\\\";\\r\\nimport \\\"./interfaces/ITreasury.sol\\\";\\r\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\r\\n\\r\\n\\r\\ncontract SPV is Ownable {\\r\\n    \\r\\n    using SafeERC20 for IERC20Extended;\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    event TokenAdded( address indexed token, PRICETYPE indexed priceType, uint indexed price );\\r\\n    event TokenPriceUpdate( address indexed token, uint indexed price );\\r\\n    event TokenPriceTypeUpdate( address indexed token, PRICETYPE indexed priceType );\\r\\n    event TokenRemoved( address indexed token );\\r\\n    event ValueAudited( uint indexed total );\\r\\n    event TreasuryWithdrawn( address indexed token, uint indexed amount );\\r\\n    event TreasuryReturned( address indexed token, uint indexed amount );\\r\\n\\r\\n    uint public constant keeperDecimals = 9;\\r\\n\\r\\n    enum PRICETYPE { STABLE, CHAINLINK, UNISWAP, MANUAL }\\r\\n\\r\\n    struct TokenPrice {\\r\\n        address token;\\r\\n        PRICETYPE priceType;\\r\\n        uint price;     // At keeper decimals\\r\\n    }\\r\\n\\r\\n    TokenPrice[] public tokens;\\r\\n\\r\\n    struct ChainlinkPriceFeed {\\r\\n        address feed;\\r\\n        uint decimals;\\r\\n    }\\r\\n    mapping( address => ChainlinkPriceFeed ) public chainlinkPriceFeeds;\\r\\n\\r\\n    mapping( address => address ) public uniswapPools;   // The other token must be a stablecoin\\r\\n\\r\\n    address public immutable treasury;\\r\\n    address public SPVWallet;\\r\\n    uint public totalValue;\\r\\n    uint public totalProfit;\\r\\n\\r\\n    uint public spvRecordedValue;\\r\\n    uint public recordTime;\\r\\n    uint public profitInterval;\\r\\n    bool public allowUpdate;    // False when SPV is transferring funds\\r\\n\\r\\n\\r\\n    constructor (address _treasury, address _USDC, address _USDT, address _DAI, address _SPVWallet, uint _profitInterval) {\\r\\n        require( _treasury != address(0) );\\r\\n        treasury = _treasury;\\r\\n        require( _SPVWallet != address(0) );\\r\\n        SPVWallet = _SPVWallet;\\r\\n\\r\\n        tokens.push(TokenPrice({\\r\\n            token: _USDC,\\r\\n            priceType: PRICETYPE.STABLE,\\r\\n            price: 10 ** keeperDecimals\\r\\n        }));\\r\\n        tokens.push(TokenPrice({\\r\\n            token: _USDT,\\r\\n            priceType: PRICETYPE.STABLE,\\r\\n            price: 10 ** keeperDecimals\\r\\n        }));\\r\\n        tokens.push(TokenPrice({\\r\\n            token: _DAI,\\r\\n            priceType: PRICETYPE.STABLE,\\r\\n            price: 10 ** keeperDecimals\\r\\n        }));\\r\\n\\r\\n        recordTime = block.timestamp;\\r\\n        require( _profitInterval > 0, \\\"Interval cannot be 0\\\" );\\r\\n        profitInterval = _profitInterval;\\r\\n        spvRecordedValue = 0;\\r\\n        allowUpdate = true;\\r\\n        updateTotalValue();\\r\\n    }\\r\\n\\r\\n\\r\\n    function enableUpdates() external onlyOwner() {\\r\\n        allowUpdate = true;\\r\\n    }\\r\\n\\r\\n\\r\\n    function disableUpdates() external onlyOwner() {\\r\\n        allowUpdate = false;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setInterval( uint _profitInterval ) external onlyOwner() {\\r\\n        require( _profitInterval > 0, \\\"Interval cannot be 0\\\" );\\r\\n        profitInterval = _profitInterval;\\r\\n    }\\r\\n\\r\\n\\r\\n    function chainlinkTokenPrice(address _token) public view returns (uint) {\\r\\n        ( , int price, , , ) = AggregatorV3Interface( chainlinkPriceFeeds[_token].feed ).latestRoundData();\\r\\n        return uint(price).mul( 10 ** keeperDecimals ).div( 10 ** chainlinkPriceFeeds[_token].decimals );\\r\\n    }\\r\\n\\r\\n\\r\\n    function uniswapTokenPrice(address _token) public view returns (uint) {\\r\\n        address _pair = uniswapPools[_token];\\r\\n        ( uint reserve0, uint reserve1, ) = IUniswapV2Pair( _pair ).getReserves();\\r\\n        uint reserve;\\r\\n        address reserveToken;\\r\\n        uint tokenAmount;\\r\\n        if ( IUniswapV2Pair( _pair ).token0() == _token ) {\\r\\n            reserveToken = IUniswapV2Pair( _pair ).token1();\\r\\n            reserve = reserve1;\\r\\n            tokenAmount = reserve0;\\r\\n        } else {\\r\\n            reserveToken = IUniswapV2Pair( _pair ).token0();\\r\\n            reserve = reserve0;\\r\\n            tokenAmount = reserve1;\\r\\n        }\\r\\n        return reserve.mul(10 ** keeperDecimals).mul( 10 ** IERC20Extended(_token).decimals() ).div( tokenAmount ).div( 10 ** IERC20Extended(reserveToken).decimals() );\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function setNewTokenPrice(address _token, PRICETYPE _priceType, address _feedOrPool, uint _decimals, uint _price) internal returns (uint tokenPrice) {\\r\\n        if (_priceType == PRICETYPE.STABLE) {\\r\\n            tokenPrice = 10 ** keeperDecimals;\\r\\n        } else if (_priceType == PRICETYPE.CHAINLINK) {\\r\\n            chainlinkPriceFeeds[_token] = ChainlinkPriceFeed({\\r\\n                feed: _feedOrPool,\\r\\n                decimals: _decimals\\r\\n            });\\r\\n            tokenPrice = chainlinkTokenPrice(_token);\\r\\n        } else if (_priceType == PRICETYPE.UNISWAP) {\\r\\n            uniswapPools[_token] = _feedOrPool;\\r\\n            tokenPrice = uniswapTokenPrice(_token);\\r\\n        } else if (_priceType == PRICETYPE.MANUAL) {\\r\\n            tokenPrice = _price;\\r\\n        } else {\\r\\n            tokenPrice = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function addToken(address _token, PRICETYPE _priceType, address _feedOrPool, uint _decimals, uint _price) external onlyOwner() {\\r\\n        uint tokenPrice = setNewTokenPrice(_token, _priceType, _feedOrPool, _decimals, _price);\\r\\n        require(tokenPrice > 0, \\\"Token price cannot be 0\\\");\\r\\n\\r\\n        tokens.push(TokenPrice({\\r\\n            token: _token,\\r\\n            priceType: _priceType,\\r\\n            price: tokenPrice\\r\\n        }));\\r\\n\\r\\n        updateTotalValue();\\r\\n        emit TokenAdded(_token, _priceType, tokenPrice);\\r\\n    }\\r\\n\\r\\n\\r\\n    function updateTokenPrice( uint _index, address _token, uint _price ) external onlyOwner() {\\r\\n        require( _token == tokens[ _index ].token, \\\"Wrong token\\\" );\\r\\n        require( tokens[ _index ].priceType == PRICETYPE.MANUAL, \\\"Only manual tokens can be updated\\\" );\\r\\n        tokens[ _index ].price = _price;\\r\\n\\r\\n        updateTotalValue();\\r\\n        emit TokenPriceUpdate(_token, _price);\\r\\n    }\\r\\n\\r\\n\\r\\n    function updateTokenPriceType( uint _index, address _token, PRICETYPE _priceType, address _feedOrPool, uint _decimals, uint _price ) external onlyOwner() {\\r\\n        require( _token == tokens[ _index ].token, \\\"Wrong token\\\" );\\r\\n        tokens[ _index ].priceType = _priceType;\\r\\n\\r\\n        uint tokenPrice = setNewTokenPrice(_token, _priceType, _feedOrPool, _decimals, _price);\\r\\n        require(tokenPrice > 0, \\\"Token price cannot be 0\\\");\\r\\n        tokens[ _index ].price = tokenPrice;\\r\\n\\r\\n        updateTotalValue();\\r\\n        emit TokenPriceTypeUpdate(_token, _priceType);\\r\\n        emit TokenPriceUpdate(_token, tokenPrice);\\r\\n    }\\r\\n\\r\\n\\r\\n    function removeToken( uint _index, address _token ) external onlyOwner() {\\r\\n        require( _token == tokens[ _index ].token, \\\"Wrong token\\\" );\\r\\n        tokens[ _index ] = tokens[tokens.length-1];\\r\\n        tokens.pop();\\r\\n        updateTotalValue();\\r\\n        emit TokenRemoved(_token);\\r\\n    }\\r\\n\\r\\n\\r\\n    function getTokenBalance( uint _index ) internal view returns (uint) {\\r\\n        address _token = tokens[ _index ].token;\\r\\n        return IERC20Extended(_token).balanceOf( SPVWallet ).mul(tokens[ _index ].price).div( 10 ** IERC20Extended( _token ).decimals() );\\r\\n    }\\r\\n\\r\\n\\r\\n    function auditTotalValue() external {\\r\\n        if ( allowUpdate ) {\\r\\n            uint newValue;\\r\\n            for ( uint i = 0; i < tokens.length; i++ ) {\\r\\n                PRICETYPE priceType = tokens[i].priceType;\\r\\n                if (priceType == PRICETYPE.CHAINLINK) {\\r\\n                    tokens[i].price = chainlinkTokenPrice(tokens[i].token);\\r\\n                } else if (priceType == PRICETYPE.UNISWAP) {\\r\\n                    tokens[i].price = uniswapTokenPrice(tokens[i].token);\\r\\n                }\\r\\n                newValue = newValue.add( getTokenBalance(i) );\\r\\n            }\\r\\n            totalValue = newValue;\\r\\n            emit ValueAudited(totalValue);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function calculateProfits() external {\\r\\n        require( recordTime.add( profitInterval ) <= block.timestamp, \\\"Not yet\\\" );\\r\\n        require( msg.sender == SPVWallet || msg.sender == ITreasury( treasury ).DAO(), \\\"Not allowed\\\" );\\r\\n        recordTime = block.timestamp;\\r\\n        updateTotalValue();\\r\\n        uint currentValue;\\r\\n        uint treasuryDebt = ITreasury( treasury ).spvDebt();\\r\\n        if ( treasuryDebt > totalValue ) {\\r\\n            currentValue = 0;\\r\\n        } else {\\r\\n            currentValue = totalValue.sub(treasuryDebt);\\r\\n        }\\r\\n        if ( currentValue > spvRecordedValue ) {\\r\\n            uint profit = currentValue.sub( spvRecordedValue );\\r\\n            spvRecordedValue = currentValue;\\r\\n            totalProfit = totalProfit.add(profit);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function treasuryWithdraw( uint _index, address _token, uint _amount ) external {\\r\\n        require( msg.sender == SPVWallet, \\\"Only SPV Wallet allowed\\\" );\\r\\n        require( _token == tokens[ _index ].token, \\\"Wrong token\\\" );\\r\\n        ITreasury( treasury ).SPVWithdraw( _token, _amount );\\r\\n        updateTotalValue();\\r\\n        emit TreasuryWithdrawn( _token, _amount );\\r\\n    }\\r\\n\\r\\n\\r\\n    function returnToTreasury( uint _index, address _token, uint _amount ) external {\\r\\n        require( _token == tokens[ _index ].token, \\\"Wrong token\\\" );\\r\\n        require( msg.sender == SPVWallet, \\\"Only SPV Wallet can return.\\\" );\\r\\n        IERC20Extended( _token ).safeTransferFrom( msg.sender, address(this), _amount );\\r\\n        IERC20Extended( _token ).approve( treasury, _amount );\\r\\n        ITreasury( treasury ).SPVDeposit( _token, _amount );\\r\\n        updateTotalValue();\\r\\n        emit TreasuryReturned( _token, _amount );\\r\\n    }\\r\\n\\r\\n\\r\\n    function migrateTokens( address newSPV ) external onlyOwner() {\\r\\n        for ( uint i = 0; i < tokens.length; i++ ) {\\r\\n            address _token = tokens[ i ].token;\\r\\n            IERC20Extended(_token).transfer(newSPV, IERC20Extended(_token).balanceOf( address(this) ) );\\r\\n        }\\r\\n        safeTransferETH(newSPV, address(this).balance );\\r\\n    }\\r\\n\\r\\n\\r\\n    function updateTotalValue() internal {\\r\\n        if ( allowUpdate ) {\\r\\n            uint newValue;\\r\\n            for ( uint i = 0; i < tokens.length; i++ ) {\\r\\n                newValue = newValue.add( getTokenBalance(i) );\\r\\n            }\\r\\n            totalValue = newValue;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n        require(success, 'STE');\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/new/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\ninterface ITreasury {\\r\\n    function unstakeMint( uint _amount ) external;\\r\\n    \\r\\n    function SPVDeposit( address _token, uint _amount ) external;\\r\\n\\r\\n    function SPVWithdraw( address _token, uint _amount ) external;\\r\\n\\r\\n    function DAO() external view returns ( address );\\r\\n\\r\\n    function spvDebt() external view returns ( uint );\\r\\n}\"\r\n    },\r\n    \"contracts/new/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"./IUniswapV2ERC20.sol\\\";\\r\\n\\r\\ninterface IUniswapV2Pair is IUniswapV2ERC20 {\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function token0() external view returns ( address );\\r\\n    function token1() external view returns ( address );\\r\\n}\"\r\n    },\r\n    \"contracts/new/interfaces/IUniswapV2ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\ninterface IUniswapV2ERC20 {\\r\\n    function totalSupply() external view returns (uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/new/LPCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"./interfaces/IERC20Extended.sol\\\";\\r\\nimport \\\"./interfaces/IUniswapV2ERC20.sol\\\";\\r\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\r\\n\\r\\n\\r\\ncontract LPCalculator {\\r\\n\\r\\n    using SafeMath for uint;\\r\\n    address public immutable KEEPER;\\r\\n    uint public constant keeperDecimals = 9;\\r\\n\\r\\n\\r\\n    constructor ( address _KEEPER ) {\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = _KEEPER;\\r\\n    }\\r\\n\\r\\n\\r\\n    function getReserve( address _pair ) public view returns ( address reserveToken, uint reserve ) {\\r\\n        ( uint reserve0, uint reserve1, ) = IUniswapV2Pair( _pair ).getReserves();\\r\\n        if ( IUniswapV2Pair( _pair ).token0() == KEEPER ) {\\r\\n            reserve = reserve1;\\r\\n            reserveToken = IUniswapV2Pair( _pair ).token1();\\r\\n        } else {\\r\\n            reserve = reserve0;\\r\\n            reserveToken = IUniswapV2Pair( _pair ).token0();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function valuationUSD( address _pair, uint _amount ) external view returns ( uint ) {\\r\\n        uint totalSupply = IUniswapV2Pair( _pair ).totalSupply();\\r\\n        ( address reserveToken, uint reserve ) = getReserve( _pair );\\r\\n        return _amount.mul( reserve ).mul(2).mul( 10 ** keeperDecimals ).div( totalSupply ).div( 10 ** IERC20Extended( reserveToken ).decimals() );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/new/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"./interfaces/ITreasury.sol\\\";\\r\\n\\r\\n\\r\\ncontract Staking is Ownable {\\r\\n    using SafeMath for uint;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    event Stake( address indexed recipient, uint indexed amount, uint indexed timestamp );\\r\\n    event Unstake( address indexed recipient, uint indexed amount, uint indexed timestamp );\\r\\n\\r\\n    uint public constant keeperDecimals = 9;\\r\\n    IERC20 public immutable KEEPER;\\r\\n    address public immutable treasury;\\r\\n    uint public rate;   // 6 decimals. 10000 = 0.01 = 1%\\r\\n    uint public INDEX;  // keeperDecimals decimals\\r\\n    uint public keeperRewards;\\r\\n\\r\\n    struct Rebase {\\r\\n        uint rebaseRate; // 6 decimals\\r\\n        uint totalStaked;\\r\\n        uint index;\\r\\n        uint timeOccured;\\r\\n    }\\r\\n\\r\\n    struct Epoch {\\r\\n        uint number;\\r\\n        uint rebaseInterval;\\r\\n        uint nextRebase;\\r\\n    }\\r\\n    Epoch public epoch;\\r\\n\\r\\n    Rebase[] public rebases; // past rebase data    \\r\\n\\r\\n    mapping(address => uint) public stakers;\\r\\n\\r\\n\\r\\n    constructor( address _KEEPER, address _treasury, uint _rate, uint _INDEX, uint _rebaseInterval ) {\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = IERC20(_KEEPER);\\r\\n        require( _treasury != address(0) );\\r\\n        treasury = _treasury;\\r\\n        require( _rate != 0 );\\r\\n        rate = _rate;\\r\\n        require( _INDEX != 0 );\\r\\n        INDEX = _INDEX;\\r\\n        require( _rebaseInterval != 0 );\\r\\n\\r\\n        epoch = Epoch({\\r\\n            number: 1,\\r\\n            rebaseInterval: _rebaseInterval,\\r\\n            nextRebase: block.timestamp.add(_rebaseInterval)\\r\\n        });\\r\\n    }\\r\\n\\r\\n\\r\\n    function setRate( uint _rate ) external onlyOwner() {\\r\\n        require( _rate >= rate.div(2) && _rate <= rate.mul(3).div(2), \\\"Rate change cannot be too sharp.\\\" );\\r\\n        rate = _rate;\\r\\n    }\\r\\n\\r\\n\\r\\n    function stake( uint _amount, address _recipient, bool _wrap ) external {\\r\\n        KEEPER.safeTransferFrom( msg.sender, address(this), _amount );\\r\\n        uint _gonsAmount = getGonsAmount( _amount );\\r\\n        stakers[ _recipient ] = stakers[ _recipient ].add( _gonsAmount );\\r\\n        emit Stake( _recipient, _amount, block.timestamp );\\r\\n        rebase();\\r\\n    }\\r\\n\\r\\n\\r\\n    function unstake( uint _amount ) external {\\r\\n        rebase();\\r\\n        require( _amount <= stakerAmount(msg.sender), \\\"Cannot unstake more than possible.\\\" );\\r\\n        if ( _amount > KEEPER.balanceOf( address(this) ) ) {\\r\\n            ITreasury(treasury).unstakeMint( _amount.sub(KEEPER.balanceOf( address(this) ) ) );\\r\\n        }\\r\\n        uint gonsAmount = getGonsAmount( _amount );\\r\\n        // Handle math precision error\\r\\n        if ( gonsAmount > stakers[msg.sender] ) {\\r\\n            gonsAmount = stakers[msg.sender];\\r\\n        }\\r\\n        stakers[msg.sender] = stakers[ msg.sender ].sub(gonsAmount);\\r\\n        KEEPER.safeTransfer( msg.sender, _amount );\\r\\n        emit Unstake( msg.sender, _amount, block.timestamp );\\r\\n    }\\r\\n\\r\\n\\r\\n    function rebase() public {\\r\\n        if (epoch.nextRebase <= block.timestamp) {\\r\\n            uint rebasingRate = rebaseRate();\\r\\n            INDEX = INDEX.add( INDEX.mul( rebasingRate ).div(1e6) );\\r\\n            epoch.nextRebase = epoch.nextRebase.add(epoch.rebaseInterval);\\r\\n            epoch.number++;\\r\\n            keeperRewards = 0;\\r\\n            rebases.push( Rebase({\\r\\n                rebaseRate: rebasingRate,\\r\\n                totalStaked: KEEPER.balanceOf( address(this) ),\\r\\n                index: INDEX,\\r\\n                timeOccured: block.timestamp\\r\\n            }) );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function stakerAmount( address _recipient ) public view returns (uint) {\\r\\n        return getKeeperAmount(stakers[ _recipient ]);\\r\\n    }\\r\\n\\r\\n\\r\\n    function rebaseRate() public view returns (uint) {\\r\\n        uint keeperBalance = KEEPER.balanceOf( address(this) );\\r\\n        if (keeperBalance == 0) {\\r\\n            return rate;\\r\\n        } else {\\r\\n            return rate.add( keeperRewards.mul(1e6).div( KEEPER.balanceOf( address(this) ) ) );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function addRebaseReward( uint _amount ) external {\\r\\n        KEEPER.safeTransferFrom( msg.sender, address(this), _amount );\\r\\n        keeperRewards = keeperRewards.add( _amount );\\r\\n    }\\r\\n\\r\\n\\r\\n    function getGonsAmount( uint _amount ) internal view returns (uint) {\\r\\n        return _amount.mul(10 ** keeperDecimals).div(INDEX);\\r\\n    }\\r\\n\\r\\n\\r\\n    function getKeeperAmount( uint _gons ) internal view returns (uint) {\\r\\n        return _gons.mul(INDEX).div(10 ** keeperDecimals);\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/new/types/VaultOwned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\ncontract VaultOwned is Ownable {\\r\\n\\r\\n  address internal _vault;\\r\\n\\r\\n  function setVault(address vault_) external onlyOwner() returns (bool) {\\r\\n    _vault = vault_;\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function vault() public view returns (address) {\\r\\n    return _vault;\\r\\n  }\\r\\n\\r\\n  modifier onlyVault() {\\r\\n    require(_vault == msg.sender, \\\"VaultOwned: caller is not the Vault\\\");\\r\\n    _;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/new/MockKeplerERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"./types/VaultOwned.sol\\\";\\r\\n\\r\\ncontract MockKeplerERC20 is ERC20, VaultOwned {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    constructor() ERC20(\\\"Keeper\\\", \\\"KEEPER\\\") {\\r\\n        _setupDecimals(9);\\r\\n    }\\r\\n\\r\\n    function mint(address account_, uint256 amount_) external {\\r\\n        _mint(account_, amount_);\\r\\n    }\\r\\n\\r\\n    function burn(uint256 amount) public virtual {\\r\\n        _burn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function burnFrom(address account_, uint256 amount_) public virtual {\\r\\n        _burnFrom(account_, amount_);\\r\\n    }\\r\\n\\r\\n    function _burnFrom(address account_, uint256 amount_) public virtual {\\r\\n        uint256 decreasedAllowance_ =\\r\\n            allowance(account_, msg.sender).sub(\\r\\n                amount_,\\r\\n                \\\"ERC20: burn amount exceeds allowance\\\"\\r\\n            );\\r\\n\\r\\n        _approve(account_, msg.sender, decreasedAllowance_);\\r\\n        _burn(account_, amount_);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/new/KeplerERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"./types/VaultOwned.sol\\\";\\r\\n\\r\\ncontract KeplerERC20 is ERC20, VaultOwned {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    constructor() ERC20(\\\"Keeper\\\", \\\"KEEPER\\\") {\\r\\n        _setupDecimals(9);\\r\\n    }\\r\\n\\r\\n    function mint(address account_, uint256 amount_) external onlyVault() {\\r\\n        _mint(account_, amount_);\\r\\n    }\\r\\n\\r\\n    function burn(uint256 amount) public virtual {\\r\\n        _burn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function burnFrom(address account_, uint256 amount_) public virtual {\\r\\n        _burnFrom(account_, amount_);\\r\\n    }\\r\\n\\r\\n    function _burnFrom(address account_, uint256 amount_) public virtual {\\r\\n        uint256 decreasedAllowance_ =\\r\\n            allowance(account_, msg.sender).sub(\\r\\n                amount_,\\r\\n                \\\"ERC20: burn amount exceeds allowance\\\"\\r\\n            );\\r\\n\\r\\n        _approve(account_, msg.sender, decreasedAllowance_);\\r\\n        _burn(account_, amount_);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/new/KeeperVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\n\\r\\n\\r\\ncontract KeeperVesting is Ownable {\\r\\n    using SafeMath for uint;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    IERC20 public immutable KEEPER;\\r\\n    event KeeperRedeemed(address redeemer, uint amount);\\r\\n\\r\\n    struct Term {\\r\\n        uint percent; // 6 decimals % ( 5000 = 0.5% = 0.005 )\\r\\n        uint claimed;\\r\\n    }\\r\\n    mapping(address => Term) public terms;\\r\\n    mapping(address => address) public walletChange;\\r\\n    // uint public totalRedeemable;\\r\\n    // uint public redeemableLastUpdated;\\r\\n    uint public totalRedeemed;\\r\\n\\r\\n    // address public redeemUpdater;\\r\\n\\r\\n\\r\\n    constructor( address _KEEPER ) {\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = IERC20(_KEEPER);\\r\\n        // redeemUpdater = _redeemUpdater;\\r\\n        // redeemableLastUpdated = block.timestamp;\\r\\n    }\\r\\n\\r\\n\\r\\n    // function setRedeemUpdater(address _redeemUpdater) external onlyOwner() {\\r\\n    //     require( _redeemUpdater != address(0) );\\r\\n    //     redeemUpdater = _redeemUpdater;\\r\\n    // }\\r\\n\\r\\n    // Sets terms for a new wallet\\r\\n    function setTerms(address _vester, uint _percent ) external onlyOwner() returns ( bool ) {\\r\\n        terms[_vester].percent = _percent;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Sets terms for multiple wallets\\r\\n    function setTermsMultiple(address[] calldata _vesters, uint[] calldata _percents ) external onlyOwner() returns ( bool ) {\\r\\n        for (uint i=0; i < _vesters.length; i++) {\\r\\n            terms[_vesters[i]].percent = _percents[i];\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    // function updateTotalRedeemable() external {\\r\\n    //     require( msg.sender == redeemUpdater, \\\"Only redeem updater can call.\\\" );\\r\\n    //     uint keeperBalance = KEEPER.balanceOf( address(this) );\\r\\n\\r\\n    //     uint newRedeemable = keeperBalance.add(totalRedeemed).mul(block.timestamp.sub(redeemableLastUpdated)).div(31536000);\\r\\n    //     totalRedeemable = totalRedeemable.add(newRedeemable);\\r\\n    //     if (totalRedeemable > keeperBalance ) {\\r\\n    //         totalRedeemable = keeperBalance;\\r\\n    //     }\\r\\n    //     redeemableLastUpdated = block.timestamp;\\r\\n    // }\\r\\n\\r\\n    // Allows wallet to redeem KEEPER\\r\\n    function redeem( uint _amount ) external returns ( bool ) {\\r\\n        Term memory info = terms[ msg.sender ];\\r\\n        require( redeemable( info ) >= _amount, 'Not enough vested' );\\r\\n        KEEPER.safeTransfer(msg.sender, _amount);\\r\\n        terms[ msg.sender ].claimed = info.claimed.add( _amount );\\r\\n        totalRedeemed = totalRedeemed.add(_amount);\\r\\n        emit KeeperRedeemed(msg.sender, _amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Allows wallet owner to transfer rights to a new address\\r\\n    function pushWalletChange( address _newWallet ) external returns ( bool ) {\\r\\n        require( terms[ msg.sender ].percent != 0 );\\r\\n        walletChange[ msg.sender ] = _newWallet;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Allows wallet to pull rights from an old address\\r\\n    function pullWalletChange( address _oldWallet ) external returns ( bool ) {\\r\\n        require( walletChange[ _oldWallet ] == msg.sender, \\\"wallet did not push\\\" );\\r\\n        walletChange[ _oldWallet ] = address(0);\\r\\n        terms[ msg.sender ] = terms[ _oldWallet ];\\r\\n        delete terms[ _oldWallet ];\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Amount a wallet can redeem\\r\\n    function redeemableFor( address _vester ) public view returns (uint) {\\r\\n        return redeemable( terms[ _vester ]);\\r\\n    }\\r\\n\\r\\n    function redeemable( Term memory _info ) internal view returns ( uint ) {\\r\\n        uint maxRedeemable = KEEPER.balanceOf( address(this) ).add( totalRedeemed );\\r\\n        if ( maxRedeemable > 1e17 ) {\\r\\n            maxRedeemable = 1e17;\\r\\n        }\\r\\n        uint maxRedeemableUser = maxRedeemable.mul( _info.percent ).div(1e6);\\r\\n        return maxRedeemableUser.sub(_info.claimed);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/new/DailyUpkeep.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\n\\r\\ninterface KeeperCompatibleInterface {\\r\\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\\r\\n\\r\\n  function performUpkeep(bytes calldata performData) external;\\r\\n}\\r\\n\\r\\n\\r\\ninterface IStaking {\\r\\n    function rebase() external;\\r\\n}\\r\\n\\r\\ninterface ITreasury {\\r\\n    function auditTotalReserves() external;\\r\\n}\\r\\n\\r\\ninterface ISPV {\\r\\n    function auditTotalValue() external;\\r\\n}\\r\\n\\r\\n\\r\\ncontract DailyUpkeep is KeeperCompatibleInterface, Ownable {\\r\\n    /**\\r\\n    * Use an interval in seconds and a timestamp to slow execution of Upkeep\\r\\n    */\\r\\n    uint public immutable interval;\\r\\n    uint public nextTimeStamp;\\r\\n\\r\\n    address public staking;\\r\\n    address public treasury;\\r\\n    address public spv;\\r\\n\\r\\n\\r\\n    constructor(address _staking, address _treasury, address _spv, uint _nextTimeStamp, uint _interval) {\\r\\n      staking = _staking;\\r\\n      treasury = _treasury;\\r\\n      spv = _spv;\\r\\n      nextTimeStamp = _nextTimeStamp;\\r\\n      interval = _interval;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setStaking(address _staking) external onlyOwner() {\\r\\n        staking = _staking;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setTreasury(address _treasury) external onlyOwner() {\\r\\n        treasury = _treasury;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setSPV(address _spv) external onlyOwner() {\\r\\n        spv = _spv;\\r\\n    }\\r\\n\\r\\n\\r\\n    function checkUpkeep(bytes calldata /* checkData */) external override returns (bool upkeepNeeded, bytes memory /* performData */) {\\r\\n        upkeepNeeded = block.timestamp > nextTimeStamp;\\r\\n    }\\r\\n\\r\\n\\r\\n    function performUpkeep(bytes calldata /* performData */) external override {\\r\\n        if (staking != address(0)) {\\r\\n            IStaking(staking).rebase();\\r\\n        }\\r\\n        if (treasury != address(0)) {\\r\\n            ITreasury(treasury).auditTotalReserves();\\r\\n        }\\r\\n        if (spv != address(0)) {\\r\\n            ISPV(spv).auditTotalValue();\\r\\n        }\\r\\n        nextTimeStamp = nextTimeStamp + interval;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/types/VaultOwned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\ncontract VaultOwned is Ownable {\\r\\n\\r\\n  address internal _vault;\\r\\n\\r\\n  function setVault(address vault_) external onlyOwner() returns (bool) {\\r\\n    _vault = vault_;\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function vault() public view returns (address) {\\r\\n    return _vault;\\r\\n  }\\r\\n\\r\\n  modifier onlyVault() {\\r\\n    require(_vault == msg.sender, \\\"VaultOwned: caller is not the Vault\\\");\\r\\n    _;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/MockKeplerERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"./types/VaultOwned.sol\\\";\\r\\n\\r\\ncontract oldMockKeplerERC20 is ERC20, VaultOwned {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    constructor() ERC20(\\\"Keeper\\\", \\\"KEEPER\\\") {\\r\\n        _setupDecimals(9);\\r\\n    }\\r\\n\\r\\n    function mint(address account_, uint256 amount_) external {\\r\\n        _mint(account_, amount_);\\r\\n    }\\r\\n\\r\\n    function burn(uint256 amount) public virtual {\\r\\n        _burn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function burnFrom(address account_, uint256 amount_) public virtual {\\r\\n        _burnFrom(account_, amount_);\\r\\n    }\\r\\n\\r\\n    function _burnFrom(address account_, uint256 amount_) public virtual {\\r\\n        uint256 decreasedAllowance_ =\\r\\n            allowance(account_, msg.sender).sub(\\r\\n                amount_,\\r\\n                \\\"ERC20: burn amount exceeds allowance\\\"\\r\\n            );\\r\\n\\r\\n        _approve(account_, msg.sender, decreasedAllowance_);\\r\\n        _burn(account_, amount_);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/KeplerERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"./types/VaultOwned.sol\\\";\\r\\n\\r\\ncontract oldKeplerERC20 is ERC20, VaultOwned {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    constructor() ERC20(\\\"Keeper\\\", \\\"KEEPER\\\") {\\r\\n        _setupDecimals(9);\\r\\n    }\\r\\n\\r\\n    function mint(address account_, uint256 amount_) external onlyVault() {\\r\\n        _mint(account_, amount_);\\r\\n    }\\r\\n\\r\\n    function burn(uint256 amount) public virtual {\\r\\n        _burn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function burnFrom(address account_, uint256 amount_) public virtual {\\r\\n        _burnFrom(account_, amount_);\\r\\n    }\\r\\n\\r\\n    function _burnFrom(address account_, uint256 amount_) public virtual {\\r\\n        uint256 decreasedAllowance_ =\\r\\n            allowance(account_, msg.sender).sub(\\r\\n                amount_,\\r\\n                \\\"ERC20: burn amount exceeds allowance\\\"\\r\\n            );\\r\\n\\r\\n        _approve(account_, msg.sender, decreasedAllowance_);\\r\\n        _burn(account_, amount_);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/iKeeperIndexCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\n\\r\\ncontract iKeeperIndexCalculator is Ownable {\\r\\n\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    event AssetIndexAdded( uint indexed deposit, uint indexed price, address indexed token );\\r\\n    event IndexUpdated( uint indexed fromIndex, uint indexed toIndex, uint oldPrice, uint newPrice );\\r\\n    event DepositUpdated( uint indexed fromDeposit, uint indexed toDeposit );\\r\\n    event AssetIndexWithdrawn( uint indexed deposit, uint price, uint indexed index, address indexed token );\\r\\n\\r\\n    struct AssetIndex {\\r\\n        uint deposit;   // In USD\\r\\n        uint price;     // 6 decimals, in USD\\r\\n        uint index;     // 9 decimals, starts with 1000000000\\r\\n        address token;   // Token address of the asset\\r\\n    }\\r\\n    AssetIndex[] public indices;\\r\\n    uint public netIndex;\\r\\n\\r\\n\\r\\n    constructor(uint _netIndex) {\\r\\n        require( _netIndex != 0, \\\"Index cannot be 0\\\" );\\r\\n        netIndex = _netIndex;\\r\\n    }\\r\\n\\r\\n\\r\\n    function calculateIndex() public {\\r\\n        uint indexProduct = 0;\\r\\n        uint totalDeposit = 0;\\r\\n        for (uint i=0; i < indices.length; i++) {\\r\\n            uint deposit = indices[i].deposit;\\r\\n            totalDeposit = totalDeposit.add(deposit);\\r\\n            indexProduct = indexProduct.add( indices[i].index.mul( deposit ) );\\r\\n        }\\r\\n        netIndex = indexProduct.div(totalDeposit);\\r\\n    }\\r\\n\\r\\n\\r\\n    function addAssetIndex(uint _deposit, uint _price, address _token) external onlyOwner() {\\r\\n        indices.push( AssetIndex({\\r\\n            deposit: _deposit,\\r\\n            price: _price,\\r\\n            index: 1e9,\\r\\n            token: _token\\r\\n        }));\\r\\n    }\\r\\n\\r\\n\\r\\n    function updateIndex(uint _index, address _token, uint _newPrice) external onlyOwner() {\\r\\n        AssetIndex storage assetIndex = indices[ _index ];\\r\\n        require(assetIndex.token == _token, \\\"Wrong index.\\\");\\r\\n        uint changeIndex = _newPrice.mul(1e9).div(assetIndex.price);\\r\\n        uint fromIndex = assetIndex.index;\\r\\n        uint oldPrice = assetIndex.price;\\r\\n        assetIndex.index = fromIndex.mul(changeIndex).div(1e9);\\r\\n        assetIndex.deposit = assetIndex.deposit.mul(changeIndex).div(1e9);\\r\\n        assetIndex.price = _newPrice;\\r\\n        emit IndexUpdated(fromIndex, assetIndex.index, oldPrice, _newPrice);\\r\\n    }\\r\\n\\r\\n\\r\\n    function updateDeposit(uint _index, address _token, uint _amount, bool _add) external onlyOwner() {\\r\\n        require(_token == indices[ _index ].token, \\\"Wrong index.\\\");\\r\\n        uint oldDeposit = indices[ _index ].deposit;\\r\\n        require(_add || oldDeposit >= _amount, \\\"Cannot withdraw more than deposit\\\");\\r\\n        if (!_add) {\\r\\n            indices[ _index ].deposit = oldDeposit.sub(_amount);\\r\\n        } else {\\r\\n            indices[ _index ].deposit = oldDeposit.add(_amount);\\r\\n        }\\r\\n        emit DepositUpdated(oldDeposit, indices[ _index ].deposit);\\r\\n    }\\r\\n\\r\\n\\r\\n    function withdrawAsset(uint _index, address _token) external onlyOwner() {\\r\\n        AssetIndex memory assetIndex = indices[ _index ];\\r\\n        require(_token == assetIndex.token, \\\"Wrong index.\\\");\\r\\n        indices[ _index ] = indices[indices.length-1];\\r\\n        indices.pop();\\r\\n        emit AssetIndexWithdrawn(assetIndex.deposit, assetIndex.price, assetIndex.index, assetIndex.token);\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/iKEEPER.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"./interfaces/IsKEEPER.sol\\\";\\r\\nimport \\\"./interfaces/IStaking.sol\\\";\\r\\n// import \\\"./interfaces/IIndexCalculator.sol\\\";\\r\\n\\r\\n\\r\\ncontract iKEEPER is ERC20, Ownable {\\r\\n\\r\\n    using SafeMath for uint;\\r\\n    address public immutable TROVE;\\r\\n    address public immutable staking;\\r\\n    address public indexCalculator;\\r\\n\\r\\n\\r\\n    constructor(address _TROVE, address _staking, address _indexCalculator) ERC20(\\\"Invest KEEPER\\\", \\\"iKEEPER\\\") {\\r\\n        require(_TROVE != address(0));\\r\\n        TROVE = _TROVE;\\r\\n        require(_staking != address(0));\\r\\n        staking = _staking;\\r\\n        require(_indexCalculator != address(0));\\r\\n        indexCalculator = _indexCalculator;\\r\\n    }\\r\\n\\r\\n    // function setIndexCalculator( address _indexCalculator ) external onlyOwner() {\\r\\n    //     require( _indexCalculator != address(0) );\\r\\n    //     indexCalculator = _indexCalculator;\\r\\n    // }\\r\\n\\r\\n    // /**\\r\\n    //     @notice get iKEEPER index (9 decimals)\\r\\n    //     @return uint\\r\\n    //  */\\r\\n    // // function getIndex() public view returns (uint) {\\r\\n    // //     return IIndexCalculator(indexCalculator).netIndex();\\r\\n    // // }\\r\\n\\r\\n    // // /**\\r\\n    // //     @notice wrap KEEPER\\r\\n    // //     @param _amount uint\\r\\n    // //     @return uint\\r\\n    // //  */\\r\\n    // // function wrapKEEPER( uint _amount ) external returns ( uint ) {\\r\\n    // //     IERC20( KEEPER ).transferFrom( msg.sender, address(this), _amount );\\r\\n\\r\\n    // //     uint value = TROVEToiKEEPER( _amount );\\r\\n    // //     _mint( msg.sender, value );\\r\\n    // //     return value;\\r\\n    // // }\\r\\n\\r\\n    // /**\\r\\n    //     @notice wrap TROVE\\r\\n    //     @param _amount uint\\r\\n    //     @return uint\\r\\n    //  */\\r\\n    // function wrap( uint _amount, address _recipient ) external returns ( uint ) {\\r\\n    //     IsKEEPER( TROVE ).transferFrom( msg.sender, address(this), _amount );\\r\\n\\r\\n    //     uint value = TROVEToiKEEPER( _amount );\\r\\n    //     _mint( _recipient, value );\\r\\n    //     return value;\\r\\n    // }\\r\\n\\r\\n\\r\\n    // // /**\\r\\n    // //     @notice unwrap KEEPER\\r\\n    // //     @param _amount uint\\r\\n    // //     @return uint\\r\\n    // //  */\\r\\n    // // function unwrapKEEPER( uint _amount ) external returns ( uint ) {\\r\\n    // //     _burn( msg.sender, _amount );\\r\\n\\r\\n    // //     uint value = iKEEPERToTROVE( _amount );\\r\\n    // //     uint keeperBalance = IERC20(KEEPER).balanceOf( address(this) );\\r\\n    // //     if (keeperBalance < value ) {\\r\\n    // //         uint difference = value.sub(keeperBalance);\\r\\n    // //         require(IsKEEPER(TROVE).balanceOf(address(this)) >= difference, \\\"Contract does not have enough TROVE\\\");\\r\\n    // //         IsKEEPER(TROVE).approve(staking, difference);\\r\\n    // //         IStaking(staking).unstake(difference, false);\\r\\n    // //     }\\r\\n    // //     IERC20( KEEPER ).transfer( msg.sender, value );\\r\\n    // //     return value;\\r\\n    // // }\\r\\n\\r\\n\\r\\n    // /**\\r\\n    //     @notice unwrap TROVE\\r\\n    //     @param _amount uint\\r\\n    //     @return uint\\r\\n    //  */\\r\\n    // function unwrap( uint _amount ) external returns ( uint ) {\\r\\n    //     _burn( msg.sender, _amount );\\r\\n\\r\\n    //     uint value = iKEEPERToTROVE( _amount );\\r\\n    //     IsKEEPER( TROVE ).transfer( msg.sender, value );\\r\\n    //     return value;\\r\\n    // }\\r\\n\\r\\n    // /**\\r\\n    //     @notice converts iKEEPER amount to TROVE\\r\\n    //     @param _amount uint\\r\\n    //     @return uint\\r\\n    //  */\\r\\n    // function iKEEPERToTROVE( uint _amount ) public view returns ( uint ) {\\r\\n    //     return _amount.mul( getIndex() ).div( 10 ** decimals() );\\r\\n    // }\\r\\n\\r\\n    // /**\\r\\n    //     @notice converts TROVE amount to iKEEPER\\r\\n    //     @param _amount uint\\r\\n    //     @return uint\\r\\n    //  */\\r\\n    // function TROVEToiKEEPER( uint _amount ) public view returns ( uint ) {\\r\\n    //     return _amount.mul( 10 ** decimals() ).div( getIndex() );\\r\\n    // }\\r\\n}\"\r\n    },\r\n    \"contracts/BondStakeDepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"./interfaces/IBondCalculator.sol\\\";\\r\\nimport \\\"./interfaces/IERC20Extended.sol\\\";\\r\\nimport \\\"./interfaces/IsKEEPER.sol\\\";\\r\\nimport \\\"./interfaces/IwTROVE.sol\\\";\\r\\nimport \\\"./interfaces/IStaking.sol\\\";\\r\\nimport \\\"./interfaces/ITreasury.sol\\\";\\r\\nimport \\\"./libraries/FixedPoint.sol\\\";\\r\\nimport \\\"./libraries/SafeMathExtended.sol\\\";\\r\\n\\r\\n\\r\\ncontract BondStakeDepository is Ownable {\\r\\n\\r\\n    using FixedPoint for *;\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeMathExtended for uint;\\r\\n    using SafeMathExtended for uint32;\\r\\n\\r\\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\\r\\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\\r\\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\\r\\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\\r\\n\\r\\n    /* ======== STATE VARIABLES ======== */\\r\\n\\r\\n    address public immutable KEEPER; // intermediate token\\r\\n    address public immutable sKEEPER; // token given as payment for bond\\r\\n    address public immutable wTROVE; // Wrap sKEEPER\\r\\n    address public immutable principle; // token used to create bond\\r\\n    address public immutable treasury; // mints KEEPER when receives principle\\r\\n    address public immutable DAO; // receives profit share from bond\\r\\n\\r\\n    address public immutable bondCalculator; // calculates value of LP tokens\\r\\n    bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\\r\\n\\r\\n    address public staking; // to auto-stake payout\\r\\n    Terms public terms; // stores terms for new bonds\\r\\n    Adjust public adjustment; // stores adjustment to BCV data\\r\\n\\r\\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\\r\\n\\r\\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\\r\\n    uint32 public lastDecay; // reference time for debt decay\\r\\n\\r\\n    /* ======== STRUCTS ======== */\\r\\n\\r\\n    // Info for creating new bonds\\r\\n    struct Terms {\\r\\n        uint controlVariable; // scaling variable for price\\r\\n        uint minimumPrice; // vs principle value\\r\\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\\r\\n        uint fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)\\r\\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\\r\\n        uint32 vestingTerm; // in seconds\\r\\n    }\\r\\n\\r\\n    // Info for bond holder\\r\\n    struct Bond {\\r\\n        uint gonsPayout; // sKEEPER remaining to be paid\\r\\n        uint pricePaid; // In DAI, for front end viewing\\r\\n        uint32 vesting; // seconds left to vest\\r\\n        uint32 lastTime; // Last interaction\\r\\n    }\\r\\n\\r\\n    // Info for incremental adjustments to control variable \\r\\n    struct Adjust {\\r\\n        bool add; // addition or subtraction\\r\\n        uint rate; // increment\\r\\n        uint target; // BCV when adjustment finished\\r\\n        uint32 buffer; // minimum length (in seconds) between adjustments\\r\\n        uint32 lastTime; // timestamp when last adjustment made\\r\\n    }\\r\\n\\r\\n    constructor ( address _KEEPER, address _sKEEPER, address _wTROVE, address _principle, address _staking, address _treasury, address _DAO, address _bondCalculator) {\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = _KEEPER;\\r\\n        require( _sKEEPER != address(0) );\\r\\n        sKEEPER = _sKEEPER;\\r\\n        require( _wTROVE != address(0) );\\r\\n        wTROVE = _wTROVE;\\r\\n        require( _principle != address(0) );\\r\\n        principle = _principle;\\r\\n        require( _treasury != address(0) );\\r\\n        treasury = _treasury;\\r\\n        require( _DAO != address(0) );\\r\\n        DAO = _DAO;\\r\\n        require( _staking != address(0) );\\r\\n        staking = _staking;\\r\\n        // bondCalculator should be address(0) if not LP bond\\r\\n        bondCalculator = _bondCalculator;\\r\\n        isLiquidityBond = ( _bondCalculator != address(0) );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice initializes bond parameters\\r\\n     *  @param _controlVariable uint\\r\\n     *  @param _vestingTerm uint\\r\\n     *  @param _minimumPrice uint\\r\\n     *  @param _maxPayout uint\\r\\n     *  @param _fee uint\\r\\n     *  @param _maxDebt uint\\r\\n     *  @param _initialDebt uint\\r\\n     */\\r\\n    function initializeBondTerms(uint _controlVariable, uint32 _vestingTerm, uint _minimumPrice, uint _maxPayout,\\r\\n                                 uint _fee, uint _maxDebt, uint _initialDebt)\\r\\n    external onlyOwner() {\\r\\n        require( terms.controlVariable == 0 && terms.vestingTerm == 0, \\\"Bonds must be initialized from 0\\\" );\\r\\n        terms = Terms ({\\r\\n            controlVariable: _controlVariable,\\r\\n            vestingTerm: _vestingTerm,\\r\\n            minimumPrice: _minimumPrice,\\r\\n            maxPayout: _maxPayout,\\r\\n            fee: _fee,\\r\\n            maxDebt: _maxDebt\\r\\n        });\\r\\n        totalDebt = _initialDebt;\\r\\n        lastDecay = uint32(block.timestamp);\\r\\n    }\\r\\n\\r\\n    /* ======== POLICY FUNCTIONS ======== */\\r\\n\\r\\n    enum PARAMETER { VESTING, PAYOUT, FEE, DEBT, MINPRICE }\\r\\n    /**\\r\\n     *  @notice set parameters for new bonds\\r\\n     *  @param _parameter PARAMETER\\r\\n     *  @param _input uint\\r\\n     */\\r\\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyOwner() {\\r\\n        if ( _parameter == PARAMETER.VESTING ) { // 0\\r\\n            require( _input >= 129600, \\\"Vesting must be longer than 36 hours\\\" );\\r\\n            require( currentDebt() == 0, \\\"Debt should be 0.\\\" );\\r\\n            terms.vestingTerm = uint32(_input);\\r\\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\\r\\n            require( _input <= 1000, \\\"Payout cannot be above 1 percent\\\" );\\r\\n            terms.maxPayout = _input;\\r\\n        } else if ( _parameter == PARAMETER.FEE ) { // 2\\r\\n            require( _input <= 10000, \\\"DAO fee cannot exceed payout\\\" );\\r\\n            terms.fee = _input;\\r\\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\\r\\n            terms.maxDebt = _input;\\r\\n        } else if ( _parameter == PARAMETER.MINPRICE ) { // 4\\r\\n            terms.minimumPrice = _input;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice set control variable adjustment\\r\\n     *  @param _addition bool\\r\\n     *  @param _increment uint\\r\\n     *  @param _target uint\\r\\n     *  @param _buffer uint\\r\\n     */\\r\\n    function setAdjustment ( bool _addition, uint _increment, uint _target, uint32 _buffer) external onlyOwner() {\\r\\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \\\"Increment too large\\\" );\\r\\n\\r\\n        adjustment = Adjust({\\r\\n            add: _addition,\\r\\n            rate: _increment,\\r\\n            target: _target,\\r\\n            buffer: _buffer,\\r\\n            lastTime: uint32(block.timestamp)\\r\\n        });\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice set contract for auto stake\\r\\n     *  @param _staking address\\r\\n     */\\r\\n    // function setStaking( address _staking ) external onlyOwner() {\\r\\n    //     require( _staking != address(0) );\\r\\n    //     staking = _staking;\\r\\n    // }\\r\\n\\r\\n\\r\\n    /* ======== USER FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice deposit bond\\r\\n     *  @param _amount uint\\r\\n     *  @param _maxPrice uint\\r\\n     *  @param _depositor address\\r\\n     *  @return uint\\r\\n     */\\r\\n    function deposit( uint _amount, uint _maxPrice, address _depositor) external returns ( uint ) {\\r\\n        require( _depositor != address(0), \\\"Invalid address\\\" );\\r\\n        decayDebt();\\r\\n        \\r\\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\\r\\n        uint nativePrice = _bondPrice();\\r\\n\\r\\n        require( _maxPrice >= nativePrice, \\\"Slippage limit: more than max price\\\" ); // slippage protection\\r\\n\\r\\n        uint value = ITreasury( treasury ).valueOfToken( principle, _amount );\\r\\n        uint payout = payoutFor( value ); // payout to bonder is computed\\r\\n\\r\\n        require( payout >= 10000000, \\\"Bond too small\\\" ); // must be > 0.01 KEEPER ( underflow protection )\\r\\n        require( payout <= maxPayout(), \\\"Bond too large\\\"); // size protection because there is no slippage\\r\\n\\r\\n        // profits are calculated\\r\\n        uint fee = payout.mul( terms.fee ).div( 10000 );\\r\\n        uint profit = value.sub( payout ).sub( fee );\\r\\n\\r\\n        /**\\r\\n            principle is transferred in\\r\\n            approved and\\r\\n            deposited into the treasury, returning (_amount - profit) KEEPER\\r\\n         */\\r\\n        IERC20( principle ).safeTransferFrom( msg.sender, address(this), _amount );\\r\\n        IERC20( principle ).approve( address( treasury ), _amount );\\r\\n        ITreasury( treasury ).deposit( _amount, principle, profit );\\r\\n        \\r\\n        if ( fee != 0 ) { // fee is transferred to dao \\r\\n            IERC20( KEEPER ).safeTransfer( DAO, fee ); \\r\\n        }\\r\\n        \\r\\n        // total debt is increased\\r\\n        totalDebt = totalDebt.add( value ); \\r\\n        require( totalDebt <= terms.maxDebt, \\\"Max capacity reached\\\" );\\r\\n\\r\\n        IERC20( KEEPER ).approve( staking, payout );\\r\\n        IStaking( staking ).stake( payout, address(this), false );\\r\\n        IStaking( staking ).claim( address(this) );\\r\\n        uint stakeGons = IsKEEPER(sKEEPER).gonsForBalance(payout);\\r\\n\\r\\n        // depositor info is stored\\r\\n        bondInfo[ _depositor ] = Bond({ \\r\\n            gonsPayout: bondInfo[ _depositor ].gonsPayout.add( stakeGons ),\\r\\n            vesting: terms.vestingTerm,\\r\\n            lastTime: uint32(block.timestamp),\\r\\n            pricePaid: priceInUSD\\r\\n        });\\r\\n\\r\\n        // indexed events are emitted\\r\\n        emit BondCreated( _amount, payout, block.timestamp.add( terms.vestingTerm ), priceInUSD );\\r\\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\\r\\n\\r\\n        adjust(); // control variable is adjusted\\r\\n        return payout; \\r\\n    }\\r\\n\\r\\n    /** \\r\\n     *  @notice redeem bond for user\\r\\n     *  @param _recipient address\\r\\n     *  @param _wrap bool\\r\\n     *  @return uint\\r\\n     */ \\r\\n    function redeem( address _recipient, bool _stake, bool _wrap ) external returns ( uint ) {        \\r\\n        Bond memory info = bondInfo[ _recipient ];\\r\\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\\r\\n\\r\\n        if ( percentVested >= 10000 ) { // if fully vested\\r\\n            delete bondInfo[ _recipient ]; // delete user info\\r\\n            uint _amount = IsKEEPER(sKEEPER).balanceForGons(info.gonsPayout);\\r\\n            emit BondRedeemed( _recipient, _amount, 0 ); // emit bond data\\r\\n            return sendOrWrap( _recipient, _wrap, _amount ); // pay user everything due\\r\\n\\r\\n        } else { // if unfinished\\r\\n            // calculate payout vested\\r\\n            uint gonsPayout = info.gonsPayout.mul( percentVested ).div( 10000 );\\r\\n            // store updated deposit info\\r\\n            bondInfo[ _recipient ] = Bond({\\r\\n                gonsPayout: info.gonsPayout.sub( gonsPayout ),\\r\\n                vesting: info.vesting.sub32( uint32(block.timestamp).sub32( info.lastTime ) ),\\r\\n                lastTime: uint32(block.timestamp),\\r\\n                pricePaid: info.pricePaid\\r\\n            });\\r\\n\\r\\n            uint _amount = IsKEEPER(sKEEPER).balanceForGons(gonsPayout);\\r\\n            uint _remainingAmount = IsKEEPER(sKEEPER).balanceForGons(bondInfo[_recipient].gonsPayout);\\r\\n            emit BondRedeemed( _recipient, _amount, _remainingAmount );\\r\\n            return sendOrWrap( _recipient, _wrap, _amount );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    \\r\\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice allow user to wrap payout automatically\\r\\n     *  @param _wrap bool\\r\\n     *  @param _amount uint\\r\\n     *  @return uint\\r\\n     */\\r\\n    function sendOrWrap( address _recipient, bool _wrap, uint _amount ) internal returns ( uint ) {\\r\\n        if ( _wrap ) { // if user wants to wrap\\r\\n            IERC20(sKEEPER).approve( wTROVE, _amount );\\r\\n            uint wrapValue = IwTROVE(wTROVE).wrap( _amount );\\r\\n            IwTROVE(wTROVE).transfer( _recipient, wrapValue );\\r\\n        } else { // if user wants to stake\\r\\n            IERC20( sKEEPER ).transfer( _recipient, _amount ); // send payout\\r\\n        }\\r\\n        return _amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice makes incremental adjustment to control variable\\r\\n     */\\r\\n    function adjust() internal {\\r\\n        uint timeCanAdjust = adjustment.lastTime.add( adjustment.buffer );\\r\\n        if( adjustment.rate != 0 && block.timestamp >= timeCanAdjust ) {\\r\\n            uint initial = terms.controlVariable;\\r\\n            if ( adjustment.add ) {\\r\\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\\r\\n                if ( terms.controlVariable >= adjustment.target ) {\\r\\n                    adjustment.rate = 0;\\r\\n                }\\r\\n            } else {\\r\\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\\r\\n                if ( terms.controlVariable <= adjustment.target || terms.controlVariable < adjustment.rate ) {\\r\\n                    adjustment.rate = 0;\\r\\n                }\\r\\n            }\\r\\n            adjustment.lastTime = uint32(block.timestamp);\\r\\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice reduce total debt\\r\\n     */\\r\\n    function decayDebt() internal {\\r\\n        totalDebt = totalDebt.sub( debtDecay() );\\r\\n        lastDecay = uint32(block.timestamp);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    /* ======== VIEW FUNCTIONS ======== */\\r\\n\\r\\n    /**\\r\\n     *  @notice determine maximum bond size\\r\\n     *  @return uint\\r\\n     */\\r\\n    function maxPayout() public view returns ( uint ) {\\r\\n        return IERC20( KEEPER ).totalSupply().mul( terms.maxPayout ).div( 100000 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate interest due for new bond\\r\\n     *  @param _value uint\\r\\n     *  @return uint\\r\\n     */\\r\\n    function payoutFor( uint _value ) public view returns ( uint ) {\\r\\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e16 );\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current bond premium\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function bondPrice() public view returns ( uint price_ ) {        \\r\\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\\r\\n        if ( price_ < terms.minimumPrice ) {\\r\\n            price_ = terms.minimumPrice;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current bond price and remove floor if above\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function _bondPrice() internal returns ( uint price_ ) {\\r\\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\\r\\n        if ( price_ < terms.minimumPrice ) {\\r\\n            price_ = terms.minimumPrice;        \\r\\n        } else if ( terms.minimumPrice != 0 ) {\\r\\n            terms.minimumPrice = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice converts bond price to DAI value\\r\\n     *  @return price_ uint\\r\\n     */\\r\\n    function bondPriceInUSD() public view returns ( uint price_ ) {\\r\\n        if( isLiquidityBond ) {\\r\\n            price_ = bondPrice().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 100 );\\r\\n        } else {\\r\\n            price_ = bondPrice().mul( 10 ** IERC20Extended( principle ).decimals() ).div( 100 );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function getBondInfo(address _depositor) public view returns ( uint payout, uint vesting, uint lastTime, uint pricePaid ) {\\r\\n        Bond memory info = bondInfo[ _depositor ];\\r\\n        payout = IsKEEPER(sKEEPER).balanceForGons(info.gonsPayout);\\r\\n        vesting = info.vesting;\\r\\n        lastTime = info.lastTime;\\r\\n        pricePaid = info.pricePaid;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate current ratio of debt to KEEPER supply\\r\\n     *  @return debtRatio_ uint\\r\\n     */\\r\\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \\r\\n        uint supply = IERC20( KEEPER ).totalSupply();\\r\\n        debtRatio_ = FixedPoint.fraction( \\r\\n            currentDebt().mul( 1e9 ), \\r\\n            supply\\r\\n        ).decode112with18().div( 1e18 );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice debt ratio in same terms for reserve or liquidity bonds\\r\\n     *  @return uint\\r\\n     */\\r\\n    function standardizedDebtRatio() external view returns ( uint ) {\\r\\n        if ( isLiquidityBond ) {\\r\\n            return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\\r\\n        } else {\\r\\n            return debtRatio();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate debt factoring in decay\\r\\n     *  @return uint\\r\\n     */\\r\\n    function currentDebt() public view returns ( uint ) {\\r\\n        return totalDebt.sub( debtDecay() );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice amount to decay total debt by\\r\\n     *  @return decay_ uint\\r\\n     */\\r\\n    function debtDecay() public view returns ( uint decay_ ) {\\r\\n        uint32 timeSinceLast = uint32(block.timestamp).sub32( lastDecay );\\r\\n        decay_ = totalDebt.mul( timeSinceLast ).div( terms.vestingTerm );\\r\\n        if ( decay_ > totalDebt ) {\\r\\n            decay_ = totalDebt;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate how far into vesting a depositor is\\r\\n     *  @param _depositor address\\r\\n     *  @return percentVested_ uint\\r\\n     */\\r\\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\\r\\n        Bond memory bond = bondInfo[ _depositor ];\\r\\n        uint timeSinceLast = uint32(block.timestamp).sub( bond.lastTime );\\r\\n        uint vesting = bond.vesting;\\r\\n\\r\\n        if ( vesting > 0 ) {\\r\\n            percentVested_ = timeSinceLast.mul( 10000 ).div( vesting );\\r\\n        } else {\\r\\n            percentVested_ = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     *  @notice calculate amount of KEEPER available for claim by depositor\\r\\n     *  @param _depositor address\\r\\n     *  @return pendingPayout_ uint\\r\\n     */\\r\\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\\r\\n        uint percentVested = percentVestedFor( _depositor );\\r\\n        uint payout = IsKEEPER(sKEEPER).balanceForGons(bondInfo[ _depositor ].gonsPayout);\\r\\n\\r\\n        if ( percentVested >= 10000 ) {\\r\\n            pendingPayout_ = payout;\\r\\n        } else {\\r\\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    /* ======= AUXILLIARY ======= */\\r\\n\\r\\n    /**\\r\\n     *  @notice allow anyone to send lost tokens (excluding principle or KEEPER) to the DAO\\r\\n     *  @return bool\\r\\n     */\\r\\n    function recoverLostToken( address _token ) external returns ( bool ) {\\r\\n        require( _token != KEEPER );\\r\\n        require( _token != sKEEPER );\\r\\n        require( _token != principle );\\r\\n        IERC20( _token ).safeTransfer( DAO, IERC20( _token ).balanceOf( address(this) ) );\\r\\n        return true;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/StandardBondingCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"./interfaces/IERC20Extended.sol\\\";\\r\\nimport \\\"./interfaces/IUniswapV2ERC20.sol\\\";\\r\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\r\\nimport \\\"./libraries/FixedPoint.sol\\\";\\r\\n\\r\\ninterface IBondingCalculator {\\r\\n  function valuation( address pair_, uint amount_ ) external view returns ( uint _value );\\r\\n}\\r\\n\\r\\ncontract StandardBondingCalculator is IBondingCalculator {\\r\\n\\r\\n    using FixedPoint for *;\\r\\n    using SafeMath for uint;\\r\\n    using SafeMath for uint112;\\r\\n\\r\\n    address public immutable KEEPER;\\r\\n\\r\\n    constructor( address _KEEPER ) {\\r\\n        require( _KEEPER != address(0) );\\r\\n        KEEPER = _KEEPER;\\r\\n    }\\r\\n\\r\\n    function sqrrt(uint256 a) internal pure returns (uint c) {\\r\\n        if (a > 3) {\\r\\n            c = a;\\r\\n            uint b = a.div(2).add(1);\\r\\n            while (b < c) {\\r\\n                c = b;\\r\\n                b = a.div(b).add(b).div(2);\\r\\n            }\\r\\n        } else if (a != 0) {\\r\\n            c = 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getKValue( address _pair ) public view returns( uint k_ ) {\\r\\n        uint token0 = IERC20Extended( IUniswapV2Pair( _pair ).token0() ).decimals();\\r\\n        uint token1 = IERC20Extended( IUniswapV2Pair( _pair ).token1() ).decimals();\\r\\n        \\r\\n        (uint reserve0, uint reserve1, ) = IUniswapV2Pair( _pair ).getReserves();\\r\\n        \\r\\n        uint totalDecimals = token0.add( token1 );\\r\\n        uint pairDecimal = IERC20Extended( _pair ).decimals();\\r\\n        \\r\\n        if (totalDecimals < pairDecimal) {\\r\\n            uint decimals = pairDecimal.sub(totalDecimals);\\r\\n            k_ = reserve0.mul(reserve1).mul(10 ** decimals);\\r\\n        }\\r\\n        else {\\r\\n            uint decimals = totalDecimals.sub(pairDecimal);\\r\\n            k_ = reserve0.mul(reserve1).div(10 ** decimals);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getTotalValue( address _pair ) public view returns ( uint _value ) {\\r\\n        _value = sqrrt(getKValue( _pair )).mul(2);\\r\\n    }\\r\\n\\r\\n    function valuation( address _pair, uint amount_ ) external view override returns ( uint _value ) {\\r\\n        uint totalValue = getTotalValue( _pair );\\r\\n        uint totalSupply = IUniswapV2Pair( _pair ).totalSupply();\\r\\n\\r\\n        _value = totalValue.mul( FixedPoint.fraction( amount_, totalSupply ).decode112with18() ).div( 1e18 );\\r\\n    }\\r\\n\\r\\n    function markdown( address _pair ) external view returns ( uint ) {\\r\\n        ( uint reserve0, uint reserve1, ) = IUniswapV2Pair( _pair ).getReserves();\\r\\n\\r\\n        uint reserve;\\r\\n        if ( IUniswapV2Pair( _pair ).token0() == KEEPER ) {\\r\\n            reserve = reserve1;\\r\\n        } else {\\r\\n            reserve = reserve0;\\r\\n        }\\r\\n        return reserve.mul( 2 * ( 10 ** IERC20Extended( KEEPER ).decimals() ) ).div( getTotalValue( _pair ) );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\ninterface IUniswapV2ERC20 {\\r\\n    function totalSupply() external view returns (uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"./IUniswapV2ERC20.sol\\\";\\r\\n\\r\\ninterface IUniswapV2Pair is IUniswapV2ERC20 {\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function token0() external view returns ( address );\\r\\n    function token1() external view returns ( address );\\r\\n}\"\r\n    },\r\n    \"contracts/other/aKEEPER.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\npragma solidity 0.7.5;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\n\\r\\n\\r\\ncontract aKEEPER is ERC20 {\\r\\n    \\r\\n    constructor() ERC20(\\\"Alpha Keeper\\\", \\\"aKEEPER\\\") {\\r\\n        _setupDecimals(9);\\r\\n        _mint(msg.sender, 220000000000000);\\r\\n    }\\r\\n\\r\\n    function burn(uint256 amount) external {\\r\\n        _burn(msg.sender, amount);\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aKEEPER\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_depositDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawDeadline\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"KEEPER\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aKEEPER\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositaKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_wrap\",\"type\":\"bool\"}],\"name\":\"migrateTrove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositDeadline\",\"type\":\"uint256\"}],\"name\":\"setDepositDeadline\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_KEEPER\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_staking\",\"type\":\"address\"}],\"name\":\"setKeeperStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawDeadline\",\"type\":\"uint256\"}],\"name\":\"setWithdrawDeadline\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawStart\",\"type\":\"uint256\"}],\"name\":\"setWithdrawStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "aKeeperStake2", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000000828be3e0c5ff6c619af533e002aa61f2f85c2940000000000000000000000000000000000000000000000000000000061e45d2000000000000000000000000000000000000000000000000000000000620a98a000000000000000000000000000000000000000000000000000000000621d0da0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}