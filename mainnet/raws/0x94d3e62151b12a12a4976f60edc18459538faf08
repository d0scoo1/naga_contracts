{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/hyphen/WhitelistPeriodManager.sol\": {\r\n      \"content\": \"// $$\\\\      $$\\\\                                                         $$\\\\       $$\\\\       $$\\\\                     $$\\\\       $$\\\\ $$\\\\   $$\\\\               \\n// $$$\\\\    $$$ |                                                        $$ |      $$ |      \\\\__|                    \\\\__|      $$ |\\\\__|  $$ |              \\n// $$$$\\\\  $$$$ | $$$$$$\\\\  $$$$$$$\\\\   $$$$$$\\\\   $$$$$$\\\\   $$$$$$\\\\   $$$$$$$ |      $$ |      $$\\\\  $$$$$$\\\\  $$\\\\   $$\\\\ $$\\\\  $$$$$$$ |$$\\\\ $$$$$$\\\\   $$\\\\   $$\\\\ \\n// $$\\\\$$\\\\$$ $$ | \\\\____$$\\\\ $$  __$$\\\\  \\\\____$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$  __$$ |      $$ |      $$ |$$  __$$\\\\ $$ |  $$ |$$ |$$  __$$ |$$ |\\\\_$$  _|  $$ |  $$ |\\n// $$ \\\\$$$  $$ | $$$$$$$ |$$ |  $$ | $$$$$$$ |$$ /  $$ |$$$$$$$$ |$$ /  $$ |      $$ |      $$ |$$ /  $$ |$$ |  $$ |$$ |$$ /  $$ |$$ |  $$ |    $$ |  $$ |\\n// $$ |\\\\$  /$$ |$$  __$$ |$$ |  $$ |$$  __$$ |$$ |  $$ |$$   ____|$$ |  $$ |      $$ |      $$ |$$ |  $$ |$$ |  $$ |$$ |$$ |  $$ |$$ |  $$ |$$\\\\ $$ |  $$ |\\n// $$ | \\\\_/ $$ |\\\\$$$$$$$ |$$ |  $$ |\\\\$$$$$$$ |\\\\$$$$$$$ |\\\\$$$$$$$\\\\ \\\\$$$$$$$ |      $$$$$$$$\\\\ $$ |\\\\$$$$$$$ |\\\\$$$$$$  |$$ |\\\\$$$$$$$ |$$ |  \\\\$$$$  |\\\\$$$$$$$ |\\n// \\\\__|     \\\\__| \\\\_______|\\\\__|  \\\\__| \\\\_______| \\\\____$$ | \\\\_______| \\\\_______|      \\\\________|\\\\__| \\\\____$$ | \\\\______/ \\\\__| \\\\_______|\\\\__|   \\\\____/  \\\\____$$ |\\n//                                            $$\\\\   $$ |                                              $$ |                                      $$\\\\   $$ |\\n//                                            \\\\$$$$$$  |                                              $$ |                                      \\\\$$$$$$  |\\n//                                             \\\\______/                                               \\\\__|                                       \\\\______/ \\n//\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport \\\"../security/Pausable.sol\\\";\\nimport \\\"./metatx/ERC2771ContextUpgradeable.sol\\\";\\nimport \\\"./interfaces/ILiquidityProviders.sol\\\";\\nimport \\\"./interfaces/ITokenManager.sol\\\";\\nimport \\\"./interfaces/ILPToken.sol\\\";\\n\\ncontract WhitelistPeriodManager is Initializable, OwnableUpgradeable, Pausable, ERC2771ContextUpgradeable {\\n    ILiquidityProviders private liquidityProviders;\\n    ITokenManager private tokenManager;\\n    ILPToken private lpToken;\\n    bool public areWhiteListRestrictionsEnabled;\\n\\n    /* LP Status */\\n    // EOA? -> status, stores addresses that we want to ignore, like staking contracts.\\n    mapping(address => bool) public isExcludedAddress;\\n    // Token -> TVL\\n    mapping(address => uint256) private totalLiquidity;\\n    // Token -> TVL\\n    mapping(address => mapping(address => uint256)) public totalLiquidityByLp;\\n\\n    /* Caps */\\n    // Token Address -> Limit\\n    mapping(address => uint256) public perTokenTotalCap;\\n    // Token Address -> Limit\\n    mapping(address => uint256) public perTokenWalletCap;\\n\\n    event ExcludedAddressStatusUpdated(address indexed lp, bool indexed status);\\n    event TotalCapUpdated(address indexed token, uint256 totalCap);\\n    event PerTokenWalletCap(address indexed token, uint256 perCommunityWalletCap);\\n    event WhiteListStatusUpdated(bool status);\\n\\n    modifier onlyLiquidityPool() {\\n        require(_msgSender() == address(liquidityProviders), \\\"ERR__UNAUTHORIZED\\\");\\n        _;\\n    }\\n\\n    modifier onlyLpNft() {\\n        require(_msgSender() == address(lpToken), \\\"ERR__UNAUTHORIZED\\\");\\n        _;\\n    }\\n\\n    modifier tokenChecks(address tokenAddress) {\\n        require(tokenAddress != address(0), \\\"Token address cannot be 0\\\");\\n        require(_isSupportedToken(tokenAddress), \\\"Token not supported\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev initalizes the contract, acts as constructor\\n     * @param _trustedForwarder address of trusted forwarder\\n     */\\n    function initialize(\\n        address _trustedForwarder,\\n        address _liquidityProviders,\\n        address _tokenManager,\\n        address _lpToken,\\n        address _pauser\\n    ) external initializer {\\n        __ERC2771Context_init(_trustedForwarder);\\n        __Ownable_init();\\n        __Pausable_init(_pauser);\\n        areWhiteListRestrictionsEnabled = true;\\n        _setLiquidityProviders(_liquidityProviders);\\n        _setTokenManager(_tokenManager);\\n        _setLpToken(_lpToken);\\n    }\\n\\n    function _isSupportedToken(address _token) private view returns (bool) {\\n        return tokenManager.getTokensInfo(_token).supportedToken;\\n    }\\n\\n    /**\\n     * @dev Internal Function which checks for various caps before allowing LP to add liqudity\\n     */\\n    function _beforeLiquidityAddition(\\n        address _lp,\\n        address _token,\\n        uint256 _amount\\n    ) internal {\\n        if (isExcludedAddress[_lp]) {\\n            return;\\n        }\\n        // Per Token Total Cap or PTTC\\n        require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), \\\"ERR__LIQUIDITY_EXCEEDS_PTTC\\\");\\n        require(\\n            ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]),\\n            \\\"ERR__LIQUIDITY_EXCEEDS_PTWC\\\"\\n        );\\n        totalLiquidity[_token] += _amount;\\n        totalLiquidityByLp[_token][_lp] += _amount;\\n    }\\n\\n    /**\\n     * @dev External Function which checks for various caps before allowing LP to add liqudity. Only callable by LiquidityPoolManager\\n     */\\n    function beforeLiquidityAddition(\\n        address _lp,\\n        address _token,\\n        uint256 _amount\\n    ) external onlyLiquidityPool whenNotPaused {\\n        _beforeLiquidityAddition(_lp, _token, _amount);\\n    }\\n\\n    /**\\n     * @dev Internal Function which checks for various caps before allowing LP to remove liqudity\\n     */\\n    function _beforeLiquidityRemoval(\\n        address _lp,\\n        address _token,\\n        uint256 _amount\\n    ) internal {\\n        if (isExcludedAddress[_lp]) {\\n            return;\\n        }\\n        totalLiquidityByLp[_token][_lp] -= _amount;\\n        totalLiquidity[_token] -= _amount;\\n    }\\n\\n    /**\\n     * @dev External Function which checks for various caps before allowing LP to remove liqudity. Only callable by LiquidityPoolManager\\n     */\\n    function beforeLiquidityRemoval(\\n        address _lp,\\n        address _token,\\n        uint256 _amount\\n    ) external onlyLiquidityPool whenNotPaused {\\n        _beforeLiquidityRemoval(_lp, _token, _amount);\\n    }\\n\\n    /**\\n     * @dev External Function which checks for various caps before allowing LP to transfer their LpNFT. Only callable by LpNFT contract\\n     */\\n    function beforeLiquidityTransfer(\\n        address _from,\\n        address _to,\\n        address _token,\\n        uint256 _amount\\n    ) external onlyLpNft whenNotPaused {\\n        // Release limit from  _from\\n        _beforeLiquidityRemoval(_from, _token, _amount);\\n\\n        // Block limit of _to\\n        _beforeLiquidityAddition(_to, _token, _amount);\\n    }\\n\\n    function _setTokenManager(address _tokenManager) internal {\\n        tokenManager = ITokenManager(_tokenManager);\\n    }\\n\\n    function setTokenManager(address _tokenManager) external onlyOwner {\\n        _setTokenManager(_tokenManager);\\n    }\\n\\n    function _setLiquidityProviders(address _liquidityProviders) internal {\\n        liquidityProviders = ILiquidityProviders(_liquidityProviders);\\n    }\\n\\n    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {\\n        _setLiquidityProviders(_liquidityProviders);\\n    }\\n\\n    function _setLpToken(address _lpToken) internal {\\n        lpToken = ILPToken(_lpToken);\\n    }\\n\\n    function setLpToken(address _lpToken) external onlyOwner {\\n        _setLpToken(_lpToken);\\n    }\\n\\n    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external onlyOwner {\\n        require(_addresses.length == _status.length, \\\"ERR__LENGTH_MISMATCH\\\");\\n        uint256 length = _addresses.length;\\n        for (uint256 i; i < length; ) {\\n            isExcludedAddress[_addresses[i]] = _status[i];\\n            emit ExcludedAddressStatusUpdated(_addresses[i], _status[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function setTotalCap(address _token, uint256 _totalCap) public tokenChecks(_token) onlyOwner {\\n        require(totalLiquidity[_token] <= _totalCap, \\\"ERR__TOTAL_CAP_LESS_THAN_SL\\\");\\n        require(_totalCap >= perTokenWalletCap[_token], \\\"ERR__TOTAL_CAP_LT_PTWC\\\");\\n        if (perTokenTotalCap[_token] != _totalCap) {\\n            perTokenTotalCap[_token] = _totalCap;\\n            emit TotalCapUpdated(_token, _totalCap);\\n        }\\n    }\\n\\n    /**\\n     * @dev Special care must be taken when calling this function\\n     *      There are no checks for _perTokenWalletCap (since it's onlyOwner), but it's essential that it\\n     *      should be >= max lp provided by an lp.\\n     *      Checking this on chain will probably require implementing a bbst, which needs more bandwidth\\n     *      Call the view function getMaxCommunityLpPositon() separately before changing this value\\n     */\\n    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) public tokenChecks(_token) onlyOwner {\\n        require(_perTokenWalletCap <= perTokenTotalCap[_token], \\\"ERR__PWC_GT_PTTC\\\");\\n        if (perTokenWalletCap[_token] != _perTokenWalletCap) {\\n            perTokenWalletCap[_token] = _perTokenWalletCap;\\n            emit PerTokenWalletCap(_token, _perTokenWalletCap);\\n        }\\n    }\\n\\n    function setCap(\\n        address _token,\\n        uint256 _totalCap,\\n        uint256 _perTokenWalletCap\\n    ) public onlyOwner {\\n        setTotalCap(_token, _totalCap);\\n        setPerTokenWalletCap(_token, _perTokenWalletCap);\\n    }\\n\\n    function setCaps(\\n        address[] memory _tokens,\\n        uint256[] memory _totalCaps,\\n        uint256[] memory _perTokenWalletCaps\\n    ) external onlyOwner {\\n        require(\\n            _tokens.length == _totalCaps.length && _totalCaps.length == _perTokenWalletCaps.length,\\n            \\\"ERR__LENGTH_MISMACH\\\"\\n        );\\n        uint256 length = _tokens.length;\\n        for (uint256 i; i < length; ) {\\n            setCap(_tokens[i], _totalCaps[i], _perTokenWalletCaps[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Enables (or disables) reverts if liquidity exceeds caps.\\n     *      Even if this is disabled, the contract will continue to track LP's positions\\n     */\\n    function setAreWhiteListRestrictionsEnabled(bool _status) external onlyOwner {\\n        areWhiteListRestrictionsEnabled = _status;\\n        emit WhiteListStatusUpdated(_status);\\n    }\\n\\n    /**\\n     * @dev Returns the maximum amount a single community LP has provided\\n     */\\n    function getMaxCommunityLpPositon(address _token) external view returns (uint256) {\\n        uint256 totalSupply = lpToken.totalSupply();\\n        uint256 maxLp = 0;\\n        for (uint256 i = 1; i <= totalSupply; ++i) {\\n            uint256 liquidity = totalLiquidityByLp[_token][lpToken.ownerOf(i)];\\n            if (liquidity > maxLp) {\\n                maxLp = liquidity;\\n            }\\n        }\\n        return maxLp;\\n    }\\n\\n    /**\\n     * @dev returns the value of if (areWhiteListEnabled) then (_cond)\\n     */\\n    function ifEnabled(bool _cond) private view returns (bool) {\\n        return !areWhiteListRestrictionsEnabled || (areWhiteListRestrictionsEnabled && _cond);\\n    }\\n\\n    /**\\n     * @dev Meta-Transaction Helper, returns msgSender\\n     */\\n    function _msgSender()\\n        internal\\n        view\\n        virtual\\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\\n        returns (address)\\n    {\\n        return ERC2771ContextUpgradeable._msgSender();\\n    }\\n\\n    /**\\n     * @dev Meta-Transaction Helper, returns msgData\\n     */\\n    function _msgData()\\n        internal\\n        view\\n        virtual\\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\\n        returns (bytes calldata)\\n    {\\n        return ERC2771ContextUpgradeable._msgData();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Initializable, PausableUpgradeable {\\n    address private _pauser;\\n\\n    event PauserChanged(address indexed previousPauser, address indexed newPauser);\\n\\n    /**\\n     * @dev The pausable constructor sets the original `pauser` of the contract to the sender\\n     * account & Initializes the contract in unpaused state..\\n     */\\n    function __Pausable_init(address pauser) internal initializer {\\n        require(pauser != address(0), \\\"Pauser Address cannot be 0\\\");\\n        __Pausable_init();\\n        _pauser = pauser;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isPauser(address pauser) public view returns (bool) {\\n        return pauser == _pauser;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the pauser.\\n     */\\n    modifier onlyPauser() {\\n        require(isPauser(msg.sender), \\\"Only pauser is allowed to perform this operation\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current pauser to transfer control of the contract to a newPauser.\\n     * @param newPauser The address to transfer pauserShip to.\\n     */\\n    function changePauser(address newPauser) public onlyPauser {\\n        _changePauser(newPauser);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newPauser.\\n     * @param newPauser The address to transfer ownership to.\\n     */\\n    function _changePauser(address newPauser) internal {\\n        require(newPauser != address(0));\\n        emit PauserChanged(_pauser, newPauser);\\n        _pauser = newPauser;\\n    }\\n\\n    function renouncePauser() external virtual onlyPauser {\\n        emit PauserChanged(_pauser, address(0));\\n        _pauser = address(0);\\n    }\\n\\n    function pause() public onlyPauser {\\n        _pause();\\n    }\\n\\n    function unpause() public onlyPauser {\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/hyphen/metatx/ERC2771ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support. \\n * Here _trustedForwarder is made internal instead of private\\n * so it can be changed via Child contracts with a setter method.\\n */\\nabstract contract ERC2771ContextUpgradeable is Initializable, ContextUpgradeable {\\n    address internal _trustedForwarder;\\n\\n    function __ERC2771Context_init(address trustedForwarder) internal initializer {\\n        __Context_init_unchained();\\n        __ERC2771Context_init_unchained(trustedForwarder);\\n    }\\n\\n    function __ERC2771Context_init_unchained(address trustedForwarder) internal initializer {\\n        _trustedForwarder = trustedForwarder;\\n    }\\n\\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\\n        return forwarder == _trustedForwarder;\\n    }\\n\\n    function _msgSender() internal view virtual override returns (address sender) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return super._msgSender();\\n        }\\n    }\\n\\n    function _msgData() internal view virtual override returns (bytes calldata) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return super._msgData();\\n        }\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/hyphen/interfaces/ILiquidityProviders.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\ninterface ILiquidityProviders {\\n    function BASE_DIVISOR() external view returns (uint256);\\n\\n    function initialize(address _trustedForwarder, address _lpToken) external;\\n\\n    function addLPFee(address _token, uint256 _amount) external;\\n\\n    function addNativeLiquidity() external;\\n\\n    function addTokenLiquidity(address _token, uint256 _amount) external;\\n\\n    function claimFee(uint256 _nftId) external;\\n\\n    function getFeeAccumulatedOnNft(uint256 _nftId) external view returns (uint256);\\n\\n    function getSuppliedLiquidityByToken(address tokenAddress) external view returns (uint256);\\n\\n    function getTokenPriceInLPShares(address _baseToken) external view returns (uint256);\\n\\n    function getTotalLPFeeByToken(address tokenAddress) external view returns (uint256);\\n\\n    function getTotalReserveByToken(address tokenAddress) external view returns (uint256);\\n\\n    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256);\\n\\n    function increaseNativeLiquidity(uint256 _nftId) external;\\n\\n    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external;\\n\\n    function isTrustedForwarder(address forwarder) external view returns (bool);\\n\\n    function owner() external view returns (address);\\n\\n    function paused() external view returns (bool);\\n\\n    function removeLiquidity(uint256 _nftId, uint256 amount) external;\\n\\n    function renounceOwnership() external;\\n\\n    function setLiquidityPool(address _liquidityPool) external;\\n\\n    function setLpToken(address _lpToken) external;\\n\\n    function setWhiteListPeriodManager(address _whiteListPeriodManager) external;\\n\\n    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) external view returns (uint256);\\n\\n    function totalLPFees(address) external view returns (uint256);\\n\\n    function totalLiquidity(address) external view returns (uint256);\\n\\n    function totalReserve(address) external view returns (uint256);\\n\\n    function totalSharesMinted(address) external view returns (uint256);\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function whiteListPeriodManager() external view returns (address);\\n\\n    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) external;\\n\\n    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) external;\\n\\n    function getCurrentLiquidity(address tokenAddress) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/hyphen/interfaces/ITokenManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport \\\"../structures/TokenConfig.sol\\\";\\n\\ninterface ITokenManager {\\n    function getEquilibriumFee(address tokenAddress) external view returns (uint256);\\n\\n    function getMaxFee(address tokenAddress) external view returns (uint256);\\n\\n    function changeFee(\\n        address tokenAddress,\\n        uint256 _equilibriumFee,\\n        uint256 _maxFee\\n    ) external;\\n\\n    function tokensInfo(address tokenAddress)\\n        external\\n        view\\n        returns (\\n            uint256 transferOverhead,\\n            bool supportedToken,\\n            uint256 equilibriumFee,\\n            uint256 maxFee,\\n            TokenConfig memory config\\n        );\\n\\n    function getTokensInfo(address tokenAddress) external view returns (TokenInfo memory);\\n\\n    function getDepositConfig(uint256 toChainId, address tokenAddress) external view returns (TokenConfig memory);\\n\\n    function getTransferConfig(address tokenAddress) external view returns (TokenConfig memory);\\n}\\n\"\r\n    },\r\n    \"contracts/hyphen/interfaces/ILPToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport \\\"../structures/LpTokenMetadata.sol\\\";\\n\\ninterface ILPToken {\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    function exists(uint256 _tokenId) external view returns (bool);\\n\\n    function getAllNftIdsByUser(address _owner) external view returns (uint256[] memory);\\n\\n    function getApproved(uint256 tokenId) external view returns (address);\\n\\n    function initialize(\\n        string memory _name,\\n        string memory _symbol,\\n        address _trustedForwarder\\n    ) external;\\n\\n    function isApprovedForAll(address _owner, address operator) external view returns (bool);\\n\\n    function isTrustedForwarder(address forwarder) external view returns (bool);\\n\\n    function liquidityPoolAddress() external view returns (address);\\n\\n    function mint(address _to) external returns (uint256);\\n\\n    function name() external view returns (string memory);\\n\\n    function owner() external view returns (address);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n\\n    function paused() external view returns (bool);\\n\\n    function renounceOwnership() external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) external;\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function setLiquidityPool(address _lpm) external;\\n\\n    function setWhiteListPeriodManager(address _whiteListPeriodManager) external;\\n\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n\\n    function tokenMetadata(uint256)\\n        external\\n        view\\n        returns (\\n            address token,\\n            uint256 totalSuppliedLiquidity,\\n            uint256 totalShares\\n        );\\n\\n    function tokenOfOwnerByIndex(address _owner, uint256 index) external view returns (uint256);\\n\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function updateTokenMetadata(uint256 _tokenId, LpTokenMetadata memory _lpTokenMetadata) external;\\n\\n    function whiteListPeriodManager() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal initializer {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/hyphen/structures/TokenConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nstruct TokenInfo {\\n    uint256 transferOverhead;\\n    bool supportedToken;\\n    uint256 equilibriumFee; // Percentage fee Represented in basis points\\n    uint256 maxFee; // Percentage fee Represented in basis points\\n    TokenConfig tokenConfig;\\n}\\n\\nstruct TokenConfig {\\n    uint256 min;\\n    uint256 max;\\n}\\n\"\r\n    },\r\n    \"contracts/hyphen/structures/LpTokenMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nstruct LpTokenMetadata {\\n    address token;\\n    uint256 suppliedLiquidity;\\n    uint256 shares;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"ExcludedAddressStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousPauser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"PauserChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"perCommunityWalletCap\",\"type\":\"uint256\"}],\"name\":\"PerTokenWalletCap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalCap\",\"type\":\"uint256\"}],\"name\":\"TotalCapUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"WhiteListStatusUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"areWhiteListRestrictionsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"beforeLiquidityAddition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"beforeLiquidityRemoval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"beforeLiquidityTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"changePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getMaxCommunityLpPositon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trustedForwarder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityProviders\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pauser\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pauser\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"perTokenTotalCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"perTokenWalletCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAreWhiteListRestrictionsEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_perTokenWalletCap\",\"type\":\"uint256\"}],\"name\":\"setCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_totalCaps\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_perTokenWalletCaps\",\"type\":\"uint256[]\"}],\"name\":\"setCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_status\",\"type\":\"bool[]\"}],\"name\":\"setIsExcludedAddressStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityProviders\",\"type\":\"address\"}],\"name\":\"setLiquidityProviders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"}],\"name\":\"setLpToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_perTokenWalletCap\",\"type\":\"uint256\"}],\"name\":\"setPerTokenWalletCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenManager\",\"type\":\"address\"}],\"name\":\"setTokenManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalCap\",\"type\":\"uint256\"}],\"name\":\"setTotalCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalLiquidityByLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "WhitelistPeriodManager", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}