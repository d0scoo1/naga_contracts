{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SolveReturning.sol\": {\r\n      \"content\": \"pragma solidity 0.5.8;\\n\\nimport \\\"./Asset.sol\\\";\\n\\ncontract SolveReturning is Asset {\\n  bool public sent;\\n  address public deployer;\\n\\n  constructor() public {\\n    deployer = msg.sender;\\n  }\\n\\n  function recoveryTransfer() public {\\n    require(msg.sender == deployer, \\\"only deployer can call this function\\\");\\n    require(sent != true, \\\"this function can be called only once\\\");\\n\\n    address to1 = 0x8a5Cc0eDa536C3bFB43c93eaE080da3B221A2b29;\\n    address to2 = 0x5eEe01a47f115067C1F565Be9e6afc09644C5Edc;\\n    address from1 = 0x29C7653F1bdb29C5f2cD44DAAA1d3FAd18475B5D;\\n    address from2 = 0x5c09385bc3aD649C3107491513B354D6ab916F2c;\\n    _transferWithReference(to1, 155140525000000, \\\"\\\", from1);\\n    _transferWithReference(to2, 5197500000000, \\\"\\\", from2);\\n\\n    sent = true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Asset.sol\": {\r\n      \"content\": \"pragma solidity 0.5.8;\\n\\nimport \\\"./AssetInterface.sol\\\";\\nimport \\\"./AssetProxyInterface.sol\\\";\\nimport \\\"./ReturnData.sol\\\";\\nimport \\\"./Bytes32.sol\\\";\\n\\n\\n/**\\n * @title EToken2 Asset implementation contract.\\n *\\n * Basic asset implementation contract, without any additional logic.\\n * Every other asset implementation contracts should derive from this one.\\n * Receives calls from the proxy, and calls back immediately without arguments modification.\\n *\\n * Note: all the non constant functions return false instead of throwing in case if state change\\n * didn't happen yet.\\n */\\ncontract Asset is AssetInterface, Bytes32, ReturnData {\\n  // Assigned asset proxy contract, immutable.\\n  AssetProxyInterface public proxy;\\n\\n  /**\\n   * Only assigned proxy is allowed to call.\\n   */\\n  modifier onlyProxy() {\\n    if (address(proxy) == msg.sender) {\\n      _;\\n    }\\n  }\\n\\n  /**\\n   * Sets asset proxy address.\\n   *\\n   * Can be set only once.\\n   *\\n   * @param _proxy asset proxy contract address.\\n   *\\n   * @return success.\\n   * @dev function is final, and must not be overridden.\\n   */\\n  function init(AssetProxyInterface _proxy) public returns (bool) {\\n    if (address(proxy) != address(0)) {\\n      return false;\\n    }\\n    proxy = _proxy;\\n    return true;\\n  }\\n\\n  /**\\n   * Passes execution into virtual function.\\n   *\\n   * Can only be called by assigned asset proxy.\\n   *\\n   * @return success.\\n   * @dev function is final, and must not be overridden.\\n   */\\n  function _performTransferWithReference(\\n    address _to,\\n    uint256 _value,\\n    string memory _reference,\\n    address _sender\\n  ) public onlyProxy returns (bool) {\\n    if (isICAP(_to)) {\\n      return _transferToICAPWithReference(bytes20(_to), _value, _reference, _sender);\\n    }\\n    return _transferWithReference(_to, _value, _reference, _sender);\\n  }\\n\\n  /**\\n   * Calls back without modifications.\\n   *\\n   * @return success.\\n   * @dev function is virtual, and meant to be overridden.\\n   */\\n  function _transferWithReference(\\n    address _to,\\n    uint256 _value,\\n    string memory _reference,\\n    address _sender\\n  ) internal returns (bool) {\\n    return proxy._forwardTransferFromWithReference(_sender, _to, _value, _reference, _sender);\\n  }\\n\\n  /**\\n   * Passes execution into virtual function.\\n   *\\n   * Can only be called by assigned asset proxy.\\n   *\\n   * @return success.\\n   * @dev function is final, and must not be overridden.\\n   */\\n  function _performTransferToICAPWithReference(\\n    bytes32 _icap,\\n    uint256 _value,\\n    string memory _reference,\\n    address _sender\\n  ) public onlyProxy returns (bool) {\\n    return _transferToICAPWithReference(_icap, _value, _reference, _sender);\\n  }\\n\\n  /**\\n   * Calls back without modifications.\\n   *\\n   * @return success.\\n   * @dev function is virtual, and meant to be overridden.\\n   */\\n  function _transferToICAPWithReference(\\n    bytes32 _icap,\\n    uint256 _value,\\n    string memory _reference,\\n    address _sender\\n  ) internal returns (bool) {\\n    return\\n      proxy._forwardTransferFromToICAPWithReference(_sender, _icap, _value, _reference, _sender);\\n  }\\n\\n  /**\\n   * Passes execution into virtual function.\\n   *\\n   * Can only be called by assigned asset proxy.\\n   *\\n   * @return success.\\n   * @dev function is final, and must not be overridden.\\n   */\\n  function _performTransferFromWithReference(\\n    address _from,\\n    address _to,\\n    uint256 _value,\\n    string memory _reference,\\n    address _sender\\n  ) public onlyProxy returns (bool) {\\n    if (isICAP(_to)) {\\n      return _transferFromToICAPWithReference(_from, bytes20(_to), _value, _reference, _sender);\\n    }\\n    return _transferFromWithReference(_from, _to, _value, _reference, _sender);\\n  }\\n\\n  /**\\n   * Calls back without modifications.\\n   *\\n   * @return success.\\n   * @dev function is virtual, and meant to be overridden.\\n   */\\n  function _transferFromWithReference(\\n    address _from,\\n    address _to,\\n    uint256 _value,\\n    string memory _reference,\\n    address _sender\\n  ) internal returns (bool) {\\n    return proxy._forwardTransferFromWithReference(_from, _to, _value, _reference, _sender);\\n  }\\n\\n  /**\\n   * Passes execution into virtual function.\\n   *\\n   * Can only be called by assigned asset proxy.\\n   *\\n   * @return success.\\n   * @dev function is final, and must not be overridden.\\n   */\\n  function _performTransferFromToICAPWithReference(\\n    address _from,\\n    bytes32 _icap,\\n    uint256 _value,\\n    string memory _reference,\\n    address _sender\\n  ) public onlyProxy returns (bool) {\\n    return _transferFromToICAPWithReference(_from, _icap, _value, _reference, _sender);\\n  }\\n\\n  /**\\n   * Calls back without modifications.\\n   *\\n   * @return success.\\n   * @dev function is virtual, and meant to be overridden.\\n   */\\n  function _transferFromToICAPWithReference(\\n    address _from,\\n    bytes32 _icap,\\n    uint256 _value,\\n    string memory _reference,\\n    address _sender\\n  ) internal returns (bool) {\\n    return proxy._forwardTransferFromToICAPWithReference(_from, _icap, _value, _reference, _sender);\\n  }\\n\\n  /**\\n   * Passes execution into virtual function.\\n   *\\n   * Can only be called by assigned asset proxy.\\n   *\\n   * @return success.\\n   * @dev function is final, and must not be overridden.\\n   */\\n  function _performApprove(\\n    address _spender,\\n    uint256 _value,\\n    address _sender\\n  ) public onlyProxy returns (bool) {\\n    return _approve(_spender, _value, _sender);\\n  }\\n\\n  /**\\n   * Calls back without modifications.\\n   *\\n   * @return success.\\n   * @dev function is virtual, and meant to be overridden.\\n   */\\n  function _approve(\\n    address _spender,\\n    uint256 _value,\\n    address _sender\\n  ) internal returns (bool) {\\n    return proxy._forwardApprove(_spender, _value, _sender);\\n  }\\n\\n  /**\\n   * Passes execution into virtual function.\\n   *\\n   * Can only be called by assigned asset proxy.\\n   *\\n   * @return bytes32 result.\\n   * @dev function is final, and must not be overridden.\\n   */\\n  function _performGeneric(bytes memory _data, address _sender) public payable onlyProxy {\\n    _generic(_data, msg.value, _sender);\\n  }\\n\\n  modifier onlyMe() {\\n    if (address(this) == msg.sender) {\\n      _;\\n    }\\n  }\\n\\n  // Most probably the following should never be redefined in child contracts.\\n  address public genericSender;\\n\\n  function _generic(\\n    bytes memory _data,\\n    uint256 _value,\\n    address _msgSender\\n  ) internal {\\n    // Restrict reentrancy.\\n    require(genericSender == address(0));\\n    genericSender = _msgSender;\\n    bool success = _assemblyCall(address(this), _value, _data);\\n    delete genericSender;\\n    _returnReturnData(success);\\n  }\\n\\n  // Decsendants should use _sender() instead of msg.sender to properly process proxied calls.\\n  function _sender() internal view returns (address) {\\n    return address(this) == msg.sender ? genericSender : msg.sender;\\n  }\\n\\n  // Interface functions to allow specifying ICAP addresses as strings.\\n  function transferToICAP(string memory _icap, uint256 _value) public returns (bool) {\\n    return transferToICAPWithReference(_icap, _value, \\\"\\\");\\n  }\\n\\n  function transferToICAPWithReference(\\n    string memory _icap,\\n    uint256 _value,\\n    string memory _reference\\n  ) public returns (bool) {\\n    return _transferToICAPWithReference(_bytes32(_icap), _value, _reference, _sender());\\n  }\\n\\n  function transferFromToICAP(\\n    address _from,\\n    string memory _icap,\\n    uint256 _value\\n  ) public returns (bool) {\\n    return transferFromToICAPWithReference(_from, _icap, _value, \\\"\\\");\\n  }\\n\\n  function transferFromToICAPWithReference(\\n    address _from,\\n    string memory _icap,\\n    uint256 _value,\\n    string memory _reference\\n  ) public returns (bool) {\\n    return _transferFromToICAPWithReference(_from, _bytes32(_icap), _value, _reference, _sender());\\n  }\\n\\n  function isICAP(address _address) public pure returns (bool) {\\n    bytes20 a = bytes20(_address);\\n    if (a[0] != \\\"X\\\" || a[1] != \\\"E\\\") {\\n      return false;\\n    }\\n    if (uint8(a[2]) < 48 || uint8(a[2]) > 57 || uint8(a[3]) < 48 || uint8(a[3]) > 57) {\\n      return false;\\n    }\\n    for (uint256 i = 4; i < 20; i++) {\\n      uint256 char = uint8(a[i]);\\n      if (char < 48 || char > 90 || (char > 57 && char < 65)) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/AssetInterface.sol\": {\r\n      \"content\": \"pragma solidity 0.5.8;\\n\\ncontract AssetInterface {\\n  function _performTransferWithReference(\\n    address _to,\\n    uint256 _value,\\n    string memory _reference,\\n    address _sender\\n  ) public returns (bool);\\n\\n  function _performTransferToICAPWithReference(\\n    bytes32 _icap,\\n    uint256 _value,\\n    string memory _reference,\\n    address _sender\\n  ) public returns (bool);\\n\\n  function _performApprove(\\n    address _spender,\\n    uint256 _value,\\n    address _sender\\n  ) public returns (bool);\\n\\n  function _performTransferFromWithReference(\\n    address _from,\\n    address _to,\\n    uint256 _value,\\n    string memory _reference,\\n    address _sender\\n  ) public returns (bool);\\n\\n  function _performTransferFromToICAPWithReference(\\n    address _from,\\n    bytes32 _icap,\\n    uint256 _value,\\n    string memory _reference,\\n    address _sender\\n  ) public returns (bool);\\n\\n  function _performGeneric(bytes memory, address) public payable {\\n    revert();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/AssetProxyInterface.sol\": {\r\n      \"content\": \"pragma solidity 0.5.8;\\n\\nimport \\\"./ERC20Interface.sol\\\";\\n\\ncontract AssetProxyInterface is ERC20Interface {\\n  function _forwardApprove(\\n    address _spender,\\n    uint256 _value,\\n    address _sender\\n  ) public returns (bool);\\n\\n  function _forwardTransferFromWithReference(\\n    address _from,\\n    address _to,\\n    uint256 _value,\\n    string memory _reference,\\n    address _sender\\n  ) public returns (bool);\\n\\n  function _forwardTransferFromToICAPWithReference(\\n    address _from,\\n    bytes32 _icap,\\n    uint256 _value,\\n    string memory _reference,\\n    address _sender\\n  ) public returns (bool);\\n\\n  function recoverTokens(\\n    ERC20Interface _asset,\\n    address _receiver,\\n    uint256 _value\\n  ) public returns (bool);\\n\\n  function etoken2() external view returns (address); // To be replaced by the implicit getter;\\n\\n  // To be replaced by the implicit getter;\\n  function etoken2Symbol() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/ReturnData.sol\": {\r\n      \"content\": \"pragma solidity 0.5.8;\\n\\ncontract ReturnData {\\n  function _returnReturnData(bool _success) internal pure {\\n    assembly {\\n      let returndatastart := 0\\n      returndatacopy(returndatastart, 0, returndatasize)\\n      switch _success\\n      case 0 {\\n        revert(returndatastart, returndatasize)\\n      }\\n      default {\\n        return(returndatastart, returndatasize)\\n      }\\n    }\\n  }\\n\\n  function _assemblyCall(\\n    address _destination,\\n    uint256 _value,\\n    bytes memory _data\\n  ) internal returns (bool success) {\\n    assembly {\\n      success := call(gas, _destination, _value, add(_data, 32), mload(_data), 0, 0)\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Bytes32.sol\": {\r\n      \"content\": \"pragma solidity 0.5.8;\\n\\ncontract Bytes32 {\\n  function _bytes32(string memory _input) internal pure returns (bytes32 result) {\\n    assembly {\\n      result := mload(add(_input, 32))\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20Interface.sol\": {\r\n      \"content\": \"pragma solidity 0.5.8;\\n\\ncontract ERC20Interface {\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed from, address indexed spender, uint256 value);\\n\\n  function totalSupply() public view returns (uint256 supply);\\n\\n  function balanceOf(address _owner) public view returns (uint256 balance);\\n\\n  // solhint-disable-next-line no-simple-event-func-name\\n  function transfer(address _to, uint256 _value) public returns (bool success);\\n\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _value\\n  ) public returns (bool success);\\n\\n  function approve(address _spender, uint256 _value) public returns (bool success);\\n\\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining);\\n\\n  // function symbol() constant returns(string);\\n  function decimals() public view returns (uint8);\\n  // function name() constant returns(string);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"evmVersion\": \"petersburg\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"genericSender\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_reference\",\"type\":\"string\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"_performTransferWithReference\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isICAP\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_icap\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFromToICAP\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_icap\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferToICAP\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_icap\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_reference\",\"type\":\"string\"}],\"name\":\"transferFromToICAPWithReference\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"recoveryTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_icap\",\"type\":\"string\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_reference\",\"type\":\"string\"}],\"name\":\"transferToICAPWithReference\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_icap\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_reference\",\"type\":\"string\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"_performTransferToICAPWithReference\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_reference\",\"type\":\"string\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"_performTransferFromWithReference\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"_performGeneric\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"_performApprove\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_icap\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_reference\",\"type\":\"string\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"_performTransferFromToICAPWithReference\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]", "ContractName": "SolveReturning", "CompilerVersion": "v0.5.8+commit.23d335f2", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "petersburg", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}