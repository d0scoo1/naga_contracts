{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n/// CurveLPOracle.sol\r\n\r\n// Copyright (C) 2021 Dai Foundation\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.8.11;\r\n\r\ninterface AddressProviderLike {\r\n    function get_registry() external view returns (address);\r\n}\r\n\r\ninterface CurveRegistryLike {\r\n    function get_n_coins(address) external view returns (uint256[2] calldata);\r\n}\r\n\r\ninterface CurvePoolLike {\r\n    function coins(uint256) external view returns (address);\r\n    function get_virtual_price() external view returns (uint256);\r\n    function lp_token() external view returns (address);\r\n}\r\n\r\ninterface OracleLike {\r\n    function read() external view returns (uint256);\r\n}\r\n\r\ncontract CurveLPOracleFactory {\r\n\r\n    AddressProviderLike immutable ADDRESS_PROVIDER;\r\n\r\n    event NewCurveLPOracle(address owner, address orcl, bytes32 wat, address pool);\r\n\r\n    constructor(address addressProvider) {\r\n        ADDRESS_PROVIDER = AddressProviderLike(addressProvider);\r\n    }\r\n\r\n    function build(\r\n        address _owner,\r\n        address _pool,\r\n        bytes32 _wat,\r\n        address[] calldata _orbs\r\n    ) external returns (address orcl) {\r\n        uint256 ncoins = CurveRegistryLike(ADDRESS_PROVIDER.get_registry()).get_n_coins(_pool)[1];\r\n        require(ncoins == _orbs.length, \"CurveLPOracleFactory/wrong-num-of-orbs\");\r\n        orcl = address(new CurveLPOracle(_owner, _pool, _wat, _orbs));\r\n        emit NewCurveLPOracle(_owner, orcl, _wat, _pool);\r\n    }\r\n}\r\n\r\ncontract CurveLPOracle {\r\n\r\n    // --- Auth ---\r\n    mapping (address => uint256) public wards;                                       // Addresses with admin authority\r\n    function rely(address _usr) external auth { wards[_usr] = 1; emit Rely(_usr); }  // Add admin\r\n    function deny(address _usr) external auth { wards[_usr] = 0; emit Deny(_usr); }  // Remove admin\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"CurveLPOracle/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    address public immutable src;   // Price source, do not remove as needed for OmegaPoker\r\n\r\n    // stopped, hop, and zph are packed into single slot to reduce SLOADs;\r\n    // this outweighs the added bitmasking overhead.\r\n    uint8   public stopped;        // Stop/start ability to update\r\n    uint16  public hop = 1 hours;  // Minimum time in between price updates\r\n    uint232 public zph;            // Time of last price update plus hop\r\n\r\n    // --- Whitelisting ---\r\n    mapping (address => uint256) public bud;\r\n    modifier toll { require(bud[msg.sender] == 1, \"CurveLPOracle/not-whitelisted\"); _; }\r\n\r\n    struct Feed {\r\n        uint128 val;  // Price\r\n        uint128 has;  // Is price valid\r\n    }\r\n\r\n    Feed internal cur;  // Current price (storage slot 0x3)\r\n    Feed internal nxt;  // Queued price  (storage slot 0x4)\r\n\r\n    address[] public orbs;  // array of price feeds for pool assets, same order as in the pool\r\n\r\n    address public immutable pool;    // Address of underlying Curve pool\r\n    bytes32 public immutable wat;     // Label of token whose price is being tracked\r\n    uint256 public immutable ncoins;  // Number of tokens in underlying Curve pool\r\n\r\n    // --- Events ---\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n    event Stop();\r\n    event Start();\r\n    event Step(uint256 hop);\r\n    event Link(uint256 id, address orb);\r\n    event Value(uint128 curVal, uint128 nxtVal);\r\n    event Kiss(address a);\r\n    event Diss(address a);\r\n\r\n    // --- Init ---\r\n    constructor(address _ward, address _pool, bytes32 _wat, address[] memory _orbs) {\r\n        require(_pool != address(0), \"CurveLPOracle/invalid-pool\");\r\n        uint256 _ncoins = _orbs.length;\r\n        pool   = _pool;\r\n        src    = CurvePoolLike(_pool).lp_token();\r\n        wat    = _wat;\r\n        ncoins = _ncoins;\r\n        for (uint256 i = 0; i < _ncoins;) {\r\n            require(_orbs[i] != address(0), \"CurveLPOracle/invalid-orb\");\r\n            orbs.push(_orbs[i]);\r\n            unchecked { i++; }\r\n        }\r\n        require(_ward != address(0), \"CurveLPOracle/ward-0\");\r\n        wards[_ward] = 1;\r\n        emit Rely(_ward);\r\n    }\r\n\r\n    function stop() external auth {\r\n        stopped = 1;\r\n        delete cur;\r\n        delete nxt;\r\n        zph = 0;\r\n        emit Stop();\r\n    }\r\n\r\n    function start() external auth {\r\n        stopped = 0;\r\n        emit Start();\r\n    }\r\n\r\n    function step(uint16 _hop) external auth {\r\n        uint16 old = hop;\r\n        hop = _hop;\r\n        if (zph > old) {  // if false, zph will be unset and no update is needed\r\n            zph = (zph - old) + _hop;\r\n        }\r\n        emit Step(_hop);\r\n    }\r\n\r\n    function link(uint256 _id, address _orb) external auth {\r\n        require(_orb != address(0), \"CurveLPOracle/invalid-orb\");\r\n        require(_id < ncoins, \"CurveLPOracle/invalid-orb-index\");\r\n        orbs[_id] = _orb;\r\n        emit Link(_id, _orb);\r\n    }\r\n\r\n    // For consistency with other oracles\r\n    function zzz() external view returns (uint256) {\r\n        if (zph == 0) return 0;  // backwards compatibility\r\n        return zph - hop;\r\n    }\r\n\r\n    function pass() external view returns (bool) {\r\n        return block.timestamp >= zph;\r\n    }\r\n\r\n    // Marked payable to save gas. DO *NOT* send ETH to poke(), it will be lost permanently.\r\n    function poke() external payable {\r\n\r\n        // Ensure a single SLOAD while avoiding solc's excessive bitmasking bureaucracy.\r\n        uint256 hop_;\r\n        {\r\n\r\n            // Block-scoping these variables saves some gas.\r\n            uint256 stopped_;\r\n            uint256 zph_;\r\n            assembly {\r\n                let slot1 := sload(1)\r\n                stopped_  := and(slot1,         0xff  )\r\n                hop_      := and(shr(8, slot1), 0xffff)\r\n                zph_      := shr(24, slot1)\r\n            }\r\n\r\n            // When stopped, values are set to zero and should remain such; thus, disallow updating in that case.\r\n            require(stopped_ == 0, \"CurveLPOracle/is-stopped\");\r\n\r\n            // Equivalent to requiring that pass() returns true; logic repeated to save gas.\r\n            require(block.timestamp >= zph_, \"CurveLPOracle/not-passed\");\r\n        }\r\n\r\n        uint256 val = type(uint256).max;\r\n        for (uint256 i = 0; i < ncoins;) {\r\n            uint256 price = OracleLike(orbs[i]).read();\r\n            if (price < val) val = price;\r\n            unchecked { i++; }\r\n        }\r\n        val = val * CurvePoolLike(pool).get_virtual_price() / 10**18;\r\n        require(val != 0, \"CurveLPOracle/zero-price\");\r\n        require(val <= type(uint128).max, \"CurveLPOracle/price-overflow\");\r\n        Feed memory cur_ = nxt;\r\n        cur = cur_;\r\n        nxt = Feed(uint128(val), 1);\r\n\r\n        // The below is equivalent to:\r\n        //    zph = block.timestamp + hop\r\n        // but ensures no extra SLOADs are performed.\r\n        //\r\n        // Even if _hop = (2^16 - 1), the maximum possible value, add(timestamp(), _hop)\r\n        // will not overflow (even a 232 bit value) for a very long time.\r\n        //\r\n        // Also, we know stopped was zero, so there is no need to account for it explicitly here.\r\n        assembly {\r\n            sstore(\r\n                1,\r\n                add(\r\n                    shl(24, add(timestamp(), hop_)),  // zph value starts 24 bits in\r\n                    shl(8, hop_)                      // hop value starts 8 bits in\r\n                )\r\n            )\r\n        }\r\n\r\n        emit Value(cur_.val, uint128(val));\r\n\r\n        // Safe to terminate immediately since no postfix modifiers are applied.\r\n        assembly { stop() }\r\n    }\r\n\r\n    function peek() external view toll returns (bytes32,bool) {\r\n        return (bytes32(uint256(cur.val)), cur.has == 1);\r\n    }\r\n\r\n    function peep() external view toll returns (bytes32,bool) {\r\n        return (bytes32(uint256(nxt.val)), nxt.has == 1);\r\n    }\r\n\r\n    function read() external view toll returns (bytes32) {\r\n        require(cur.has == 1, \"CurveLPOracle/no-current-value\");\r\n        return (bytes32(uint256(cur.val)));\r\n    }\r\n\r\n    function kiss(address _a) external auth {\r\n        require(_a != address(0), \"CurveLPOracle/no-contract-0\");\r\n        bud[_a] = 1;\r\n        emit Kiss(_a);\r\n    }\r\n\r\n    function kiss(address[] calldata _a) external auth {\r\n        for(uint256 i = 0; i < _a.length;) {\r\n            require(_a[i] != address(0), \"CurveLPOracle/no-contract-0\");\r\n            bud[_a[i]] = 1;\r\n            emit Kiss(_a[i]);\r\n            unchecked { i++; }\r\n        }\r\n    }\r\n\r\n    function diss(address _a) external auth {\r\n        bud[_a] = 0;\r\n        emit Diss(_a);\r\n    }\r\n\r\n    function diss(address[] calldata _a) external auth {\r\n        for(uint256 i = 0; i < _a.length;) {\r\n            bud[_a[i]] = 0;\r\n            emit Diss(_a[i]);\r\n            unchecked { i++; }\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ward\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_wat\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"_orbs\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Deny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"Diss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"Kiss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"orb\",\"type\":\"address\"}],\"name\":\"Link\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Rely\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Start\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hop\",\"type\":\"uint256\"}],\"name\":\"Step\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Stop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"curVal\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"nxtVal\",\"type\":\"uint128\"}],\"name\":\"Value\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bud\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_a\",\"type\":\"address[]\"}],\"name\":\"diss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"diss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hop\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_a\",\"type\":\"address[]\"}],\"name\":\"kiss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"kiss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_orb\",\"type\":\"address\"}],\"name\":\"link\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ncoins\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orbs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pass\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"peek\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"peep\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poke\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"read\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"src\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_hop\",\"type\":\"uint16\"}],\"name\":\"step\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wat\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zph\",\"outputs\":[{\"internalType\":\"uint232\",\"name\":\"\",\"type\":\"uint232\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zzz\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CurveLPOracle", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000be8e3e3618f7474f8cb1d074a26affef007e98fb000000000000000000000000dc24316b9ae028f1497c275eb9192a3ea0f6702243525656314554485354455448000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000200000000000000000000000064de91f5a373cd4c28de3600cb34c7c6ce410c85000000000000000000000000911d7a8f87282c4111f621e2d100aa751bab1260", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fda241e016792946d430588cd3961b3fc99cb2c33d56e3cc1c513b0a581c0cd9"}]}