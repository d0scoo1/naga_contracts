{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/E/Defi/force/contracts/contracts/Controllable.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\r\\n\\r\\nimport \\\"./Governable.sol\\\";\\r\\n\\r\\ncontract Controllable is Governable {\\r\\n    constructor(address _storage) public Governable(_storage) {}\\r\\n\\r\\n    modifier onlyController() {\\r\\n        require(store.isController(msg.sender), \\\"Not a controller\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyControllerOrGovernance() {\\r\\n        require(\\r\\n            (store.isController(msg.sender) || store.isGovernance(msg.sender)),\\r\\n            \\\"The caller must be controller or governance\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function controller() public view returns (address) {\\r\\n        return store.controller();\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/E/Defi/force/contracts/contracts/Governable.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\r\\n\\r\\nimport \\\"./Storage.sol\\\";\\r\\n\\r\\ncontract Governable {\\r\\n    Storage public store;\\r\\n\\r\\n    constructor(address _store) public {\\r\\n        require(_store != address(0), \\\"new storage shouldn't be empty\\\");\\r\\n        store = Storage(_store);\\r\\n    }\\r\\n\\r\\n    modifier onlyGovernance() {\\r\\n        require(store.isGovernance(msg.sender), \\\"Not governance\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setStorage(address _store) public onlyGovernance {\\r\\n        require(_store != address(0), \\\"new storage shouldn't be empty\\\");\\r\\n        store = Storage(_store);\\r\\n    }\\r\\n\\r\\n    function governance() public view returns (address) {\\r\\n        return store.governance();\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/E/Defi/force/contracts/contracts/Storage.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\r\\n\\r\\ncontract Storage {\\r\\n    address public governance;\\r\\n    address public controller;\\r\\n\\r\\n    constructor() public {\\r\\n        governance = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier onlyGovernance() {\\r\\n        require(isGovernance(msg.sender), \\\"Not governance\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setGovernance(address _governance) public onlyGovernance {\\r\\n        require(_governance != address(0), \\\"new governance shouldn't be empty\\\");\\r\\n        governance = _governance;\\r\\n    }\\r\\n\\r\\n    function setController(address _controller) public onlyGovernance {\\r\\n        require(_controller != address(0), \\\"new controller shouldn't be empty\\\");\\r\\n        controller = _controller;\\r\\n    }\\r\\n\\r\\n    function isGovernance(address account) public view returns (bool) {\\r\\n        return account == governance;\\r\\n    }\\r\\n\\r\\n    function isController(address account) public view returns (bool) {\\r\\n        return account == controller;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/E/Defi/force/contracts/contracts/interfaces/IController.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\r\\n\\r\\ninterface IController {\\r\\n    function whiteList(address _target) external view returns (bool);\\r\\n\\r\\n    function addVaultAndStrategy(address _vault, address _strategy) external;\\r\\n\\r\\n    function forceUnleashed(address _vault) external;\\r\\n\\r\\n    function hasVault(address _vault) external returns (bool);\\r\\n\\r\\n    function salvage(address _token, uint256 amount) external;\\r\\n\\r\\n    function salvageStrategy(\\r\\n        address _strategy,\\r\\n        address _token,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n\\r\\n    function notifyFee(address _underlying, uint256 fee) external;\\r\\n\\r\\n    function profitSharingNumerator() external view returns (uint256);\\r\\n\\r\\n    function profitSharingDenominator() external view returns (uint256);\\r\\n\\r\\n    function treasury() external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/E/Defi/force/contracts/contracts/interfaces/IStrategy.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\r\\n\\r\\ninterface IStrategy {\\r\\n    function unsalvagableTokens(address tokens) external view returns (bool);\\r\\n\\r\\n    function governance() external view returns (address);\\r\\n\\r\\n    function controller() external view returns (address);\\r\\n\\r\\n    function underlying() external view returns (address);\\r\\n\\r\\n    function vault() external view returns (address);\\r\\n\\r\\n    function withdrawAllToVault() external;\\r\\n\\r\\n    function withdrawToVault(uint256 amount) external;\\r\\n\\r\\n    function investedUnderlyingBalance() external view returns (uint256); // itsNotMuch()\\r\\n\\r\\n    // should only be called by controller\\r\\n    function salvage(\\r\\n        address recipient,\\r\\n        address token,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n\\r\\n    function forceUnleashed() external;\\r\\n\\r\\n    function depositArbCheck() external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/E/Defi/force/contracts/contracts/interfaces/IVault.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\r\\n\\r\\ninterface IVault {\\r\\n    function underlyingBalanceInVault() external view returns (uint256);\\r\\n\\r\\n    function underlyingBalanceWithInvestment() external view returns (uint256);\\r\\n\\r\\n    function governance() external view returns (address);\\r\\n\\r\\n    function controller() external view returns (address);\\r\\n\\r\\n    function underlying() external view returns (address);\\r\\n\\r\\n    function strategy() external view returns (address);\\r\\n\\r\\n    function setStrategy(address _strategy) external;\\r\\n\\r\\n    function setVaultFractionToInvest(uint256 numerator, uint256 denominator)\\r\\n        external;\\r\\n\\r\\n    function deposit(uint256 amountWei) external;\\r\\n\\r\\n    function depositFor(uint256 amountWei, address holder) external;\\r\\n\\r\\n    function withdrawAll() external;\\r\\n\\r\\n    function withdraw(uint256 numberOfShares) external;\\r\\n\\r\\n    function getPricePerFullShare() external view returns (uint256);\\r\\n\\r\\n    function underlyingBalanceWithInvestmentForHolder(address holder)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    // force unleash should be callable only by the controller (by the force unleasher) or by governance\\r\\n    function forceUnleashed() external;\\r\\n\\r\\n    function rebalance() external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/E/Defi/force/contracts/contracts/strategies/RewardTokenProfitNotifier.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"../interfaces/IController.sol\\\";\\r\\nimport \\\"../Controllable.sol\\\";\\r\\n\\r\\ncontract RewardTokenProfitNotifier is Controllable {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    uint256 public profitSharingNumerator;\\r\\n    uint256 public profitSharingDenominator;\\r\\n    address public rewardToken;\\r\\n\\r\\n    constructor(address _storage, address _rewardToken)\\r\\n        public\\r\\n        Controllable(_storage)\\r\\n    {\\r\\n        rewardToken = _rewardToken;\\r\\n        profitSharingNumerator = 0;\\r\\n        profitSharingDenominator = 100;\\r\\n        require(\\r\\n            profitSharingNumerator < profitSharingDenominator,\\r\\n            \\\"invalid profit share\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    event ProfitLogInReward(\\r\\n        uint256 profitAmount,\\r\\n        uint256 feeAmount,\\r\\n        uint256 timestamp\\r\\n    );\\r\\n\\r\\n    function notifyProfitInRewardToken(uint256 _rewardBalance) internal {\\r\\n        if (_rewardBalance > 0 && profitSharingNumerator > 0) {\\r\\n            uint256 feeAmount =\\r\\n                _rewardBalance.mul(profitSharingNumerator).div(\\r\\n                    profitSharingDenominator\\r\\n                );\\r\\n            emit ProfitLogInReward(_rewardBalance, feeAmount, block.timestamp);\\r\\n            IERC20(rewardToken).safeApprove(controller(), 0);\\r\\n            IERC20(rewardToken).safeApprove(controller(), feeAmount);\\r\\n\\r\\n            IController(controller()).notifyFee(rewardToken, feeAmount);\\r\\n        } else {\\r\\n            emit ProfitLogInReward(0, 0, block.timestamp);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setProfitSharingNumerator(uint256 _profitSharingNumerator)\\r\\n        external\\r\\n        onlyGovernance\\r\\n    {\\r\\n        profitSharingNumerator = _profitSharingNumerator;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/E/Defi/force/contracts/contracts/strategies/idle/IIdleTokenHelper.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\r\\n\\r\\ncontract IIdleTokenHelper {\\r\\n    function getMintingPrice(address idleYieldToken)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 mintingPrice);\\r\\n\\r\\n    function getRedeemPrice(address idleYieldToken)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 redeemPrice);\\r\\n\\r\\n    function getRedeemPrice(address idleYieldToken, address user)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 redeemPrice);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/E/Defi/force/contracts/contracts/strategies/idle/IdleFinanceStrategy.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\r\\nimport \\\"../../Controllable.sol\\\";\\r\\nimport \\\"../../interfaces/IStrategy.sol\\\";\\r\\nimport \\\"../../uniswap/interfaces/IUniswapV2Router02.sol\\\";\\r\\nimport \\\"./IdleToken.sol\\\";\\r\\nimport \\\"./IIdleTokenHelper.sol\\\";\\r\\nimport \\\"../RewardTokenProfitNotifier.sol\\\";\\r\\nimport \\\"../../interfaces/IVault.sol\\\";\\r\\n\\r\\ncontract IdleFinanceStrategy is IStrategy, RewardTokenProfitNotifier {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    event ProfitsNotCollected(address);\\r\\n    event Liquidating(address, uint256);\\r\\n\\r\\n    IERC20 public underlying;\\r\\n    address public idleUnderlying;\\r\\n    uint256 public virtualPrice;\\r\\n    IIdleTokenHelper public idleTokenHelper;\\r\\n\\r\\n    address public vault;\\r\\n    address public comp;\\r\\n    address public idle;\\r\\n\\r\\n    address[] public uniswapComp;\\r\\n    address[] public uniswapIdle;\\r\\n\\r\\n    address public uniswapRouterV2;\\r\\n\\r\\n    bool public sellComp;\\r\\n    bool public sellIdle;\\r\\n    bool public claimAllowed;\\r\\n    bool public protected;\\r\\n\\r\\n    // These tokens cannot be claimed by the controller\\r\\n    mapping(address => bool) public unsalvagableTokens;\\r\\n\\r\\n    modifier restricted() {\\r\\n        require(\\r\\n            msg.sender == vault ||\\r\\n                msg.sender == address(controller()) ||\\r\\n                msg.sender == address(governance()),\\r\\n            \\\"The sender has to be the controller or vault or governance\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier updateVirtualPrice() {\\r\\n        if (protected) {\\r\\n            require(\\r\\n                virtualPrice <= idleTokenHelper.getRedeemPrice(idleUnderlying),\\r\\n                \\\"virtual price is higher than needed\\\"\\r\\n            );\\r\\n        }\\r\\n        _;\\r\\n        virtualPrice = idleTokenHelper.getRedeemPrice(idleUnderlying);\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address _storage,\\r\\n        address _underlying,\\r\\n        address _idleUnderlying,\\r\\n        address _vault,\\r\\n        address _comp,\\r\\n        address _idle,\\r\\n        address _weth,\\r\\n        address _uniswap\\r\\n    ) public RewardTokenProfitNotifier(_storage, _idle) {\\r\\n        comp = _comp;\\r\\n        idle = _idle;\\r\\n        underlying = IERC20(_underlying);\\r\\n        idleUnderlying = _idleUnderlying;\\r\\n        vault = _vault;\\r\\n        uniswapRouterV2 = _uniswap;\\r\\n        protected = true;\\r\\n\\r\\n        // set these tokens to be not salvagable\\r\\n        unsalvagableTokens[_underlying] = true;\\r\\n        unsalvagableTokens[_idleUnderlying] = true;\\r\\n        unsalvagableTokens[_comp] = true;\\r\\n        unsalvagableTokens[_idle] = true;\\r\\n\\r\\n        uniswapComp = [_comp, _weth, _idle];\\r\\n        uniswapIdle = [_idle, _weth, _underlying];\\r\\n\\r\\n        idleTokenHelper = IIdleTokenHelper(\\r\\n            0x04Ce60ed10F6D2CfF3AA015fc7b950D13c113be5\\r\\n        );\\r\\n        virtualPrice = idleTokenHelper.getRedeemPrice(idleUnderlying);\\r\\n    }\\r\\n\\r\\n    function depositArbCheck() public view returns (bool) {\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * The strategy invests by supplying the underlying token into IDLE.\\r\\n     */\\r\\n    function investAllUnderlying() public restricted updateVirtualPrice {\\r\\n        uint256 balance = underlying.balanceOf(address(this));\\r\\n        underlying.safeApprove(address(idleUnderlying), 0);\\r\\n        underlying.safeApprove(address(idleUnderlying), balance);\\r\\n        IIdleTokenV3_1(idleUnderlying).mintIdleToken(balance, true, address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Exits IDLE and transfers everything to the vault.\\r\\n     */\\r\\n    function withdrawAllToVault() external restricted updateVirtualPrice {\\r\\n        withdrawAll();\\r\\n        IERC20(address(underlying)).safeTransfer(\\r\\n            vault,\\r\\n            underlying.balanceOf(address(this))\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Withdraws all from IDLE\\r\\n     */\\r\\n    function withdrawAll() internal {\\r\\n        uint256 balance = IERC20(idleUnderlying).balanceOf(address(this));\\r\\n\\r\\n        // this automatically claims the crops\\r\\n        IIdleTokenV3_1(idleUnderlying).redeemIdleToken(balance);\\r\\n\\r\\n        liquidateComp();\\r\\n        liquidateIdle();\\r\\n    }\\r\\n\\r\\n    function withdrawToVault(uint256 amountUnderlying) public restricted {\\r\\n        // this method is called when the vault is missing funds\\r\\n        // we will calculate the proportion of idle LP tokens that matches\\r\\n        // the underlying amount requested\\r\\n        uint256 balanceBefore = underlying.balanceOf(address(this));\\r\\n        uint256 totalIdleLpTokens =\\r\\n            IERC20(idleUnderlying).balanceOf(address(this));\\r\\n        uint256 totalUnderlyingBalance =\\r\\n            totalIdleLpTokens.mul(virtualPrice).div(1e18);\\r\\n        uint256 ratio = amountUnderlying.mul(1e18).div(totalUnderlyingBalance);\\r\\n        uint256 toRedeem = totalIdleLpTokens.mul(ratio).div(1e18);\\r\\n        IIdleTokenV3_1(idleUnderlying).redeemIdleToken(toRedeem);\\r\\n        uint256 balanceAfter = underlying.balanceOf(address(this));\\r\\n        underlying.safeTransfer(vault, balanceAfter.sub(balanceBefore));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Withdraws all assets, liquidates COMP, and invests again in the required ratio.\\r\\n     */\\r\\n    function forceUnleashed() public restricted updateVirtualPrice {\\r\\n        if (claimAllowed) {\\r\\n            claim();\\r\\n        }\\r\\n        liquidateComp();\\r\\n        liquidateIdle();\\r\\n\\r\\n        // this updates the virtual price\\r\\n        investAllUnderlying();\\r\\n\\r\\n        // state of supply/loan will be updated by the modifier\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Salvages a token.\\r\\n     */\\r\\n    function salvage(\\r\\n        address recipient,\\r\\n        address token,\\r\\n        uint256 amount\\r\\n    ) public onlyGovernance {\\r\\n        // To make sure that governance cannot come in and take away the coins\\r\\n        require(\\r\\n            !unsalvagableTokens[token],\\r\\n            \\\"token is defined as not salvagable\\\"\\r\\n        );\\r\\n        IERC20(token).safeTransfer(recipient, amount);\\r\\n    }\\r\\n\\r\\n    function claim() internal {\\r\\n        IIdleTokenV3_1(idleUnderlying).redeemIdleToken(0);\\r\\n    }\\r\\n\\r\\n    function liquidateComp() internal {\\r\\n        if (!sellComp) {\\r\\n            // Profits can be disabled for possible simplified and rapid exit\\r\\n            emit ProfitsNotCollected(comp);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // no profit notification, comp is liquidated to IDLE and will be notified there\\r\\n\\r\\n        uint256 compBalance = IERC20(comp).balanceOf(address(this));\\r\\n        if (compBalance > 0) {\\r\\n            emit Liquidating(address(comp), compBalance);\\r\\n            IERC20(comp).safeApprove(uniswapRouterV2, 0);\\r\\n            IERC20(comp).safeApprove(uniswapRouterV2, compBalance);\\r\\n            // we can accept 1 as the minimum because this will be called only by a trusted worker\\r\\n            IUniswapV2Router02(uniswapRouterV2).swapExactTokensForTokens(\\r\\n                compBalance,\\r\\n                1,\\r\\n                uniswapComp,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function liquidateIdle() internal {\\r\\n        if (!sellIdle) {\\r\\n            // Profits can be disabled for possible simplified and rapid exit\\r\\n            emit ProfitsNotCollected(idle);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 rewardBalance = IERC20(idle).balanceOf(address(this));\\r\\n        notifyProfitInRewardToken(rewardBalance);\\r\\n\\r\\n        uint256 idleBalance = IERC20(idle).balanceOf(address(this));\\r\\n        if (idleBalance > 0) {\\r\\n            emit Liquidating(address(idle), idleBalance);\\r\\n            IERC20(idle).safeApprove(uniswapRouterV2, 0);\\r\\n            IERC20(idle).safeApprove(uniswapRouterV2, idleBalance);\\r\\n            // we can accept 1 as the minimum because this will be called only by a trusted worker\\r\\n            IUniswapV2Router02(uniswapRouterV2).swapExactTokensForTokens(\\r\\n                idleBalance,\\r\\n                1,\\r\\n                uniswapIdle,\\r\\n                address(this),\\r\\n                block.timestamp\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns the current balance. Ignores COMP that was not liquidated and invested.\\r\\n     */\\r\\n    function investedUnderlyingBalance() public view returns (uint256) {\\r\\n        // NOTE: The use of virtual price is okay for appreciating assets inside IDLE,\\r\\n        // but would be wrong and exploitable if funds were lost by IDLE, indicated by\\r\\n        // the virtualPrice being greater than the token price.\\r\\n        if (protected) {\\r\\n            require(\\r\\n                virtualPrice <= idleTokenHelper.getRedeemPrice(idleUnderlying),\\r\\n                \\\"virtual price is higher than needed\\\"\\r\\n            );\\r\\n        }\\r\\n        uint256 invested =\\r\\n            IERC20(idleUnderlying)\\r\\n                .balanceOf(address(this))\\r\\n                .mul(virtualPrice)\\r\\n                .div(1e18);\\r\\n        return invested.add(IERC20(underlying).balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    function setLiquidation(\\r\\n        bool _sellComp,\\r\\n        bool _sellIdle,\\r\\n        bool _claimAllowed\\r\\n    ) public onlyGovernance {\\r\\n        sellComp = _sellComp;\\r\\n        sellIdle = _sellIdle;\\r\\n        claimAllowed = _claimAllowed;\\r\\n    }\\r\\n\\r\\n    function setProtected(bool _protected) public onlyGovernance {\\r\\n        protected = _protected;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/E/Defi/force/contracts/contracts/strategies/idle/IdleStrategyUSDCMainnet.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\r\\nimport \\\"./IdleFinanceStrategy.sol\\\";\\r\\n\\r\\n/**\\r\\n * Adds the mainnet addresses to the PickleStrategy3Pool\\r\\n */\\r\\ncontract IdleStrategyUSDCMainnet is IdleFinanceStrategy {\\r\\n    // token addresses\\r\\n    address public constant __weth =\\r\\n        address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\r\\n    address public constant __usdc =\\r\\n        address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\\r\\n    address public constant __uniswap =\\r\\n        address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n    address public constant __idleUnderlying =\\r\\n        address(0x5274891bEC421B39D23760c04A6755eCB444797C);\\r\\n    address public constant __comp =\\r\\n        address(0xc00e94Cb662C3520282E6f5717214004A7f26888);\\r\\n    address public constant __idle =\\r\\n        address(0x875773784Af8135eA0ef43b5a374AaD105c5D39e);\\r\\n\\r\\n    constructor(address _storage, address _vault)\\r\\n        public\\r\\n        IdleFinanceStrategy(\\r\\n            _storage,\\r\\n            __usdc,\\r\\n            __idleUnderlying,\\r\\n            _vault,\\r\\n            __comp,\\r\\n            __idle,\\r\\n            __weth,\\r\\n            __uniswap\\r\\n        )\\r\\n    {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"/E/Defi/force/contracts/contracts/strategies/idle/IdleToken.sol\": {\r\n      \"content\": \"/**\\r\\n * @title: Idle Token interface\\r\\n * @author: Idle Labs Inc., idle.finance\\r\\n */\\r\\npragma solidity 0.5.16;\\r\\n\\r\\ninterface IIdleTokenV3_1 {\\r\\n    // view\\r\\n    /**\\r\\n     * IdleToken price calculation, in underlying\\r\\n     *\\r\\n     * @return : price in underlying token\\r\\n     */\\r\\n    function tokenPrice() external view returns (uint256 price);\\r\\n\\r\\n    /**\\r\\n     * @return : underlying token address\\r\\n     */\\r\\n    function token() external view returns (address);\\r\\n\\r\\n    /**\\r\\n     * Get APR of every ILendingProtocol\\r\\n     *\\r\\n     * @return addresses: array of token addresses\\r\\n     * @return aprs: array of aprs (ordered in respect to the `addresses` array)\\r\\n     */\\r\\n    function getAPRs()\\r\\n        external\\r\\n        view\\r\\n        returns (address[] memory addresses, uint256[] memory aprs);\\r\\n\\r\\n    // external\\r\\n    // We should save the amount one has deposited to calc interests\\r\\n\\r\\n    /**\\r\\n     * Used to mint IdleTokens, given an underlying amount (eg. DAI).\\r\\n     * This method triggers a rebalance of the pools if needed\\r\\n     * NOTE: User should 'approve' _amount of tokens before calling mintIdleToken\\r\\n     * NOTE 2: this method can be paused\\r\\n     *\\r\\n     * @param _amount : amount of underlying token to be lended\\r\\n     * @param _skipRebalance : flag for skipping rebalance for lower gas price\\r\\n     * @param _referral : referral address\\r\\n     * @return mintedTokens : amount of IdleTokens minted\\r\\n     */\\r\\n    function mintIdleToken(\\r\\n        uint256 _amount,\\r\\n        bool _skipRebalance,\\r\\n        address _referral\\r\\n    ) external returns (uint256 mintedTokens);\\r\\n\\r\\n    /**\\r\\n     * Here we calc the pool share one can withdraw given the amount of IdleToken they want to burn\\r\\n     * This method triggers a rebalance of the pools if needed\\r\\n     * NOTE: If the contract is paused or iToken price has decreased one can still redeem but no rebalance happens.\\r\\n     * NOTE 2: If iToken price has decresed one should not redeem (but can do it) otherwise he would capitalize the loss.\\r\\n     *         Ideally one should wait until the black swan event is terminated\\r\\n     *\\r\\n     * @param _amount : amount of IdleTokens to be burned\\r\\n     * @return redeemedTokens : amount of underlying tokens redeemed\\r\\n     */\\r\\n    function redeemIdleToken(uint256 _amount)\\r\\n        external\\r\\n        returns (uint256 redeemedTokens);\\r\\n\\r\\n    /**\\r\\n     * Here we calc the pool share one can withdraw given the amount of IdleToken they want to burn\\r\\n     * and send interest-bearing tokens (eg. cDAI/iDAI) directly to the user.\\r\\n     * Underlying (eg. DAI) is not redeemed here.\\r\\n     *\\r\\n     * @param _amount : amount of IdleTokens to be burned\\r\\n     */\\r\\n    function redeemInterestBearingTokens(uint256 _amount) external;\\r\\n\\r\\n    /**\\r\\n     * @return : whether has rebalanced or not\\r\\n     */\\r\\n    function rebalance() external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/E/Defi/force/contracts/contracts/uniswap/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 amountA,\\r\\n            uint256 amountB,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountETH,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactETHForTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactETH(\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETH(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapETHForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function quote(\\r\\n        uint256 amountA,\\r\\n        uint256 reserveA,\\r\\n        uint256 reserveB\\r\\n    ) external pure returns (uint256 amountB);\\r\\n\\r\\n    function getAmountOut(\\r\\n        uint256 amountIn,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) external pure returns (uint256 amountOut);\\r\\n\\r\\n    function getAmountIn(\\r\\n        uint256 amountOut,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) external pure returns (uint256 amountIn);\\r\\n\\r\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory amounts);\\r\\n\\r\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory amounts);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/E/Defi/force/contracts/contracts/uniswap/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\r\\n\\r\\nimport \\\"./IUniswapV2Router01.sol\\\";\\r\\n\\r\\ninterface IUniswapV2Router02 {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 amountA,\\r\\n            uint256 amountB,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountETH,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactETHForTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapTokensForExactETH(\\r\\n        uint256 amountOut,\\r\\n        uint256 amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForETH(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapETHForExactTokens(\\r\\n        uint256 amountOut,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function quote(\\r\\n        uint256 amountA,\\r\\n        uint256 reserveA,\\r\\n        uint256 reserveB\\r\\n    ) external pure returns (uint256 amountB);\\r\\n\\r\\n    function getAmountOut(\\r\\n        uint256 amountIn,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) external pure returns (uint256 amountOut);\\r\\n\\r\\n    function getAmountIn(\\r\\n        uint256 amountOut,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) external pure returns (uint256 amountIn);\\r\\n\\r\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory amounts);\\r\\n\\r\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory amounts);\\r\\n\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountETH);\\r\\n\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline,\\r\\n        bool approveMax,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Optional functions from the ERC20 standard.\\n */\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\\n     * these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following \\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_storage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Liquidating\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profitAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ProfitLogInReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ProfitsNotCollected\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"__comp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"__idle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"__idleUnderlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"__uniswap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"__usdc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"__weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"comp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositArbCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"forceUnleashed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"idle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"idleTokenHelper\",\"outputs\":[{\"internalType\":\"contract IIdleTokenHelper\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"idleUnderlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"investAllUnderlying\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investedUnderlyingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profitSharingDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profitSharingNumerator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"protected\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"salvage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellComp\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellIdle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_sellComp\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_sellIdle\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_claimAllowed\",\"type\":\"bool\"}],\"name\":\"setLiquidation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_profitSharingNumerator\",\"type\":\"uint256\"}],\"name\":\"setProfitSharingNumerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_protected\",\"type\":\"bool\"}],\"name\":\"setProtected\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_store\",\"type\":\"address\"}],\"name\":\"setStorage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"store\",\"outputs\":[{\"internalType\":\"contract Storage\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uniswapComp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uniswapIdle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"uniswapRouterV2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"unsalvagableTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"virtualPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAllToVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountUnderlying\",\"type\":\"uint256\"}],\"name\":\"withdrawToVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "IdleStrategyUSDCMainnet", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000837b73e6e8f04e3e4685c41b9a8c6f2bebc9e70f00000000000000000000000051654a8c04e97424724e1643d468b51924f6c40f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}