{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ICE64Renderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\n/*\\n\\n\\n        .++++++    .-=+**++=:  -+++++++++++-      .-=+**.     .++++:      \\n         :@@@@. .+%@#++++#@@@@#=*@@@%++*@@@*   :*@@%+=-:      +@@@+       \\n          %@@# +@@+        :#@@#.@@@=    :#+ .#@@*.          -@@@+        \\n          #@@#*@@=           *@# @@@@-      -@@@*+*+=-      :@@@= =       \\n          #@@@@@@             += @@@@@@%%%=:@@@@*++#@@@#:  :@@@--%#       \\n          #@@@@@@                @@@= -*@@=#@@@     .*@@@--@@# +@@#   =   \\n          #@@@@@@-               @@@=    :.@@@%       #@@@@@+..+@@%-*@@   \\n          #@@#%@@@-           .%@@@@=      #@@@:      -@@@@@@@@@@@@@@@@   \\n          %@@# #@@@#-       :+@%-@@@=     :%@@@%.     *@@+     +@@%       \\n         :@@@@. :*@@@@%###%@@#= +@@@#++#%@@@**@@@#=-=%@%-     .@@@@-      \\n        .*****+    :=*###*+-.  -************:  -*###*=:      :******=\\n\\n        M E T A D A T A   &   R E N D E R I N G   C O N T R A C T\\n\\n*/\\n\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport {DynamicBuffer} from \\\"@divergencetech/ethier/contracts/utils/DynamicBuffer.sol\\\";\\nimport {Base64} from \\\"./Base64.sol\\\";\\n\\nimport {IICE64} from \\\"./interfaces/IICE64.sol\\\";\\nimport {IICE64DataStore} from \\\"./interfaces/IICE64DataStore.sol\\\";\\nimport {IICE64Renderer} from \\\"./interfaces/IICE64Renderer.sol\\\";\\nimport {IExquisiteGraphics} from \\\"./interfaces/IExquisiteGraphics.sol\\\";\\n\\n/**\\n@title ICE64 Renderer\\n@author Sam King (samkingstudio.eth)\\n@notice This contract renders token metadata for the main ICE64 contract: a standard baseURI\\n        for original photos stored off-chain, and base64 encoded on-chain SVGs for editions.\\n\\n        Code is licensed as MIT.\\n        https://spdx.org/licenses/MIT.html\\n\\n        Token metadata and images licensed as CC BY-NC 4.0\\n        https://creativecommons.org/licenses/by-nc/4.0/\\n        You are free to:\\n            - Share: copy and redistribute the material in any medium or format\\n            - Adapt: remix, transform, and build upon the material\\n        Under the following terms:\\n            - Attribution: You must give appropriate credit, provide a link to the license,\\n            and indicate if changes were made. You may do so in any reasonable manner, but not\\n            in any way that suggests the licensor endorses you or your use.\\n            - NonCommercial: You may not use the material for commercial purposes\\n            - No additional restrictions: You may not apply legal terms or technological measures\\n            that legally restrict others from doing anything the license permits.\\n\\n*/\\ncontract ICE64Renderer is IICE64Renderer {\\n    using Strings for uint256;\\n    using DynamicBuffer for bytes;\\n\\n    /* ------------------------------------------------------------------------\\n                                   S T O R A G E\\n    ------------------------------------------------------------------------ */\\n\\n    /// @dev The address of the token ownership contract\\n    IICE64 public ice64;\\n\\n    /// @dev The address of the on-chain data storage contract\\n    IICE64DataStore public dataStore;\\n\\n    /// @dev The address of the xqstgfx public rendering contract\\n    IExquisiteGraphics public xqstgfx;\\n\\n    /* ------------------------------------------------------------------------\\n                                      I N I T\\n    ------------------------------------------------------------------------ */\\n\\n    /// @param ice64_ The address of the token ownership contract\\n    /// @param ice64DataStore_ The address of the on-chain data storage contract\\n    /// @param xqstgfx_ The address of the xqstgfx public rendering contract\\n    constructor(\\n        address ice64_,\\n        address ice64DataStore_,\\n        address xqstgfx_\\n    ) {\\n        ice64 = IICE64(ice64_);\\n        dataStore = IICE64DataStore(ice64DataStore_);\\n        xqstgfx = IExquisiteGraphics(payable(xqstgfx_));\\n    }\\n\\n    /* ------------------------------------------------------------------------\\n                             R A W   R E N D E R I N G\\n    ------------------------------------------------------------------------ */\\n\\n    /// @notice Draws an SVG from data in the .xqst format to a string\\n    /// @param data The photo data in .xqst format\\n    function drawSVGToString(bytes memory data) public view returns (string memory) {\\n        return string(drawSVGToBytes(data));\\n    }\\n\\n    /// @notice Draws an SVG from data in the .xqst format to bytes\\n    /// @param data The photo data in .xqst format\\n    function drawSVGToBytes(bytes memory data) public view returns (bytes memory) {\\n        string memory rects = xqstgfx.drawPixelsUnsafe(data);\\n        bytes memory svg = DynamicBuffer.allocate(2**19);\\n\\n        svg.appendSafe(\\n            abi.encodePacked(\\n                '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" shape-rendering=\\\"crispEdges\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 128 128\\\" fill=\\\"#fff\\\"><rect width=\\\"128\\\" height=\\\"128\\\" fill=\\\"#fff\\\" /><g transform=\\\"translate(32,32)\\\">',\\n                rects,\\n                \\\"</g></svg>\\\"\\n            )\\n        );\\n\\n        return svg;\\n    }\\n\\n    /* ------------------------------------------------------------------------\\n                 P U B L I C   F R I E N D L Y   R E N D E R I N G\\n    ------------------------------------------------------------------------ */\\n\\n    /// @notice Gets a photo in SVG format\\n    /// @param id The id of the photo to render\\n    function getEditionPhotoSVG(uint256 id) external view returns (string memory) {\\n        bytes memory data = dataStore.getRawPhotoData(id);\\n        return drawSVGToString(data);\\n    }\\n\\n    /// @notice Gets a photo in Base64 encoded SVG format\\n    /// @param id The id of the photo to render (use original photo's id: `getEditionId(id)`)\\n    function getEditionPhotoBase64SVG(uint256 id) external view returns (string memory) {\\n        bytes memory data = dataStore.getRawPhotoData(id);\\n        bytes memory svg = drawSVGToBytes(data);\\n        bytes memory svgBase64 = DynamicBuffer.allocate(2**19);\\n\\n        svgBase64.appendSafe(\\\"data:image/svg+xml;base64,\\\");\\n        svgBase64.appendSafe(bytes(Base64.encode(svg)));\\n\\n        return string(svgBase64);\\n    }\\n\\n    /* ------------------------------------------------------------------------\\n                         O N - C H A I N   T O K E N U R I\\n    ------------------------------------------------------------------------ */\\n\\n    /// @notice Renders metadata for a given token id\\n    /// @dev If the photo is an edition, then render an SVG, otherwise return the constructed URI\\n    /// @param id The token id to render\\n    function tokenURI(uint256 id) external view returns (string memory) {\\n        if (!ice64.isEdition(id)) {\\n            return string(abi.encodePacked(dataStore.getBaseURI(), id.toString()));\\n        }\\n\\n        uint256 originalId = ice64.getOriginalTokenId(id);\\n        string memory originalIdStr = originalId.toString();\\n\\n        bytes memory data = dataStore.getRawPhotoData(originalId);\\n        bytes memory svg = drawSVGToBytes(data);\\n\\n        bytes memory svgBase64 = DynamicBuffer.allocate(2**19);\\n        svgBase64.appendSafe(\\\"data:image/svg+xml;base64,\\\");\\n        svgBase64.appendSafe(bytes(Base64.encode(svg)));\\n\\n        bytes memory json = DynamicBuffer.allocate(2**19);\\n        bytes memory jsonBase64 = DynamicBuffer.allocate(2**19);\\n\\n        json.appendSafe(\\n            abi.encodePacked(\\n                '{\\\"symbol\\\":\\\"ICE64\\\",\\\"name\\\":\\\"ICE64 #',\\n                originalIdStr,\\n                ' (Edition)\\\",\\\"description\\\":\\\"A fully on-chain edition of ICE64 #',\\n                originalIdStr,\\n                \\\". Edition size of \\\",\\n                ice64.getMaxEditions().toString(),\\n                '. Each edition is 64x64px in size with a 32px border, 64 colors, and stored on the Ethereum blockchain forever.\\\",\\\"image\\\":\\\"',\\n                string(svgBase64),\\n                '\\\",\\\"external_url\\\":\\\"https://ice64.com/photo/',\\n                id.toString(),\\n                '\\\",\\\"attributes\\\":[{\\\"trait_type\\\":\\\"Size\\\",\\\"value\\\":\\\"64x64px\\\"},{\\\"trait_type\\\":\\\"Border\\\",\\\"value\\\":\\\"32px\\\"},{\\\"trait_type\\\":\\\"Colors\\\",\\\"value\\\":\\\"64\\\"}]}'\\n            )\\n        );\\n\\n        jsonBase64.appendSafe(\\\"data:application/json;base64,\\\");\\n        jsonBase64.appendSafe(bytes(Base64.encode(json)));\\n\\n        return string(jsonBase64);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@divergencetech/ethier/contracts/utils/DynamicBuffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (c) 2021 the ethier authors (github.com/divergencetech/ethier)\\n\\npragma solidity >=0.8.0;\\n\\n/// @title DynamicBuffer\\n/// @author David Huber (@cxkoda) and Simon Fremaux (@dievardump). See also\\n///         https://raw.githubusercontent.com/dievardump/solidity-dynamic-buffer\\n/// @notice This library is used to allocate a big amount of container memory\\n//          which will be subsequently filled without needing to reallocate\\n///         memory.\\n/// @dev First, allocate memory.\\n///      Then use `buffer.appendUnchecked(theBytes)` or `appendSafe()` if\\n///      bounds checking is required.\\nlibrary DynamicBuffer {\\n    /// @notice Allocates container space for the DynamicBuffer\\n    /// @param capacity The intended max amount of bytes in the buffer\\n    /// @return buffer The memory location of the buffer\\n    /// @dev Allocates `capacity + 0x60` bytes of space\\n    ///      The buffer array starts at the first container data position,\\n    ///      (i.e. `buffer = container + 0x20`)\\n    function allocate(uint256 capacity)\\n        internal\\n        pure\\n        returns (bytes memory buffer)\\n    {\\n        assembly {\\n            // Get next-free memory address\\n            let container := mload(0x40)\\n\\n            // Allocate memory by setting a new next-free address\\n            {\\n                // Add 2 x 32 bytes in size for the two length fields\\n                // Add 32 bytes safety space for 32B chunked copy\\n                let size := add(capacity, 0x60)\\n                let newNextFree := add(container, size)\\n                mstore(0x40, newNextFree)\\n            }\\n\\n            // Set the correct container length\\n            {\\n                let length := add(capacity, 0x40)\\n                mstore(container, length)\\n            }\\n\\n            // The buffer starts at idx 1 in the container (0 is length)\\n            buffer := add(container, 0x20)\\n\\n            // Init content with length 0\\n            mstore(buffer, 0)\\n        }\\n\\n        return buffer;\\n    }\\n\\n    /// @notice Appends data to buffer, and update buffer length\\n    /// @param buffer the buffer to append the data to\\n    /// @param data the data to append\\n    /// @dev Does not perform out-of-bound checks (container capacity)\\n    ///      for efficiency.\\n    function appendUnchecked(bytes memory buffer, bytes memory data)\\n        internal\\n        pure\\n    {\\n        assembly {\\n            let length := mload(data)\\n            for {\\n                data := add(data, 0x20)\\n                let dataEnd := add(data, length)\\n                let copyTo := add(buffer, add(mload(buffer), 0x20))\\n            } lt(data, dataEnd) {\\n                data := add(data, 0x20)\\n                copyTo := add(copyTo, 0x20)\\n            } {\\n                // Copy 32B chunks from data to buffer.\\n                // This may read over data array boundaries and copy invalid\\n                // bytes, which doesn't matter in the end since we will\\n                // later set the correct buffer length, and have allocated an\\n                // additional word to avoid buffer overflow.\\n                mstore(copyTo, mload(data))\\n            }\\n\\n            // Update buffer length\\n            mstore(buffer, add(mload(buffer), length))\\n        }\\n    }\\n\\n    /// @notice Appends data to buffer, and update buffer length\\n    /// @param buffer the buffer to append the data to\\n    /// @param data the data to append\\n    /// @dev Performs out-of-bound checks and calls `appendUnchecked`.\\n    function appendSafe(bytes memory buffer, bytes memory data) internal pure {\\n        uint256 capacity;\\n        uint256 length;\\n        assembly {\\n            capacity := sub(mload(sub(buffer, 0x20)), 0x40)\\n            length := mload(buffer)\\n        }\\n\\n        require(\\n            length + data.length <= capacity,\\n            \\\"DynamicBuffer: Appending out of bounds.\\\"\\n        );\\n        appendUnchecked(buffer, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.2;\\n\\n/// [MIT License]\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\nlibrary Base64 {\\n    bytes internal constant TABLE =\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IICE64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.14;\\n\\ninterface IICE64 {\\n    function getOriginalTokenId(uint256 editionId) external pure returns (uint256);\\n\\n    function getEditionTokenId(uint256 id) external pure returns (uint256);\\n\\n    function getMaxEditions() external view returns (uint256);\\n\\n    function isEdition(uint256 id) external pure returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IICE64DataStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.14;\\n\\ninterface IICE64DataStore {\\n    function getBaseURI() external view returns (string memory);\\n\\n    function getRawPhotoData(uint256 id) external view returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IICE64Renderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.14;\\n\\ninterface IICE64Renderer {\\n    function drawSVGToString(bytes memory data) external view returns (string memory);\\n\\n    function drawSVGToBytes(bytes memory data) external view returns (bytes memory);\\n\\n    function tokenURI(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IExquisiteGraphics.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface IExquisiteGraphics {\\n    struct Header {\\n        /* HEADER START */\\n        uint8 version; // 8 bits\\n        uint16 width; // 8 bits\\n        uint16 height; // 8 bits\\n        uint16 numColors; // 16 bits\\n        uint8 backgroundColorIndex; // 8 bits\\n        uint16 scale; // 10 bits\\n        uint8 reserved; // 4 bits\\n        bool alpha; // 1 bit\\n        bool hasBackground; // 1 bit\\n        /* HEADER END */\\n\\n        /* CALCULATED DATA START */\\n        uint24 totalPixels; // total pixels in the image\\n        uint8 bitsPerPixel; // bits per pixel\\n        uint8 pixelsPerByte; // pixels per byte\\n        uint16 paletteStart; // number of the byte where the palette starts\\n        uint16 dataStart; // number of the byte where the data starts\\n        /* CALCULATED DATA END */\\n    }\\n\\n    struct DrawContext {\\n        bytes data; // the binary data in .xqst format\\n        Header header; // the header of the data\\n        string[] palette; // hex color for each color in the image\\n        uint8[] pixels; // color index (in the palette) for a pixel\\n    }\\n\\n    error ExceededMaxPixels();\\n    error ExceededMaxRows();\\n    error ExceededMaxColumns();\\n    error ExceededMaxColors();\\n    error BackgroundColorIndexOutOfRange();\\n    error PixelColorIndexOutOfRange();\\n    error MissingHeader();\\n    error NotEnoughData();\\n\\n    /// @notice Draw an SVG from the provided data\\n    /// @param data Binary data in the .xqst format.\\n    /// @return string the <svg>\\n    function draw(bytes memory data) external pure returns (string memory);\\n\\n    /// @notice Draw an SVG from the provided data. No validation.\\n    /// @param data Binary data in the .xqst format.\\n    /// @return string the <svg>\\n    function drawUnsafe(bytes memory data) external pure returns (string memory);\\n\\n    /// @notice Draw the <rect> elements of an SVG from the data\\n    /// @param data Binary data in the .xqst format.\\n    /// @return string the <rect> elements\\n    function drawPixels(bytes memory data) external pure returns (string memory);\\n\\n    /// @notice Draw the <rect> elements of an SVG from the data. No validation\\n    /// @param data Binary data in the .xqst format.\\n    /// @return string the <rect> elements\\n    function drawPixelsUnsafe(bytes memory data) external pure returns (string memory);\\n\\n    /// @notice validates if the given data is a valid .xqst file\\n    /// @param data Binary data in the .xqst format.\\n    /// @return bool true if the data is valid\\n    function validate(bytes memory data) external pure returns (bool);\\n\\n    // Check if the header of some data is an XQST Graphics Compatible file\\n    /// @notice validates the header for some data is a valid .xqst header\\n    /// @param data Binary data in the .xqst format.\\n    /// @return bool true if the header is valid\\n    function validateHeader(bytes memory data) external pure returns (bool);\\n\\n    /// @notice Decodes the header from a binary .xqst blob\\n    /// @param data Binary data in the .xqst format.\\n    /// @return Header the decoded header\\n    function decodeHeader(bytes memory data) external pure returns (Header memory);\\n\\n    /// @notice Decodes the palette from a binary .xqst blob\\n    /// @param data Binary data in the .xqst format.\\n    /// @return bytes8[] the decoded palette\\n    function decodePalette(bytes memory data) external pure returns (string[] memory);\\n\\n    /// @notice Decodes all of the data needed to draw an SVG from the .xqst file\\n    /// @param data Binary data in the .xqst format.\\n    /// @return ctx The Draw Context containing all of the decoded data\\n    function decodeDrawContext(bytes memory data) external pure returns (DrawContext memory ctx);\\n\\n    /// @notice A way to say \\\"Thank You\\\"\\n    function ty() external payable;\\n\\n    /// @notice A way to say \\\"Thank You\\\"\\n    function ty(string memory message) external payable;\\n\\n    /// @notice Able to receive ETH from anyone\\n    receive() external payable;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ice64_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ice64DataStore_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"xqstgfx_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"dataStore\",\"outputs\":[{\"internalType\":\"contract IICE64DataStore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"drawSVGToBytes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"drawSVGToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getEditionPhotoBase64SVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getEditionPhotoSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ice64\",\"outputs\":[{\"internalType\":\"contract IICE64\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xqstgfx\",\"outputs\":[{\"internalType\":\"contract IExquisiteGraphics\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ICE64Renderer", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000006d36745510dc7a75570755b295694e8ec625b7d200000000000000000000000067fca1a4f04093a927af648f1f4ca337521bda37000000000000000000000000df01a4040493b514605392620b3a0a05eb8cd295", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}