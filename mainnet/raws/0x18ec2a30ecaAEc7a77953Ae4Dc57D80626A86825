{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/Zomta721.sol\": {\r\n      \"content\": \"/**\\n *Submitted for verification at Etherscan.io on 2022-02-11\\n*/\\n\\n// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.4;\\n\\ninterface IERC165 {\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n    */\\n\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n*/\\n\\ninterface IERC721 is IERC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of NFTs in `owner`'s account.\\n    */\\n    function royaltyFee(uint256 tokenId) external view returns(uint256);\\n    function getCreator(uint256 tokenId) external view returns(address);\\n\\n    /**\\n     * @dev Returns the owner of the NFT specified by `tokenId`.\\n     */\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     *\\n     *\\n     * Requirements:\\n     * - `from`, `to` cannot be zero.\\n     * - `tokenId` must be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this\\n     * NFT by either {approve} or {setApprovalForAll}.\\n     */\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n    function contractOwner() external view returns(address owner);\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n    function mintAndTransfer(address from, address to, uint256 itemId, uint256 fee, string memory _tokenURI, bytes memory data)external returns(uint256);\\n\\n}\\n\\ninterface IERC1155 is IERC165 {\\n\\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n    event URI(string _value, uint256 indexed _id);\\n    \\n\\n    /**\\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \\\"Approval\\\" section of the standard).\\n        MUST revert if `_to` is the zero address.\\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\\n        MUST revert on any other error.\\n        MUST emit the `TransferSingle` event to reflect the balance change (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \\\"Safe Transfer Rules\\\" section of the standard).\\n        @param _from    Source address\\n        @param _to      Target address\\n        @param _id      ID of the token type\\n        @param _value   Transfer amount\\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\\n    */\\n\\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\\n    function royaltyFee(uint256 tokenId) external view returns(uint256);\\n    function getCreator(uint256 tokenId) external view returns(address);\\n    function mintAndTransfer(address from, address to, uint256 itemId, uint256 fee, uint256 _supply, string memory _tokenURI, uint256 qty, bytes memory data)external returns(uint256);\\n}\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n*/\\n\\ninterface IERC20 {\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n    */\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n    */\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n    */\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n    */\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n    */\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n    */ \\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\n\\nlibrary SafeMath {\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */    \\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */    \\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow. \\n     */    \\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */    \\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */    \\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n}    \\n\\ncontract TransferProxy {\\n\\n    function erc721safeTransferFrom(IERC721 token, address from, address to, uint256 tokenId) external  {\\n        token.safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    function erc1155safeTransferFrom(IERC1155 token, address from, address to, uint256 id, uint256 value, bytes calldata data) external  {\\n        token.safeTransferFrom(from, to, id, value, data);\\n    }\\n    \\n    function erc20safeTransferFrom(IERC20 token, address from, address to, uint256 value) external  {\\n        require(token.transferFrom(from, to, value), \\\"failure while transferring\\\");\\n    }\\n\\n    function erc721mintAndTransfer(IERC721 token, address from, address to, uint256 tokenId, uint256 fee, string memory tokenURI, bytes calldata data) external {\\n        token.mintAndTransfer(from, to,tokenId, fee, tokenURI, data);\\n    }\\n\\n    function erc1155mintAndTransfer(IERC1155 token, address from, address to, uint256 tokenId, uint256 fee , uint256 supply, string memory tokenURI, uint256 qty, bytes calldata data) external {\\n        token.mintAndTransfer(from, to, tokenId, fee, supply, tokenURI, qty, data);\\n    }  \\n}\\n\\ncontract Trade {\\n    using SafeMath for uint256;\\n\\n    enum BuyingAssetType {ERC1155, ERC721 , LazyMintERC1155, LazyMintERC721}\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    event SellerFee(uint8 sellerFee);\\n    event BuyerFee(uint8 buyerFee);\\n    event BuyAsset(address indexed assetOwner , uint256 indexed tokenId, uint256 quantity, address indexed buyer);\\n    event ExecuteBid(address indexed assetOwner , uint256 indexed tokenId, uint256 quantity, address indexed buyer);\\n\\n    uint8 private buyerFeePermille;\\n    uint8 private sellerFeePermille;\\n    TransferProxy public transferProxy;\\n    address public owner;\\n    mapping(uint256 => bool) private usedNonce;\\n\\n    struct Fee {\\n        uint platformFee;\\n        uint assetFee;\\n        uint royaltyFee;\\n        uint price;\\n        address tokenCreator;\\n    }\\n\\n\\n\\n    /* An ECDSA signature. */\\n    struct Sign {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        uint256 nonce;\\n    }\\n\\n    struct Order {\\n        address seller;\\n        address buyer;\\n        address erc20Address;\\n        address nftAddress;\\n        BuyingAssetType nftType;\\n        uint unitPrice;\\n        uint amount;\\n        uint tokenId;\\n        uint256 supply;\\n        string tokenURI;\\n        uint256 fee;\\n        uint qty;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n    receive() external payable {}\\n\\n    constructor (uint8 _buyerFee, uint8 _sellerFee, TransferProxy _transferProxy) {\\n        buyerFeePermille = _buyerFee;\\n        sellerFeePermille = _sellerFee;\\n        transferProxy = _transferProxy;\\n        owner = msg.sender;\\n    }\\n\\n    function buyerServiceFee() public view virtual returns (uint8) {\\n        return buyerFeePermille;\\n    }\\n\\n    function sellerServiceFee() public view virtual returns (uint8) {\\n        return sellerFeePermille;\\n    }\\n\\n    function setBuyerServiceFee(uint8 _buyerFee) public onlyOwner returns(bool) {\\n        buyerFeePermille = _buyerFee;\\n        emit BuyerFee(buyerFeePermille);\\n        return true;\\n    }\\n\\n    function setSellerServiceFee(uint8 _sellerFee) public onlyOwner returns(bool) {\\n        sellerFeePermille = _sellerFee;\\n        emit SellerFee(sellerFeePermille);\\n        return true;\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner returns(bool){\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n        return true;\\n    }\\n\\n    function getSigner(bytes32 hash, Sign memory sign) internal pure returns(address) {\\n        return ecrecover(keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)), sign.v, sign.r, sign.s);\\n    }\\n\\n    function verifySellerSign(address seller, uint256 tokenId, uint amount, address paymentAssetAddress, address assetAddress, Sign memory sign) internal pure {\\n        bytes32 hash = keccak256(abi.encodePacked(assetAddress, tokenId, paymentAssetAddress, amount, sign.nonce));\\n        require(seller == getSigner(hash, sign), \\\"seller sign verification failed\\\");\\n    }\\n\\n    function verifyBuyerSign(address buyer, uint256 tokenId, uint amount, address paymentAssetAddress, address assetAddress, uint qty, Sign memory sign) internal pure {\\n        bytes32 hash = keccak256(abi.encodePacked(assetAddress, tokenId, paymentAssetAddress, amount, qty, sign.nonce));\\n        require(buyer == getSigner(hash, sign), \\\"buyer sign verification failed\\\");\\n    }\\n\\n    function verifyOwnerSign(address buyingAssetAddress,address seller,string memory tokenURI, Sign memory sign) internal view {\\n        address _owner = IERC721(buyingAssetAddress).contractOwner();\\n        bytes32 hash = keccak256(abi.encodePacked(address(this), seller, tokenURI, sign.nonce ));\\n        require(_owner == getSigner(hash, sign), \\\"Owner sign verification failed\\\");\\n    }\\n\\n\\n\\n    function getFees( Order memory order) internal view returns(Fee memory){\\n        address tokenCreator;\\n        uint platformFee;\\n        uint royaltyFee;\\n        uint assetFee;\\n        uint royaltyPermille;\\n        uint price = order.amount.mul(1000).div((1000+buyerFeePermille));\\n        uint buyerFee = order.amount.sub(price);\\n        uint sellerFee = price.mul(sellerFeePermille).div(1000);\\n        platformFee = buyerFee.add(sellerFee);\\n        if(order.nftType == BuyingAssetType.ERC721) {\\n            royaltyPermille = ((IERC721(order.nftAddress).royaltyFee(order.tokenId)));\\n            tokenCreator = ((IERC721(order.nftAddress).getCreator(order.tokenId)));\\n        }\\n        if(order.nftType == BuyingAssetType.ERC1155)  {\\n            royaltyPermille = ((IERC1155(order.nftAddress).royaltyFee(order.tokenId)));\\n            tokenCreator = ((IERC1155(order.nftAddress).getCreator(order.tokenId)));\\n        }\\n        if(order.nftType == BuyingAssetType.LazyMintERC721) {\\n            royaltyPermille = order.fee;\\n            tokenCreator = order.seller;\\n        }\\n        if(order.nftType == BuyingAssetType.LazyMintERC1155) {\\n            royaltyPermille = order.fee;\\n            tokenCreator = order.seller;\\n        }\\n        royaltyFee = price.mul(royaltyPermille).div(1000);\\n        assetFee = price.sub(royaltyFee).sub(sellerFee);\\n        return Fee(platformFee, assetFee, royaltyFee, price, tokenCreator);\\n    }\\n\\n    function tradeAsset(Order memory order, Fee memory fee) internal virtual {\\n        \\n        if(order.nftType == BuyingAssetType.ERC721) {\\n            transferProxy.erc721safeTransferFrom(IERC721(order.nftAddress), order.seller, order.buyer, order.tokenId);\\n        }\\n        if(order.nftType == BuyingAssetType.ERC1155)  {\\n            transferProxy.erc1155safeTransferFrom(IERC1155(order.nftAddress), order.seller, order.buyer, order.tokenId, order.qty, \\\"\\\"); \\n        }\\n        if(order.nftType == BuyingAssetType.LazyMintERC721){\\n            transferProxy.erc721mintAndTransfer(IERC721(order.nftAddress), order.seller, order.buyer, order.tokenId, order.fee,order.tokenURI,\\\"\\\" );\\n        }\\n        if(order.nftType == BuyingAssetType.LazyMintERC1155){\\n            transferProxy.erc1155mintAndTransfer(IERC1155(order.nftAddress), order.seller, order.buyer, order.tokenId, order.fee, order.supply,order.tokenURI,order.qty,\\\"\\\" );\\n        }\\n\\n        if(fee.platformFee > 0) {\\n            payable(owner).transfer(fee.platformFee);\\n        }\\n        if(fee.royaltyFee > 0) {\\n            payable(fee.tokenCreator).transfer(fee.royaltyFee);\\n        }\\n        payable(order.seller).transfer(fee.assetFee);        \\n    }\\n\\n    function tradeAssetByBid(Order memory order, Fee memory fee) internal virtual {\\n        \\n        if(order.nftType == BuyingAssetType.ERC721) {\\n            transferProxy.erc721safeTransferFrom(IERC721(order.nftAddress), order.seller, order.buyer, order.tokenId);\\n        }\\n        if(order.nftType == BuyingAssetType.ERC1155)  {\\n            transferProxy.erc1155safeTransferFrom(IERC1155(order.nftAddress), order.seller, order.buyer, order.tokenId, order.qty, \\\"\\\"); \\n        }\\n        if(order.nftType == BuyingAssetType.LazyMintERC721){\\n            transferProxy.erc721mintAndTransfer(IERC721(order.nftAddress), order.seller, order.buyer, order.tokenId, order.fee,order.tokenURI,\\\"\\\" );\\n        }\\n        if(order.nftType == BuyingAssetType.LazyMintERC1155){\\n            transferProxy.erc1155mintAndTransfer(IERC1155(order.nftAddress), order.seller, order.buyer, order.tokenId, order.fee, order.supply,order.tokenURI,order.qty,\\\"\\\" );\\n        }\\n\\n        if(fee.platformFee > 0) {\\n            transferProxy.erc20safeTransferFrom(IERC20(order.erc20Address), order.buyer, owner, fee.platformFee);\\n        }\\n        if(fee.royaltyFee > 0) {\\n            transferProxy.erc20safeTransferFrom(IERC20(order.erc20Address), order.buyer, fee.tokenCreator, fee.royaltyFee);\\n        }\\n        transferProxy.erc20safeTransferFrom(IERC20(order.erc20Address), order.buyer, order.seller, fee.assetFee);\\n    }\\n\\n    function mintAndBuyAsset(Order memory order, Sign memory ownerSign, Sign memory sign) public payable returns(bool){\\n        require(!usedNonce[sign.nonce] && !usedNonce[ownerSign.nonce],\\\"Nonce: Invalid Nonce\\\");\\n        if(order.nftType == BuyingAssetType.ERC721 || order.nftType == BuyingAssetType.LazyMintERC721 ) usedNonce[sign.nonce] = true;\\n        if(order.nftType == BuyingAssetType.ERC721 || order.nftType == BuyingAssetType.LazyMintERC721 ) usedNonce[ownerSign.nonce] = true;\\n        Fee memory fee = getFees(order);\\n        require((fee.price >= order.unitPrice * order.qty), \\\"Paid invalid amount\\\");\\n        verifyOwnerSign(order.nftAddress, order.seller, order.tokenURI, ownerSign);\\n        verifySellerSign(order.seller, order.tokenId, order.unitPrice, order.erc20Address, order.nftAddress, sign);\\n        order.buyer = msg.sender;\\n        tradeAsset(order, fee);\\n        emit BuyAsset(order.seller , order.tokenId, order.qty, msg.sender);\\n        return true;\\n    }\\n\\n    function mintAndExecuteBid(Order memory order, Sign memory ownerSign, Sign memory sign) public returns(bool){\\n        require(!usedNonce[sign.nonce] && !usedNonce[ownerSign.nonce],\\\"Nonce: Invalid Nonce\\\");\\n        if(order.nftType == BuyingAssetType.ERC721 || order.nftType == BuyingAssetType.LazyMintERC721 ) usedNonce[sign.nonce] = true;\\n        if(order.nftType == BuyingAssetType.ERC721 || order.nftType == BuyingAssetType.LazyMintERC721 ) usedNonce[ownerSign.nonce] = true;\\n        Fee memory fee = getFees(order);\\n\\n        require((fee.price >= order.unitPrice * order.qty), \\\"Paid invalid amount\\\");\\n        verifyOwnerSign(order.nftAddress,order.seller, order.tokenURI, ownerSign);\\n        verifyBuyerSign(order.buyer, order.tokenId, order.amount, order.erc20Address, order.nftAddress, order.qty,sign);\\n        order.seller = msg.sender;\\n        tradeAssetByBid(order, fee);\\n        emit ExecuteBid(order.seller , order.tokenId, order.qty, msg.sender);\\n        return true;\\n\\n    }\\n\\n    function buyAsset(Order memory order, Sign memory sign) public payable returns(bool) {\\n        require(!usedNonce[sign.nonce],\\\"Nonce: Invalid Nonce\\\");\\n        if(order.nftType == BuyingAssetType.ERC721 || order.nftType == BuyingAssetType.LazyMintERC721 ) usedNonce[sign.nonce] = true;\\n        Fee memory fee = getFees(order);\\n        require((fee.price >= order.unitPrice * order.qty), \\\"Paid invalid amount\\\");\\n        verifySellerSign(order.seller, order.tokenId, order.unitPrice, order.erc20Address, order.nftAddress, sign);\\n        order.buyer = msg.sender;\\n        tradeAsset(order, fee);\\n        emit BuyAsset(order.seller , order.tokenId, order.qty, msg.sender);\\n        return true;\\n    }\\n\\n    function executeBid(Order memory order, Sign memory sign) public returns(bool) {\\n        require(!usedNonce[sign.nonce],\\\"Nonce: Invalid Nonce\\\");\\n        if(order.nftType == BuyingAssetType.ERC721 || order.nftType == BuyingAssetType.LazyMintERC721 ) usedNonce[sign.nonce] = true;\\n        Fee memory fee = getFees(order);\\n        verifyBuyerSign(order.buyer, order.tokenId, order.amount, order.erc20Address, order.nftAddress, order.qty, sign);\\n        order.seller = msg.sender;\\n        tradeAssetByBid(order, fee);\\n        emit ExecuteBid(msg.sender , order.tokenId, order.qty, order.buyer);\\n        return true;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_buyerFee\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_sellerFee\",\"type\":\"uint8\"},{\"internalType\":\"contract TransferProxy\",\"name\":\"_transferProxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"BuyAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"buyerFee\",\"type\":\"uint8\"}],\"name\":\"BuyerFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"ExecuteBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"sellerFee\",\"type\":\"uint8\"}],\"name\":\"SellerFee\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"enum Trade.BuyingAssetType\",\"name\":\"nftType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"unitPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tokenURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"}],\"internalType\":\"struct Trade.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Trade.Sign\",\"name\":\"sign\",\"type\":\"tuple\"}],\"name\":\"buyAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyerServiceFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"enum Trade.BuyingAssetType\",\"name\":\"nftType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"unitPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tokenURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"}],\"internalType\":\"struct Trade.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Trade.Sign\",\"name\":\"sign\",\"type\":\"tuple\"}],\"name\":\"executeBid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"enum Trade.BuyingAssetType\",\"name\":\"nftType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"unitPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tokenURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"}],\"internalType\":\"struct Trade.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Trade.Sign\",\"name\":\"ownerSign\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Trade.Sign\",\"name\":\"sign\",\"type\":\"tuple\"}],\"name\":\"mintAndBuyAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"erc20Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"enum Trade.BuyingAssetType\",\"name\":\"nftType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"unitPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tokenURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"}],\"internalType\":\"struct Trade.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Trade.Sign\",\"name\":\"ownerSign\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct Trade.Sign\",\"name\":\"sign\",\"type\":\"tuple\"}],\"name\":\"mintAndExecuteBid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellerServiceFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_buyerFee\",\"type\":\"uint8\"}],\"name\":\"setBuyerServiceFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_sellerFee\",\"type\":\"uint8\"}],\"name\":\"setSellerServiceFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferProxy\",\"outputs\":[{\"internalType\":\"contract TransferProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Trade", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000019000000000000000000000000596539344cae6342167c298ef83caf51878fa074", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}