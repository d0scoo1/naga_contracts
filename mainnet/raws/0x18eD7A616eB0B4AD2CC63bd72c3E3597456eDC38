{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/swappers/SwapperUniswapV2Lp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2022 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity 0.7.6;\\n\\n\\nimport \\\"../interfaces/swappers/ISwapper.sol\\\";\\nimport \\\"./helpers/UniswapV2Helper.sol\\\";\\nimport \\\"./AbstractSwapper.sol\\\";\\nimport \\\"../interfaces/curve/ICurvePoolMeta.sol\\\";\\nimport \\\"../interfaces/curve/ICurvePoolCrypto.sol\\\";\\nimport \\\"../helpers/SafeMath.sol\\\";\\nimport \\\"../helpers/IUniswapV2PairFull.sol\\\";\\nimport '../helpers/TransferHelper.sol';\\nimport \\\"../helpers/ReentrancyGuard.sol\\\";\\nimport \\\"../Auth2.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n\\n/**\\n * @dev swap usdp/any uniswapv2 lp\\n */\\ncontract SwapperUniswapV2Lp is AbstractSwapper {\\n    using SafeMath for uint;\\n    using UniswapV2Helper for IUniswapV2PairFull;\\n    using TransferHelper for address;\\n\\n    address public immutable WETH;\\n\\n    ISwapper public immutable wethSwapper;\\n\\n    constructor(\\n        address _vaultParameters, address _weth,  address _usdp,\\n        address _wethSwapper\\n    ) AbstractSwapper(_vaultParameters, _usdp) {\\n        require(\\n            _weth != address(0)\\n            && _wethSwapper != address(0)\\n            , \\\"Unit Protocol Swappers: ZERO_ADDRESS\\\"\\n        );\\n\\n        WETH = _weth;\\n\\n        wethSwapper = ISwapper(_wethSwapper);\\n    }\\n\\n    function predictAssetOut(address _asset, uint256 _usdpAmountIn) external view override returns (uint predictedAssetAmount) {\\n        IUniswapV2PairFull pair = IUniswapV2PairFull(_asset);\\n        (uint256 pairWethId,,) = pair.getTokenInfo(WETH);\\n        (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\\n\\n        // USDP -> WETH\\n        uint wethAmount = wethSwapper.predictAssetOut(WETH, _usdpAmountIn);\\n\\n        // ~1/2 WETH -> LP underlying token\\n        uint wethToSwap = pair.calcWethToSwapBeforeMint(wethAmount, pairWethId);\\n        uint tokenAmount = pair.calcAmountOutByTokenId(pairWethId, wethToSwap, reserve0, reserve1);\\n\\n        // ~1/2 WETH + LP underlying token -> LP tokens\\n        uint wethToDeposit = wethAmount.sub(wethToSwap);\\n        if (pairWethId == 0) {\\n            predictedAssetAmount = pair.calculateLpAmountAfterDepositTokens(\\n                wethToDeposit, tokenAmount, uint(reserve0).add(wethToSwap), uint(reserve1).sub(tokenAmount)\\n            );\\n        } else {\\n            predictedAssetAmount = pair.calculateLpAmountAfterDepositTokens(\\n                tokenAmount, wethToDeposit, uint(reserve0).sub(tokenAmount), uint(reserve1).add(wethToSwap)\\n            );\\n        }\\n    }\\n\\n    function predictUsdpOut(address _asset, uint256 _assetAmountIn) external view override returns (uint predictedUsdpAmount) {\\n        IUniswapV2PairFull pair = IUniswapV2PairFull(_asset);\\n        (uint256 pairWethId, uint pairTokenId,) = pair.getTokenInfo(WETH);\\n        (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\\n\\n        // LP tokens -> WETH + LP underlying token\\n        (uint amount0, uint amount1) = pair.calculateTokensAmountAfterWithdrawLp(_assetAmountIn);\\n        (uint wethAmount, uint tokenAmount) = (pairWethId == 0) ? (amount0, amount1) : (amount1, amount0);\\n\\n        // LP underlying token -> WETH\\n        wethAmount = wethAmount.add(\\n            pair.calcAmountOutByTokenId(pairTokenId, tokenAmount, uint(reserve0).sub(amount0), uint(reserve1).sub(amount1))\\n        );\\n\\n        // WETH -> USDP\\n        predictedUsdpAmount = wethSwapper.predictUsdpOut(WETH, wethAmount);\\n    }\\n\\n    function _swapUsdpToAsset(address _user, address _asset, uint256 _usdpAmount, uint256 /** _minAssetAmount */)\\n        internal override returns (uint swappedAssetAmount)\\n    {\\n        IUniswapV2PairFull pair = IUniswapV2PairFull(_asset);\\n        (uint256 pairWethId,, address underlyingToken) = pair.getTokenInfo(WETH);\\n\\n        // USDP -> WETH\\n        address(USDP).safeTransfer(address(wethSwapper), _usdpAmount);\\n        uint wethAmount = wethSwapper.swapUsdpToAssetWithDirectSending(address(this), WETH, _usdpAmount, 0);\\n\\n\\n        // ~1/2 WETH -> LP underlying token\\n        uint wethToSwap = pair.calcWethToSwapBeforeMint(wethAmount, pairWethId);\\n        uint tokenAmount = _swapPairTokens(pair, WETH, pairWethId, wethToSwap, address(this));\\n\\n        // ~1/2 WETH + LP underlying token -> LP tokens and send remainders to user\\n        WETH.safeTransfer(address(pair), wethAmount.sub(wethToSwap));\\n        underlyingToken.safeTransfer(address(pair), tokenAmount);\\n        swappedAssetAmount = pair.mint(_user);\\n    }\\n\\n    function _swapAssetToUsdp(address _user, address _asset, uint256 _assetAmount, uint256 /** _minUsdpAmount */)\\n        internal override returns (uint swappedUsdpAmount)\\n    {\\n        IUniswapV2PairFull pair = IUniswapV2PairFull(_asset);\\n        (uint256 pairWethId, uint pairTokenId, address underlyingToken) = pair.getTokenInfo(WETH);\\n\\n        // LP tokens -> WETH + LP underlying token\\n        _asset.safeTransfer(_asset, _assetAmount);\\n        (uint amount0, uint amount1) = pair.burn(address(this));\\n        (uint wethAmount, uint tokenAmount) = (pairWethId == 0) ? (amount0, amount1) : (amount1, amount0);\\n\\n        // LP underlying token -> WETH\\n        wethAmount = wethAmount.add(_swapPairTokens(pair, underlyingToken, pairTokenId, tokenAmount, address(this)));\\n\\n        // WETH -> USDP\\n        WETH.safeTransfer(address(wethSwapper), wethAmount);\\n        swappedUsdpAmount = wethSwapper.swapAssetToUsdpWithDirectSending(address(this), WETH, wethAmount, 0);\\n\\n        // USDP -> user\\n        address(USDP).safeTransfer(_user, swappedUsdpAmount);\\n    }\\n\\n    function _swapPairTokens(IUniswapV2PairFull _pair, address _token, uint _tokenId, uint _amount, address _to) internal returns (uint tokenAmount) {\\n        tokenAmount = _pair.calcAmountOutByTokenId(_tokenId, _amount);\\n        TransferHelper.safeTransfer(_token, address(_pair), _amount);\\n\\n        _pair.swap(_tokenId == 0 ? 0: tokenAmount, _tokenId == 1 ? 0 : tokenAmount, _to, new bytes(0));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/swappers/ISwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2022 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity 0.7.6;\\n\\n\\ninterface ISwapper {\\n\\n    /**\\n     * @notice Predict asset amount after usdp swap\\n     */\\n    function predictAssetOut(address _asset, uint256 _usdpAmountIn) external view returns (uint predictedAssetAmount);\\n\\n    /**\\n     * @notice Predict USDP amount after asset swap\\n     */\\n    function predictUsdpOut(address _asset, uint256 _assetAmountIn) external view returns (uint predictedUsdpAmount);\\n\\n    /**\\n     * @notice usdp must be approved to swapper\\n     * @dev asset must be sent to user after swap\\n     */\\n    function swapUsdpToAsset(address _user, address _asset, uint256 _usdpAmount, uint256 _minAssetAmount) external returns (uint swappedAssetAmount);\\n\\n    /**\\n     * @notice asset must be approved to swapper\\n     * @dev usdp must be sent to user after swap\\n     */\\n    function swapAssetToUsdp(address _user, address _asset, uint256 _assetAmount, uint256 _minUsdpAmount) external returns (uint swappedUsdpAmount);\\n\\n    /**\\n     * @notice DO NOT SEND tokens to contract manually. For usage in contracts only.\\n     * @dev for gas saving with usage in contracts tokens must be send directly to contract instead\\n     * @dev asset must be sent to user after swap\\n     */\\n    function swapUsdpToAssetWithDirectSending(address _user, address _asset, uint256 _usdpAmount, uint256 _minAssetAmount) external returns (uint swappedAssetAmount);\\n\\n    /**\\n     * @notice DO NOT SEND tokens to contract manually. For usage in contracts only.\\n     * @dev for gas saving with usage in contracts tokens must be send directly to contract instead\\n     * @dev usdp must be sent to user after swap\\n     */\\n    function swapAssetToUsdpWithDirectSending(address _user, address _asset, uint256 _assetAmount, uint256 _minUsdpAmount) external returns (uint swappedUsdpAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/swappers/helpers/UniswapV2Helper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2022 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity 0.7.6;\\n\\nimport \\\"../../helpers/IUniswapV2Factory.sol\\\";\\nimport \\\"../../helpers/IUniswapV2PairFull.sol\\\";\\nimport '../../helpers/TransferHelper.sol';\\nimport \\\"../../helpers/SafeMath.sol\\\";\\nimport \\\"../../helpers/Math.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @dev several methods for calculations different uniswap v2 params. Part of them extracted for uniswap contracts\\n * @dev for original licenses see attached links\\n */\\nlibrary UniswapV2Helper {\\n    using SafeMath for uint;\\n\\n    /**\\n     * given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n     * see https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol\\n     */\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n        require(amountA > 0, 'Unit Protocol Swappers: INSUFFICIENT_AMOUNT');\\n        require(reserveA > 0 && reserveB > 0, 'Unit Protocol Swappers: INSUFFICIENT_LIQUIDITY');\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    /**\\n     * given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n     * see https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2Library.sol\\n     */\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\n        require(amountIn > 0, 'Unit Protocol Swappers: INSUFFICIENT_INPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'Unit Protocol Swappers: INSUFFICIENT_LIQUIDITY');\\n        uint amountInWithFee = amountIn.mul(997);\\n        uint numerator = amountInWithFee.mul(reserveOut);\\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    /**\\n     * see pair._mintFee in pair contract https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol\\n     */\\n    function getLPAmountAddedDuringFeeMint(IUniswapV2PairFull pair, uint _reserve0, uint _reserve1) internal view returns (uint) {\\n        address feeTo = IUniswapV2Factory(pair.factory()).feeTo();\\n        bool feeOn = feeTo != address(0);\\n\\n        uint _kLast = pair.kLast(); // gas savings\\n        if (feeOn) {\\n            if (_kLast != 0) {\\n                uint rootK = Math.sqrt(_reserve0.mul(_reserve1));\\n                uint rootKLast = Math.sqrt(_kLast);\\n                if (rootK > rootKLast) {\\n                    uint numerator = pair.totalSupply().mul(rootK.sub(rootKLast));\\n                    uint denominator = rootK.mul(5).add(rootKLast);\\n                    uint liquidity = numerator / denominator;\\n                    return liquidity;\\n                }\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n    /**\\n     * see pair.mint in pair contract https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol\\n     */\\n    function calculateLpAmountAfterDepositTokens(IUniswapV2PairFull _pair, uint _amount0, uint _amount1) internal view returns (uint) {\\n        (uint112 reserve0, uint112 reserve1,) = _pair.getReserves();\\n        return calculateLpAmountAfterDepositTokens(_pair, _amount0, _amount1, reserve0, reserve1);\\n    }\\n\\n    function calculateLpAmountAfterDepositTokens(\\n        IUniswapV2PairFull _pair, uint _amount0, uint _amount1, uint _reserve0, uint _reserve1\\n    ) internal view returns (uint) {\\n        uint _totalSupply = _pair.totalSupply().add(getLPAmountAddedDuringFeeMint(_pair, _reserve0, _reserve1));\\n        if (_totalSupply == 0) {\\n            return Math.sqrt(_amount0.mul(_amount1)).sub(_pair.MINIMUM_LIQUIDITY());\\n        }\\n\\n        return Math.min(_amount0.mul(_totalSupply) / _reserve0, _amount1.mul(_totalSupply) / _reserve1);\\n    }\\n\\n    /**\\n     * see pair.burn in pair contract https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol\\n     */\\n    function calculateTokensAmountAfterWithdrawLp(IUniswapV2PairFull pair, uint lpAmount) internal view returns (uint amount0, uint amount1) {\\n        (uint112 _reserve0, uint112 _reserve1,) = pair.getReserves();\\n        address _token0 = pair.token0();\\n        address _token1 = pair.token1();\\n        uint balance0 = IERC20(_token0).balanceOf(address(pair));\\n        uint balance1 = IERC20(_token1).balanceOf(address(pair));\\n\\n        uint _totalSupply = pair.totalSupply().add(getLPAmountAddedDuringFeeMint(pair, _reserve0, _reserve1));\\n        amount0 = lpAmount.mul(balance0) / _totalSupply;\\n        amount1 = lpAmount.mul(balance1) / _totalSupply;\\n    }\\n\\n    function getTokenInfo(IUniswapV2PairFull pair, address _token) internal view returns (uint tokenId, uint secondTokenId, address secondToken) {\\n        if (pair.token0() == _token) {\\n            return (0, 1, pair.token1());\\n        } else if (pair.token1() == _token) {\\n            return (1, 0, pair.token0());\\n        } else {\\n            revert(\\\"Unit Protocol Swappers: UNSUPPORTED_PAIR\\\");\\n        }\\n    }\\n\\n    function calcAmountOutByTokenId(IUniswapV2PairFull _pair, uint _tokenId, uint _amount) internal view returns (uint) {\\n        (uint112 reserve0, uint112 reserve1, ) = _pair.getReserves();\\n\\n        return calcAmountOutByTokenId(_pair, _tokenId, _amount, uint(reserve0), uint(reserve1));\\n    }\\n\\n    function calcAmountOutByTokenId(IUniswapV2PairFull /* _pair */, uint _tokenId, uint _amount, uint reserve0, uint reserve1) internal pure returns (uint) {\\n        uint256 reserveIn;\\n        uint256 reserveOut;\\n        if (_tokenId == 0) {\\n            reserveIn = reserve0;\\n            reserveOut = reserve1;\\n        } else { // the fact that pair has weth must be checked outside\\n            reserveIn = reserve1;\\n            reserveOut = reserve0;\\n        }\\n\\n        return UniswapV2Helper.getAmountOut(_amount, reserveIn, reserveOut);\\n    }\\n\\n    /**\\n     * @dev In case we want to get pair LP tokens but we have weth only\\n     * @dev - First we swap `wethToSwap` tokens\\n     * @dev - then we deposit `_wethAmount-wethToSwap` and `exchangedTokenAmount` to pair\\n     */\\n    function calcWethToSwapBeforeMint(IUniswapV2PairFull _pair, uint _wethAmount, uint _pairWethId) internal view returns (uint wethToSwap) {\\n        (uint112 reserve0, uint112 reserve1, ) = _pair.getReserves();\\n        uint wethReserve = _pairWethId == 0 ? uint(reserve0) : uint(reserve1);\\n\\n        return Math.sqrt(\\n            wethReserve.mul(\\n                wethReserve.mul(3988009).add(\\n                    _wethAmount.mul(3988000)\\n                )\\n            )\\n        ).sub(\\n            wethReserve.mul(1997)\\n        ).div(1994);\\n\\n        /*\\n            we have several equations\\n            ```\\n            syms wethToChange  wethReserve tokenReserve wethAmount wethToAdd tokenChanged tokenToAdd wethReserve2 tokenReserve2\\n            % we have `wethAmount` amount, `wethToChange` we want to change for `tokenChanged`, `wethToAdd` we will deposit for minting LP\\n            eqn1 = wethAmount == wethToChange + wethToAdd\\n            % all `tokenChanged` which we got from exchange we want to deposit for minting LP\\n            eqn2 = tokenToAdd == tokenChanged\\n            % formula from swap\\n            eqn3 = ((wethReserve + wethToChange) * 1000 - wethToChange * 3) * (tokenReserve - tokenChanged) * 1000 = wethReserve * tokenReserve * 1000 * 1000\\n            % after change we have such reserves:\\n            eqn4 = wethReserve2 == (wethReserve + wethToChange)\\n            eqn5 = tokenReserve2 == (tokenReserve - tokenChanged)\\n            % depositing in current reserves ratio (both parts of min must be equal `Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);`)\\n            eqn6 = wethToAdd / tokenToAdd == wethReserve2 / tokenReserve2\\n            S = solve(eqn6, wethToChange)\\n            ```\\n\\n            lets transform equations to substitute variables in eqn6\\n            step 1:\\n            ```\\n            syms wethToChange  wethReserve tokenReserve wethAmount wethToAdd tokenChanged tokenToAdd wethReserve2 tokenReserve2\\n            eqn1 = wethToAdd == (wethAmount - wethToChange)\\n            eqn2 = tokenToAdd == tokenChanged\\n            %eqn3 = ((wethReserve + wethToChange) * 1000 - wethToChange * 3) * (tokenReserve - tokenChanged) = wethReserve * tokenReserve * 1000\\n            %eqn3 = (wethReserve * 1000 + wethToChange * 997) * (tokenReserve - tokenChanged) = wethReserve * tokenReserve * 1000\\n            %eqn3 = (tokenReserve - tokenChanged) = wethReserve * tokenReserve * 1000 / (wethReserve * 1000 + wethToChange * 997)\\n            eqn3 = tokenChanged = (tokenReserve - wethReserve * tokenReserve * 1000 / (wethReserve * 1000 + wethToChange * 997))\\n            eqn4 = wethReserve2 == (wethReserve + wethToChange)\\n            eqn5 = tokenReserve2 == (tokenReserve - tokenChanged)\\n            eqn6 = wethToAdd / tokenChanged == (wethReserve + wethToChange) / (tokenReserve - tokenChanged)\\n            S = solve(eqn6, wethToChange)\\n            ```\\n\\n            step 2: substitute variables from eqn1-eqn5 in eqn6\\n            ```\\n            syms wethToChange  wethReserve tokenReserve wethAmount wethToAdd tokenChanged tokenToAdd wethReserve2 tokenReserve2\\n            eqn6 = (wethAmount - wethToChange) / (tokenReserve - wethReserve * tokenReserve * 1000 / (wethReserve * 1000 + wethToChange * 997)) == (wethReserve + wethToChange) / (tokenReserve - (tokenReserve - wethReserve * tokenReserve * 1000 / (wethReserve * 1000 + wethToChange * 997)))\\n            S = solve(eqn6, wethToChange)\\n            ```\\n\\n            result = sqrt(wethReserve*(3988009*wethReserve + 3988000*wethAmount))/1994 - (1997*wethReserve)/1994\\n        */\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/swappers/AbstractSwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2022 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity 0.7.6;\\n\\n\\nimport \\\"../interfaces/swappers/ISwapper.sol\\\";\\nimport \\\"../helpers/ReentrancyGuard.sol\\\";\\nimport '../helpers/TransferHelper.sol';\\nimport \\\"../helpers/SafeMath.sol\\\";\\nimport \\\"../Auth2.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @dev base class for swappers, makes common checks\\n * @dev internal _swapUsdpToAsset and _swapAssetToUsdp must be overridden instead of external swapUsdpToAsset and swapAssetToUsdp\\n */\\nabstract contract AbstractSwapper is ISwapper, ReentrancyGuard, Auth2 {\\n    using TransferHelper for address;\\n    using SafeMath for uint;\\n\\n    IERC20 public immutable USDP;\\n\\n    constructor(address _vaultParameters, address _usdp) Auth2(_vaultParameters) {\\n        require(_usdp != address(0), \\\"Unit Protocol Swappers: ZERO_ADDRESS\\\");\\n\\n        USDP = IERC20(_usdp);\\n    }\\n\\n    /**\\n     * @dev usdp already transferred to swapper\\n     */\\n    function _swapUsdpToAsset(address _user, address _asset, uint256 _usdpAmount, uint256 _minAssetAmount)\\n        internal virtual returns (uint swappedAssetAmount);\\n\\n    /**\\n     * @dev asset already transferred to swapper\\n     */\\n    function _swapAssetToUsdp(address _user, address _asset, uint256 _assetAmount, uint256 _minUsdpAmount)\\n        internal virtual returns (uint swappedUsdpAmount);\\n\\n    function swapUsdpToAsset(address _user, address _asset, uint256 _usdpAmount, uint256 _minAssetAmount)\\n        external override returns (uint swappedAssetAmount) // nonReentrant in swapUsdpToAssetWithDirectSending\\n    {\\n        // get USDP from user\\n        address(USDP).safeTransferFrom(_user, address(this), _usdpAmount);\\n\\n        return swapUsdpToAssetWithDirectSending(_user, _asset, _usdpAmount, _minAssetAmount);\\n    }\\n\\n    function swapAssetToUsdp(address _user, address _asset, uint256 _assetAmount, uint256 _minUsdpAmount)\\n        external override returns (uint swappedUsdpAmount) // nonReentrant in swapAssetToUsdpWithDirectSending\\n    {\\n        // get asset from user\\n        _asset.safeTransferFrom(_user, address(this), _assetAmount);\\n\\n        return swapAssetToUsdpWithDirectSending(_user, _asset, _assetAmount, _minUsdpAmount);\\n    }\\n\\n    function swapUsdpToAssetWithDirectSending(address _user, address _asset, uint256 _usdpAmount, uint256 _minAssetAmount)\\n        public override nonReentrant returns (uint swappedAssetAmount)\\n    {\\n        require(msg.sender == _user || vaultParameters.canModifyVault(msg.sender), \\\"Unit Protocol Swappers: AUTH_FAILED\\\");\\n\\n        swappedAssetAmount = _swapUsdpToAsset(_user, _asset, _usdpAmount, _minAssetAmount);\\n\\n        require(swappedAssetAmount >= _minAssetAmount, \\\"Unit Protocol Swapper: SWAPPED_AMOUNT_LESS_THAN_EXPECTED_MINIMUM\\\");\\n    }\\n\\n    function swapAssetToUsdpWithDirectSending(address _user, address _asset, uint256 _assetAmount, uint256 _minUsdpAmount)\\n        public override nonReentrant returns (uint swappedUsdpAmount)\\n    {\\n        require(msg.sender == _user || vaultParameters.canModifyVault(msg.sender), \\\"Unit Protocol Swappers: AUTH_FAILED\\\");\\n\\n        swappedUsdpAmount = _swapAssetToUsdp(_user, _asset, _assetAmount, _minUsdpAmount);\\n\\n        require(swappedUsdpAmount >= _minUsdpAmount, \\\"Unit Protocol Swappers: SWAPPED_AMOUNT_LESS_THAN_EXPECTED_MINIMUM\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/curve/ICurvePoolMeta.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2022 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.6;\\n\\nimport \\\"./ICurvePoolBase.sol\\\";\\n\\ninterface ICurvePoolMeta is ICurvePoolBase {\\n\\n    function base_pool() external view returns (address);\\n\\n    /**\\n     * @dev variant of token/3crv pool\\n     * @param i Index value for the underlying coin to send\\n     * @param j Index value of the underlying coin to recieve\\n     * @param _dx Amount of `i` being exchanged\\n     * @param _min_dy Minimum amount of `j` to receive\\n     * @return Actual amount of `j` received\\n     */\\n    function exchange_underlying(int128 i, int128 j, uint256 _dx, uint256 _min_dy) external returns (uint256);\\n\\n    function get_dy_underlying(int128 i, int128 j, uint256 _dx) external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/curve/ICurvePoolCrypto.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.6;\\n\\nimport \\\"../ICurvePool.sol\\\";\\n\\ninterface ICurvePoolCrypto is ICurvePool {\\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external;\\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/helpers/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity 0.7.6;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n    /**\\n    * @dev Multiplies two numbers, throws on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers, truncating the quotient.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, throws on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/IUniswapV2PairFull.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity 0.7.6;\\n\\ninterface IUniswapV2PairFull {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity 0.7.6;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Auth2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2021 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity 0.7.6;\\n\\nimport \\\"./VaultParameters.sol\\\";\\n\\n\\n/**\\n * @title Auth2\\n * @dev Manages USDP's system access\\n * @dev copy of Auth from VaultParameters.sol but with immutable vaultParameters for saving gas\\n **/\\ncontract Auth2 {\\n\\n    // address of the the contract with vault parameters\\n    VaultParameters public immutable vaultParameters;\\n\\n    constructor(address _parameters) {\\n        require(_parameters != address(0), \\\"Unit Protocol: ZERO_ADDRESS\\\");\\n\\n        vaultParameters = VaultParameters(_parameters);\\n    }\\n\\n    // ensures tx's sender is a manager\\n    modifier onlyManager() {\\n        require(vaultParameters.isManager(msg.sender), \\\"Unit Protocol: AUTH_FAILED\\\");\\n        _;\\n    }\\n\\n    // ensures tx's sender is able to modify the Vault\\n    modifier hasVaultAccess() {\\n        require(vaultParameters.canModifyVault(msg.sender), \\\"Unit Protocol: AUTH_FAILED\\\");\\n        _;\\n    }\\n\\n    // ensures tx's sender is the Vault\\n    modifier onlyVault() {\\n        require(msg.sender == vaultParameters.vault(), \\\"Unit Protocol: AUTH_FAILED\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity 0.7.6;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity 0.7.6;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n\\n    /**\\n     * @dev babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n     **/\\n    function sqrt(uint x) internal pure returns (uint y) {\\n        if (x > 3) {\\n            uint z = x / 2 + 1;\\n            y = x;\\n            while (z < y) {\\n                y = z;\\n                z = (x / z + z) / 2;\\n            }\\n        } else if (x != 0) {\\n            y = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/VaultParameters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity 0.7.6;\\n\\n\\n\\n/**\\n * @title Auth\\n * @dev Manages USDP's system access\\n **/\\ncontract Auth {\\n\\n    // address of the the contract with vault parameters\\n    VaultParameters public vaultParameters;\\n\\n    constructor(address _parameters) {\\n        vaultParameters = VaultParameters(_parameters);\\n    }\\n\\n    // ensures tx's sender is a manager\\n    modifier onlyManager() {\\n        require(vaultParameters.isManager(msg.sender), \\\"Unit Protocol: AUTH_FAILED\\\");\\n        _;\\n    }\\n\\n    // ensures tx's sender is able to modify the Vault\\n    modifier hasVaultAccess() {\\n        require(vaultParameters.canModifyVault(msg.sender), \\\"Unit Protocol: AUTH_FAILED\\\");\\n        _;\\n    }\\n\\n    // ensures tx's sender is the Vault\\n    modifier onlyVault() {\\n        require(msg.sender == vaultParameters.vault(), \\\"Unit Protocol: AUTH_FAILED\\\");\\n        _;\\n    }\\n}\\n\\n\\n\\n/**\\n * @title VaultParameters\\n **/\\ncontract VaultParameters is Auth {\\n\\n    // map token to stability fee percentage; 3 decimals\\n    mapping(address => uint) public stabilityFee;\\n\\n    // map token to liquidation fee percentage, 0 decimals\\n    mapping(address => uint) public liquidationFee;\\n\\n    // map token to USDP mint limit\\n    mapping(address => uint) public tokenDebtLimit;\\n\\n    // permissions to modify the Vault\\n    mapping(address => bool) public canModifyVault;\\n\\n    // managers\\n    mapping(address => bool) public isManager;\\n\\n    // enabled oracle types\\n    mapping(uint => mapping (address => bool)) public isOracleTypeEnabled;\\n\\n    // address of the Vault\\n    address payable public vault;\\n\\n    // The foundation address\\n    address public foundation;\\n\\n    /**\\n     * The address for an Ethereum contract is deterministically computed from the address of its creator (sender)\\n     * and how many transactions the creator has sent (nonce). The sender and nonce are RLP encoded and then\\n     * hashed with Keccak-256.\\n     * Therefore, the Vault address can be pre-computed and passed as an argument before deployment.\\n    **/\\n    constructor(address payable _vault, address _foundation) Auth(address(this)) {\\n        require(_vault != address(0), \\\"Unit Protocol: ZERO_ADDRESS\\\");\\n        require(_foundation != address(0), \\\"Unit Protocol: ZERO_ADDRESS\\\");\\n\\n        isManager[msg.sender] = true;\\n        vault = _vault;\\n        foundation = _foundation;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Grants and revokes manager's status of any address\\n     * @param who The target address\\n     * @param permit The permission flag\\n     **/\\n    function setManager(address who, bool permit) external onlyManager {\\n        isManager[who] = permit;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets the foundation address\\n     * @param newFoundation The new foundation address\\n     **/\\n    function setFoundation(address newFoundation) external onlyManager {\\n        require(newFoundation != address(0), \\\"Unit Protocol: ZERO_ADDRESS\\\");\\n        foundation = newFoundation;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets ability to use token as the main collateral\\n     * @param asset The address of the main collateral token\\n     * @param stabilityFeeValue The percentage of the year stability fee (3 decimals)\\n     * @param liquidationFeeValue The liquidation fee percentage (0 decimals)\\n     * @param usdpLimit The USDP token issue limit\\n     * @param oracles The enables oracle types\\n     **/\\n    function setCollateral(\\n        address asset,\\n        uint stabilityFeeValue,\\n        uint liquidationFeeValue,\\n        uint usdpLimit,\\n        uint[] calldata oracles\\n    ) external onlyManager {\\n        setStabilityFee(asset, stabilityFeeValue);\\n        setLiquidationFee(asset, liquidationFeeValue);\\n        setTokenDebtLimit(asset, usdpLimit);\\n        for (uint i=0; i < oracles.length; i++) {\\n            setOracleType(oracles[i], asset, true);\\n        }\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets a permission for an address to modify the Vault\\n     * @param who The target address\\n     * @param permit The permission flag\\n     **/\\n    function setVaultAccess(address who, bool permit) external onlyManager {\\n        canModifyVault[who] = permit;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets the percentage of the year stability fee for a particular collateral\\n     * @param asset The address of the main collateral token\\n     * @param newValue The stability fee percentage (3 decimals)\\n     **/\\n    function setStabilityFee(address asset, uint newValue) public onlyManager {\\n        stabilityFee[asset] = newValue;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets the percentage of the liquidation fee for a particular collateral\\n     * @param asset The address of the main collateral token\\n     * @param newValue The liquidation fee percentage (0 decimals)\\n     **/\\n    function setLiquidationFee(address asset, uint newValue) public onlyManager {\\n        require(newValue <= 100, \\\"Unit Protocol: VALUE_OUT_OF_RANGE\\\");\\n        liquidationFee[asset] = newValue;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Enables/disables oracle types\\n     * @param _type The type of the oracle\\n     * @param asset The address of the main collateral token\\n     * @param enabled The control flag\\n     **/\\n    function setOracleType(uint _type, address asset, bool enabled) public onlyManager {\\n        isOracleTypeEnabled[_type][asset] = enabled;\\n    }\\n\\n    /**\\n     * @notice Only manager is able to call this function\\n     * @dev Sets USDP limit for a specific collateral\\n     * @param asset The address of the main collateral token\\n     * @param limit The limit number\\n     **/\\n    function setTokenDebtLimit(address asset, uint limit) public onlyManager {\\n        tokenDebtLimit[asset] = limit;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/curve/ICurvePoolBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\n\\n/*\\n  Copyright 2022 Unit Protocol: Artem Zakharov (az@unit.xyz).\\n*/\\npragma solidity ^0.7.6;\\n\\nimport \\\"../ICurvePool.sol\\\";\\n\\ninterface ICurvePoolBase is ICurvePool {\\n    /**\\n     * @notice Perform an exchange between two coins\\n     * @dev Index values can be found via the `coins` public getter method\\n     * @param i Index value for the coin to send\\n     * @param j Index valie of the coin to recieve\\n     * @param _dx Amount of `i` being exchanged\\n     * @param _min_dy Minimum amount of `j` to receive\\n     * @return Actual amount of `j` received\\n     */\\n    function exchange(int128 i, int128 j, uint256 _dx, uint256 _min_dy) external returns (uint256);\\n\\n    function get_dy(int128 i, int128 j, uint256 _dx) external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ICurvePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: bsl-1.1\\r\\n\\r\\n/*\\r\\n  Copyright 2020 Unit Protocol: Artem Zakharov (az@unit.xyz).\\r\\n*/\\r\\npragma solidity ^0.7.6;\\r\\n\\r\\ninterface ICurvePool {\\r\\n    function get_virtual_price() external view returns (uint);\\r\\n    function coins(uint) external view returns (address);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultParameters\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wethSwapper\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"USDP\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_usdpAmountIn\",\"type\":\"uint256\"}],\"name\":\"predictAssetOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"predictedAssetAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetAmountIn\",\"type\":\"uint256\"}],\"name\":\"predictUsdpOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"predictedUsdpAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minUsdpAmount\",\"type\":\"uint256\"}],\"name\":\"swapAssetToUsdp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swappedUsdpAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minUsdpAmount\",\"type\":\"uint256\"}],\"name\":\"swapAssetToUsdpWithDirectSending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swappedUsdpAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_usdpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAssetAmount\",\"type\":\"uint256\"}],\"name\":\"swapUsdpToAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swappedAssetAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_usdpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAssetAmount\",\"type\":\"uint256\"}],\"name\":\"swapUsdpToAssetWithDirectSending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swappedAssetAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultParameters\",\"outputs\":[{\"internalType\":\"contract VaultParameters\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethSwapper\",\"outputs\":[{\"internalType\":\"contract ISwapper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SwapperUniswapV2Lp", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b46f8cf42e504efe8bef895f848741daa55e9f1d000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000001456688345527be1f37e9e627da0837d6f08c925000000000000000000000000b0bcf61d9bb95794a8d92b49011dc6d8786d0773", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}