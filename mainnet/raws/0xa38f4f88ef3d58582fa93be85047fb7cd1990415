{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/BabyDogeMarketPlace.sol\r\n\r\n//SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\ninterface BabyDogeNFT {\r\n    function mint(address, uint256, uint256) external;\r\n    function maxMint() external returns(uint256);\r\n}\r\ncontract BabyDogeMarketplace is Ownable{\r\n    BabyDogeNFT public babyDogeNFT;\r\n    uint256 public constant TOTAL_CATEGORIES = 3;\r\n    struct CategoryDetail {\r\n        uint256 price;\r\n        uint256 total;\r\n        uint256 totalForPresale;\r\n        uint256 totalForOwner;\r\n        uint256 totalMinted;\r\n        uint256 totalMintedForOwner;\r\n        uint256 nextTokenId;\r\n    }\r\n\r\n    struct CodeDetail {\r\n        uint256 totalCollected;\r\n        uint256 totalGiven;\r\n    }\r\n    //0 = presale 1 = postSale\r\n    uint256 public stage;\r\n    address public superOwner;\r\n    //0 gold 1 platinum 2 black\r\n    mapping(uint256 => CategoryDetail) public tokenCategories;\r\n    mapping(uint256 => uint256[3]) public randomAvailable;\r\n    mapping(address => bool) public whitelistedAddress;\r\n    mapping(uint256 => CodeDetail) public codesDetails;\r\n\r\n    //events\r\n    event buy(address buyer, uint256 requestedTokenCategory,uint256 givenTokenCategory, uint256 startTokenId, uint256 totalToken, uint256 price, uint256 boughtAt, uint256 stage);\r\n    event buyForOwner(address buyer, uint256 tokenCategory, uint256 startTokenId, uint256 totalToken, uint256 boughtAt);\r\n   \r\n    //modifer\r\n    modifier isValidCategory(uint256 _tokenCategory){\r\n        require(_tokenCategory < TOTAL_CATEGORIES, 'Invalid token categories');\r\n        _;\r\n    }\r\n    constructor(\r\n        address _babyDogeNFT, \r\n        uint256[TOTAL_CATEGORIES] memory _prices, \r\n        uint256[TOTAL_CATEGORIES] memory _total, \r\n        uint256[TOTAL_CATEGORIES] memory _totalForPresale, \r\n        uint256[TOTAL_CATEGORIES] memory _totalForOwner,\r\n        uint256[TOTAL_CATEGORIES][TOTAL_CATEGORIES] memory _random,\r\n        address _superOwner) {\r\n        babyDogeNFT = BabyDogeNFT(_babyDogeNFT);\r\n        uint256 nextTokenId = 1;\r\n        for(uint8 index = 0; index < TOTAL_CATEGORIES; index++){\r\n            if(index == 0){\r\n                require(_random[index][0] + _random[index][1] + _random[index][2] == 0, 'Invalid Random');\r\n            } else if(index == 1){\r\n                require(_random[index][1] + _random[index][2] == 0, 'Invalid Random');\r\n            } else {\r\n                require(_random[index][2] == 0, 'Invalid Random');\r\n            }\r\n            require(_random[index][0] + _random[index][1] + _random[index][2] <=  _total[index], 'Invalid Random sum');\r\n            require(_total[index] >= _totalForPresale[index] + _totalForOwner[index], 'Invalid token counts');\r\n            tokenCategories[index] = CategoryDetail(_prices[index], _total[index], _totalForPresale[index], _totalForOwner[index], 0,0, nextTokenId);\r\n            nextTokenId = nextTokenId + _total[index];\r\n            \r\n        }\r\n        superOwner = _superOwner;\r\n    }\r\n\r\n    //USER FUNCTIONS\r\n    function buyToken(uint256 _tokenCategory, uint256 _totalUnits, uint256 _code) external isValidCategory(_tokenCategory) payable{\r\n        require(_totalUnits <= babyDogeNFT.maxMint() && _totalUnits > 0, 'Invalid number of units');\r\n        uint256 categoryUnit = _totalUnits;\r\n        uint256 startRandomId;\r\n        CategoryDetail storage categoryDetail = tokenCategories[_tokenCategory];\r\n        uint256 startTokenId = categoryDetail.nextTokenId;\r\n        if(stage == 0){\r\n            require(whitelistedAddress[msg.sender], 'Not eligible to buy in presale');\r\n            require(categoryDetail.totalMinted - categoryDetail.totalMintedForOwner + _totalUnits <= categoryDetail.totalForPresale, 'That much token not left in presale');\r\n        } else {\r\n            require(categoryDetail.totalMinted - categoryDetail.totalMintedForOwner + _totalUnits <= categoryDetail.total - categoryDetail.totalForOwner, 'That much token are not left');\r\n        }\r\n        uint256 price = _totalUnits * currentPrice(_tokenCategory);\r\n        require(msg.value >= price, 'Price of tokens is more than the given');\r\n        uint random = uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp))) % 15;\r\n        bool randomAllowed;\r\n        if (random > _tokenCategory && random < TOTAL_CATEGORIES && randomAvailable[random][_tokenCategory] > 0){\r\n            CategoryDetail storage randomCategoryDetail = tokenCategories[random];\r\n            if(stage == 0){\r\n                if(randomCategoryDetail.totalMinted - randomCategoryDetail.totalMintedForOwner < randomCategoryDetail.totalForPresale){\r\n                    randomAllowed = true;\r\n                }\r\n            } else {\r\n                if(categoryDetail.totalMinted - categoryDetail.totalMintedForOwner < categoryDetail.total - categoryDetail.totalForOwner){\r\n                    randomAllowed = true;\r\n                }\r\n            }\r\n            if(randomAllowed){\r\n                randomCategoryDetail.totalMinted++;\r\n                startRandomId = randomCategoryDetail.nextTokenId;\r\n                randomCategoryDetail.nextTokenId++;\r\n                randomAvailable[random][_tokenCategory]--;\r\n                categoryUnit--;\r\n            }\r\n            else {\r\n                random = _tokenCategory;\r\n            }\r\n        } \r\n        categoryDetail.totalMinted = categoryDetail.totalMinted + categoryUnit;\r\n        categoryDetail.nextTokenId = categoryDetail.nextTokenId + categoryUnit;\r\n        babyDogeNFT.mint(msg.sender, startTokenId, categoryUnit);\r\n        if(startRandomId > 0){\r\n            babyDogeNFT.mint(msg.sender, startRandomId, 1);\r\n            emit buy(msg.sender, _tokenCategory, random, startRandomId, 1, price, block.timestamp, stage);\r\n        }\r\n        uint256 ownerAmount = msg.value;\r\n        if(_code != 0){\r\n            ownerAmount = msg.value/2;\r\n            codesDetails[_code].totalCollected += msg.value - ownerAmount; //\r\n        }\r\n        payable(superOwner).transfer(ownerAmount);\r\n        emit buy(msg.sender, _tokenCategory, _tokenCategory, startTokenId, categoryUnit, price, block.timestamp, stage);\r\n     }\r\n\r\n    //ADMIN FUNCTIONS\r\n    function updateStage() external onlyOwner(){\r\n        stage = 1;\r\n    }\r\n\r\n    function updatePrices(uint256[TOTAL_CATEGORIES] memory _prices) external onlyOwner(){\r\n        for(uint8 index = 0; index < TOTAL_CATEGORIES; index++){\r\n            tokenCategories[index].price = _prices[index];\r\n        }\r\n    }\r\n\r\n    function whitelist(address[] memory _userAddress) external onlyOwner(){\r\n        for(uint256 index = 0; index < _userAddress.length; index++){\r\n            whitelistedAddress[_userAddress[index]] = true;\r\n        }\r\n    }\r\n\r\n    function giveBenefit(uint256 _code, address payable _userAddress) external onlyOwner(){\r\n        require(_code != 0, 'Invalid Code');\r\n        require(_userAddress != address(0), 'Invalid address');\r\n        uint256 amountToGive = codesDetails[_code].totalCollected - codesDetails[_code].totalGiven ;\r\n        require(amountToGive > 0, 'Nothing to give');\r\n        codesDetails[_code].totalGiven = codesDetails[_code].totalGiven + amountToGive;\r\n        _userAddress.transfer(amountToGive);\r\n    }\r\n\r\n    function blacklist(address[] memory _userAddress) external onlyOwner(){\r\n        for(uint256 index = 0; index < _userAddress.length; index++){\r\n            whitelistedAddress[_userAddress[index]] = false;\r\n        }\r\n    }\r\n\r\n    function withdraw() external {\r\n        require(msg.sender == superOwner, 'Only Super Owner can call');\r\n        require(address(this).balance > 0, 'Nothing to withdraw');\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n      \r\n    function changeSuperOwner(address _newSuperOwner) external {\r\n        require(msg.sender == superOwner, 'Only Super Owner can call');\r\n        require(_newSuperOwner != address(0), 'Invalid address');\r\n        superOwner = _newSuperOwner;\r\n    }\r\n\r\n    function buyTokenForOwner(uint256 _tokenCategory, uint256 _totalUnits) external onlyOwner() isValidCategory(_tokenCategory){\r\n        require(_totalUnits <= babyDogeNFT.maxMint() && _totalUnits > 0, 'Invalid number of units');\r\n        CategoryDetail storage categoryDetail = tokenCategories[_tokenCategory];\r\n        uint256 startTokenId = categoryDetail.nextTokenId;\r\n        require(categoryDetail.totalMintedForOwner + _totalUnits <= categoryDetail.totalForOwner, 'That much token are not left');\r\n        categoryDetail.totalMinted = categoryDetail.totalMinted + _totalUnits;\r\n        categoryDetail.totalMintedForOwner = categoryDetail.totalMintedForOwner + _totalUnits;\r\n        categoryDetail.nextTokenId = categoryDetail.nextTokenId + _totalUnits;\r\n        babyDogeNFT.mint(msg.sender, startTokenId, _totalUnits);\r\n        emit buyForOwner(msg.sender, _tokenCategory, startTokenId, _totalUnits, block.timestamp);\r\n    }\r\n\r\n    //VIEW FUNCTIONS\r\n\r\n    function currentPrice(uint256 _category) public view isValidCategory(_category) returns(uint256) {\r\n        CategoryDetail memory categoryDetail = tokenCategories[_category];\r\n        if(categoryDetail.totalMinted >= categoryDetail.total / 2 && categoryDetail.totalMinted < 3 * categoryDetail.total / 4) {\r\n            return categoryDetail.price * 2;\r\n        } else if(categoryDetail.totalMinted >= 3 * categoryDetail.total / 4){\r\n            return categoryDetail.price * 4;\r\n        } \r\n        return categoryDetail.price;\r\n    }\r\n\r\n    function availableTokens(uint256 _category) public view returns(uint256) {\r\n        CategoryDetail memory categoryDetail = tokenCategories[_category];\r\n        return categoryDetail.total - categoryDetail.totalMinted;\r\n    }\r\n\r\n    function availableTokensForOwner(uint256 _category) public view returns(uint256) {\r\n        CategoryDetail memory categoryDetail = tokenCategories[_category];\r\n        return categoryDetail.totalForOwner - categoryDetail.totalMintedForOwner;\r\n    }\r\n\r\n    function beneftiDetails(uint256 _code) public view returns(uint256, uint256) {\r\n        return (codesDetails[_code].totalCollected, codesDetails[_code].totalGiven);\r\n    }\r\n }", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_babyDogeNFT\",\"type\":\"address\"},{\"internalType\":\"uint256[3]\",\"name\":\"_prices\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[3]\",\"name\":\"_total\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[3]\",\"name\":\"_totalForPresale\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[3]\",\"name\":\"_totalForOwner\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[3][3]\",\"name\":\"_random\",\"type\":\"uint256[3][3]\"},{\"internalType\":\"address\",\"name\":\"_superOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestedTokenCategory\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"givenTokenCategory\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boughtAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stage\",\"type\":\"uint256\"}],\"name\":\"buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenCategory\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boughtAt\",\"type\":\"uint256\"}],\"name\":\"buyForOwner\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TOTAL_CATEGORIES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_category\",\"type\":\"uint256\"}],\"name\":\"availableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_category\",\"type\":\"uint256\"}],\"name\":\"availableTokensForOwner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"babyDogeNFT\",\"outputs\":[{\"internalType\":\"contract BabyDogeNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_code\",\"type\":\"uint256\"}],\"name\":\"beneftiDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_userAddress\",\"type\":\"address[]\"}],\"name\":\"blacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenCategory\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalUnits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_code\",\"type\":\"uint256\"}],\"name\":\"buyToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenCategory\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalUnits\",\"type\":\"uint256\"}],\"name\":\"buyTokenForOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newSuperOwner\",\"type\":\"address\"}],\"name\":\"changeSuperOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"codesDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalCollected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalGiven\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_category\",\"type\":\"uint256\"}],\"name\":\"currentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_code\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"giveBenefit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"randomAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"superOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenCategories\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalForPresale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalForOwner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalMinted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalMintedForOwner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextTokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"_prices\",\"type\":\"uint256[3]\"}],\"name\":\"updatePrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateStage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_userAddress\",\"type\":\"address[]\"}],\"name\":\"whitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BabyDogeMarketplace", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000003b302b854e2f93b25d398335f58d8166001c106600000000000000000000000000000000000000000000000000b1a2bc2ec500000000000000000000000000000000000000000000000000000429d069189e00000000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000000000000000bb80000000000000000000000000000000000000000000000000000000000000078000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000000003e80000000000000000000000000000000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000007800000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000698c5dddef84387b35fa071ff81b922187e58edf", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5c056ed72cc343c443cf93bb913d168818616d70323650974d5e9a76c5506556"}]}