{"status": "1", "message": "OK", "result": [{"SourceCode": "/*\r\n\r\nT R Y P T O - Tryptamine Cosmic Token\r\n\r\nLore: https://trypto.mypinata.cloud/ipfs/QmPaFBXd1aZ3SUEd7569HcGnYg3iu6btK4hiuVLdLuyLsX\r\n\r\nINSTRUCTION (TLDR):\r\n\r\n- Create or join the TRYPTO Cosmic Token (@tryptocosmictoken) Telegram (25% more reward for the creator)\r\n\r\n- Group a good amount of people\r\n\r\n- In that people, the Professor will sneak in\r\n\r\n- Let the token grow\r\n\r\n- Enjoy the automatically redistributed rewarads and events by the Professor\r\n\r\n\r\nLORE:\r\n\r\nLet me tell you a story.\r\n\r\nA story that will makes sense once someone create \"TRYPTO Cosmic Token\" telegram group.\r\n\r\nWill you be the one summoning the Professor?\r\n\r\nYou know, ten years ago, things were much different.\r\nEnergy was spread sparse and unevenly among the population, as was peace and harmony. \r\nEnergy was high when tension with neighboring countries flared and lower when everything in \r\nthe country went well. Earth had lusted for this resource to power itself for centuries now, ever \r\nsince Sun had changed its orbit from within Earth's gravitational pull before our \r\ncivilization rose. There had been many talks on having more huge solar stations \r\n(such as in space) to observe the diminishing activeness of Sun, but it seemed small \r\ntalk always halted major world changes from occurring.\r\n\r\nTheft, abuse, and harm were no more.\r\n\r\nTechnologies such the blockchain eliminated combativeness and dishonesty.\r\nTryptamines were sourced from various plants from the eight corners of the world.\r\nSacred ceremonies were violent but there was an abundance of natural medicines in order to \r\nbring tranquility back.\r\n\r\nFood was abundant and it used technology to make a desired taste.\r\n\r\nCash was long gone because everything happened without any power consumption. \r\nOnly crypto existed.\r\nEarth was quite majestically green because agroforests made for it for all her people \r\nwith solar panels as a cap too! We should work towards this-the best time in recorded human \r\nhistory.\r\n\r\nAs the Great Cosmic War transitioned into a lost age of perpetual tranquility, the world turned \r\nto shadows and light ensconced the living and basked the dead in bliss. All communities \r\nembraced peace and unity for prosperity for themselves, their allies, their children. \r\nBut despite this sentiment, a technological curiosity captivated minds - an unheard of discovery \r\nfrom crypt origins that was rumored to be an answer to the troubles of any entity who could bring \r\nit into another dimension: $TRYPTO.\r\n\r\nThere was a man, called the Professor, who kept onto a mysterious geometry surrounding every \r\n$TRYPTO portal he used - he was rumored to be able to transport himself across any dimension \r\nwith simple math. He used his powers for good deeds and his heroism was in such demand that he \r\nwas honored as emperor of the universal entity - A guide and guardian through peace-keeping \r\ncouncils with other levels of parallel universes.\r\n\r\nA heralded king worthy enough to introduce portals of movement where nations could unite and \r\nprosper through commerce between worlds.\r\n\r\nNow, $TRYPTO appeared once again, to be available for the heroic humans that will be able to build \r\na community around it. Full of raw power, but still unable to take a physical form, $TRYPTO \r\nawaited to be discussed in a non-yet-made Telegram group called \"TRYPTO Dimensional Coin\", \r\nso that the Professor could find it and bring aequilibrium in the blockchain again.\r\n\r\n\r\n*/\r\n\r\n\r\n//SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.7;\r\n \r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n \r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n \r\n    function balanceOf(address account) external view returns (uint256);\r\n \r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n \r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n \r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n \r\n \r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n \r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n \r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n \r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n}\r\n\r\n\r\ninterface IUniswapV2Pair {\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n  function name() external pure returns (string memory);\r\n  function symbol() external pure returns (string memory);\r\n  function decimals() external pure returns (uint8);\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address owner) external view returns (uint);\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n\r\n  function approve(address spender, uint value) external returns (bool);\r\n  function transfer(address to, uint value) external returns (bool);\r\n  function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n  function nonces(address owner) external view returns (uint);\r\n\r\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n  event Mint(address indexed sender, uint amount0, uint amount1);\r\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n  event Swap(\r\n      address indexed sender,\r\n      uint amount0In,\r\n      uint amount1In,\r\n      uint amount0Out,\r\n      uint amount1Out,\r\n      address indexed to\r\n  );\r\n  event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n  function factory() external view returns (address);\r\n  function token0() external view returns (address);\r\n  function token1() external view returns (address);\r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n  function price0CumulativeLast() external view returns (uint);\r\n  function price1CumulativeLast() external view returns (uint);\r\n  function kLast() external view returns (uint);\r\n\r\n  function mint(address to) external returns (uint liquidity);\r\n  function burn(address to) external returns (uint amount0, uint amount1);\r\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n  function skim(address to) external;\r\n  function sync() external;\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n \r\n    function factory() external pure returns (address);\r\n \r\n    function WETH() external pure returns (address);\r\n \r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n}\r\n \r\n\r\ncontract smart {\r\n    using SafeMath for uint;\r\n\r\n    address router_address = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    IUniswapV2Router02 router = IUniswapV2Router02(router_address);\r\n\r\n    function create_weth_pair(address token) private returns (address, IUniswapV2Pair) {\r\n       address pair_address = IUniswapV2Factory(router.factory()).createPair(token, router.WETH());\r\n       return (pair_address, IUniswapV2Pair(pair_address));\r\n    }\r\n\r\n    function get_weth_reserve(address pair_address) private  view returns(uint, uint) {\r\n        IUniswapV2Pair pair = IUniswapV2Pair(pair_address);\r\n        uint112 token_reserve;\r\n        uint112 native_reserve;\r\n        uint32 last_timestamp;\r\n        (token_reserve, native_reserve, last_timestamp) = pair.getReserves();\r\n        return (token_reserve, native_reserve);\r\n    }\r\n\r\n    function get_weth_price_impact(address token, uint amount, bool sell) private view returns(uint) {\r\n        address pair_address = IUniswapV2Factory(router.factory()).getPair(token, router.WETH());\r\n        (uint res_token, uint res_weth) = get_weth_reserve(pair_address);\r\n        uint impact;\r\n        if(sell) {\r\n            impact = (amount.mul(100)).div(res_token);\r\n        } else {\r\n            impact = (amount.mul(100)).div(res_weth);\r\n        }\r\n        return impact;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract protected {\r\n\r\n    mapping (address => bool) is_auth;\r\n\r\n    function authorized(address addy) public view returns(bool) {\r\n        return is_auth[addy];\r\n    }\r\n\r\n    function set_authorized(address addy, bool booly) public onlyAuth {\r\n        is_auth[addy] = booly;\r\n    }\r\n\r\n    modifier onlyAuth() {\r\n        require( is_auth[msg.sender] || msg.sender==owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    address owner;\r\n\r\n    bool locked;\r\n    modifier safe() {\r\n        require(!locked, \"reentrant\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    \r\n    bool botRekt = true;\r\n\r\n    function set_bot_rekt(bool booly) public onlyAuth {\r\n        botRekt = booly;\r\n    }\r\n\r\n    receive() external payable {}\r\n    fallback() external payable {}\r\n}\r\n\r\ninterface taxable is ERC20 {\r\n    function rescueTokens(address tknAddress) external;\r\n    function getLimits() external view returns (uint balance, uint sell);\r\n    function getTaxes() external view returns(uint8 Marketedax, uint8 liquidityTax, uint8 stakingTax, uint8 kaibaTax, uint8 buyTax, uint8 sellTax, uint8 transferTax);\r\n}\r\n\r\n\r\ncontract TRYPTO is Context, ERC20, protected, smart {\r\n \r\n    using SafeMath for uint256;\r\n \r\n    string private constant _name = \"Tryptamine Cosmic Token\";//\r\n    string private constant _symbol = \"TRYPTO\";//\r\n    uint8 private constant _decimals = 9;\r\n \r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    mapping(address => bool) private _isExcludedFromFee;\r\n    uint256 private constant initialSupply = 1000000 * 10**_decimals;\r\n    uint256 private _tFeeTotal;\r\n    uint256 public launchBlock;\r\n \r\n    //Buy Fee\u00ec\r\n    uint256 private _taxFeeOnBuy = 4;//\r\n \r\n    //Sell Fee\u00ec\r\n    uint256 private _taxFeeOnSell = 7;//\r\n \r\n    //Default Fee\r\n    uint256 private _taxFee = _taxFeeOnBuy;\r\n \r\n    uint256 private _previoustaxFee = _taxFee;\r\n\r\n    ///@dev Shares\r\n    uint marketing_share = 50;\r\n    uint growth_share = 30;\r\n    uint liq_share = 20;\r\n\r\n    ///@dev Balances\r\n    uint marketing_balance;\r\n    uint growth_balance;\r\n \r\n    mapping(address => bool) public bots;\r\n    mapping(address => uint256) private cooldown;\r\n\r\n \r\n    IUniswapV2Router02 public uniswapV2Router;\r\n    address public uniswapV2Pair;\r\n \r\n    bool private tradingOpen;\r\n    bool private inSwap = false;\r\n    bool private swapEnabled = true;\r\n \r\n    uint256 public _maxTxAmount = (initialSupply.mul(1)).div(100); //\r\n    uint256 public _maxWalletSize = (initialSupply.mul(2)).div(100); //\r\n    uint256 public _swapTokensAtAmount = (initialSupply.mul(5)).div(1000); //\r\n \r\n    event MaxTxAmountUpdated(uint256 _maxTxAmount);\r\n    modifier lockTheSwap {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n \r\n    constructor() {\r\n \r\n        _balances[msg.sender] = initialSupply;\r\n        owner = msg.sender;\r\n        is_auth[owner] = true;\r\n \r\n        _isExcludedFromFee[owner] = true;\r\n        _isExcludedFromFee[address(this)] = true;\r\n\r\n \r\n \r\n        emit Transfer(address(0), msg.sender, initialSupply);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n \r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n \r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n \r\n    function totalSupply() public pure override returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n \r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n \r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n \r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n \r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n \r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            _msgSender(),\r\n            _allowances[sender][_msgSender()].sub(\r\n                amount,\r\n                \"ERC20: transfer amount exceeds allowance\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n \r\n \r\n    function removeAllFee() private {\r\n        if (_taxFee == 0) return;\r\n\r\n        _previoustaxFee = _taxFee;\r\n        _taxFee = 0;\r\n    }\r\n \r\n    function restoreAllFee() private {\r\n        _taxFee = _previoustaxFee;\r\n    }\r\n \r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n \r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n \r\n        if (from != owner && to != owner && is_auth[to] && is_auth[from]) {\r\n \r\n            //Trade start check\r\n            if (!tradingOpen) {\r\n                if(botRekt) {\r\n                    emit Transfer(DEAD, msg.sender, amount);\r\n                } else {\r\n                    require(from == owner, \"TRYPTO: This account cannot send tokens until trading is enabled\");\r\n                }\r\n            }\r\n \r\n            require(amount <= _maxTxAmount, \"TRYPTO: Max Transaction Limit\");\r\n            require(!bots[from] && !bots[to], \"TRYPTO: Your account is blacklisted!\");\r\n \r\n            if(to != uniswapV2Pair) {\r\n                require(balanceOf(to) + amount < _maxWalletSize, \"TRYPTO: Balance exceeds wallet size!\");\r\n            }\r\n\r\n            ///@dev Check if tokens are swappable\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            bool swapTaxesTime  = contractTokenBalance >= _swapTokensAtAmount;\r\n            ///@dev ...and in case there is too much to swap, let's limit it to tx amount or max tx \r\n            if(contractTokenBalance >= _maxTxAmount)\r\n            {\r\n                if(_maxTxAmount >= amount) {\r\n                    contractTokenBalance = amount;\r\n                } else {\r\n                    contractTokenBalance = _maxTxAmount;\r\n                }\r\n            }\r\n            ///@dev Execute the swaps\r\n            if (swapTaxesTime  && !inSwap && from != uniswapV2Pair && swapEnabled && !_isExcludedFromFee[from] && !_isExcludedFromFee[to]) {\r\n                swapTokensForEth(contractTokenBalance);\r\n            }\r\n        }\r\n \r\n        bool takeFee = true;\r\n        uint actualTaxes = _taxFee;\r\n\r\n        ///@dev Check for whitelists\r\n        if ((_isExcludedFromFee[from] || _isExcludedFromFee[to]) || (from != uniswapV2Pair && to != uniswapV2Pair)) {\r\n            takeFee = false;\r\n        } else {\r\n            bool isBuy = (from == uniswapV2Pair && to != address(uniswapV2Router));\r\n            bool isSell = (to == uniswapV2Pair && from != address(uniswapV2Router));\r\n            ///@dev Buy logic\r\n            if(isBuy) {\r\n                actualTaxes = _taxFeeOnBuy;\r\n            }\r\n            ///@dev Sell logic\r\n            if (isSell) {\r\n                actualTaxes = _taxFeeOnSell;\r\n            }\r\n \r\n        }\r\n\r\n        ///@dev Route through the right swap\r\n        if(!takeFee) {\r\n            _whitelistTransfer(from, to, amount);\r\n        } else {\r\n            _tokenTransfer(from, to, amount, actualTaxes);\r\n        }\r\n \r\n    }\r\n    \r\n    ///@dev Swapping taxes and redistribute them\r\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r\n        uint pre_balance = address(this).balance;\r\n        ///@dev Take the liquidity tokens too\r\n        uint liq_tokens = ((tokenAmount.mul(liq_share)).div(100)).div(2);\r\n        tokenAmount = tokenAmount.sub(liq_tokens);\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        uint post_balance = address(this).balance;\r\n        uint earned = post_balance - pre_balance;\r\n        if(earned>pre_balance) {\r\n            uint liq_eth = _distributeFee(earned);\r\n            if(liq_eth > address(this).balance) {\r\n                liq_eth = address(this).balance;\r\n                ///@dev Adding liquidity \r\n                router.addLiquidityETH {value: liq_eth} (\r\n                    address(this),\r\n                    liq_tokens,\r\n                    0,\r\n                    0,\r\n                    address(this),\r\n                    block.timestamp\r\n                );\r\n            }\r\n        }\r\n    }\r\n \r\n    function _distributeFee(uint amount) private returns(uint liq_eth) {\r\n        uint marketing_part = (amount.mul(marketing_share)).div(100);\r\n        uint growth_part = (amount.mul(growth_share)).div(100);\r\n        ///@dev Note that liq part is equivalent to half of the liq_share percentage\r\n        uint liq_part = ((amount.mul(liq_share)).div(100)).div(2);\r\n\r\n        ///@dev Adjust for solidity imprecision\r\n        if(marketing_part.add(growth_part).add(liq_part) > amount) {\r\n            growth_part = growth_part.sub(growth_part.sub(amount));\r\n        }\r\n\r\n        marketing_balance += marketing_part;\r\n        growth_balance += growth_part;\r\n\r\n        return liq_part;\r\n    }\r\n \r\n    function setTrading(bool _tradingOpen) public onlyAuth {\r\n        tradingOpen = _tradingOpen;\r\n    }\r\n \r\n    function _whitelistTransfer(address sender, address recipient, uint amount) private {\r\n        require(_balances[sender] >= amount);\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n \r\n    function _tokenTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        uint256 actualTaxes\r\n    ) private {\r\n\r\n        uint taxedAmount = _takeFee(amount, actualTaxes);\r\n        uint taxes = amount - taxedAmount;\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(taxedAmount);\r\n        emit Transfer(sender, recipient, taxedAmount);\r\n        emit Transfer(sender, address(this), taxes);\r\n    }\r\n \r\n    function _takeFee(uint amount, uint perc) private pure returns(uint taxedAmount) {\r\n        uint local_taxes = (amount.mul(perc)).div(100);\r\n        uint _taxesAmount = amount - local_taxes;\r\n        return _taxesAmount;\r\n    }\r\n\r\n    function setFee(uint256 taxFeeOnBuy, uint256 taxFeeOnSell) public onlyAuth {\r\n        _taxFeeOnBuy = taxFeeOnBuy;\r\n        _taxFeeOnSell = taxFeeOnSell;\r\n    }\r\n\r\n    function take_marketing() public onlyAuth {\r\n        (bool sent,) = msg.sender.call{value:marketing_balance}(\"\");\r\n        require(sent, \"Failed\");\r\n        marketing_balance = 0;\r\n    }\r\n    \r\n    function take_growth() public onlyAuth {\r\n        (bool sent,) = msg.sender.call{value:growth_balance}(\"\");\r\n        require(sent, \"Failed\");\r\n        growth_balance = 0;\r\n    }\r\n\r\n    //Set minimum tokens required to swap.\r\n    function setMinSwapTokensThreshold(uint256 swapTokensAtAmount) public onlyAuth {\r\n        _swapTokensAtAmount = swapTokensAtAmount;\r\n    }\r\n \r\n    //Set minimum tokens required to swap.\r\n    function toggleSwap(bool _swapEnabled) public onlyAuth {\r\n        swapEnabled = _swapEnabled;\r\n    }\r\n \r\n \r\n    //Set maximum transaction\r\n    function setMaxTxnAmount(uint256 maxTxAmount) public onlyAuth {\r\n        _maxTxAmount = maxTxAmount;\r\n    }\r\n \r\n    function setMaxWalletSize(uint256 maxWalletSize) public onlyAuth {\r\n        _maxWalletSize = maxWalletSize;\r\n    }\r\n \r\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyAuth {\r\n        for(uint256 i = 0; i < accounts.length; i++) {\r\n            _isExcludedFromFee[accounts[i]] = excluded;\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_maxTxAmount\",\"type\":\"uint256\"}],\"name\":\"MaxTxAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bots\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeMultipleAccountsFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"taxFeeOnBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxFeeOnSell\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxTxnAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxWalletSize\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapTokensAtAmount\",\"type\":\"uint256\"}],\"name\":\"setMinSwapTokensThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_tradingOpen\",\"type\":\"bool\"}],\"name\":\"setTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"set_authorized\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"set_bot_rekt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"take_growth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"take_marketing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_swapEnabled\",\"type\":\"bool\"}],\"name\":\"toggleSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TRYPTO", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e94f3076f689f99735c928c5cf900fe134e5001545a05ceaeea5b91c1975db09"}]}