{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/core/DamageCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/// @title RaidParty Party Contract\\n\\n/**\\n *   ___      _    _ ___          _\\n *  | _ \\\\__ _(_)__| | _ \\\\__ _ _ _| |_ _  _\\n *  |   / _` | / _` |  _/ _` | '_|  _| || |\\n *  |_|_\\\\__,_|_\\\\__,_|_| \\\\__,_|_|  \\\\__|\\\\_, |\\n *                                    |__/\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IParty.sol\\\";\\nimport \\\"../interfaces/IDamageCalculator.sol\\\";\\nimport \\\"../interfaces/IHero.sol\\\";\\nimport \\\"../interfaces/IFighter.sol\\\";\\nimport \\\"../interfaces/IHeroURIHandler.sol\\\";\\nimport \\\"../interfaces/IFighterURIHandler.sol\\\";\\nimport \\\"../lib/Damage.sol\\\";\\n\\ncontract DamageCalculator is IDamageCalculator {\\n    IHero private _hero;\\n    IFighter private _fighter;\\n\\n    uint32 private constant PRECISION = 1000;\\n\\n    constructor(address hero, address fighter) {\\n        _hero = IHero(hero);\\n        _fighter = IFighter(fighter);\\n    }\\n\\n    function getHero() external view returns (address) {\\n        return address(_hero);\\n    }\\n\\n    function getFighter() external view returns (address) {\\n        return address(_fighter);\\n    }\\n\\n    // getDamageComponents computes and returns a large array of damage components maintaining input ordering\\n    function getDamageComponents(\\n        uint256[] calldata heroIds,\\n        uint256[] calldata fighterIds\\n    ) external view override returns (Damage.DamageComponent[] memory) {\\n        // Initialize equipped array\\n        Damage.DamageComponent[]\\n            memory components = new Damage.DamageComponent[](\\n                heroIds.length + fighterIds.length\\n            );\\n        uint256 idx;\\n\\n        idx = _getHeroComponents(components, heroIds, idx);\\n        idx = _getFighterComponents(components, fighterIds, idx);\\n\\n        return components;\\n    }\\n\\n    // Returns a hero damage component given an enhancement value\\n    function getHeroEnhancementComponents(\\n        uint256[] calldata ids,\\n        uint8[] calldata prev\\n    ) external view override returns (Damage.DamageComponent[] memory) {\\n        Damage.DamageComponent[]\\n            memory components = new Damage.DamageComponent[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            components[i] = _getHeroDamageComponentEnhancement(ids[i], prev[i]);\\n        }\\n        return components;\\n    }\\n\\n    // Returns a fighter damage component given an enhancement value\\n    function getFighterEnhancementComponents(\\n        uint256[] calldata ids,\\n        uint8[] calldata prev\\n    ) external view override returns (Damage.DamageComponent[] memory) {\\n        Damage.DamageComponent[]\\n            memory components = new Damage.DamageComponent[](ids.length);\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            components[i] = _getFighterDamageComponentEnhancement(\\n                ids[i],\\n                prev[i]\\n            );\\n        }\\n        return components;\\n    }\\n\\n    // Returns a hero damage component\\n    function getHeroDamageComponent(uint256 hero)\\n        external\\n        view\\n        override\\n        returns (Damage.DamageComponent memory)\\n    {\\n        return _getHeroDamageComponent(hero);\\n    }\\n\\n    // Returns a fighter damage component\\n    function getFighterDamageComponent(uint256 fighter)\\n        external\\n        view\\n        override\\n        returns (Damage.DamageComponent memory)\\n    {\\n        return _getFighterDamageComponent(fighter);\\n    }\\n\\n    // Collection of internal functions to get property damage components\\n    function _getFighterDamageComponent(uint256 id)\\n        internal\\n        view\\n        returns (Damage.DamageComponent memory)\\n    {\\n        Stats.FighterStats memory fStats = IFighterURIHandler(\\n            _fighter.getHandler()\\n        ).getStats(id);\\n\\n        return\\n            Damage.DamageComponent(\\n                0,\\n                uint32(\\n                    fStats.dmg +\\n                        _getFighterEnhancementAdjustment(\\n                            fStats.enhancement,\\n                            fStats.dmg\\n                        )\\n                )\\n            );\\n    }\\n\\n    function _getHeroDamageComponent(uint256 id)\\n        internal\\n        view\\n        returns (Damage.DamageComponent memory)\\n    {\\n        Stats.HeroStats memory hStats = IHeroURIHandler(_hero.getHandler())\\n            .getStats(id);\\n\\n        return\\n            Damage.DamageComponent(\\n                uint32(\\n                    hStats.dmgMultiplier +\\n                        _getHeroEnhancementMultiplier(hStats.enhancement, id)\\n                ),\\n                0\\n            );\\n    }\\n\\n    // Collection of internal functions to get property damage components with caller provided enhancement values\\n    function _getFighterDamageComponentEnhancement(\\n        uint256 id,\\n        uint8 enhancement\\n    ) internal view returns (Damage.DamageComponent memory) {\\n        Stats.FighterStats memory fStats = IFighterURIHandler(\\n            _fighter.getHandler()\\n        ).getStats(id);\\n\\n        return\\n            Damage.DamageComponent(\\n                0,\\n                uint32(\\n                    fStats.dmg +\\n                        _getFighterEnhancementAdjustment(\\n                            enhancement,\\n                            fStats.dmg\\n                        )\\n                )\\n            );\\n    }\\n\\n    function _getHeroDamageComponentEnhancement(uint256 id, uint8 enhancement)\\n        internal\\n        view\\n        returns (Damage.DamageComponent memory)\\n    {\\n        Stats.HeroStats memory hStats = IHeroURIHandler(_hero.getHandler())\\n            .getStats(id);\\n\\n        return\\n            Damage.DamageComponent(\\n                uint32(\\n                    hStats.dmgMultiplier +\\n                        _getHeroEnhancementMultiplier(enhancement, id)\\n                ),\\n                0\\n            );\\n    }\\n\\n    // Collection of internal functions to return components to caller provided component array\\n    function _getHeroComponents(\\n        Damage.DamageComponent[] memory components,\\n        uint256[] memory heroes,\\n        uint256 idx\\n    ) internal view returns (uint256) {\\n        for (uint256 i = 0; i < heroes.length; i++) {\\n            components[idx] = _getHeroDamageComponent(heroes[i]);\\n            idx += 1;\\n        }\\n\\n        return idx;\\n    }\\n\\n    function _getFighterComponents(\\n        Damage.DamageComponent[] memory components,\\n        uint256[] memory fighters,\\n        uint256 idx\\n    ) internal view returns (uint256) {\\n        for (uint256 i = 0; i < fighters.length; i++) {\\n            components[idx] = _getFighterDamageComponent(fighters[i]);\\n            idx += 1;\\n        }\\n\\n        return idx;\\n    }\\n\\n    // Collection of internal functions for enhancement computations\\n    function _getHeroEnhancementMultiplier(uint8 enhancement, uint256 tokenId)\\n        internal\\n        pure\\n        returns (uint8 multiplier)\\n    {\\n        if (tokenId <= 1111 && enhancement >= 5) {\\n            multiplier = 4 + 3 * (enhancement - 4);\\n        } else if (enhancement >= 5) {\\n            multiplier = 4 + 2 * (enhancement - 4);\\n        } else {\\n            multiplier = enhancement;\\n        }\\n    }\\n\\n    function _getFighterEnhancementAdjustment(uint8 enhancement, uint32 damage)\\n        internal\\n        pure\\n        returns (uint32)\\n    {\\n        if (enhancement == 0) {\\n            return 0;\\n        } else if (enhancement == 1) {\\n            return (160 * damage) / 100;\\n        } else if (enhancement == 2) {\\n            return (254 * damage) / 100;\\n        } else if (enhancement == 3) {\\n            return (320 * damage) / 100;\\n        } else if (enhancement == 4) {\\n            return (372 * damage) / 100;\\n        } else if (enhancement == 5) {\\n            return (414 * damage) / 100;\\n        } else if (enhancement == 6) {\\n            return (449 * damage) / 100;\\n        } else if (enhancement == 7) {\\n            return (480 * damage) / 100;\\n        } else if (enhancement == 8) {\\n            return (507 * damage) / 100;\\n        } else if (enhancement == 9) {\\n            return (532 * damage) / 100;\\n        } else if (enhancement == 10) {\\n            return (554 * damage) / 100;\\n        } else if (enhancement == 11) {\\n            return (574 * damage) / 100;\\n        } else if (enhancement == 12) {\\n            return (592 * damage) / 100;\\n        } else if (enhancement == 13) {\\n            return (609 * damage) / 100;\\n        } else if (enhancement == 14) {\\n            return (625 * damage) / 100;\\n        }\\n\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDamageCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../lib/Stats.sol\\\";\\nimport \\\"../lib/Damage.sol\\\";\\n\\ninterface IDamageCalculator {\\n    function getDamageComponents(\\n        uint256[] calldata heroIds,\\n        uint256[] calldata fighterIds\\n    ) external view returns (Damage.DamageComponent[] memory);\\n\\n    function getHeroEnhancementComponents(\\n        uint256[] calldata ids,\\n        uint8[] calldata prev\\n    ) external view returns (Damage.DamageComponent[] memory);\\n\\n    function getFighterEnhancementComponents(\\n        uint256[] calldata ids,\\n        uint8[] calldata prev\\n    ) external view returns (Damage.DamageComponent[] memory);\\n\\n    function getHeroDamageComponent(uint256 id)\\n        external\\n        view\\n        returns (Damage.DamageComponent memory);\\n\\n    function getFighterDamageComponent(uint256 id)\\n        external\\n        view\\n        returns (Damage.DamageComponent memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEnhanceable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IEnhanceable {\\n    struct EnhancementRequest {\\n        uint256 id;\\n        address requester;\\n    }\\n\\n    event EnhancementRequested(\\n        uint256 indexed tokenId,\\n        uint256 indexed timestamp\\n    );\\n\\n    event EnhancementCompleted(\\n        uint256 indexed tokenId,\\n        uint256 indexed timestamp,\\n        bool success,\\n        bool degraded\\n    );\\n\\n    event SeederUpdated(address indexed caller, address indexed seeder);\\n\\n    function enhancementCost(uint256 tokenId)\\n        external\\n        view\\n        returns (uint256, bool);\\n\\n    function enhance(uint256 tokenId, uint256 burnTokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFighter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IRaidERC721.sol\\\";\\nimport \\\"./IFighterURIHandler.sol\\\";\\nimport \\\"./ISeeder.sol\\\";\\n\\ninterface IFighter is IRaidERC721 {\\n    event HandlerUpdated(address indexed caller, address indexed handler);\\n\\n    function setHandler(IFighterURIHandler handler) external;\\n\\n    function getHandler() external view returns (address);\\n\\n    function getSeeder() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFighterURIHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IEnhanceable.sol\\\";\\nimport \\\"../lib/Stats.sol\\\";\\n\\ninterface IFighterURIHandler is IEnhanceable {\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    function getStats(uint256 tokenId)\\n        external\\n        view\\n        returns (Stats.FighterStats memory);\\n\\n    function getSeeder() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IHero.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IRaidERC721.sol\\\";\\nimport \\\"./IHeroURIHandler.sol\\\";\\nimport \\\"./ISeeder.sol\\\";\\n\\ninterface IHero is IRaidERC721 {\\n    event HandlerUpdated(address indexed caller, address indexed handler);\\n\\n    function setHandler(IHeroURIHandler handler) external;\\n\\n    function getHandler() external view returns (address);\\n\\n    function getSeeder() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IHeroURIHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IEnhanceable.sol\\\";\\nimport \\\"../lib/Stats.sol\\\";\\n\\ninterface IHeroURIHandler is IEnhanceable {\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    function getStats(uint256 tokenId)\\n        external\\n        view\\n        returns (Stats.HeroStats memory);\\n\\n    function getSeeder() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IParty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../lib/Stats.sol\\\";\\n\\ninterface IParty {\\n    event Equipped(address indexed user, uint8 item, uint8 slot, uint256 id);\\n\\n    event Unequipped(address indexed user, uint8 item, uint8 slot, uint256 id);\\n\\n    event DamageUpdated(address indexed user, uint32 damageCurr);\\n\\n    struct PartyData {\\n        uint256 hero;\\n        mapping(uint256 => uint256) fighters;\\n    }\\n\\n    struct Action {\\n        ActionType action;\\n        uint256 id;\\n        uint8 slot;\\n    }\\n\\n    enum Property {\\n        HERO,\\n        FIGHTER\\n    }\\n\\n    enum ActionType {\\n        UNEQUIP,\\n        EQUIP\\n    }\\n\\n    function act(\\n        Action[] calldata heroActions,\\n        Action[] calldata fighterActions\\n    ) external;\\n\\n    function equip(\\n        Property item,\\n        uint256 id,\\n        uint8 slot\\n    ) external;\\n\\n    function unequip(Property item, uint8 slot) external;\\n\\n    function enhance(\\n        Property item,\\n        uint8 slot,\\n        uint256 burnTokenId\\n    ) external;\\n\\n    function getUserHero(address user) external view returns (uint256);\\n\\n    function getUserFighters(address user)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    function getDamage(address user) external view returns (uint32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRaidERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IRaidERC721 is IERC721 {\\n    function getSeeder() external view returns (address);\\n\\n    function burn(uint256 tokenId) external;\\n\\n    function tokensOfOwner(address owner)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    function mint(address owner, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISeeder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../lib/Randomness.sol\\\";\\n\\ninterface ISeeder {\\n    event Requested(address indexed origin, uint256 indexed identifier);\\n\\n    event Seeded(bytes32 identifier, uint256 randomness);\\n\\n    function getIdReferenceCount(\\n        bytes32 randomnessId,\\n        address origin,\\n        uint256 startIdx\\n    ) external view returns (uint256);\\n\\n    function getIdentifiers(\\n        bytes32 randomnessId,\\n        address origin,\\n        uint256 startIdx,\\n        uint256 count\\n    ) external view returns (uint256[] memory);\\n\\n    function requestSeed(uint256 identifier) external;\\n\\n    function getSeed(address origin, uint256 identifier)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getSeedSafe(address origin, uint256 identifier)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function executeRequestMulti() external;\\n\\n    function isSeeded(address origin, uint256 identifier)\\n        external\\n        view\\n        returns (bool);\\n\\n    function setFee(uint256 fee) external;\\n\\n    function getFee() external view returns (uint256);\\n\\n    function getData(address origin, uint256 identifier)\\n        external\\n        view\\n        returns (Randomness.SeedData memory);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Damage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Damage {\\n    struct DamageComponent {\\n        uint32 m;\\n        uint32 d;\\n    }\\n\\n    uint256 public constant PRECISION = 10;\\n\\n    function computeDamage(DamageComponent memory dmg)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return (dmg.m * dmg.d) / PRECISION;\\n    }\\n\\n    // This function assumes a hero is equipped after state change\\n    function getDamageUpdate(\\n        Damage.DamageComponent calldata dmg,\\n        Damage.DamageComponent[] calldata removed,\\n        Damage.DamageComponent[] calldata added\\n    ) public pure returns (Damage.DamageComponent memory) {\\n        Damage.DamageComponent memory updatedDmg = Damage.DamageComponent(\\n            dmg.m,\\n            dmg.d\\n        );\\n\\n        for (uint256 i = 0; i < removed.length; i++) {\\n            updatedDmg.m -= removed[i].m;\\n            updatedDmg.d -= removed[i].d;\\n        }\\n\\n        for (uint256 i = 0; i < added.length; i++) {\\n            updatedDmg.m += added[i].m;\\n            updatedDmg.d += added[i].d;\\n        }\\n\\n        return updatedDmg;\\n    }\\n\\n    // This function assumes a hero is equipped after state change\\n    function getDamageUpdate(\\n        Damage.DamageComponent calldata dmg,\\n        Damage.DamageComponent calldata removed,\\n        Damage.DamageComponent calldata added\\n    ) public pure returns (Damage.DamageComponent memory) {\\n        Damage.DamageComponent memory updatedDmg = Damage.DamageComponent(\\n            dmg.m,\\n            dmg.d\\n        );\\n\\n        updatedDmg.m -= removed.m;\\n        updatedDmg.d -= removed.d;\\n\\n        updatedDmg.m += added.m;\\n        updatedDmg.d += added.d;\\n\\n        return updatedDmg;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Randomness.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Randomness {\\n    struct SeedData {\\n        uint256 batch;\\n        bytes32 randomnessId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Stats.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Stats {\\n    struct HeroStats {\\n        uint8 dmgMultiplier;\\n        uint8 partySize;\\n        uint8 enhancement;\\n    }\\n\\n    struct FighterStats {\\n        uint32 dmg;\\n        uint8 enhancement;\\n    }\\n\\n    struct EquipmentStats {\\n        uint32 dmg;\\n        uint8 dmgMultiplier;\\n        uint8 slot;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hero\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fighter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"heroIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"fighterIds\",\"type\":\"uint256[]\"}],\"name\":\"getDamageComponents\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"m\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"d\",\"type\":\"uint32\"}],\"internalType\":\"struct Damage.DamageComponent[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFighter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fighter\",\"type\":\"uint256\"}],\"name\":\"getFighterDamageComponent\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"m\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"d\",\"type\":\"uint32\"}],\"internalType\":\"struct Damage.DamageComponent\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"prev\",\"type\":\"uint8[]\"}],\"name\":\"getFighterEnhancementComponents\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"m\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"d\",\"type\":\"uint32\"}],\"internalType\":\"struct Damage.DamageComponent[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHero\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hero\",\"type\":\"uint256\"}],\"name\":\"getHeroDamageComponent\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"m\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"d\",\"type\":\"uint32\"}],\"internalType\":\"struct Damage.DamageComponent\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"prev\",\"type\":\"uint8[]\"}],\"name\":\"getHeroEnhancementComponents\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"m\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"d\",\"type\":\"uint32\"}],\"internalType\":\"struct Damage.DamageComponent[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DamageCalculator", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000966731dfd9b9925dd105ff465687f5aa8f54ee9f00000000000000000000000087e738a3d5e5345d6212d8982205a564289e6324", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}