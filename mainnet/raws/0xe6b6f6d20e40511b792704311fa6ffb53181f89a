{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/vaults/STETHVault.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.6;\\n\\nimport \\\"./BaseVault.sol\\\";\\n\\n/**\\n * @title A Vault that use variable weekly yields to buy calls\\n * @author Pods Finance\\n */\\ncontract STETHVault is BaseVault {\\n    using TransferUtils for IERC20Metadata;\\n    using FixedPointMath for uint256;\\n    using FixedPointMath for FixedPointMath.Fractional;\\n\\n    uint256 public constant DENOMINATOR = 10000;\\n\\n    uint8 public immutable sharePriceDecimals;\\n    uint256 public lastRoundAssets;\\n    FixedPointMath.Fractional public lastSharePrice;\\n\\n    uint256 public investorRatio = 5000;\\n    address public investor;\\n\\n    event StartRoundData(uint256 indexed roundId, uint256 lastRoundAssets, uint256 sharePrice);\\n    event EndRoundData(\\n        uint256 indexed roundId,\\n        uint256 roundAccruedInterest,\\n        uint256 investmentYield,\\n        uint256 idleAssets\\n    );\\n    event SharePrice(uint256 indexed roundId, uint256 startSharePrice, uint256 endSharePrice);\\n\\n    constructor(\\n        address _asset,\\n        address _strategist,\\n        address _investor\\n    ) BaseVault(_asset, _strategist) {\\n        investor = _investor;\\n        sharePriceDecimals = asset.decimals();\\n    }\\n\\n    /**\\n     * @dev See {IVault-name}.\\n     */\\n    function name() external pure override returns (string memory) {\\n        return \\\"stETH Vault\\\";\\n    }\\n\\n    function _afterRoundStart(uint256) internal override {\\n        lastRoundAssets = totalAssets();\\n        lastSharePrice = FixedPointMath.Fractional({\\n            numerator: totalShares == 0 ? 0 : lastRoundAssets,\\n            denominator: totalShares\\n        });\\n\\n        uint256 sharePrice = lastSharePrice.denominator == 0 ? 0 : lastSharePrice.mulDivDown(10**sharePriceDecimals);\\n        emit StartRoundData(currentRoundId, lastRoundAssets, sharePrice);\\n    }\\n\\n    function _afterRoundEnd() internal override {\\n        uint256 roundAccruedInterest;\\n        uint256 endSharePrice;\\n        uint256 investmentYield = asset.balanceOf(investor);\\n        uint256 idleAssets = asset.balanceOf(address(this));\\n\\n        if (totalShares != 0) {\\n            endSharePrice = (totalAssets() + investmentYield).mulDivDown(10**sharePriceDecimals, totalShares);\\n            roundAccruedInterest = totalAssets() - lastRoundAssets;\\n\\n            // Pulls the yields from investor\\n            if (investmentYield > 0) {\\n                asset.safeTransferFrom(investor, address(this), investmentYield);\\n            }\\n\\n            // Sends another batch to Investor\\n            uint256 investmentAmount = (roundAccruedInterest * investorRatio) / DENOMINATOR;\\n            if (investmentAmount > 0) {\\n                asset.safeTransfer(investor, investmentAmount);\\n            }\\n        }\\n        uint256 startSharePrice = lastSharePrice.denominator == 0\\n            ? 0\\n            : lastSharePrice.mulDivDown(10**sharePriceDecimals);\\n\\n        emit EndRoundData(currentRoundId, roundAccruedInterest, investmentYield, idleAssets);\\n        emit SharePrice(currentRoundId, startSharePrice, endSharePrice);\\n    }\\n\\n    function _beforeWithdraw(uint256 shares, uint256) internal override {\\n        lastRoundAssets -= shares.mulDivDown(lastSharePrice);\\n    }\\n\\n    /**\\n     * @dev See {BaseVault-totalAssets}.\\n     */\\n    function totalAssets() public view override returns (uint256) {\\n        return asset.balanceOf(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/vaults/BaseVault.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"../interfaces/IVault.sol\\\";\\nimport \\\"../libs/TransferUtils.sol\\\";\\nimport \\\"../libs/FixedPointMath.sol\\\";\\nimport \\\"../libs/DepositQueueLib.sol\\\";\\n\\n/**\\n * @title A Vault that tokenize shares of strategy\\n * @author Pods Finance\\n */\\ncontract BaseVault is IVault {\\n    using TransferUtils for IERC20Metadata;\\n    using FixedPointMath for uint256;\\n    using DepositQueueLib for DepositQueueLib.DepositQueue;\\n\\n    IERC20Metadata public immutable asset;\\n\\n    address public strategist;\\n\\n    uint256 public currentRoundId;\\n    mapping(address => uint256) userRounds;\\n\\n    mapping(address => uint256) userShares;\\n    uint256 public totalShares;\\n\\n    bool public isProcessingDeposits = false;\\n\\n    DepositQueueLib.DepositQueue private depositQueue;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    constructor(address _asset, address _strategist) {\\n        asset = IERC20Metadata(_asset);\\n        strategist = _strategist;\\n\\n        // Vault starts in `start` state\\n        emit StartRound(currentRoundId, 0);\\n    }\\n\\n    /** Depositor **/\\n\\n    /**\\n     * @dev See {IVault-deposit}.\\n     */\\n    function deposit(uint256 assets, address receiver) public virtual override {\\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\\n\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n        depositQueue.push(DepositQueueLib.DepositEntry(receiver, assets));\\n\\n        emit Deposit(receiver, assets);\\n    }\\n\\n    /**\\n     * @dev See {IVault-withdraw}.\\n     */\\n    function withdraw(address owner) public virtual override {\\n        if (isProcessingDeposits) revert IVault__ForbiddenWhileProcessingDeposits();\\n\\n        uint256 shares = sharesOf(owner);\\n        uint256 assets = _burnShares(owner, shares);\\n\\n        if (msg.sender != owner) {\\n            _useAllowance(owner, msg.sender, shares);\\n        }\\n\\n        // Apply custom withdraw logic\\n        _beforeWithdraw(shares, assets);\\n\\n        asset.safeTransfer(owner, assets);\\n\\n        emit Withdraw(owner, shares, assets);\\n    }\\n\\n    /**\\n     * @dev See {IVault-name}.\\n     */\\n    function name() external pure virtual override returns (string memory) {\\n        return \\\"Base Vault\\\";\\n    }\\n\\n    /**\\n     * @dev See {IVault-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IVault-approve}.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool) {\\n        if (spender == address(0)) revert IVault__ApprovalToAddressZero();\\n\\n        _allowances[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Outputs the amount of shares and the locked shares for a given `owner` address.\\n     */\\n    function sharesOf(address owner) public view virtual returns (uint256) {\\n        return userShares[owner];\\n    }\\n\\n    /**\\n     * @dev Outputs the amount of shares that would be generated by depositing `assets`.\\n     */\\n    function previewShares(uint256 assets) public view virtual returns (uint256) {\\n        uint256 shares;\\n\\n        if (totalShares > 0) {\\n            shares = assets.mulDivUp(totalShares, totalAssets());\\n        }\\n\\n        return shares;\\n    }\\n\\n    /**\\n     * @dev Outputs the amount of underlying tokens would be withdrawn with a given amount of shares.\\n     */\\n    function previewWithdraw(uint256 shares) public view virtual returns (uint256) {\\n        return shares.mulDivDown(totalAssets(), totalShares);\\n    }\\n\\n    /**\\n     * @dev Calculate the total amount of assets under management.\\n     */\\n    function totalAssets() public view virtual returns (uint256) {\\n        return asset.balanceOf(address(this));\\n    }\\n\\n    /**\\n     * @dev Outputs the amount of underlying tokens of an `owner` is idle, waiting for the next round.\\n     */\\n    function idleAmountOf(address owner) public view virtual returns (uint256) {\\n        return depositQueue.balanceOf(owner);\\n    }\\n\\n    /**\\n     * @dev Outputs current size of the deposit queue.\\n     */\\n    function depositQueueSize() external view returns (uint256) {\\n        return depositQueue.size();\\n    }\\n\\n    /** Strategist **/\\n\\n    modifier onlyStrategist() {\\n        if (msg.sender != strategist) revert IVault__CallerIsNotTheStrategist();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Starts the next round, sending the idle funds to the\\n     * strategist where it should start accruing yield.\\n     */\\n    function startRound() public virtual onlyStrategist {\\n        isProcessingDeposits = false;\\n\\n        uint256 idleBalance = asset.balanceOf(address(this));\\n        _afterRoundStart(idleBalance);\\n\\n        emit StartRound(currentRoundId, idleBalance);\\n    }\\n\\n    /**\\n     * @dev Closes the round, allowing deposits to the next round be processed.\\n     * and opens the window for withdraws.\\n     */\\n    function endRound() public virtual onlyStrategist {\\n        isProcessingDeposits = true;\\n        _afterRoundEnd();\\n\\n        emit EndRound(currentRoundId++);\\n    }\\n\\n    /**\\n     * @dev Mint shares for deposits accumulated, effectively including their owners in the next round.\\n     * `processQueuedDeposits` extracts up to but not including endIndex. For example, processQueuedDeposits(1,4)\\n     * extracts the second element through the fourth element (elements indexed 1, 2, and 3).\\n     *\\n     * @param startIndex Zero-based index at which to start processing deposits\\n     * @param endIndex The index of the first element to exclude from queue\\n     */\\n    function processQueuedDeposits(uint256 startIndex, uint256 endIndex) public {\\n        if (!isProcessingDeposits) revert IVault__NotProcessingDeposits();\\n\\n        uint256 processedDeposits;\\n        for (uint256 i = startIndex; i < endIndex; i++) {\\n            DepositQueueLib.DepositEntry memory depositEntry = depositQueue.get(i);\\n            uint256 shares = _mintShares(depositEntry.owner, depositEntry.amount, processedDeposits);\\n            processedDeposits += depositEntry.amount;\\n            emit DepositProcessed(depositEntry.owner, currentRoundId, depositEntry.amount, shares);\\n        }\\n        depositQueue.remove(startIndex, endIndex);\\n    }\\n\\n    /** Internals **/\\n\\n    /**\\n     * @dev Mint new shares, effectively representing user participation in the Vault.\\n     */\\n    function _mintShares(\\n        address owner,\\n        uint256 assets,\\n        uint256 processedDeposits\\n    ) internal virtual returns (uint256 shares) {\\n        shares = assets;\\n        processedDeposits += totalAssets();\\n\\n        if (totalShares > 0) {\\n            shares = assets.mulDivUp(totalShares, processedDeposits);\\n        }\\n\\n        userShares[owner] += shares;\\n        totalShares += shares;\\n    }\\n\\n    /**\\n     * @dev Burn shares.\\n     * @param owner Address owner of the shares\\n     * @param shares Amount of shares to lock\\n     */\\n    function _burnShares(address owner, uint256 shares) internal virtual returns (uint256 claimableUnderlying) {\\n        if (shares > userShares[owner]) revert IVault__CallerHasNotEnoughShares();\\n        claimableUnderlying = userShares[owner].mulDivDown(totalAssets(), totalShares);\\n        userShares[owner] -= shares;\\n        totalShares -= shares;\\n    }\\n\\n    /**\\n     * @dev Spend allowance on behalf of the shares owner.\\n     * @param owner Address owner of the shares\\n     * @param spender Address shares spender\\n     * @param shares Amount of shares to spend\\n     */\\n    function _useAllowance(\\n        address owner,\\n        address spender,\\n        uint256 shares\\n    ) internal {\\n        uint256 allowed = _allowances[owner][spender];\\n        if (shares > allowed) revert IVault__SharesExceedAllowance();\\n\\n        if (allowed != type(uint256).max) {\\n            _allowances[owner][spender] = allowed - shares;\\n        }\\n    }\\n\\n    /** Hooks **/\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    function _beforeWithdraw(uint256 shares, uint256 assets) internal virtual {}\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    function _afterRoundStart(uint256 assets) internal virtual {}\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    function _afterRoundEnd() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVault.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.6;\\n\\ninterface IVault {\\n    error IVault__CallerHasNotEnoughShares();\\n    error IVault__CallerIsNotTheStrategist();\\n    error IVault__NotProcessingDeposits();\\n    error IVault__ForbiddenWhileProcessingDeposits();\\n    error IVault__ApprovalToAddressZero();\\n    error IVault__SharesExceedAllowance();\\n\\n    event Deposit(address indexed owner, uint amountDeposited);\\n    event Withdraw(address indexed owner, uint sharesBurnt, uint amountWithdrawn);\\n    event StartRound(uint indexed roundId, uint amountAddedToStrategy);\\n    event EndRound(uint indexed roundId);\\n    event DepositProcessed(address indexed owner, uint indexed roundId, uint assets, uint shares);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /**\\n     * @dev Returns the name of the Vault.\\n     */\\n    function name() external view returns(string memory);\\n\\n    /**\\n     * @dev Deposits underlying tokens, generating shares.\\n     * @param assets The amount of asset token to deposit\\n     * @param receiver The address to be owner of the shares\\n     */\\n    function deposit(uint256 assets, address receiver) external;\\n\\n    /**\\n     * @dev Burn shares, withdrawing underlying tokens.\\n     */\\n    function withdraw(address owner) external;\\n\\n    /**\\n     * @dev Returns the remaining number of shares that `spender` will be\\n     * allowed to spend on behalf of `owner` through {withdraw}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {withdraw} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns(uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's shares.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Note that approving `type(uint256).max` is considered unlimited approval and should not be spent.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/TransferUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary TransferUtils {\\n    error TransferUtils__TransferDidNotSucceed();\\n\\n    function safeTransfer(IERC20 token, address to, uint value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory result) = address(token).call(data);\\n        if (!success || result.length > 0) {\\n            // Return data is optional\\n            bool transferSucceeded = abi.decode(result, (bool));\\n            if (!transferSucceeded) revert TransferUtils__TransferDidNotSucceed();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/FixedPointMath.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.6;\\n\\nlibrary FixedPointMath {\\n    error FixedPointMath__DivByZero();\\n    using FixedPointMath for uint256;\\n\\n    struct Fractional {\\n        uint256 numerator;\\n        uint256 denominator;\\n    }\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        if (denominator == 0) revert FixedPointMath__DivByZero();\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(x == 0 || (x * y) / x == y)\\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        if (denominator == 0) revert FixedPointMath__DivByZero();\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function mulDivUp(uint256 x, Fractional memory y) internal pure returns (uint256 z) {\\n        return x.mulDivUp(y.numerator, y.denominator);\\n    }\\n\\n    function mulDivDown(uint256 x, Fractional memory y) internal pure returns (uint256 z) {\\n        return x.mulDivDown(y.numerator, y.denominator);\\n    }\\n\\n    function mulDivUp(Fractional memory x, uint256 y) internal pure returns (uint256 z) {\\n        return x.numerator.mulDivUp(y, x.denominator);\\n    }\\n\\n    function mulDivDown(Fractional memory x, uint256 y) internal pure returns (uint256 z) {\\n        return x.numerator.mulDivDown(y, x.denominator);\\n    }\\n\\n    function fractionRoundUp(Fractional memory x) internal pure returns (uint256 z) {\\n        return x.numerator.mulDivUp(1, x.denominator);\\n    }\\n\\n    function fractionRoundDown(Fractional memory x) internal pure returns (uint256 z) {\\n        return x.numerator.mulDivDown(1, x.denominator);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/DepositQueueLib.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.6;\\n\\nlibrary DepositQueueLib {\\n    struct DepositEntry {\\n        address owner;\\n        uint amount;\\n    }\\n\\n    struct DepositQueue {\\n        address[] list;\\n        mapping(address => uint) cache;\\n    }\\n\\n    function push(DepositQueue storage queue, DepositEntry memory deposit) external {\\n        if (queue.cache[deposit.owner] == 0) {\\n            queue.list.push(deposit.owner);\\n        }\\n\\n        queue.cache[deposit.owner] += deposit.amount;\\n    }\\n\\n    function remove(DepositQueue storage queue, uint startIndex, uint endIndex) external {\\n        if (endIndex > startIndex) {\\n            // Remove the interval from the cache\\n            while(startIndex < endIndex) {\\n                queue.cache[queue.list[startIndex]] = 0;\\n                startIndex++;\\n            }\\n\\n            // Update the list with the remaining entries\\n            address[] memory newList = new address[](queue.list.length - endIndex);\\n            uint i = 0;\\n\\n            while(endIndex < queue.list.length) {\\n                newList[i++] = queue.list[endIndex++];\\n            }\\n\\n            queue.list = newList;\\n        }\\n    }\\n\\n    function get(DepositQueue storage queue, uint index) external view returns(DepositEntry memory depositEntry) {\\n        address owner = queue.list[index];\\n        depositEntry.owner = owner;\\n        depositEntry.amount = queue.cache[owner];\\n    }\\n\\n    function balanceOf(DepositQueue storage queue, address owner) external view returns(uint) {\\n        return queue.cache[owner];\\n    }\\n\\n    function size(DepositQueue storage queue) external view returns(uint) {\\n        return queue.list.length;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libs/DepositQueueLib.sol\": {\r\n        \"DepositQueueLib\": \"0xf378794d7e6062ee64e53c8be33e9b16d5a034dc\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_strategist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_investor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FixedPointMath__DivByZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IVault__ApprovalToAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IVault__CallerHasNotEnoughShares\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IVault__CallerIsNotTheStrategist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IVault__ForbiddenWhileProcessingDeposits\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IVault__NotProcessingDeposits\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IVault__SharesExceedAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferUtils__TransferDidNotSucceed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDeposited\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"DepositProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"EndRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundAccruedInterest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investmentYield\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"idleAssets\",\"type\":\"uint256\"}],\"name\":\"EndRoundData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startSharePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endSharePrice\",\"type\":\"uint256\"}],\"name\":\"SharePrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAddedToStrategy\",\"type\":\"uint256\"}],\"name\":\"StartRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastRoundAssets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharePrice\",\"type\":\"uint256\"}],\"name\":\"StartRoundData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesBurnt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"contract IERC20Metadata\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRoundId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositQueueSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"idleAmountOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investorRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isProcessingDeposits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRoundAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastSharePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"processQueuedDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sharePriceDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"sharesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "STETHVault", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000ae7ab96520de3a18e5e111b5eaab095312d7fe84000000000000000000000000a8e8affc55e6ab42ba4a3e19cb5a3c7adcf0407b0000000000000000000000006af3ad73a094df093e190a34975d757c0030f893", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}