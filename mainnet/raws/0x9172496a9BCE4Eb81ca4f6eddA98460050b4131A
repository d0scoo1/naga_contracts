{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LaserWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.14;\\n\\nimport \\\"./core/AccountAbstraction.sol\\\";\\nimport \\\"./core/Singleton.sol\\\";\\nimport \\\"./handlers/Handler.sol\\\";\\nimport \\\"./interfaces/ILaserWallet.sol\\\";\\nimport \\\"./libraries/UserOperation.sol\\\";\\nimport \\\"./ssr/SSR.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/**\\n * @title LaserWallet - EVM based smart contract wallet. Implementes \\\"sovereign social recovery\\\" mechanism and account abstraction.\\n * @author Rodrigo Herrera I.\\n */\\ncontract LaserWallet is\\n    Singleton,\\n    AccountAbstraction,\\n    SSR,\\n    Handler,\\n    ILaserWallet\\n{\\n    string public constant VERSION = \\\"1.0.0\\\";\\n\\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\\n        keccak256(\\\"EIP712Domain(uint256 chainId,address verifyingContract)\\\");\\n    bytes32 private constant LASER_OP_TYPEHASH =\\n        keccak256(\\n            \\\"LaserOp(address sender,uint256 nonce,bytes callData,uint256 callGas,uint256 verificationGas,uint256 preVerificationGas,uint256 maxFeePerGas,uint256 maxPriorityFeePerGas,address paymaster,bytes paymasterData)\\\"\\n        );\\n    bytes4 private constant EIP1271_MAGIC_VALUE =\\n        bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"));\\n\\n    uint256 public nonce;\\n\\n    modifier onlyEntryPoint() {\\n        if (msg.sender != entryPoint) revert LW__notEntryPoint();\\n        _;\\n    }\\n\\n    constructor() {\\n        // This makes the singleton unusable. e.g. (parity wallet hack).\\n        owner = address(this);\\n    }\\n\\n    receive() external payable {\\n        emit Received(msg.sender, msg.value);\\n    }\\n\\n    /**\\n     * @dev Setup function, sets initial storage of contract.\\n     * @param _owner The owner of the wallet.\\n     * @param _recoveryOwner Recovery owner in case the owner looses the main device. Implementation of Sovereign Social Recovery.\\n     * @param _guardians Addresses that can activate the social recovery mechanism.\\n     * @param _entryPoint Entry Point contract address.\\n     * @notice It can't be called after initialization.\\n     */\\n    function init(\\n        address _owner,\\n        address _recoveryOwner,\\n        address[] calldata _guardians,\\n        address _entryPoint\\n    ) external {\\n        // initOwner() requires that the current owner is address 0.\\n        // This is enough to protect init() from being called after initialization.\\n        initOwners(_owner, _recoveryOwner);\\n        initGuardians(_guardians);\\n        initEntryPoint(_entryPoint);\\n        emit Setup(owner, _guardians, entryPoint);\\n    }\\n\\n    /**\\n     * @dev Validates that the exeuction from EntryPoint is correct.\\n     * EIP: https://eips.ethereum.org/EIPS/eip-4337\\n     * @param userOp UserOperation struct that contains the transaction information.\\n     * @param _requiredPrefund amount to pay to EntryPoint to perform execution.\\n     */\\n    function validateUserOp(\\n        UserOperation calldata userOp,\\n        bytes32,\\n        uint256 _requiredPrefund\\n    ) external onlyEntryPoint {\\n        // Increase the nonce to avoid drained funds from multiple pay prefunds.\\n        if (nonce++ != userOp.nonce) revert LW__validateUserOp__invalidNonce();\\n\\n        // We encode the transaction data ...\\n        bytes memory userOpData = encodeUserOperationData(\\n            userOp.sender,\\n            userOp.nonce,\\n            userOp.callData,\\n            userOp.callGas,\\n            userOp.verificationGas,\\n            userOp.preVerificationGas,\\n            userOp.maxFeePerGas,\\n            userOp.maxPriorityFeePerGas,\\n            userOp.paymaster,\\n            userOp.paymasterData\\n        );\\n\\n        // Now we hash it ...\\n        bytes32 dataHash = keccak256(userOpData);\\n\\n        // We get the actual function selector to determine access ...\\n        bytes4 funcSelector = bytes4(userOp.callData[132:]);\\n\\n        // access() checks if the wallet is locked for the owner or guardians ...\\n        Access _access = access(funcSelector);\\n\\n        // We verify that the signatures are correct depending on the transaction type ...\\n        verifySignatures(_access, dataHash, userOp.signature);\\n\\n        // Finally... we can pay the costs to the EntryPoint ...\\n        payPrefund(_requiredPrefund);\\n    }\\n\\n    /**\\n     * @dev Executes an AA transaction. The msg.sender needs to be the EntryPoint address.\\n     * The signatures are verified in validateUserOp().\\n     * @param to Destination address of the transaction.\\n     * @param value Ether value of the transaction.\\n     * @param data Data payload of the transaction.\\n     */\\n    function exec(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) external onlyEntryPoint {\\n        bool success = _call(to, value, data, gasleft());\\n        if (!success) revert LW__exec__failure();\\n        else emit Success(to, value, bytes4(data));\\n    }\\n\\n    /**\\n     * @dev Returns the user operation hash to be signed by owners.\\n     * @param userOp The UserOperation struct.\\n     */\\n    function userOperationHash(UserOperation calldata userOp)\\n        external\\n        view\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                encodeUserOperationData(\\n                    userOp.sender,\\n                    userOp.nonce,\\n                    userOp.callData,\\n                    userOp.callGas,\\n                    userOp.verificationGas,\\n                    userOp.preVerificationGas,\\n                    userOp.maxFeePerGas,\\n                    userOp.maxPriorityFeePerGas,\\n                    userOp.paymaster,\\n                    userOp.paymasterData\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Implementation of EIP 1271: https://eips.ethereum.org/EIPS/eip-1271.\\n     * @param hash Hash of a message signed on behalf of address(this).\\n     * @param signature Signature byte array associated with _msgHash.\\n     * @return Magic value  or reverts with an error message.\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature)\\n        external\\n        view\\n        returns (bytes4)\\n    {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        (r, s, v) = splitSigs(signature, 0);\\n        address recovered = returnSigner(hash, r, s, v);\\n        if (recovered != owner) revert LW__isValidSignature__invalidSigner();\\n        else return EIP1271_MAGIC_VALUE;\\n    }\\n\\n    /**\\n     * @return chainId The chain id of this.\\n     */\\n    function getChainId() public view returns (uint256 chainId) {\\n        assembly {\\n            chainId := chainid()\\n        }\\n    }\\n\\n    function domainSeparator() public view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    DOMAIN_SEPARATOR_TYPEHASH,\\n                    getChainId(),\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Pays the required amount to the EntryPoint contract.\\n     * @param requiredPrefund amount to pay to EntryPoint to perform execution.\\n     */\\n    function payPrefund(uint256 requiredPrefund) internal {\\n        if (requiredPrefund > 0) {\\n            // If we need to pay back to EntryPoint ...\\n            // The only possible caller of this function is EntryPoint.\\n            bool success = _call(\\n                payable(msg.sender),\\n                requiredPrefund,\\n                new bytes(0),\\n                gasleft()\\n            );\\n            // It is EntryPoint's job to check for success.\\n            (success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Verifies that the signature(s) match the transaction type and sender.\\n     * @param _access Who has permission to invoke this transaction.\\n     * @param dataHash The keccak256 has of the transaction's data playload.\\n     * @param signatures The signatures sent by the UserOp.\\n     */\\n    function verifySignatures(\\n        Access _access,\\n        bytes32 dataHash,\\n        bytes calldata signatures\\n    ) internal view {\\n        if (_access == Access.Owner) {\\n            verifyOwner(dataHash, signatures);\\n        } else if (_access == Access.Guardian) {\\n            verifyGuardian(dataHash, signatures);\\n        } else if (_access == Access.OwnerAndGuardian) {\\n            verifyOwnerAndGuardian(dataHash, signatures);\\n        } else if (_access == Access.RecoveryOwnerAndGuardian) {\\n            verifyRecoveryOwnerAndGurdian(dataHash, signatures);\\n        } else if (_access == Access.OwnerAndRecoveryOwner) {\\n            verifyOwnerAndRecoveryOwner(dataHash, signatures);\\n        } else {\\n            revert();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the bytes that are hashed to be signed by owners.\\n     * @param sender The wallet making the operation (should be address(this)).\\n     * @param _nonce Anti-replay parameter; also used as the salt for first-time wallet creation.\\n     * @param callData The data to pass to the sender during the main execution call.\\n     * @param callGas The amount of gas to allocate the main execution call.\\n     * @param verificationGas The amount of gas to allocate for the verification step.\\n     * @param preVerificationGas The amount of gas to pay to compensate the bundler for the pre-verification execution and calldata.\\n     * @param maxFeePerGas Maximum fee per gas (similar to EIP 1559  max_fee_per_gas).\\n     * @param maxPriorityFeePerGas Maximum priority fee per gas (similar to EIP 1559 max_priority_fee_per_gas).\\n     * @param paymaster Address sponsoring the transaction (or zero for regular self-sponsored transactions).\\n     * @param paymasterData Extra data to send to the paymaster.\\n     */\\n    function encodeUserOperationData(\\n        address sender,\\n        uint256 _nonce,\\n        bytes calldata callData,\\n        uint256 callGas,\\n        uint256 verificationGas,\\n        uint256 preVerificationGas,\\n        uint256 maxFeePerGas,\\n        uint256 maxPriorityFeePerGas,\\n        address paymaster,\\n        bytes calldata paymasterData\\n    ) internal view returns (bytes memory) {\\n        bytes32 _userOperationHash = keccak256(\\n            abi.encode(\\n                LASER_OP_TYPEHASH,\\n                sender,\\n                _nonce,\\n                keccak256(callData),\\n                callGas,\\n                verificationGas,\\n                preVerificationGas,\\n                maxFeePerGas,\\n                maxPriorityFeePerGas,\\n                paymaster,\\n                keccak256(paymasterData)\\n            )\\n        );\\n        return\\n            abi.encodePacked(\\n                bytes1(0x19),\\n                bytes1(0x01),\\n                domainSeparator(),\\n                _userOperationHash\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/AccountAbstraction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.14;\\n\\nimport \\\"../core/SelfAuthorized.sol\\\";\\nimport \\\"../interfaces/IStakeManager.sol\\\";\\nimport \\\"../interfaces/IAccountAbstraction.sol\\\";\\n\\n/**\\n * @title AccountAbstraction - Handles the entry point address. Can only be changed through a safe transaction.\\n */\\ncontract AccountAbstraction is IAccountAbstraction, SelfAuthorized {\\n    // Entrypoint address should always be located at storage slot 1.\\n    address public entryPoint;\\n\\n    /**\\n     * @dev Inits the entry point address.\\n     * @param _entryPoint the entry point address.\\n     */\\n    function initEntryPoint(address _entryPoint) internal {\\n        if (_entryPoint.code.length == 0 || _entryPoint == address(this))\\n            revert AA__initEntryPoint__invalidEntryPoint();\\n\\n        entryPoint = _entryPoint;\\n    }\\n\\n    /**\\n     * @dev Withdraws deposits from the Entry Point.\\n     * @param amount The amount to withdraw.\\n     */\\n    function withdrawDeposit(uint256 amount) external authorized {\\n        if (IStakeManager(entryPoint).balanceOf(address(this)) < amount)\\n            revert AA__withdrawDeposit__insufficientBalance();\\n\\n        // The stake manager will check for success.\\n        IStakeManager(entryPoint).withdrawTo(address(this), amount);\\n    }\\n\\n    /**\\n     * @dev Changes the entry point address.\\n     * @param newEntryPoint  new entry point address.\\n     */\\n    function changeEntryPoint(address newEntryPoint) external authorized {\\n        if (\\n            newEntryPoint.code.length == 0 ||\\n            newEntryPoint == address(this) ||\\n            entryPoint == newEntryPoint\\n        ) revert AA__changeEntryPoint__invalidEntryPoint();\\n\\n        entryPoint = newEntryPoint;\\n        emit EntryPointChanged(entryPoint);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/Singleton.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.14;\\n\\nimport \\\"../interfaces/IERC165.sol\\\";\\nimport \\\"../interfaces/ISingleton.sol\\\";\\nimport \\\"./SelfAuthorized.sol\\\";\\n\\n/**\\n * @title Singleton - Base for singleton contracts (should always be first super contract).\\n * This contract is tightly coupled to our proxy contract (see `proxies/LaserProxy.sol`).\\n */\\ncontract Singleton is SelfAuthorized, ISingleton {\\n    // Singleton always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\\n    // It should also always be ensured that the address is stored alone (uses a full word)\\n    address public singleton;\\n\\n    /**\\n     * @dev Migrates to a new singleton (implementation).\\n     * @param _singleton New implementation address.\\n     */\\n    function upgradeSingleton(address _singleton) external authorized {\\n        if (_singleton == address(this))\\n            revert Singleton__upgradeSingleton__incorrectAddress();\\n\\n        if (!IERC165(_singleton).supportsInterface(0xae029e0b)) {\\n            //bytes4(keccak256(\\\"I_AM_LASER\\\")))\\n            revert Singleton__upgradeSingleton__notLaser();\\n        } else {\\n            singleton = _singleton;\\n            emit SingletonChanged(_singleton);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/handlers/Handler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.14;\\n\\nimport \\\"../interfaces/IHandler.sol\\\";\\nimport \\\"../interfaces/IERC165.sol\\\";\\n\\n/**\\n * @title TokenHandler - Supports token callbacks.\\n */\\ncontract Handler is IHandler, IERC165 {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure returns (bytes4) {\\n        return 0x150b7a02;\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external pure returns (bytes4) {\\n        return 0xf23a6e61;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external pure returns (bytes4 result) {\\n        return 0xbc197c81;\\n    }\\n\\n    function tokensReceived(\\n        address,\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata,\\n        bytes calldata\\n    ) external pure {}\\n\\n    function supportsInterface(bytes4 _interfaceId)\\n        external\\n        pure\\n        returns (bool)\\n    {\\n        return\\n            _interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165\\n            _interfaceId == 0x1626ba7e || // EIP 1271\\n            _interfaceId == 0xd9b67a26 || // ERC165 interface ID for ERC1155\\n            _interfaceId == 0x4e2312e0 || // ERC-1155 `ERC1155TokenReceiver` support (i.e. `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\")) ^bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`).\\n            _interfaceId == 0xae029e0b || // Laser Wallet contract: bytes4(keccak256(\\\"I_AM_LASER\\\"))\\n            _interfaceId == 0x150b7a02; // ERC721 onErc721Received\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILaserWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.14;\\n\\nimport {UserOperation} from \\\"../libraries/UserOperation.sol\\\";\\n\\n/**\\n * @title ILaserWallet\\n * @author Rodrigo Herrera I.\\n * @notice Has all the external functions, structs, events and errors for LaserWallet.sol.\\n */\\ninterface ILaserWallet {\\n    event Received(address indexed sender, uint256 amount);\\n    event Setup(address owner, address[] guardians, address entryPoint);\\n    event Success(address to, uint256 value, bytes4 funcSelector);\\n\\n    ///@dev modifier custom error.\\n    error LW__notEntryPoint();\\n\\n    ///@dev validateUserOp custom error.\\n    error LW__validateUserOp__invalidNonce();\\n\\n    ///@dev exec() custom error.\\n    error LW__exec__failure();\\n\\n    ///@dev isValidSignature() custom error.\\n    error LW__isValidSignature__invalidSigner();\\n\\n    /**\\n     * @dev Setup function, sets initial storage of contract.\\n     * @param owner The owner of the wallet.\\n     * @param recoveryOwner Recovery owner in case the owner looses the main device. Implementation of Sovereign Social Recovery.\\n     * @param guardians Addresses that can activate the social recovery mechanism.\\n     * @param entryPoint Entry Point contract address.\\n     * @notice It can't be called after initialization.\\n     */\\n    function init(\\n        address owner,\\n        address recoveryOwner,\\n        address[] calldata guardians,\\n        address entryPoint\\n    ) external;\\n\\n    /**\\n     * @dev Core interface to be EIP4337 compliant.\\n     * @param userOp the operation to be executed.\\n     * @param _requiredPrefund the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\\n     * @notice only the EntryPoint contract can call this function.\\n     */\\n    function validateUserOp(\\n        UserOperation calldata userOp,\\n        bytes32,\\n        uint256 _requiredPrefund\\n    ) external;\\n\\n    /**\\n     * @dev Executes an AA transaction. The msg.sender needs to be the EntryPoint address.\\n     * The signatures are verified in validateUserOp().\\n     * @param to Destination address of the transaction.\\n     * @param value Ether value of the transaction.\\n     * @param data Data payload of the transaction.\\n     */\\n    function exec(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) external;\\n\\n    /**\\n     * @dev Returns the user operation hash to be signed by owners.\\n     * @param userOp The UserOperation struct.\\n     */\\n    function userOperationHash(UserOperation calldata userOp)\\n        external\\n        view\\n        returns (bytes32);\\n\\n    /**\\n     * @dev Implementation of EIP 1271: https://eips.ethereum.org/EIPS/eip-1271.\\n     * @param hash Hash of a message signed on behalf of address(this).\\n     * @param signature Signature byte array associated with _msgHash.\\n     * @return Magic value  or reverts with an error message.\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature)\\n        external\\n        returns (bytes4);\\n\\n    /**\\n     * @dev Returns the chain id of this.\\n     */\\n    function getChainId() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator of this.\\n     * @notice This is done to avoid replay attacks.\\n     */\\n    function domainSeparator() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/UserOperation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.14;\\n\\n/**\\n * @param sender The wallet making the operation (should be address(this)).\\n * @param nonce Anti-replay parameter; also used as the salt for first-time wallet creation.\\n * @param initCode The initCode of the wallet (only needed if the wallet is not yet on-chain and needs to be created).\\n * @param callData The data to pass to the sender during the main execution call.\\n * @param callGas The amount of gas to allocate the main execution call.\\n * @param verificationGas The amount of gas to allocate for the verification step.\\n * @param preVerificationGas The amount of gas to pay to compensate the bundler for the pre-verification execution and calldata.\\n * @param maxFeePerGas Maximum fee per gas (similar to EIP 1559  max_fee_per_gas).\\n * @param maxPriorityFeePerGas Maximum priority fee per gas (similar to EIP 1559 max_priority_fee_per_gas).\\n * @param paymaster Address sponsoring the transaction (or zero for regular self-sponsored transactions).\\n * @param paymasterData Extra data to send to the paymaster.\\n * @param signature Data passed into the wallet along with the nonce during the verification step.\\n */\\nstruct UserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    uint256 callGas;\\n    uint256 verificationGas;\\n    uint256 preVerificationGas;\\n    uint256 maxFeePerGas;\\n    uint256 maxPriorityFeePerGas;\\n    address paymaster;\\n    bytes paymasterData;\\n    bytes signature;\\n}\\n\"\r\n    },\r\n    \"contracts/ssr/SSR.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.14;\\n\\nimport \\\"../core/SelfAuthorized.sol\\\";\\nimport \\\"../core/Owner.sol\\\";\\nimport \\\"../interfaces/IEIP1271.sol\\\";\\nimport \\\"../interfaces/IERC165.sol\\\";\\nimport \\\"../interfaces/ISSR.sol\\\";\\nimport \\\"../utils/Utils.sol\\\";\\n\\n/**\\n * @title SSR - Sovereign Social Recovery\\n * @notice New wallet recovery mechanism.\\n * @author Rodrigo Herrera I.\\n */\\ncontract SSR is ISSR, SelfAuthorized, Owner, Utils {\\n    ///@dev pointer address for the nested mapping.\\n    address internal constant pointer = address(0x1);\\n\\n    uint256 internal guardianCount;\\n\\n    bool public isLocked;\\n\\n    ///@dev If guardians are blocked, they cannot do any transaction.\\n    ///This is to completely prevent from guardians misbehaving.\\n    bool public guardiansBlocked;\\n\\n    mapping(address => address) internal guardians;\\n\\n    /**\\n     *\u00a0@dev Locks the wallet. Can only be called by a guardian.\\n     */\\n    function lock() external authorized {\\n        isLocked = true;\\n        emit WalletLocked();\\n    }\\n\\n    /**\\n     * @dev Unlocks the wallet. Can only be called by a guardian + the owner.\\n     */\\n    function unlock() external authorized {\\n        isLocked = false;\\n        emit WalletUnlocked();\\n    }\\n\\n    /**\\n     * @dev Unlocks the wallet. Can only be called by the recovery owner + the owner.\\n     * This is to avoid the wallet being locked forever if a guardian misbehaves.\\n     * The guardians will be locked until the owner decides otherwise.\\n     */\\n    function recoveryUnlock() external authorized {\\n        isLocked = false;\\n        guardiansBlocked = true;\\n        emit RecoveryUnlocked();\\n    }\\n\\n    /**\\n     * @dev Unlocks the guardians. This can only be called by the owner.\\n     */\\n    function unlockGuardians() external authorized {\\n        guardiansBlocked = false;\\n    }\\n\\n    /**\\n     * @dev Can only recover with the signature of 1 guardian and the recovery owner.\\n     * @param newOwner The new owner address. This is generated instantaneously.\\n     * @param newRecoveryOwner The new recovery owner address. This is generated instantaneously.\\n     * @notice The newOwner and newRecoveryOwner key pair should be generated from the mobile device.\\n     * The main reason of this is to restart the generation process in case an attacker has the current recoveryOwner.\\n     */\\n    function recover(address newOwner, address newRecoveryOwner)\\n        external\\n        authorized\\n    {\\n        checkParams(newOwner, newRecoveryOwner);\\n        owner = newOwner;\\n        recoveryOwner = newRecoveryOwner;\\n        emit WalletRecovered(newOwner, newRecoveryOwner);\\n    }\\n\\n    /**\\n     * @dev Adds a guardian to the wallet.\\n     * @param newGuardian Address of the new guardian.\\n     * @notice Can only be called by the owner.\\n     */\\n    function addGuardian(address newGuardian) external authorized {\\n        if (\\n            newGuardian == address(0) ||\\n            newGuardian == owner ||\\n            guardians[newGuardian] != address(0)\\n        ) revert SSR__addGuardian__invalidAddress();\\n        if (!IERC165(newGuardian).supportsInterface(0x1626ba7e))\\n            revert SSR__addGuardian__invalidAddress();\\n\\n        guardians[newGuardian] = guardians[pointer];\\n        guardians[pointer] = newGuardian;\\n\\n        unchecked {\\n            // Won't overflow...\\n            ++guardianCount;\\n        }\\n        emit NewGuardian(newGuardian);\\n    }\\n\\n    /**\\n     * @dev Removes a guardian to the wallet.\\n     * @param prevGuardian Address of the previous guardian in the linked list.\\n     * @param guardianToRemove Address of the guardian to be removed.\\n     * @notice Can only be called by the owner.\\n     */\\n    function removeGuardian(address prevGuardian, address guardianToRemove)\\n        external\\n        authorized\\n    {\\n        if (guardianToRemove == pointer) {\\n            revert SSR__removeGuardian__invalidAddress();\\n        }\\n\\n        if (guardians[prevGuardian] != guardianToRemove) {\\n            revert SSR__removeGuardian__incorrectPreviousGuardian();\\n        }\\n\\n        // There needs to be at least 1 guardian ..\\n        if (guardianCount - 1 < 1) revert SSR__removeGuardian__underflow();\\n\\n        guardians[prevGuardian] = guardians[guardianToRemove];\\n        guardians[guardianToRemove] = address(0);\\n        unchecked {\\n            //Won't underflow...\\n            --guardianCount;\\n        }\\n        emit GuardianRemoved(guardianToRemove);\\n    }\\n\\n    /**\\n     * @param guardian Requested address.\\n     * @return Boolean if the address is a guardian of the current wallet.\\n     */\\n    function isGuardian(address guardian) external view returns (bool) {\\n        return guardian != pointer && guardians[guardian] != address(0);\\n    }\\n\\n    /**\\n     * @return Array of guardians of this.\\n     */\\n    function getGuardians() public view returns (address[] memory) {\\n        address[] memory guardiansArray = new address[](guardianCount);\\n        address currentGuardian = guardians[pointer];\\n\\n        uint256 index = 0;\\n        while (currentGuardian != pointer) {\\n            guardiansArray[index] = currentGuardian;\\n            currentGuardian = guardians[currentGuardian];\\n            index++;\\n        }\\n        return guardiansArray;\\n    }\\n\\n    /**\\n     * @dev Sets up the initial guardian configuration. Can only be called from the init function.\\n     * @param _guardians Array of guardians.\\n     */\\n    function initGuardians(address[] calldata _guardians) internal {\\n        uint256 guardiansLength = _guardians.length;\\n        if (guardiansLength < 1) revert SSR__initGuardians__zeroGuardians();\\n\\n        address currentGuardian = pointer;\\n\\n        for (uint256 i = 0; i < guardiansLength; ) {\\n            address guardian = _guardians[i];\\n            if (\\n                guardian == owner ||\\n                guardian == address(0) ||\\n                guardian == pointer ||\\n                guardian == currentGuardian ||\\n                guardians[guardian] != address(0)\\n            ) revert SSR__initGuardians__invalidAddress();\\n\\n            if (guardian.code.length > 0) {\\n                // If the guardian is a smart contract wallet, it needs to support EIP1271.\\n                if (!IERC165(guardian).supportsInterface(0x1626ba7e))\\n                    revert SSR__initGuardians__invalidAddress();\\n            }\\n\\n            unchecked {\\n                // Won't overflow...\\n                ++i;\\n            }\\n            guardians[currentGuardian] = guardian;\\n            currentGuardian = guardian;\\n        }\\n\\n        guardians[currentGuardian] = pointer;\\n        guardianCount = guardiansLength;\\n    }\\n\\n    /**\\n     * @dev Returns who has access to call a specific function.\\n     * @param funcSelector The function selector: bytes4(keccak256(...)).\\n     */\\n    function access(bytes4 funcSelector) internal view returns (Access) {\\n        if (funcSelector == this.lock.selector) {\\n            // Only a guardian can lock the wallet ...\\n            // If  guardians are locked, we revert ...\\n            if (guardiansBlocked) revert SSR__access__guardiansBlocked();\\n            else return Access.Guardian;\\n        } else if (funcSelector == this.unlock.selector) {\\n            // Only a guardian + the owner can unlock the wallet ...\\n            return Access.OwnerAndGuardian;\\n        } else if (funcSelector == this.recoveryUnlock.selector) {\\n            // This is in case a guardian is misbehaving ...\\n            return Access.OwnerAndRecoveryOwner;\\n        } else if (funcSelector == this.recover.selector) {\\n            // Only the recovery owner + the guardian can recover the wallet (change the owner keys) ...\\n            return Access.RecoveryOwnerAndGuardian;\\n        } else {\\n            // Else is the owner ... If the the wallet is locked, we revert ...\\n            if (isLocked) revert SSR__access__walletLocked();\\n            else return Access.Owner;\\n        }\\n    }\\n\\n    /**\\n     * @dev Verifies that the signature matches the owner.\\n     */\\n    function verifyOwner(bytes32 dataHash, bytes memory signature)\\n        internal\\n        view\\n    {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        if (signature.length < 65)\\n            revert SSR__verifyGuardian__invalidSignature();\\n\\n        (r, s, v) = splitSigs(signature, 0);\\n        address recovered = returnSigner(dataHash, r, s, v);\\n        if (recovered != owner) revert SSR__verifyOwner__notOwner();\\n    }\\n\\n    /**\\n     * @dev Verifies that the signature matches a guardian.\\n     */\\n    function verifyGuardian(bytes32 dataHash, bytes memory signature)\\n        internal\\n        view\\n    {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        bool _isGuardian;\\n\\n        if (signature.length < 65)\\n            revert SSR__verifyGuardian__invalidSignature();\\n\\n        (r, s, v) = splitSigs(signature, 0);\\n\\n        // We first check if the guardian is a regular EOA ...\\n        address recovered = returnSigner(dataHash, r, s, v);\\n\\n        if (guardians[recovered] != address(0)) {\\n            _isGuardian = true;\\n        } else {\\n            // Else, the guardian can be a smart contract wallet ...\\n            // Each wallet can pack their signatures in different ways,\\n            // so we need to send the payload ...\\n            address[] memory _guardians = getGuardians();\\n\\n            for (uint256 i = 0; i < guardianCount; ) {\\n                address guardian = _guardians[i];\\n                // We check if the guardian is a smart contract wallet ...\\n                if (guardian.code.length > 0) {\\n                    if (\\n                        IEIP1271(guardian).isValidSignature(\\n                            dataHash,\\n                            signature\\n                        ) == 0x1626ba7e\\n                    ) _isGuardian = true;\\n                }\\n                unchecked {\\n                    // Won't overflow ...\\n                    ++i;\\n                }\\n            }\\n        }\\n        if (!_isGuardian) revert SSR__verifyGurdian__notGuardian();\\n    }\\n\\n    /**\\n     * @dev Verifies that the signatures correspond to the owner and guardian.\\n     * The first signature needs to match the owner.\\n     */\\n    function verifyOwnerAndGuardian(bytes32 dataHash, bytes calldata signatures)\\n        internal\\n        view\\n    {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // The guardian can be an EOA or smart contract wallet ...\\n        if (signatures.length < 130)\\n            revert SSR__verifyOwnerAndGuardian__invalidSignature();\\n\\n        // The first signer needs to be the owner ...\\n        (r, s, v) = splitSigs(signatures, 0);\\n        address _isOwner = returnSigner(dataHash, r, s, v);\\n        if (_isOwner != owner) revert SSR__verifyOwnerAndGuardian__notOwner();\\n\\n        // The second signer needs to be the guardian ...\\n        // We first check if the guardian is a regular EOA ...\\n        address recoveredGuardian;\\n        bool _isGuardian;\\n        recoveredGuardian = returnSigner(dataHash, r, s, v);\\n        if (guardians[recoveredGuardian] != address(0)) {\\n            _isGuardian = true;\\n        } else {\\n            // Else, the guardian can be a smart contract wallet ...\\n            // Each wallet can pack their signatures in different ways,\\n            // so we need to send the payload ...\\n            address[] memory _guardians = getGuardians();\\n\\n            for (uint256 i = 0; i < guardianCount; ) {\\n                address guardian = _guardians[i];\\n                // We check if the guardian is a smart contract wallet ...\\n                if (guardian.code.length > 0) {\\n                    if (\\n                        IEIP1271(guardian).isValidSignature(\\n                            dataHash,\\n                            signatures\\n                        ) == 0x1626ba7e\\n                    ) _isGuardian = true;\\n                }\\n                unchecked {\\n                    // Won't overflow ...\\n                    ++i;\\n                }\\n            }\\n        }\\n        if (!_isGuardian) revert SSR__verifyOwnerAndGuardian__notGuardian();\\n    }\\n\\n    /**\\n     * @dev Verifies that the signatures correspond to the recovery owner and guardian.\\n     * The first signature needs to match the recovery owner.\\n     */\\n    function verifyRecoveryOwnerAndGurdian(\\n        bytes32 dataHash,\\n        bytes calldata signatures\\n    ) internal view {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // The guardian can be an EOA or smart contract wallet ...\\n        if (signatures.length < 130)\\n            revert SSR__verifyRecoveryOwnerAndGurdian__invalidSignature();\\n\\n        // The first signer needs to be the recovery owner ...\\n        (r, s, v) = splitSigs(signatures, 0);\\n        address _isRecoveryOwner = returnSigner(dataHash, r, s, v);\\n        if (_isRecoveryOwner != recoveryOwner)\\n            revert SSR__verifyRecoveryOwnerAndGurdian__notRecoveryOwner();\\n\\n        // The second signer needs to be the guardian ...\\n        // We first check if the guardian is a regular EOA ...\\n        bool _isGuardian;\\n        address recoveredGuardian = returnSigner(dataHash, r, s, v);\\n        if (guardians[recoveredGuardian] != address(0)) {\\n            _isGuardian = true;\\n        } else {\\n            // Else, the guardian can be a smart contract wallet ...\\n            // Each wallet can pack their signatures in different ways,\\n            // so we need to send the payload ...\\n            address[] memory _guardians = getGuardians();\\n\\n            for (uint256 i = 0; i < guardianCount; ) {\\n                address guardian = _guardians[i];\\n                // We check if the guardian is a smart contract wallet ...\\n                if (guardian.code.length > 0) {\\n                    if (\\n                        IEIP1271(guardian).isValidSignature(\\n                            dataHash,\\n                            signatures\\n                        ) == 0x1626ba7e\\n                    ) _isGuardian = true;\\n                }\\n                unchecked {\\n                    // Won't overflow ...\\n                    ++i;\\n                }\\n            }\\n        }\\n        if (!_isGuardian)\\n            revert SSR__verifyRecoveryOwnerAndGurdian__notGuardian();\\n    }\\n\\n    /**\\n     * @dev Verifies that the signatures correspond to the owner and recovery owner.\\n     * The first signature needs to match the owner.\\n     */\\n    function verifyOwnerAndRecoveryOwner(\\n        bytes32 dataHash,\\n        bytes memory signatures\\n    ) internal view {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // Both, the owner and recovery owner must be EOA's ....\\n        if (signatures.length != 130)\\n            revert SSR__verifyOwnerAndRecoveryOwner__invalidSignature();\\n\\n        // The first signer needs to be the owner ...\\n        (r, s, v) = splitSigs(signatures, 0);\\n        address _isOwner = returnSigner(dataHash, r, s, v);\\n        if (_isOwner != owner)\\n            revert SSR__verifyOwnerAndRecoveryOwner__notOwner();\\n\\n        // The second signer needs to be the recovery owner ...\\n        (r, s, v) = splitSigs(signatures, 1);\\n        address _isRecoveryOwner = returnSigner(dataHash, r, s, v);\\n        if (_isRecoveryOwner != recoveryOwner)\\n            revert SSR__verifyOwnerAndRecoveryOwner__notRecoveryOwner();\\n    }\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"contracts/core/SelfAuthorized.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.14;\\n\\n/**\\n * @title SelfAuthorized - authorizes current contract to perform actions.\\n */\\ncontract SelfAuthorized {\\n    error SelfAuthorized__notWallet();\\n\\n    modifier authorized() {\\n        if (msg.sender != address(this)) revert SelfAuthorized__notWallet();\\n\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.14;\\n\\ninterface IStakeManager {\\n    function balanceOf(address wallet) external view returns (uint256);\\n\\n    function withdrawTo(address wallet, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAccountAbstraction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.14;\\n\\n/**\\n * @title IAccountAbstraction\\n * @notice Has all the external functions, events and errors for AccountAbstraction.sol.\\n */\\ninterface IAccountAbstraction {\\n    event EntryPointChanged(address newEntrypoint);\\n\\n    ///@dev innitEntryPoint() custom error.\\n    error AA__initEntryPoint__invalidEntryPoint();\\n    error AA__initEntryPoint__invalidSignature();\\n\\n    ///@dev withdrawDeposit() custom error.\\n    error AA__withdrawDeposit__insufficientBalance();\\n\\n    ///@dev changeEntryPoint() custom error.\\n    error AA__changeEntryPoint__invalidEntryPoint();\\n\\n    /**\\n     * @dev Withdraws the stake deposit from EntryPoint.\\n     * @param amount Amount to withdraw.\\n     */\\n    function withdrawDeposit(uint256 amount) external;\\n\\n    /**\\n     * @dev Changes the entry point address.\\n     * @param newEntryPoint  New entry point address.\\n     */\\n    function changeEntryPoint(address newEntryPoint) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.14;\\n\\n/**\\n * @title IERC165\\n * @notice Support of ERC165.\\n */\\ninterface IERC165 {\\n    /**\\n     * @notice Query if a contract implements an interface\\n     * @param interfaceID The interface identifier, as specified in ERC-165\\n     * @dev Interface identification is specified in ERC-165. This function\\n     * uses less than 30,000 gas.\\n     * @return `true` if the contract implements `interfaceID` and\\n     * interfaceID` is not 0xffffffff, `false` otherwise\\n     */\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISingleton.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.14;\\n\\n/**\\n * @title ISingleton\\n * @notice Has all the external functions, events and errors for Singleton.sol.\\n */\\n\\ninterface ISingleton {\\n    event SingletonChanged(address indexed newSingleton);\\n\\n    ///@dev upgradeSingleton() custom errors.\\n    error Singleton__upgradeSingleton__incorrectAddress();\\n    error Singleton__upgradeSingleton__notLaser();\\n\\n    /**\\n     * @dev Migrates to a new singleton (implementation).\\n     * @param singleton New implementation address.\\n     */\\n    function upgradeSingleton(address singleton) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.14;\\n\\n/**\\n * @title IHandler\\n * @notice Has all the external functions for Handler.sol.\\n */\\ninterface IHandler {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure returns (bytes4);\\n\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external pure returns (bytes4 result);\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external pure returns (bytes4 result);\\n\\n    function tokensReceived(\\n        address,\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata,\\n        bytes calldata\\n    ) external pure;\\n}\\n\"\r\n    },\r\n    \"contracts/core/Owner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.14;\\n\\nimport \\\"../interfaces/IOwner.sol\\\";\\nimport \\\"./SelfAuthorized.sol\\\";\\n\\n/**\\n * @title Owner\\n * @notice Handles the owners addresses.\\n */\\ncontract Owner is IOwner, SelfAuthorized {\\n    ///@dev owner should always bet at storage slot 2.\\n    address public owner;\\n\\n    ///@dev recovery owner should always be at storage slot 3.\\n    address public recoveryOwner;\\n\\n    /**\\n     * @dev Changes the owner of the wallet.\\n     * @param newOwner The address of the new owner.\\n     */\\n    function changeOwner(address newOwner) external authorized {\\n        if (newOwner.code.length != 0 || newOwner == address(0))\\n            revert Owner__changeOwner__invalidOwnerAddress();\\n        owner = newOwner;\\n        emit OwnerChanged(newOwner);\\n    }\\n\\n    /**\\n     * @dev Changes the recoveryOwner address. Only the owner can call this function.\\n     * @param newRecoveryOwner The new recovery owner address.\\n     */\\n    function changeRecoveryOwner(address newRecoveryOwner) external authorized {\\n        recoveryOwner = newRecoveryOwner;\\n        if (newRecoveryOwner.code.length != 0 || newRecoveryOwner == address(0))\\n            revert Owner__changeRecoveryOwner__invalidRecoveryOwnerAddress();\\n        emit NewRecoveryOwner(recoveryOwner);\\n    }\\n\\n    /**\\n     * @dev Inits the owner. This can only be called at creation.\\n     * @param _owner The owner of the wallet.\\n     * @param _recoveryOwner Recovery owner in case the owner looses the main device. Implementation of Sovereign Social Recovery.\\n     */\\n    function initOwners(address _owner, address _recoveryOwner) internal {\\n        // If owner is not address0, the wallet was already initialized...\\n        if (owner != address(0)) revert Owner__initOwner__walletInitialized();\\n        checkParams(_owner, _recoveryOwner);\\n        owner = _owner;\\n        recoveryOwner = _recoveryOwner;\\n    }\\n\\n    /**\\n     * @dev Checks that the parameters are in bounds.\\n     * @param _owner The owner of the wallet.\\n     * @param _recoveryOwner Recovery owner in case the owner looses the main device. Implementation of Sovereign Social Recovery.\\n     */\\n    function checkParams(address _owner, address _recoveryOwner) internal view {\\n        if (_owner.code.length != 0 || _owner == address(0))\\n            revert Owner__initOwner__invalidOwnerAddress();\\n\\n        if (_recoveryOwner.code.length != 0 || _recoveryOwner == address(0))\\n            revert Owner__initOwner__invalidRecoveryOwnerAddress();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEIP1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.14;\\n\\n/**\\n * @title IEIP1271\\n * @notice Interface to call external contracts to validate signature.\\n */\\ninterface IEIP1271 {\\n    /**\\n     * @dev Implementation of EIP 1271: https://eips.ethereum.org/EIPS/eip-1271.\\n     * @param hash Hash of a message signed on behalf of address(this).\\n     * @param signature Signature byte array associated with _msgHash.\\n     * @return Magic value  or reverts with an error message.\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature)\\n        external\\n        view\\n        returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISSR.sol\": {\r\n      \"content\": \"/**\\n * @title ISSR\\n * @notice Has all the external functions, structs, events and errors for SSR.sol.\\n */\\ninterface ISSR {\\n    ///@dev Determines who has access to call a specific function.\\n    enum Access {\\n        Owner,\\n        Guardian,\\n        OwnerAndGuardian,\\n        RecoveryOwnerAndGuardian,\\n        OwnerAndRecoveryOwner\\n    }\\n\\n    event WalletLocked();\\n    event WalletUnlocked();\\n    event RecoveryUnlocked();\\n    event NewGuardian(address newGuardian);\\n    event GuardianRemoved(address removedGuardian);\\n    event WalletRecovered(address newOwner, address newRecoveryOwner);\\n\\n    ///@dev addGuardian() custom errors.\\n    error SSR__addGuardian__invalidAddress();\\n\\n    ///@dev removeGuardian() custom errors.\\n    error SSR__removeGuardian__invalidAddress();\\n    error SSR__removeGuardian__incorrectPreviousGuardian();\\n    error SSR__removeGuardian__underflow();\\n\\n    ///@dev initGuardians() custom errors.\\n    error SSR__initGuardians__zeroGuardians();\\n    error SSR__initGuardians__invalidAddress();\\n\\n    ///@dev access() custom errors.\\n    error SSR__access__guardiansBlocked();\\n    error SSR__access__walletLocked();\\n\\n    ///@dev verifyOwner() custom errors.\\n    error SSR__verifyOwner__invalidSignature();\\n    error SSR__verifyOwner__notOwner();\\n\\n    ///@dev verifyGuardian() custom errors.\\n    error SSR__verifyGuardian__invalidSignature();\\n    error SSR__verifyGurdian__notGuardian();\\n\\n    ///@dev verifyOwnerAndGuardian() custom errors.\\n    error SSR__verifyOwnerAndGuardian__invalidSignature();\\n    error SSR__verifyOwnerAndGuardian__notOwner();\\n    error SSR__verifyOwnerAndGuardian__notGuardian();\\n\\n    ///@dev verifyRecoveryOwnerAndGurdian() custom errors.\\n    error SSR__verifyRecoveryOwnerAndGurdian__invalidSignature();\\n    error SSR__verifyRecoveryOwnerAndGurdian__notRecoveryOwner();\\n    error SSR__verifyRecoveryOwnerAndGurdian__notGuardian();\\n\\n    ///@dev verifyOwnerAndRecoveryOwner() custom errors.\\n    error SSR__verifyOwnerAndRecoveryOwner__invalidSignature();\\n    error SSR__verifyOwnerAndRecoveryOwner__notOwner();\\n    error SSR__verifyOwnerAndRecoveryOwner__notRecoveryOwner();\\n\\n    /**\\n     *\u00a0@dev Locks the wallet. Can only be called by a guardian.\\n     */\\n    function lock() external;\\n\\n    /**\\n     * @dev Unlocks the wallet. Can only be called by a guardian + the owner.\\n     */\\n    function unlock() external;\\n\\n    /**\\n     * @dev Unlocks the wallet. Can only be called by the recovery owner + the owner.\\n     * This is to avoid the wallet being locked forever if a guardian misbehaves.\\n     * The guardians will be locked until the owner decides otherwise.\\n     */\\n    function recoveryUnlock() external;\\n\\n    /**\\n     * @dev Unlocks the guardians. This can only be called by the owner.\\n     */\\n    function unlockGuardians() external;\\n\\n    /**\\n     * @dev Can only recover with the signature of the recovery owner and guardian.\\n     * @param newOwner The new owner address. This is generated instantaneously.\\n     * @param newRecoveryOwner The new recovery owner address. This is generated instantaneously.\\n     * @notice The newOwner and newRecoveryOwner key pair should be generated from the mobile device.\\n     * The main reason of this is to restart the generation process in case an attacker has the current recoveryOwner.\\n     */\\n    function recover(address newOwner, address newRecoveryOwner) external;\\n\\n    /**\\n     * @dev Adds a guardian to the wallet.\\n     * @param newGuardian Address of the new guardian.\\n     * @notice Can only be called by the owner.\\n     */\\n    function addGuardian(address newGuardian) external;\\n\\n    /**\\n     * @dev Removes a guardian to the wallet.\\n     * @param prevGuardian Address of the previous guardian in the linked list.\\n     * @param guardianToRemove Address of the guardian to be removed.\\n     * @notice Can only be called by the owner.\\n     */\\n    function removeGuardian(address prevGuardian, address guardianToRemove)\\n        external;\\n\\n    /**\\n     * @param guardian Requested address.\\n     * @return Boolean if the address is a guardian of the current wallet.\\n     */\\n    function isGuardian(address guardian) external view returns (bool);\\n\\n    /**\\n     * @return Array of guardians of this.\\n     */\\n    function getGuardians() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.14;\\n\\n/**\\n * @title Utils - Helper functions for LaserWallet.\\n */\\ncontract Utils {\\n    error Utils__InvalidSignature();\\n\\n    /**\\n     * @dev Returns the signer of the hash.\\n     * @param dataHash The hash that was signed.\\n     */\\n    function returnSigner(\\n        bytes32 dataHash,\\n        bytes32 r,\\n        bytes32 s,\\n        uint8 v\\n    ) public pure returns (address signer) {\\n        if (v > 30) {\\n            signer = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                        dataHash\\n                    )\\n                ),\\n                v - 4,\\n                r,\\n                s\\n            );\\n        } else {\\n            signer = ecrecover(dataHash, v, r, s);\\n        }\\n        if (signer == address(0)) revert Utils__InvalidSignature();\\n    }\\n\\n    /**\\n     * @dev Returns the r, s and v of the signature.\\n     * @param signature Signature.\\n     * @param pos Which signature to read.\\n     */\\n    function splitSigs(bytes memory signature, uint256 pos)\\n        public\\n        pure\\n        returns (\\n            bytes32 r,\\n            bytes32 s,\\n            uint8 v\\n        )\\n    {\\n        assembly {\\n            let sigPos := mul(0x41, pos)\\n            r := mload(add(signature, add(sigPos, 0x20)))\\n            s := mload(add(signature, add(sigPos, 0x40)))\\n            v := byte(0, mload(add(signature, add(sigPos, 0x60))))\\n        }\\n    }\\n\\n    /**\\n     * @dev Calls a target address, sends value and / or data payload.\\n     * @param to Destination address.\\n     * @param value Amount to send in ETH.\\n     * @param data Data payload.\\n     * @param txGas Amount of gas to forward.\\n     */\\n    function _call(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        uint256 txGas\\n    ) internal returns (bool success) {\\n        assembly {\\n            // We execute a call to the target address and return boolean...\\n            success := call(\\n                txGas,\\n                to,\\n                value,\\n                add(data, 0x20),\\n                mload(data),\\n                0,\\n                0\\n            )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.14;\\n\\n/**\\n * @title IOwner\\n * @notice Has all the external functions, events and errors for Owner.sol.\\n */\\ninterface IOwner {\\n    event OwnerChanged(address newOwner);\\n\\n    ///@dev changeOwner() custom error.\\n    error Owner__changeOwner__invalidOwnerAddress();\\n\\n    ///@dev changeRecoveryOwner() custom error.\\n    error Owner__changeRecoveryOwner__invalidRecoveryOwnerAddress();\\n\\n    ///@dev initOwner() custom errors.\\n    error Owner__initOwner__walletInitialized();\\n    error Owner__initOwner__invalidOwnerAddress();\\n    error Owner__initOwner__invalidRecoveryOwnerAddress();\\n    event NewRecoveryOwner(address recoveryOwner);\\n\\n    /**\\n     * @dev Changes the owner of the wallet.\\n     * @param newOwner The address of the new owner.\\n     */\\n    function changeOwner(address newOwner) external;\\n\\n    /**\\n     * @dev Changes the recoveryOwner address. Only the owner can call this function.\\n     * @param newRecoveryOwner The new recovery owner address.\\n     */\\n    function changeRecoveryOwner(address newRecoveryOwner) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AA__changeEntryPoint__invalidEntryPoint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AA__initEntryPoint__invalidEntryPoint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AA__initEntryPoint__invalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AA__withdrawDeposit__insufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LW__exec__failure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LW__isValidSignature__invalidSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LW__notEntryPoint\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LW__validateUserOp__invalidNonce\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Owner__changeOwner__invalidOwnerAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Owner__changeRecoveryOwner__invalidRecoveryOwnerAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Owner__initOwner__invalidOwnerAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Owner__initOwner__invalidRecoveryOwnerAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Owner__initOwner__walletInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__access__guardiansBlocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__access__walletLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__addGuardian__invalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__initGuardians__invalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__initGuardians__zeroGuardians\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__removeGuardian__incorrectPreviousGuardian\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__removeGuardian__invalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__removeGuardian__underflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__verifyGuardian__invalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__verifyGurdian__notGuardian\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__verifyOwnerAndGuardian__invalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__verifyOwnerAndGuardian__notGuardian\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__verifyOwnerAndGuardian__notOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__verifyOwnerAndRecoveryOwner__invalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__verifyOwnerAndRecoveryOwner__notOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__verifyOwnerAndRecoveryOwner__notRecoveryOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__verifyOwner__invalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__verifyOwner__notOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__verifyRecoveryOwnerAndGurdian__invalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__verifyRecoveryOwnerAndGurdian__notGuardian\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SSR__verifyRecoveryOwnerAndGurdian__notRecoveryOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SelfAuthorized__notWallet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Singleton__upgradeSingleton__incorrectAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Singleton__upgradeSingleton__notLaser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Utils__InvalidSignature\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newEntrypoint\",\"type\":\"address\"}],\"name\":\"EntryPointChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"removedGuardian\",\"type\":\"address\"}],\"name\":\"GuardianRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGuardian\",\"type\":\"address\"}],\"name\":\"NewGuardian\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recoveryOwner\",\"type\":\"address\"}],\"name\":\"NewRecoveryOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RecoveryUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"guardians\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"entryPoint\",\"type\":\"address\"}],\"name\":\"Setup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newSingleton\",\"type\":\"address\"}],\"name\":\"SingletonChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"funcSelector\",\"type\":\"bytes4\"}],\"name\":\"Success\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"WalletLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRecoveryOwner\",\"type\":\"address\"}],\"name\":\"WalletRecovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"WalletUnlocked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGuardian\",\"type\":\"address\"}],\"name\":\"addGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newEntryPoint\",\"type\":\"address\"}],\"name\":\"changeEntryPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRecoveryOwner\",\"type\":\"address\"}],\"name\":\"changeRecoveryOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryPoint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"exec\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGuardians\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardiansBlocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recoveryOwner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_guardians\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_entryPoint\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"isGuardian\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"result\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newRecoveryOwner\",\"type\":\"address\"}],\"name\":\"recover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoveryOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoveryUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"prevGuardian\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardianToRemove\",\"type\":\"address\"}],\"name\":\"removeGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"returnSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"singleton\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"pos\",\"type\":\"uint256\"}],\"name\":\"splitSigs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokensReceived\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockGuardians\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_singleton\",\"type\":\"address\"}],\"name\":\"upgradeSingleton\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"paymasterData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"}],\"name\":\"userOperationHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"callGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"verificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymaster\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"paymasterData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct UserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_requiredPrefund\",\"type\":\"uint256\"}],\"name\":\"validateUserOp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LaserWallet", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}