{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.13;\r\n\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ncontract Timelock is Ownable {\r\n\r\n    struct depositInfo {\r\n        address depositor;\r\n        address beneficiary;\r\n        uint256 depositAmount;\r\n        uint256 depositRemaining;\r\n        uint releaseTime;\r\n    }\r\n\r\n    struct uniqueDepositInfo {\r\n        address beneficiary;\r\n        address token;\r\n    }\r\n\r\n    bool internal lock;\r\n    string private _name = \"Timelock\";\r\n\r\n    address payable private _owner;\r\n    address private edithContractAddress;\r\n\r\n    uint256 private edithRequired = 50;\r\n    uint256 private totalEdithCollected = 0;\r\n    //uint256 private ownerEmergencyUnlockTime = 0;\r\n    mapping (address => mapping (address => depositInfo[])) private deposited;\r\n    uniqueDepositInfo[] UDI;\r\n\r\n    mapping (address => uint256) private tokenDepoistBalances;\r\n    mapping (address => uint256) private creditsAvailable;\r\n\r\n\r\n    constructor(address payable ownerIn) {\r\n        //end = block.timestamp + duration;\r\n        _owner = ownerIn;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(!lock, \"no reentrancy allowed\");\r\n        lock = true;\r\n        _;\r\n        lock = false;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function name() public view returns(string memory){\r\n        return _name;\r\n    }\r\n\r\n    function getOwner() public view returns(address) {\r\n        return _owner;\r\n    }\r\n\r\n    function setOwner(address payable newOwner) external onlyOwner returns(bool) {\r\n        _owner = newOwner;\r\n        return true;\r\n    }\r\n\r\n    function setEdithContractAddress(address newAddress) public onlyOwner {\r\n        edithContractAddress = newAddress;\r\n    }\r\n\r\n    function getEdithContractAddress() public view returns(address) {\r\n        return edithContractAddress;\r\n    }\r\n\r\n    function setEdithRequired(uint256 amount) public onlyOwner returns(bool) {\r\n        edithRequired = amount;\r\n        return true;\r\n    }\r\n\r\n    function getEdithRequired() public view returns(uint256) {\r\n        return edithRequired;\r\n    }\r\n\r\n    //transfers all edith credits to the contract owner\r\n    function loadCredits(uint256 amount) public nonReentrant returns(bool) {\r\n        bool success;\r\n        if (msg.sender != _owner){\r\n            success = IERC20(edithContractAddress).transferFrom(msg.sender, _owner, amount);\r\n            if (success){\r\n                creditsAvailable[msg.sender] += amount;\r\n                totalEdithCollected += amount;\r\n            }\r\n        } \r\n        return true;\r\n    }\r\n\r\n    function getLoadedCredits(address account) public view returns(uint256) {\r\n        return creditsAvailable[account];\r\n    }\r\n\r\n    function getTotalEdithCollected() public view returns(uint256) {\r\n        return totalEdithCollected;\r\n    }\r\n\r\n    function deposit(address beneficiary, address token, uint256 amount, uint256 delayTime) public nonReentrant returns(bool){\r\n        //demand credits unless edithContract address is set to zero or if caller is owner or if edithRrquired == 0\r\n        if (edithContractAddress != address(0) && msg.sender != _owner && edithRequired > 0){\r\n            require(creditsAvailable[msg.sender] >= edithRequired, \"you need more edith credits deposited\");\r\n            creditsAvailable[msg.sender] -= edithRequired;\r\n        }\r\n        if (deposited[beneficiary][token].length ==  0){\r\n            UDI.push(uniqueDepositInfo(beneficiary, token));\r\n        }\r\n        uint256 releaseTime = block.timestamp + delayTime;\r\n        deposited[beneficiary][token].push(depositInfo(msg.sender, beneficiary, amount, amount, releaseTime));\r\n        bool success = IERC20(token).transferFrom(msg.sender, address(this), amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function numUniqueDeposits() public view returns(uint256){\r\n        return UDI.length;\r\n    }\r\n\r\n    function viewUniqueDeposit(uint256 index) public view returns(address, address){\r\n        require(index < UDI.length);\r\n        uniqueDepositInfo memory UD = UDI[index];\r\n        return (UD.beneficiary, UD.token);\r\n    }\r\n\r\n    function numberOfDeposits(address beneficiary, address token) public view returns(uint256) {\r\n        return deposited[beneficiary][token].length;\r\n    }\r\n\r\n    function viewDeposit(address beneficiary, address token, uint depositNumber) public view returns(address, address, uint256, uint256, uint256) {\r\n        require(deposited[beneficiary][token].length >= depositNumber, \"invalid deposit number\");\r\n        depositInfo memory DI = deposited[beneficiary][token][depositNumber];\r\n        return (DI.depositor, DI.beneficiary, DI.depositAmount, DI.depositRemaining, DI.releaseTime);\r\n    }\r\n\r\n    function withdraw(address token, uint256 amount) public nonReentrant returns(bool) {\r\n        require(amount > 0, \"amount cannot be 0\");\r\n        address beneficiary = msg.sender;\r\n        depositInfo[] memory DIL = deposited[beneficiary][token];\r\n        require(DIL.length > 0, \"no tokens deposited.\");\r\n        \r\n        depositInfo memory DI;\r\n        uint currentTime = block.timestamp;\r\n\r\n        uint256 numTokensDeducted = 0;\r\n        uint256 numTokensStillNeeded = amount;\r\n        //uint[] memory depositsEmptied;\r\n        for (uint256 i=0; i<DIL.length; i++) {\r\n            if (numTokensStillNeeded > 0){\r\n                DI = DIL[i];\r\n                if (DI.releaseTime <= currentTime && DI.depositRemaining > 0) {\r\n                    if (DI.depositRemaining <= numTokensStillNeeded){\r\n                        numTokensStillNeeded -= DI.depositRemaining;\r\n                        deposited[beneficiary][token][i].depositRemaining = 0;\r\n                    } else { //number in this deposit are greater than num needed.\r\n                        deposited[beneficiary][token][i].depositRemaining -= numTokensStillNeeded;\r\n                        numTokensStillNeeded = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        numTokensDeducted = amount - numTokensStillNeeded;\r\n        require(numTokensDeducted > 0, \"no tokens were ready to unlock\");\r\n        bool success = IERC20(token).transfer(beneficiary, numTokensDeducted);\r\n        if (success){\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function withdrawAllAvailable(address token) public returns(bool) {\r\n        uint256 amount = ~uint256(0);\r\n        return withdraw(token, amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"ownerIn\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delayTime\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEdithContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEdithRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getLoadedCredits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalEdithCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"loadCredits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numUniqueDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"numberOfDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setEdithContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setEdithRequired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositNumber\",\"type\":\"uint256\"}],\"name\":\"viewDeposit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"viewUniqueDeposit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawAllAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Timelock", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f2b0512dabc4b2632848899c82d3657617f987ec", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6de0917d4220b9fb1d82bf750e308a15c13e6abfe57778f6ed8e75f1c50fb6c3"}]}