{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: contracts/openZeppelin/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/openZeppelin/Address.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\r\npragma solidity ^0.8.1;\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n// File: contracts/openZeppelin/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n// File: contracts/openZeppelin/ERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\npragma solidity ^0.8.0;\r\n\r\n\r\nabstract contract ERC165 is IERC165 {\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n// File: contracts/openZeppelin/IERC1155Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC1155Receiver is IERC165 {\r\n\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n// File: contracts/openZeppelin/IERC1155.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC1155 is IERC165 {\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n    event URI(string value, uint256 indexed id);\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: contracts/openZeppelin/IERC1155MetadataURI.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC1155MetadataURI is IERC1155 {\r\n\r\n    function uri(uint256 id) external view returns (string memory);\r\n}\r\n// File: contracts/openZeppelin/ERC1155.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/ERC1155.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract metaCasperz is Context, ERC165, IERC1155, IERC1155MetadataURI {\r\n    using Address for address;\r\n    mapping(uint256 => mapping(address => uint256)) private _balances;\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n    string private _uri;\r\n\r\n    constructor(string memory uri_) {\r\n        _setURI(uri_);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC1155).interfaceId ||\r\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function uri(uint256) public view virtual override returns (string memory) {\r\n        return _uri;\r\n    }\r\n\r\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\r\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\r\n        return _balances[id][account];\r\n    }\r\n\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _setApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n        _safeTransferFrom(from, to, id, amount, data);\r\n    }\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: transfer caller is not owner nor approved\"\r\n        );\r\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n        uint256[] memory ids = _asSingletonArray(id);\r\n        uint256[] memory amounts = _asSingletonArray(amount);\r\n\r\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n        _balances[id][to] += amount;\r\n\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n\r\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\r\n    }\r\n\r\n    function _safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n            _balances[id][to] += amount;\r\n        }\r\n\r\n        emit TransferBatch(operator, from, to, ids, amounts);\r\n\r\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\r\n    }\r\n\r\n    function _setURI(string memory newuri) internal virtual {\r\n        _uri = newuri;\r\n    }\r\n\r\n    function _mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n        uint256[] memory ids = _asSingletonArray(id);\r\n        uint256[] memory amounts = _asSingletonArray(amount);\r\n\r\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n\r\n        _balances[id][to] += amount;\r\n        emit TransferSingle(operator, address(0), to, id, amount);\r\n\r\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\r\n    }\r\n\r\n    function _mintBatch(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            _balances[ids[i]][to] += amounts[i];\r\n        }\r\n\r\n        emit TransferBatch(operator, address(0), to, ids, amounts);\r\n\r\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\r\n    }\r\n\r\n    function _burn(\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC1155: burn from the zero address\");\r\n\r\n        address operator = _msgSender();\r\n        uint256[] memory ids = _asSingletonArray(id);\r\n        uint256[] memory amounts = _asSingletonArray(amount);\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n\r\n        emit TransferSingle(operator, from, address(0), id, amount);\r\n\r\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n    }\r\n\r\n    function _burnBatch(\r\n        address from,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC1155: burn from the zero address\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(operator, from, address(0), ids, amounts);\r\n\r\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n    }\r\n\r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) internal virtual {\r\n        require(owner != operator, \"ERC1155: setting approval status for self\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n\r\n    function _afterTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\r\n                bytes4 response\r\n            ) {\r\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\r\n        uint256[] memory array = new uint256[](1);\r\n        array[0] = element;\r\n\r\n        return array;\r\n    }\r\n}\r\n\r\n// File: contracts/metaCasperzSecurity.sol\r\n\r\n\r\n// metaCasperzPortalLock.sol ERC1155 v1.0\r\n// by Dr.Barns @metaCasperz\r\n// admin@blackboxmint.io\r\n\r\npragma solidity 0.8.12;\r\n\r\ncontract metaCasperzSecurity {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier portalLock() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier isLivingSoul() {\r\n        require( contractAddressLength(msg.sender) == false , \"The unliving may not pass\");\r\n        _;\r\n    }\r\n}\r\n\r\nfunction contractAddressLength (address contractAddress) view returns (bool) {\r\n    uint256 size;\r\n        assembly {\r\n        size := extcodesize(contractAddress)\r\n    }\r\n    return size > 0;\r\n}\r\n\r\n// File: contracts/metaCasperzAdmin.sol\r\n\r\n\r\n// metaCasperzAdmin.sol ERC1155 v1.0\r\n// by Dr.Barns @metaCasperz\r\n// admin@blackboxmint.io\r\n\r\npragma solidity 0.8.12;\r\n\r\ncontract metaCasperzAdmin {\r\n\r\n    address internal casperzSuperAdmin;\r\n    \r\n    event EventCasperzAdminTransfer (address indexed oldAddress, address indexed newAddress);\r\n        \r\n    constructor() {\r\n        casperzSuperAdmin = payable(msg.sender);\r\n        emit EventCasperzAdminTransfer(address(0), casperzSuperAdmin);\r\n    }\r\n\r\n    function _ADMIN_SET_ADMIN (address newCasperzAdmin) external onlyCasperzSuperAdmin {\r\n        casperzSuperAdmin = payable(newCasperzAdmin);\r\n        emit EventCasperzAdminTransfer(casperzSuperAdmin, newCasperzAdmin);\r\n    }\r\n\r\n    function _ADMIN_SHOW_ADMIN() external view returns (address) {\r\n        return casperzSuperAdmin;\r\n    }\r\n\r\n    modifier onlyCasperzSuperAdmin() {\r\n        require(msg.sender == casperzSuperAdmin, \"Caller is not casperzSuperAdmin\");\r\n        _;\r\n    }\r\n}\r\n// File: contracts/metaCasperzVault.sol\r\n\r\n\r\n// metacasperzVault.sol ERC1155 v1.0\r\n// by Dr.Barns @metaCasperz\r\n// admin@blackboxmint.io\r\n\r\npragma solidity 0.8.12;\r\n\r\ncontract metaCasperzVault is metaCasperzAdmin {\r\n    uint256 internal casperzMintedTotal;\r\n    uint256 internal casperzCurrentPrice;\r\n    uint256 internal balance_caspers;\r\n    uint256 internal balance_blackboxmint;\r\n    address internal metacasperzVaultKeeper;\r\n    address internal blackboxmintVaultKeeper;\r\n    uint256 internal casperzMaxSupply = 3333;\r\n    mapping(address => uint256) internal casperzCollectorsBalance;\r\n\r\n    event EventDepositMade(address indexed sender, uint256 amount);\r\n    event EventCasperzVaultWithdrawal(address indexed sender, uint256 amount);\r\n    event EventBlackBoxVaultWithdrawal(address indexed sender, uint256 amount);\r\n    event EventCasperzKeeperTransfer(address from, address to);\r\n    event EventBlackBoxKeeperTransfer(address from, address to);\r\n  \r\n    constructor() {\r\n        metacasperzVaultKeeper = payable(msg.sender);\r\n        blackboxmintVaultKeeper = payable(msg.sender);\r\n        emit EventCasperzKeeperTransfer(address(0), metacasperzVaultKeeper);\r\n        emit EventBlackBoxKeeperTransfer(address(0), blackboxmintVaultKeeper);\r\n    }\r\n\r\n    receive() external payable {\r\n        emit EventDepositMade(msg.sender, msg.value);\r\n    }\r\n\r\n    function _V_DEPOSIT () external payable {\r\n        vaultShareHandling (msg.value);\r\n        emit EventDepositMade(msg.sender, msg.value);\r\n    }\r\n\r\n    function vaultShareHandling (uint256 _value) internal  {\r\n        if (_value > 19){\r\n            balance_blackboxmint += (_value * 5) / 100; \r\n        }\r\n        balance_caspers += _value - balance_blackboxmint;\r\n    }\r\n\r\n    function _V_WITHDRAW_CASPERZ () external onlymetacasperzVaultKeeper {\r\n        require(balance_caspers > 0, \"The Vault has been cleared\");\r\n        (bool success, ) = metacasperzVaultKeeper.call{value: balance_caspers}(\"\");\r\n        require(success, \"The vault is locked\");\r\n        emit EventCasperzVaultWithdrawal(address(0), balance_caspers);\r\n        balance_caspers -= balance_caspers;\r\n    }\r\n\r\n    function _V_WITHDRAW_BLACKBOX () external onlyblackboxmintVaultKeeper {\r\n        require(balance_blackboxmint > 0, \"The Vault has been cleared\");\r\n        (bool success, ) = blackboxmintVaultKeeper.call{value: balance_blackboxmint}(\"\");\r\n        require(success, \"The vault is locked\");\r\n        emit EventBlackBoxVaultWithdrawal(address(0), balance_caspers);\r\n        balance_blackboxmint -= balance_blackboxmint;\r\n    }\r\n\r\n    function _V_SET_CASPERZ (address _newCasperzKeeper) external onlymetacasperzVaultKeeper {\r\n        metacasperzVaultKeeper = payable(_newCasperzKeeper);\r\n        emit EventCasperzKeeperTransfer(address(0), metacasperzVaultKeeper);\r\n    }\r\n\r\n    function _V_SET_BLACKBOX (address _newblackboxKeeper) external onlyblackboxmintVaultKeeper {\r\n        blackboxmintVaultKeeper = payable(_newblackboxKeeper);\r\n        emit EventBlackBoxKeeperTransfer(address(0), metacasperzVaultKeeper);\r\n    }\r\n\r\n    function _V_KEEPER_CASPERZ() external view returns (address) {\r\n        return metacasperzVaultKeeper;\r\n    }\r\n\r\n    function _V_KEEPER_BLACKBOX() external view returns (address) {\r\n        return blackboxmintVaultKeeper;\r\n    }\r\n\r\n    function _V_CASPERZ_PRICE() external view returns (uint256) {\r\n        return casperzCurrentPrice;\r\n    }\r\n\r\n    function _V_CASPERZ_MINTED() external view returns (uint256) {\r\n        return casperzMintedTotal;\r\n    }\r\n\r\n    function _V_CASPERZ_MAX() external view returns (uint256) {\r\n        return casperzMaxSupply;\r\n    }\r\n\r\n    function _V_BALANCE_CASPERZ() external view returns (uint256) {\r\n        return balance_caspers;\r\n    }\r\n\r\n    function _V_BALANCE_BLACKBOX() external view returns (uint256) {\r\n        return balance_blackboxmint;\r\n    }\r\n\r\n    modifier onlymetacasperzVaultKeeper() {\r\n        require(msg.sender == metacasperzVaultKeeper, \"Caller is not metacasperzVaultKeeper\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyblackboxmintVaultKeeper() {\r\n        require(msg.sender == blackboxmintVaultKeeper, \"Caller is not blackboxmintVaultKeeper\");\r\n        _;\r\n    }\r\n}\r\n// File: contracts/metaCasperzSpooks.sol\r\n\r\n\r\n    // metaCasperzSpooks.sol ERC1155 v1.0\r\n    // by Dr.Barns @metaCasperz\r\n    // admin@blackboxmint.io\r\n    \r\n    pragma solidity 0.8.12;\r\n\r\n\r\n\r\n    \r\n    \r\n    contract metaCasperzSpooks is metaCasperzAdmin, metaCasperzSecurity, metaCasperzVault {\r\n\r\n    bool internal whitelist_toggle; // STARTS FALSE\r\n    uint256 internal casperzWhiteListID;\r\n    mapping(uint256 => uint256) internal casperzWhitelistEvents;\r\n    mapping(address => mapping(uint256 => uint)) internal casperzWhitelisted;\r\n    mapping(address => uint256) internal casperzShurs;\r\n\r\n    event EventAdminAddedShur (address indexed theShur, uint256 isOrNot);\r\n    event EventWhitelistStarted(uint256 whitelistCapactity, uint256 casperzWhiteListID);\r\n\r\n    function _ADMIN_ADD_SHUR (address _shurAddress) external onlyCasperzSuperAdmin portalLock {\r\n        casperzShurs[_shurAddress] = 1;\r\n        emit EventAdminAddedShur (_shurAddress, 1);\r\n    }\r\n\r\n    function _ADMIN_WL_TRUE_IS_OFF (bool _onOrOff) external onlyCasperzSuperAdmin portalLock {\r\n        if (whitelist_toggle){\r\n            whitelist_toggle = _onOrOff;\r\n        }else{\r\n            whitelist_toggle = _onOrOff;\r\n        }\r\n    }\r\n\r\n    function _ADMIN_IS_SHUR (address _address) external view returns (uint256) {\r\n        return casperzShurs[_address];\r\n    }      \r\n\r\n    function _WL_ID () external view returns (uint256) { \r\n        return casperzWhiteListID;\r\n    }\r\n\r\n    function _WL_Capactity () external view returns (uint256) { \r\n        return casperzWhitelistEvents[casperzWhiteListID];\r\n    }\r\n\r\n    function check_casperzWhiteliststatus(address _address) internal view returns (uint) {\r\n        return casperzWhitelisted[_address][casperzWhiteListID];\r\n    }\r\n\r\n    function _ADMIN_WL_STATUS (address _address, uint256 _whitelistID) external view returns (uint) {\r\n        return casperzWhitelisted[_address][_whitelistID];\r\n    }\r\n\r\n    modifier onlyWhitelisted() {\r\n        if (!whitelist_toggle) {\r\n            require(casperzWhiteListID > 0, \"No Whitelisting events have been started\" );\r\n            require(check_casperzWhiteliststatus(msg.sender) != 0, \"You are not whitelisted\");\r\n            require(check_casperzWhiteliststatus(msg.sender) == 1, \"You have already collected your NFT\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyCasperzShur() {\r\n        require(casperzShurs[msg.sender] == 1, \"You are not a shur\");\r\n        _;\r\n    }\r\n\r\n    modifier checkWhiteListPass() {\r\n        require(casperzWhiteListID > 0, \"No Whitelisting events have been started\" );\r\n        require(check_casperzWhiteliststatus(msg.sender) == 0, \"You cannot sign up to the same whitelist twice\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/metaCasperzMain.sol\r\n\r\n\r\n// metaCasperzMain.sol ERC1155 v1.0\r\n// by Dr.Barns @metaCasperz\r\n// admin@blackboxmint.io\r\n\r\npragma solidity 0.8.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract metaCasperzMain is metaCasperz, metaCasperzAdmin, metaCasperzSecurity, metaCasperzVault, metaCasperzSpooks {\r\n\r\n    event EventAdminSetsURI(address indexed setter, string newuri);\r\n    event EventAddressMintsCasperz(address indexed minter, uint256 mintPrice);\r\n    event EventAddressGetsWhitelisted(address indexed whitelistme, uint256 casperzWhiteListID);\r\n    \r\n    constructor () metaCasperz(\"https://metacasperz.com/test/{id}.json\"){    \r\n    }\r\n\r\n    function _ADMIN_SET_URI(string memory newuri) external onlyCasperzSuperAdmin portalLock {\r\n        _setURI(newuri);\r\n        emit EventAdminSetsURI(msg.sender, newuri);\r\n    }\r\n\r\n    function _WL_SIGNUP() external portalLock checkWhiteListPass {\r\n        require(casperzWhiteListID > 0, \"No Whitelisting events have been started\" );\r\n        require(casperzWhitelistEvents[casperzWhiteListID] > 0, \"All seats have been taken this whitelisting event\" );\r\n        casperzWhitelisted[msg.sender][casperzWhiteListID] = 1;\r\n        casperzWhitelistEvents[casperzWhiteListID] -= 1; \r\n        emit EventAddressMintsCasperz(msg.sender, casperzWhiteListID);\r\n    }\r\n\r\n    function _WL_SHUR_MINT() external payable onlyCasperzShur portalLock {\r\n        _mint (msg.sender, casperzMintedTotal, 1, \"\");\r\n        casperzShurs[msg.sender] = 2;\r\n    }\r\n     \r\n    function _WL_MINT() external payable onlyWhitelisted portalLock isLivingSoul {    \r\n        require(casperzMintedTotal <= casperzMaxSupply, \"I am afraid casperz 3333 series has been completed\");\r\n        uint256 casperzTotalPrice = casperzCheckBatchPrice(1);\r\n        require(casperzTotalPrice > 0, \"Cannot cannot be 0\");\r\n        require(msg.value >= casperzTotalPrice, \"You need to pay the minting price\");\r\n        vaultShareHandling(msg.value);\r\n        casperzMintedTotal ++;\r\n        _mint (msg.sender, casperzMintedTotal, 1, \"\");\r\n        casperzWhitelisted[msg.sender][casperzWhiteListID] = 2; \r\n        emit EventAddressGetsWhitelisted(msg.sender, casperzCurrentPrice);\r\n    }\r\n\r\n    function casperzCheckBatchPrice(uint256 _casperzAmount) internal returns (uint256 casperzMultiPrice){\r\n        require(_casperzAmount > 0, \"Amount cannot be 0\");\r\n        casperzCurrentPrice = returnCasperzCurrentPrice(casperzMintedTotal);\r\n        casperzMultiPrice = casperzCurrentPrice * _casperzAmount;\r\n        return casperzMultiPrice;\r\n    } \r\n\r\n    function _ADMIN_WL_SETUP (uint256 _whitelistCapactity) external onlyCasperzSuperAdmin portalLock {\r\n        casperzWhiteListID ++;\r\n        casperzCheckBatchPrice(1);\r\n        uint256 remainingCapacity = casperzMaxSupply - casperzMintedTotal;\r\n        require(_whitelistCapactity <= remainingCapacity, \"There is not enough NFTs left in the series\");\r\n        casperzWhitelistEvents[casperzWhiteListID] = _whitelistCapactity;\r\n        emit EventWhitelistStarted(casperzWhiteListID, _whitelistCapactity);\r\n    }\r\n}\r\n\r\nfunction returnCasperzCurrentPrice(uint256 _casperzMintedTotal) pure returns (uint256 _casperzCurrentPrice){\r\n    _casperzCurrentPrice=1000000000000000000; // maximum by default\r\n    if (_casperzMintedTotal < 11 ){\r\n        _casperzCurrentPrice = 10000000000000000; // 0.01 ETH   \r\n    }else if (_casperzMintedTotal > 10 && _casperzMintedTotal < 201){\r\n        _casperzCurrentPrice = 20000000000000000; // 0.02 ETH       \r\n    }else if (_casperzMintedTotal > 200 && _casperzMintedTotal < 501){\r\n        _casperzCurrentPrice = 30000000000000000; // 0.03 ETH\r\n    }else if (_casperzMintedTotal > 500 && _casperzMintedTotal < 1001){\r\n        _casperzCurrentPrice = 80000000000000000; // 0.08 ETH\r\n    }else if (_casperzMintedTotal > 1000 && _casperzMintedTotal < 2001){\r\n        _casperzCurrentPrice = 110000000000000000; // 0.11 ETH\r\n    }else if (_casperzMintedTotal > 2000 && _casperzMintedTotal < 3001){\r\n        _casperzCurrentPrice = 140000000000000000; // 0.14 ETH\r\n    }else{\r\n        if (_casperzMintedTotal > 3000){\r\n            _casperzCurrentPrice = 170000000000000000; // 0.17 ETH\r\n        }\r\n    }\r\n    return _casperzCurrentPrice;\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelistme\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"casperzWhiteListID\",\"type\":\"uint256\"}],\"name\":\"EventAddressGetsWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"}],\"name\":\"EventAddressMintsCasperz\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"theShur\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"isOrNot\",\"type\":\"uint256\"}],\"name\":\"EventAdminAddedShur\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newuri\",\"type\":\"string\"}],\"name\":\"EventAdminSetsURI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"EventBlackBoxKeeperTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EventBlackBoxVaultWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"EventCasperzAdminTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"EventCasperzKeeperTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EventCasperzVaultWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EventDepositMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"whitelistCapactity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"casperzWhiteListID\",\"type\":\"uint256\"}],\"name\":\"EventWhitelistStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_shurAddress\",\"type\":\"address\"}],\"name\":\"_ADMIN_ADD_SHUR\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"_ADMIN_IS_SHUR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCasperzAdmin\",\"type\":\"address\"}],\"name\":\"_ADMIN_SET_ADMIN\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newuri\",\"type\":\"string\"}],\"name\":\"_ADMIN_SET_URI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ADMIN_SHOW_ADMIN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_whitelistCapactity\",\"type\":\"uint256\"}],\"name\":\"_ADMIN_WL_SETUP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_whitelistID\",\"type\":\"uint256\"}],\"name\":\"_ADMIN_WL_STATUS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_onOrOff\",\"type\":\"bool\"}],\"name\":\"_ADMIN_WL_TRUE_IS_OFF\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_V_BALANCE_BLACKBOX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_V_BALANCE_CASPERZ\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_V_CASPERZ_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_V_CASPERZ_MINTED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_V_CASPERZ_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_V_DEPOSIT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_V_KEEPER_BLACKBOX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_V_KEEPER_CASPERZ\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newblackboxKeeper\",\"type\":\"address\"}],\"name\":\"_V_SET_BLACKBOX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newCasperzKeeper\",\"type\":\"address\"}],\"name\":\"_V_SET_CASPERZ\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_V_WITHDRAW_BLACKBOX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_V_WITHDRAW_CASPERZ\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_WL_Capactity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_WL_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_WL_MINT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_WL_SHUR_MINT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_WL_SIGNUP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "metaCasperzMain", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://51e643d507ab90780363505334eaadd90f4423beeffb05afbb8771d4ce7b21b0"}]}