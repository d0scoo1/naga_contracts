{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/GenArtNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport \\\"@rari-capital/solmate/src/tokens/ERC721.sol\\\";\\nimport \\\"./NFTDescriptor.sol\\\";\\n\\ncontract GenArtNFT is ERC721 {\\n    uint256 internal constant MAX_SUPPLY = 3000;\\n\\n    bool public mintable;\\n    uint16 public dimensionLimits;\\n    uint24 public totalSupply;\\n    address public tokenDescriptor;\\n    address public owner;\\n    uint128[MAX_SUPPLY] public tokenData;\\n\\n    constructor() ERC721(unicode\\\"\u2588\u2588\u2588\\\", unicode\\\"\u2588\u2588\u2588\\\") {\\n        owner = msg.sender;\\n        dimensionLimits = 0x6166;\\n    }\\n\\n    function mint(uint128 data) external {\\n        require(mintable, \\\"Minting disabled\\\");\\n        uint256 ncol = (data >> 0) & 0x7;\\n        uint256 nrow = (data >> 3) & 0x7;\\n        uint256 dim = dimensionLimits;\\n        //prettier-ignore\\n        require(\\n            ncol >= ((dim >> 0)  & 0xF) &&\\n            ncol <= ((dim >> 4)  & 0xF) &&\\n            nrow >= ((dim >> 8)  & 0xF) &&\\n            nrow <= ((dim >> 12) & 0xF),\\n            \\\"Invalid Data\\\"\\n        );\\n        uint256 tokenId = ++totalSupply;\\n        require(tokenId <= MAX_SUPPLY, \\\"Exceed max supply\\\");\\n        uint256 rand = uint256(keccak256(abi.encodePacked(msg.sender, block.timestamp, block.number, tokenId))) % 8;\\n        tokenData[tokenId] = (uint128(rand) << 120) | uint120(data);\\n        _mint(msg.sender, tokenId);\\n    }\\n\\n    function _getData(uint256 tokenId)\\n        internal\\n        view\\n        returns (\\n            uint256 ncol,\\n            uint256 nrow,\\n            uint256 result,\\n            uint256 salt\\n        )\\n    {\\n        uint256 data = tokenData[tokenId];\\n        require(data != 0, \\\"Token not exists\\\");\\n        ncol = (data >> 0) & 0x7;\\n        nrow = (data >> 3) & 0x7;\\n        result = uint120(data) >> 6;\\n        salt = data;\\n    }\\n\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        if (tokenDescriptor != address(0)) {\\n            return IERC721Descriptor(tokenDescriptor).tokenURI(tokenId);\\n        }\\n        (uint256 ncol, uint256 nrow, uint256 result, uint256 salt) = _getData(tokenId);\\n        return NFTDescriptor.constructTokenURI(tokenId, result, ncol, nrow, salt, name);\\n    }\\n\\n    function imageURI(uint256 tokenId) external view returns (string memory) {\\n        (uint256 ncol, uint256 nrow, uint256 result, uint256 salt) = _getData(tokenId);\\n        return NFTDescriptor.makeImageURI(result, ncol, nrow, salt);\\n    }\\n\\n    function squares(uint256 tokenId) external view returns (string memory) {\\n        (uint256 ncol, uint256 nrow, uint256 result, ) = _getData(tokenId);\\n        return NFTDescriptor.makeSquares(result, ncol, nrow);\\n    }\\n\\n    // ----------\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function setOwner(address newOwner) external onlyOwner {\\n        owner = newOwner;\\n    }\\n\\n    function setInfo(string calldata _name, string calldata _symbol) external onlyOwner {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    function setMintable(bool _mintable) external onlyOwner {\\n        mintable = _mintable;\\n    }\\n\\n    function setDimensionLimit(uint16 _dimensionLimits) external onlyOwner {\\n        dimensionLimits = _dimensionLimits;\\n    }\\n\\n    // only in case we need to patch the art logic\\n    function setTokenDescriptor(address _descriptor) external onlyOwner {\\n        tokenDescriptor = _descriptor;\\n    }\\n}\\n\\ninterface IERC721Descriptor {\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\\nabstract contract ERC721 {\\n    /*///////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC721 STORAGE                        \\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(uint256 => address) public ownerOf;\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            balanceOf[from]--;\\n\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = ownerOf[id];\\n\\n        require(ownerOf[id] != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            balanceOf[owner]--;\\n        }\\n\\n        delete ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\ninterface ERC721TokenReceiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/NFTDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport \\\"./NFTArt.sol\\\";\\nimport \\\"base64-sol/base64.sol\\\";\\n\\nlibrary NFTDescriptor {\\n    function constructTokenURI(\\n        uint256 tokenId,\\n        uint256 result,\\n        uint256 ncol,\\n        uint256 nrow,\\n        uint256 salt,\\n        string memory collectionName\\n    ) internal pure returns (string memory) {\\n        string memory image = Base64.encode(NFTArt.drawSVG(result, ncol, nrow, salt));\\n        bytes memory metadata = abi.encodePacked(\\n            '{\\\"name\\\":\\\"',\\n            collectionName,\\n            \\\" #\\\",\\n            uintToString(tokenId),\\n            '\\\", \\\"description\\\":\\\"',\\n            \\\"Completely on-chain generative art collection. Art is uniquely generated based on the minter's result in our rebranding game. Limited edition. \\\\\\\\n\\\\\\\\nThe minter's result:\\\\\\\\n\\\",\\n            makeSquares(result, ncol, nrow),\\n            '\\\", \\\"image\\\": \\\"',\\n            \\\"data:image/svg+xml;base64,\\\",\\n            image,\\n            '\\\"}'\\n        );\\n        return string(abi.encodePacked(\\\"data:application/json;base64,\\\", Base64.encode(metadata)));\\n    }\\n\\n    function makeSquares(\\n        uint256 result,\\n        uint256 ncol,\\n        uint256 nrow\\n    ) internal pure returns (string memory) {\\n        unchecked {\\n            bytes[8] memory rows;\\n            for (uint256 q = 0; q < nrow; ++q) {\\n                string[8] memory strs;\\n                for (uint256 p = ncol - 1; p != type(uint256).max; --p) {\\n                    uint256 res = result % 3;\\n                    strs[p] = res == 0 ? hex\\\"e2ac9cefb88f\\\" : res == 1 ? hex\\\"f09f9fa8\\\" : hex\\\"f09f9fa9\\\";\\n                    result /= 3;\\n                }\\n                rows[q] = abi.encodePacked(strs[0], strs[1], strs[2], strs[3], strs[4], strs[5], strs[6], strs[7], \\\"\\\\\\\\n\\\");\\n            }\\n            return string(abi.encodePacked(rows[0], rows[1], rows[2], rows[3], rows[4], rows[5], rows[6], rows[7]));\\n        }\\n    }\\n\\n    function makeImageURI(\\n        uint256 result,\\n        uint256 ncol,\\n        uint256 nrow,\\n        uint256 salt\\n    ) internal pure returns (string memory) {\\n        string memory image = Base64.encode(NFTArt.drawSVG(result, ncol, nrow, salt));\\n        return string(abi.encodePacked(\\\"data:image/svg+xml;base64,\\\", image));\\n    }\\n\\n    function uintToString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/NFTArt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nimport \\\"./RNG.sol\\\";\\n\\nlibrary NFTArt {\\n    using RNG for RNG.Data;\\n\\n    uint256 internal constant W_BASE = 30;\\n    uint256 internal constant W_RAND = 30;\\n    uint256 internal constant L_BASE = 30;\\n    uint256 internal constant L_RAND = 30;\\n    uint256 internal constant H_BASE = 20;\\n    uint256 internal constant H_RAND = 40;\\n    uint256 internal constant LAST_ROW_MIN_L = 55;\\n    uint256 internal constant FIRST_COL_MIN_W = 25;\\n\\n    bytes6 internal constant FRAME_COLOR = \\\"332E22\\\";\\n    bytes6 internal constant COLOR1 = \\\"E8E4DC\\\";\\n    bytes internal constant COLOR2 = \\\"6688EE6688EEFCBC18FDBD2EFE514EF2532DE7AC52EC6B2558C9EDEC6B25457DB6FCD265999999C3B89FF4AB13208793\\\";\\n    bytes internal constant COLOR3 = \\\"EE6666EE666628A7914561CC6CC2820B9594639AA0639AA0EF8FA3623A53DC5357DC505355555550978E9FBBC1C92B28\\\";\\n    bytes internal constant BG_COLOR = \\\"FBF5E9FBF5E9FBECE9F7F2E6ECEBE8EAEAEAF5EEE6\\\";\\n\\n    int256 internal constant LOGO_LENGTH = 112 * 35; // logo scale: 35\\n    int256 internal constant SCALE = 100;\\n    int256 internal constant OFFSET_X = ((600 / 2) + 0) * SCALE;\\n    int256 internal constant OFFSET_Y = ((600 / 2) + 20) * SCALE;\\n    int256 internal constant COS_30 = 86602540;\\n    int256 internal constant SIN_30 = 50000000;\\n\\n    /**\\n     * w:       block width\\n     * l:       block length\\n     * h:       block height\\n     * (p, q):  block position in virtual plane\\n     * (x, y):  block position in projected plane\\n     */\\n\\n    function isometric(int256 p, int256 q) internal pure returns (int256 x, int256 y) {\\n        unchecked {\\n            x = ((p + q) * COS_30) / 1e8 + OFFSET_X;\\n            y = ((q - p) * SIN_30) / 1e8 + OFFSET_Y;\\n        }\\n    }\\n\\n    function intToString(int256 value) internal pure returns (bytes5 buffer) {\\n        assert(value >= 0 && value <= 99999);\\n        unchecked {\\n            // prettier-ignore\\n            buffer = bytes5(0x3030303030 + uint40(\\n                ((((uint256(value) / 1e0) % 10)) << 0) |\\n                ((((uint256(value) / 1e1) % 10)) << 8) |\\n                ((((uint256(value) / 1e2) % 10)) << 16) |\\n                ((((uint256(value) / 1e3) % 10)) << 24) |\\n                ((((uint256(value) / 1e4) % 10)) << 32)\\n            ));\\n        }\\n    }\\n\\n    function pickColor(bytes memory choices, uint256 rand) internal pure returns (bytes6 picked) {\\n        unchecked {\\n            uint256 i = (rand % (choices.length / 6)) * 6;\\n            assembly {\\n                picked := mload(add(add(choices, 32), i))\\n            }\\n        }\\n    }\\n\\n    struct Plane {\\n        int256 ax;\\n        int256 ay;\\n        int256 bx;\\n        int256 by;\\n        int256 cx;\\n        int256 cy;\\n        int256 dx;\\n        int256 dy;\\n    }\\n\\n    function makeBlock(\\n        int256 p,\\n        int256 q,\\n        int256 w,\\n        int256 l,\\n        int256 h,\\n        bytes6 color,\\n        bool addLogo\\n    ) internal pure returns (bytes memory blk) {\\n        unchecked {\\n            Plane memory ground;\\n            (ground.ax, ground.ay) = isometric(p, q);\\n            (ground.bx, ground.by) = isometric(p + w, q);\\n            (ground.cx, ground.cy) = isometric(p + w, q + l);\\n            (ground.dx, ground.dy) = isometric(p, q + l);\\n\\n            Plane memory cover = Plane({\\n                ax: ground.ax,\\n                ay: ground.ay - h,\\n                bx: ground.bx,\\n                by: ground.by - h,\\n                cx: ground.cx,\\n                cy: ground.cy - h,\\n                dx: ground.dx,\\n                dy: ground.dy - h\\n            });\\n\\n            // prettier-ignore\\n            bytes memory coverCode = abi.encodePacked(\\n                '<path d=\\\"M', intToString(cover.ax), \\\",\\\", intToString(cover.ay),\\n                \\\"L\\\", intToString(cover.bx), \\\",\\\", intToString(cover.by),\\n                \\\"L\\\", intToString(cover.cx), \\\",\\\", intToString(cover.cy),\\n                \\\"L\\\", intToString(cover.dx), \\\",\\\", intToString(cover.dy), 'Z\\\" fill=\\\"#', color, '\\\"/>'\\n            );\\n            // prettier-ignore\\n            bytes memory sides = abi.encodePacked(\\n                '<path d=\\\"M', intToString(cover.ax), \\\",\\\", intToString(cover.ay),\\n                \\\"L\\\", intToString(cover.dx), \\\",\\\", intToString(cover.dy),\\n                \\\"L\\\", intToString(cover.cx), \\\",\\\", intToString(cover.cy),\\n                \\\"V\\\", intToString(ground.cy),\\n                \\\"L\\\", intToString(ground.dx), \\\",\\\", intToString(ground.dy),\\n                \\\"L\\\", intToString(ground.ax), \\\",\\\", intToString(ground.ay), 'Z\\\"/>'\\n            );\\n            blk = abi.encodePacked(sides, coverCode);\\n\\n            if (addLogo) {\\n                (int256 x, int256 y) = isometric(p + w / 2, q + (l - LOGO_LENGTH) / 2);\\n                blk = abi.encodePacked(blk, '<use href=\\\"#logo\\\" x=\\\"', intToString(x), '\\\" y=\\\"', intToString(y - h), '\\\"/>');\\n            }\\n        }\\n    }\\n\\n    function makeBlocks(Config memory cfg) internal pure returns (bytes[8] memory rows) {\\n        unchecked {\\n            int256 qMemo = 0;\\n            for (uint256 q = 0; q < cfg.nrow; q++) {\\n                bytes[8] memory bs;\\n                int256 l = int256(cfg.ls[q]);\\n\\n                uint256 i = 0;\\n                for (uint256 p = cfg.ncol - 1; p != type(uint256).max; --p) {\\n                    bytes6 color = cfg.colors[cfg.result % 3];\\n                    int256 w = int256(cfg.ws[p]);\\n                    int256 h = int256(cfg.hs[q][p]);\\n                    int256 pAdjusted = cfg.offsetP + int256(p == 0 ? 0 : cfg.wsCumSum[p - 1]);\\n                    int256 qAdjusted = cfg.offsetQ + qMemo;\\n                    bool addLogo = q == cfg.nrow - 1 && p == 0;\\n\\n                    bs[i++] = makeBlock(pAdjusted, qAdjusted, w, l, h, color, addLogo);\\n                    cfg.result /= 3;\\n                }\\n                rows[q] = abi.encodePacked(bs[0], bs[1], bs[2], bs[3], bs[4], bs[5], bs[6], bs[7]);\\n                qMemo += l;\\n            }\\n        }\\n    }\\n\\n    function makeSvg(Config memory cfg) internal pure returns (bytes memory svg) {\\n        bytes[8] memory rows = makeBlocks(cfg);\\n        svg = abi.encodePacked(\\n            '<svg viewBox=\\\"0 0 60000 60000\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">'\\n            '<def><g id=\\\"logo\\\" fill=\\\"#332E22\\\" stroke-width=\\\"0\\\" transform=\\\"scale(35)\\\">'\\n            '<path d=\\\"M18 20c2 1 2.3 2.3.6 3.2S14 24 12 23c-2-1-2.2-2.4-.6-3.2s4.6-1 6.6.1zm5.3 12.6c1.7-1 1.4-2.3-.6-3.2s-5-1-6.5-.2-1.3 2.3.6 3.2c2 1 4.8 1 6.5.2z\\\"/>'\\n            '<path fill-rule=\\\"evenodd\\\" d=\\\"M80 19.5C84.6 1 29.2-3.6 11 8-8.7 17.8 1 48 35.7 44.4c.2.2.5.3.8.4l23 9.8c1.8.8 4.3.7 6-.2L99.8 35c1.6-1 1.6-2.2.1-3.2l-19-12c-.3-.2-.6-.3-1-.4zM48.6 34C16.5 51-6.8 22.3 16 10.5 10 22 78 15.4 48.6 34zm45.2-.6l-13 7.4c-3-1-9.8-6.7-13.5-4.3-4.4 2 6.6 5.5 8.6 7L71 46.3c-3-1-11-6.5-14-4-3.8 2 7.4 5.2 9.5 6.6l-4 2.3L42.8 43l35-19.7 16 10.2z\\\"/>'\\n            \\\"</g></def>\\\"\\n            '<rect width=\\\"60000\\\" height=\\\"60000\\\" fill=\\\"#',\\n            cfg.frameColor,\\n            '\\\"/>'\\n            '<rect x=\\\"2500\\\" y=\\\"2500\\\" width=\\\"55000\\\" height=\\\"55000\\\" stroke=\\\"#332E22\\\" stroke-width=\\\"200\\\" fill=\\\"#',\\n            cfg.bgColor,\\n            '\\\"/>'\\n            '<g fill=\\\"#332E22\\\" stroke=\\\"#332E22\\\" stroke-width=\\\"100\\\">'\\n        );\\n        svg = abi.encodePacked(svg, rows[0], rows[1], rows[2], rows[3], rows[4], rows[5], rows[6], rows[7], \\\"</g></svg>\\\");\\n    }\\n\\n    // ------- config -------\\n\\n    struct Config {\\n        uint256 result;\\n        uint256 ncol;\\n        uint256 nrow;\\n        int256 offsetP;\\n        int256 offsetQ;\\n        uint256[8] ws;\\n        uint256[8] ls;\\n        uint256[8][8] hs;\\n        uint256[8] wsCumSum;\\n        bytes6[3] colors;\\n        bytes6 bgColor;\\n        bytes6 frameColor;\\n    }\\n\\n    function generateConfig(\\n        uint256 result,\\n        uint256 ncol,\\n        uint256 nrow,\\n        uint256 salt\\n    ) internal pure returns (Config memory cfg) {\\n        RNG.Data memory rng = RNG.Data(salt, 0);\\n\\n        cfg.result = result;\\n        cfg.ncol = ncol;\\n        cfg.nrow = nrow;\\n\\n        cfg.colors[0] = COLOR1;\\n        cfg.colors[1] = pickColor(COLOR2, rng.rand());\\n        cfg.colors[2] = pickColor(COLOR3, rng.rand());\\n        cfg.bgColor = pickColor(BG_COLOR, rng.rand());\\n        cfg.frameColor = FRAME_COLOR;\\n\\n        while (true) {\\n            // generate widths\\n            unchecked {\\n                uint256[8] memory ws = cfg.ws;\\n                uint256[8] memory wsCumSum = cfg.wsCumSum;\\n                uint256 rand = rng.rand();\\n                uint256 memo = 0;\\n                for (uint256 p = 0; p < ncol; ++p) {\\n                    uint256 w = (W_BASE + ((rand >> (8 * p)) % W_RAND)) * uint256(SCALE);\\n                    if (p == 0 && w < FIRST_COL_MIN_W) w = FIRST_COL_MIN_W;\\n                    wsCumSum[p] = (memo += (ws[p] = w));\\n                }\\n                cfg.offsetP = -int256(memo) / 2;\\n            }\\n\\n            // generate lengths\\n            unchecked {\\n                uint256[8] memory ls = cfg.ls;\\n                uint256 rand = rng.rand();\\n                uint256 memo = 0;\\n                for (uint256 q = 0; q < nrow; ++q) {\\n                    uint256 l = (L_BASE + ((rand >> (8 * q)) % L_RAND)) * uint256(SCALE);\\n                    if (q == nrow - 1 && l < LAST_ROW_MIN_L) l = LAST_ROW_MIN_L;\\n                    memo += (ls[q] = l);\\n                }\\n                cfg.offsetQ = -int256(memo) / 2;\\n            }\\n\\n            // ensure no \\\"out of canvas\\\"\\n            (int256 x0, ) = isometric(cfg.offsetP, cfg.offsetQ);\\n            if (x0 >= 3000) break;\\n        }\\n\\n        // generate heights\\n        unchecked {\\n            uint256[8][8] memory hs = cfg.hs;\\n            for (uint256 q = 0; q < nrow; ++q) {\\n                uint256 rand = rng.rand();\\n                for (uint256 p = 0; p < ncol; ++p) {\\n                    hs[q][p] = (H_BASE + ((rand >> (8 * p)) % H_RAND)) * uint256(SCALE);\\n                }\\n            }\\n        }\\n    }\\n\\n    // ------- entry point -------\\n\\n    function drawSVG(\\n        uint256 result,\\n        uint256 ncol,\\n        uint256 nrow,\\n        uint256 salt\\n    ) internal pure returns (bytes memory svg) {\\n        return makeSvg(generateConfig(result, ncol, nrow, salt));\\n    }\\n}\\n\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n                    decodedLen := sub(decodedLen, 1)\\n                }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               // read 4 characters\\n               dataPtr := add(dataPtr, 4)\\n               let input := mload(dataPtr)\\n\\n               // write 3 bytes\\n               let output := add(\\n                   add(\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\n                   add(\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\n                    )\\n                )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/RNG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nlibrary RNG {\\n    struct Data {\\n        uint256 seed;\\n        uint256 i;\\n    }\\n\\n    function rand(Data memory rng) internal pure returns (uint256) {\\n        unchecked {\\n            return uint256(keccak256(abi.encode(rng.seed, rng.i++)));\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dimensionLimits\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"imageURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"data\",\"type\":\"uint128\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dimensionLimits\",\"type\":\"uint16\"}],\"name\":\"setDimensionLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_mintable\",\"type\":\"bool\"}],\"name\":\"setMintable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_descriptor\",\"type\":\"address\"}],\"name\":\"setTokenDescriptor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"squares\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenData\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenDescriptor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GenArtNFT", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}