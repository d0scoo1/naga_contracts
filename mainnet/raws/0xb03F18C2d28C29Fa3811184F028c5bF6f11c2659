{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AaveV2StablecoinCellar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.11;\\n\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IAaveV2StablecoinCellar} from \\\"./interfaces/IAaveV2StablecoinCellar.sol\\\";\\nimport {IAaveIncentivesController} from \\\"./interfaces/IAaveIncentivesController.sol\\\";\\nimport {IStakedTokenV2} from \\\"./interfaces/IStakedTokenV2.sol\\\";\\nimport {ICurveSwaps} from \\\"./interfaces/ICurveSwaps.sol\\\";\\nimport {ISushiSwapRouter} from \\\"./interfaces/ISushiSwapRouter.sol\\\";\\nimport {IGravity} from \\\"./interfaces/IGravity.sol\\\";\\nimport {ILendingPool} from \\\"./interfaces/ILendingPool.sol\\\";\\nimport {MathUtils} from \\\"./utils/MathUtils.sol\\\";\\n\\n/**\\n * @title Sommelier Aave V2 Stablecoin Cellar\\n * @notice Dynamic ERC4626 that adapts strategies to always get the best yield for stablecoins on Aave.\\n * @author Brian Le\\n */\\ncontract AaveV2StablecoinCellar is IAaveV2StablecoinCellar, ERC20, Ownable {\\n    using SafeTransferLib for ERC20;\\n    using MathUtils for uint256;\\n\\n    /**\\n     * @notice The asset that makes up the cellar's holding pool. Will change whenever the cellar\\n     *         rebalances into a new strategy.\\n     * @dev The cellar denotes its inactive assets in this token. While it waits in the holding pool\\n     *      to be entered into a strategy, it is used to pay for withdraws from those redeeming their\\n     *      shares.\\n     */\\n    ERC20 public asset;\\n\\n    /**\\n     * @notice An interest-bearing derivative of the current asset returned by Aave for lending\\n     *         assets. Represents cellar's portion of active assets earning yield in a lending\\n     *         strategy.\\n     */\\n    ERC20 public assetAToken;\\n\\n    /**\\n     * @notice The decimals of precision used by the current asset.\\n     * @dev Some stablecoins (eg. USDC and USDT) don't use the standard 18 decimals of precision.\\n     *      This is used for converting between decimals when performing calculations in the cellar.\\n     */\\n    uint8 public assetDecimals;\\n\\n    /**\\n     * @notice Mapping from a user's address to all their deposits and balances.\\n     * @dev Used in determining which of a user's shares are active (entered into a strategy earning\\n     *      yield vs inactive (waiting in the holding pool to be entered into a strategy and not\\n     *      earning yield).\\n     */\\n    mapping(address => UserDeposit[]) public userDeposits;\\n\\n    /**\\n     * @notice Mapping from user's address to the index of first non-zero deposit in `userDeposits`.\\n     * @dev Saves gas when looping through all user's deposits.\\n     */\\n    mapping(address => uint256) public currentDepositIndex;\\n\\n    /**\\n     * @notice Last time all inactive assets were entered into a strategy and made active.\\n     */\\n    uint256 public lastTimeEnteredStrategy;\\n\\n    /**\\n     * @notice The value fees are divided by to get a percentage. Represents maximum percent (100%).\\n     */\\n    uint256 public constant DENOMINATOR = 100_00;\\n\\n    /**\\n     * @notice The percentage of platform fees (1%) taken off of active assets over a year.\\n     */\\n    uint256 public constant PLATFORM_FEE = 1_00;\\n\\n    /**\\n     * @notice The percentage of performance fees (5%) taken off of cellar gains.\\n     */\\n    uint256 public constant PERFORMANCE_FEE = 5_00;\\n\\n    /**\\n     * @notice Timestamp of last time platform fees were accrued.\\n     */\\n    uint256 public lastTimeAccruedPlatformFees;\\n\\n    /**\\n     * @notice Amount of active assets in cellar last time performance fees were accrued.\\n     */\\n    uint256 public lastActiveAssets;\\n\\n    /**\\n     * @notice Normalized income index for the current asset on Aave recorded last time performance\\n     *         fees were accrued.\\n     */\\n    uint256 public lastNormalizedIncome;\\n\\n    /**\\n     * @notice Amount of platform fees that have been accrued awaiting transfer.\\n     * @dev Fees are taken in shares and redeemed for assets at the time they are transferred from\\n     *      the cellar to Cosmos to be distributed.\\n     */\\n    uint256 public accruedPlatformFees;\\n\\n    /**\\n     * @notice Amount of performance fees that have been accrued awaiting transfer.\\n     * @dev Fees are taken in shares and redeemed for assets at the time they are transferred from\\n     *      the cellar to Cosmos to be distributed.\\n     */\\n    uint256 public accruedPerformanceFees;\\n\\n    /**\\n     * @notice Cosmos address of the fee distributor as a hex value.\\n     * @dev The Gravity contract expects a 32-byte value formatted in a specific way.\\n     */\\n    bytes32 public constant feesDistributor = hex\\\"000000000000000000000000b813554b423266bbd4c16c32fa383394868c1f55\\\";\\n\\n    /**\\n     * @notice Maximum amount of assets that can be managed by the cellar. Denominated in the same\\n     *         units as the current asset.\\n     * @dev Limited to $5m until after security audits.\\n     */\\n    uint256 public maxLiquidity;\\n\\n    /**\\n     * @notice Whether or not the contract is paused in case of an emergency.\\n     */\\n    bool public isPaused;\\n\\n    /**\\n     * @notice Whether or not the contract is permanently shutdown in case of an emergency.\\n     */\\n    bool public isShutdown;\\n\\n    // ======================================== IMMUTABLES ========================================\\n\\n    // Curve Registry Exchange contract\\n    ICurveSwaps public immutable curveRegistryExchange; // 0xD1602F68CC7C4c7B59D686243EA35a9C73B0c6a2\\n    // SushiSwap Router V2 contract\\n    ISushiSwapRouter public immutable sushiswapRouter; // 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F\\n    // Aave Lending Pool V2 contract\\n    ILendingPool public immutable lendingPool; // 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9\\n    // Aave Incentives Controller V2 contract\\n    IAaveIncentivesController public immutable incentivesController; // 0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5\\n    // Cosmos Gravity Bridge contract\\n    IGravity public immutable gravityBridge; // 0x69592e6f9d21989a043646fE8225da2600e5A0f7\\n\\n    IStakedTokenV2 public immutable stkAAVE; // 0x4da27a545c0c5B758a6BA100e3a049001de870f5\\n    ERC20 public immutable AAVE; // 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9\\n    ERC20 public immutable WETH; // 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\\n\\n    /**\\n     * @dev Owner of the cellar will be the Gravity contract controlled by Steward:\\n     *      https://github.com/cosmos/gravity-bridge/blob/main/solidity/contracts/Gravity.sol\\n     *      https://github.com/PeggyJV/steward\\n     * @param _asset current asset managed by the cellar\\n     * @param _curveRegistryExchange Curve registry exchange\\n     * @param _sushiswapRouter Sushiswap V2 router address\\n     * @param _lendingPool Aave V2 lending pool address\\n     * @param _incentivesController _incentivesController\\n     * @param _gravityBridge Cosmos Gravity Bridge address\\n     * @param _stkAAVE stkAAVE address\\n     * @param _AAVE AAVE address\\n     * @param _WETH WETH address\\n     */\\n    constructor(\\n        ERC20 _asset,\\n        ICurveSwaps _curveRegistryExchange,\\n        ISushiSwapRouter _sushiswapRouter,\\n        ILendingPool _lendingPool,\\n        IAaveIncentivesController _incentivesController,\\n        IGravity _gravityBridge,\\n        IStakedTokenV2 _stkAAVE,\\n        ERC20 _AAVE,\\n        ERC20 _WETH\\n    ) ERC20(\\\"Sommelier Aave V2 Stablecoin Cellar LP Token\\\", \\\"aave2-CLR-S\\\", 18) Ownable() {\\n        curveRegistryExchange =  _curveRegistryExchange;\\n        sushiswapRouter = _sushiswapRouter;\\n        lendingPool = _lendingPool;\\n        incentivesController = _incentivesController;\\n        gravityBridge = _gravityBridge;\\n        stkAAVE = _stkAAVE;\\n        AAVE = _AAVE;\\n        WETH = _WETH;\\n\\n        // Initialize asset.\\n        _updateStrategy(address(_asset));\\n\\n        // Initialize starting point for platform fee accrual to time when cellar was created.\\n        // Otherwise it would incorrectly calculate how much platform fees to take when accrueFees\\n        // is called for the first time.\\n        lastTimeAccruedPlatformFees = block.timestamp;\\n    }\\n\\n    // =============================== DEPOSIT/WITHDRAWAL OPERATIONS ===============================\\n\\n    /**\\n     * @notice Deposits assets and mints the shares to receiver.\\n     * @param assets amount of assets to deposit\\n     * @param receiver address receiving the shares\\n     * @return shares amount of shares minted\\n     */\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares) {\\n        // In the case where a user tries to deposit more than their balance, the desired behavior\\n        // is to deposit what they have instead of reverting.\\n        uint256 maxDepositable = asset.balanceOf(msg.sender);\\n        if (assets > maxDepositable) assets = maxDepositable;\\n\\n        (, shares) = _deposit(assets, 0, receiver);\\n    }\\n\\n    /**\\n     * @notice Mints shares to receiver by depositing assets.\\n     * @param shares amount of shares to mint\\n     * @param receiver address receiving the shares\\n     * @return assets amount of assets deposited\\n     */\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets) {\\n        // In the case where a user tries to mint more shares than possible, the desired behavior\\n        // is to mint as many shares as their balance allows instead of reverting.\\n        uint256 maxMintable = previewDeposit(asset.balanceOf(msg.sender));\\n        if (shares > maxMintable) shares = maxMintable;\\n\\n        (assets, ) = _deposit(0, shares, receiver);\\n    }\\n\\n\\n    function _deposit(uint256 assets, uint256 shares, address receiver) internal returns (uint256, uint256) {\\n        // In case of an emergency or contract vulnerability, we don't want users to be able to\\n        // deposit more assets into a compromised contract.\\n        if (isPaused) revert ContractPaused();\\n        if (isShutdown) revert ContractShutdown();\\n\\n        // Must calculate before assets are transferred in.\\n        shares > 0 ? assets = previewMint(shares) : shares = previewDeposit(assets);\\n\\n        // Check for rounding error on `deposit` since we round down in previewDeposit. No need to\\n        // check for rounding error if `mint`, previewMint rounds up.\\n        if (shares == 0) revert ZeroShares();\\n\\n        // Check if security restrictions still apply. Enforce them if they do.\\n        if (maxLiquidity != type(uint256).max) {\\n            if (assets + totalAssets() > maxLiquidity) revert LiquidityRestricted(maxLiquidity);\\n            if (assets > maxDeposit(receiver)) revert DepositRestricted(50_000 * 10**assetDecimals);\\n        }\\n\\n        // Transfers assets into the cellar.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        // Mint user tokens that represents their share of the cellar's assets.\\n        _mint(receiver, shares);\\n\\n        // Store the user's deposit data. This will be used later on when the user wants to withdraw\\n        // their assets or transfer their shares.\\n        UserDeposit[] storage deposits = userDeposits[receiver];\\n        deposits.push(UserDeposit({\\n            // Always store asset amounts with 18 decimals of precision regardless of the asset's\\n            // decimals. This is so we can still use this data even after rebalancing to different\\n            // asset.\\n            assets: uint112(assets.changeDecimals(assetDecimals, decimals)),\\n            shares: uint112(shares),\\n            timeDeposited: uint32(block.timestamp)\\n        }));\\n\\n        emit Deposit(\\n            msg.sender,\\n            receiver,\\n            address(asset),\\n            assets,\\n            shares\\n        );\\n\\n        return (assets, shares);\\n    }\\n\\n    /**\\n     * @notice Withdraws assets to receiver by redeeming shares from owner.\\n     * @param assets amount of assets being withdrawn\\n     * @param receiver address of account receiving the assets\\n     * @param owner address of the owner of the shares being redeemed\\n     * @return shares amount of shares redeemed\\n     */\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 shares) {\\n        // This is done to avoid the possibility of an overflow if `assets` was set to a very high\\n        // number (like 2**256 \u2013 1)  when trying to change decimals. If a user tries to withdraw\\n        // more than their balance, the desired behavior is to withdraw as much as possible.\\n        uint256 maxWithdrawable = previewRedeem(balanceOf[owner]);\\n        if (assets > maxWithdrawable) assets = maxWithdrawable;\\n\\n        // Ensures proceeding calculations are done with a standard 18 decimals of precision. Will\\n        // change back to the using the asset's usual decimals of precision when transferring assets\\n        // after all calculations are done.\\n        assets = assets.changeDecimals(assetDecimals, decimals);\\n\\n        (, shares) = _withdraw(assets, receiver, owner);\\n    }\\n\\n    /**\\n     * @notice Redeems shares from owner to withdraw assets to receiver.\\n     * @param shares amount of shares redeemed\\n     * @param receiver address of account receiving the assets\\n     * @param owner address of the owner of the shares being redeemed\\n     * @return assets amount of assets sent to receiver\\n     */\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 assets) {\\n        // This is done to avoid the possibility of an overflow if `shares` was set to a very high\\n        // number (like 2**256 \u2013 1) when trying to change decimals. If a user tries to redeem more\\n        // than their balance, the desired behavior is to redeem as much as possible.\\n        uint256 maxRedeemable = maxRedeem(owner);\\n        if (shares > maxRedeemable) shares = maxRedeemable;\\n\\n        (assets, ) = _withdraw(_convertToAssets(shares), receiver, owner);\\n    }\\n\\n    /// @dev `assets` must be passed in with 18 decimals of precision. Should extend/truncate decimals of\\n    ///      the amount passed in if necessary to ensure this is true.\\n    function _withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) internal returns (uint256, uint256) {\\n        if (balanceOf[owner] == 0) revert ZeroShares();\\n        if (assets == 0) revert ZeroAssets();\\n\\n        // Tracks the total amount of shares being redeemed for the amount of assets withdrawn.\\n        uint256 shares;\\n\\n        // Retrieve the user's deposits to begin looping through them, generally from oldest to\\n        // newest deposits. This may not be the case though if shares have been transferred to the\\n        // owner, which will be added to the end of the owner's deposits regardless of time\\n        // deposited.\\n        UserDeposit[] storage deposits = userDeposits[owner];\\n\\n        // Tracks the amount of assets left to withdraw. Updated at the end of each loop.\\n        uint256 leftToWithdraw = assets;\\n\\n        // Saves gas by avoiding calling `_convertToAssets` on active shares during each loop.\\n        uint256 exchangeRate = _convertToAssets(1e18);\\n\\n        for (uint256 i = currentDepositIndex[owner]; i < deposits.length; i++) {\\n            UserDeposit storage d = deposits[i];\\n\\n            // Whether or not deposited shares are active or inactive.\\n            bool isActive = d.timeDeposited <= lastTimeEnteredStrategy;\\n\\n            // If shares are active, convert them to the amount of assets they're worth to see the\\n            // maximum amount of assets we can take from this deposit.\\n            uint256 dAssets = isActive ? uint256(d.shares).mulWadDown(exchangeRate) : d.assets;\\n\\n            // Determine the amount of assets and shares to withdraw from this deposit.\\n            uint256 withdrawnAssets = MathUtils.min(leftToWithdraw, dAssets);\\n            uint256 withdrawnShares = uint256(d.shares).mulDivUp(withdrawnAssets, dAssets);\\n\\n            // For active shares, deletes the deposit data we don't need anymore for a gas refund.\\n            if (isActive) {\\n                delete d.assets;\\n                delete d.timeDeposited;\\n            } else {\\n                d.assets -= uint112(withdrawnAssets);\\n            }\\n\\n            // Take the shares we need from this deposit and add them to our total.\\n            d.shares -= uint112(withdrawnShares);\\n            shares += withdrawnShares;\\n\\n            // Update the counter of assets we have left to withdraw.\\n            leftToWithdraw -= withdrawnAssets;\\n\\n            // Finish if this is the last deposit or there is nothing left to withdraw.\\n            if (i == deposits.length - 1 || leftToWithdraw == 0) {\\n                // Store the user's next non-zero deposit to save gas on future looping.\\n                currentDepositIndex[owner] = d.shares != 0 ? i : i+1;\\n                break;\\n            }\\n        }\\n\\n        // If the caller is not the owner of the shares, check to see if the owner has approved them\\n        // to spend their shares.\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Redeem shares for assets.\\n        _burn(owner, shares);\\n\\n        // Determine the total amount of assets withdrawn.\\n        assets -= leftToWithdraw;\\n\\n        // Convert assets decimals back to get ready for transfers.\\n        assets = assets.changeDecimals(decimals, assetDecimals);\\n\\n        // Only withdraw from strategy if holding pool does not contain enough funds.\\n        _allocateAssets(assets);\\n\\n        // Transfer assets to receiver from the cellar's holding pool.\\n        asset.safeTransfer(receiver, assets);\\n\\n        emit Withdraw(receiver, owner, address(asset), assets, shares);\\n\\n        // Returns the amount of assets withdrawn and amount of shares redeemed. The amount of\\n        // assets withdrawn may differ from the amount of assets specified when calling the function\\n        // if the user has less assets then they tried withdrawing.\\n        return (assets, shares);\\n    }\\n\\n    // ================================== ACCOUNTING OPERATIONS ==================================\\n\\n    /**\\n     * @dev The internal functions always use 18 decimals of precision while the public functions use\\n     *      as many decimals as the current asset (aka they don't change the decimals). This is\\n     *      because we want the user deposit data the cellar stores to be usable across different\\n     *      assets regardless of the decimals used. This means the cellar will always perform\\n     *      calculations and store data with a standard of 18 decimals of precision but will change\\n     *      the decimals back when transferring assets outside the contract or returning data\\n     *      through public view functions.\\n     */\\n\\n    /**\\n     * @notice Total amount of active asset entered into a strategy.\\n     */\\n    function activeAssets() public view returns (uint256) {\\n        // The aTokens' value is pegged to the value of the corresponding asset at a 1:1 ratio. We\\n        // can find the amount of assets active in a strategy simply by taking balance of aTokens\\n        // cellar holds.\\n        return assetAToken.balanceOf(address(this));\\n    }\\n\\n    function _activeAssets() internal view returns (uint256) {\\n        uint256 assets = assetAToken.balanceOf(address(this));\\n        return assets.changeDecimals(assetDecimals, decimals);\\n    }\\n\\n    /**\\n     * @notice Total amount of inactive asset waiting in a holding pool to be entered into a strategy.\\n     */\\n    function inactiveAssets() public view returns (uint256) {\\n        return asset.balanceOf(address(this));\\n    }\\n\\n    function _inactiveAssets() internal view returns (uint256) {\\n        uint256 assets = asset.balanceOf(address(this));\\n        return assets.changeDecimals(assetDecimals, decimals);\\n    }\\n\\n    /**\\n     * @notice Total amount of the asset that is managed by cellar.\\n     */\\n    function totalAssets() public view returns (uint256) {\\n        return activeAssets() + inactiveAssets();\\n    }\\n\\n    function _totalAssets() internal view returns (uint256) {\\n        return _activeAssets() + _inactiveAssets();\\n    }\\n\\n    /**\\n     * @notice The amount of shares that the cellar would exchange for the amount of assets provided\\n     *         ONLY if they are active.\\n     * @param assets amount of assets to convert\\n     * @return shares the assets can be exchanged for\\n     */\\n    function convertToShares(uint256 assets) public view returns (uint256) {\\n        assets = assets.changeDecimals(assetDecimals, decimals);\\n        return _convertToShares(assets);\\n    }\\n\\n    function _convertToShares(uint256 assets) internal view returns (uint256) {\\n        return totalSupply == 0 ? assets : assets.mulDivDown(totalSupply, _totalAssets());\\n    }\\n\\n    /**\\n     * @notice The amount of assets that the cellar would exchange for the amount of shares provided\\n     *         ONLY if they are active.\\n     * @param shares amount of shares to convert\\n     * @return assets the shares can be exchanged for\\n     */\\n    function convertToAssets(uint256 shares) public view returns (uint256) {\\n        uint256 assets = _convertToAssets(shares);\\n        return assets.changeDecimals(decimals, assetDecimals);\\n    }\\n\\n    function _convertToAssets(uint256 shares) internal view returns (uint256) {\\n        return totalSupply == 0 ? shares : shares.mulDivDown(_totalAssets(), totalSupply);\\n    }\\n\\n    /**\\n    * @notice Simulate the effects of depositing assets at the current block, given current on-chain\\n    *         conditions.\\n     * @param assets amount of assets to deposit\\n     * @return shares that will be minted\\n     */\\n    function previewDeposit(uint256 assets) public view returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    /**\\n    * @notice Simulate the effects of minting shares at the current block, given current on-chain\\n    *         conditions.\\n     * @param shares amount of shares to mint\\n     * @return assets that will be deposited\\n     */\\n    function previewMint(uint256 shares) public view returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        uint256 assets = supply == 0 ? shares : shares.mulDivUp(_totalAssets(), supply);\\n        return assets.changeDecimals(decimals, assetDecimals);\\n    }\\n\\n    /**\\n    * @notice Simulate the effects of withdrawing assets at the current block, given current\\n    *         on-chain conditions. Assumes the shares being redeemed are all active.\\n     * @param assets amount of assets to withdraw\\n     * @return shares that will be redeemed\\n     */\\n    function previewWithdraw(uint256 assets) public view returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\\n    }\\n\\n    /**\\n    * @notice Simulate the effects of redeeming shares at the current block, given current on-chain\\n    *         conditions. Assumes the shares being redeemed are all active.\\n     * @param shares amount of sharers to redeem\\n     * @return assets that can be withdrawn\\n     */\\n    function previewRedeem(uint256 shares) public view returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    // ======================================= STATE INFORMATION =====================================\\n\\n    /**\\n     * @notice Retrieve information on a user's deposits.\\n     * @param user address of the user\\n     * @return userActiveShares amount of active shares the user has\\n     * @return userInactiveShares amount of inactive shares the user has\\n     * @return userActiveAssets amount of active assets the user has\\n     * @return userInactiveAssets amount of inactive assets the user has\\n     */\\n    function depositBalances(address user) public view returns (\\n        uint256 userActiveShares,\\n        uint256 userInactiveShares,\\n        uint256 userActiveAssets,\\n        uint256 userInactiveAssets\\n    ) {\\n        // Retrieve the user's deposits to begin looping through them, generally from oldest to\\n        // newest deposits. This may not be the case though if shares have been transferred to the\\n        // user, which will be added to the end of the user's deposits regardless of time\\n        // deposited.\\n        UserDeposit[] storage deposits = userDeposits[user];\\n\\n        // Saves gas by avoiding calling `_convertToAssets` on active shares during each loop.\\n        uint256 exchangeRate = _convertToAssets(1e18);\\n\\n        for (uint256 i = currentDepositIndex[user]; i < deposits.length; i++) {\\n            UserDeposit storage d = deposits[i];\\n\\n\\n            // Determine whether or not deposit is active or inactive.\\n            if (d.timeDeposited <= lastTimeEnteredStrategy) {\\n                // Saves an extra SLOAD if active and cast type to uint256.\\n                uint256 dShares = d.shares;\\n\\n                userActiveShares += dShares;\\n                userActiveAssets += dShares.mulWadDown(exchangeRate); // Convert shares to assets.\\n            } else {\\n                userInactiveShares += d.shares;\\n                userInactiveAssets += d.assets;\\n            }\\n        }\\n\\n        // Return assets in their original units.\\n        userActiveAssets = userActiveAssets.changeDecimals(decimals, assetDecimals);\\n        userInactiveAssets = userInactiveAssets.changeDecimals(decimals, assetDecimals);\\n    }\\n\\n    /**\\n     * @notice Returns the number of deposits for a user. Can be used off-chain to\\n     *         make iterating through user stakes easier.\\n     * @param user address of the user\\n     * @return deposits the number of deposits for the user\\n     */\\n    function numDeposits(address user) external view returns (uint256) {\\n        return userDeposits[user].length;\\n    }\\n\\n    // =========================== DEPOSIT/WITHDRAWAL LIMIT OPERATIONS ===========================\\n\\n    /**\\n     * @notice Total number of assets that can be deposited by owner into the cellar.\\n     * @dev Until after security audits, limits deposits to $50k per wallet.\\n     * @param owner address of account that would receive the shares\\n     * @return maximum amount of assets that can be deposited\\n     */\\n    function maxDeposit(address owner) public view returns (uint256) {\\n        if (isShutdown || isPaused) return 0;\\n\\n        if (maxLiquidity == type(uint256).max) return type(uint256).max;\\n\\n        uint256 depositLimit = 50_000 * 10**assetDecimals;\\n        uint256 assets = previewRedeem(balanceOf[owner]);\\n\\n        return depositLimit > assets ? depositLimit - assets : 0;\\n    }\\n\\n    /**\\n     * @notice Total number of shares that can be minted for owner from the cellar.\\n     * @dev Until after security audits, limits mints to $50k of shares per wallet.\\n     * @param owner address of account that would receive the shares\\n     * @return maximum amount of shares that can be minted\\n     */\\n    function maxMint(address owner) public view returns (uint256) {\\n        if (isShutdown || isPaused) return 0;\\n\\n        if (maxLiquidity == type(uint256).max) return type(uint256).max;\\n\\n        uint256 mintLimit = previewDeposit(50_000 * 10**assetDecimals);\\n        uint256 shares = balanceOf[owner];\\n\\n        return mintLimit > shares ? mintLimit - shares : 0;\\n    }\\n\\n    /**\\n     * @notice Total number of assets that can be withdrawn from the cellar.\\n     * @param owner address of account that would holds the shares\\n     * @return maximum amount of assets that can be withdrawn\\n     */\\n    function maxWithdraw(address owner) public view returns (uint256) {\\n        UserDeposit[] storage deposits = userDeposits[owner];\\n\\n        // Track max assets that can be withdrawn.\\n        uint256 assets;\\n\\n        // Saves gas by avoiding calling `_convertToAssets` on active shares during each loop.\\n        uint256 exchangeRate = _convertToAssets(1e18);\\n\\n        for (uint256 i = currentDepositIndex[owner]; i < deposits.length; i++) {\\n            UserDeposit storage d = deposits[i];\\n\\n            // Determine the amount of assets that can be withdrawn. Only redeem active shares for\\n            // assets, otherwise just withdrawn the original amount of assets that were deposited.\\n            assets += d.timeDeposited <= lastTimeEnteredStrategy ?\\n                uint256(d.shares).mulWadDown(exchangeRate) :\\n                d.assets;\\n        }\\n\\n        // Return the maximum amount of assets that can be withdrawn in the assets original units.\\n        return assets.changeDecimals(decimals, assetDecimals);\\n    }\\n\\n    /**\\n     * @notice Total number of shares that can be redeemed from the cellar.\\n     * @param owner address of account that would holds the shares\\n     * @return maximum amount of shares that can be redeemed\\n     */\\n    function maxRedeem(address owner) public view returns (uint256) {\\n        return balanceOf[owner];\\n    }\\n\\n    // ====================================== FEE OPERATIONS ======================================\\n\\n    /**\\n     * @notice Take platform fees and performance fees off of cellar's active assets.\\n     */\\n    function accrueFees() external {\\n        // When the contract is shutdown, there should be no reason to accrue fees because there\\n        // will be no active assets to accrue fees on.\\n        if (isShutdown) revert ContractShutdown();\\n\\n        // Platform fees taken each accrual = activeAssets * (elapsedTime * (2% / SECS_PER_YEAR)).\\n        uint256 elapsedTime = block.timestamp - lastTimeAccruedPlatformFees;\\n        uint256 platformFeeInAssets =\\n            (_activeAssets() * elapsedTime * PLATFORM_FEE) / DENOMINATOR / 365 days;\\n\\n        // The cellar accrues fees as shares instead of assets.\\n        uint256 platformFees = _convertToShares(platformFeeInAssets);\\n        _mint(address(this), platformFees);\\n\\n        // Update the tracker for total platform fees accrued that are still waiting to be\\n        // transferred.\\n        accruedPlatformFees += platformFees;\\n\\n        emit AccruedPlatformFees(platformFees);\\n\\n        // Begin accrual of performance fees.\\n        _accruePerformanceFees(true);\\n    }\\n\\n    /**\\n     * @notice Accrue performance fees.\\n     * @param updateFeeData whether or not to update fee data\\n     */\\n    function _accruePerformanceFees(bool updateFeeData) internal {\\n        // Retrieve the current normalized income per unit of asset for the current strategy on Aave.\\n        uint256 normalizedIncome = lendingPool.getReserveNormalizedIncome(address(asset));\\n\\n        // If this is the first time the cellar is accruing performance fees, it will skip the part\\n        // were we take fees and should just update the fee data to set a baseline for assessing the\\n        // current strategy's performance.\\n        if (lastActiveAssets != 0) {\\n            // An index value greater than 1e27 indicates positive performance for the strategy's\\n            // lending position, while a value less than that indicates negative performance.\\n            uint256 performanceIndex = normalizedIncome.mulDivDown(1e27, lastNormalizedIncome);\\n\\n            // This is the amount the cellar's active assets have grown to solely from performance\\n            // on Aave since the last time performance fees were accrued.  It does not include\\n            // changes from deposits and withdraws.\\n            uint256 updatedActiveAssets = lastActiveAssets.mulDivUp(performanceIndex, 1e27);\\n\\n            // Determines whether performance has been positive or negative.\\n            if (performanceIndex >= 1e27) {\\n                // Fees taken each accrual = (updatedActiveAssets - lastActiveAssets) * 5%\\n                uint256 gain = updatedActiveAssets - lastActiveAssets;\\n                uint256 performanceFeeInAssets = gain.mulDivDown(PERFORMANCE_FEE, DENOMINATOR);\\n\\n                // The cellar accrues fees as shares instead of assets.\\n                uint256 performanceFees = _convertToShares(performanceFeeInAssets);\\n                _mint(address(this), performanceFees);\\n\\n                accruedPerformanceFees += performanceFees;\\n\\n                emit AccruedPerformanceFees(performanceFees);\\n            } else {\\n                // This would only happen if the current stablecoin strategy on Aave performed\\n                // negatively.  This should rarely happen, if ever, for this particular cellar. But\\n                // in case it does, this mechanism will burn performance fees to help offset losses\\n                // in proportion to those minted for previous gains.\\n\\n                uint256 loss = lastActiveAssets - updatedActiveAssets;\\n                uint256 insuranceInAssets = loss.mulDivDown(PERFORMANCE_FEE, DENOMINATOR);\\n\\n                // Cannot burn more performance fees than the cellar has accrued.\\n                uint256 insurance = MathUtils.min(\\n                    _convertToShares(insuranceInAssets),\\n                    accruedPerformanceFees\\n                );\\n\\n                _burn(address(this), insurance);\\n\\n                accruedPerformanceFees -= insurance;\\n\\n                emit BurntPerformanceFees(insurance);\\n            }\\n        }\\n\\n        // There may be cases were we don't want to update fee data in this function, for example\\n        // when we accrue performance fees before rebalancing into a new strategy since the data\\n        // will be outdated after the rebalance to a new strategy.\\n        if (updateFeeData) {\\n            lastActiveAssets = _activeAssets();\\n            lastNormalizedIncome = normalizedIncome;\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfer accrued fees to Cosmos to distribute.\\n     */\\n    function transferFees() external onlyOwner {\\n        // Total up all the fees this cellar has accrued and determine how much they can be redeemed\\n        // for in assets.\\n        uint256 fees = accruedPerformanceFees + accruedPlatformFees;\\n        uint256 feeInAssets = previewRedeem(fees);\\n\\n        // Redeem our fee shares for assets to transfer to Cosmos.\\n        _burn(address(this), fees);\\n\\n        // Only withdraw assets from strategy if the holding pool does not contain enough funds.\\n        // Otherwise, all assets will come from the holding pool.\\n        _allocateAssets(feeInAssets);\\n\\n        // Transfer assets to a fee distributor on Cosmos.\\n        asset.approve(address(gravityBridge), feeInAssets);\\n        gravityBridge.sendToCosmos(address(asset), feesDistributor, feeInAssets);\\n\\n        emit TransferFees(accruedPlatformFees, accruedPerformanceFees);\\n\\n        // Reset the tracker for fees accrued that are still waiting to be transferred.\\n        accruedPlatformFees = 0;\\n        accruedPerformanceFees = 0;\\n    }\\n\\n    // ===================================== ADMIN OPERATIONS =====================================\\n\\n    /**\\n     * @notice Enters into the current Aave stablecoin strategy.\\n     */\\n    function enterStrategy() external onlyOwner {\\n        // When the contract is shutdown, it shouldn't be allowed to enter back into a strategy with\\n        // the assets it just withdrew from Aave.\\n        if (isShutdown) revert ContractShutdown();\\n\\n        // Deposits all inactive assets in the holding pool into the current strategy.\\n        _depositToAave(address(asset), inactiveAssets());\\n\\n        // The cellar will use this when determining which of a user's shares are active vs inactive.\\n        lastTimeEnteredStrategy = block.timestamp;\\n    }\\n\\n    /**\\n     * @notice Rebalances current assets into a new asset strategy.\\n     * @param route array of [initial token, pool, token, pool, token, ...] that specifies the swap route\\n     * @param swapParams multidimensional array of [i, j, swap type] where i and j are the correct\\n                         values for the n'th pool in `_route` and swap type should be 1 for a\\n                         stableswap `exchange`, 2 for stableswap `exchange_underlying`, 3 for a\\n                         cryptoswap `exchange`, 4 for a cryptoswap `exchange_underlying` and 5 for\\n                         Polygon factory metapools `exchange_underlying`\\n     * @param minAmountOut minimum amount received after the final swap\\n     */\\n    function rebalance(\\n        address[9] memory route,\\n        uint256[3][4] memory swapParams,\\n        uint256 minAmountOut\\n    ) external onlyOwner {\\n        // If the contract is shutdown, cellar shouldn't be able to rebalance assets it recently\\n        // pulled out back into a new strategy.\\n        if (isShutdown) revert ContractShutdown();\\n\\n        // Retrieve the last token in the route and store it as the new asset.\\n        address newAsset;\\n        for (uint256 i; ; i += 2) {\\n            if (i == 8 || route[i+1] == address(0)) {\\n                newAsset = route[i];\\n                break;\\n            }\\n        }\\n\\n        // Doesn't make sense to rebalance into the same asset.\\n        if (newAsset == address(asset)) revert SameAsset(newAsset);\\n\\n        // Accrue any final performance fees from the current strategy before rebalancing. Otherwise\\n        // those fees would be lost when we proceed to update fee data for the new strategy. Also we\\n        // don't want to update the fee data here because we will do that later on after we've\\n        // rebalanced into a new strategy.\\n        _accruePerformanceFees(false);\\n\\n        // Pull all active assets entered into Aave back into the cellar so we can swap everything\\n        // into the new asset.\\n        _withdrawFromAave(address(asset), type(uint256).max);\\n\\n        uint256 holdingPoolAssets = inactiveAssets();\\n\\n        // Approve Curve to swap the cellar's assets.\\n        asset.safeApprove(address(curveRegistryExchange), holdingPoolAssets);\\n\\n        // Perform stablecoin swap using Curve.\\n        uint256 amountOut = curveRegistryExchange.exchange_multiple(\\n            route,\\n            swapParams,\\n            holdingPoolAssets,\\n            minAmountOut\\n        );\\n\\n        // Store this later for the event we will emit.\\n        address oldAsset = address(asset);\\n\\n        // Updates state for our new strategy and check to make sure Aave supports it before\\n        // rebalancing.\\n        _updateStrategy(newAsset);\\n\\n        // Rebalance our assets into a new strategy.\\n        _depositToAave(newAsset, amountOut);\\n\\n        // Update fee data for next fee accrual with new strategy.\\n        lastActiveAssets = _activeAssets();\\n        lastNormalizedIncome = lendingPool.getReserveNormalizedIncome(address(asset));\\n\\n        emit Rebalance(oldAsset, newAsset, amountOut);\\n    }\\n\\n    /**\\n     * @notice Reinvest rewards back into cellar's current strategy.\\n     * @dev Must be called within 2 day unstake period 10 days after `claimAndUnstake` was run.\\n     * @param minAmountOut minimum amount of assets cellar should receive after swap\\n     */\\n    function reinvest(uint256 minAmountOut) public onlyOwner {\\n        // Redeems the cellar's stkAAVe rewards for AAVE.\\n        stkAAVE.redeem(address(this), type(uint256).max);\\n\\n        uint256 amountIn = AAVE.balanceOf(address(this));\\n\\n        // Approve the Sushiswap to swap AAVE.\\n        AAVE.safeApprove(address(sushiswapRouter), amountIn);\\n\\n        // Specify the swap path from AAVE -> WETH -> current asset.\\n        address[] memory path = new address[](3);\\n        path[0] = address(AAVE);\\n        path[1] = address(WETH);\\n        path[2] = address(asset);\\n\\n        // Perform a multihop swap using Sushiswap.\\n        uint256[] memory amounts = sushiswapRouter.swapExactTokensForTokens(\\n            amountIn,\\n            minAmountOut,\\n            path,\\n            address(this),\\n            block.timestamp + 60\\n        );\\n\\n        uint256 amountOut = amounts[amounts.length - 1];\\n\\n        // In the case of a shutdown, we just may want to redeem any leftover rewards for\\n        // shareholders to claim but without entering them back into a strategy.\\n        if (!isShutdown) {\\n            // Take performance fee off of rewards.\\n            uint256 performanceFeeInAssets = amountOut.mulDivDown(PERFORMANCE_FEE, DENOMINATOR);\\n            uint256 performanceFees = convertToShares(performanceFeeInAssets);\\n\\n            // Mint performance fees to cellar as shares.\\n            _mint(address(this), performanceFees);\\n\\n            accruedPerformanceFees += performanceFees;\\n\\n            // Reinvest rewards back into the current strategy.\\n            _depositToAave(address(asset), amountOut);\\n        }\\n    }\\n\\n    /**\\n     * @notice Claim rewards from Aave and begin cooldown period to unstake them.\\n     * @return claimed amount of rewards claimed from Aave\\n     */\\n    function claimAndUnstake() public onlyOwner returns (uint256 claimed) {\\n        // Necessary to do as `claimRewards` accepts a dynamic array as first param.\\n        address[] memory aToken = new address[](1);\\n        aToken[0] = address(assetAToken);\\n\\n        // Claim all stkAAVE rewards.\\n        claimed = incentivesController.claimRewards(aToken, type(uint256).max, address(this));\\n\\n        // Begin the cooldown period for unstaking stkAAVE to later redeem for AAVE.\\n        stkAAVE.cooldown();\\n    }\\n\\n    /**\\n     * @notice Sweep tokens sent here that are not managed by the cellar.\\n     * @dev This may be used in case the wrong tokens are accidentally sent to this contract.\\n     * @param token address of token to transfer out of this cellar\\n     */\\n    function sweep(address token) external onlyOwner {\\n        // Prevent sweeping of assets managed by the cellar and shares minted to the cellar as fees.\\n        if (token == address(asset) || token == address(assetAToken) || token == address(this))\\n            revert ProtectedAsset(token);\\n\\n        // Transfer out tokens in this cellar that shouldn't be here.\\n        uint256 amount = ERC20(token).balanceOf(address(this));\\n        ERC20(token).safeTransfer(msg.sender, amount);\\n\\n        emit Sweep(token, amount);\\n    }\\n\\n    /**\\n     * @notice Removes initial liquidity restriction.\\n     */\\n    function removeLiquidityRestriction() external onlyOwner {\\n        maxLiquidity = type(uint256).max;\\n\\n        emit LiquidityRestrictionRemoved();\\n    }\\n\\n    /**\\n     * @notice Pause the contract to prevent deposits.\\n     * @param _isPaused whether the contract should be paused or unpaused\\n     */\\n    function setPause(bool _isPaused) external onlyOwner {\\n        if (isShutdown) revert ContractShutdown();\\n\\n        isPaused = _isPaused;\\n\\n        emit Pause(_isPaused);\\n    }\\n\\n    /**\\n     * @notice Stops the contract - this is irreversible. Should only be used in an emergency,\\n     *         for example an irreversible accounting bug or an exploit.\\n     */\\n    function shutdown() external onlyOwner {\\n        if (isShutdown) revert AlreadyShutdown();\\n\\n        isShutdown = true;\\n\\n        // Ensure contract is not paused.\\n        isPaused = false;\\n\\n        // Withdraw everything from Aave. The check is necessary to prevent a revert happening if we\\n        // try to withdraw from Aave without any assets entered into a strategy which would prevent\\n        // the contract from being able to be shutdown in this case.\\n        if (activeAssets() > 0) _withdrawFromAave(address(asset), type(uint256).max);\\n\\n        emit Shutdown();\\n    }\\n\\n    // ========================================== HELPERS ==========================================\\n\\n    /**\\n     * @notice Update state variables related to the current strategy.\\n     * @param newAsset address of the new asset being managed by the cellar\\n     */\\n    function _updateStrategy(address newAsset) internal {\\n        // Retrieve the aToken that will represent the cellar's new strategy on Aave.\\n        (, , , , , , , address aTokenAddress, , , , ) = lendingPool.getReserveData(newAsset);\\n\\n        // If the address is not null, it is supported by Aave.\\n        if (aTokenAddress == address(0)) revert TokenIsNotSupportedByAave(newAsset);\\n\\n        // Update state related to the current strategy.\\n        asset = ERC20(newAsset);\\n        assetDecimals = ERC20(newAsset).decimals();\\n        assetAToken = ERC20(aTokenAddress);\\n\\n        // Update the decimals max liquidity is denoted in if restrictions are still in place.\\n        if (maxLiquidity != type(uint256).max) maxLiquidity = 5_000_000 * 10**assetDecimals;\\n    }\\n\\n    /**\\n     * @notice Ensures there is enough assets in the contract available for a transfer.\\n     * @dev Only withdraws from strategy if needed.\\n     * @param assets The amount of assets to allocate\\n     */\\n    function _allocateAssets(uint256 assets) internal {\\n        uint256 holdingPoolAssets = inactiveAssets();\\n\\n        if (assets > holdingPoolAssets) {\\n            _withdrawFromAave(address(asset), assets - holdingPoolAssets);\\n        }\\n    }\\n\\n    /**\\n     * @notice Deposits cellar holdings into an Aave lending pool.\\n     * @param token the address of the token\\n     * @param amount the amount of tokens to deposit\\n     */\\n    function _depositToAave(address token, uint256 amount) internal {\\n        ERC20(token).safeApprove(address(lendingPool), amount);\\n\\n        // Deposit tokens to Aave protocol.\\n        lendingPool.deposit(token, amount, address(this), 0);\\n\\n        emit DepositToAave(token, amount);\\n    }\\n\\n    /**\\n     * @notice Withdraws assets from Aave.\\n     * @param token the address of the token\\n     * @param amount the amount of tokens to withdraw\\n     * @return withdrawnAmount the withdrawn amount from Aave\\n     */\\n    function _withdrawFromAave(address token, uint256 amount) internal returns (uint256) {\\n        // Withdraw tokens from Aave protocol\\n        uint256 withdrawnAmount = lendingPool.withdraw(token, amount, address(this));\\n\\n        emit WithdrawFromAave(token, withdrawnAmount);\\n\\n        return withdrawnAmount;\\n    }\\n\\n    // ================================= SHARE TRANSFER OPERATIONS =================================\\n\\n    /**\\n     * @dev Modified versions of Solmate's ERC20 transfer and transferFrom functions to work with the\\n     *      cellar's active vs inactive shares mechanic.\\n     */\\n\\n    /**\\n     * @notice Transfers shares from one account to another.\\n     * @dev If the sender specifies to only transfer active shares and does not have enough active\\n     *      shares to transfer to meet the amount specified, the default behavior is to not to\\n     *      revert but transfer as many active shares as the sender has to the receiver.\\n     * @param from address that is sending shares\\n     * @param to address that is receiving shares\\n     * @param amount amount of shares to transfer\\n     * @param onlyActive whether to only transfer active shares\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bool onlyActive\\n    ) public returns (bool) {\\n        // If the sender is not the owner of the shares, check to see if the owner has approved them\\n        // to spend their shares.\\n        if (from != msg.sender) {\\n            uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n        }\\n\\n        // Retrieve the deposits from sender then begin looping through deposits, generally from\\n        // oldest to newest deposits. This may not be the case though if shares have been\\n        // transferred to the sender, as they will be added to the end of the sender's deposits\\n        // regardless of time deposited.\\n        UserDeposit[] storage depositsFrom = userDeposits[from];\\n\\n        // Tracks the amount of shares left to transfer; updated at the end of each loop.\\n        uint256 leftToTransfer = amount;\\n\\n        for (uint256 i = currentDepositIndex[from]; i < depositsFrom.length; i++) {\\n            UserDeposit storage dFrom = depositsFrom[i];\\n\\n            // If we only want to transfer active shares, skips this deposit if it is inactive.\\n            bool isActive = dFrom.timeDeposited <= lastTimeEnteredStrategy;\\n            if (onlyActive && !isActive) continue;\\n\\n            // Saves an extra SLOAD if active and cast type to uint256.\\n            uint256 dFromShares = dFrom.shares;\\n\\n            // Determine the amount of assets and shares to transfer from this deposit.\\n            uint256 transferredShares = MathUtils.min(leftToTransfer, dFromShares);\\n            uint256 transferredAssets = uint256(dFrom.assets).mulDivUp(transferredShares, dFromShares);\\n\\n            // For active shares, deletes the deposit data we don't need anymore for a gas refund.\\n            if (isActive) {\\n                delete dFrom.assets;\\n                delete dFrom.timeDeposited;\\n            } else {\\n                dFrom.assets -= uint112(transferredAssets);\\n            }\\n\\n            // Taken shares from this deposit to transfer.\\n            dFrom.shares -= uint112(transferredShares);\\n\\n            // Transfer a new deposit to the end of receiver's list of deposits.\\n            userDeposits[to].push(UserDeposit({\\n                assets: isActive ? 0 : uint112(transferredAssets),\\n                shares: uint112(transferredShares),\\n                timeDeposited: isActive ? 0 : dFrom.timeDeposited\\n            }));\\n\\n            // Update the counter of assets left to transfer.\\n            leftToTransfer -= transferredShares;\\n\\n            if (i == depositsFrom.length - 1 || leftToTransfer == 0) {\\n                // Only store the index for the next non-zero deposit to save gas on looping if\\n                // inactive deposits weren't skipped.\\n                if (!onlyActive) currentDepositIndex[from] = dFrom.shares != 0 ? i : i+1;\\n                break;\\n            }\\n        }\\n\\n        // Determine the total amount of shares transferred.\\n        amount -= leftToTransfer;\\n\\n        // Will revert here if sender is trying to transfer more shares then they have, so no need\\n        // for an explicit check.\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /// @dev For compatibility with ERC20 standard.\\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\\n        // Defaults to only transferring active shares.\\n        return transferFrom(from, to, amount, true);\\n    }\\n\\n    function transfer(address to, uint256 amount) public override returns (bool) {\\n        // Defaults to only transferring active shares.\\n        return transferFrom(msg.sender, to, amount, true);\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveV2StablecoinCellar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.11;\\n\\n/// @title interface for AaveV2StablecoinCellar\\ninterface IAaveV2StablecoinCellar {\\n    // ======================================= EVENTS =======================================\\n\\n    /**\\n     * @notice Emitted when assets are deposited into cellar.\\n     * @param caller the address of the caller\\n     * @param token the address of token the cellar receives\\n     * @param owner the address of the owner of shares\\n     * @param assets the amount of assets being deposited\\n     * @param shares the amount of shares minted to owner\\n     */\\n    event Deposit(\\n        address indexed caller,\\n        address indexed owner,\\n        address indexed token,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @notice Emitted when assets are withdrawn from cellar.\\n     * @param receiver the address of the receiver of the withdrawn assets\\n     * @param owner the address of the owner of the shares\\n     * @param token the address of the token withdrawn\\n     * @param assets the amount of assets being withdrawn\\n     * @param shares the amount of shares burned from owner\\n     */\\n    event Withdraw(\\n        address indexed receiver,\\n        address indexed owner,\\n        address indexed token,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @notice Emitted on deposit to Aave.\\n     * @param token the address of the token\\n     * @param amount the amount of tokens to deposit\\n     */\\n    event DepositToAave(\\n        address indexed token,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @notice Emitted on withdraw from Aave.\\n     * @param token the address of the token\\n     * @param amount the amount of tokens to withdraw\\n     */\\n    event WithdrawFromAave(\\n        address indexed token,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @notice Emitted on rebalance of Aave strategy.\\n     * @param oldAsset the address of the asset for the old strategy\\n     * @param newAsset the address of the asset for the new strategy\\n     * @param assets the amount of the new assets that has been deposited to Aave after rebalance\\n     */\\n    event Rebalance(\\n        address indexed oldAsset,\\n        address indexed newAsset,\\n        uint256 assets\\n    );\\n\\n    /**\\n     * @notice Emitted when platform fees accrued.\\n     * @param fees amount of fees accrued in shares\\n     */\\n    event AccruedPlatformFees(uint256 fees);\\n\\n    /**\\n     * @notice Emitted when performance fees accrued.\\n     * @param fees amount of fees accrued in shares\\n     */\\n    event AccruedPerformanceFees(uint256 fees);\\n\\n    /**\\n     * @notice Emitted when performance fees burnt as insurance.\\n     * @param fees amount of fees burnt in shares\\n     */\\n    event BurntPerformanceFees(uint256 fees);\\n\\n    /**\\n     * @notice Emitted when platform fees are transferred to Cosmos.\\n     * @param platformFees amount of platform fees transferred\\n     * @param performanceFees amount of performance fees transferred\\n     */\\n    event TransferFees(uint256 platformFees, uint256 performanceFees);\\n\\n    /**\\n     * @notice Emitted when liquidity restriction removed.\\n     */\\n    event LiquidityRestrictionRemoved();\\n\\n    /**\\n     * @notice Emitted when tokens accidentally sent to cellar are recovered.\\n     * @param token the address of the token\\n     * @param amount amount transferred out\\n     */\\n    event Sweep(address indexed token, uint256 amount);\\n\\n    /**\\n     * @notice Emitted when cellar is paused.\\n     * @param isPaused whether the contract is paused\\n     */\\n    event Pause(bool isPaused);\\n\\n    /**\\n     * @notice Emitted when cellar is shutdown.\\n     */\\n    event Shutdown();\\n\\n    // ======================================= ERRORS =======================================\\n\\n    /**\\n     * @notice Attempted an action with zero assets.\\n     */\\n    error ZeroAssets();\\n\\n    /**\\n     * @notice Attempted an action with zero shares.\\n     */\\n    error ZeroShares();\\n\\n    /**\\n     * @notice Attempted deposit more liquidity over the liquidity limit.\\n     * @param maxLiquidity the max liquidity\\n     */\\n    error LiquidityRestricted(uint256 maxLiquidity);\\n\\n    /**\\n     * @notice Attempted deposit more than the per wallet limit.\\n     * @param maxDeposit the max deposit\\n     */\\n    error DepositRestricted(uint256 maxDeposit);\\n\\n    /**\\n     * @notice Current asset is updated to an asset not supported by Aave.\\n     * @param unsupportedToken address of the unsupported token\\n     */\\n    error TokenIsNotSupportedByAave(address unsupportedToken);\\n\\n    /**\\n     * @notice Attempted to sweep an asset that is managed by the cellar.\\n     * @param token address of the token that can't be sweeped\\n     */\\n    error ProtectedAsset(address token);\\n\\n    /**\\n     * @notice Attempted rebalance into the same asset.\\n     * @param asset address of the asset\\n     */\\n    error SameAsset(address asset);\\n\\n    /**\\n     * @notice Attempted action was prevented due to contract being shutdown.\\n     */\\n    error ContractShutdown();\\n\\n    /**\\n     * @notice Attempted action was prevented due to contract being paused.\\n     */\\n    error ContractPaused();\\n\\n    /**\\n     * @notice Attempted to shutdown the contract when it was already shutdown.\\n     */\\n    error AlreadyShutdown();\\n\\n    // ======================================= STRUCTS =======================================\\n\\n    /**\\n     * @notice Stores user deposit data.\\n     * @param assets amount of assets deposited\\n     * @param shares amount of shares that were minted for their deposit\\n     * @param timeDeposited timestamp of when the user deposited\\n     */\\n    struct UserDeposit {\\n        uint112 assets;\\n        uint112 shares;\\n        uint32 timeDeposited;\\n    }\\n\\n    // ================================= DEPOSIT/WITHDRAWAL OPERATIONS =================================\\n\\n    function deposit(uint256 assets, address receiver) external returns (uint256);\\n\\n    function mint(uint256 shares, address receiver) external returns (uint256);\\n\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 shares);\\n\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 assets);\\n\\n    // ==================================== ACCOUNTING OPERATIONS ====================================\\n\\n    function activeAssets() external view returns (uint256);\\n\\n    function inactiveAssets() external view returns (uint256);\\n\\n    function totalAssets() external view returns (uint256);\\n\\n    function convertToShares(uint256 assets) external view returns (uint256);\\n\\n    function convertToAssets(uint256 shares) external view returns (uint256);\\n\\n    function previewDeposit(uint256 assets) external view returns (uint256);\\n\\n    function previewMint(uint256 shares) external view returns (uint256);\\n\\n    function previewWithdraw(uint256 assets) external view returns (uint256);\\n\\n    function previewRedeem(uint256 shares) external view returns (uint256);\\n\\n    // ======================================= STATE INFORMATION =====================================\\n\\n    function depositBalances(address user) external view returns (\\n        uint256 userActiveShares,\\n        uint256 userInactiveShares,\\n        uint256 userActiveAssets,\\n        uint256 userInactiveAssets\\n    );\\n\\n    function numDeposits(address user) external view returns (uint256);\\n\\n    // ============================ DEPOSIT/WITHDRAWAL LIMIT OPERATIONS ============================\\n\\n    function maxDeposit(address owner) external view returns (uint256);\\n\\n    function maxMint(address owner) external view returns (uint256);\\n\\n    function maxWithdraw(address owner) external view returns (uint256);\\n\\n    function maxRedeem(address owner) external view returns (uint256);\\n\\n    // ======================================= FEE OPERATIONS =======================================\\n\\n    function accrueFees() external;\\n\\n    function transferFees() external;\\n\\n    // ======================================= ADMIN OPERATIONS =======================================\\n\\n    function enterStrategy() external;\\n\\n    function rebalance(\\n        address[9] memory route,\\n        uint256[3][4] memory swapParams,\\n        uint256 minAmountOut\\n    ) external;\\n\\n    function reinvest(uint256 minAmountOut) external;\\n\\n    function claimAndUnstake() external returns (uint256 claimed);\\n\\n    function sweep(address token) external;\\n\\n    function removeLiquidityRestriction() external;\\n\\n    function setPause(bool _isPaused) external;\\n\\n    function shutdown() external;\\n\\n    // ================================== SHARE TRANSFER OPERATIONS ==================================\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bool onlyActive\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveIncentivesController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.11;\\n\\ninterface IAaveIncentivesController {\\n  event RewardsAccrued(address indexed user, uint256 amount);\\n\\n  event RewardsClaimed(\\n    address indexed user,\\n    address indexed to,\\n    address indexed claimer,\\n    uint256 amount\\n  );\\n\\n  event ClaimerSet(address indexed user, address indexed claimer);\\n\\n  /*\\n   * @dev Returns the configuration of the distribution for a certain asset\\n   * @param asset The address of the reference asset of the distribution\\n   * @return The asset index, the emission per second and the last updated timestamp\\n   **/\\n  function getAssetData(address asset)\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    );\\n\\n  /*\\n   * LEGACY **************************\\n   * @dev Returns the configuration of the distribution for a certain asset\\n   * @param asset The address of the reference asset of the distribution\\n   * @return The asset index, the emission per second and the last updated timestamp\\n   **/\\n  function assets(address asset)\\n    external\\n    view\\n    returns (\\n      uint128,\\n      uint128,\\n      uint256\\n    );\\n\\n  /**\\n   * @dev Whitelists an address to claim the rewards on behalf of another address\\n   * @param user The address of the user\\n   * @param claimer The address of the claimer\\n   */\\n  function setClaimer(address user, address claimer) external;\\n\\n  /**\\n   * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\\n   * @param user The address of the user\\n   * @return The claimer address\\n   */\\n  function getClaimer(address user) external view returns (address);\\n\\n  /**\\n   * @dev Configure assets for a certain rewards emission\\n   * @param assets The assets to incentivize\\n   * @param emissionsPerSecond The emission for each asset\\n   */\\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\\n    external;\\n\\n  /**\\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\\n   * @param asset The address of the user\\n   * @param userBalance The balance of the user of the asset in the lending pool\\n   * @param totalSupply The total supply of the asset in the lending pool\\n   **/\\n  function handleAction(\\n    address asset,\\n    uint256 userBalance,\\n    uint256 totalSupply\\n  ) external;\\n\\n  /**\\n   * @dev Returns the total of rewards of an user, already accrued + not yet accrued\\n   * @param user The address of the user\\n   * @return The rewards\\n   **/\\n  function getRewardsBalance(address[] calldata assets, address user)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\\n   * @param amount Amount of rewards to claim\\n   * @param to Address that will be receiving the rewards\\n   * @return Rewards claimed\\n   **/\\n  function claimRewards(\\n    address[] calldata assets,\\n    uint256 amount,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\\n   * be whitelisted via \\\"allowClaimOnBehalf\\\" function by the RewardsAdmin role manager\\n   * @param amount Amount of rewards to claim\\n   * @param user Address to check and claim rewards\\n   * @param to Address that will be receiving the rewards\\n   * @return Rewards claimed\\n   **/\\n  function claimRewardsOnBehalf(\\n    address[] calldata assets,\\n    uint256 amount,\\n    address user,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev returns the unclaimed rewards of the user\\n   * @param user the address of the user\\n   * @return the unclaimed user rewards\\n   */\\n  function getUserUnclaimedRewards(address user) external view returns (uint256);\\n\\n  /**\\n   * @dev returns the unclaimed rewards of the user\\n   * @param user the address of the user\\n   * @param asset The asset to incentivize\\n   * @return the user index for the asset\\n   */\\n  function getUserAssetData(address user, address asset) external view returns (uint256);\\n\\n  /**\\n   * @dev for backward compatibility with previous implementation of the Incentives controller\\n   */\\n  function REWARD_TOKEN() external view returns (address);\\n\\n  /**\\n   * @dev for backward compatibility with previous implementation of the Incentives controller\\n   */\\n  function PRECISION() external view returns (uint8);\\n\\n  /**\\n   * @dev Gets the distribution end timestamp of the emissions\\n   */\\n  function DISTRIBUTION_END() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakedTokenV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.11;\\n\\ninterface IStakedTokenV2 {\\n  function stake(address to, uint256 amount) external;\\n\\n  function redeem(address to, uint256 amount) external;\\n\\n  function cooldown() external;\\n\\n  function claimRewards(address to, uint256 amount) external;\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function stakersCooldowns(address account) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICurveSwaps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.11;\\n\\ninterface ICurveSwaps {\\n    function exchange_multiple(\\n        address[9] memory _route,\\n        uint256[3][4] memory _swap_params,\\n        uint256 _amount,\\n        uint256 _expected\\n    ) external returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISushiSwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.11;\\n\\n/**\\n * @notice Partial interface for a SushiSwap Router contract\\n **/\\ninterface ISushiSwapRouter {\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGravity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.11;\\n\\ninterface IGravity {\\n    function sendToCosmos(address _tokenContract, bytes32 _destination, uint256 _amount) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/ILendingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.11;\\n\\n/**\\n * @dev Partial interface for a Aave LendingPool contract,\\n * which is the main point of interaction with an Aave protocol's market\\n **/\\ninterface ILendingPool {\\n    /**\\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\n     * @param asset The address of the underlying asset to deposit\\n     * @param amount The amount to be deposited\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n     *   is a different wallet\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     **/\\n    function deposit(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n     * @param asset The address of the underlying asset to withdraw\\n     * @param amount The underlying amount to be withdrawn\\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n     * @param to Address that will receive the underlying, same as msg.sender if the user\\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n     *   different wallet\\n     * @return The final amount withdrawn\\n     **/\\n    function withdraw(\\n        address asset,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Returns the normalized income normalized income of the reserve\\n     * @param asset The address of the underlying asset of the reserve\\n     * @return The reserve's normalized income\\n     */\\n    function getReserveNormalizedIncome(address asset) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the normalized income normalized income of the reserve\\n     * @param asset The address of the underlying asset of the reserve\\n     **/\\n    function getReserveData(address asset)\\n        external\\n        view\\n        returns (\\n            //stores the reserve configuration\\n            //bit 0-15: LTV\\n            //bit 16-31: Liq. threshold\\n            //bit 32-47: Liq. bonus\\n            //bit 48-55: Decimals\\n            //bit 56: Reserve is active\\n            //bit 57: reserve is frozen\\n            //bit 58: borrowing is enabled\\n            //bit 59: stable rate borrowing enabled\\n            //bit 60-63: reserved\\n            //bit 64-79: reserve factor\\n            uint256 configuration,\\n            //the liquidity index. Expressed in ray\\n            uint128 liquidityIndex,\\n            //variable borrow index. Expressed in ray\\n            uint128 variableBorrowIndex,\\n            //the current supply rate. Expressed in ray\\n            uint128 currentLiquidityRate,\\n            //the current variable borrow rate. Expressed in ray\\n            uint128 currentVariableBorrowRate,\\n            //the current stable borrow rate. Expressed in ray\\n            uint128 currentStableBorrowRate,\\n            uint40 lastUpdateTimestamp,\\n            //tokens addresses\\n            address aTokenAddress,\\n            address stableDebtTokenAddress,\\n            address variableDebtTokenAddress,\\n            //address of the interest rate strategy\\n            address interestRateStrategyAddress,\\n            //the id of the reserve. Represents the position in the list of the active reserves\\n            uint8 id\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/utils/MathUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.11;\\n\\nlibrary MathUtils {\\n    /**\\n     * @notice Used to change the decimals of precision used for an amount.\\n     */\\n    function changeDecimals(\\n        uint256 amount,\\n        uint8 fromDecimals,\\n        uint8 toDecimals\\n    ) internal pure returns (uint256) {\\n        if (fromDecimals == toDecimals) {\\n            return amount;\\n        } else if (fromDecimals < toDecimals) {\\n            return amount * 10**(toDecimals - fromDecimals);\\n        } else {\\n            return ceilDiv(amount, 10**(fromDecimals - toDecimals));\\n        }\\n    }\\n\\n    // ===================================== OPENZEPPELIN'S MATH =====================================\\n\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    // ================================= SOLMATE's FIXEDPOINTMATHLIB =================================\\n\\n    uint256 public constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100,\r\n      \"details\": {\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"contract ICurveSwaps\",\"name\":\"_curveRegistryExchange\",\"type\":\"address\"},{\"internalType\":\"contract ISushiSwapRouter\",\"name\":\"_sushiswapRouter\",\"type\":\"address\"},{\"internalType\":\"contract ILendingPool\",\"name\":\"_lendingPool\",\"type\":\"address\"},{\"internalType\":\"contract IAaveIncentivesController\",\"name\":\"_incentivesController\",\"type\":\"address\"},{\"internalType\":\"contract IGravity\",\"name\":\"_gravityBridge\",\"type\":\"address\"},{\"internalType\":\"contract IStakedTokenV2\",\"name\":\"_stkAAVE\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"_AAVE\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"_WETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyShutdown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractShutdown\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"}],\"name\":\"DepositRestricted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxLiquidity\",\"type\":\"uint256\"}],\"name\":\"LiquidityRestricted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"ProtectedAsset\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"SameAsset\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"unsupportedToken\",\"type\":\"address\"}],\"name\":\"TokenIsNotSupportedByAave\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAssets\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroShares\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"AccruedPerformanceFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"AccruedPlatformFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"BurntPerformanceFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositToAave\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LiquidityRestrictionRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAsset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"Rebalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Shutdown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Sweep\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"platformFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"performanceFees\",\"type\":\"uint256\"}],\"name\":\"TransferFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFromAave\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AAVE\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERFORMANCE_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PLATFORM_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accrueFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accruedPerformanceFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accruedPlatformFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetAToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"assetDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAndUnstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"convertToAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"convertToShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"currentDepositIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveRegistryExchange\",\"outputs\":[{\"internalType\":\"contract ICurveSwaps\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"depositBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userActiveShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userInactiveShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userActiveAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userInactiveAssets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enterStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesDistributor\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gravityBridge\",\"outputs\":[{\"internalType\":\"contract IGravity\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inactiveAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incentivesController\",\"outputs\":[{\"internalType\":\"contract IAaveIncentivesController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isShutdown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastActiveAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastNormalizedIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeAccruedPlatformFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeEnteredStrategy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingPool\",\"outputs\":[{\"internalType\":\"contract ILendingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"numDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[9]\",\"name\":\"route\",\"type\":\"address[9]\"},{\"internalType\":\"uint256[3][4]\",\"name\":\"swapParams\",\"type\":\"uint256[3][4]\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"rebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLiquidityRestriction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isPaused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shutdown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stkAAVE\",\"outputs\":[{\"internalType\":\"contract IStakedTokenV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiswapRouter\",\"outputs\":[{\"internalType\":\"contract ISushiSwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"onlyActive\",\"type\":\"bool\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userDeposits\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"assets\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"shares\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"timeDeposited\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AaveV2StablecoinCellar", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000008e764be4288b842791989db5b8ec067279829809000000000000000000000000d9e1ce17f2641f24ae83637ab66a2cca9c378b9f0000000000000000000000007d2768de32b0b80b7a3454c06bdac94a69ddc7a9000000000000000000000000d784927ff2f95ba542bfc824c8a8a98f3495f6b500000000000000000000000069592e6f9d21989a043646fe8225da2600e5a0f70000000000000000000000004da27a545c0c5b758a6ba100e3a049001de870f50000000000000000000000007fc66500c84a76ad7e9c93437bfc5ac33e2ddae9000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}