{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\n/* ----------------------------------------- Imports ------------------------------------------ */\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/* -------------------------------------- Main Contract --------------------------------------- */\r\n\r\ncontract Skyvault_0 is Ownable {\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    /* ------------------------------------ State Variables ----------------------------------- */\r\n\r\n    IERC20 public immutable skywardToken;\r\n    address public immutable skyRewards;\r\n    bool public poolOpened;\r\n    uint256 public poolOpenedTime;\r\n    uint256 public poolClosedTime;\r\n    uint256 public totalStaked;\r\n\r\n    struct staker {\r\n        uint256 owedRewards;\r\n        uint256 stakerBalance;\r\n        uint256 stakeTime;\r\n    }\r\n\r\n    mapping (address => staker) public stakers;\r\n\r\n    event RewardsCompounded(address staker, uint256 amount);\r\n    event RewardsClaimed(address staker, uint256 amount);\r\n    event Staked(address staker, uint256 amount);\r\n    event Unstaked(address staker, uint256 amount);\r\n\r\n    /* --------------------------------- Contract Constructor --------------------------------- */\r\n\r\n    constructor(address _skywardToken, address _skyRewards) {\r\n        skywardToken = IERC20(_skywardToken); \r\n        skyRewards = _skyRewards;\r\n        transferOwnership(msg.sender);\r\n    }\r\n\r\n    /* ------------------------------- Main Contract Functions -------------------------------- */\r\n\r\n    // Claim pending rewards (manual implementation)\r\n    function claimManual() external {\r\n        require(stakers[msg.sender].stakerBalance > 0 || stakers[msg.sender].owedRewards > 0, \"Not a staker\");\r\n        uint256 rewards = getPendingRewards();\r\n        require(rewards > 0, \"No rewards to claim\");\r\n        require(rewards <= skywardToken.balanceOf(skyRewards), \"Insufficient rewards in rewards pool\");\r\n\r\n        skywardToken.safeTransferFrom(skyRewards, msg.sender, rewards);\r\n        if (stakers[msg.sender].owedRewards > 0) {\r\n            stakers[msg.sender].owedRewards = 0;\r\n        }\r\n        \r\n        if (poolOpened) {\r\n            stakers[msg.sender].stakeTime = block.timestamp;\r\n        } else {\r\n            stakers[msg.sender].stakeTime = poolClosedTime;\r\n        }\r\n\r\n        emit RewardsClaimed(msg.sender, rewards);\r\n    }\r\n\r\n    // Compound pending rewards\r\n    function compound() external {\r\n        require(poolOpened, \"Staking pool not open\");\r\n        require(stakers[msg.sender].stakerBalance > 0, \"Not a staker\");\r\n        uint256 rewards = getPendingRewards();\r\n        require(rewards > 0, \"No rewards to compound\");\r\n        require(rewards <= skywardToken.balanceOf(skyRewards), \"Insufficient rewards in rewards pool\");\r\n\r\n        totalStaked += rewards;\r\n        stakers[msg.sender].stakerBalance += rewards;\r\n        stakers[msg.sender].stakeTime = block.timestamp;\r\n        if (stakers[msg.sender].owedRewards > 0) {\r\n            stakers[msg.sender].owedRewards = 0;\r\n        }\r\n\r\n        skywardToken.safeTransferFrom(skyRewards, address(this), rewards);\r\n        emit RewardsCompounded(msg.sender, rewards);\r\n    }\r\n\r\n    // Stake the specified amount of tokens\r\n    function stake(uint256 _amount) external {\r\n        require(poolOpened, \"Staking pool not open\");\r\n        require(skywardToken.balanceOf(msg.sender) > 0, \"No wallet balance to stake\");\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n        require(_amount <= skywardToken.balanceOf(msg.sender), \"Amount greater than wallet balance\");\r\n\r\n        uint256 rewards = getPendingRewards();\r\n        claim(rewards);\r\n\r\n        totalStaked += _amount;\r\n        stakers[msg.sender].stakerBalance += _amount;\r\n        stakers[msg.sender].stakeTime = block.timestamp;\r\n\r\n        skywardToken.safeTransferFrom(msg.sender, address(this), _amount);\r\n        emit Staked(msg.sender, _amount);\r\n    }\r\n\r\n    // Unstake the specified amount of tokens\r\n    function unstake(uint256 _amount) external {\r\n        require(_amount > 0, \"Amount must be greater than 0\");\r\n        require(stakers[msg.sender].stakerBalance >= _amount, \"Amount must be less than or equal to staked balance\");\r\n\r\n        uint256 rewards = getPendingRewards();\r\n        claim(rewards);\r\n        \r\n        totalStaked -= _amount;\r\n        stakers[msg.sender].stakerBalance -= _amount;\r\n        if (poolOpened) {\r\n            stakers[msg.sender].stakeTime = block.timestamp;\r\n        } else {\r\n            stakers[msg.sender].stakeTime = poolClosedTime;\r\n        }\r\n\r\n        uint256 fees = _amount * 5 / 100;\r\n        _amount -= fees;\r\n\r\n        skywardToken.safeTransfer(skyRewards, fees);\r\n        skywardToken.safeTransfer(msg.sender, _amount);\r\n        emit Unstaked(msg.sender, _amount);\r\n    }\r\n\r\n    /* ----------------------------------- Owner Functions ------------------------------------ */\r\n\r\n    // Open the staking pool\r\n    function openPool() external onlyOwner {\r\n        require(poolOpenedTime == 0, \"Staking pool already opened\");\r\n        poolOpened = true;\r\n        poolOpenedTime = block.timestamp;\r\n    }\r\n\r\n    // Close the staking pool\r\n    function closePool() external onlyOwner {\r\n        require(poolOpened, \"Staking pool not open\");\r\n        poolOpened = false;\r\n        poolClosedTime = block.timestamp;\r\n    }\r\n\r\n    /* ------------------------------- Private Helper Functions ------------------------------- */\r\n\r\n    // Claim pending rewards\r\n    function claim(uint256 rewards) private {\r\n        if (rewards > 0) {\r\n            if (rewards > skywardToken.balanceOf(skyRewards)) {\r\n                stakers[msg.sender].owedRewards += rewards - stakers[msg.sender].owedRewards;\r\n            } else {\r\n                skywardToken.safeTransferFrom(skyRewards, msg.sender, rewards);\r\n                if (stakers[msg.sender].owedRewards > 0) {\r\n                    stakers[msg.sender].owedRewards = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /* -------------------------------- Public View Functions --------------------------------- */\r\n\r\n    // Get pending rewards\r\n    function getPendingRewards() public view returns (uint256) { \r\n        if (poolOpened) {\r\n            return (block.timestamp - stakers[msg.sender].stakeTime) * (getStakerRewardRate() / 86400) + stakers[msg.sender].owedRewards;\r\n        } else {\r\n            return (poolClosedTime - stakers[msg.sender].stakeTime) * (getStakerRewardRate() / 86400) + stakers[msg.sender].owedRewards;\r\n        }\r\n    }\r\n\r\n    // Get staked balance\r\n    function getStakerBalance() public view returns (uint256) {\r\n        return stakers[msg.sender].stakerBalance;\r\n    }\r\n\r\n    // Get daily reward yield rate\r\n    function getStakerRewardRate() public view returns (uint256) { \r\n        return stakers[msg.sender].stakerBalance / 100;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_skywardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_skyRewards\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsCompounded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimManual\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakerBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakerRewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolClosedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolOpened\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolOpenedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"skyRewards\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"skywardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"owedRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakerBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Skyvault_0", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000083e06d480d38c7c0cc60b2ae775c2bf9c23e459d00000000000000000000000037ce97aacb7e68a595f3f85c36b55e7034a5731a", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://084d40b0200342cd26ef6c89c6179fc344ef7659d6f7a71273d197abbf00349b"}]}