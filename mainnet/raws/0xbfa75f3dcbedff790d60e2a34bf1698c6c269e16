{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.12;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n} /// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max)\n            allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            PERMIT_TYPEHASH,\n                            owner,\n                            spender,\n                            value,\n                            nonces[owner]++,\n                            deadline\n                        )\n                    )\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n\n            require(\n                recoveredAddress != address(0) && recoveredAddress == owner,\n                \"INVALID_SIGNER\"\n            );\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return\n            block.chainid == INITIAL_CHAIN_ID\n                ? INITIAL_DOMAIN_SEPARATOR\n                : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n} // OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n} /// @title Interface for verifying contract-based account signatures\n\n/// @notice Interface that verifies provided signature for the data\n/// @dev Interface defined by EIP-1271\ninterface IERC1271 {\n    /// @notice Returns whether the provided signature is valid for the provided data\n    /// @dev MUST return the bytes4 magic value 0x1626ba7e when function passes.\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5).\n    /// MUST allow external calls.\n    /// @param hash Hash of the data to be signed\n    /// @param signature Signature byte array associated with _data\n    /// @return magicValue The bytes4 magic value 0x1626ba7e\n    function isValidSignature(bytes32 hash, bytes memory signature)\n        external\n        view\n        returns (bytes4 magicValue);\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nlibrary Signature {\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(\n            uint256(s) <=\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n            \"ODYSSEY: INVALID_SIGNATURE_S_VALUE\"\n        );\n        require(v == 27 || v == 28, \"ODYSSEY: INVALID_SIGNATURE_V_VALUE\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ODYSSEY: INVALID_SIGNATURE\");\n\n        return signer;\n    }\n\n    function verify(\n        bytes32 hash,\n        address signer,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bytes32 domainSeparator\n    ) internal view {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, hash)\n        );\n        if (Address.isContract(signer)) {\n            require(\n                IERC1271(signer).isValidSignature(\n                    digest,\n                    abi.encodePacked(r, s, v)\n                ) == 0x1626ba7e,\n                \"ODYSSEY: UNAUTHORIZED\"\n            );\n        } else {\n            require(\n                recover(digest, v, r, s) == signer,\n                \"ODYSSEY: UNAUTHORIZED\"\n            );\n        }\n    }\n} // OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b)\n        private\n        pure\n        returns (bytes32 value)\n    {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n\nlibrary MerkleWhiteList {\n    function verify(\n        address sender,\n        bytes32[] calldata merkleProof,\n        bytes32 merkleRoot\n    ) internal pure {\n        // Verify whitelist\n        require(address(0) != sender);\n        bytes32 leaf = keccak256(abi.encodePacked(sender));\n        require(\n            MerkleProof.verify(merkleProof, merkleRoot, leaf),\n            \"Not whitelisted\"\n        );\n    }\n} /// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed id\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 indexed id\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(uint256 => address) public ownerOf;\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = ownerOf[id];\n\n        require(\n            msg.sender == owner || isApprovedForAll[owner][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from ||\n                msg.sender == getApproved[id] ||\n                isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    id,\n                    \"\"\n                ) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    id,\n                    data\n                ) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        virtual\n        returns (bool)\n    {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = ownerOf[id];\n\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            balanceOf[owner]--;\n        }\n\n        delete ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(\n                    msg.sender,\n                    address(0),\n                    id,\n                    \"\"\n                ) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(\n                    msg.sender,\n                    address(0),\n                    id,\n                    data\n                ) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\nlibrary UInt2Str {\n    function uint2str(uint256 _i)\n        internal\n        pure\n        returns (string memory _uintAsString)\n    {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n\ncontract OdysseyERC721 is ERC721(\"\", \"\") {\n    using UInt2Str for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                            CUSTOM ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error OdysseyERC721_AlreadyInit();\n    error OdysseyERC721_Unauthorized();\n    error OdysseyERC721_BadAddress();\n\n    /*///////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n    address launcher;\n    address public owner;\n    bool initialized;\n    string public baseURI;\n    uint256 public royaltyFeeInBips; // 1% = 100\n    address public royaltyReceiver;\n    string public contractURI;\n\n    /*///////////////////////////////////////////////////////////////\n                              METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function tokenURI(uint256 id)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        return string(abi.encodePacked(baseURI, id.uint2str()));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              FACTORY LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function initialize(\n        address _launcher,\n        address _owner,\n        string calldata _name,\n        string calldata _symbol,\n        string calldata _baseURI\n    ) external {\n        if (initialized) {\n            revert OdysseyERC721_AlreadyInit();\n        }\n        initialized = true;\n        launcher = _launcher;\n        owner = _owner;\n        name = _name;\n        symbol = _symbol;\n        baseURI = _baseURI;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual {\n        if (newOwner == address(0)) {\n            revert OdysseyERC721_BadAddress();\n        }\n        if (msg.sender != owner) {\n            revert OdysseyERC721_Unauthorized();\n        }\n        owner = newOwner;\n    }\n\n    function mint(address user, uint256 id) external {\n        if (msg.sender != launcher) {\n            revert OdysseyERC721_Unauthorized();\n        }\n        _mint(user, id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP2981 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function royaltyInfo(uint256, uint256 _salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        return (royaltyReceiver, (_salePrice / 10000) * royaltyFeeInBips);\n    }\n\n    function setRoyaltyInfo(address _royaltyReceiver, uint256 _royaltyFeeInBips)\n        external\n    {\n        if (_royaltyReceiver == address(0)) {\n            revert OdysseyERC721_BadAddress();\n        }\n        if (msg.sender != owner) {\n            revert OdysseyERC721_Unauthorized();\n        }\n        royaltyReceiver = _royaltyReceiver;\n        royaltyFeeInBips = _royaltyFeeInBips;\n    }\n\n    function setContractURI(string memory _uri) public {\n        if (msg.sender != owner) {\n            revert OdysseyERC721_Unauthorized();\n        }\n        contractURI = _uri;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceID)\n        public\n        pure\n        override(ERC721)\n        returns (bool)\n    {\n        return\n            bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == interfaceID ||\n            super.supportsInterface(interfaceID);\n    }\n} /// @notice Minimalist and gas efficient standard ERC1155 implementation.\n\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*///////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    event URI(string value, uint256 indexed id);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                             ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(\n                    msg.sender,\n                    from,\n                    id,\n                    amount,\n                    data\n                ) == ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        for (uint256 i = 0; i < idsLength; ) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender,\n                    from,\n                    ids,\n                    amounts,\n                    data\n                ) == ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        uint256 ownersLength = owners.length; // Saves MLOADs.\n\n        require(ownersLength == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < ownersLength; i++) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        virtual\n        returns (bool)\n    {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(\n                    msg.sender,\n                    address(0),\n                    id,\n                    amount,\n                    data\n                ) == ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(\n                    msg.sender,\n                    address(0),\n                    ids,\n                    amounts,\n                    data\n                ) == ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                i++;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\ninterface ERC1155TokenReceiver {\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ncontract OdysseyERC1155 is ERC1155 {\n    using UInt2Str for uint256;\n\n    /*///////////////////////////////////////////////////////////////\n                            CUSTOM ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error OdysseyERC1155_AlreadyInit();\n    error OdysseyERC1155_Unauthorized();\n    error OdysseyERC1155_BadAddress();\n\n    /*///////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n    address launcher;\n    address public owner;\n    string public name;\n    string public symbol;\n    string public baseURI;\n    bool initialized;\n    uint256 public royaltyFeeInBips; // 1% = 100\n    address public royaltyReceiver;\n    string public contractURI;\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        return string(abi.encodePacked(baseURI, id.uint2str()));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              FACTORY LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function initialize(\n        address _launcher,\n        address _owner,\n        string calldata _name,\n        string calldata _symbol,\n        string calldata _baseURI\n    ) external {\n        if (isInit()) {\n            revert OdysseyERC1155_AlreadyInit();\n        }\n        initialized = true;\n        launcher = _launcher;\n        owner = _owner;\n        name = _name;\n        symbol = _symbol;\n        baseURI = _baseURI;\n    }\n\n    function isInit() internal view returns (bool) {\n        return initialized;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual {\n        if (newOwner == address(0)) {\n            revert OdysseyERC1155_BadAddress();\n        }\n        if (msg.sender != owner) {\n            revert OdysseyERC1155_Unauthorized();\n        }\n        owner = newOwner;\n    }\n\n    function mint(address user, uint256 id) external {\n        if (msg.sender != launcher) {\n            revert OdysseyERC1155_Unauthorized();\n        }\n        _mint(user, id, 1, \"\");\n    }\n\n    function mintBatch(\n        address user,\n        uint256 id,\n        uint256 amount\n    ) external {\n        if (msg.sender != launcher) {\n            revert OdysseyERC1155_Unauthorized();\n        }\n        _mint(user, id, amount, \"\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP2981 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function royaltyInfo(uint256, uint256 _salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount)\n    {\n        return (royaltyReceiver, (_salePrice / 10000) * royaltyFeeInBips);\n    }\n\n    function setRoyaltyInfo(address _royaltyReceiver, uint256 _royaltyFeeInBips)\n        external\n    {\n        if (_royaltyReceiver == address(0)) {\n            revert OdysseyERC1155_BadAddress();\n        }\n        if (msg.sender != owner) {\n            revert OdysseyERC1155_Unauthorized();\n        }\n        royaltyReceiver = _royaltyReceiver;\n        royaltyFeeInBips = _royaltyFeeInBips;\n    }\n\n    function setContractURI(string memory _uri) public {\n        if (msg.sender != owner) {\n            revert OdysseyERC1155_Unauthorized();\n        }\n        contractURI = _uri;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceID)\n        public\n        pure\n        override(ERC1155)\n        returns (bool)\n    {\n        return\n            bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == interfaceID ||\n            super.supportsInterface(interfaceID);\n    }\n}\n\ncontract OdysseyTokenFactory {\n    /*///////////////////////////////////////////////////////////////\n                            CUSTOM ERRORS\n    //////////////////////////////////////////////////////////////*/\n    error OdysseyTokenFactory_TokenAlreadyExists();\n    /*///////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TokenCreated(\n        string indexed name,\n        string indexed symbol,\n        address addr,\n        bool isERC721,\n        uint256 length\n    );\n\n    /*///////////////////////////////////////////////////////////////\n                            FACTORY STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(string => mapping(string => address)) public getToken;\n    mapping(address => uint256) public tokenExists;\n    address[] public allTokens;\n\n    /*///////////////////////////////////////////////////////////////\n                            FACTORY LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function allTokensLength() external view returns (uint256) {\n        return allTokens.length;\n    }\n\n    function create1155(\n        address owner,\n        string calldata name,\n        string calldata symbol,\n        string calldata baseURI\n    ) external returns (address token) {\n        if (getToken[name][symbol] != address(0)) {\n            revert OdysseyTokenFactory_TokenAlreadyExists();\n        }\n        bytes memory bytecode = type(OdysseyERC1155).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(name, symbol));\n        assembly {\n            token := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        getToken[name][symbol] = token;\n        tokenExists[token] = 1;\n        // Run the proper initialize function\n        OdysseyERC1155(token).initialize(\n            msg.sender,\n            owner,\n            name,\n            symbol,\n            string(\n                abi.encodePacked(\n                    baseURI,\n                    Strings.toString(block.chainid),\n                    \"/\",\n                    Strings.toHexString(uint160(token)),\n                    \"/\"\n                )\n            )\n        );\n        emit TokenCreated(name, symbol, token, false, allTokens.length);\n        return token;\n    }\n\n    function create721(\n        address owner,\n        string calldata name,\n        string calldata symbol,\n        string calldata baseURI\n    ) external returns (address token) {\n        if (getToken[name][symbol] != address(0)) {\n            revert OdysseyTokenFactory_TokenAlreadyExists();\n        }\n        bytes memory bytecode = type(OdysseyERC721).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(name, symbol));\n        assembly {\n            token := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        getToken[name][symbol] = token;\n        tokenExists[token] = 1;\n        // Run the proper initialize function\n        OdysseyERC721(token).initialize(\n            msg.sender,\n            owner,\n            name,\n            symbol,\n            string(\n                abi.encodePacked(\n                    baseURI,\n                    Strings.toString(block.chainid),\n                    \"/\",\n                    Strings.toHexString(uint160(token)),\n                    \"/\"\n                )\n            )\n        );\n        emit TokenCreated(name, symbol, token, true, allTokens.length);\n    }\n}\n\nlibrary OdysseyLib {\n    struct Odyssey1155Info {\n        uint256[] maxSupply;\n        uint256[] tokenIds;\n        uint256[] reserveAmounts;\n    }\n\n    struct BatchMint {\n        bytes32[][] merkleProof;\n        bytes32[] merkleRoot;\n        uint256[] minPrice;\n        uint256[] mintsPerUser;\n        uint256[] tokenId;\n        address[] tokenAddress;\n        address[] currency;\n        uint8[] v;\n        bytes32[] r;\n        bytes32[] s;\n    }\n\n    struct Percentage {\n        uint256 numerator;\n        uint256 denominator;\n    }\n\n    function compareDefaultPercentage(OdysseyLib.Percentage calldata percent)\n        internal\n        pure\n        returns (bool result)\n    {\n        if (percent.numerator > percent.denominator) {\n            // Can't have a percent greater than 100\n            return false;\n        }\n\n        if (percent.numerator == 0 || percent.denominator == 0) {\n            // Can't use 0 in percentage\n            return false;\n        }\n\n        //Check cross multiplication of 3/100\n        uint256 crossMultiple1 = percent.numerator * 100;\n        uint256 crossMultiple2 = percent.denominator * 3;\n        if (crossMultiple1 < crossMultiple2) {\n            return false;\n        }\n        return true;\n    }\n}\n\nabstract contract OdysseyDatabase {\n    // Custom Errors\n    error OdysseyLaunchPlatform_TokenDoesNotExist();\n    error OdysseyLaunchPlatform_AlreadyClaimed();\n    error OdysseyLaunchPlatform_MaxSupplyCap();\n    error OdysseyLaunchPlatform_InsufficientFunds();\n    error OdysseyLaunchPlatform_TreasuryPayFailure();\n    error OdysseyLaunchPlatform_FailedToPayEther();\n    error OdysseyLaunchPlatform_FailedToPayERC20();\n    error OdysseyLaunchPlatform_ReservedOrClaimedMax();\n\n    // Constants\n    // keccak256(\"whitelistMint721(bytes32 merkleRoot,uint256 minPrice,uint256 mintsPerUser,address tokenAddress,address currency)\").toString('hex')\n    bytes32 public constant MERKLE_TREE_ROOT_ERC721_TYPEHASH =\n        0xf0f6f256599682b9387f45fc268ed696625f835d98d64b8967134239e103fc6c;\n    // keccak256(\"whitelistMint1155(bytes32 merkleRoot,uint256 minPrice,uint256 mintsPerUser,uint256 tokenId,address tokenAddress,address currency)\").toString('hex')\n    bytes32 public constant MERKLE_TREE_ROOT_ERC1155_TYPEHASH =\n        0x0a52f6e0133eadd055cc5703844e676242c3b461d85fb7ce7f74becd7e40edd1;\n\n    // Def understand this before writing code:\n    // https://docs.soliditylang.org/en/v0.8.12/internals/layout_in_storage.html\n    //--------------------------------------------------------------------------------//\n    // Slot       |  Type                  | Description                              //\n    //--------------------------------------------------------------------------------//\n    // 0x00       |  address               | OdysseyLaunchPlatform.sol                //\n    // 0x01       |  address               | OdysseyFactory.sol                       //\n    // 0x02       |  address               | Treasury Multisig                        //\n    // 0x03       |  address               | Admin Address                            //\n    // 0x04       |  address               | OdysseyXp.sol                            //\n    //--------------------------------------------------------------------------------//\n    // Slot storage\n    address launchPlatform; // slot 0\n    address factory; // slot 1\n    address treasury; // slot 2\n    address admin; //slot 3\n    address xp; //slot 4\n\n    // Common Storage\n    mapping(address => bytes32) public domainSeparator;\n    mapping(address => uint256) public whitelistActive;\n    mapping(address => address) public ownerOf;\n    mapping(address => address) public royaltyRecipient;\n    mapping(address => OdysseyLib.Percentage) public treasuryCommission;\n    mapping(address => uint256) public ohmFamilyCurrencies;\n    // ERC721 Storage\n    mapping(address => mapping(address => uint256)) public whitelistClaimed721;\n    mapping(address => mapping(address => uint256)) public isReserved721;\n    mapping(address => uint256) public cumulativeSupply721;\n    mapping(address => uint256) public mintedSupply721;\n    mapping(address => uint256) public maxSupply721;\n    // ERC1155 Storage\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\n        public whitelistClaimed1155;\n    mapping(address => mapping(address => mapping(uint256 => uint256)))\n        public isReserved1155;\n    mapping(address => mapping(uint256 => uint256)) public cumulativeSupply1155;\n    mapping(address => mapping(uint256 => uint256)) public maxSupply1155;\n\n    function readSlotAsAddress(uint256 slot)\n        public\n        view\n        returns (address data)\n    {\n        assembly {\n            data := sload(slot)\n        }\n    }\n} /// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\nlibrary SafeTransferLib {\n    /*///////////////////////////////////////////////////////////////\n                            ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool callStatus;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(callStatus, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(\n                freeMemoryPointer,\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\n            ) // Begin with the function selector.\n            mstore(\n                add(freeMemoryPointer, 4),\n                and(from, 0xffffffffffffffffffffffffffffffffffffffff)\n            ) // Mask and append the \"from\" argument.\n            mstore(\n                add(freeMemoryPointer, 36),\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n            ) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 100 because the calldata length is 4 + 32 * 3.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\n        }\n\n        require(\n            didLastOptionalReturnCallSucceed(callStatus),\n            \"TRANSFER_FROM_FAILED\"\n        );\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(\n                freeMemoryPointer,\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\n            ) // Begin with the function selector.\n            mstore(\n                add(freeMemoryPointer, 4),\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n            ) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(\n            didLastOptionalReturnCallSucceed(callStatus),\n            \"TRANSFER_FAILED\"\n        );\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(\n                freeMemoryPointer,\n                0x095ea7b300000000000000000000000000000000000000000000000000000000\n            ) // Begin with the function selector.\n            mstore(\n                add(freeMemoryPointer, 4),\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n            ) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function didLastOptionalReturnCallSucceed(bool callStatus)\n        private\n        pure\n        returns (bool success)\n    {\n        assembly {\n            // Get how many bytes the call returned.\n            let returnDataSize := returndatasize()\n\n            // If the call reverted:\n            if iszero(callStatus) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                success := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                success := 1\n            }\n            default {\n                // It returned some malformed input.\n                success := 0\n            }\n        }\n    }\n} /// @notice Arithmetic library with operations for fixed-point numbers.\n\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(\n                and(\n                    iszero(iszero(denominator)),\n                    or(iszero(x), eq(div(z, x), y))\n                )\n            ) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(\n                and(\n                    iszero(iszero(denominator)),\n                    or(iszero(x), eq(div(z, x), y))\n                )\n            ) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n} // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId)\n        internal\n        view\n        returns (bool)\n    {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return\n            supportsERC165(account) &&\n            _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(\n                    account,\n                    interfaceIds[i]\n                );\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId)\n        private\n        view\n        returns (bool)\n    {\n        bytes memory encodedParams = abi.encodeWithSelector(\n            IERC165.supportsInterface.selector,\n            interfaceId\n        );\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(\n            encodedParams\n        );\n        if (result.length < 32) return false;\n        return success && abi.decode(result, (bool));\n    }\n}\nstruct Rewards {\n    uint256 sale;\n    uint256 purchase;\n    uint256 mint;\n    uint256 ohmPurchase;\n    uint256 ohmMint;\n    uint256 multiplier;\n}\n\nstruct NFT {\n    address contractAddress;\n    uint256 id;\n}\n\nenum NftType {\n    ERC721,\n    ERC1155\n}\n\nerror OdysseyXpDirectory_Unauthorized();\n\ncontract OdysseyXpDirectory {\n    using ERC165Checker for address;\n\n    Rewards public defaultRewards;\n    mapping(address => Rewards) public erc721rewards;\n    mapping(address => mapping(uint256 => Rewards)) public erc1155rewards;\n    NFT[] public customRewardTokens;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // modifier substitute\n    function notOwner() internal view returns (bool) {\n        return msg.sender != owner;\n    }\n\n    function transferOwnership(address newOwner) external {\n        if (notOwner()) revert OdysseyXpDirectory_Unauthorized();\n        owner = newOwner;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            Reward Setters\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Set default rewards for contracts without a custom reward set\n    /// @param sale XP reward for selling an NFT\n    /// @param purchase XP reward for purchasing an NFT\n    /// @param mint XP reward for minting an NFT\n    /// @param ohmPurchase XP reward for purchasing an NFT with OHM\n    /// @param ohmMint XP reward for minting an NFT with OHM\n    /// @param multiplier XP reward multiplier for wallets holding an NFT\n    function setDefaultRewards(\n        uint256 sale,\n        uint256 purchase,\n        uint256 mint,\n        uint256 ohmPurchase,\n        uint256 ohmMint,\n        uint256 multiplier\n    ) public {\n        if (notOwner()) revert OdysseyXpDirectory_Unauthorized();\n        defaultRewards = Rewards(\n            sale,\n            purchase,\n            mint,\n            ohmPurchase,\n            ohmMint,\n            multiplier\n        );\n    }\n\n    /// @notice Set custom rewards for an ERC721 contract\n    /// @param sale XP reward for selling this NFT\n    /// @param purchase XP reward for purchasing this NFT\n    /// @param mint XP reward for minting this NFT\n    /// @param ohmPurchase XP reward for purchasing this NFT with OHM\n    /// @param ohmMint XP reward for minting this NFT with OHM\n    /// @param multiplier XP reward multiplier for wallets holding this NFT\n    function setErc721CustomRewards(\n        address tokenAddress,\n        uint256 sale,\n        uint256 purchase,\n        uint256 mint,\n        uint256 ohmPurchase,\n        uint256 ohmMint,\n        uint256 multiplier\n    ) public {\n        if (notOwner()) revert OdysseyXpDirectory_Unauthorized();\n        customRewardTokens.push(NFT(tokenAddress, 0));\n        erc721rewards[tokenAddress] = Rewards(\n            sale,\n            purchase,\n            mint,\n            ohmPurchase,\n            ohmMint,\n            multiplier\n        );\n    }\n\n    /// @notice Set custom rewards for an ERC1155 contract and token ID\n    /// @param sale XP reward for selling this NFT\n    /// @param purchase XP reward for purchasing this NFT\n    /// @param mint XP reward for minting this NFT\n    /// @param ohmPurchase XP reward for purchasing this NFT with OHM\n    /// @param ohmMint XP reward for minting this NFT with OHM\n    /// @param multiplier XP reward multiplier for wallets holding this NFT\n    function setErc1155CustomRewards(\n        address tokenAddress,\n        uint256 tokenId,\n        uint256 sale,\n        uint256 purchase,\n        uint256 mint,\n        uint256 ohmPurchase,\n        uint256 ohmMint,\n        uint256 multiplier\n    ) public {\n        if (notOwner()) revert OdysseyXpDirectory_Unauthorized();\n        customRewardTokens.push(NFT(tokenAddress, tokenId));\n        erc1155rewards[tokenAddress][tokenId] = Rewards(\n            sale,\n            purchase,\n            mint,\n            ohmPurchase,\n            ohmMint,\n            multiplier\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            Reward Getters\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Get the XP reward for selling an NFT\n    /// @param seller Seller of the NFT\n    /// @param contractAddress Address of the NFT being sold\n    /// @param tokenId ID of the NFT being sold\n    function getSaleReward(\n        address seller,\n        address contractAddress,\n        uint256 tokenId\n    ) public view returns (uint256) {\n        (\n            bool isCustomErc721,\n            bool isCustomErc1155,\n            uint256 multiplier\n        ) = _getRewardDetails(seller, contractAddress, tokenId);\n        if (isCustomErc721) {\n            return erc721rewards[contractAddress].sale * multiplier;\n        } else if (isCustomErc1155) {\n            return erc1155rewards[contractAddress][tokenId].sale * multiplier;\n        } else {\n            return defaultRewards.sale * multiplier;\n        }\n    }\n\n    /// @notice Get the XP reward for buying an NFT\n    /// @param buyer Buyer of the NFT\n    /// @param contractAddress Address of the NFT being sold\n    /// @param tokenId ID of the NFT being sold\n    function getPurchaseReward(\n        address buyer,\n        address contractAddress,\n        uint256 tokenId\n    ) public view returns (uint256) {\n        (\n            bool isCustomErc721,\n            bool isCustomErc1155,\n            uint256 multiplier\n        ) = _getRewardDetails(buyer, contractAddress, tokenId);\n        if (isCustomErc721) {\n            return erc721rewards[contractAddress].purchase * multiplier;\n        } else if (isCustomErc1155) {\n            return\n                erc1155rewards[contractAddress][tokenId].purchase * multiplier;\n        } else {\n            return defaultRewards.purchase * multiplier;\n        }\n    }\n\n    /// @notice Get the XP reward for minting an NFT\n    /// @param buyer Buyer of the NFT\n    /// @param contractAddress Address of the NFT being sold\n    /// @param tokenId ID of the NFT being sold\n    function getMintReward(\n        address buyer,\n        address contractAddress,\n        uint256 tokenId\n    ) public view returns (uint256) {\n        (\n            bool isCustomErc721,\n            bool isCustomErc1155,\n            uint256 multiplier\n        ) = _getRewardDetails(buyer, contractAddress, tokenId);\n        if (isCustomErc721) {\n            return erc721rewards[contractAddress].mint * multiplier;\n        } else if (isCustomErc1155) {\n            return erc1155rewards[contractAddress][tokenId].mint * multiplier;\n        } else {\n            return defaultRewards.mint * multiplier;\n        }\n    }\n\n    /// @notice Get the XP reward for buying an NFT with OHM\n    /// @param buyer Buyer of the NFT\n    /// @param contractAddress Address of the NFT being sold\n    /// @param tokenId ID of the NFT being sold\n    function getOhmPurchaseReward(\n        address buyer,\n        address contractAddress,\n        uint256 tokenId\n    ) public view returns (uint256) {\n        (\n            bool isCustomErc721,\n            bool isCustomErc1155,\n            uint256 multiplier\n        ) = _getRewardDetails(buyer, contractAddress, tokenId);\n        if (isCustomErc721) {\n            return erc721rewards[contractAddress].ohmPurchase * multiplier;\n        } else if (isCustomErc1155) {\n            return\n                erc1155rewards[contractAddress][tokenId].ohmPurchase *\n                multiplier;\n        } else {\n            return defaultRewards.ohmPurchase * multiplier;\n        }\n    }\n\n    /// @notice Get the XP reward for minting an NFT with OHM\n    /// @param buyer Buyer of the NFT\n    /// @param contractAddress Address of the NFT being sold\n    /// @param tokenId ID of the NFT being sold\n    function getOhmMintReward(\n        address buyer,\n        address contractAddress,\n        uint256 tokenId\n    ) public view returns (uint256) {\n        (\n            bool isCustomErc721,\n            bool isCustomErc1155,\n            uint256 multiplier\n        ) = _getRewardDetails(buyer, contractAddress, tokenId);\n        if (isCustomErc721) {\n            return erc721rewards[contractAddress].ohmMint * multiplier;\n        } else if (isCustomErc1155) {\n            return\n                erc1155rewards[contractAddress][tokenId].ohmMint * multiplier;\n        } else {\n            return defaultRewards.ohmMint * multiplier;\n        }\n    }\n\n    /// @notice Determine if an NFT has custom rewards and any multiplier based on the user's held NFTs\n    /// @dev The multiplier and custom rewards are determined simultaneously to save on gas costs of iteration\n    /// @param user Wallet address with potential multiplier NFTs\n    /// @param contractAddress Address of the NFT being sold\n    /// @param tokenId ID of the NFT being sold\n    function _getRewardDetails(\n        address user,\n        address contractAddress,\n        uint256 tokenId\n    )\n        internal\n        view\n        returns (\n            bool isCustomErc721,\n            bool isCustomErc1155,\n            uint256 multiplier\n        )\n    {\n        NFT[] memory _customRewardTokens = customRewardTokens; // save an SLOAD from length reading\n        for (uint256 i = 0; i < _customRewardTokens.length; i++) {\n            NFT memory token = _customRewardTokens[i];\n            if (token.contractAddress.supportsInterface(0x80ac58cd)) {\n                // is ERC721\n                if (OdysseyERC721(token.contractAddress).balanceOf(user) > 0) {\n                    uint256 reward = erc721rewards[token.contractAddress]\n                        .multiplier;\n                    multiplier = reward > 1 ? multiplier + reward : multiplier; // only increment if multiplier is non-one\n                }\n                if (contractAddress == token.contractAddress) {\n                    isCustomErc721 = true;\n                }\n            } else if (token.contractAddress.supportsInterface(0xd9b67a26)) {\n                // is isERC1155\n                if (\n                    OdysseyERC1155(token.contractAddress).balanceOf(\n                        user,\n                        token.id\n                    ) > 0\n                ) {\n                    uint256 reward = erc1155rewards[token.contractAddress][\n                        token.id\n                    ].multiplier;\n                    multiplier = reward > 1 ? multiplier + reward : multiplier; // only increment if multiplier is non-one\n                    if (\n                        contractAddress == token.contractAddress &&\n                        tokenId == token.id\n                    ) {\n                        isCustomErc1155 = true;\n                    }\n                }\n            }\n        }\n        multiplier = multiplier == 0 ? defaultRewards.multiplier : multiplier; // if no custom multiplier, use default\n        multiplier = multiplier > 4 ? 4 : multiplier; // multiplier caps at 4\n    }\n}\nerror OdysseyXp_Unauthorized();\nerror OdysseyXp_NonTransferable();\nerror OdysseyXp_ZeroAssets();\n\ncontract OdysseyXp is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    struct UserHistory {\n        uint256 balanceAtLastRedeem;\n        uint256 globallyWithdrawnAtLastRedeem;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Mint(address indexed owner, uint256 assets, uint256 xp);\n\n    event Redeem(address indexed owner, uint256 assets, uint256 xp);\n\n    /*///////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    address public router;\n    address public exchange;\n    address public owner;\n    uint256 public globallyWithdrawn;\n    ERC20 public immutable asset;\n    OdysseyXpDirectory public directory;\n    mapping(address => UserHistory) public userHistories;\n\n    constructor(\n        ERC20 _asset,\n        OdysseyXpDirectory _directory,\n        address _router,\n        address _exchange,\n        address _owner\n    ) ERC20(\"Odyssey XP\", \"XP\", 0) {\n        asset = _asset;\n        directory = _directory;\n        router = _router;\n        exchange = _exchange;\n        owner = _owner;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    function notOwner() internal view returns (bool) {\n        return msg.sender != owner;\n    }\n\n    function notRouter() internal view returns (bool) {\n        return msg.sender != router;\n    }\n\n    function notExchange() internal view returns (bool) {\n        return msg.sender != exchange;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        RESTRICTED SETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    function setExchange(address _exchange) external {\n        if (notOwner()) revert OdysseyXp_Unauthorized();\n        exchange = _exchange;\n    }\n\n    function setRouter(address _router) external {\n        if (notOwner()) revert OdysseyXp_Unauthorized();\n        router = _router;\n    }\n\n    function setDirectory(address _directory) external {\n        if (notOwner()) revert OdysseyXp_Unauthorized();\n        directory = OdysseyXpDirectory(_directory);\n    }\n\n    function transferOwnership(address _newOwner) external {\n        if (notOwner()) revert OdysseyXp_Unauthorized();\n        owner = _newOwner;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        XP Granting Methods\n    //////////////////////////////////////////////////////////////*/\n\n    function saleReward(\n        address seller,\n        address contractAddress,\n        uint256 tokenId\n    ) external {\n        if (notExchange()) revert OdysseyXp_Unauthorized();\n        _grantXP(\n            seller,\n            directory.getSaleReward(seller, contractAddress, tokenId)\n        );\n    }\n\n    function purchaseReward(\n        address buyer,\n        address contractAddress,\n        uint256 tokenId\n    ) external {\n        if (notExchange()) revert OdysseyXp_Unauthorized();\n        _grantXP(\n            buyer,\n            directory.getPurchaseReward(buyer, contractAddress, tokenId)\n        );\n    }\n\n    function mintReward(\n        address buyer,\n        address contractAddress,\n        uint256 tokenId\n    ) external {\n        if (notRouter()) revert OdysseyXp_Unauthorized();\n        _grantXP(\n            buyer,\n            directory.getMintReward(buyer, contractAddress, tokenId)\n        );\n    }\n\n    function ohmPurchaseReward(\n        address buyer,\n        address contractAddress,\n        uint256 tokenId\n    ) external {\n        if (notExchange()) revert OdysseyXp_Unauthorized();\n        _grantXP(\n            buyer,\n            directory.getOhmPurchaseReward(buyer, contractAddress, tokenId)\n        );\n    }\n\n    function ohmMintReward(\n        address buyer,\n        address contractAddress,\n        uint256 tokenId\n    ) external {\n        if (notRouter()) revert OdysseyXp_Unauthorized();\n        _grantXP(\n            buyer,\n            directory.getOhmMintReward(buyer, contractAddress, tokenId)\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Grants the receiver the given amount of XP\n    /// @dev Forces the receiver to redeem if they have rewards available\n    /// @param receiver The address to grant XP to\n    /// @param xp The amount of XP to grant\n    function _grantXP(address receiver, uint256 xp)\n        internal\n        returns (uint256 assets)\n    {\n        uint256 currentXp = balanceOf[receiver];\n        if ((assets = previewRedeem(receiver, currentXp)) > 0)\n            _redeem(receiver, assets, currentXp); // force redeeming to keep portions in line\n        else if (currentXp == 0)\n            userHistories[receiver]\n                .globallyWithdrawnAtLastRedeem = globallyWithdrawn; // if a new user, adjust their history to calculate withdrawn at their first redeem\n        _mint(receiver, xp);\n\n        emit Mint(msg.sender, assets, xp);\n\n        afterMint(assets, xp);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        REDEEM LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice external redeem method\n    /// @dev will revert if there is nothing to redeem\n    function redeem() public returns (uint256 assets) {\n        uint256 xp = balanceOf[msg.sender];\n        if ((assets = previewRedeem(msg.sender, xp)) == 0)\n            revert OdysseyXp_ZeroAssets();\n        _redeem(msg.sender, assets, xp);\n    }\n\n    /// @notice Internal logic for redeeming rewards\n    /// @param receiver The receiver of rewards\n    /// @param assets The amount of assets to grant\n    /// @param xp The amount of XP the user is redeeming with\n    function _redeem(\n        address receiver,\n        uint256 assets,\n        uint256 xp\n    ) internal virtual {\n        beforeRedeem(assets, xp);\n\n        userHistories[receiver].balanceAtLastRedeem =\n            asset.balanceOf(address(this)) -\n            assets;\n        userHistories[receiver].globallyWithdrawnAtLastRedeem =\n            globallyWithdrawn +\n            assets;\n        globallyWithdrawn += assets;\n\n        asset.safeTransfer(receiver, assets);\n\n        emit Redeem(receiver, assets, xp);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Preview the result of a redeem for the given user with the given XP amount\n    /// @param recipient The user to check potential rewards for\n    /// @param xp The amount of XP the user is previewing a redeem for\n    function previewRedeem(address recipient, uint256 xp)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return\n            supply == 0 || xp == 0\n                ? 0\n                : xp.mulDivDown(totalAssets(recipient), supply);\n    }\n\n    /// @notice The total amount of available assets for the user, adjusted based on their history\n    /// @param user The user to check assets for\n    function totalAssets(address user) internal view returns (uint256) {\n        uint256 balance = asset.balanceOf(address(this)); // Saves an extra SLOAD if balance is non-zero.\n        return\n            balance +\n            (globallyWithdrawn -\n                userHistories[user].globallyWithdrawnAtLastRedeem) -\n            userHistories[user].balanceAtLastRedeem;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       OVERRIDE TRANSFERABILITY\n    //////////////////////////////////////////////////////////////*/\n\n    function transfer(address to, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        revert OdysseyXp_NonTransferable();\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override returns (bool) {\n        revert OdysseyXp_NonTransferable();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeRedeem(uint256 assets, uint256 xp) internal virtual {}\n\n    function afterMint(uint256 assets, uint256 xp) internal virtual {}\n}\n\ncontract OdysseyLaunchPlatform is OdysseyDatabase, ReentrancyGuard {\n    /*///////////////////////////////////////////////////////////////\n                                ACTIONS\n    //////////////////////////////////////////////////////////////*/\n    function mintERC721(\n        bytes32[] calldata merkleProof,\n        bytes32 merkleRoot,\n        uint256 minPrice,\n        uint256 mintsPerUser,\n        address tokenAddress,\n        address currency,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable nonReentrant {\n        if (OdysseyTokenFactory(factory).tokenExists(tokenAddress) == 0) {\n            revert OdysseyLaunchPlatform_TokenDoesNotExist();\n        }\n        if (whitelistClaimed721[tokenAddress][msg.sender] >= mintsPerUser) {\n            revert OdysseyLaunchPlatform_AlreadyClaimed();\n        }\n        // Check if user is already reserved + paid\n        if (isReserved721[tokenAddress][msg.sender] == 0) {\n            if (\n                cumulativeSupply721[tokenAddress] >= maxSupply721[tokenAddress]\n            ) {\n                revert OdysseyLaunchPlatform_MaxSupplyCap();\n            }\n            {\n                // Verify merkle root and minPrice signed by owner (all id's have same min price)\n                bytes32 hash = keccak256(\n                    abi.encode(\n                        MERKLE_TREE_ROOT_ERC721_TYPEHASH,\n                        merkleRoot,\n                        minPrice,\n                        mintsPerUser,\n                        tokenAddress,\n                        currency\n                    )\n                );\n                Signature.verify(\n                    hash,\n                    ownerOf[tokenAddress],\n                    v,\n                    r,\n                    s,\n                    domainSeparator[tokenAddress]\n                );\n            }\n            if (whitelistActive[tokenAddress] == 1) {\n                // Verify user whitelisted\n                MerkleWhiteList.verify(msg.sender, merkleProof, merkleRoot);\n            }\n            cumulativeSupply721[tokenAddress]++;\n\n            OdysseyLib.Percentage storage percent = treasuryCommission[\n                tokenAddress\n            ];\n            uint256 commission = (minPrice * percent.numerator) /\n                percent.denominator;\n\n            if (currency == address(0)) {\n                if (msg.value < minPrice) {\n                    revert OdysseyLaunchPlatform_InsufficientFunds();\n                }\n                (bool treasurySuccess, ) = treasury.call{value: commission}(\"\");\n                if (!treasurySuccess) {\n                    revert OdysseyLaunchPlatform_TreasuryPayFailure();\n                }\n                (bool success, ) = royaltyRecipient[tokenAddress].call{\n                    value: minPrice - commission\n                }(\"\");\n                if (!success) {\n                    revert OdysseyLaunchPlatform_FailedToPayEther();\n                }\n            } else {\n                if (\n                    ERC20(currency).allowance(msg.sender, address(this)) <\n                    minPrice\n                ) {\n                    revert OdysseyLaunchPlatform_InsufficientFunds();\n                }\n                bool result = ERC20(currency).transferFrom(\n                    msg.sender,\n                    treasury,\n                    commission\n                );\n                if (!result) {\n                    revert OdysseyLaunchPlatform_TreasuryPayFailure();\n                }\n                result = ERC20(currency).transferFrom(\n                    msg.sender,\n                    royaltyRecipient[tokenAddress],\n                    minPrice - commission\n                );\n                if (!result) {\n                    revert OdysseyLaunchPlatform_FailedToPayERC20();\n                }\n                if (ohmFamilyCurrencies[currency] == 1) {\n                    OdysseyXp(xp).ohmMintReward(msg.sender, tokenAddress, 0);\n                }\n            }\n        } else {\n            isReserved721[tokenAddress][msg.sender]--;\n        }\n        // Update State\n        whitelistClaimed721[tokenAddress][msg.sender]++;\n        OdysseyERC721(tokenAddress).mint(\n            msg.sender,\n            mintedSupply721[tokenAddress]++\n        );\n    }\n\n    function reserveERC721(\n        bytes32[] calldata merkleProof,\n        bytes32 merkleRoot,\n        uint256 minPrice,\n        uint256 mintsPerUser,\n        address tokenAddress,\n        address currency,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable nonReentrant {\n        if (OdysseyTokenFactory(factory).tokenExists(tokenAddress) == 0) {\n            revert OdysseyLaunchPlatform_TokenDoesNotExist();\n        }\n        if (cumulativeSupply721[tokenAddress] >= maxSupply721[tokenAddress]) {\n            revert OdysseyLaunchPlatform_MaxSupplyCap();\n        }\n        if (\n            isReserved721[tokenAddress][msg.sender] +\n                whitelistClaimed721[tokenAddress][msg.sender] >=\n            mintsPerUser\n        ) {\n            revert OdysseyLaunchPlatform_ReservedOrClaimedMax();\n        }\n        {\n            // Verify merkle root and minPrice signed by owner (all id's have same min price)\n            bytes32 hash = keccak256(\n                abi.encode(\n                    MERKLE_TREE_ROOT_ERC721_TYPEHASH,\n                    merkleRoot,\n                    minPrice,\n                    mintsPerUser,\n                    tokenAddress,\n                    currency\n                )\n            );\n            Signature.verify(\n                hash,\n                ownerOf[tokenAddress],\n                v,\n                r,\n                s,\n                domainSeparator[tokenAddress]\n            );\n        }\n        if (whitelistActive[tokenAddress] == 1) {\n            // Verify user whitelisted\n            MerkleWhiteList.verify(msg.sender, merkleProof, merkleRoot);\n        }\n\n        // Set user is reserved\n        isReserved721[tokenAddress][msg.sender]++;\n        // Increate Reserved + minted supply\n        cumulativeSupply721[tokenAddress]++;\n\n        OdysseyLib.Percentage storage percent = treasuryCommission[\n            tokenAddress\n        ];\n        uint256 commission = (minPrice * percent.numerator) /\n            percent.denominator;\n\n        if (currency == address(0)) {\n            if (msg.value < minPrice) {\n                revert OdysseyLaunchPlatform_InsufficientFunds();\n            }\n            (bool treasurySuccess, ) = treasury.call{value: commission}(\"\");\n            if (!treasurySuccess) {\n                revert OdysseyLaunchPlatform_TreasuryPayFailure();\n            }\n            (bool success, ) = royaltyRecipient[tokenAddress].call{\n                value: minPrice - commission\n            }(\"\");\n            if (!success) {\n                revert OdysseyLaunchPlatform_FailedToPayEther();\n            }\n        } else {\n            if (\n                ERC20(currency).allowance(msg.sender, address(this)) < minPrice\n            ) {\n                revert OdysseyLaunchPlatform_InsufficientFunds();\n            }\n            bool result = ERC20(currency).transferFrom(\n                msg.sender,\n                treasury,\n                commission\n            );\n            if (!result) {\n                revert OdysseyLaunchPlatform_TreasuryPayFailure();\n            }\n            result = ERC20(currency).transferFrom(\n                msg.sender,\n                royaltyRecipient[tokenAddress],\n                minPrice - commission\n            );\n            if (!result) {\n                revert OdysseyLaunchPlatform_FailedToPayERC20();\n            }\n            if (ohmFamilyCurrencies[currency] == 1) {\n                OdysseyXp(xp).ohmMintReward(msg.sender, tokenAddress, 0);\n            }\n        }\n    }\n\n    function mintERC1155(\n        bytes32[] calldata merkleProof,\n        bytes32 merkleRoot,\n        uint256 minPrice,\n        uint256 mintsPerUser,\n        uint256 tokenId,\n        address tokenAddress,\n        address currency,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable nonReentrant {\n        if (OdysseyTokenFactory(factory).tokenExists(tokenAddress) == 0) {\n            revert OdysseyLaunchPlatform_TokenDoesNotExist();\n        }\n        if (\n            whitelistClaimed1155[tokenAddress][msg.sender][tokenId] >=\n            mintsPerUser\n        ) {\n            revert OdysseyLaunchPlatform_AlreadyClaimed();\n        }\n        // Check if user is already reserved + paid\n        if (isReserved1155[tokenAddress][msg.sender][tokenId] == 0) {\n            if (\n                cumulativeSupply1155[tokenAddress][tokenId] >=\n                maxSupply1155[tokenAddress][tokenId]\n            ) {\n                revert OdysseyLaunchPlatform_MaxSupplyCap();\n            }\n            {\n                // Verify merkle root and minPrice signed by owner (all id's have same min price)\n                bytes32 hash = keccak256(\n                    abi.encode(\n                        MERKLE_TREE_ROOT_ERC1155_TYPEHASH,\n                        merkleRoot,\n                        minPrice,\n                        mintsPerUser,\n                        tokenId,\n                        tokenAddress,\n                        currency\n                    )\n                );\n                Signature.verify(\n                    hash,\n                    ownerOf[tokenAddress],\n                    v,\n                    r,\n                    s,\n                    domainSeparator[tokenAddress]\n                );\n            }\n\n            if (whitelistActive[tokenAddress] == 1) {\n                // Verify user whitelisted\n                MerkleWhiteList.verify(msg.sender, merkleProof, merkleRoot);\n            }\n            cumulativeSupply1155[tokenAddress][tokenId]++;\n\n            OdysseyLib.Percentage storage percent = treasuryCommission[\n                tokenAddress\n            ];\n            uint256 commission = (minPrice * percent.numerator) /\n                percent.denominator;\n\n            if (currency == address(0)) {\n                if (msg.value < minPrice) {\n                    revert OdysseyLaunchPlatform_InsufficientFunds();\n                }\n                (bool treasurySuccess, ) = treasury.call{value: commission}(\"\");\n                if (!treasurySuccess) {\n                    revert OdysseyLaunchPlatform_TreasuryPayFailure();\n                }\n                (bool success, ) = royaltyRecipient[tokenAddress].call{\n                    value: minPrice - commission\n                }(\"\");\n                if (!success) {\n                    revert OdysseyLaunchPlatform_FailedToPayEther();\n                }\n            } else {\n                if (\n                    ERC20(currency).allowance(msg.sender, address(this)) <\n                    minPrice\n                ) {\n                    revert OdysseyLaunchPlatform_InsufficientFunds();\n                }\n                bool result = ERC20(currency).transferFrom(\n                    msg.sender,\n                    treasury,\n                    commission\n                );\n                if (!result) {\n                    revert OdysseyLaunchPlatform_TreasuryPayFailure();\n                }\n                result = ERC20(currency).transferFrom(\n                    msg.sender,\n                    royaltyRecipient[tokenAddress],\n                    minPrice - commission\n                );\n                if (!result) {\n                    revert OdysseyLaunchPlatform_FailedToPayERC20();\n                }\n                if (ohmFamilyCurrencies[currency] == 1) {\n                    OdysseyXp(xp).ohmMintReward(\n                        msg.sender,\n                        tokenAddress,\n                        tokenId\n                    );\n                }\n            }\n        } else {\n            isReserved1155[tokenAddress][msg.sender][tokenId]--;\n        }\n        // Update State\n        whitelistClaimed1155[tokenAddress][msg.sender][tokenId]++;\n\n        OdysseyERC1155(tokenAddress).mint(msg.sender, tokenId);\n    }\n\n    function reserveERC1155(\n        bytes32[] calldata merkleProof,\n        bytes32 merkleRoot,\n        uint256 minPrice,\n        uint256 mintsPerUser,\n        uint256 tokenId,\n        address tokenAddress,\n        address currency,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable nonReentrant {\n        if (OdysseyTokenFactory(factory).tokenExists(tokenAddress) == 0) {\n            revert OdysseyLaunchPlatform_TokenDoesNotExist();\n        }\n        if (\n            cumulativeSupply1155[tokenAddress][tokenId] >=\n            maxSupply1155[tokenAddress][tokenId]\n        ) {\n            revert OdysseyLaunchPlatform_MaxSupplyCap();\n        }\n        if (\n            isReserved1155[tokenAddress][msg.sender][tokenId] +\n                whitelistClaimed1155[tokenAddress][msg.sender][tokenId] >=\n            mintsPerUser\n        ) {\n            revert OdysseyLaunchPlatform_ReservedOrClaimedMax();\n        }\n        {\n            // Verify merkle root and minPrice signed by owner (all id's have same min price)\n            bytes32 hash = keccak256(\n                abi.encode(\n                    MERKLE_TREE_ROOT_ERC1155_TYPEHASH,\n                    merkleRoot,\n                    minPrice,\n                    mintsPerUser,\n                    tokenId,\n                    tokenAddress,\n                    currency\n                )\n            );\n            Signature.verify(\n                hash,\n                ownerOf[tokenAddress],\n                v,\n                r,\n                s,\n                domainSeparator[tokenAddress]\n            );\n        }\n\n        if (whitelistActive[tokenAddress] == 1) {\n            // Verify user whitelisted\n            MerkleWhiteList.verify(msg.sender, merkleProof, merkleRoot);\n        }\n\n        // Set user is reserved\n        isReserved1155[tokenAddress][msg.sender][tokenId]++;\n        // Increase Reserved + minted supply\n        cumulativeSupply1155[tokenAddress][tokenId]++;\n\n        OdysseyLib.Percentage storage percent = treasuryCommission[\n            tokenAddress\n        ];\n        uint256 commission = (minPrice * percent.numerator) /\n            percent.denominator;\n\n        if (currency == address(0)) {\n            if (msg.value < minPrice) {\n                revert OdysseyLaunchPlatform_InsufficientFunds();\n            }\n            (bool treasurySuccess, ) = treasury.call{value: commission}(\"\");\n            if (!treasurySuccess) {\n                revert OdysseyLaunchPlatform_TreasuryPayFailure();\n            }\n            (bool success, ) = royaltyRecipient[tokenAddress].call{\n                value: minPrice - commission\n            }(\"\");\n            if (!success) {\n                revert OdysseyLaunchPlatform_FailedToPayEther();\n            }\n        } else {\n            if (\n                ERC20(currency).allowance(msg.sender, address(this)) < minPrice\n            ) {\n                revert OdysseyLaunchPlatform_InsufficientFunds();\n            }\n            bool result = ERC20(currency).transferFrom(\n                msg.sender,\n                treasury,\n                commission\n            );\n            if (!result) {\n                revert OdysseyLaunchPlatform_TreasuryPayFailure();\n            }\n            result = ERC20(currency).transferFrom(\n                msg.sender,\n                royaltyRecipient[tokenAddress],\n                minPrice - commission\n            );\n            if (!result) {\n                revert OdysseyLaunchPlatform_FailedToPayERC20();\n            }\n            if (ohmFamilyCurrencies[currency] == 1) {\n                OdysseyXp(xp).ohmMintReward(msg.sender, tokenAddress, tokenId);\n            }\n        }\n    }\n\n    function setWhitelistStatus(address addr, bool active)\n        external\n        nonReentrant\n    {\n        if (OdysseyTokenFactory(factory).tokenExists(addr) == 0) {\n            revert OdysseyLaunchPlatform_TokenDoesNotExist();\n        }\n        whitelistActive[addr] = active ? 1 : 0;\n    }\n\n    function mint721OnCreate(uint256 amount, address token)\n        external\n        nonReentrant\n    {\n        cumulativeSupply721[token] = amount;\n        mintedSupply721[token] = amount;\n        uint256 i;\n        for (; i < amount; ++i) {\n            OdysseyERC721(token).mint(msg.sender, i);\n        }\n    }\n\n    function mint1155OnCreate(\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts,\n        address token\n    ) external nonReentrant {\n        uint256 i;\n        for (; i < tokenIds.length; ++i) {\n            cumulativeSupply1155[token][tokenIds[i]] = amounts[i];\n            OdysseyERC1155(token).mintBatch(\n                msg.sender,\n                tokenIds[i],\n                amounts[i]\n            );\n        }\n    }\n\n    function ownerMint721(address token, address to) external nonReentrant {\n        if (cumulativeSupply721[token] >= maxSupply721[token]) {\n            revert OdysseyLaunchPlatform_MaxSupplyCap();\n        }\n        cumulativeSupply721[token]++;\n        OdysseyERC721(token).mint(to, mintedSupply721[token]++);\n    }\n\n    function ownerMint1155(\n        uint256 id,\n        uint256 amount,\n        address token,\n        address to\n    ) external nonReentrant {\n        if (\n            cumulativeSupply1155[token][id] + amount > maxSupply1155[token][id]\n        ) {\n            revert OdysseyLaunchPlatform_MaxSupplyCap();\n        }\n        cumulativeSupply1155[token][id] += amount;\n        OdysseyERC1155(token).mintBatch(to, id, amount);\n    }\n}\n\ncontract OdysseyRouter is OdysseyDatabase, ReentrancyGuard {\n    error OdysseyRouter_TokenIDSupplyMismatch();\n    error OdysseyRouter_WhitelistUpdateFail();\n    error OdysseyRouter_Unauthorized();\n    error OdysseyRouter_OwnerMintFailure();\n    error OdysseyRouter_BadTokenAddress();\n    error OdysseyRouter_BadOwnerAddress();\n    error OdysseyRouter_BadSenderAddress();\n    error OdysseyRouter_BadRecipientAddress();\n    error OdysseyRouter_BadTreasuryAddress();\n    error OdysseyRouter_BadAdminAddress();\n\n    constructor(\n        address treasury_,\n        address xpDirectory_,\n        address xp_,\n        address[] memory ohmCurrencies_\n    ) {\n        launchPlatform = address(new OdysseyLaunchPlatform());\n        factory = address(new OdysseyTokenFactory());\n        treasury = treasury_;\n        admin = msg.sender;\n        uint256 i;\n        for (; i < ohmCurrencies_.length; i++) {\n            ohmFamilyCurrencies[ohmCurrencies_[i]] = 1;\n        }\n        if (xp_ == address(0)) {\n            if (xpDirectory_ == address(0)) {\n                xpDirectory_ = address(new OdysseyXpDirectory());\n                OdysseyXpDirectory(xpDirectory_).setDefaultRewards(\n                    1,\n                    1,\n                    1,\n                    3,\n                    3,\n                    1\n                );\n                OdysseyXpDirectory(xpDirectory_).transferOwnership(admin);\n            }\n            xp_ = address(\n                new OdysseyXp(\n                    ERC20(ohmCurrencies_[0]),\n                    OdysseyXpDirectory(xpDirectory_),\n                    address(this),\n                    address(this),\n                    admin\n                )\n            );\n        }\n        xp = xp_;\n    }\n\n    function Factory() public view returns (OdysseyTokenFactory) {\n        return OdysseyTokenFactory(readSlotAsAddress(1));\n    }\n\n    function create1155(\n        string calldata name,\n        string calldata symbol,\n        string calldata baseURI,\n        OdysseyLib.Odyssey1155Info calldata info,\n        OdysseyLib.Percentage calldata treasuryPercentage,\n        address royaltyReceiver,\n        bool whitelist\n    ) external returns (address token) {\n        if (info.maxSupply.length != info.tokenIds.length) {\n            revert OdysseyRouter_TokenIDSupplyMismatch();\n        }\n        token = Factory().create1155(msg.sender, name, symbol, baseURI);\n        ownerOf[token] = msg.sender;\n        whitelistActive[token] = whitelist ? 1 : 0;\n        royaltyRecipient[token] = royaltyReceiver;\n        uint256 i;\n        for (; i < info.tokenIds.length; ++i) {\n            maxSupply1155[token][info.tokenIds[i]] = (info.maxSupply[i] == 0)\n                ? type(uint256).max\n                : info.maxSupply[i];\n        }\n\n        domainSeparator[token] = keccak256(\n            abi.encode(\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                keccak256(bytes(Strings.toHexString(uint160(token)))),\n                0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, // keccak256(bytes(\"1\"))\n                block.chainid,\n                token\n            )\n        );\n\n        if (OdysseyLib.compareDefaultPercentage(treasuryPercentage)) {\n            // Treasury % was greater than 3/100\n            treasuryCommission[token] = treasuryPercentage;\n        } else {\n            // Treasury % was less than 3/100, using 3/100 as default\n            treasuryCommission[token] = OdysseyLib.Percentage(3, 100);\n        }\n\n        if (info.reserveAmounts.length > 0) {\n            (bool success, bytes memory data) = launchPlatform.delegatecall(\n                abi.encodeWithSignature(\n                    \"mint1155OnCreate(uint256[],uint256[],address)\",\n                    info.tokenIds,\n                    info.reserveAmounts,\n                    token\n                )\n            );\n            if (!success) {\n                if (data.length == 0) revert();\n                assembly {\n                    revert(add(32, data), mload(data))\n                }\n            }\n        }\n        return token;\n    }\n\n    function create721(\n        string calldata name,\n        string calldata symbol,\n        string calldata baseURI,\n        uint256 maxSupply,\n        uint256 reserveAmount,\n        OdysseyLib.Percentage calldata treasuryPercentage,\n        address royaltyReceiver,\n        bool whitelist\n    ) external returns (address token) {\n        token = Factory().create721(msg.sender, name, symbol, baseURI);\n        ownerOf[token] = msg.sender;\n        maxSupply721[token] = (maxSupply == 0) ? type(uint256).max : maxSupply;\n        whitelistActive[token] = whitelist ? 1 : 0;\n        royaltyRecipient[token] = royaltyReceiver;\n        domainSeparator[token] = keccak256(\n            abi.encode(\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                keccak256(bytes(Strings.toHexString(uint160(token)))),\n                0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, // keccak256(bytes(\"1\"))\n                block.chainid,\n                token\n            )\n        );\n\n        if (OdysseyLib.compareDefaultPercentage(treasuryPercentage)) {\n            // Treasury % was greater than 3/100\n            treasuryCommission[token] = treasuryPercentage;\n        } else {\n            // Treasury % was less than 3/100, using 3/100 as default\n            treasuryCommission[token] = OdysseyLib.Percentage(3, 100);\n        }\n\n        if (reserveAmount > 0) {\n            (bool success, bytes memory data) = launchPlatform.delegatecall(\n                abi.encodeWithSignature(\n                    \"mint721OnCreate(uint256,address)\",\n                    reserveAmount,\n                    token\n                )\n            );\n            if (!success) {\n                if (data.length == 0) revert();\n                assembly {\n                    revert(add(32, data), mload(data))\n                }\n            }\n        }\n\n        return token;\n    }\n\n    function mintERC721(\n        bytes32[] calldata merkleProof,\n        bytes32 merkleRoot,\n        uint256 minPrice,\n        uint256 mintsPerUser,\n        address tokenAddress,\n        address currency,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable {\n        (bool success, bytes memory data) = launchPlatform.delegatecall(\n            abi.encodeWithSignature(\n                \"mintERC721(bytes32[],bytes32,uint256,uint256,address,address,uint8,bytes32,bytes32)\",\n                merkleProof,\n                merkleRoot,\n                minPrice,\n                mintsPerUser,\n                tokenAddress,\n                currency,\n                v,\n                r,\n                s\n            )\n        );\n        if (!success) {\n            if (data.length == 0) revert();\n            assembly {\n                revert(add(32, data), mload(data))\n            }\n        }\n    }\n\n    function batchMintERC721(OdysseyLib.BatchMint calldata batch)\n        public\n        payable\n    {\n        for (uint256 i = 0; i < batch.tokenAddress.length; i++) {\n            (bool success, bytes memory data) = launchPlatform.delegatecall(\n                abi.encodeWithSignature(\n                    \"mintERC721(bytes32[],bytes32,uint256,uint256,address,address,uint8,bytes32,bytes32)\",\n                    batch.merkleProof[i],\n                    batch.merkleRoot[i],\n                    batch.minPrice[i],\n                    batch.mintsPerUser[i],\n                    batch.tokenAddress[i],\n                    batch.currency[i],\n                    batch.v[i],\n                    batch.r[i],\n                    batch.s[i]\n                )\n            );\n            if (!success) {\n                if (data.length == 0) revert();\n                assembly {\n                    revert(add(32, data), mload(data))\n                }\n            }\n        }\n    }\n\n    function reserveERC721(\n        bytes32[] calldata merkleProof,\n        bytes32 merkleRoot,\n        uint256 minPrice,\n        uint256 mintsPerUser,\n        address tokenAddress,\n        address currency,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable {\n        (bool success, bytes memory data) = launchPlatform.delegatecall(\n            abi.encodeWithSignature(\n                \"reserveERC721(bytes32[],bytes32,uint256,uint256,address,address,uint8,bytes32,bytes32)\",\n                merkleProof,\n                merkleRoot,\n                minPrice,\n                mintsPerUser,\n                tokenAddress,\n                currency,\n                v,\n                r,\n                s\n            )\n        );\n        if (!success) {\n            if (data.length == 0) revert();\n            assembly {\n                revert(add(32, data), mload(data))\n            }\n        }\n    }\n\n    function batchReserveERC721(OdysseyLib.BatchMint calldata batch)\n        public\n        payable\n    {\n        for (uint256 i = 0; i < batch.tokenAddress.length; i++) {\n            (bool success, bytes memory data) = launchPlatform.delegatecall(\n                abi.encodeWithSignature(\n                    \"reserveERC721(bytes32[],bytes32,uint256,uint256,address,address,uint8,bytes32,bytes32)\",\n                    batch.merkleProof[i],\n                    batch.merkleRoot[i],\n                    batch.minPrice[i],\n                    batch.mintsPerUser[i],\n                    batch.tokenAddress[i],\n                    batch.currency[i],\n                    batch.v[i],\n                    batch.r[i],\n                    batch.s[i]\n                )\n            );\n            if (!success) {\n                if (data.length == 0) revert();\n                assembly {\n                    revert(add(32, data), mload(data))\n                }\n            }\n        }\n    }\n\n    function mintERC1155(\n        bytes32[] calldata merkleProof,\n        bytes32 merkleRoot,\n        uint256 minPrice,\n        uint256 mintsPerUser,\n        uint256 tokenId,\n        address tokenAddress,\n        address currency,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable {\n        (bool success, bytes memory data) = launchPlatform.delegatecall(\n            abi.encodeWithSignature(\n                \"mintERC1155(bytes32[],bytes32,uint256,uint256,uint256,address,address,uint8,bytes32,bytes32)\",\n                merkleProof,\n                merkleRoot,\n                minPrice,\n                mintsPerUser,\n                tokenId,\n                tokenAddress,\n                currency,\n                v,\n                r,\n                s\n            )\n        );\n        if (!success) {\n            if (data.length == 0) revert();\n            assembly {\n                revert(add(32, data), mload(data))\n            }\n        }\n    }\n\n    function batchMintERC1155(OdysseyLib.BatchMint calldata batch)\n        public\n        payable\n    {\n        for (uint256 i = 0; i < batch.tokenAddress.length; i++) {\n            (bool success, bytes memory data) = launchPlatform.delegatecall(\n                abi.encodeWithSignature(\n                    \"mintERC1155(bytes32[],bytes32,uint256,uint256,uint256,address,address,uint8,bytes32,bytes32)\",\n                    batch.merkleProof[i],\n                    batch.merkleRoot[i],\n                    batch.minPrice[i],\n                    batch.mintsPerUser[i],\n                    batch.tokenId[i],\n                    batch.tokenAddress[i],\n                    batch.currency[i],\n                    batch.v[i],\n                    batch.r[i],\n                    batch.s[i]\n                )\n            );\n            if (!success) {\n                if (data.length == 0) revert();\n                assembly {\n                    revert(add(32, data), mload(data))\n                }\n            }\n        }\n    }\n\n    function reserveERC1155(\n        bytes32[] calldata merkleProof,\n        bytes32 merkleRoot,\n        uint256 minPrice,\n        uint256 mintsPerUser,\n        uint256 tokenId,\n        address tokenAddress,\n        address currency,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable {\n        (bool success, bytes memory data) = launchPlatform.delegatecall(\n            abi.encodeWithSignature(\n                \"reserveERC1155(bytes32[],bytes32,uint256,uint256,uint256,address,address,uint8,bytes32,bytes32)\",\n                merkleProof,\n                merkleRoot,\n                minPrice,\n                mintsPerUser,\n                tokenId,\n                tokenAddress,\n                currency,\n                v,\n                r,\n                s\n            )\n        );\n        if (!success) {\n            if (data.length == 0) revert();\n            assembly {\n                revert(add(32, data), mload(data))\n            }\n        }\n    }\n\n    function batchReserveERC1155(OdysseyLib.BatchMint calldata batch)\n        public\n        payable\n    {\n        for (uint256 i = 0; i < batch.tokenAddress.length; i++) {\n            (bool success, bytes memory data) = launchPlatform.delegatecall(\n                abi.encodeWithSignature(\n                    \"reserveERC1155(bytes32[],bytes32,uint256,uint256,uint256,address,address,uint8,bytes32,bytes32)\",\n                    batch.merkleProof[i],\n                    batch.merkleRoot[i],\n                    batch.minPrice[i],\n                    batch.mintsPerUser[i],\n                    batch.tokenId[i],\n                    batch.tokenAddress[i],\n                    batch.currency[i],\n                    batch.v[i],\n                    batch.r[i],\n                    batch.s[i]\n                )\n            );\n            if (!success) {\n                if (data.length == 0) revert();\n                assembly {\n                    revert(add(32, data), mload(data))\n                }\n            }\n        }\n    }\n\n    function setWhitelistStatus(address addr, bool active) public {\n        if (msg.sender != ownerOf[addr]) {\n            revert OdysseyRouter_Unauthorized();\n        }\n        (bool success, ) = launchPlatform.delegatecall(\n            abi.encodeWithSignature(\n                \"setWhitelistStatus(address,bool)\",\n                addr,\n                active\n            )\n        );\n        if (!success) {\n            revert OdysseyRouter_WhitelistUpdateFail();\n        }\n    }\n\n    function ownerMint721(address token, address to) public {\n        if (ownerOf[token] != msg.sender) {\n            revert OdysseyRouter_Unauthorized();\n        }\n        (bool success, ) = launchPlatform.delegatecall(\n            abi.encodeWithSignature(\"ownerMint721(address,address)\", token, to)\n        );\n        if (!success) {\n            revert OdysseyRouter_OwnerMintFailure();\n        }\n    }\n\n    function ownerMint1155(\n        uint256 id,\n        uint256 amount,\n        address token,\n        address to\n    ) public {\n        if (ownerOf[token] != msg.sender) {\n            revert OdysseyRouter_Unauthorized();\n        }\n        (bool success, ) = launchPlatform.delegatecall(\n            abi.encodeWithSignature(\n                \"ownerMint1155(uint256,uint256,address,address)\",\n                id,\n                amount,\n                token,\n                to\n            )\n        );\n        if (!success) {\n            revert OdysseyRouter_OwnerMintFailure();\n        }\n    }\n\n    function setOwnerShip(address token, address newOwner) public {\n        if (token == address(0)) {\n            revert OdysseyRouter_BadTokenAddress();\n        }\n        if (newOwner == address(0)) {\n            revert OdysseyRouter_BadOwnerAddress();\n        }\n        if (msg.sender == address(0)) {\n            revert OdysseyRouter_BadSenderAddress();\n        }\n        if (ownerOf[token] != msg.sender) {\n            revert OdysseyRouter_Unauthorized();\n        }\n        ownerOf[token] = newOwner;\n    }\n\n    function setRoyaltyRecipient(address token, address recipient) public {\n        if (token == address(0)) {\n            revert OdysseyRouter_BadTokenAddress();\n        }\n        if (recipient == address(0)) {\n            revert OdysseyRouter_BadRecipientAddress();\n        }\n        if (msg.sender == address(0)) {\n            revert OdysseyRouter_BadSenderAddress();\n        }\n        if (ownerOf[token] != msg.sender) {\n            revert OdysseyRouter_Unauthorized();\n        }\n        royaltyRecipient[token] = recipient;\n    }\n\n    function setTreasury(address newTreasury) public {\n        if (msg.sender != admin) {\n            revert OdysseyRouter_Unauthorized();\n        }\n        if (msg.sender == address(0)) {\n            revert OdysseyRouter_BadSenderAddress();\n        }\n        if (newTreasury == address(0)) {\n            revert OdysseyRouter_BadTreasuryAddress();\n        }\n        treasury = newTreasury;\n    }\n\n    function setXP(address newXp) public {\n        if (msg.sender != admin) {\n            revert OdysseyRouter_Unauthorized();\n        }\n        if (msg.sender == address(0)) {\n            revert OdysseyRouter_BadSenderAddress();\n        }\n        if (newXp == address(0)) {\n            revert OdysseyRouter_BadTokenAddress();\n        }\n        xp = newXp;\n    }\n\n    function setAdmin(address newAdmin) public {\n        if (msg.sender != admin) {\n            revert OdysseyRouter_Unauthorized();\n        }\n        if (msg.sender == address(0)) {\n            revert OdysseyRouter_BadSenderAddress();\n        }\n        if (newAdmin == address(0)) {\n            revert OdysseyRouter_BadAdminAddress();\n        }\n        admin = newAdmin;\n    }\n\n    function setMaxSupply721(address token, uint256 amount) public {\n        if (ownerOf[token] != msg.sender) {\n            revert OdysseyRouter_Unauthorized();\n        }\n        maxSupply721[token] = amount;\n    }\n\n    function setMaxSupply1155(\n        address token,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts\n    ) public {\n        if (ownerOf[token] != msg.sender) {\n            revert OdysseyRouter_Unauthorized();\n        }\n        uint256 i;\n        for (; i < tokenIds.length; ++i) {\n            maxSupply1155[token][tokenIds[i]] = amounts[i];\n        }\n    }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasury_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"xpDirectory_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"xp_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"ohmCurrencies_\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"OdysseyLaunchPlatform_AlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyLaunchPlatform_FailedToPayERC20\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyLaunchPlatform_FailedToPayEther\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyLaunchPlatform_InsufficientFunds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyLaunchPlatform_MaxSupplyCap\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyLaunchPlatform_ReservedOrClaimedMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyLaunchPlatform_TokenDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyLaunchPlatform_TreasuryPayFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyRouter_BadAdminAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyRouter_BadOwnerAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyRouter_BadRecipientAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyRouter_BadSenderAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyRouter_BadTokenAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyRouter_BadTreasuryAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyRouter_OwnerMintFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyRouter_TokenIDSupplyMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyRouter_Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OdysseyRouter_WhitelistUpdateFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Factory\",\"outputs\":[{\"internalType\":\"contract OdysseyTokenFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MERKLE_TREE_ROOT_ERC1155_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MERKLE_TREE_ROOT_ERC721_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32[][]\",\"name\":\"merkleProof\",\"type\":\"bytes32[][]\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleRoot\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minPrice\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"mintsPerUser\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddress\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"currency\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct OdysseyLib.BatchMint\",\"name\":\"batch\",\"type\":\"tuple\"}],\"name\":\"batchMintERC1155\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32[][]\",\"name\":\"merkleProof\",\"type\":\"bytes32[][]\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleRoot\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minPrice\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"mintsPerUser\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddress\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"currency\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct OdysseyLib.BatchMint\",\"name\":\"batch\",\"type\":\"tuple\"}],\"name\":\"batchMintERC721\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32[][]\",\"name\":\"merkleProof\",\"type\":\"bytes32[][]\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleRoot\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minPrice\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"mintsPerUser\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddress\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"currency\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct OdysseyLib.BatchMint\",\"name\":\"batch\",\"type\":\"tuple\"}],\"name\":\"batchReserveERC1155\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32[][]\",\"name\":\"merkleProof\",\"type\":\"bytes32[][]\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleRoot\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minPrice\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"mintsPerUser\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddress\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"currency\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"v\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"r\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"s\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct OdysseyLib.BatchMint\",\"name\":\"batch\",\"type\":\"tuple\"}],\"name\":\"batchReserveERC721\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"maxSupply\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"reserveAmounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct OdysseyLib.Odyssey1155Info\",\"name\":\"info\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"internalType\":\"struct OdysseyLib.Percentage\",\"name\":\"treasuryPercentage\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"royaltyReceiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"whitelist\",\"type\":\"bool\"}],\"name\":\"create1155\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"internalType\":\"struct OdysseyLib.Percentage\",\"name\":\"treasuryPercentage\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"royaltyReceiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"whitelist\",\"type\":\"bool\"}],\"name\":\"create721\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cumulativeSupply1155\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cumulativeSupply721\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isReserved1155\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isReserved721\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"maxSupply1155\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxSupply721\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintsPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"mintERC1155\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintsPerUser\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"mintERC721\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintedSupply721\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ohmFamilyCurrencies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ownerMint1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ownerMint721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"}],\"name\":\"readSlotAsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintsPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"reserveERC1155\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintsPerUser\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"reserveERC721\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"royaltyRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMaxSupply1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxSupply721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwnerShip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"setRoyaltyRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"setWhitelistStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newXp\",\"type\":\"address\"}],\"name\":\"setXP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"treasuryCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistActive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"whitelistClaimed1155\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistClaimed721\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OdysseyRouter", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000cb7ec73fd2bca2596794804a6ef5475d0dc4f42700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000ab87046fbb341d058f17cbc4c1133f25a20a52f00000000000000000000000064aa3364f17a4d01c6f1751fd97c2bd3d7e7f1d500000000000000000000000004906695d6d12cf5459975d7c3c03356e4ccd460", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}