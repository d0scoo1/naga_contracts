{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LazlosPizzaShop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nimport './Types/Types.sol';\\n\\n/*\\n   __           _      _        ___ _                __ _                 \\n  / /  __ _ ___| | ___( )__    / _ (_)__________ _  / _\\\\ |__   ___  _ __  \\n / /  / _` |_  / |/ _ \\\\/ __|  / /_)/ |_  /_  / _` | \\\\ \\\\| '_ \\\\ / _ \\\\| '_ \\\\ \\n/ /__| (_| |/ /| | (_) \\\\__ \\\\ / ___/| |/ / / / (_| | _\\\\ \\\\ | | | (_) | |_) |\\n\\\\____/\\\\__,_/___|_|\\\\___/|___/ \\\\/    |_/___/___\\\\__,_| \\\\__/_| |_|\\\\___/| .__/ \\n                                                                   |_|    \\n\\nLazlosPizzaShop is the main contract for buying ingredients and baking pizza's out of Lazlo's kitchen.\\n*/\\ncontract LazlosPizzaShop is Ownable, ReentrancyGuard {\\n    using ECDSA for bytes32;\\n    using Counters for Counters.Counter;\\n    using Strings for uint256;\\n\\n    bool public mintingOn = true;\\n    bool public bakeRandomPizzaOn = true;\\n    uint256 public bakePizzaPrice = 0.01 ether;\\n    uint256 public unbakePizzaPrice = 0.05 ether;\\n    uint256 public rebakePizzaPrice = 0.01 ether;\\n    uint256 public randomBakePrice = 0.05 ether;\\n    address public pizzaContractAddress;\\n    address public ingredientsContractAddress;\\n    address private systemAddress;\\n    mapping(address => uint256) artistWithdrawalAmount;\\n    mapping(uint256 => mapping(address => bool)) isPaidByBlockAndAddress;\\n\\n    function setMintingOn(bool on) public onlyOwner {\\n        mintingOn = on;\\n    }\\n\\n    function setBakeRandomPizzaOn(bool on) public onlyOwner {\\n        bakeRandomPizzaOn = on;\\n    }\\n\\n    function setPizzaContractAddress(address addr) public onlyOwner {\\n        pizzaContractAddress = addr;\\n    }\\n\\n    function setIngredientsContractAddress(address addr) public onlyOwner {\\n        ingredientsContractAddress = addr;\\n    }\\n    \\n    function setSystemAddress(address addr) public onlyOwner {\\n        systemAddress = addr;\\n    }\\n\\n    function buyIngredients(uint256[] memory tokenIds, uint256[] memory amounts) public payable nonReentrant {\\n        require(mintingOn, 'minting must be on');\\n        \\n        uint256 expectedPrice;\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            uint256 tokenId = tokenIds[i];\\n            uint256 amount = amounts[i];\\n\\n            Ingredient memory ingredient = ILazlosIngredients(ingredientsContractAddress).getIngredient(tokenId);\\n            require(bytes(ingredient.name).length != 0, 'Ingredient does not exist');\\n            require(ingredient.supply >= amount, 'Not enough ingredient leftover.');\\n\\n            ILazlosIngredients(ingredientsContractAddress).decreaseIngredientSupply(tokenId, amount);\\n\\n            unchecked {\\n                expectedPrice += ingredient.price * amount;\\n            }\\n        }\\n        \\n        require(expectedPrice == msg.value, 'Invalid price.');\\n\\n        ILazlosIngredients(ingredientsContractAddress).mintIngredients(msg.sender, tokenIds, amounts);\\n    }\\n\\n    function bakePizza(uint256[] memory tokenIds) public payable nonReentrant returns (uint256) {\\n        require(mintingOn, 'minting must be on');\\n        require(msg.value == bakePizzaPrice, 'Invalid price.');\\n        return _bakePizza(tokenIds, true);\\n    }\\n\\n    function buyAndBakePizza(uint256[] memory tokenIds) public payable nonReentrant returns (uint256) {\\n        require(mintingOn, 'minting must be on');\\n\\n        // Validate that:\\n        //  1. None of these ingredients are sold out.\\n        //  2. The given eth is correct (cost of ingredients + bake price).\\n        uint256 expectedPrice = bakePizzaPrice;\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            uint256 tokenId = tokenIds[i];\\n\\n            Ingredient memory ingredient = ILazlosIngredients(ingredientsContractAddress).getIngredient(tokenId);\\n            require(ingredient.supply >= 1, 'Ingredient sold out.');\\n\\n            ILazlosIngredients(ingredientsContractAddress).decreaseIngredientSupply(tokenId, 1);\\n\\n            unchecked {\\n                expectedPrice += ingredient.price;\\n            }\\n        }\\n\\n        require(expectedPrice == msg.value, 'Invalid price.');\\n        return _bakePizza(tokenIds, false);\\n    }\\n    \\n    struct NumIngredientsUsed {\\n        uint16 cheeses;\\n        uint16 meats;\\n        uint16 toppings;\\n    }\\n\\n    function _bakePizza(uint256[] memory tokenIds, bool useBuyersIngredients) private returns (uint256) {\\n        Pizza memory pizza;\\n        return _addIngredientsToPizza(0, pizza, tokenIds, useBuyersIngredients);\\n    }\\n\\n    function _addIngredientsToPizza(\\n        uint256 pizzaTokenId,\\n        Pizza memory pizza,\\n        uint256[] memory tokenIds,\\n        bool useBuyersIngredients\\n    ) private returns (uint256) {\\n        // Calculate num ingredients already used in the pizza if its not a fresh bake.\\n        NumIngredientsUsed memory numIngredientsUsed;\\n\\n        if (pizzaTokenId != 0) {\\n            for (uint256 i; i<pizza.cheeses.length;) {\\n                if (pizza.cheeses[i] == 0) {\\n                    break;\\n                }\\n\\n                unchecked {\\n                    numIngredientsUsed.cheeses++;\\n                    i++;\\n                }\\n            }\\n\\n            for (uint256 i; i<pizza.meats.length;) {\\n                if (pizza.meats[i] == 0) {\\n                    break;\\n                }\\n\\n                unchecked {\\n                    numIngredientsUsed.meats++;\\n                    i++;\\n                }\\n            }\\n\\n            for (uint256 i; i<pizza.toppings.length;) {\\n                if (pizza.toppings[i] == 0) {\\n                    break;\\n                }\\n\\n                unchecked {\\n                    numIngredientsUsed.toppings++;\\n                    i++;\\n                }\\n            }\\n        }\\n        \\n        // Loop over each token and:\\n        //  1. Check that the buyer has the correct balance for each ingredient (if useBuyersIngredients is true).\\n        //  2. Collect the ingredients and validate that the correct amount of each ingredient is being used:\\n        //      - 1 Base\\n        //      - 1 Sauce\\n        //      - 1-3 Cheeses\\n        //      - 0-4 Meats\\n        //      - 0-4 Toppings\\n        uint256[] memory amounts = new uint256[](tokenIds.length);\\n        for (uint256 i = 0; i < tokenIds.length;) {\\n            uint256 tokenId = tokenIds[i];\\n\\n            if (useBuyersIngredients) {\\n                uint256 balance = ILazlosIngredients(ingredientsContractAddress).balanceOfAddress(msg.sender, tokenId);\\n                require(balance > 0, 'Missing ingredient.');\\n            }\\n            \\n            Ingredient memory ingredient = ILazlosIngredients(ingredientsContractAddress).getIngredient(tokenId);\\n            \\n            if (ingredient.ingredientType == IngredientType.Base) {\\n                require(pizza.base == 0, 'Cannot use more than 1 base.');\\n\\n                pizza.base = uint16(tokenId);\\n            \\n            } else if (ingredient.ingredientType == IngredientType.Sauce) {\\n                require(pizza.sauce == 0, 'Cannot use more than 1 sauce.');\\n\\n                pizza.sauce = uint16(tokenId);\\n            \\n            } else if (ingredient.ingredientType == IngredientType.Cheese) {\\n                unchecked {\\n                    numIngredientsUsed.cheeses++;\\n                }\\n                \\n                require(numIngredientsUsed.cheeses <= 3, 'Cannot use more than 3 cheeses.');\\n                \\n                pizza.cheeses[numIngredientsUsed.cheeses - 1] = uint16(tokenId);\\n            \\n            } else if (ingredient.ingredientType == IngredientType.Meat) {\\n                unchecked {\\n                    numIngredientsUsed.meats++;\\n                }\\n                \\n                require(numIngredientsUsed.meats <= 4, 'Cannot use more than 4 meats.');\\n                \\n                pizza.meats[numIngredientsUsed.meats - 1] = uint16(tokenId);\\n\\n            } else if (ingredient.ingredientType == IngredientType.Topping) {\\n                unchecked {\\n                    numIngredientsUsed.toppings++;\\n                }\\n                \\n                require(numIngredientsUsed.toppings <= 4, 'Cannot use more than 4 toppings.');\\n                \\n                pizza.toppings[numIngredientsUsed.toppings - 1] = uint16(tokenId);\\n            \\n            } else {\\n                revert('Invalid ingredient type.');\\n            }\\n\\n            amounts[i] = 1;\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        require(pizza.base != 0, 'A base is required.');\\n        require(pizza.sauce != 0, 'A sauce is required.');\\n        require(pizza.cheeses[0] != 0, 'At least one cheese is required.');\\n        validateNoDuplicateIngredients(pizza);\\n\\n        // Make sure to burn buyer's ingredients.\\n        if (useBuyersIngredients) {\\n            ILazlosIngredients(ingredientsContractAddress).burnIngredients(msg.sender, tokenIds, amounts);\\n        }\\n\\n        if (pizzaTokenId == 0) {\\n            // Now we mint a new pizza.\\n            return ILazlosPizzas(pizzaContractAddress).bake(msg.sender, pizza);\\n        \\n        } else {\\n            // Rebake pizza now.\\n            ILazlosPizzas(pizzaContractAddress).rebake(msg.sender, pizzaTokenId, pizza);\\n            return pizzaTokenId;\\n        }\\n    }\\n\\n    function validateNoDuplicateIngredients(Pizza memory pizza) internal pure {\\n        validateNoDuplicates3(pizza.cheeses);\\n        validateNoDuplicates4(pizza.meats);\\n        validateNoDuplicates4(pizza.toppings);\\n    }\\n\\n    function validateNoDuplicates3(uint16[3] memory arr) internal pure {\\n        for (uint256 i; i<arr.length;) {\\n            if (arr[i] == 0) {\\n                break;\\n            }\\n\\n            for (uint256 j; j<arr.length;) {\\n                if (arr[j] == 0) {\\n                    break;\\n                }\\n\\n                if (i == j) {\\n                    unchecked {\\n                        j++;\\n                    }\\n                    continue;\\n                }\\n\\n                require(arr[i] != arr[j], 'No duplicate ingredients.');      \\n\\n                unchecked {\\n                    j++;\\n                }\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    function validateNoDuplicates4(uint16[4] memory arr) internal pure {\\n        for (uint256 i; i<arr.length;) {\\n            if (arr[i] == 0) {\\n                break;\\n            }\\n\\n            for (uint256 j; j<arr.length;) {\\n                if (arr[j] == 0) {\\n                    break;\\n                }\\n\\n                if (i == j) {\\n                    unchecked {\\n                        j++;\\n                    }\\n                    continue;\\n                }\\n\\n                require(arr[i] != arr[j], 'No duplicate ingredients.');      \\n\\n                unchecked {\\n                    j++;\\n                }\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    function unbakePizza(uint256 pizzaTokenId) public payable nonReentrant {\\n        require(mintingOn, 'minting must be on');\\n        require(msg.value == unbakePizzaPrice, 'Invalid price.');\\n\\n        Pizza memory pizza = ILazlosPizzas(pizzaContractAddress).pizza(pizzaTokenId);\\n\\n        // Sum up the number of ingredients in this pizza.\\n        // Every pizza has at least 3 ingredients.\\n        uint256 numIngredientsInPizza = 3;\\n        for (uint256 i=1; i<3;) {\\n            if (pizza.cheeses[i] == 0) {\\n                break;\\n            }\\n\\n            numIngredientsInPizza++;\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        for (uint256 i; i<4;) {\\n            if (pizza.meats[i] == 0) {\\n                break;\\n            }\\n\\n            numIngredientsInPizza++;\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        for (uint256 i; i<4;) {\\n            if (pizza.toppings[i] == 0) {\\n                break;\\n            }\\n\\n            numIngredientsInPizza++;\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        // Build up tokenIds array.\\n        uint256[] memory tokenIds = new uint256[](numIngredientsInPizza);\\n        tokenIds[0] = uint256(pizza.base);\\n        tokenIds[1] = uint256(pizza.sauce);\\n        uint256 tokenIdsIndex = 2;\\n\\n        for (uint256 i=0; i<3;) {\\n            if (pizza.cheeses[i] == 0) {\\n                break;\\n            }\\n\\n            tokenIds[tokenIdsIndex] = pizza.cheeses[i];\\n            unchecked {\\n                tokenIdsIndex++;\\n                i++;\\n            }\\n        }\\n\\n        for (uint256 i; i<4;) {\\n            if (pizza.meats[i] == 0) {\\n                break;\\n            }\\n\\n            tokenIds[tokenIdsIndex] = pizza.meats[i];\\n            unchecked {\\n                tokenIdsIndex++;\\n                i++;\\n            }\\n        }\\n\\n        for (uint256 i; i<4;) {\\n            if (pizza.toppings[i] == 0) {\\n                break;\\n            }\\n\\n            tokenIds[tokenIdsIndex] = pizza.toppings[i];\\n            unchecked {\\n                tokenIdsIndex++;\\n                i++;\\n            }\\n        }\\n\\n        // Create amounts array which is just a bunch of 1's.\\n        uint256[] memory amounts = new uint256[](numIngredientsInPizza);\\n        for (uint256 i; i<numIngredientsInPizza;) {\\n            amounts[i] = 1;\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        ILazlosIngredients(ingredientsContractAddress).mintIngredients(msg.sender, tokenIds, amounts);\\n        ILazlosPizzas(pizzaContractAddress).burn(pizzaTokenId);\\n    }\\n\\n    function rebakePizza(uint256 pizzaTokenId, uint256[] memory ingredientTokenIdsToAdd, uint256[] memory ingredientTokenIdsToRemove) public payable nonReentrant {\\n        require(mintingOn, 'minting must be on');\\n        require(msg.value == rebakePizzaPrice, 'Invalid price.');\\n\\n        Pizza memory pizza = ILazlosPizzas(pizzaContractAddress).pizza(pizzaTokenId);\\n\\n        // Loop over ingredients to be removed from pizza and update the pizza accordingly.\\n        for (uint256 i; i<ingredientTokenIdsToRemove.length;) {\\n            uint256 tokenIdToRemove = ingredientTokenIdsToRemove[i];\\n\\n            Ingredient memory ingredient = ILazlosIngredients(ingredientsContractAddress).getIngredient(tokenIdToRemove);\\n\\n            if (ingredient.ingredientType == IngredientType.Base) {\\n                pizza.base = 0;\\n            \\n            } else if (ingredient.ingredientType == IngredientType.Sauce) {\\n                pizza.sauce = 0;\\n            \\n            } else if (ingredient.ingredientType == IngredientType.Cheese) {\\n                bool foundCheese;\\n                uint16[3] memory updatedCheeses;\\n                uint256 updatedCheeseIndex;\\n                for (uint256 j; j<updatedCheeses.length;) {\\n                    uint256 existingCheese = pizza.cheeses[j];\\n                    if (existingCheese == 0) {\\n                        break;\\n                    }\\n\\n                    if (existingCheese != tokenIdToRemove) {\\n                        updatedCheeses[updatedCheeseIndex] = uint16(existingCheese);\\n\\n                        unchecked {\\n                            updatedCheeseIndex++;\\n                        }\\n                    \\n                    } else {\\n                        foundCheese = true;\\n                    }\\n\\n                    unchecked {\\n                        j++;\\n                    }\\n                }\\n\\n                require(foundCheese, 'Could not find cheese to be removed.');\\n                pizza.cheeses = updatedCheeses;\\n            \\n            } else if (ingredient.ingredientType == IngredientType.Meat) {\\n                bool foundMeat;\\n                uint16[4] memory updatedMeats;\\n                uint256 updatedMeatIndex;\\n                for (uint256 j; j<updatedMeats.length;) {\\n                    uint256 existingMeat = pizza.meats[j];\\n                    if (existingMeat == 0) {\\n                        break;\\n                    }\\n\\n                    if (existingMeat != tokenIdToRemove) {\\n                        updatedMeats[updatedMeatIndex] = uint16(existingMeat);\\n\\n                        unchecked {\\n                            updatedMeatIndex++;\\n                        }\\n                    \\n                    } else {\\n                        foundMeat = true;\\n                    }\\n\\n                    unchecked {\\n                        j++;\\n                    }\\n                }\\n\\n                require(foundMeat, 'Could not find meat to be removed.');\\n                pizza.meats = updatedMeats;\\n\\n            } else if (ingredient.ingredientType == IngredientType.Topping) {\\n                bool foundTopping;\\n                uint16[4] memory updatedToppings;\\n                uint256 updatedToppingIndex;\\n                for (uint256 j; j<updatedToppings.length;) {\\n                    uint256 existingTopping = pizza.toppings[j];\\n                    if (existingTopping == 0) {\\n                        break;\\n                    }\\n\\n                    if (existingTopping != tokenIdToRemove) {\\n                        updatedToppings[updatedToppingIndex] = uint16(existingTopping);\\n\\n                        unchecked {\\n                            updatedToppingIndex++;\\n                        }\\n                    \\n                    } else {\\n                        foundTopping = true;\\n                    }\\n\\n                    unchecked {\\n                        j++;\\n                    }\\n                }\\n\\n                require(foundTopping, 'Could not find topping to be removed.');\\n                pizza.toppings = updatedToppings;\\n            \\n            } else {\\n                revert('Invalid ingredient type.');\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        } \\n\\n        _addIngredientsToPizza(pizzaTokenId, pizza, ingredientTokenIdsToAdd, true);\\n    }\\n\\n    function bakeRandomPizza(uint256[] memory tokenIds, uint256 timestamp, bytes32 r, bytes32 s, uint8 v) public payable nonReentrant returns (uint256) {\\n        require(mintingOn, 'minting must be on');\\n        require(bakeRandomPizzaOn, 'bakeRandomPizza must be on');\\n        require(randomBakePrice == msg.value, 'Invalid price.');\\n        require(block.timestamp - timestamp < 300, 'timestamp expired');\\n\\n        bytes32 messageHash = keccak256(abi.encodePacked(\\n            msg.sender,\\n            timestamp,\\n            tokenIds\\n        ));\\n\\n        address signerAddress = verifySignature(messageHash, r, s, v);\\n        bool validSignature = signerAddress == systemAddress;\\n        require(validSignature, 'Invalid signature.');\\n\\n        // Validate that:\\n        //  1. None of these ingredients are sold out.\\n        uint256 expectedPrice = bakePizzaPrice;\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            uint256 tokenId = tokenIds[i];\\n\\n            Ingredient memory ingredient = ILazlosIngredients(ingredientsContractAddress).getIngredient(tokenId);\\n            require(ingredient.supply >= 1, 'Ingredient sold out.');\\n\\n            ILazlosIngredients(ingredientsContractAddress).decreaseIngredientSupply(tokenId, 1);\\n\\n            unchecked {\\n                expectedPrice += ingredient.price;\\n            }\\n        }\\n\\n        return _bakePizza(tokenIds, false);\\n    }\\n\\n    function verifySignature(bytes32 messageHash, bytes32 r, bytes32 s, uint8 v) public pure returns (address) {\\n        bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\n        bytes memory prefixedMessage = abi.encodePacked(prefix, messageHash);\\n        bytes32 hashedMessage = keccak256(prefixedMessage);\\n        return ecrecover(hashedMessage, v, r, s);\\n    }\\n\\n    function artistWithdraw() public nonReentrant {\\n        uint256 amountToBePayed = artistAllowedWithdrawalAmount(msg.sender);\\n        artistWithdrawalAmount[msg.sender] += amountToBePayed;\\n\\n        (bool success,) = msg.sender.call{value : amountToBePayed}('');\\n        require(success, \\\"Withdrawal failed.\\\");\\n    }\\n\\n    function artistAllowedWithdrawalAmount(address artist) public view returns( uint256) {\\n        uint256 earnedCommission = artistTotalCommission(artist);\\n        uint256 amountWithdrawn = artistWithdrawalAmount[artist];\\n\\n        require(earnedCommission > amountWithdrawn, \\\"Hasn't earned any more commission.\\\");\\n        uint256 withdrawalAmount = earnedCommission - amountWithdrawn;\\n        return withdrawalAmount;\\n    }\\n\\n    function artistTotalCommission(address artist) public view returns (uint256) {\\n        uint256 numIngredients = ILazlosIngredients(ingredientsContractAddress).getNumIngredients();\\n\\n        uint256 artistCommission;\\n        for (uint256 tokenId = 1; tokenId <= numIngredients; tokenId++) {\\n            Ingredient memory ingredient = ILazlosIngredients(ingredientsContractAddress).getIngredient(tokenId);\\n\\n            if (ingredient.artist != artist) {\\n                continue;\\n            }\\n\\n            uint256 numSold = ingredient.initialSupply - ingredient.supply;\\n            uint256 ingredientRevenue = numSold * ingredient.price;\\n            uint256 artistsIngredientCommission = ingredientRevenue / 10;\\n            artistCommission += artistsIngredientCommission;\\n        }\\n\\n        return artistCommission;\\n    }\\n\\n    struct Payout {\\n        uint256 payoutBlock;\\n        uint256 amount;\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n    }\\n\\n    function redeemPayout(Payout[] memory payouts) public nonReentrant {\\n        uint256 totalPayout;\\n        for (uint256 i; i < payouts.length; i++) {\\n            Payout memory payout = payouts[i];\\n\\n            bytes32 messageHash = keccak256(abi.encodePacked(\\n                payout.payoutBlock,\\n                msg.sender,\\n                payout.amount\\n            ));\\n            address signerAddress = verifySignature(messageHash, payout.r, payout.s, payout.v);\\n            bool validSignature = signerAddress == systemAddress;\\n            require(validSignature, 'Invalid signature.');\\n\\n            require(!isPaidByBlockAndAddress[payout.payoutBlock][msg.sender], 'Address already been paid for this block.');\\n\\n            isPaidByBlockAndAddress[payout.payoutBlock][msg.sender] = true;\\n            totalPayout += payout.amount;\\n        }\\n\\n        if (totalPayout > 0) {\\n            (bool success,) = msg.sender.call{value : totalPayout}('');\\n            require(success, \\\"Withdrawal failed.\\\");\\n        }\\n    }\\n\\n    function isPaidOutForBlock(address addr, uint256 payoutBlock) public view returns (bool) {\\n        return isPaidByBlockAndAddress[payoutBlock][addr];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Types/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nenum IngredientType {\\n    Base,\\n    Sauce,\\n    Cheese,\\n    Meat,\\n    Topping\\n}\\n\\nstruct Ingredient {\\n    string name;\\n    IngredientType ingredientType;\\n    address artist;\\n    uint256 price;\\n    uint256 supply;\\n    uint256 initialSupply;\\n}\\n\\nstruct Pizza {\\n    uint16 base;\\n    uint16 sauce;\\n    uint16[3] cheeses;\\n    uint16[4] meats;\\n    uint16[4] toppings;\\n}\\n\\ninterface ILazlosIngredients {\\n    function getNumIngredients() external view returns (uint256);\\n    function getIngredient(uint256 tokenId) external view returns (Ingredient memory);\\n    function increaseIngredientSupply(uint256 tokenId, uint256 amount) external;\\n    function decreaseIngredientSupply(uint256 tokenId, uint256 amount) external;\\n    function mintIngredients(address addr, uint256[] memory tokenIds, uint256[] memory amounts) external;\\n    function burnIngredients(address addr, uint256[] memory tokenIds, uint256[] memory amounts) external;\\n    function balanceOfAddress(address addr, uint256 tokenId) external view returns (uint256);\\n}\\n\\ninterface ILazlosPizzas {\\n    function bake(address baker, Pizza memory pizza) external returns (uint256);\\n    function rebake(address baker, uint256 pizzaTokenId, Pizza memory pizza) external;\\n    function pizza(uint256 tokenId) external view returns (Pizza memory);\\n    function burn(uint256 tokenId) external;\\n}\\n\\ninterface ILazlosRendering {\\n    function ingredientTokenMetadata(uint256 id) external view returns (string memory); \\n    function pizzaTokenMetadata(uint256 id) external view returns (string memory); \\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"}],\"name\":\"artistAllowedWithdrawalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"}],\"name\":\"artistTotalCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"artistWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"bakePizza\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bakePizzaPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"bakeRandomPizza\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bakeRandomPizzaOn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"buyAndBakePizza\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"buyIngredients\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ingredientsContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"payoutBlock\",\"type\":\"uint256\"}],\"name\":\"isPaidOutForBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintingOn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pizzaContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomBakePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pizzaTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ingredientTokenIdsToAdd\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ingredientTokenIdsToRemove\",\"type\":\"uint256[]\"}],\"name\":\"rebakePizza\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebakePizzaPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"payoutBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct LazlosPizzaShop.Payout[]\",\"name\":\"payouts\",\"type\":\"tuple[]\"}],\"name\":\"redeemPayout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"on\",\"type\":\"bool\"}],\"name\":\"setBakeRandomPizzaOn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setIngredientsContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"on\",\"type\":\"bool\"}],\"name\":\"setMintingOn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setPizzaContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setSystemAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pizzaTokenId\",\"type\":\"uint256\"}],\"name\":\"unbakePizza\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unbakePizzaPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"verifySignature\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "LazlosPizzaShop", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}