{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"Epigeon.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.4.11;\\n\\nimport \\\"./EpigeonInterfaces.sol\\\";\\n\\n//----------------------------------------------------------------------------------------------------\\n\\ncontract NameAndPublicKeyDirectory is INameAndPublicKeyDirectory{\\n    \\n    mapping (address =\\u003e string) internal addressToPublicKey;\\n    mapping (address =\\u003e string) internal addressToUserName;\\n    mapping (string =\\u003e address) internal userNameToAddress;\\n\\t\\n\\tEpigeon epigeonAddress;\\n\\tuint256 public uniqueNamePrice;\\n\\t\\n\\tconstructor (){\\n        epigeonAddress = Epigeon(msg.sender);\\n    }\\n    \\n    function getPublicKeyForAddress (address owner) public view returns (string key){\\n        return addressToPublicKey[owner];\\n    }\\n    \\n    function getUserNameForAddress (address owner) public view returns (string name){\\n        return addressToUserName[owner];\\n    }\\n    \\n    function setPublicKeyToAddress (string key) public {\\n        addressToPublicKey[msg.sender] = key;\\n    }\\n\\t\\n\\tfunction setUniqueNamePrice (uint256 price) public {\\n\\t\\trequire(msg.sender == epigeonAddress.owner(), \\\"Only Epigeon owner\\\");\\n        uniqueNamePrice = price;\\n    }\\n    \\n    function setUserNameToAddress (string name) public payable {\\n        require(userNameToAddress[name] == msg.sender || userNameToAddress[name] == 0, \\\"Name is already in use\\\");\\n        require(msg.value \\u003e= uniqueNamePrice, \\\"Not enough value\\\");\\n        delete userNameToAddress[addressToUserName[msg.sender]];\\n        addressToUserName[msg.sender] = name;\\n        userNameToAddress[name] = msg.sender;\\n\\t\\tepigeonAddress.owner().transfer(address(this).balance);\\n    }\\n\\t\\n\\tfunction transferUniqueName (address toAddress) public {\\n\\t\\taddressToUserName[toAddress]= addressToUserName[msg.sender];\\n\\t\\tuserNameToAddress[addressToUserName[toAddress]] = toAddress;\\n\\t\\tdelete addressToUserName[msg.sender];\\n    }\\n}\\n//----------------------------------------------------------------------------------------------------\\n\\ncontract PigeonDestinationDirectory is IPigeonDestinationDirectory{\\n    \\n    address public epigeonAddress;\\n    \\n    mapping (address =\\u003e address[]) internal toAddressToPigeon;\\n    mapping (address =\\u003e uint256) internal pigeonToToAddressIndex;\\n    mapping (address =\\u003e bool) internal pigeonToAddressExists;\\n    \\n    event PigeonSent(address toAddress);\\n    \\n    constructor (){\\n        epigeonAddress = msg.sender;\\n    }\\n    \\n    function changeToAddress(address newToAddress, address oldToAddress) public {\\n        //Check if the call is from a CryptoPigeon\\n        require(_isPigeon(msg.sender), \\\"Available only for Epigeon\\u0027s pigeon contracts\\\");\\n        ICryptoPigeon pigeon = ICryptoPigeon(msg.sender);\\n        require(pigeonToAddressExists[msg.sender] == true, \\\"Pigeon has no recipient entry to change\\\");\\n        \\n        //Push new to address\\n        toAddressToPigeon[newToAddress].push(pigeon);\\n        pigeonToToAddressIndex[pigeon] = toAddressToPigeon[newToAddress].length-1;\\n        \\n        //Delete old to address\\n        address pigeonToRemove = pigeon;\\n        uint256 pigeonToRemoveIndex = pigeonToToAddressIndex[pigeon];\\n        uint256 lastIdIndex = toAddressToPigeon[oldToAddress].length - 1;\\n        if (toAddressToPigeon[oldToAddress][lastIdIndex] != pigeonToRemove)\\n        {\\n          address lastPigeon = toAddressToPigeon[oldToAddress][lastIdIndex];\\n          toAddressToPigeon[oldToAddress][pigeonToToAddressIndex[pigeonToRemove]] = lastPigeon;\\n          pigeonToToAddressIndex[lastPigeon] = pigeonToRemoveIndex;\\n        }\\n        delete toAddressToPigeon[oldToAddress][lastIdIndex];\\n        toAddressToPigeon[oldToAddress].length--;\\n        emit PigeonSent(newToAddress);\\n    }\\n    \\n    function deleteToAddress(address oldToAddress) public {\\n        //Check if the call is from a CryptoPigeon\\n        require(_isPigeon(msg.sender), \\\"Available only for Epigeon\\u0027s pigeon contracts\\\");\\n        ICryptoPigeon pigeon = ICryptoPigeon(msg.sender);\\n        \\n        //Delete old to address \\n        address pigeonToRemove = pigeon;\\n        uint256 pigeonToRemoveIndex = pigeonToToAddressIndex[pigeon];\\n        uint256 lastIdIndex = toAddressToPigeon[oldToAddress].length - 1;\\n        if (toAddressToPigeon[oldToAddress][lastIdIndex] != pigeonToRemove)\\n        {\\n          address lastPigeon = toAddressToPigeon[oldToAddress][lastIdIndex];\\n          toAddressToPigeon[oldToAddress][pigeonToToAddressIndex[pigeonToRemove]] = lastPigeon;\\n          pigeonToToAddressIndex[lastPigeon] = pigeonToRemoveIndex;\\n        }\\n        delete toAddressToPigeon[oldToAddress][lastIdIndex];\\n        toAddressToPigeon[oldToAddress].length--;\\n        \\n        pigeonToAddressExists[pigeon] = false;\\n    }\\n    \\n    function deleteToAddressByEpigeon(address pigeon) public {\\n        require(epigeonAddress == msg.sender, \\\"Available only for Epigeon Smart Contract\\\");\\n        address pToAddress = ICryptoPigeon(pigeon).toAddress();\\n        address pigeonToRemove = pigeon;\\n        \\n        //Delete to address\\n        if (ICryptoPigeon(pigeon).hasFlown()){\\n            uint256 pigeonToRemoveIndex = pigeonToToAddressIndex[pigeon];\\n            uint256 lastIdIndex = toAddressToPigeon[pToAddress].length - 1;\\n            if (toAddressToPigeon[pToAddress][lastIdIndex] != pigeonToRemove)\\n            {\\n              address alastPigeon = toAddressToPigeon[pToAddress][lastIdIndex];\\n              toAddressToPigeon[pToAddress][pigeonToToAddressIndex[pigeonToRemove]] = alastPigeon;\\n              pigeonToToAddressIndex[alastPigeon] = pigeonToRemoveIndex;\\n            }\\n            delete toAddressToPigeon[pToAddress][lastIdIndex];\\n            toAddressToPigeon[pToAddress].length--;\\n         }\\n         pigeonToAddressExists[pigeon] = false;\\n    }\\n    \\n    function pigeonSentToAddressByIndex(address toAddress, uint index) public view returns (address rpaddress){\\n        rpaddress = toAddressToPigeon[toAddress][index];\\n    }\\n    \\n    function pigeonsSentToAddressLenght(address toAddress) public view returns (uint256 length){\\n        length = toAddressToPigeon[toAddress].length;\\n    }\\n    \\n    function setToAddress(address newToAddress) public {\\n        //Check if the call is from a CryptoPigeon\\n        require(_isPigeon(msg.sender), \\\"Available only for Epigeon\\u0027s pigeon contracts\\\");\\n        ICryptoPigeon pigeon = ICryptoPigeon(msg.sender);\\n        \\n        //Push new to address\\n        require(pigeonToAddressExists[msg.sender] != true, \\\"Pigeon already has recipient entry\\\");\\n        toAddressToPigeon[newToAddress].push(pigeon);\\n        pigeonToToAddressIndex[pigeon] = toAddressToPigeon[newToAddress].length-1;\\n        \\n        pigeonToAddressExists[pigeon] = true;\\n        emit PigeonSent(newToAddress);\\n    }\\n    \\n    function _isPigeon (address sender) internal view returns (bool indeed){\\n        ICryptoPigeon pigeon = ICryptoPigeon(sender);\\n        return IEpigeon(epigeonAddress).validPigeon(sender, pigeon.owner());\\n    }\\n}\\n//----------------------------------------------------------------------------------------------------\\n\\ncontract Epigeon is IEpigeon{\\n\\n    address public owner;\\n    string public egigeonURI;\\n    address private _nftContractAddress;\\n\\n    INameAndPublicKeyDirectory private _nameAndKeyDirectory;\\n    IPigeonDestinationDirectory private _pigeonDestinations;\\n\\n    uint256[] factoryIds;\\n    mapping (address =\\u003e bool) disabledFactories;\\n    mapping (uint256 =\\u003e address) factoryIdtoAddress;\\n\\n    mapping (address =\\u003e address[]) internal ownerToPigeon;\\n    mapping (address =\\u003e uint256) internal pigeonToOwnerIndex;\\n\\n    event PigeonCreated(ICryptoPigeon pigeon);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor (){ \\n        owner = msg.sender;\\n        _nameAndKeyDirectory = new NameAndPublicKeyDirectory();\\n        _pigeonDestinations = new PigeonDestinationDirectory();\\n    }   \\n\\n    function addFactory(address factoryAddress) public {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        IPigeonFactory factory = IPigeonFactory(factoryAddress);\\n        require(factory.iAmFactory(), \\\"Not a factory\\\");\\n        require(factory.amIEpigeon(), \\\"Not the factory\\u0027s Epigeon\\\");\\n        require(factoryIdtoAddress[factory.factoryId()] == address(0), \\\"Existing Factory ID\\\");\\n        factoryIds.push(factory.factoryId());\\n        factoryIdtoAddress[factory.factoryId()] = factory;\\n        disabledFactories[factory] = false;\\n    }\\n\\n    function burnPigeon(address pigeon) public {\\n        require((_nftContractAddress == msg.sender) || ((IEpigeonNFT(_nftContractAddress).isTokenizedPigeon(pigeon) == false) \\u0026\\u0026 (ICryptoPigeon(pigeon).owner() == msg.sender)), \\\"Not authorized\\\");\\n        address pOwner = ICryptoPigeon(pigeon).owner();\\n        address pigeonToRemove = pigeon;\\n        \\n        //Delete old owner address\\n        uint256 pigeonToRemoveIndex = pigeonToOwnerIndex[pigeon];\\n        uint256 lastIdIndex = ownerToPigeon[pOwner].length - 1;\\n        if (ownerToPigeon[pOwner][lastIdIndex] != pigeonToRemove)\\n        {\\n          address lastPigeon = ownerToPigeon[pOwner][lastIdIndex];\\n          ownerToPigeon[pOwner][pigeonToOwnerIndex[pigeonToRemove]] = lastPigeon;\\n          pigeonToOwnerIndex[lastPigeon] = pigeonToRemoveIndex;       \\n        }\\n        delete ownerToPigeon[pOwner][lastIdIndex];\\n        ownerToPigeon[pOwner].length--;\\n         \\n        //Delete to address\\n        _pigeonDestinations.deleteToAddressByEpigeon(pigeon);\\n        \\n        //Burn contract too\\n        ICryptoPigeon(pigeon).burnPigeon();        \\n    }\\n    \\n    function createCryptoPigeon(uint256 factoryId) public payable returns (address pigeonAddress) {\\n        require(msg.value \\u003e= getPigeonPriceForFactory(factoryId), \\\"Not enough value\\\"); \\n        return _createPigeon(msg.sender, factoryId);\\n    }\\n    \\n    function createCryptoPigeonByLatestFactory() public payable returns (address pigeonAddress) {\\n        require(msg.value \\u003e= getPigeonPriceForFactory(getLastFactoryId()), \\\"Not enough value\\\");\\n        return _createPigeon(msg.sender, getLastFactoryId());\\n    }\\n    \\n    function createCryptoPigeonForToken(address ERC20Token, uint256 factoryId) public returns (address pigeonAddress) {\\n        require(getPigeonTokenPriceForFactory(ERC20Token, factoryId) \\u003e 0, \\\"Price for token not available\\\");\\n        require(IERC20(ERC20Token).balanceOf(msg.sender) \\u003e= getPigeonTokenPriceForFactory(ERC20Token, factoryId), \\\"Not enough balance\\\");\\n        require(IERC20(ERC20Token).allowance(msg.sender, address(this)) \\u003e= getPigeonTokenPriceForFactory(ERC20Token, factoryId), \\\"Not enough allowance\\\");\\n        IERC20(ERC20Token).transferFrom(msg.sender, owner, getPigeonTokenPriceForFactory(ERC20Token, factoryId));\\n        return _createPigeon(msg.sender, factoryId);\\n    }\\n    \\n    function createCryptoPigeonNFT(address to, uint256 factoryId) public returns (address pigeonAddress) {\\n        require(_nftContractAddress == msg.sender, \\\"Available only for the NFT contract\\\");   \\n        return _createPigeon(to, factoryId);\\n    }\\n    \\n    function disableFactory(uint256 factoryId) public {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        disabledFactories[factoryIdtoAddress[factoryId]] = true;\\n    }\\n    \\n    function enableFactory(uint256 factoryId) public {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        require(factoryIdtoAddress[factoryId] != address(0));\\n        disabledFactories[factoryIdtoAddress[factoryId]] = false;\\n    }\\n    \\n    function getFactoryAddresstoId(uint256 id) public view returns (address factory){\\n        return factoryIdtoAddress[id];\\n    }\\n    \\n    function getFactoryCount() public view returns (uint256 count){\\n        return factoryIds.length;\\n    }\\n    \\n    function getIdforFactory(uint256 index) public view returns (uint256 id){\\n        return factoryIds[index];\\n    }\\n    \\n    function getLastFactoryId() public view returns (uint256 id){\\n        return factoryIds[factoryIds.length-1];\\n    }\\n    \\n    function getPigeonPriceForFactory(uint256 factoryId) public view returns (uint256 price){\\n        return IPigeonFactory(factoryIdtoAddress[factoryId]).mintingPrice();\\n    }\\n    \\n    function getPigeonTokenPriceForFactory(address ERC20Token, uint256 factoryId) public view returns (uint256 price){\\n        return IPigeonFactory(factoryIdtoAddress[factoryId]).getFactoryTokenPrice(ERC20Token);\\n    }\\n    \\n    function isFactoryDisabled(address factoryAddress) public view returns (bool disabled){\\n        return disabledFactories[factoryAddress];\\n    }\\n    \\n    function nameAndKeyDirectory() external view returns (INameAndPublicKeyDirectory directory){\\n        return _nameAndKeyDirectory;\\n    }\\n    \\n    function nftContractAddress() external view returns (address _nftcontract){\\n        return _nftContractAddress;\\n    }\\n\\n    function payout() public {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        owner.transfer(address(this).balance);\\n    }\\n    \\n    function pigeonDestinations() external view returns (IPigeonDestinationDirectory destinations){\\n        return _pigeonDestinations;\\n    }\\n    \\n    function pigeonsCountOfOwner(address pigeonOwner) public view returns (uint256 length){\\n        length = ownerToPigeon[pigeonOwner].length;\\n        return length;\\n    }\\n    \\n    function pigeonOfOwnerByIndex(address pigeonOwner, uint index) public view returns (address rpaddress){\\n        rpaddress = ownerToPigeon[pigeonOwner][index];\\n        return rpaddress;\\n    }\\n    \\n    function setNFTContractAddress(address nftContract) public { \\n        require(owner == msg.sender, \\\"Only owner\\\");\\n        require(_nftContractAddress == address(0), \\\"NFT contract already set\\\");\\n        _nftContractAddress = nftContract;\\n    }\\n    \\n    function setUri(string uri) public {  \\n        require(owner == msg.sender, \\\"Only owner\\\");\\n        egigeonURI = uri;\\n    }\\n    \\n    function transferOwnership(address newOwner) public {    \\n        require(owner == msg.sender, \\\"Only owner\\\");\\n        require(newOwner != address(0), \\\"Zero address\\\");\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner.transfer(address(this).balance);\\n        owner = newOwner;\\n    }\\n    \\n    function transferPigeon(address from, address to, address pigeon) public {\\n    \\n        if (IEpigeonNFT(_nftContractAddress).isTokenizedPigeon(pigeon)) {\\n            require(_nftContractAddress == msg.sender, \\\"Tokenized Pigeon can only be transferred by NFT contract\\\");\\n        }\\n        else{\\n            require(ICryptoPigeon(pigeon).owner() == msg.sender || pigeon == msg.sender, \\\"Only pigeon owner\\\");\\n        }\\n        \\n        //Push new owner address\\n        ownerToPigeon[to].push(pigeon);\\n        pigeonToOwnerIndex[pigeon] = ownerToPigeon[to].length-1;\\n        \\n        //Delete old owner address\\n        address pigeonToRemove = pigeon;\\n        uint256 pigeonToRemoveIndex = pigeonToOwnerIndex[pigeon];\\n        uint256 lastIdIndex = ownerToPigeon[from].length - 1;\\n        if (ownerToPigeon[from][lastIdIndex] != pigeonToRemove)\\n        {\\n          address lastPigeon = ownerToPigeon[from][lastIdIndex];\\n          ownerToPigeon[from][pigeonToOwnerIndex[pigeonToRemove]] = lastPigeon;\\n          pigeonToOwnerIndex[lastPigeon] = pigeonToRemoveIndex;\\n          \\n        }\\n        delete ownerToPigeon[from][lastIdIndex];\\n        ownerToPigeon[from].length--;\\n        \\n        //Delete old to address\\n        _pigeonDestinations.deleteToAddressByEpigeon(pigeon);\\n         \\n        //Transfer contract too\\n        ICryptoPigeon(pigeon).transferPigeon(to);\\n    }\\n    \\n    function validPigeon(address pigeon, address pigeonOwner) public view returns (bool valid){\\n        require(pigeon != address(0), \\\"Null address\\\");\\n        return ownerToPigeon[pigeonOwner][pigeonToOwnerIndex[pigeon]] == pigeon;\\n    }\\n    \\n    function _createPigeon(address to, uint256 factoryId) internal returns (address pigeonAddress) {\\n        require(isFactoryDisabled(factoryIdtoAddress[factoryId]) == false, \\\"Factory is disabled\\\");\\n        ICryptoPigeon pigeon = IPigeonFactory(factoryIdtoAddress[factoryId]).createCryptoPigeon( to);\\n        ownerToPigeon[to].push(pigeon);\\n        pigeonToOwnerIndex[pigeon] = ownerToPigeon[to].length-1;\\n        emit PigeonCreated(pigeon);\\n        return pigeon;\\n    }\\n}\\n\\n\"},\"EpigeonInterfaces.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.4.11;\\r\\n\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface IERC777 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function granularity() external view returns (uint256);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n    function send(address recipient, uint256 amount, bytes data) external;\\r\\n    function burn(uint256 amount, bytes data) external;\\r\\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\\r\\n    function authorizeOperator(address operator) external;\\r\\n    function revokeOperator(address operator) external;\\r\\n    function defaultOperators() external view returns (address[] memory);\\r\\n    function operatorSend(address sender, address recipient, uint256 amount, bytes data, bytes operatorData) external;\\r\\n    function operatorBurn(address account, uint256 amount, bytes data, bytes operatorData) external;\\r\\n    event Sent( address indexed operator, address indexed from, address indexed to, uint256 amount, bytes data, bytes operatorData);\\r\\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\\r\\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\\r\\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\r\\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface ILockable {\\r\\n    function lock(address to, uint256 amount, bytes32 hash) external;\\r\\n    function operatorLock(address from, address to, uint256 amount, bytes32 hash, bytes data, bytes operatorData) external;\\r\\n    function unlock(string unlockerPhrase) external;\\r\\n    function operatorUnlock(address to, string unlockerPhrase, bytes data, bytes operatorData) external;\\r\\n    function reclaim(address to, string unlockerPhrase) external;\\r\\n    function operatorReclaim(address from, address to, string unlockerPhrase, bytes data, bytes operatorData) external;\\r\\n    function unlockByLockedCoinContract(address to, bytes32 hash) external;\\r\\n    function reclaimByLockedCoinContract(address from, address to, bytes32 hash) external;\\r\\n    function lockedSupply() external view returns (uint256 locked_supply);\\r\\n    function lockedAmount(address from, bytes32 hash) external view returns (uint256 amount);\\r\\n    function lockedBalanceOf(address account) external view returns (uint256);\\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface IPigeonFactory {\\r\\n    function createCryptoPigeon(address to) external returns (ICryptoPigeon pigeonAddress);    \\r\\n    function iAmFactory() external pure returns (bool);\\r\\n    function amIEpigeon() external returns (bool);\\r\\n    function factoryId() external view returns (uint256 id);\\r\\n    function getMetaDataForPigeon(address pigeon) external view returns (string metadata);\\r\\n    function mintingPrice() external view returns (uint256 price);\\r\\n    function totalSupply() external view returns (uint256 supply);\\r\\n    function maxSupply() external view returns (uint256 supply);\\r\\n    function getFactoryTokenPrice(address ERC20Token) external view returns (uint256 price);\\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface ICryptoPigeon {\\r\\n    function burnPigeon() external;    \\r\\n    function iAmPigeon() external pure returns (bool); \\r\\n    function transferPigeon(address newOwner) external; \\r\\n    function hasFlown() external view returns (bool);\\r\\n    function toAddress() external view returns (address addressee);   \\r\\n    function owner() external view returns (address ownerAddress);\\r\\n    function manager() external view returns (address managerAddress);\\r\\n    function factoryId() external view returns (uint256 id);\\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface IEpigeon {\\r\\n    function pigeonDestinations() external view returns (IPigeonDestinationDirectory destinations);\\r\\n    function nameAndKeyDirectory() external view returns (INameAndPublicKeyDirectory directory);\\r\\n    function getLastFactoryId() external view returns (uint256 id);\\r\\n    function getFactoryAddresstoId(uint256 id) external view returns (address factoryAddress);\\r\\n    function getPigeonPriceForFactory(uint256 factoryId) external view returns (uint256 price);\\r\\n    function getPigeonTokenPriceForFactory(address ERC20Token, uint256 factoryId) external view returns (uint256 price);\\r\\n    function createCryptoPigeonNFT(address to, uint256 factoryId) external returns (address pigeonaddress);\\r\\n    function transferPigeon(address from, address to, address pigeon) external;\\r\\n    function burnPigeon(address pigeon) external;\\r\\n    function nftContractAddress() external view returns (address nftContract);\\r\\n    function validPigeon(address pigeon, address pigeonOwner) external view returns (bool);\\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface IEpigeonNFT {\\r\\n    function isTokenizedPigeon(address pigeon) external view returns (bool);\\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface INameAndPublicKeyDirectory {\\r\\n    function getPublicKeyForAddress (address owner) external view returns (string key); \\r\\n    function getUserNameForAddress (address owner) external view returns (string name);\\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface IPigeonDestinationDirectory{\\r\\n    function changeToAddress(address newToAddress, address oldToAddress) external;\\r\\n    function setToAddress(address newToAddress) external;\\r\\n    function deleteToAddress(address oldToAddress) external;\\r\\n    function deleteToAddressByEpigeon(address pigeon) external;\\r\\n    function pigeonsSentToAddressLenght(address toAddress) external view returns (uint256 length);\\r\\n    function pigeonSentToAddressByIndex(address toAddress, uint index) external view returns (address pigeonAddress);   \\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\ninterface IPigeonManagerDirectory{\\r\\n    function changeManager(address newManager, address oldManager) external;\\r\\n    function deleteManager(address oldManager) external;\\r\\n    function setManager(address newManager) external;\\r\\n    function pigeonsOfManagerLenght(address toAddress) external view returns (uint256 length);\\r\\n    function pigeonOfManagerByIndex(address toAddress, uint index) external view returns (address pigeonAddress);   \\r\\n}\\r\\n//----------------------------------------------------------------------------------------------------\\r\\n\\r\\n\"}}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"factoryId\",\"type\":\"uint256\"}],\"name\":\"createCryptoPigeonNFT\",\"outputs\":[{\"name\":\"pigeonAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"egigeonURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createCryptoPigeonByLatestFactory\",\"outputs\":[{\"name\":\"pigeonAddress\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"factoryId\",\"type\":\"uint256\"}],\"name\":\"enableFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastFactoryId\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nftContract\",\"type\":\"address\"}],\"name\":\"setNFTContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"factoryAddress\",\"type\":\"address\"}],\"name\":\"addFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ERC20Token\",\"type\":\"address\"},{\"name\":\"factoryId\",\"type\":\"uint256\"}],\"name\":\"getPigeonTokenPriceForFactory\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nameAndKeyDirectory\",\"outputs\":[{\"name\":\"directory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getIdforFactory\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pigeonOwner\",\"type\":\"address\"}],\"name\":\"pigeonsCountOfOwner\",\"outputs\":[{\"name\":\"length\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"factoryId\",\"type\":\"uint256\"}],\"name\":\"disableFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pigeonOwner\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"pigeonOfOwnerByIndex\",\"outputs\":[{\"name\":\"rpaddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"factoryId\",\"type\":\"uint256\"}],\"name\":\"createCryptoPigeon\",\"outputs\":[{\"name\":\"pigeonAddress\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pigeon\",\"type\":\"address\"},{\"name\":\"pigeonOwner\",\"type\":\"address\"}],\"name\":\"validPigeon\",\"outputs\":[{\"name\":\"valid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pigeon\",\"type\":\"address\"}],\"name\":\"burnPigeon\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setUri\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nftContractAddress\",\"outputs\":[{\"name\":\"_nftcontract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getFactoryAddresstoId\",\"outputs\":[{\"name\":\"factory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"factoryAddress\",\"type\":\"address\"}],\"name\":\"isFactoryDisabled\",\"outputs\":[{\"name\":\"disabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"factoryId\",\"type\":\"uint256\"}],\"name\":\"getPigeonPriceForFactory\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFactoryCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pigeonDestinations\",\"outputs\":[{\"name\":\"destinations\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"pigeon\",\"type\":\"address\"}],\"name\":\"transferPigeon\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ERC20Token\",\"type\":\"address\"},{\"name\":\"factoryId\",\"type\":\"uint256\"}],\"name\":\"createCryptoPigeonForToken\",\"outputs\":[{\"name\":\"pigeonAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pigeon\",\"type\":\"address\"}],\"name\":\"PigeonCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "Epigeon", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://567ebadbc3c8f030b9b3c39db80ae7ac801a54e20593e6fedd45e422ff288468"}]}