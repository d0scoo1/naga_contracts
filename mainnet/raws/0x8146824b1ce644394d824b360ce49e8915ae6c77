{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.6;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IPairXCore {\r\n\r\n    // \u5411\u6c60\u5b50\u4e2d\u5b58\u5165\u8d44\u4ea7\r\n    function deposit( address token , address to , uint amount ) external  ;\r\n\r\n    // \u53d6\u56de\u6307\u5b9a\u7684Token\u8d44\u4ea7\u53ca\u5956\u52b1\r\n    function claim( address token ) external returns (uint amount) ;\r\n\r\n    // \u63d0\u53d6PairX\u7684\u6316\u77ff\u5956\u52b1,\u53ef\u4ee5\u63d0\u53d6\u5f53\u524d\u5df2\u89e3\u9501\u7684\u4efd\u989d\r\n    function redeem(address token ) external returns (uint amount ) ;\r\n\r\n    /**\r\n     *  \u7ed3\u675f\u6d41\u52a8\u6027\u6316\u77ff\r\n     */\r\n    function finish() external ;\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface IStakingRewards {\r\n    // Views\r\n    function lastTimeRewardApplicable() external view returns (uint256);\r\n\r\n    function rewardPerToken() external view returns (uint256);\r\n\r\n    function earned(address account) external view returns (uint256);\r\n\r\n    function getRewardForDuration() external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    // Mutative\r\n    function stake(uint256 amount) external;\r\n\r\n    function withdraw(uint256 amount) external;\r\n\r\n    function getReward() external;\r\n\r\n    function exit() external;\r\n\r\n    event Staked(address indexed user, uint256 amount);\r\n    event Withdrawn(address indexed user, uint256 amount);\r\n    event RewardPaid(address indexed user, uint256 reward);\r\n    event RewardAdded(uint256 reward);\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n\r\ncontract PairPairX is IPairXCore {\r\n    using SafeMath for uint256;\r\n\r\n    address public Owner;\r\n    uint8 public Fee = 10;\r\n    address public FeeTo;\r\n\r\n    uint256 private MinToken0Deposit;\r\n    uint256 private MinToken1Deposit;\r\n\r\n    // for pairx\r\n    address public RewardToken; // Reward Token\r\n    uint256 public RewardAmount;\r\n\r\n    uint8 public Status = 0; // 0 = not init , 1 = open , 2 = locked , 9 = finished\r\n    // uint public MaxLockDays = 365 ;\r\n    uint256 public RewardBeginTime = 0; // \u5f00\u59cbPairX\u8ba1\u7b97\u65e5\u671f,\u5728addLiquidityAndStake\u65f6\u8bbe\u7f6e\r\n    uint256 public DepositEndTime = 0; // \u5b58\u5165\u7ed3\u675f\u65f6\u95f4\r\n    uint256 public StakeEndTime = 0;\r\n\r\n    address public UniPairAddress; // \u914d\u5bf9\u5956\u52b1Token address\r\n    address public MainToken; // stake and reward token\r\n    address public Token0; // Already sorted .\r\n    address public Token1;\r\n    TokenRecord Token0Record;\r\n    TokenRecord Token1Record;\r\n\r\n    address public StakeAddress; //\r\n    // uint StakeAmount ;\r\n\r\n    uint RewardGottedTotal ;    //\u5df2\u63d0\u73b0\u603b\u6570\r\n    mapping(address => mapping(address => uint256)) UserBalance; // \u7528\u6237\u5145\u503c\u4f59\u989d UserBalance[sender][token]\r\n    mapping(address => mapping(address => uint256)) RewardGotted; // RewardGotted[sender][token]\r\n\r\n    event Deposit(address from, address to, address token, uint256 amount);\r\n    event Claim(\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint256 principal,\r\n        uint256 interest,\r\n        uint256 reward\r\n    );\r\n\r\n    struct TokenRecord {\r\n        uint256 total; // \u5b58\u5165\u603b\u4ee3\u5e01\u8ba1\u6570\r\n        uint256 reward; // \u5206\u914d\u7684\u603b\u5956\u52b1pairx,\u9ed8\u8ba4\u5148\u5206\u914d40%,\u6700\u540e20%\u6839\u636e\u89c4\u5219\u5206\u914d\r\n        uint256 compensation; // PairX\u8865\u8d34\u989d\u5ea6,\u9ed8\u8ba4\u4e3a0\r\n        uint256 stake; // lon staking token\r\n        uint256 withdraw; // \u53ef\u63d0\u73b0\u603b\u91cf\uff0c\u53ef\u63d0\u73b0\u4ee3\u5e01\u9700\u8981\u5305\u542b\u6316\u77ff\u5956\u52b1\u90e8\u5206\r\n        uint256 mint; // \u6316\u77ff\u5956\u52b1\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == Owner, \"no role.\");\r\n        _;\r\n    }\r\n\r\n    modifier isActive() {\r\n        require(block.timestamp < StakeEndTime, \"Mining was expired.\");\r\n        require(Status == 1, \"Not open.\");\r\n        _;\r\n    }\r\n\r\n    constructor(address owner) public {\r\n        Owner = owner;\r\n    }\r\n\r\n    function active(\r\n        address feeTo,\r\n        address pair,\r\n        address main,\r\n        address stake,\r\n        uint256 stakeEndTime\r\n    ) external onlyOwner {\r\n        FeeTo = feeTo;\r\n        UniPairAddress = pair;\r\n        MainToken = main;\r\n        // \u901a\u8fc7\u63a5\u53e3\u8bfb\u53d6token0\u548ctoken1\u7684\u503c\r\n        IUniswapV2Pair uni = IUniswapV2Pair(UniPairAddress);\r\n        Token0 = uni.token0();\r\n        Token1 = uni.token1();\r\n\r\n        StakeEndTime = stakeEndTime; //\u6309\u79d2\u8ba1\u7b97\uff0c\u4e0d\u518d\u6309\u5929\u8ba1\u7b97\u4e86\r\n        StakeAddress = stake;\r\n    }\r\n\r\n    /**\r\n     *  deposit reward-tokens (PairX token).\r\n     */\r\n    function setReward(\r\n        address reward,\r\n        uint256 amount,\r\n        uint256 token0min,\r\n        uint256 token1min,\r\n        uint256 depositEndTime\r\n    ) external onlyOwner {\r\n        RewardToken = reward;\r\n        TransferHelper.safeTransferFrom(\r\n            reward,\r\n            msg.sender,\r\n            address(this),\r\n            amount\r\n        );\r\n        RewardAmount = RewardAmount.add(amount);\r\n        MinToken0Deposit = token0min;\r\n        MinToken1Deposit = token1min;\r\n        Status = 1;\r\n\r\n        //update TokenRecord\r\n        uint256 defaultReward = RewardAmount.mul(4).div(10);\r\n        Token0Record.reward = defaultReward;\r\n        Token1Record.reward = defaultReward;\r\n        DepositEndTime = depositEndTime;\r\n    }\r\n\r\n    function tokenRecordInfo(address token)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 free,\r\n            uint256 total,\r\n            uint256 reward,\r\n            uint256 stake,\r\n            uint256 withdraw\r\n        )\r\n    {\r\n        if (token == Token0) {\r\n            // free = _tokenBalance(Token0);\r\n            free = Token0Record.withdraw ;\r\n            total = Token0Record.total;\r\n            reward = Token0Record.reward;\r\n            stake = Token0Record.stake;\r\n            withdraw = Token0Record.withdraw;\r\n        } else {\r\n            // free = _tokenBalance(Token1);\r\n            free = Token1Record.withdraw ;\r\n            total = Token1Record.total;\r\n            reward = Token1Record.reward;\r\n            stake = Token1Record.stake;\r\n            withdraw = Token1Record.withdraw;\r\n        }\r\n\r\n    }\r\n\r\n    function info() external view returns (\r\n        // address owner , uint8 fee , address feeTo ,\r\n        uint minToken0Deposit , uint minToken1Deposit ,\r\n        address rewardToken  , uint rewardAmount , \r\n        uint8 status , uint stakeEndTime , \r\n        address token0 , address token1 , address pair ,\r\n        address mainToken , uint rewardBeginTime , uint depositEndTime\r\n    ) {\r\n        minToken0Deposit = MinToken0Deposit ;\r\n        minToken1Deposit = MinToken1Deposit ;\r\n        rewardToken = RewardToken ;\r\n        rewardAmount = RewardAmount ;\r\n        status = Status ;\r\n        stakeEndTime = StakeEndTime ;\r\n        token0 = Token0 ;\r\n        token1 = Token1 ;\r\n        mainToken = MainToken ;\r\n        pair = UniPairAddress ;\r\n        rewardBeginTime = RewardBeginTime ;\r\n        depositEndTime = DepositEndTime ;\r\n    } \r\n\r\n    function depositInfo( address sender , address token ) external view returns \r\n     ( uint depositBalance ,uint depositTotal , uint leftDays ,\r\n       uint lockedReward , uint freeReward , uint gottedReward ) {\r\n        depositBalance = UserBalance[sender][token] ;\r\n        if( token == Token0 ) {\r\n            depositTotal = Token0Record.total ;\r\n        } else {\r\n            depositTotal = Token1Record.total ;\r\n        }\r\n        // rewardTotal = RewardTotal[sender] ;\r\n        if( sender != address(0) ){\r\n            ( leftDays , lockedReward , freeReward , gottedReward )\r\n                = getRewardRecord( token , sender ) ;\r\n        } else {\r\n            leftDays = 0 ;\r\n            lockedReward = 0 ;\r\n            freeReward = 0 ;\r\n            gottedReward = 0 ;\r\n        }\r\n    }\r\n\r\n    function getRewardRecord(address token , address sender ) public view returns  \r\n     ( uint leftDays , uint locked , uint free , uint gotted ) {\r\n\r\n        uint nowDate = getDateTime( block.timestamp ) ;\r\n        //\u8ba1\u7b97\u4e00\u5171\u53ef\u63d0\u53d6\u7684\u5956\u52b1\r\n        uint depositAmount = UserBalance[sender][token] ;\r\n        TokenRecord memory record = token == Token0 ? Token0Record : Token1Record ;\r\n\r\n        leftDays = _leftDays( StakeEndTime , nowDate ) ;\r\n        locked = 0 ;\r\n        free = 0 ;\r\n        gotted = 0 ;\r\n        if( depositAmount == 0 ) {\r\n            return ( leftDays , 0 , 0 , 0 );\r\n        }\r\n\r\n        if( record.reward == 0 ) {\r\n            return ( leftDays , 0 , 0 , 0 );\r\n        }\r\n\r\n        gotted = RewardGotted[sender][token] ;\r\n\r\n        //\u6362\u4e2a\u8ba1\u7b97\u65b9\u6cd5,\u8ba1\u7b97\u6bcf\u79d2\u53ef\u83b7\u5f97\u7684\u6536\u76ca\r\n        uint lockedTimes = _leftDays( StakeEndTime , RewardBeginTime ) ;\r\n        uint oneTimeReward = record.reward.div( lockedTimes ) ;\r\n        uint freeTime ;\r\n\r\n        if( nowDate > StakeEndTime ) {\r\n            leftDays = 0 ;\r\n            locked = 0 ;\r\n            freeTime = lockedTimes ; \r\n        } else {\r\n            leftDays = _leftDays( StakeEndTime , nowDate ) ;\r\n            freeTime = lockedTimes.sub( leftDays ) ;\r\n        }\r\n\r\n        // \u9632\u6b62\u6ea2\u51fa,\u4fdd\u75593\u4f4d\u7cbe\u5ea6\r\n        uint maxReward = depositAmount.mul( oneTimeReward ).div(1e15)\r\n            .mul( lockedTimes ).div( record.total.div(1e15) );\r\n            \r\n        if( Status == 2 ) {\r\n            free = depositAmount.mul( oneTimeReward ).div(1e15)\r\n                .mul( freeTime ).div( record.total.div(1e15) ); \r\n            if( free.add(gotted) > maxReward ){\r\n                locked = 0 ;\r\n            } else {\r\n                locked = maxReward.sub( free ).sub( gotted ) ;\r\n            }\r\n        } else if ( Status == 9 ) {\r\n            free = maxReward.sub( gotted ) ;\r\n            locked = 0 ;\r\n        } else if ( Status == 1 ) {\r\n            free = 0 ;\r\n            locked = maxReward ;\r\n        } else {\r\n            free = 0 ;\r\n            locked = 0 ;\r\n        }\r\n\r\n    }    \r\n    \r\n    function getDateTime( uint timestamp ) public pure returns ( uint ) {\r\n        // timeValue = timestamp ;\r\n        return timestamp ;\r\n    }\r\n\r\n    function _sendReward( address to , uint amount ) internal {\r\n        //Give reward tokens .\r\n        uint balance = RewardAmount.sub( RewardGottedTotal ); \r\n        if( amount > 0 && balance > 0 ) {\r\n            if( amount > balance ){\r\n                amount = balance ;  //\u4f59\u989d\u4e0d\u8db3\u65f6\uff0c\u53ea\u80fd\u83b7\u5f97\u4f59\u989d\u90e8\u5206\r\n            }\r\n            TransferHelper.safeTransfer( RewardToken , to , amount ) ;\r\n            // RewardAmount = RewardAmount.sub( amount ) ;  \u4f7f\u7528balanceOf \u786e\u5b9a\u4f59\u989d\r\n        }\r\n    }\r\n\r\n    function _deposit(address sender ,  address token , uint amount ) internal {\r\n        if( token == Token0 ) {\r\n            require( amount > MinToken0Deposit , \"Deposit tokens is too less.\" ) ;\r\n        }\r\n\r\n        if( token == Token1 ) {\r\n            require( amount > MinToken1Deposit , \"Deposit tokens is too less.\" ) ;\r\n        }\r\n\r\n        if( token == Token0 ) {\r\n            Token0Record.total = Token0Record.total.add( amount ) ;\r\n            Token0Record.withdraw = Token0Record.total ;\r\n        }\r\n\r\n        if( token == Token1 ) {\r\n            Token1Record.total = Token1Record.total.add( amount ) ;\r\n            Token1Record.withdraw = Token1Record.total ;\r\n        }\r\n\r\n        UserBalance[sender][token] = UserBalance[sender][token].add(amount );\r\n    }\r\n\r\n    function _fee( uint amount ) internal returns ( uint fee ) {\r\n        fee = amount.mul( Fee ).div( 100 ) ;\r\n        if( fee > 0 ) {\r\n            _safeTransfer( MainToken , FeeTo , fee ) ;\r\n        }\r\n    }\r\n\r\n    function _leftDays(uint afterDate , uint beforeDate ) internal pure returns( uint ) {\r\n        if( afterDate <= beforeDate ) {\r\n            return 0 ;\r\n        } else {\r\n            return afterDate.sub(beforeDate ) ;\r\n            // \u5c06\u7531\u5929\u8ba1\u7b97\u6539\u4e3a\u7531\u79d2\u8ba1\u7b97\r\n            //return afterDate.sub(beforeDate).div( OneDay )  ;\r\n        }\r\n    }\r\n\r\n    /*\r\n    *   \u5411\u6c60\u5b50\u4e2d\u5b58\u5165\u8d44\u4ea7, \u76ee\u524d\u8be5\u63a5\u53e3\u53ea\u652f\u6301erc20\u4ee3\u5e01.\r\n    *   \u5982\u679c\u9700\u8981\u4f7f\u7528eth\uff0c\u4f1a\u5728\u524d\u7f6e\u5408\u7ea6\u8fdb\u884c\u5904\u7406,\u5c06eth\u5151\u6362\u6210WETH\r\n    */\r\n    function deposit( address token , address to , uint amount  ) public override isActive {\r\n        \r\n        require( Status == 1 , \"Not allow deposit .\" ) ;\r\n        require( (token == Token0) || ( token == Token1) , \"Match token faild.\" ) ;\r\n\r\n        // More gas , But logic will more easy.\r\n        if( token == MainToken ){\r\n            TransferHelper.safeTransferFrom( token , msg.sender , address(this) , amount ) ;\r\n        } else {\r\n            // \u5151\u6362 weth\r\n            IWETH( token ).deposit{\r\n                value : amount \r\n            }() ;\r\n        }\r\n        _deposit( to , token , amount ) ;\r\n\r\n        emit Deposit( to, address(this) , token , amount ) ;\r\n    } \r\n\r\n    /**\r\n     *  \u63d0\u53d6\u53ef\u63d0\u73b0\u7684\u5956\u52b1Token\r\n     */\r\n    function redeem(address token ) public override returns ( uint amount ) {\r\n        require( Status == 2 || Status == 9 , \"Not finished.\" ) ;\r\n        address sender = msg.sender ;\r\n        ( , , uint free , ) = getRewardRecord( token , sender ) ;\r\n        amount = free ;\r\n        _sendReward( sender , amount ) ;\r\n        RewardGotted[sender][token] = RewardGotted[sender][token].add( amount ) ;  \r\n        RewardGottedTotal = RewardGottedTotal.add( amount ) ;\r\n    }\r\n\r\n    // redeem all , claim from tokenlon , and removeLiquidity from uniswap\r\n    // \u6d41\u7a0b\u7ed3\u675f\r\n    function finish() external override onlyOwner {\r\n        // require(block.timestamp >= StakeEndTime , \"It's not time for redemption.\" ) ;\r\n        // redeem liquidity from staking contracts \r\n        IStakingRewards staking = IStakingRewards(StakeAddress) ;\r\n        // uint stakeBalance = staking.balanceOf( address(this) ) ;\r\n\r\n        //\u8ba1\u7b97MainToken\u4f59\u989d\u53d8\u5316,\u5373\u6316\u77ffToken\u7684\u4f59\u989d\u53d8\u5316\uff0c\u83b7\u53d6\u6536\u76ca\r\n        uint beforeExit = _tokenBalance( MainToken ); \r\n        staking.exit() ;\r\n        uint afterExit = _tokenBalance( MainToken ); \r\n\r\n        uint interest = afterExit.sub( beforeExit ) ;\r\n\r\n        // remove liquidity\r\n        IUniswapV2Pair pair = IUniswapV2Pair( UniPairAddress ) ;\r\n        uint liquidityBalance = pair.balanceOf( address(this) ) ;\r\n        TransferHelper.safeTransfer( UniPairAddress , UniPairAddress , liquidityBalance ) ;\r\n        pair.burn( address(this) ) ;\r\n\r\n        //\u8ba1\u7b97\u5269\u4f59\u672c\u91d1\r\n        uint mainTokenBalance = _tokenBalance( MainToken ) ;\r\n        uint principal = mainTokenBalance.sub( interest ).sub( RewardAmount ).add( RewardGottedTotal ) ;  \r\n\r\n        // \u6536\u53d6 interest \u7684 10% \u4f5c\u4e3a\u7ba1\u7406\u8d39\r\n        uint fee = _fee( interest ) ;\r\n        uint interestWithoutFee = interest - fee ;\r\n        //\u5224\u65ad\u65e0\u507f\u635f\u5931\r\n        // \u5224\u65adToken0\u662f\u5426\u53d7\u5230\u4e86\u65e0\u507f\u635f\u5931\u5f71\u54cd\r\n        TokenRecord memory mainRecord = MainToken == Token0 ? Token0Record : Token1Record ;\r\n        \r\n        uint mainTokenRate = 5 ;\r\n        uint pairTokenRate = 5 ;  //\u540450%\u7684\u6536\u76ca,\u4e0d\u9700\u8981\u8865\u507f\u65e0\u507f\u635f\u5931\u7684\u4e00\u65b9\r\n        if( mainRecord.total > principal ) {\r\n            // \u6709\u65e0\u507f\u635f\u5931\r\n            uint diff = mainRecord.total - principal ;\r\n            uint minDiff = mainRecord.total.div( 10 ) ; // 10%\u7684\u635f\u5931\r\n            if( diff > minDiff ) {\r\n                //\u6ee1\u8db3\u8865\u8d34\u6761\u4ef6\r\n                mainTokenRate = 6 ;\r\n                pairTokenRate = 4 ;\r\n            }\r\n        } else {\r\n            // \u8ba1\u7b97\u53e6\u4e00\u4e2atoken\u7684\u662f\u5426\u6ee1\u8db3\u8865\u507f\u6761\u4ef6\r\n            TokenRecord memory pairRecord = MainToken == Token0 ? Token1Record : Token0Record ;\r\n            //\u83b7\u53d6\u914d\u5bf9Token\u7684\u4f59\u989d\r\n            address pairToken = Token0 == MainToken ? Token1 : Token0 ;\r\n            //TODO \u4e8c\u6c60\u56e0\u4e3a\u5956\u52b1token\u548c\u6316\u77fftoken\u5c5e\u4e8e\u540c\u4e00token\uff0c\u6240\u4ee5\u8fd9\u91cc\u901a\u8fc7\u4f59\u989d\u8ba1\u7b97\u4f1a\u5b58\u5728\u95ee\u9898\uff0c\u9700\u8981\u8c03\u6574\r\n            uint pairTokenBalance = _tokenBalance( pairToken ) ;\r\n            uint diff = pairRecord.total - pairTokenBalance ;\r\n            uint minDiff = pairRecord.total.div(10) ;\r\n            if( diff > minDiff ) {\r\n                pairTokenRate = 6 ;\r\n                mainTokenRate = 4 ;\r\n            }\r\n        }\r\n\r\n        ( uint token0Rate , uint token1Rate ) = Token0 == MainToken ? \r\n            ( mainTokenRate , pairTokenRate) : ( pairTokenRate , mainTokenRate ) ;\r\n\r\n        Token0Record.reward = RewardAmount.mul( token0Rate ).div( 10 ) ;\r\n        Token1Record.reward = RewardAmount.mul( token1Rate ).div( 10 ) ;\r\n\r\n        Token0Record.mint = interestWithoutFee.mul( token0Rate ).div( 10 ) ;\r\n        Token1Record.mint = interestWithoutFee.mul( token1Rate ).div( 10 ) ;\r\n\r\n        // \u8bbe\u7f6e\u4e3a\u6316\u77ff\u7ed3\u675f\r\n        Status = 9 ;\r\n    }\r\n\r\n    /**\r\n     *  \u6dfb\u52a0\u6d41\u52a8\u6027\u5e76\u5f00\u59cb\u6316\u77ff\u65f6\r\n     *      1\u3001\u4e0d\u63a5\u6536\u7ee7\u7eed\u5b58\u5165\u8d44\u4ea7\u3002\r\n     *      2\u3001\u5f00\u59cb\u8ba1\u7b97PairX\u7684\u6316\u77ff\u5956\u52b1\uff0c\u5e76\u7ebf\u6027\u91ca\u653e\u3002\r\n     */\r\n    function addLiquidityAndStake( ) external onlyOwner returns ( uint token0Amount , uint token1Amount , uint liquidity , uint stake ) {\r\n        //TODO \u5728\u4e8c\u6c60\u7684\u60c5\u51b5\u4e0b\u6709\u95ee\u9898\r\n        // uint token0Balance = _tokenBalance( Token0 ) ;\r\n        // uint token1Balance = _tokenBalance( Token1 ) ;\r\n        uint token0Balance = Token0Record.total ; \r\n        uint token1Balance = Token1Record.total ;\r\n\r\n        require( token0Balance > MinToken0Deposit && token1Balance > MinToken1Deposit , \"No enought balance .\" ) ;\r\n        IUniswapV2Pair pair = IUniswapV2Pair( UniPairAddress ) ;\r\n        ( uint reserve0 , uint reserve1 , ) = pair.getReserves() ;  // sorted\r\n\r\n        //\u5148\u8ba1\u7b97\u5c06A\u5168\u90e8\u5b58\u5165\u9700\u8981B\u7684\u914d\u5bf9\u91cf\r\n        token0Amount = token0Balance ;\r\n        token1Amount = token0Amount.mul( reserve1 ) /reserve0 ;\r\n        if( token1Amount > token1Balance ) {\r\n            //\u8ba1\u7b97\u5c06B\u5168\u90e8\u5b58\u5165\u9700\u8981\u7684B\u7684\u603b\u91cf\r\n            token1Amount = token1Balance ;\r\n            token0Amount = token1Amount.mul( reserve0 ) / reserve1 ;\r\n        } \r\n\r\n        require( token0Amount > 0 && token1Amount > 0 , \"No enought tokens for pair.\" ) ;\r\n        TransferHelper.safeTransfer( Token0 , UniPairAddress , token0Amount ) ;\r\n        TransferHelper.safeTransfer( Token1 , UniPairAddress , token1Amount ) ;\r\n\r\n        //add liquidity\r\n        liquidity = pair.mint( address(this) ) ;\r\n\r\n        require( liquidity > 0 , \"Stake faild. No liquidity.\" ) ;\r\n        //stake \r\n        stake = _stake( ) ;\r\n        // \u5f00\u59cb\u8ba1\u7b97PairX\u6316\u77ff\r\n        RewardBeginTime = getDateTime( block.timestamp ) ;\r\n        Status = 2 ;    //Locked \r\n    }\r\n\r\n    //\u63d0\u53d6\u5b58\u5165\u4ee3\u5e01\u53ca\u6316\u77ff\u6536\u76ca,\u4e00\u6b21\u6027\u5168\u90e8\u63d0\u53d6\r\n    function claim( address token ) public override returns (uint amount ) {\r\n        // require( StakeEndTime <= block.timestamp , \"Unexpired for locked.\") ;\r\n        // \u4f59\u989d\u505a\u4e86\u5904\u7406,\u4e0d\u7528\u62c5\u5fc3\u91cd\u5165\r\n        amount = UserBalance[msg.sender][token] ;\r\n\r\n        require( amount > 0 , \"Invaild request, balance is not enough.\" ) ;\r\n        require( Status != 2 , \"Not finish. \" ) ;   //locked\r\n        require( token == Token0 || token == Token1 , \"No matched token.\") ; \r\n        uint reward = 0 ;\r\n        uint principal = amount ;\r\n        uint interest = 0 ;\r\n        if( Status == 1 ) {\r\n            // \u76f4\u63a5\u63d0\u53d6\u672c\u91d1,\u4f46\u6ca1\u6709\u4efb\u4f55\u6536\u76ca\r\n            _safeTransfer( token , msg.sender , amount ) ;\r\n            if( token == Token0 ) {\r\n                Token0Record.total = Token0Record.total.sub( amount ) ;\r\n                Token0Record.withdraw = Token0Record.total ;\r\n            }\r\n            if( token == Token1 ) {\r\n                Token1Record.total = Token1Record.total.sub( amount ) ;\r\n                Token1Record.withdraw = Token1Record.total ;\r\n            }\r\n            // UserBalance[msg.sender][token] = UserBalance[msg.sender][token].sub( amount ) ; \r\n        } \r\n\r\n        if( Status == 9 ) {\r\n            TokenRecord storage tokenRecord = token == Token0 ? Token0Record : Token1Record ;\r\n            // \u8ba1\u7b97\u53ef\u63d0\u53d6\u7684\u672c\u91d1 amount / total * withdraw\r\n            principal = amount.div(1e15).mul( tokenRecord.withdraw ).div( tokenRecord.total.div(1e15) );\r\n            if( tokenRecord.mint > 0 ) {\r\n                interest = amount.div(1e15).mul( tokenRecord.mint ).div( tokenRecord.total.div(1e15) ) ;\r\n            }\r\n            \r\n            // if( token == Token0 ) {\r\n            //     tokenBalance = Token0Record.total ;\r\n            // }\r\n            if( token == MainToken ) {\r\n                // \u4e00\u6b21\u6027\u8f6c\u5165\r\n                uint tranAmount = principal + interest ;\r\n                _safeTransfer( token , msg.sender , tranAmount ) ;\r\n            } else {\r\n                _safeTransfer( token , msg.sender , principal ) ;\r\n                if( interest > 0 ) {\r\n                    // \u5206\u522b\u8f6c\u51fa\r\n                    _safeTransfer( MainToken , msg.sender , interest ) ;\r\n                }\r\n            }\r\n\r\n            // \u63d0\u53d6\u89e3\u9501\u7684\u89e3\u9501\u7684\u5168\u90e8\u5956\u52b1\r\n            reward = redeem( token ) ;\r\n        }\r\n        \r\n        // clear \r\n        UserBalance[msg.sender][token] = uint(0);\r\n\r\n        emit Claim( address(this) , msg.sender , token , principal , interest , reward ) ;\r\n    }\r\n\r\n    function _stake() internal returns (uint stake ) {\r\n        IStakingRewards staking = IStakingRewards( StakeAddress ) ;\r\n        uint liquidity = IUniswapV2Pair( UniPairAddress ).balanceOf( address(this) ) ;\r\n        stake = liquidity ;\r\n        TransferHelper.safeApprove( UniPairAddress , StakeAddress , liquidity) ;\r\n        staking.stake( liquidity ) ;\r\n        // emit Staking( address(this) , StakeAddress , liquidity , stake ) ;\r\n    }\r\n\r\n    function depositETH() external payable {\r\n        uint ethValue = msg.value ;\r\n        require( ethValue > 0 , \"Payment is zero.\" ) ;\r\n        address weth = Token0 == MainToken ? Token1 : Token0 ;\r\n        deposit( weth , msg.sender , ethValue ) ;\r\n    }\r\n\r\n    function _safeTransfer( address token , address to , uint amount ) internal {\r\n        uint balance = _tokenBalance( token ) ;\r\n        if( amount > balance ){\r\n            amount = balance ;\r\n        }\r\n        if( token == MainToken ) {\r\n            TransferHelper.safeTransfer( token , to , amount ) ;\r\n        } else {\r\n            // weth\r\n            IWETH( token ).withdraw( amount ) ;\r\n            TransferHelper.safeTransferETH( to , amount );\r\n        }\r\n    }\r\n\r\n    function _tokenBalance( address token ) internal view returns (uint) {\r\n        return IERC20( token ).balanceOf( address(this) ) ;\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == Token0 || msg.sender == Token1 ); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DepositEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Fee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FeeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MainToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RewardBeginTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StakeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StakeEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Status\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UniPairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeTo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"main\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stake\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeEndTime\",\"type\":\"uint256\"}],\"name\":\"active\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addLiquidityAndStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"token0Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"depositInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"depositBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leftDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"freeReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gottedReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finish\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getDateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getRewardRecord\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"leftDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"locked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"free\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gotted\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"info\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minToken0Deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToken1Deposit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"stakeEndTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mainToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardBeginTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositEndTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositEndTime\",\"type\":\"uint256\"}],\"name\":\"setReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenRecordInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"free\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdraw\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PairPairX", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000083d0126fbd8d221175c9c7f442b35b0a915c4dec", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4c97c85cc8e2bea6d9060485b8f55c334ba28b9e1cf7e63e87fdc138bee0590c"}]}