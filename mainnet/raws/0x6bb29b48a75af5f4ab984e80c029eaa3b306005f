{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary MathLib {\r\n\r\n    uint8 constant Decimals = 8;\r\n    int256 constant PI = 314159265;\r\n\r\n    function sqrt(uint256 y) internal pure returns (uint256) {\r\n      uint256 result;\r\n      if (y > 3) {\r\n          result = y;\r\n          uint256 x = y / 2 + 1;\r\n          while (x < result) {\r\n              result = x;\r\n              x = (y / x + x) / 2;\r\n          }\r\n      } else if (y != 0) {\r\n          result = 1;\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    function abs(int256 x) internal pure returns (int256) {\r\n        return x < 0 ? x*(-1) : x;\r\n    }\r\n\r\n    /**\r\n     * Return the sine of an integer approximated angle as a signed 10^8\r\n     * integer.\r\n     *\r\n     * @param input A 14-bit angle. This divides the circle into 628318530(2*PI)\r\n     *               angle units, instead of the standard 360 degrees.\r\n     * @return The sine result as a number in the range -10^8 to 10^8.\r\n     */\r\n    function sin(int256 input) internal pure  returns(int256)\r\n    {\r\n        int256[20] memory arctan_table = [int256(78539816), 39269908, 19634954, 9817477, 4908739, 2454369, 1227185, 613592, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory sin_table = [int256(70710678), 38268343, 19509032, 9801714, 4906767, 2454123, 1227154, 613588, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory cos_table = [int256(70710678), 92387953, 98078528, 99518473, 99879546, 99969882, 99992470, 99998118, 99999529, 99999882, 99999971, 99999993, 99999998, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000];\r\n\r\n        while(input < 0) {\r\n            input = input + 2*PI;\r\n        }\r\n        int256 _angle = int(input % 628318530);\r\n\r\n        if (_angle > PI/2 && _angle <= PI) {\r\n            _angle = PI - _angle;\r\n        } else if(_angle > PI && _angle < PI*3/2) {\r\n            _angle = PI - _angle;\r\n        } else if(_angle >= PI*3/2 && _angle < 2*PI) {\r\n            _angle = _angle - 2*PI;\r\n        }\r\n\r\n        int256 x = 100000000;\r\n        int256 xnew = 100000000;\r\n        int256 y = 0;\r\n        int256 ynew = 0;\r\n        int256 ang = 0;\r\n\r\n        uint8 i = 0;\r\n        for (i = 0; i <= 19; i = i + 1)\r\n        {\r\n            if (ang < _angle)\r\n            {\r\n                xnew = (x*cos_table[i] - y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] + x*sin_table[i]) / 100000000;\r\n                ang = ang + arctan_table[i];\r\n            }\r\n\r\n            else if (ang > _angle)\r\n            {\r\n                xnew = (x*cos_table[i] + y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] - x*sin_table[i]) / 100000000;\r\n                ang = ang - arctan_table[i];\r\n            }\r\n\r\n            x = xnew;\r\n            y = ynew;\r\n        }\r\n        return(y);\r\n    }\r\n\r\n    /**\r\n     * Return the cos of an integer approximated angle as a signed 10^8\r\n     * integer.\r\n     *\r\n     * @param input A 10^8 radian angle. This divides the circle into 628318530(2*PI)\r\n     *               angle units, instead of the standard 360 degrees.\r\n     * @return The cos result as a number in the range -10^8 to 10^8.\r\n     */\r\n    function cos(int256 input) internal pure returns(int256)\r\n    {\r\n        bool neg = false;\r\n        int256[20] memory arctan_table = [int256(78539816), 39269908, 19634954, 9817477, 4908739, 2454369, 1227185, 613592, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory sin_table = [int256(70710678), 38268343, 19509032, 9801714, 4906767, 2454123, 1227154, 613588, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory cos_table = [int256(70710678), 92387953, 98078528, 99518473, 99879546, 99969882, 99992470, 99998118, 99999529, 99999882, 99999971, 99999993, 99999998, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000];\r\n\r\n        while(input < 0) {\r\n            input = input + 2*PI;\r\n        }\r\n        int256 _angle = int(input % 628318530);\r\n\r\n        if (_angle > PI/2 && _angle <= PI) {\r\n            _angle = PI - _angle;\r\n            neg = true;\r\n        } else if(_angle > PI && _angle < PI*3/2) {\r\n            _angle = _angle - PI;\r\n            neg = true;\r\n        } else if(_angle >= PI*3/2 && _angle < 2*PI) {\r\n            _angle = 2*PI - _angle;\r\n        }\r\n\r\n        int256 x = 100000000;\r\n        int256 xnew = 100000000;\r\n        int256 y = 0;\r\n        int256 ynew = 0;\r\n        int256 ang = 0;\r\n\r\n        uint8 i = 0;\r\n        for (i = 0; i <= 19; i = i + 1)\r\n        {\r\n            if (ang < _angle)\r\n            {\r\n                xnew = (x*cos_table[i] - y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] + x*sin_table[i]) / 100000000;\r\n                ang = ang + arctan_table[i];\r\n            }\r\n\r\n            else if (ang > _angle)\r\n            {\r\n                xnew = (x*cos_table[i] + y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] - x*sin_table[i]) / 100000000;\r\n                ang = ang - arctan_table[i];\r\n            }\r\n\r\n            x = xnew;\r\n            y = ynew;\r\n        }\r\n\r\n        if(neg)\r\n        {\r\n            return(-x);\r\n        }\r\n        else\r\n        {\r\n            return(x);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the tan of an integer approximated angle as a signed 10^8\r\n     * integer.\r\n     *\r\n     * @param input A 10^8 radian angle. This divides the circle into 628318530(2*PI)\r\n     *               angle units, instead of the standard 360 degrees.\r\n     * @return The tan result as a number in the range -10^8 to 10^8.\r\n     */\r\n    function tan(int256 input) internal pure returns(int256)\r\n    {\r\n        // int256 PI = 314159265;\r\n        int256[20] memory arctan_table = [int256(78539816), 39269908, 19634954, 9817477, 4908739, 2454369, 1227185, 613592, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory sin_table = [int256(70710678), 38268343, 19509032, 9801714, 4906767, 2454123, 1227154, 613588, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory cos_table = [int256(70710678), 92387953, 98078528, 99518473, 99879546, 99969882, 99992470, 99998118, 99999529, 99999882, 99999971, 99999993, 99999998, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000];\r\n\r\n        while(input < 0) {\r\n            input = input + 2*PI;\r\n        }\r\n        int256 _angle = int(input % 628318530);\r\n\r\n        if (_angle >= PI/2 && _angle <= PI*3/2) {\r\n            _angle = _angle - PI;\r\n        } else if (_angle > 3*PI/2) {\r\n            _angle = _angle - 3*PI/2;\r\n        }\r\n\r\n        int256 x = 100000000;\r\n        int256 xnew = 100000000;\r\n        int256 y = 0;\r\n        int256 ynew = 0;\r\n        int256 ang = 0;\r\n\r\n        uint8 i = 0;\r\n        for (i = 0; i <= 19; i = i + 1)\r\n        {\r\n            if (ang < _angle)\r\n            {\r\n                xnew = (x*cos_table[i] - y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] + x*sin_table[i]) / 100000000;\r\n                ang = ang + arctan_table[i];\r\n            }\r\n\r\n            else if (ang > _angle)\r\n            {\r\n                xnew = (x*cos_table[i] + y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] - x*sin_table[i]) / 100000000;\r\n                ang = ang - arctan_table[i];\r\n            }\r\n\r\n            x = xnew;\r\n            y = ynew;\r\n        }\r\n        //now divide y and x\r\n        int256 res; res = 0;\r\n        int256 digit;\r\n        int8 j;\r\n\r\n        j = 1;\r\n        while(j <= 8)\r\n        {\r\n            digit = y / x;\r\n            res = res + digit;\r\n            res = res * 10;\r\n            y = (y % x)*10;\r\n            j = j + 1;\r\n        }\r\n\r\n        return(res);\r\n    }\r\n\r\n    /**\r\n     * Return the arcsin of an integer approximated ratio as a signed 10^8\r\n     * integer.\r\n     *\r\n     * @param input A 10^8 ratio. This divides the (-1, 1) into (-10^8, 10^8)\r\n     *               angle units, instead of the standard 360 degrees.\r\n     * @return The arcsin result as a number in the range -10^8 to 10^8 .\r\n     */\r\n\r\n    function arcsin(int256 input) internal pure returns(int256)\r\n    {\r\n        int256[20] memory arctan_table = [int256(78539816), 39269908, 19634954, 9817477, 4908739, 2454369, 1227185, 613592, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory sin_table = [int256(70710678), 38268343, 19509032, 9801714, 4906767, 2454123, 1227154, 613588, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory cos_table = [int256(70710678), 92387953, 98078528, 99518473, 99879546, 99969882, 99992470, 99998118, 99999529, 99999882, 99999971, 99999993, 99999998, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000];\r\n\r\n        int256 x = 100000000;\r\n        int256 xnew = 100000000;\r\n        int256 y = 0;\r\n        int256 ynew = 0;\r\n        int256 ang = 0;\r\n\r\n        uint8 i = 0;\r\n        for (i = 0; i <= 19; i = i + 1)\r\n        {\r\n            if (y < input)\r\n            {\r\n                xnew = (x*cos_table[i] - y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] + x*sin_table[i]) / 100000000;\r\n                ang = ang + arctan_table[i];\r\n            }\r\n\r\n            else if (y > input)\r\n            {\r\n                xnew = (x*cos_table[i] + y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] - x*sin_table[i]) / 100000000;\r\n                ang = ang - arctan_table[i];\r\n            }\r\n\r\n            x = xnew;\r\n            y = ynew;\r\n        }\r\n        return(ang);\r\n    }\r\n\r\n    function arctan(int256 input) internal pure returns(int256)\r\n    {\r\n        int256[20] memory arctan_table = [int256(78539816), 39269908, 19634954, 9817477, 4908739, 2454369, 1227185, 613592, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory sin_table = [int256(70710678), 38268343, 19509032, 9801714, 4906767, 2454123, 1227154, 613588, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory cos_table = [int256(70710678), 92387953, 98078528, 99518473, 99879546, 99969882, 99992470, 99998118, 99999529, 99999882, 99999971, 99999993, 99999998, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000];\r\n\r\n        int256 x = 100000000;\r\n        int256 xnew = 100000000;\r\n        int256 y = input;\r\n        int256 ynew = input;\r\n        int256 ang = 0;\r\n\r\n        uint8 i = 0;\r\n        for (i = 0; i <= 19; i = i + 1)\r\n        {\r\n            if (y > 0)\r\n            {\r\n                xnew = (x*cos_table[i] + y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] - x*sin_table[i]) / 100000000;\r\n                ang = ang + arctan_table[i];\r\n            }\r\n\r\n            else if (y < 0)\r\n            {\r\n                xnew = (x*cos_table[i] - y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] + x*sin_table[i]) / 100000000;\r\n                ang = ang - arctan_table[i];\r\n            }\r\n\r\n            x = xnew;\r\n            y = ynew;\r\n        }\r\n        return(ang);\r\n    }\r\n\r\n\r\n    function arctan2(int256 Y, int256 X) internal pure returns(int256)\r\n    {\r\n        int256 alpha = arctan( abs(int256(10**Decimals) * Y / X));\r\n        if( X < 0 && Y > 0) {\r\n            alpha = PI - alpha;\r\n        }\r\n        if( X > 0 && Y < 0) {\r\n            alpha = alpha * int256(-1);\r\n        }\r\n        if( X < 0 && Y < 0) {\r\n            alpha = alpha - PI;\r\n        }\r\n\r\n        return(alpha);\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Conversion from ecliptic cartesian coordinates to equatorial ones\r\n     * integer, integer, integer.\r\n     *\r\n     * @param cart_X cartesian X position\r\n     * @param cart_Y cartesian Y position\r\n     * @param cart_Z cartesian Z position\r\n     * @param epsilon Axial tilt (40910000 = default value for the Earth )\r\n     * @return The equatorial position.\r\n     */\r\n    function cart_ecl2cart_eq(int256 cart_X, int256 cart_Y, int256 cart_Z, int256 epsilon) internal pure returns(int256, int256, int256)\r\n    {\r\n        int256 equat_X = cart_X;\r\n        int256 equat_Y = ( cart_Y*cos(epsilon) - cart_Z*sin(epsilon) )/int256( 10**Decimals );\r\n        int256 equat_Z = ( cart_Y*sin(epsilon) + cart_Z*cos(epsilon) )/int256( 10**Decimals );\r\n        return(equat_X, equat_Y, equat_Z);\r\n    }\r\n\r\n\r\n    /**\r\n     * Conversion from cartesian to spherical coordinates\r\n     * integer, integer.\r\n     *\r\n     * @param cart_X cartesian X position\r\n     * @param cart_Y cartesian Y position\r\n     * @param cart_Z cartesian Z position\r\n     * @return The Spherical position.\r\n     */\r\n    function cart2sph(int256 cart_X, int256 cart_Y, int256 cart_Z) internal pure returns(int256, int256)\r\n    {\r\n        int256 norm = int256(sqrt(uint256(cart_X*cart_X + cart_Y*cart_Y + cart_Z*cart_Z)));\r\n        int256 alpha = (arctan2(cart_Y, cart_X) + 2*PI) % (2*PI);\r\n        int256 delta = arcsin(int256(10**Decimals) * cart_Z / norm);\r\n        return(alpha, delta);\r\n    }\r\n\r\n    /**\r\n     * Conversion from Equatorial to Horizontal coordinates (both spherical)\r\n     * integer, integer.\r\n     *\r\n     * @param timeIndex UTC time index from 2000-01-01 12:00:00 (second unit)\r\n     * @param RA Alpha value of Equatorial coordinates\r\n     * @param DEC Delta value of Equatorial coordinates\r\n     * @param lat latutude of the observer (north is positive) [rad]\r\n     * @param lon longitude of the observer (east is positive) [rad]\r\n     * @return return Horizontal position.\r\n     */\r\n    function sph_eq2sph_hor(int256 timeIndex, int256 RA, int256 DEC, int256 lat, int256 lon ) internal pure returns(int256, int256)\r\n    {\r\n        int256 temp;\r\n        // calculating Greenwich Sideral Time\r\n        int256 tu = int256( 10**Decimals ) * timeIndex / ( 24 * 3600 );\r\n        int256 GST = 2*PI * ((77905727 + 100273781 * tu / int256( 10**Decimals )  ) % int256( 10**Decimals )) / int256(10**Decimals);\r\n        // calculating Local Sideral Time\r\n        int256 LST = GST + lon;\r\n\r\n        // calculating the hour angle\r\n        int256 h = LST - RA;\r\n        // calculating the altitudes (a) and the azimuths (A) using spherical triangles\r\n        int256 delta = DEC;\r\n\r\n        temp = sin(lat) * sin(delta)/(int256(10**Decimals)) + cos(lat) * cos(delta) * cos(h)/(int256(10**(Decimals*2)));\r\n        int256 a = arcsin(temp);\r\n\r\n        temp = int256(-1) * cos(delta) * cos(h) * sin(lat)/(int256(10**(Decimals*2))) + sin(delta) * cos(lat)/(int256(10**Decimals));\r\n        int256 A = int256(-1) * arctan2( cos(delta)*sin(h)/(int256(10**Decimals)), temp );\r\n\r\n        return(a, A);\r\n    }\r\n\r\n\r\n    /**\r\n     * Transforms positions in space to positions in the sky relative to an observer\r\n     * integer, integer.\r\n     *\r\n     * @param pos_X positions X in space\r\n     * @param pos_Y positions Y in space\r\n     * @param pos_Z positions Z in space\r\n     * @param obliquity Axial tilt (40910000 = default value for the Earth )\r\n     * @param obs_latitude_rad latutude of the observer (north is positive) [rad]\r\n     * @param obs_longitude_rad longitude of the observer (east is positive) [rad]\r\n     * @param timeindex UTC time index from 2000-01-01 12:00:00 (second unit)\r\n     * @return return Sky position.\r\n     */\r\n    function get_sky_positions(int256 pos_X, int256 pos_Y, int256 pos_Z, int256 obliquity, int256 obs_latitude_rad, int256 obs_longitude_rad, int256 timeindex ) internal pure returns(int256, int256)\r\n    {\r\n        int256 RA;\r\n        int256 DEC;\r\n        int256 temp_1;\r\n        int256 temp_2;\r\n        int256 temp_3;\r\n\r\n        (temp_1, temp_2, temp_3) = cart_ecl2cart_eq(pos_X, pos_Y, pos_Z, obliquity);\r\n        (RA, DEC) = cart2sph(temp_1, temp_2, temp_3);\r\n\r\n        (temp_1, temp_2) = sph_eq2sph_hor(timeindex, RA, DEC, obs_latitude_rad, obs_longitude_rad);\r\n\r\n        return(temp_1, temp_2);\r\n    }\r\n}", "ABI": "[]", "ContractName": "MathLib", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d6984683385bfc684aaa6bfa114f3dd7ccc1f52cbd290a30679685b8523d4899"}]}