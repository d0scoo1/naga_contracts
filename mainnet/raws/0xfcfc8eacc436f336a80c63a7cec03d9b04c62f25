{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"CyberGorillaBabies.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.10;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./ERC721.sol\\\";\\n\\n/*\\n   ______      __              ______           _ ____          \\n  / ____/_  __/ /_  ___  _____/ ____/___  _____(_) / /___ ______\\n / /   / / / / __ \\\\/ _ \\\\/ ___/ / __/ __ \\\\/ ___/ / / / __ `/ ___/\\n/ /___/ /_/ / /_/ /  __/ /  / /_/ / /_/ / /  / / / / /_/ (__  ) \\n\\\\____/\\\\__, /_.___/\\\\___/_/   \\\\____/\\\\____/_/  /_/_/_/\\\\__,_/____/  \\n     /____/                                                     \\n\\n*/\\n\\n/// @title Cyber Gorillas Babies\\n/// @author delta devs (https://twitter.com/deltadevelopers)\\ncontract CyberGorillaBabies is ERC721, Ownable {\\n    using Strings for uint256;\\n\\n    /// @notice The address which is allowed to breed Cyber Gorillas.\\n    address private gorillaBreeder;\\n    /// @notice Base URI pointing to CyberGorillaBabies metadata.\\n    string public baseURI;\\n    /// @notice Returns true if the requested gorilla baby has the genesis trait, false otherwise.\\n    mapping(uint256 =\\u003e bool) public isGenesis;\\n\\n    constructor(string memory initialBaseURI)\\n        ERC721(\\\"Cyber Gorilla Babies\\\", \\\"CyberGorillaBabies\\\")\\n    {\\n        baseURI = initialBaseURI;\\n    }\\n\\n    /// @notice Set the address which is allowed to breed gorillas.\\n    /// @param newGorillaBreeder The target address, authorized to breed.\\n    function setGorillaBreeder(address newGorillaBreeder) public onlyOwner {\\n        gorillaBreeder = newGorillaBreeder;\\n    }\\n\\n    /// @notice Allows the contract deployer to set the Base URI for CyberGorillaBabies\\u0027 metadata.\\n    /// @param newBaseURI The new Base URI.\\n    function setBaseURI(string memory newBaseURI) public onlyOwner {\\n        baseURI = newBaseURI;\\n    }\\n\\n    /// @notice Allows the authorized breeder address to mint a gorilla baby to a specific address.\\n    /// @param to The address to receive the minted gorilla baby.\\n    /// @param _isGenesis Whether the baby to be minted has the genesis trait or not.\\n    function mintBaby(address to, bool _isGenesis) public {\\n        require(msg.sender == gorillaBreeder, \\\"Not Authorized\\\");\\n        isGenesis[totalSupply] = _isGenesis;\\n        _mint(to, totalSupply);\\n    }\\n\\n    /// @notice Returns the token URI of a specific gorilla baby.\\n    /// @param tokenId The token ID of the requested gorilla baby.\\n    /// @return The full URI of the requested gorilla baby.\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (string memory)\\n    {\\n        return\\n            bytes(baseURI).length \\u003e 0\\n                ? string(abi.encodePacked(baseURI, tokenId.toString(), \\\".json\\\"))\\n                : \\\"\\\";\\n    }\\n\\n\\n    function supportsInterface(bytes4 interfaceId) public pure override(ERC721, Ownable) returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f || // ERC165 Interface ID for ERC721Metadata\\n            interfaceId == 0x7f5828d0;   // ERC165 Interface ID for ERC173\\n    }\\n}\\n\"},\"CyberGorillas.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\nerror SoldOut();\\nerror SaleClosed();\\nerror InvalidMintParameters();\\nerror MintingTooMany();\\nerror NotWhitelisted();\\nerror NotAuthorized();\\n\\n/*\\n   ______      __              ______           _ ____          \\n  / ____/_  __/ /_  ___  _____/ ____/___  _____(_) / /___ ______\\n / /   / / / / __ \\\\/ _ \\\\/ ___/ / __/ __ \\\\/ ___/ / / / __ `/ ___/\\n/ /___/ /_/ / /_/ /  __/ /  / /_/ / /_/ / /  / / / / /_/ (__  ) \\n\\\\____/\\\\__, /_.___/\\\\___/_/   \\\\____/\\\\____/_/  /_/_/_/\\\\__,_/____/  \\n     /____/                                                     \\n\\n*/\\n\\n/// @author distractedm1nd\\ncontract CyberGorillas is ERC721, Ownable {\\n    using Strings for uint256;\\n    address private passwordSigner;\\n    address private gorillaBurner;\\n\\n    bool publicSaleActive;\\n\\n    uint256 constant PRESALE_MAX_TX = 2;\\n    uint256 constant PUBLIC_MAX_TX = 5;\\n    uint256 public constant MAX_SUPPLY = 3333;\\n    uint256 constant PRICE = 0.08 ether;\\n\\n    string public baseURI;\\n\\n    mapping(address =\\u003e uint256) private presaleWalletLimits;\\n    mapping(address =\\u003e uint256) private mainsaleWalletLimits;\\n\\n    constructor(string memory initialBaseURI, address initialPasswordSigner)\\n        ERC721(\\\"Cyber Gorillas\\\", \\\"CyberGorillas\\\")\\n    {\\n        baseURI = initialBaseURI;\\n        passwordSigner = initialPasswordSigner;\\n    }\\n\\n    function airdrop(address[] calldata airdropAddresses) public onlyOwner {\\n        for (uint256 i = 0; i \\u003c airdropAddresses.length; i++) {\\n            _mint(airdropAddresses[i], totalSupply);\\n        }\\n    }\\n\\n    function setGorilliaBurner(address newGorillaBurner) public onlyOwner {\\n        gorillaBurner = newGorillaBurner;\\n    }\\n\\n    function setPasswordSigner(address signer) public onlyOwner {\\n        passwordSigner = signer;\\n    }\\n\\n    function setBaseURI(string memory newBaseURI) public onlyOwner {\\n        baseURI = newBaseURI;\\n    }\\n\\n    function setPublicSale(bool publicSale) public onlyOwner {\\n        publicSaleActive = publicSale;\\n    }\\n\\n    function specialMintForTests(address to, uint256 tokenId) public {\\n        if (ownerOf[tokenId] == address(0)) _mint(to, tokenId);\\n    }\\n\\n    function purchase(uint256 amount) public payable {\\n        if (!publicSaleActive) revert SaleClosed();\\n        if (totalSupply + amount \\u003e MAX_SUPPLY) revert SoldOut();\\n        if (\\n            mainsaleWalletLimits[msg.sender] + amount \\u003e PUBLIC_MAX_TX ||\\n            msg.value \\u003c PRICE * amount\\n        ) revert InvalidMintParameters();\\n\\n        mainsaleWalletLimits[msg.sender] += amount;\\n        for (uint256 i = 0; i \\u003c amount; i++) {\\n            _mint(msg.sender, totalSupply);\\n        }\\n    }\\n\\n    function presale(uint256 amount, bytes memory signature) public payable {\\n        if (publicSaleActive) revert SaleClosed();\\n        if (totalSupply + amount \\u003e MAX_SUPPLY) revert SoldOut();\\n        if (!isWhitelisted(msg.sender, signature)) revert NotWhitelisted();\\n        if (\\n            presaleWalletLimits[msg.sender] + amount \\u003e PRESALE_MAX_TX ||\\n            msg.value \\u003c PRICE * amount\\n        ) revert InvalidMintParameters();\\n\\n        presaleWalletLimits[msg.sender] += amount;\\n        for (uint256 i = 0; i \\u003c amount; i++) {\\n            _mint(msg.sender, totalSupply);\\n        }\\n    }\\n\\n    function unstake(address payable recipient) external onlyOwner {\\n        recipient.transfer(address(this).balance);\\n    }\\n\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (string memory)\\n    {\\n        return\\n            bytes(baseURI).length \\u003e 0\\n                ? string(abi.encodePacked(baseURI, tokenId.toString(), \\\".json\\\"))\\n                : \\\"\\\";\\n    }\\n\\n    function isWhitelisted(address user, bytes memory signature)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        bytes32 messageHash = keccak256(abi.encode(user));\\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\\n\\n        return recoverSigner(ethSignedMessageHash, signature) == passwordSigner;\\n    }\\n\\n    function getEthSignedMessageHash(bytes32 _messageHash)\\n        private\\n        pure\\n        returns (bytes32)\\n    {\\n        /*\\n        Signature is produced by signing a keccak256 hash with the following format:\\n        \\\"\\\\x19Ethereum Signed Message\\\\n\\\" + len(msg) + msg\\n        */\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                    _messageHash\\n                )\\n            );\\n    }\\n\\n    function recoverSigner(\\n        bytes32 _ethSignedMessageHash,\\n        bytes memory _signature\\n    ) private pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\n    }\\n\\n    function recoverSignerTest(\\n        bytes32 _ethSignedMessageHash,\\n        bytes memory _signature\\n    ) private pure returns (address) {\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\n    }\\n\\n    function splitSignature(bytes memory sig)\\n        private\\n        pure\\n        returns (\\n            bytes32 r,\\n            bytes32 s,\\n            uint8 v\\n        )\\n    {\\n        require(sig.length == 65, \\\"sig invalid\\\");\\n\\n        assembly {\\n            /*\\n        First 32 bytes stores the length of the signature\\n\\n        add(sig, 32) = pointer of sig + 32\\n        effectively, skips first 32 bytes of signature\\n\\n        mload(p) loads next 32 bytes starting at the memory address p into memory\\n        */\\n\\n            // first 32 bytes, after the length prefix\\n            r := mload(add(sig, 32))\\n            // second 32 bytes\\n            s := mload(add(sig, 64))\\n            // final byte (first byte of the next 32 bytes)\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n\\n        // implicitly return (r, s, v)\\n    }\\n\\n\\n    function supportsInterface(bytes4 interfaceId) public pure override(ERC721, Ownable) returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f || // ERC165 Interface ID for ERC721Metadata\\n            interfaceId == 0x7f5828d0;   // ERC165 Interface ID for ERC173\\n    }\\n\\n    function burn(uint256 tokenId) public {\\n        if (msg.sender != gorillaBurner) revert NotAuthorized();\\n        _burn(tokenId);\\n    }\\n}\\n\"},\"CyberGorillasStaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"./CyberGorillas.sol\\\";\\nimport \\\"./GrillaToken.sol\\\";\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./RewardBoostProvider.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\n/*\\n   ______      __              ______           _ ____          \\n  / ____/_  __/ /_  ___  _____/ ____/___  _____(_) / /___ ______\\n / /   / / / / __ \\\\/ _ \\\\/ ___/ / __/ __ \\\\/ ___/ / / / __ `/ ___/\\n/ /___/ /_/ / /_/ /  __/ /  / /_/ / /_/ / /  / / / / /_/ (__  ) \\n\\\\____/\\\\__, /_.___/\\\\___/_/   \\\\____/\\\\____/_/  /_/_/_/\\\\__,_/____/  \\n     /____/                                                     \\n\\n*/\\n\\n/// @title Cyber Gorillas Staking\\n/// @author delta devs (https://twitter.com/deltadevelopers)\\ncontract CyberGorillasStaking is Ownable {\\n    /*///////////////////////////////////////////////////////////////\\n                        CONTRACT STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice An instance of the GRILLA token, paid out as staking reward.\\n    GrillaToken public rewardsToken;\\n    /// @notice An ERC721 instance of the Cyber Gorillas contract.\\n    ERC721 public gorillaContract;\\n\\n    /// @notice An address slot for a future contract to allow users to withdraw their rewards from multiple staking contracts in one call.\\n    address public rewardAggregator;\\n\\n    /// @notice The reward rate for staking a regular gorilla.\\n    /// @dev The reward rate is fixed to 10 * 1E18 GRILLA every 86400 seconds, 1157407407407400 per second.\\n    uint256 constant normalRate = (100 * 1E18) / uint256(1 days);\\n\\n    /// @notice The reward rate for staking a genesis gorilla.\\n    /// @dev The reward rate is fixed to 15 * 1E18 GRILLA every 86400 seconds, 1736111111111110 per second.\\n    uint256 constant genesisRate = (150 * 1E18) / uint256(1 days);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    GORILLA METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Keeps track of which gorilla\\u0027s have the genesis trait.\\n    mapping(uint256 =\\u003e bool) private genesisTokens;\\n    /// @notice A list of reward boost providers.\\n    RewardBoostProvider[] rewardBoostProviders;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        STAKING STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Returns the owner of the specified gorilla.\\n    mapping(uint256 =\\u003e address) public tokenToAddr;\\n    /// @notice Returns the reward amount for the specified address.\\n    mapping(address =\\u003e uint256) public rewards;\\n    /// @notice Returns the number of normal gorillas staked by specified address.\\n    mapping(address =\\u003e uint256) public _balancesNormal;\\n    /// @notice Returns the number of genesis gorillas staked by specified address.\\n    mapping(address =\\u003e uint256) public _balancesGenesis;\\n    /// @notice Returns the start time of staking rewards accumulation for a specified address.\\n    /// @dev The UNIX timestamp in seconds in which staking rewards were last claimed.\\n    /// This is later compared with block.timestamp to calculate the accumulated staking rewards.\\n    mapping(address =\\u003e uint256) public _updateTimes;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _gorillaContract, address _rewardsToken) {\\n        gorillaContract = ERC721(_gorillaContract);\\n        rewardsToken = GrillaToken(_rewardsToken);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            SETTERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Allows the contract deployer to specify which gorillas are to be considered of type genesis.\\n    /// @param genesisIndexes An array of indexes specifying which gorillas are of type genesis.\\n    function uploadGenesisArray(uint256[] memory genesisIndexes)\\n        public\\n        onlyOwner\\n    {\\n        for (uint256 i = 0; i \\u003c genesisIndexes.length; i++) {\\n            genesisTokens[genesisIndexes[i]] = true;\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                VIEWS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Returns the accumulated staking rewards of the function caller.\\n    /// @return The amount of GRILLA earned while staking.\\n    function viewReward() public view returns (uint256) {\\n        return rewards[msg.sender] + rewardDifferential(msg.sender);\\n    }\\n\\n    /// @notice Calculates the accumulated staking reward for the requested address.\\n    /// @param account The address of the staker.\\n    /// @return The amount of GRILLA earned while staking.\\n    function rewardDifferential(address account) public view returns (uint256) {\\n        uint256 accum = 0;\\n        uint256 bal = 0;\\n        for (uint256 boosterId = 0; boosterId \\u003c rewardBoostProviders.length; ) {\\n            bal = _balancesNormal[account];\\n            if (bal \\u003e 0)\\n                accum +=\\n                    rewardBoostProviders[boosterId].getPercentBoostAdultNormal(\\n                        account\\n                    ) *\\n                    bal;\\n            bal = _balancesGenesis[account];\\n            if (bal \\u003e 0)\\n                accum +=\\n                    rewardBoostProviders[boosterId].getPercentBoostAdultGenesis(\\n                        account\\n                    ) *\\n                    bal;\\n            unchecked {\\n                boosterId++;\\n            }\\n        }\\n        uint256 baseDiff = (((block.timestamp - _updateTimes[account]) *\\n            normalRate *\\n            _balancesNormal[account]) +\\n            ((block.timestamp - _updateTimes[account]) *\\n                genesisRate *\\n                _balancesGenesis[account]));\\n        return baseDiff + (baseDiff * accum) / 100;\\n    }\\n\\n    /// @notice Returns true if gorilla has the genesis trait, false otherwise.\\n    /// @return Whether the requested gorilla has the genesis trait.\\n    function isGenesis(uint256 tokenId) private view returns (bool) {\\n        return genesisTokens[tokenId];\\n    }\\n\\n    /// @notice Returns true if the requested address is staking at least one genesis gorilla, false otherwise.\\n    /// @return Whether the requested address is staking genesis gorillas.\\n    function isStakingGenesis(address account) public view returns (bool) {\\n        return _balancesGenesis[account] \\u003e 0;\\n    }\\n\\n    /// @notice Returns true if the requested address is staking normal gorillas, false otherwise.\\n    /// @return Whether the requested address is staking normal gorillas.\\n    function isStakingNormal(address account) public view returns (bool) {\\n        return _balancesNormal[account] \\u003e 0;\\n    }\\n\\n    /// @notice Modifier which updates the timestamp of when a staker last withdrew staking rewards.\\n    /// @param account The address of the staker.\\n    modifier updateReward(address account) {\\n        uint256 reward = rewardDifferential(account);\\n        _updateTimes[account] = block.timestamp;\\n        rewards[account] += reward;\\n        _;\\n    }\\n\\n    /// @notice Sets the reward aggregator.\\n    /// @param _rewardAggregator The address of the reward aggregation contract.\\n    function setRewardAggregator(address _rewardAggregator) public onlyOwner {\\n        rewardAggregator = _rewardAggregator;\\n    }\\n\\n    /// @notice Adds a reward booster.\\n    /// @param booster The address of the booster.\\n    function addRewardBoostProvider(address booster) public onlyOwner {\\n        rewardBoostProviders.push(RewardBoostProvider(booster));\\n    }\\n\\n    /// @notice Remove a specific reward booster at a specific index.\\n    /// @param index Index of the booster to remove.\\n    function removeRewardBoostProvider(uint256 index) public onlyOwner {\\n        delete rewardBoostProviders[index];\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            STAKING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    // TODO: This function is only for testing, can be removed\\n    // REASONING: Nothing else calls it, and a user would not spend the gas\\n    //            necessary in order to updateReward()\\n    function earned(address account)\\n        public\\n        updateReward(account)\\n        returns (uint256)\\n    {\\n        return rewards[account];\\n    }\\n\\n    /// @notice Allows a staker to withdraw their rewards.\\n    /// @return The amount of GRILLA earned from staking.\\n    function withdrawReward()\\n        public\\n        updateReward(msg.sender)\\n        returns (uint256)\\n    {\\n        uint256 reward = rewards[msg.sender];\\n        rewards[msg.sender] = 0;\\n        rewardsToken.stakerMint(msg.sender, reward);\\n        return reward;\\n    }\\n\\n    /// @notice Allows a contract to withdraw the rewards on behalf of a user.\\n    /// @return The amount of GRILLA earned from staking.\\n    function withdrawReward(address user)\\n        public\\n        updateReward(user)\\n        returns (uint256)\\n    {\\n        require(msg.sender == rewardAggregator, \\\"Unauthorized\\\");\\n        uint256 reward = rewards[user];\\n        rewards[user] = 0;\\n        rewardsToken.stakerMint(user, reward);\\n        return reward;\\n    }\\n\\n    /// @notice Allows a holder to stake a gorilla.\\n    /// @dev First checks whether the specified gorilla has the genesis trait. Updates balances accordingly.\\n    /// unchecked, because no arithmetic overflow is possible.\\n    /// @param _tokenId A specific gorilla, identified by its token ID.\\n    function stake(uint256 _tokenId) public updateReward(msg.sender) {\\n        bool isGen = isGenesis(_tokenId);\\n        unchecked {\\n            if (isGen) {\\n                _balancesGenesis[msg.sender]++;\\n            } else {\\n                _balancesNormal[msg.sender]++;\\n            }\\n        }\\n        tokenToAddr[_tokenId] = msg.sender;\\n        gorillaContract.transferFrom(msg.sender, address(this), _tokenId);\\n    }\\n\\n    /// @notice Allows a staker to stake multiple gorillas at once.\\n    /// @param tokenIds An array of token IDs, representing multiple gorillas.\\n    function stakeMultiple(uint256[] memory tokenIds)\\n        public\\n        updateReward(msg.sender)\\n    {\\n        for (uint256 i = 0; i \\u003c tokenIds.length; i++) {\\n            stake(tokenIds[i]);\\n        }\\n    }\\n\\n    /// @notice Allows a staker to unstake a staked gorilla.\\n    /// @param _tokenId A specific gorilla, identified by its token ID.\\n    function unstake(uint256 _tokenId) public updateReward(msg.sender) {\\n        require(tokenToAddr[_tokenId] == msg.sender, \\\"Owner Invalid\\\");\\n        bool isGen = isGenesis(_tokenId);\\n        unchecked {\\n            if (isGen) {\\n                _balancesGenesis[msg.sender]--;\\n            } else {\\n                _balancesNormal[msg.sender]--;\\n            }\\n        }\\n        delete tokenToAddr[_tokenId];\\n        gorillaContract.transferFrom(address(this), msg.sender, _tokenId);\\n    }\\n\\n    /// @notice Allows a staker to unstake multiple gorillas at once.\\n    /// @param tokenIds An array of token IDs, representing multiple gorillas.\\n    function unstakeMultiple(uint256[] memory tokenIds)\\n        public\\n        updateReward(msg.sender)\\n    {\\n        for (uint256 i = 0; i \\u003c tokenIds.length; i++) {\\n            unstake(tokenIds[i]);\\n        }\\n    }\\n}\\n\"},\"ERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity \\u003e=0.8.0;\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 {\\n    /*///////////////////////////////////////////////////////////////\\n                                EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public balanceOf;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        for (uint256 i = 0; i \\u003c idsLength; ) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can\\u0027t have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        uint256 ownersLength = owners.length; // Saves MLOADs.\\n\\n        require(ownersLength == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i \\u003c ownersLength; i++) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i \\u003c idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can\\u0027t have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i \\u003c idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can\\u0027t have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\ninterface ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity \\u003e=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address =\\u003e uint256) public balanceOf;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address =\\u003e uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline \\u003e= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner\\u0027s nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) \\u0026\\u0026 recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user\\u0027s balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"},\"ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity \\u003e=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\\nabstract contract ERC721 {\\n    /*///////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC721 STORAGE                        \\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address =\\u003e uint256) public balanceOf;\\n\\n    mapping(uint256 =\\u003e address) public ownerOf;\\n\\n    mapping(uint256 =\\u003e address) public getApproved;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender\\u0027s balance is impossible because we check for\\n        // ownership above and the recipient\\u0027s balance can\\u0027t realistically overflow.\\n        unchecked {\\n            balanceOf[from]--;\\n\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            totalSupply++;\\n\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = ownerOf[id];\\n\\n        require(ownerOf[id] != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            totalSupply--;\\n\\n            balanceOf[owner]--;\\n        }\\n\\n        delete ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\ninterface ERC721TokenReceiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"},\"GrillaToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./JungleSerum.sol\\\";\\nimport \\\"./CyberGorillasStaking.sol\\\";\\n\\n/*\\n   ______      __              ______           _ ____          \\n  / ____/_  __/ /_  ___  _____/ ____/___  _____(_) / /___ ______\\n / /   / / / / __ \\\\/ _ \\\\/ ___/ / __/ __ \\\\/ ___/ / / / __ `/ ___/\\n/ /___/ /_/ / /_/ /  __/ /  / /_/ / /_/ / /  / / / / /_/ (__  ) \\n\\\\____/\\\\__, /_.___/\\\\___/_/   \\\\____/\\\\____/_/  /_/_/_/\\\\__,_/____/  \\n     /____/                                                     \\n\\n*/\\n\\n/// @title Grilla Token\\n/// @author delta devs (https://twitter.com/deltadevelopers)\\ncontract GrillaToken is ERC20, Ownable {\\n    /*///////////////////////////////////////////////////////////////\\n                            EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Emitted by `buyOffChainUtility` function.\\n    /// @dev Event logging when utility has been purchased.\\n    /// @param sender Address of purchaser.\\n    /// @param itemId Item identifier tied to utility.\\n    event UtilityPurchase(address indexed sender, uint256 indexed itemId);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice An instance of the JungleSerum contract.\\n    JungleSerum serumContract;\\n\\n    /// @notice Retrieves price tied to specific utility item ID.\\n    mapping(uint256 =\\u003e uint256) utilityPrices;\\n\\n    /// @notice Returns true if address is authorized to make stake function calls.\\n    mapping(address =\\u003e bool) authorizedStakingContracts;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n    constructor() ERC20(\\\"GRILLA\\\", \\\"GRILLA\\\", 18) {}\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            MINTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Allows the contract deployer to mint GRILLA.\\n    /// @param account The address which will receive the minted amount.\\n    /// @param amount The amount of tokens to mint.\\n    function ownerMint(address account, uint256 amount) public onlyOwner {\\n        _mint(account, amount);\\n    }\\n\\n    /// @notice Allows authorized staking contracts to mint GRILLA.\\n    /// @param account The address which will receive the minted amount.\\n    /// @param amount The amount of tokens to mint.\\n    function stakerMint(address account, uint256 amount) public {\\n        require(\\n            authorizedStakingContracts[msg.sender],\\n            \\\"Request only valid from staking contract\\\"\\n        );\\n        _mint(account, amount);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        CONTRACT SETTERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Allows the contract deployer to authorize a contract to stake.\\n    /// @param staker The address to authorize.\\n    function addStakingContract(address staker) public onlyOwner {\\n        authorizedStakingContracts[staker] = true;\\n    }\\n\\n    /// @notice Allows the contract deployer to unauthorize a contract to stake.\\n    /// @param staker The address to remove authority from.\\n    function removeStakingContract(address staker) public onlyOwner {\\n        authorizedStakingContracts[staker] = false;\\n    }\\n\\n    /// @notice Sets the address of the JungleSerum contract.\\n    /// @param serumContractAddress The address of the JungleSerum contract.\\n    function setSerumContract(address serumContractAddress) public onlyOwner {\\n        serumContract = JungleSerum(serumContractAddress);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        UTILITY PURCHASING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Purchase JungleSerum.\\n    function buySerum() public {\\n        transfer(address(serumContract), serumContract.serumPrice());\\n        serumContract.mint(msg.sender);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    OFFCHAIN UTILITY PURCHASING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Retrieves the price of a specific utility.\\n    /// @param itemId The identifier of the utility item.\\n    /// @return The price of a specific utility.\\n    function getUtilityPrice(uint256 itemId) public view returns (uint256) {\\n        return utilityPrices[itemId];\\n    }\\n\\n    /// @notice Allows the contract deployer to add off-chain utility data.\\n    /// @param itemId The identifier of the utility item.\\n    /// @param itemPrice The price of the utility item.\\n    function addOffchainUtility(uint256 itemId, uint256 itemPrice)\\n        public\\n        onlyOwner\\n    {\\n        utilityPrices[itemId] = itemPrice;\\n    }\\n\\n    /// @notice Allows the contract deployer to remove off-chain utility data.\\n    /// @param itemId The identifier of the utility item.\\n    function deleteUtilityPrice(uint256 itemId) public onlyOwner {\\n        delete utilityPrices[itemId];\\n    }\\n\\n    /// @notice Allows the contract deployer to add off-chain utility data for multiple items.\\n    /// @param items List of multiple utility item identifiers.\\n    /// @param prices List of multiple utility item prices.\\n    function uploadUtilityPrices(\\n        uint256[] memory items,\\n        uint256[] memory prices\\n    ) public onlyOwner {\\n        for (uint256 i = 0; i \\u003c items.length; i++) {\\n            utilityPrices[items[i]] = prices[i];\\n        }\\n    }\\n\\n    /// @notice Buy the requested off chain utility.\\n    /// @param itemId The identifier of the utility item.\\n    function buyOffchainUtility(uint256 itemId) public {\\n        require(utilityPrices[itemId] \\u003e 0, \\\"Invalid utility id\\\");\\n        transfer(address(serumContract), utilityPrices[itemId]);\\n        emit UtilityPurchase(msg.sender, itemId);\\n    }\\n}\\n\"},\"JungleSerum.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"./ERC1155.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./CyberGorillas.sol\\\";\\nimport \\\"./CyberGorillaBabies.sol\\\";\\nimport \\\"./CyberGorillasStaking.sol\\\";\\nimport \\\"./GrillaToken.sol\\\";\\n\\n/*\\n   ______      __              ______           _ ____          \\n  / ____/_  __/ /_  ___  _____/ ____/___  _____(_) / /___ ______\\n / /   / / / / __ \\\\/ _ \\\\/ ___/ / __/ __ \\\\/ ___/ / / / __ `/ ___/\\n/ /___/ /_/ / /_/ /  __/ /  / /_/ / /_/ / /  / / / / /_/ (__  ) \\n\\\\____/\\\\__, /_.___/\\\\___/_/   \\\\____/\\\\____/_/  /_/_/_/\\\\__,_/____/  \\n     /____/                                                     \\n*/\\n\\n/// @title Jungle Serum\\n/// @author delta devs (https://twitter.com/deltadevelopers)\\n/// @dev Inspired by BoredApeChemistryClub.sol (https://etherscan.io/address/0x22c36bfdcef207f9c0cc941936eff94d4246d14a)\\nabstract contract JungleSerum is ERC1155, Ownable {\\n    using Strings for uint256;\\n    /*///////////////////////////////////////////////////////////////\\n                            EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Emitted by `breed` function.\\n    /// @dev Event logging when breeding occurs.\\n    /// @param firstGorilla First Cyber Gorilla parent used for breeding.\\n    /// @param secondGorilla Second Cyber Gorilla parent used for breeding.\\n    event MutateGorilla(\\n        uint256 indexed firstGorilla,\\n        uint256 indexed secondGorilla,\\n        bool indexed babyGenesis\\n    );\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Keeps track of which gorilla adults have the genesis trait.\\n    mapping(uint256 =\\u003e bool) private genesisTokens;\\n\\n    /// @notice String pointing to Jungle Serum URI.\\n    string serumURI;\\n    /// @notice Set name as Jungle Serum.\\n    string public constant name = \\\"Jungle Serum\\\";\\n    /// @notice The symbol of Jungle Serum.\\n    string public constant symbol = \\\"JS\\\";\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The price of a Jungle Serum.\\n    uint256 public serumPrice;\\n    /// @notice An instance of the CyberGorilla contract.\\n    CyberGorillas cyberGorillaContract;\\n    /// @notice An instance of the CyberGorillaBabies contract.\\n    CyberGorillaBabies cyberBabiesContract;\\n    /// @notice An instance of the CyberGorillasStaking contract.\\n    CyberGorillasStaking stakingContract;\\n    /// @notice An instance of the GrillaToken contract.\\n    GrillaToken public grillaTokenContract;\\n    /// @notice Returns true if specified gorilla is mutated, false otherwise.\\n    mapping(uint256 =\\u003e bool) mutatedGorillas;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _serumURI,\\n        uint256 _serumPrice,\\n        address _cyberGorillaContract,\\n        address _cyberBabiesContract,\\n        address _stakingContract\\n    ) {\\n        serumURI = _serumURI;\\n        serumPrice = _serumPrice;\\n        cyberGorillaContract = CyberGorillas(_cyberGorillaContract);\\n        cyberBabiesContract = CyberGorillaBabies(_cyberBabiesContract);\\n        stakingContract = CyberGorillasStaking(_stakingContract);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        STORAGE SETTERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Set the URI pointing to Jungle Serum metadata.\\n    /// @param _serumURI the target URI.\\n    function setSerumURI(string memory _serumURI) public onlyOwner {\\n        serumURI = _serumURI;\\n    }\\n\\n    /// @notice Set the price for a Jungle Serum.\\n    /// @param _serumPrice the price to set it to.\\n    function setSerumPrice(uint256 _serumPrice) public onlyOwner {\\n        serumPrice = _serumPrice;\\n    }\\n\\n    /// @notice Sets the address of the GrillaToken contract.\\n    /// @param _grillaTokenContract The address of the GrillaToken contract.\\n    function setGrillaTokenContract(address _grillaTokenContract)\\n        public\\n        onlyOwner\\n    {\\n        grillaTokenContract = GrillaToken(_grillaTokenContract);\\n    }\\n\\n    /// @notice Sets the address of the CyberGorilla contract.\\n    /// @param _cyberGorillaContract The address of the CyberGorilla contract.\\n    function setCyberGorillaContract(address _cyberGorillaContract)\\n        public\\n        onlyOwner\\n    {\\n        cyberGorillaContract = CyberGorillas(_cyberGorillaContract);\\n    }\\n\\n    /// @notice Sets the address of the CyberGorillaBabies contract.\\n    /// @param _cyberGorillaBabiesContract The address of the CyberGorillaBabies contract.\\n    function setCyberBabiesContract(address _cyberGorillaBabiesContract)\\n        public\\n        onlyOwner\\n    {\\n        cyberBabiesContract = CyberGorillaBabies(_cyberGorillaBabiesContract);\\n    }\\n\\n    /// @notice Sets the address of the CyberGorillasStaking contract.\\n    /// @param _stakingContract The address of the GrillaToken contract.\\n    function setStakingContract(address _stakingContract) public onlyOwner {\\n        stakingContract = CyberGorillasStaking(_stakingContract);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ADMIN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Allows the contract deployer to withdraw the GRILLA held by this contract to a specified address.\\n    /// @param receiver The address which receives the funds.\\n    function withdrawGrilla(address receiver) public onlyOwner {\\n        grillaTokenContract.transfer(\\n            receiver,\\n            grillaTokenContract.balanceOf(address(this))\\n        );\\n    }\\n\\n    /// @notice Allows the contract deployer to specify which adult gorillas are to be considered of type genesis.\\n    /// @param genesisIndexes An array of indexes specifying which adult gorillas are of type genesis.\\n    function uploadGenesisArray(uint256[] memory genesisIndexes)\\n        public\\n        onlyOwner\\n    {\\n        for (uint256 i = 0; i \\u003c genesisIndexes.length; i++) {\\n            genesisTokens[genesisIndexes[i]] = true;\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view override returns (string memory) {\\n        return\\n            bytes(serumURI).length \\u003e 0\\n                ? string(abi.encodePacked(serumURI, id.toString(), \\\".json\\\"))\\n                : \\\"\\\";\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            MINTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Allows the GrillaToken contract to mint a Jungle Serum for a specified address.\\n    /// @param gorillaOwner The gorilla owner that will receive the minted Serum.\\n    function mint(address gorillaOwner) public {\\n        require(msg.sender == address(grillaTokenContract), \\\"Not authorized\\\");\\n        _mint(gorillaOwner, 1, 1, \\\"\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            BREEDING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Allows a gorilla holder to breed a baby gorilla.\\n    /// @dev One of the parents dies after the total supply of baby gorillas reaches 1667.\\n    /// @param firstGorilla The tokenID of the first parent used for breeding.\\n    /// @param secondGorilla The tokenID of the second parent used for breeding.\\n    function breed(uint256 firstGorilla, uint256 secondGorilla) public virtual;\\n\\n    /// @notice Psuedorandom number to determine which parent dies during breeding.\\n    function randomGorilla() private view returns (bool) {\\n        unchecked {\\n            return\\n                uint256(\\n                    keccak256(abi.encodePacked(block.timestamp, block.number))\\n                ) %\\n                    2 ==\\n                0;\\n        }\\n    }\\n\\n\\n    function supportsInterface(bytes4 interfaceId) public pure override(ERC1155, Ownable) returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c || // ERC165 Interface ID for ERC1155MetadataURI\\n            interfaceId == 0x7f5828d0;   // ERC165 Interface ID for ERC173\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nerror NotOwner();\\n\\n// https://github.com/m1guelpf/erc721-drop/blob/main/src/LilOwnable.sol\\nabstract contract Ownable {\\n    address internal _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender);\\n        _;\\n    }\\n\\n    constructor() {\\n        _owner = msg.sender;\\n    }\\n\\n    function owner() external view returns (address) {\\n        return _owner;\\n    }\\n\\n    function transferOwnership(address _newOwner) external {\\n        if (msg.sender != _owner) revert NotOwner();\\n\\n        _owner = _newOwner;\\n    }\\n\\n    function renounceOwnership() public {\\n        if (msg.sender != _owner) revert NotOwner();\\n\\n        _owner = address(0);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        pure\\n        virtual\\n        returns (bool)\\n    {\\n        return interfaceId == 0x7f5828d0; // ERC165 Interface ID for ERC173\\n    }\\n}\"},\"RewardBoostProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\n/*\\n   ______      __              ______           _ ____          \\n  / ____/_  __/ /_  ___  _____/ ____/___  _____(_) / /___ ______\\n / /   / / / / __ \\\\/ _ \\\\/ ___/ / __/ __ \\\\/ ___/ / / / __ `/ ___/\\n/ /___/ /_/ / /_/ /  __/ /  / /_/ / /_/ / /  / / / / /_/ (__  ) \\n\\\\____/\\\\__, /_.___/\\\\___/_/   \\\\____/\\\\____/_/  /_/_/_/\\\\__,_/____/  \\n     /____/                                                     \\n\\n*/\\n\\n/// @title Reward Boost Provider\\n/// @author delta devs (https://twitter.com/deltadevelopers)\\nabstract contract RewardBoostProvider {\\n    /// @notice Retrieves the additional percentage boost for staking a genesis adult gorilla.\\n    /// @dev Each NFT type consists of a ERC1155, which in turn consists of several sub-types.\\n    /// By calculating the total balance for each sub-type, the total boost can be calculated.\\n    /// @param account The address of the account to which the boost is eligible.\\n    /// @return Returns the total boost.\\n    function getPercentBoostAdultGenesis(address account)\\n        public\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        return 0;\\n    }\\n\\n    /// @notice Retrieves the additional percentage boost for staking a normal adult gorilla.\\n    /// @dev Each NFT type consists of a ERC1155, which in turn consists of several sub-types.\\n    /// By calculating the total balance for each sub-type, the total boost can be calculated.\\n    /// @param account The address of the account to which the boost is eligible.\\n    /// @return Returns the total boost.\\n    function getPercentBoostAdultNormal(address account)\\n        public\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        return 0;\\n    }\\n\\n    /// @notice Retrieves the additional percentage boost for staking a genesis baby gorilla.\\n    /// @dev Each NFT type consists of a ERC1155, which in turn consists of several sub-types.\\n    /// By calculating the total balance for each sub-type, the total boost can be calculated.\\n    /// @param account The address of the account to which the boost is eligible.\\n    /// @return Returns the total boost.\\n    function getPercentBoostBabyGenesis(address account)\\n        public\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        return 0;\\n    }\\n\\n    /// @notice Retrieves the additional percentage boost for staking a normal baby gorilla.\\n    /// @dev Each NFT type consists of a ERC1155, which in turn consists of several sub-types.\\n    /// By calculating the total balance for each sub-type, the total boost can be calculated.\\n    /// @param account The address of the account to which the boost is eligible.\\n    /// @return Returns the total boost.\\n    function getPercentBoostBabyNormal(address account)\\n        public\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        return 0;\\n    }\\n}\\n\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp \\u003e\\u003e= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value \\u0026 0xf];\\n            value \\u003e\\u003e= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"UtilityPurchase\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemPrice\",\"type\":\"uint256\"}],\"name\":\"addOffchainUtility\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"addStakingContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"buyOffchainUtility\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buySerum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"deleteUtilityPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"getUtilityPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ownerMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"removeStakingContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"serumContractAddress\",\"type\":\"address\"}],\"name\":\"setSerumContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakerMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"items\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"name\":\"uploadUtilityPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GrillaToken", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4f4831a9dee4c59609534fe97ea1ff46ae1761bf6891d3d5eb03224e24b113c1"}]}