{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/0.8.9/CompositePostRebaseBeaconReceiver.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\n/* See contracts/COMPILERS.md */\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts-v4.4/utils/introspection/ERC165.sol\\\";\\nimport \\\"./OrderedCallbacksArray.sol\\\";\\nimport \\\"./interfaces/IBeaconReportReceiver.sol\\\";\\n\\n/**\\n  * @title Contract defining an composite post-rebase beacon receiver for the Lido oracle\\n  *\\n  * Contract adds permission modifiers.\\n  * Only the `ORACLE` address can invoke `processLidoOracleReport` function.\\n  */\\ncontract CompositePostRebaseBeaconReceiver is OrderedCallbacksArray, IBeaconReportReceiver, ERC165 {\\n    address public immutable ORACLE;\\n\\n    modifier onlyOracle() {\\n        require(msg.sender == ORACLE, \\\"MSG_SENDER_MUST_BE_ORACLE\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _voting,\\n        address _oracle\\n    ) OrderedCallbacksArray(_voting, type(IBeaconReportReceiver).interfaceId) {\\n        require(_oracle != address(0), \\\"ORACLE_ZERO_ADDRESS\\\");\\n\\n        ORACLE = _oracle;\\n    }\\n\\n    function processLidoOracleReport(\\n        uint256 _postTotalPooledEther,\\n        uint256 _preTotalPooledEther,\\n        uint256 _timeElapsed\\n    ) external virtual override onlyOracle {\\n        uint256 callbacksLen = callbacksLength();\\n\\n        for (uint256 brIndex = 0; brIndex < callbacksLen; brIndex++) {\\n            IBeaconReportReceiver(callbacks[brIndex])\\n                .processLidoOracleReport(\\n                    _postTotalPooledEther,\\n                    _preTotalPooledEther,\\n                    _timeElapsed\\n                );\\n        }\\n    }\\n\\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\\n        return (\\n            _interfaceId == type(IBeaconReportReceiver).interfaceId\\n            || super.supportsInterface(_interfaceId)\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-v4.4/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/0.8.9/OrderedCallbacksArray.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\n/* See contracts/COMPILERS.md */\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts-v4.4/utils/introspection/ERC165Checker.sol\\\";\\n\\nimport \\\"./interfaces/IOrderedCallbacksArray.sol\\\";\\n\\n/**\\n  * @title Contract defining an ordered callbacks array supporting add/insert/remove ops\\n  *\\n  * Contract adds permission modifiers atop of `IOrderedCallbacksArray` interface functions.\\n  * Only the `VOTING` address can invoke storage mutating (add/insert/remove) functions.\\n  */\\ncontract OrderedCallbacksArray is IOrderedCallbacksArray {\\n    using ERC165Checker for address;\\n\\n    uint256 public constant MAX_CALLBACKS_COUNT = 16;\\n    bytes4 constant INVALID_INTERFACE_ID = 0xffffffff;\\n\\n    address public immutable VOTING;\\n    bytes4 public immutable REQUIRED_INTERFACE;\\n\\n    address[] public callbacks;\\n\\n    modifier onlyVoting() {\\n        require(msg.sender == VOTING, \\\"MSG_SENDER_MUST_BE_VOTING\\\");\\n        _;\\n    }\\n\\n    constructor(address _voting, bytes4 _requiredIface) {\\n        require(_requiredIface != INVALID_INTERFACE_ID, \\\"INVALID_IFACE\\\");\\n        require(_voting != address(0), \\\"VOTING_ZERO_ADDRESS\\\");\\n\\n        VOTING = _voting;\\n        REQUIRED_INTERFACE = _requiredIface;\\n    }\\n\\n    function callbacksLength() public view override returns (uint256) {\\n        return callbacks.length;\\n    }\\n\\n    function addCallback(address _callback) external override onlyVoting {\\n        _insertCallback(_callback, callbacks.length);\\n    }\\n\\n    function insertCallback(address _callback, uint256 _atIndex) external override onlyVoting {\\n        _insertCallback(_callback, _atIndex);\\n    }\\n\\n    function removeCallback(uint256 _atIndex) external override onlyVoting {\\n        uint256 oldCArrayLength = callbacks.length;\\n        require(_atIndex < oldCArrayLength, \\\"INDEX_IS_OUT_OF_RANGE\\\");\\n\\n        emit CallbackRemoved(callbacks[_atIndex], _atIndex);\\n\\n        for (uint256 cIndex = _atIndex; cIndex < oldCArrayLength-1; cIndex++) {\\n            callbacks[cIndex] = callbacks[cIndex+1];\\n        }\\n\\n        callbacks.pop();\\n    }\\n\\n    function _insertCallback(address _callback, uint256 _atIndex) private {\\n        require(_callback != address(0), \\\"CALLBACK_ZERO_ADDRESS\\\");\\n        require(_callback.supportsInterface(REQUIRED_INTERFACE), \\\"BAD_CALLBACK_INTERFACE\\\");\\n\\n        uint256 oldCArrayLength = callbacks.length;\\n        require(_atIndex <= oldCArrayLength, \\\"INDEX_IS_OUT_OF_RANGE\\\");\\n        require(oldCArrayLength < MAX_CALLBACKS_COUNT, \\\"MAX_CALLBACKS_COUNT_EXCEEDED\\\");\\n\\n        emit CallbackAdded(_callback, _atIndex);\\n\\n        callbacks.push();\\n\\n        if (oldCArrayLength > 0) {\\n            for (uint256 cIndex = oldCArrayLength; cIndex > _atIndex; cIndex--) {\\n                callbacks[cIndex] = callbacks[cIndex-1];\\n            }\\n        }\\n\\n        callbacks[_atIndex] = _callback;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/0.8.9/interfaces/IBeaconReportReceiver.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.9;\\n\\n/**\\n  * @title Interface defining a callback that the quorum will call on every quorum reached\\n  */\\ninterface IBeaconReportReceiver {\\n    /**\\n      * @notice Callback to be called by the oracle contract upon the quorum is reached\\n      * @param _postTotalPooledEther total pooled ether on Lido right after the quorum value was reported\\n      * @param _preTotalPooledEther total pooled ether on Lido right before the quorum value was reported\\n      * @param _timeElapsed time elapsed in seconds between the last and the previous quorum\\n      */\\n    function processLidoOracleReport(uint256 _postTotalPooledEther,\\n                                     uint256 _preTotalPooledEther,\\n                                     uint256 _timeElapsed) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-v4.4/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-v4.4/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\\n        if (result.length < 32) return false;\\n        return success && abi.decode(result, (bool));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/0.8.9/interfaces/IOrderedCallbacksArray.sol\": {\r\n      \"content\": \"// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\\n\\n// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.9;\\n\\n/**\\n  * @title Interface defining an ordered callbacks array supporting add/insert/remove ops\\n  */\\ninterface IOrderedCallbacksArray {\\n    /**\\n      * @notice Callback added event\\n      *\\n      * @dev emitted by `addCallback` and `insertCallback` functions\\n      */\\n    event CallbackAdded(address indexed callback, uint256 atIndex);\\n\\n    /**\\n      * @notice Callback removed event\\n      *\\n      * @dev emitted by `removeCallback` function\\n      */\\n    event CallbackRemoved(address indexed callback, uint256 atIndex);\\n\\n    /**\\n      * @notice Callback length\\n      * @return Added callbacks count\\n      */\\n    function callbacksLength() external view returns (uint256);\\n\\n    /**\\n      * @notice Add a `_callback` to the back of array\\n      * @param _callback callback address\\n      *\\n      * @dev cheapest way to insert new item (doesn't incur additional moves)\\n      */\\n    function addCallback(address _callback) external;\\n\\n    /**\\n      * @notice Insert a `_callback` at the given `_atIndex` position\\n      * @param _callback callback address\\n      * @param _atIndex callback insert position\\n      *\\n      * @dev insertion gas cost is higher for the lower `_atIndex` values\\n      */\\n    function insertCallback(address _callback, uint256 _atIndex) external;\\n\\n    /**\\n      * @notice Remove a callback at the given `_atIndex` position\\n      * @param _atIndex callback remove position\\n      *\\n      * @dev remove gas cost is higher for the lower `_atIndex` values\\n      */\\n    function removeCallback(uint256 _atIndex) external;\\n\\n    /**\\n      * @notice Get callback at position\\n      * @return Callback at the given `_atIndex`\\n      *\\n      * @dev function reverts if `_atIndex` is out of range\\n      */\\n    function callbacks(uint256 _atIndex) external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voting\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"callback\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"atIndex\",\"type\":\"uint256\"}],\"name\":\"CallbackAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"callback\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"atIndex\",\"type\":\"uint256\"}],\"name\":\"CallbackRemoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_CALLBACKS_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ORACLE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REQUIRED_INTERFACE\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VOTING\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_callback\",\"type\":\"address\"}],\"name\":\"addCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"callbacks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"callbacksLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_callback\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_atIndex\",\"type\":\"uint256\"}],\"name\":\"insertCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_postTotalPooledEther\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_preTotalPooledEther\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeElapsed\",\"type\":\"uint256\"}],\"name\":\"processLidoOracleReport\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_atIndex\",\"type\":\"uint256\"}],\"name\":\"removeCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CompositePostRebaseBeaconReceiver", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000002e59a20f205bb85a89c53f1936454680651e618e000000000000000000000000442af784a788a5bd6f42a01ebe9f287a871243fb", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}