{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"dreamMarketplace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IDreamNFT {\\n    function minter(uint256 id) external returns (address);\\n}\\n\\n// Not to be confused with the actual WETH contract. This is a simple\\n// contract to keep track of ETH/BNB the user is owned by the contract.\\n// The user can withdraw it at any moment, it's not a token, hence it's not\\n// transferable. The marketplace will automatically try to refund the ETH to\\n// the user (e.g outbid, NFT sold) with a gas limit. This is simply backup\\n// when the ETH/BNB could not be sent to the user/address. For example, if\\n// the user is a smart contract that uses a lot of gas on it's payable.\\ncontract WrappedETH is ReentrancyGuard {\\n    mapping(address => uint256) public wethBalance;\\n    function claimETH() external {\\n        uint256 refund = wethBalance[msg.sender];\\n        wethBalance[msg.sender] = 0;\\n        (bool success,) = msg.sender.call{value: refund}(\\\"\\\");\\n        // If the tx failed, restore back their balance.\\n        if(!success) {\\n            wethBalance[msg.sender] = refund;\\n        }\\n    }\\n\\n    // claimETHForUser tries to payout the user's owned balance with\\n    // a gas limit. Does not throw if it failed to send.\\n    function claimETHForUser(address user) public {\\n        uint256 refund = wethBalance[user];\\n        wethBalance[user] = 0;\\n        (bool success,) = user.call{value: refund, gas: 3500}(\\\"\\\");\\n        // If the tx failed, restore back their balance.\\n        if(!success) {\\n            wethBalance[user] = refund;\\n        }\\n    }\\n\\n    // rewardETHToUser tries to send specified amount of ETH to the user.\\n    // If it cannot, it will add it to their balance. It will NOT throw.\\n    // Used for paying out other users safely, e.g when outbidding someone.\\n    function rewardETHToUser(address user, uint256 amount) internal {\\n        (bool success,) = user.call{value: amount, gas: 3500}(\\\"\\\");\\n        if(!success) {\\n            wethBalance[user] += amount;\\n        }\\n    }\\n}\\n\\ncontract Buyback {\\n    // Uniswap V2 Router address for buyback functionality.\\n    IUniswapV2Router02 public uniswapV2Router;\\n    // Keep store of the WETH address to save on gas.\\n    address WETH;\\n\\n    // devWalletAddress is the Dream development address for 10% fees, and buyback.\\n    address internal devWalletAddress;\\n    address public dreamTokenAddress;\\n\\n    uint256 ethToBuybackWith = 0;\\n\\n    event UniswapRouterUpdated(\\n        address newAddress\\n    );\\n\\n    event DreamBuyback(\\n        uint256 ethSpent\\n    );\\n\\n    function updateBuybackUniswapRouter(address newRouterAddress) internal {\\n        uniswapV2Router = IUniswapV2Router02(newRouterAddress);\\n        WETH = uniswapV2Router.WETH();\\n        emit UniswapRouterUpdated(newRouterAddress);\\n    }\\n\\n    function buybackDream() external {\\n        require(msg.sender == address(this), \\\"can only be called by the contract\\\");\\n        address[] memory path = new address[](2);\\n        path[0] = WETH;\\n        path[1] = dreamTokenAddress;\\n        uint256 amount = ethToBuybackWith;\\n        ethToBuybackWith = 0;\\n        uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\\n            0, // accept any amount of Tokens\\n            path,\\n            devWalletAddress,\\n            block.timestamp\\n        );\\n        emit DreamBuyback(amount);\\n    }\\n\\n    function swapETHForTokens(uint256 amount) internal {\\n        ethToBuybackWith += amount;\\n        // 500k gas is more than enough.\\n        try this.buybackDream{gas: 500000}() {} catch {}\\n    }\\n}\\n\\ncontract DreamMarketplace is ReentrancyGuard, Ownable, WrappedETH, Buyback {\\n    // MarketItem consists of buy-now and bid items.\\n    // Auction refers to items that can be bid on.\\n    // An item can either be buy-now or bid, or both.\\n    struct MarketItem {\\n        uint256 tokenId;\\n\\n        address payable seller;\\n\\n        // If purchasePrice is non-0, item can be bought out-right for that price\\n        // if bidPrice is non-0, item can be bid upon.\\n        uint256 purchasePrice;\\n        uint256 bidPrice;\\n\\n        uint8 state;\\n        uint64 listingCreationTime;\\n        uint64 auctionStartTime; // Set when first bid is received. 0 until then.\\n        uint64 auctionEndTime; // Initially it is the DURATION of the auction.\\n                               // After the first bid, it is set to the END time\\n                               // of the auction.\\n        // Defaults to 0. When 0, no bid has been placed yet.\\n        address payable highestBidder;\\n    }\\n\\n    struct BidHistory {       \\n        address bidder;\\n        uint256 bidAmount;\\n        uint64 bidTime;\\n    }\\n\\n    uint8 constant ON_MARKET = 0;\\n    uint8 constant SOLD = 1;\\n    uint8 constant CANCELLED = 2;\\n\\n    uint256 buybackResaleFeePercentage = 5;\\n    uint256 buybackMinterFeePercentage = 10;\\n    uint256 artistFeePercentage = 5;\\n    uint256 devFeePercentage = 10;\\n    uint256 nextBidPricePercentage = 105;\\n\\n\\n    uint256 delistCooldown = 600;\\n    uint256 extendedTime = 300;\\n\\n    // itemsOnMarket is a list of all items, historic and current, on the marketplace.\\n    // This includes items all of states, i.e items are never removed from this list.\\n    MarketItem[] public itemsOnMarket;\\n    \\n    mapping(uint256 => BidHistory[]) public itemsOnMarketBidHistories;\\n\\n    // dreamNFTAddress is the address for the Dream NFT address.\\n    address public dreamNFTAddress;\\n\\n    event AuctionItemAdded(\\n        uint256 marketId,\\n        uint256 tokenId,\\n        address tokenAddress,\\n        uint256 bidPrice,\\n        uint256 auctionDuration\\n    );\\n\\n    event FixedPriceItemAdded(\\n        uint256 marketId,\\n        uint256 tokenId,\\n        address tokenAddress,\\n        uint256 purchasePrice\\n    );\\n\\n    event ItemSold(\\n        uint256 marketId,\\n        uint256 tokenId,\\n        address buyer,\\n        uint256 purchasePrice,\\n        uint256 bidPrice\\n    );\\n\\n    event HighestBidIncrease(\\n        uint256 marketId,\\n        address bidder,\\n        uint256 amount,\\n        uint256 auctionEndTime\\n    );\\n\\n    event PriceReduction(\\n        uint256 marketId,\\n        uint256 newPurchasePrice,\\n        uint256 newBidPrice\\n    );\\n\\n    event ItemPulledFromMarket(uint256 id);\\n\\n    constructor(address _dreamNFTAddress, address _uniswapRouterAddress, address _dreamTokenAddress, address _devWallet) {\\n        dreamNFTAddress = _dreamNFTAddress;        \\n        updateBuybackUniswapRouter(_uniswapRouterAddress);\\n        dreamTokenAddress = _dreamTokenAddress;\\n        devWalletAddress = _devWallet;\\n    }\\n\\n    function updateUniswapRouter(address newRouterAddress) external onlyOwner {\\n        updateBuybackUniswapRouter(newRouterAddress);\\n    }\\n\\n    function updateDreamNFTAddress(address newAddress) external onlyOwner {\\n        dreamNFTAddress = newAddress;\\n    }\\n\\n    function updateDreamTokenAddress(address newAddress) external onlyOwner {\\n        dreamTokenAddress = newAddress;\\n    }\\n\\n    function isMinter(uint256 id, address target) internal returns (bool) {\\n        IDreamNFT sNFT = IDreamNFT(dreamNFTAddress);\\n        return sNFT.minter(id) == target;\\n    }\\n\\n    function minter(uint256 id) internal returns (address) {\\n        IDreamNFT sNFT = IDreamNFT(dreamNFTAddress);\\n        return sNFT.minter(id);\\n    }\\n\\n    function setFees(uint256 _buybackResaleFeePercentage, \\n        uint256 _buybackMinterFeePercentage,\\n        uint256 _artistFeePercentage,\\n        uint256 _devFeePercentage,\\n        uint256 _nextBidPricePercentage ) external onlyOwner {\\n        buybackResaleFeePercentage = _buybackResaleFeePercentage;\\n        buybackMinterFeePercentage = _buybackMinterFeePercentage;\\n        artistFeePercentage = _artistFeePercentage;\\n        devFeePercentage = _devFeePercentage;\\n        nextBidPricePercentage = _nextBidPricePercentage;\\n    }\\n\\n    function changeDevWalletAddress(address newAddress) external onlyOwner{\\n        devWalletAddress = newAddress;\\n    }\\n\\n    function setDelistCooldown(uint256 cooldown) external onlyOwner {\\n        delistCooldown = cooldown;\\n    }\\n\\n    function setExtendedTime(uint256 time) external onlyOwner {\\n        extendedTime = time;\\n    }\\n\\n    function handleFees(uint256 tokenId, uint256 amount, bool isMinterSale) internal returns (uint256) {\\n        uint256 buybackFee;\\n        if(!isMinterSale) {\\n            // In resale, 5% buyback and 5% to artist.\\n            // 90% to seller.\\n            buybackFee = amount * buybackResaleFeePercentage / 100;\\n            uint256 artistFee = amount * artistFeePercentage / 100;\\n            rewardETHToUser(minter(tokenId), artistFee);\\n            amount = amount - artistFee;\\n        } else {\\n            // When it's the minter selling, they get 80%\\n            // 10% to buyback\\n            // 10% to Dream dev wallet.\\n            buybackFee = amount * buybackMinterFeePercentage / 100;\\n            uint256 devFee = amount * devFeePercentage / 100;\\n            rewardETHToUser(devWalletAddress, devFee);\\n            amount = amount - devFee;\\n        }\\n        swapETHForTokens(buybackFee);\\n        return amount - buybackFee;\\n    }\\n    function withdrawStuckETH() external onlyOwner {\\n        bool success;\\n        (success,) = address(msg.sender).call{value: address(this).balance}(\\\"\\\");\\n    }\\n\\n   function withdrawStuckNFT(address nftAddress, uint256 tokenId) public onlyOwner{\\n        IERC721(nftAddress).safeTransferFrom(address(this), msg.sender, tokenId);\\n    }\\n\\n    function createAuctionItem(\\n        uint256 tokenId,\\n        address seller,\\n        uint256 purchasePrice,\\n        uint256 startingBidPrice,\\n        uint256 biddingTime\\n    ) internal {\\n        itemsOnMarket.push(\\n            MarketItem(\\n                tokenId,\\n                payable(seller),\\n                purchasePrice,\\n                startingBidPrice,\\n                ON_MARKET,\\n                uint64(block.timestamp),\\n                uint64(0),\\n                uint64(biddingTime),\\n                payable(address(0))\\n            )\\n        );\\n    }\\n    \\n    // purchasePrice is the direct purchasing price. Starting bid price\\n    // is the starting price for bids. If purchase price is 0, item cannot\\n    // be bought directly. Similarly for startingBidPrice, if it's 0, item\\n    // cannot be bid upon. One of them must be non-zero.\\n    function listItemOnAuction(\\n        address tokenAddress,\\n        uint256 tokenId,\\n        uint256 purchasePrice,\\n        uint256 startingBidPrice,\\n        uint256 biddingTime\\n    )\\n        external\\n        returns (uint256)\\n    {\\n        IERC721 tokenContract = IERC721(tokenAddress);\\n        require(tokenContract.ownerOf(tokenId) == msg.sender, \\\"Missing Item Ownership\\\");\\n        require(tokenContract.getApproved(tokenId) == address(this), \\\"Missing transfer approval\\\");\\n\\n        require(purchasePrice > 0 || startingBidPrice > 0, \\\"Item must have a price\\\");\\n        require(startingBidPrice == 0 || biddingTime > 60, \\\"Bidding time must be above one minute\\\");\\n\\n        uint256 newItemId = itemsOnMarket.length;\\n        createAuctionItem(\\n            tokenId,\\n            msg.sender,\\n            purchasePrice,\\n            startingBidPrice,\\n            biddingTime\\n        );\\n \\n        IERC721(dreamNFTAddress).transferFrom(\\n            msg.sender,\\n            address(this),\\n            tokenId\\n        );\\n        if(purchasePrice > 0) {            \\n            emit FixedPriceItemAdded(newItemId, tokenId, tokenAddress, purchasePrice);\\n        }\\n\\n        if(startingBidPrice > 0) {\\n            emit AuctionItemAdded(\\n                newItemId,\\n                tokenId,\\n                dreamNFTAddress,\\n                startingBidPrice,\\n                biddingTime\\n            );\\n        }\\n        return newItemId;\\n    }\\n\\n    function buyFixedPriceItem(uint256 id)\\n        external\\n        payable\\n        nonReentrant\\n    {\\n        require(id < itemsOnMarket.length, \\\"Invalid id\\\");\\n        MarketItem memory item = itemsOnMarket[id];\\n        require(item.state == ON_MARKET, \\\"Item not for sale\\\");\\n        require(msg.value >= item.purchasePrice, \\\"Not enough funds sent\\\");\\n        require(item.purchasePrice > 0, \\\"Item does not have a purchase price.\\\");\\n        require(msg.sender != item.seller, \\\"Seller can't buy\\\");\\n        item.state = SOLD;\\n        IERC721(dreamNFTAddress).safeTransferFrom(\\n            address(this),\\n            msg.sender,\\n            item.tokenId\\n        ); \\n        uint256 netPrice = handleFees(item.tokenId, item.purchasePrice, isMinter(item.tokenId, item.seller));\\n        rewardETHToUser(item.seller, netPrice);\\n        emit ItemSold(id, item.tokenId, msg.sender, item.purchasePrice, item.bidPrice);\\n        itemsOnMarket[id] = item;\\n\\n        // If the user sent excess ETH/BNB, send any extra back to the user.\\n        uint256 refundableEther = msg.value - item.purchasePrice;\\n        if(refundableEther > 0) {\\n            rewardETHToUser(msg.sender, refundableEther);\\n        }\\n    }\\n\\n    function placeBid(uint256 id)\\n        external\\n        payable\\n        nonReentrant\\n    {\\n        require(id < itemsOnMarket.length, \\\"Invalid id\\\");\\n        MarketItem memory item = itemsOnMarket[id];\\n\\n        require(item.state == ON_MARKET, \\\"Item not for sale\\\");\\n        \\n        require(block.timestamp < item.auctionEndTime || item.highestBidder == address(0), \\\"Auction has ended\\\");\\n        \\n        if (item.highestBidder != address(0)) {\\n            require(msg.value >= item.bidPrice * nextBidPricePercentage / 100, \\\"Bid must be 5% higher than previous bid\\\");\\n        } else {\\n            require(msg.value >= item.bidPrice, \\\"Too low bid\\\");\\n\\n            // First bid!\\n            item.auctionStartTime = uint64(block.timestamp);\\n            // item.auctionEnd is the auction duration. Add current time to it\\n            // to set it to the end time.\\n            item.auctionEndTime += uint64(block.timestamp);\\n        }\\n\\n        address previousBidder = item.highestBidder;\\n        // Return ETH to previous highest bidder.\\n        if (previousBidder != address(0)) {\\n            rewardETHToUser(previousBidder, item.bidPrice);\\n        }\\n\\n        item.highestBidder = payable(msg.sender);\\n        item.bidPrice = msg.value;\\n        // Extend the auction time by 5 minutes if there is less than 5 minutes remaining.\\n        // This is to prevent snipers sniping in the last block, and give everyone a chance\\n        // to bid.\\n        if ((item.auctionEndTime - block.timestamp) < extendedTime){\\n            item.auctionEndTime = uint64(block.timestamp + extendedTime);\\n        }\\n\\n        emit HighestBidIncrease(id, msg.sender, msg.value, item.auctionEndTime);\\n\\n        itemsOnMarket[id] = item;\\n\\n        itemsOnMarketBidHistories[id].push(                \\n                BidHistory(\\n                    msg.sender,\\n                    msg.value,\\n                    uint64(block.timestamp)                   \\n                )\\n            );\\n    }\\n\\n    function closeAuction(uint256 id)\\n        external\\n        nonReentrant\\n    {\\n        require(id < itemsOnMarket.length, \\\"Invalid id\\\");\\n        MarketItem memory item = itemsOnMarket[id];\\n\\n        require(item.state == ON_MARKET, \\\"Item not for sale\\\");\\n        require(item.bidPrice > 0, \\\"Item is not on auction.\\\");\\n        require(item.highestBidder != address(0), \\\"No bids placed\\\");\\n        require(block.timestamp > item.auctionEndTime, \\\"Auction is still on going\\\");\\n        \\n        item.state = SOLD;\\n        \\n        IERC721(dreamNFTAddress).transferFrom(\\n            address(this),\\n            item.highestBidder,\\n            item.tokenId\\n        );\\n        \\n        uint256 netPrice = handleFees(item.tokenId, item.bidPrice, isMinter(item.tokenId, item.seller));\\n        rewardETHToUser(item.seller, netPrice);\\n        \\n        emit ItemSold(id, item.tokenId, item.highestBidder, item.purchasePrice, item.bidPrice);\\n        itemsOnMarket[id] = item;\\n    }\\n\\n    function reducePrice(\\n        uint256 id,\\n        uint256 reducedPrice,\\n        uint256 reducedBidPrice\\n    )\\n        external\\n        nonReentrant\\n    {\\n        require(id < itemsOnMarket.length, \\\"Invalid id\\\");\\n        MarketItem memory item = itemsOnMarket[id];\\n        require(item.state == ON_MARKET, \\\"Item not for sale\\\");\\n        require(msg.sender == item.seller, \\\"Only the item seller can trigger a price reduction\\\");\\n        require(block.timestamp >= item.listingCreationTime + delistCooldown, \\\"Must wait after listing before lowering the listing price\\\");\\n        require(item.highestBidder == address(0), \\\"Cannot reduce price once a bid has been placed\\\");\\n        require(reducedBidPrice > 0 || reducedPrice > 0, \\\"Must reduce price\\\");\\n\\n        if (reducedPrice > 0) {\\n            require(\\n                item.purchasePrice > 0 && reducedPrice <= item.purchasePrice * 95 / 100,\\n                \\\"Reduced price must be at least 5% less than the current price\\\"\\n            );\\n            item.purchasePrice = reducedPrice;\\n        }\\n\\n        if (reducedBidPrice > 0) {\\n            require(\\n                item.bidPrice > 0 && reducedBidPrice <= item.bidPrice * 95 / 100,\\n                \\\"Reduced price must be at least 5% less than the current price\\\"\\n            );\\n            item.bidPrice = reducedPrice;\\n        }\\n\\n        itemsOnMarket[id] = item;\\n        emit PriceReduction(\\n            id,\\n            item.purchasePrice,\\n            item.bidPrice\\n        );\\n    }\\n\\n    function pullFromMarket(uint256 id)\\n        external\\n        nonReentrant\\n    {\\n        require(id < itemsOnMarket.length, \\\"Invalid id\\\");\\n        MarketItem memory item = itemsOnMarket[id];\\n\\n        require(item.state == ON_MARKET, \\\"Item not for sale\\\");\\n        require(msg.sender == item.seller, \\\"Only the item seller can pull an item from the marketplace\\\");\\n\\n        // Up for debate: Currently we don't allow items to be pulled if it's been bid on\\n        require(item.highestBidder == address(0), \\\"Cannot pull from market once a bid has been placed\\\");\\n        require(block.timestamp >= item.listingCreationTime + 600, \\\"Must wait ten minutes after listing before pulling from the market\\\");\\n        item.state = CANCELLED;\\n\\n        IERC721(dreamNFTAddress).transferFrom(\\n            address(this),\\n            item.seller,\\n            item.tokenId\\n        );\\n        itemsOnMarket[id] = item;\\n\\n        emit ItemPulledFromMarket(id);\\n    }\\n\\n    // A method for retrieve a NftMarketplaceId, given a NFTID\\n    function getMarketplaceId(uint256 tokenId)\\n        external\\n        view returns (uint256 marketplaceID)\\n    {\\n        bool result = false;\\n        for(uint256 idx = 0; idx < itemsOnMarket.length; idx++) {\\n            MarketItem memory item = itemsOnMarket[idx];\\n            if (item.tokenId == tokenId) {\\n                result = true;\\n                marketplaceID = idx;\\n                return marketplaceID;\\n            }            \\n        }\\n        require(result, \\\"Item not found\\\");\\n    }\\n\\n    function getBidHistories(uint256 id)\\n        external\\n        view\\n        returns (\\n            BidHistory[] memory bidHistories\\n        )\\n    {\\n        uint bidHistoryLength = itemsOnMarketBidHistories[id].length;\\n        require(0 < bidHistoryLength, \\\"not auction item\\\");\\n        bidHistories = itemsOnMarketBidHistories[id];\\n        return bidHistories;\\n    }\\n    \\n}\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\n// pragma solidity >=0.6.2;\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dreamNFTAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapRouterAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dreamTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionDuration\",\"type\":\"uint256\"}],\"name\":\"AuctionItemAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethSpent\",\"type\":\"uint256\"}],\"name\":\"DreamBuyback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"purchasePrice\",\"type\":\"uint256\"}],\"name\":\"FixedPriceItemAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionEndTime\",\"type\":\"uint256\"}],\"name\":\"HighestBidIncrease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ItemPulledFromMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"purchasePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidPrice\",\"type\":\"uint256\"}],\"name\":\"ItemSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPurchasePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBidPrice\",\"type\":\"uint256\"}],\"name\":\"PriceReduction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"UniswapRouterUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"buyFixedPriceItem\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buybackDream\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeDevWalletAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimETHForUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"closeAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dreamNFTAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dreamTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getBidHistories\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"bidTime\",\"type\":\"uint64\"}],\"internalType\":\"struct DreamMarketplace.BidHistory[]\",\"name\":\"bidHistories\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getMarketplaceId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"marketplaceID\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"itemsOnMarket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"purchasePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"listingCreationTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"auctionStartTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"auctionEndTime\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"highestBidder\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"itemsOnMarketBidHistories\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"bidTime\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchasePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingBidPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"biddingTime\",\"type\":\"uint256\"}],\"name\":\"listItemOnAuction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"placeBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"pullFromMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reducedPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reducedBidPrice\",\"type\":\"uint256\"}],\"name\":\"reducePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cooldown\",\"type\":\"uint256\"}],\"name\":\"setDelistCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setExtendedTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buybackResaleFeePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buybackMinterFeePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_artistFeePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_devFeePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nextBidPricePercentage\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateDreamNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateDreamTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouterAddress\",\"type\":\"address\"}],\"name\":\"updateUniswapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wethBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawStuckETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawStuckNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DreamMarketplace", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000021684c6b32665922755b5d5677c2df71cd0c64dd0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000008b17fea54d85f61e71bdf161e920762898ac53da000000000000000000000000cd11d4f84e6dd5cf256e595557ebd482399087ec", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}