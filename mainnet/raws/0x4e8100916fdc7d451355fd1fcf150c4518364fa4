{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.4;\r\n\r\n// Inspired by OpenZeppelin TokenTimelock contract\r\n// Reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/TokenTimelock.sol\r\n\r\n/// @title an abstract contract for timed events\r\n/// @author Fei Protocol\r\nabstract contract Timed {\r\n    /// @notice the start timestamp of the timed period\r\n    uint256 public startTime;\r\n\r\n    /// @notice the duration of the timed period\r\n    uint256 public duration;\r\n\r\n    event DurationUpdate(uint256 oldDuration, uint256 newDuration);\r\n\r\n    event TimerReset(uint256 startTime);\r\n\r\n    constructor(uint256 _duration) {\r\n        _setDuration(_duration);\r\n    }\r\n\r\n    modifier duringTime() {\r\n        require(isTimeStarted(), \"Timed: time not started\");\r\n        require(!isTimeEnded(), \"Timed: time ended\");\r\n        _;\r\n    }\r\n\r\n    modifier afterTime() {\r\n        require(isTimeEnded(), \"Timed: time not ended\");\r\n        _;\r\n    }\r\n\r\n    /// @notice return true if time period has ended\r\n    function isTimeEnded() public view returns (bool) {\r\n        return remainingTime() == 0;\r\n    }\r\n\r\n    /// @notice number of seconds remaining until time is up\r\n    /// @return remaining\r\n    function remainingTime() public view returns (uint256) {\r\n        return duration - timeSinceStart(); // duration always >= timeSinceStart which is on [0,d]\r\n    }\r\n\r\n    /// @notice number of seconds since contract was initialized\r\n    /// @return timestamp\r\n    /// @dev will be less than or equal to duration\r\n    function timeSinceStart() public view returns (uint256) {\r\n        if (!isTimeStarted()) {\r\n            return 0; // uninitialized\r\n        }\r\n        uint256 _duration = duration;\r\n        uint256 timePassed = block.timestamp - startTime; // block timestamp always >= startTime\r\n        return timePassed > _duration ? _duration : timePassed;\r\n    }\r\n\r\n    function isTimeStarted() public view returns (bool) {\r\n        return startTime != 0;\r\n    }\r\n\r\n    function _initTimed() internal {\r\n        startTime = block.timestamp;\r\n\r\n        emit TimerReset(block.timestamp);\r\n    }\r\n\r\n    function _setDuration(uint256 newDuration) internal {\r\n        require(newDuration != 0, \"Timed: zero duration\");\r\n\r\n        uint256 oldDuration = duration;\r\n        duration = newDuration;\r\n        emit DurationUpdate(oldDuration, newDuration);\r\n    }\r\n}\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n/// @title TokenTimelock interface\r\n/// @author Fei Protocol\r\ninterface ITokenTimelock {\r\n    // ----------- Events -----------\r\n\r\n    event Release(address indexed _beneficiary, address indexed _recipient, uint256 _amount);\r\n    event BeneficiaryUpdate(address indexed _beneficiary);\r\n    event PendingBeneficiaryUpdate(address indexed _pendingBeneficiary);\r\n\r\n    // ----------- State changing api -----------\r\n\r\n    function release(address to, uint256 amount) external;\r\n\r\n    function releaseMax(address to) external;\r\n\r\n    function setPendingBeneficiary(address _pendingBeneficiary) external;\r\n\r\n    function acceptBeneficiary() external;\r\n\r\n    // ----------- Getters -----------\r\n\r\n    function lockedToken() external view returns (IERC20);\r\n\r\n    function beneficiary() external view returns (address);\r\n\r\n    function pendingBeneficiary() external view returns (address);\r\n\r\n    function initialBalance() external view returns (uint256);\r\n\r\n    function availableForRelease() external view returns (uint256);\r\n\r\n    function totalToken() external view returns (uint256);\r\n\r\n    function alreadyReleasedAmount() external view returns (uint256);\r\n}\r\n\r\nabstract contract TokenTimelock is ITokenTimelock, Timed {\r\n    /// @notice ERC20 basic token contract being held in timelock\r\n    IERC20 public override lockedToken;\r\n\r\n    /// @notice beneficiary of tokens after they are released\r\n    address public override beneficiary;\r\n\r\n    /// @notice pending beneficiary appointed by current beneficiary\r\n    address public override pendingBeneficiary;\r\n\r\n    /// @notice initial balance of lockedToken\r\n    uint256 public override initialBalance;\r\n\r\n    uint256 internal lastBalance;\r\n\r\n    /// @notice number of seconds before releasing is allowed\r\n    uint256 public immutable cliffSeconds;\r\n\r\n    address public immutable clawbackAdmin;\r\n\r\n    constructor(\r\n        address _beneficiary,\r\n        uint256 _duration,\r\n        uint256 _cliffSeconds,\r\n        address _lockedToken,\r\n        address _clawbackAdmin\r\n    ) Timed(_duration) {\r\n        require(_duration != 0, \"TokenTimelock: duration is 0\");\r\n        require(_beneficiary != address(0), \"TokenTimelock: Beneficiary must not be 0 address\");\r\n\r\n        beneficiary = _beneficiary;\r\n        _initTimed();\r\n\r\n        _setLockedToken(_lockedToken);\r\n\r\n        cliffSeconds = _cliffSeconds;\r\n\r\n        clawbackAdmin = _clawbackAdmin;\r\n    }\r\n\r\n    // Prevents incoming LP tokens from messing up calculations\r\n    modifier balanceCheck() {\r\n        if (totalToken() > lastBalance) {\r\n            uint256 delta = totalToken() - lastBalance;\r\n            initialBalance = initialBalance + delta;\r\n        }\r\n        _;\r\n        lastBalance = totalToken();\r\n    }\r\n\r\n    modifier onlyBeneficiary() {\r\n        require(msg.sender == beneficiary, \"TokenTimelock: Caller is not a beneficiary\");\r\n        _;\r\n    }\r\n\r\n    /// @notice releases `amount` unlocked tokens to address `to`\r\n    function release(address to, uint256 amount) external override onlyBeneficiary balanceCheck {\r\n        require(amount != 0, \"TokenTimelock: no amount desired\");\r\n        require(passedCliff(), \"TokenTimelock: Cliff not passed\");\r\n\r\n        uint256 available = availableForRelease();\r\n        require(amount <= available, \"TokenTimelock: not enough released tokens\");\r\n\r\n        _release(to, amount);\r\n    }\r\n\r\n    /// @notice releases maximum unlocked tokens to address `to`\r\n    function releaseMax(address to) external override onlyBeneficiary balanceCheck {\r\n        require(passedCliff(), \"TokenTimelock: Cliff not passed\");\r\n        _release(to, availableForRelease());\r\n    }\r\n\r\n    /// @notice the total amount of tokens held by timelock\r\n    function totalToken() public view virtual override returns (uint256) {\r\n        return lockedToken.balanceOf(address(this));\r\n    }\r\n\r\n    /// @notice amount of tokens released to beneficiary\r\n    function alreadyReleasedAmount() public view override returns (uint256) {\r\n        return initialBalance - totalToken();\r\n    }\r\n\r\n    /// @notice amount of held tokens unlocked and available for release\r\n    function availableForRelease() public view override returns (uint256) {\r\n        uint256 elapsed = timeSinceStart();\r\n\r\n        uint256 totalAvailable = _proportionAvailable(initialBalance, elapsed, duration);\r\n        uint256 netAvailable = totalAvailable - alreadyReleasedAmount();\r\n        return netAvailable;\r\n    }\r\n\r\n    /// @notice current beneficiary can appoint new beneficiary, which must be accepted\r\n    function setPendingBeneficiary(address _pendingBeneficiary) public override onlyBeneficiary {\r\n        pendingBeneficiary = _pendingBeneficiary;\r\n        emit PendingBeneficiaryUpdate(_pendingBeneficiary);\r\n    }\r\n\r\n    /// @notice pending beneficiary accepts new beneficiary\r\n    function acceptBeneficiary() public virtual override {\r\n        _setBeneficiary(msg.sender);\r\n    }\r\n\r\n    function clawback() public balanceCheck {\r\n        require(msg.sender == clawbackAdmin, \"TokenTimelock: Only clawbackAdmin\");\r\n        if (passedCliff()) {\r\n            _release(beneficiary, availableForRelease());\r\n        }\r\n        _release(clawbackAdmin, totalToken());\r\n    }\r\n\r\n    function passedCliff() public view returns (bool) {\r\n        return timeSinceStart() >= cliffSeconds;\r\n    }\r\n\r\n    function _proportionAvailable(\r\n        uint256 initialBalance,\r\n        uint256 elapsed,\r\n        uint256 duration\r\n    ) internal pure virtual returns (uint256);\r\n\r\n    function _setBeneficiary(address newBeneficiary) internal {\r\n        require(newBeneficiary == pendingBeneficiary, \"TokenTimelock: Caller is not pending beneficiary\");\r\n        beneficiary = newBeneficiary;\r\n        emit BeneficiaryUpdate(newBeneficiary);\r\n        pendingBeneficiary = address(0);\r\n    }\r\n\r\n    function _setLockedToken(address tokenAddress) internal {\r\n        lockedToken = IERC20(tokenAddress);\r\n    }\r\n\r\n    function _release(address to, uint256 amount) internal {\r\n        lockedToken.transfer(to, amount);\r\n        emit Release(beneficiary, to, amount);\r\n    }\r\n}\r\n\r\ncontract LinearTokenTimelock is TokenTimelock {\r\n    constructor(\r\n        address _beneficiary,\r\n        uint256 _duration,\r\n        address _lockedToken,\r\n        uint256 _cliffDuration,\r\n        address _clawbackAdmin,\r\n        uint256 _startTime\r\n    ) TokenTimelock(_beneficiary, _duration, _cliffDuration, _lockedToken, _clawbackAdmin) {\r\n        if (_startTime != 0) {\r\n            startTime = _startTime;\r\n        }\r\n    }\r\n\r\n    function _proportionAvailable(\r\n        uint256 initialBalance,\r\n        uint256 elapsed,\r\n        uint256 duration\r\n    ) internal pure override returns (uint256) {\r\n        return (initialBalance * elapsed) / duration;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lockedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cliffDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_clawbackAdmin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"BeneficiaryUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"DurationUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pendingBeneficiary\",\"type\":\"address\"}],\"name\":\"PendingBeneficiaryUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Release\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"TimerReset\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"alreadyReleasedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableForRelease\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clawback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clawbackAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cliffSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTimeEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTimeStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"passedCliff\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingBeneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"releaseMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pendingBeneficiary\",\"type\":\"address\"}],\"name\":\"setPendingBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeSinceStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LinearTokenTimelock", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a285ea5495e22fbf66b0d0ca05560411677398900000000000000000000000000000000000000000000000000000000001dfe200000000000000000000000000956f47f50a910163d8bf957cf5846d573e7f87ca00000000000000000000000000000000000000000000000000000000000000000000000000000000000000005ea4a9a7592683bf0bc187d6da706c6c4770976f0000000000000000000000000000000000000000000000000000000062304c2b", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://257ceba216a4cf98a2b8ddca05365041ff43354006d841d2c2f60825c0ff7da3"}]}