{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ETHRouter_V2.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSE\\npragma solidity ^0.8.0;\\n\\n//i mport \\\"hardhat/console.sol\\\";\\n\\n//i mport \\\"./libraries/BytesLib.sol\\\";\\nimport \\\"./libraries/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./libraries/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\\\";\\n//i mport \\\"./libraries/v2-core/contracts/interfaces/IUniswapV2Callee.sol\\\";\\n//i mport \\\"./libraries/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\\\";\\nimport \\\"./libraries/v2-core/contracts/interfaces/IERC20.sol\\\";\\n//i mport \\\"./libraries/anyswap-v1-core/contracts/AnyswapV4CallProxy.sol\\\";\\n\\nimport \\\"./ETHRouter_V2_CalldataLoader.sol\\\";\\nimport \\\"./ETHRouter_V2_types.sol\\\";\\n\\nimport \\\"./ETHRouter_V2_selectors.sol\\\";\\n\\ncontract ETHRouter_V2 { //is IUniswapV2Callee, IUniswapV3SwapCallback {\\n  using SafeMath for uint;\\n  using SafeMath for int;\\n  using CalldataLoader for uint;\\n  using CallType_1_lib for CallType_1_lib.CallType_1_vars;\\n//  address current_pool;\\n\\n  address public owner;\\n  uint public constant network = 1;\\n\\n  uint public constant SLIPPAGE_LIMIT = 200;\\n\\n  constructor() {\\n    owner = msg.sender;\\n  }\\n\\n  modifier ownerOnly {\\n//////    console.log(\\\"owner: \\\", owner, \\\" | msg.sender: \\\", msg.sender);\\n    require(owner == msg.sender);\\n    _;\\n  }\\n\\n  function setOwner(address newOwner) external ownerOnly {\\n    owner = newOwner;\\n  }\\n\\n  function exec(bytes calldata data) external returns (uint256) {\\n//    console.log(\\\"---exec V2---: data.length:\\\", data.length);\\n    uint ind = 68;// = 0\\n    {\\n      uint _network = ind.loadUint16();\\n      ind += 2;\\n      require(network == _network, \\\"WRONGNETWORK\\\");\\n      uint version = ind.loadUint8();\\n      ind++;\\n      require(version == 2, \\\"WRONGVERSION\\\");\\n    }\\n    uint slippage = ind.loadUint8();\\n    ind++;\\n//    console.log(\\\"slippage:\\\", slippage);\\n    uint tokens_num = ind.loadUint8();\\n    ind++;\\n//    console.log(\\\"tokens_num:\\\", tokens_num);\\n//    uint tokens_start = ind; // just shr( ... ) instead of shr(shl( ... )) // ind + 68 - 12;\\n//    console.log(\\\"ind:\\\", ind);\\n    ind += tokens_num.mul(20);\\n//    for (uint j = 0; j < tokens_num; j++) {\\n////      console.log(j, \\\":\\\", j.loadTokenFromArray());\\n//    }\\n    uint[] memory balances = new uint[](tokens_num);\\n//    for (uint i = 0; i < tokens_num; i++) {\\n//      balances[i] = 0;\\n//    }\\n//    console.log(\\\"ind:\\\", ind);\\n    uint num_of_calls = ind.loadUint8();// = uint8(data[ind]);\\n    ind++;\\n//    console.log(\\\"num_of_calls:\\\", num_of_calls);\\n    for (uint i = 0; i < num_of_calls; i++) {\\n      uint calltype = ind.loadUint8();// = uint8(data[ind]);\\n      ind++;\\n      if (calltype == 1) { // transfer to univ2-like pair and swap\\n//        console.log(\\\"\\\\ncalltype == 1\\\");\\n        CallType_1_lib.CallType_1_vars memory vars;\\n        ind = vars.load(ind, tokens_num);\\n        \\n//        uint available_amount;\\n        if (vars.flags & CallType_1_lib.CT_1_FROM_SENDER != 0) {\\n//          available_amount = vars.amount_in_expected;\\n//          console.log(\\\"allowed balanceOf:\\\", IERC20(vars.token_source).allowance(msg.sender, address(this)));\\n          vars.amount_to_be_sent = vars.amount_in_expected;\\n        } else {\\n          uint available_amount = balances[vars.token_source_ind];\\n//          console.log(\\\"available_amount:\\\", available_amount);\\n          {\\n            uint limit = vars.amount_in_expected.mul(SLIPPAGE_LIMIT.sub(slippage));\\n            limit = limit.div(SLIPPAGE_LIMIT);\\n            if (vars.amount_in_expected > 1000) {\\n              require(available_amount > limit, \\\"1S\\\"); \\n            } else {\\n              if (available_amount == 0) {\\n                continue; // skip since it's just dust\\n              }\\n              //pass since it's supposedly just dust\\n            }\\n          }\\n\\n          vars.amount_to_be_sent = available_amount > vars.amount_in_expected ? vars.amount_in_expected : available_amount;\\n//          console.log(\\\"balanceOf:\\\", IERC20(vars.token_source).balanceOf(address(this)));\\n        }\\n\\n        vars.doIt();\\n\\n        balances[vars.token_source_ind] -= vars.minus_source; \\n        balances[vars.token_target_ind] += vars.plus_target;\\n      } else if (calltype == 2) { //transfer funds to msg.sender\\n//        console.log(\\\"\\\\ncalltype == 2\\\");\\n        uint token_ind = ind.loadUint8();\\n        ind++;\\n//        console.log(\\\"token_ind:\\\", token_ind);\\n        require(token_ind < tokens_num, \\\"2TO\\\");\\n        address token = token_ind.loadTokenFromArray();\\n        uint amount_expected;\\n        {\\n          uint amount_len = ind.loadUint8();\\n          ind++;\\n          amount_expected = ind.loadVariableUint(amount_len);\\n          ind += amount_len;\\n        }\\n//        console.log(\\\"amount_expected:\\\", amount_expected);\\n//        console.log(\\\"balances[token_ind]:\\\", balances[token_ind]);\\n        require(balances[token_ind] >= amount_expected.mul(SLIPPAGE_LIMIT.sub(slippage)).div(SLIPPAGE_LIMIT), \\\"2S\\\");\\n        (bool success, ) = token.call(abi.encodeWithSelector(Selectors.TRANSFER_SELECTOR, msg.sender, balances[token_ind]));\\n        require(success, \\\"2TR\\\");\\n        balances[token_ind] = 0; // the order is ok since it is not in storage\\n      } else if (calltype == 4) { //fetch funds from msg.sender\\n//        console.log(\\\"\\\\ncalltype == 4\\\");\\n        uint token_ind = ind.loadUint8();\\n        ind++;\\n//        console.log(\\\"token_ind:\\\", token_ind);\\n        require(token_ind < tokens_num, \\\"4TO\\\");\\n        address token = token_ind.loadTokenFromArray();\\n//        console.log(\\\"token:\\\", token);\\n        uint amount;\\n        {\\n          uint amount_len = ind.loadUint8();\\n          ind++;\\n          amount = ind.loadVariableUint(amount_len);\\n          ind += amount_len;\\n        }\\n//        console.log(\\\"amount:\\\", amount);\\n        (bool success, ) = token.call(abi.encodeWithSelector(Selectors.TRANSFERFROM_SELECTOR, msg.sender, address(this), amount));\\n        require(success, \\\"4TR\\\");\\n        balances[token_ind] += amount;\\n//        console.log(\\\"balanceOf:\\\", IERC20(token).balanceOf(address(this)));\\n      } else if (calltype == 3) { // uniV2swap just swap\\n//        console.log(\\\"\\\\ncalltype == 3\\\");\\n        revert(\\\"CT3\\\"); // reserved for future\\n      } else if (calltype == 0) { // exec\\n//        console.log(\\\"\\\\ncalltype == 0\\\");\\n        require(msg.sender == owner, \\\"OWN\\\");\\n        address addr = ind.loadAddress();\\n        ind += 20;\\n        uint len = ind.loadUint16();\\n        ind += 2;\\n        uint start = ind.sub(68);\\n        (bool success, ) = addr.call(data[start : start + len]);\\n        require(success);\\n      } else {\\n//        console.log(\\\"\\\\ncalltype ==\\\", calltype);\\n        revert(\\\"CT\\\");\\n      }\\n    }\\n    return ind;\\n  }\\n\\n  function calcUniswapV2Out(uint r0, uint r1, uint a0) pure private returns (uint a1) {\\n    uint numer = r1.mul(a0).mul(997);\\n    uint denom = r0.mul(1000).add(a0.mul(997));\\n    a1 = numer.div(denom);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/v2-core/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/ETHRouter_V2_CalldataLoader.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libraries/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\\\";\\n\\nlibrary CalldataLoader {\\n  using SafeMath for uint;\\n\\n  function loadUint8(uint self) pure internal returns (uint x) {\\n    assembly {\\n      x := shr(248, calldataload(self))\\n    }\\n  }\\n  function loadUint16(uint self) pure internal returns (uint x) {\\n    assembly {\\n      x := shr(240, calldataload(self))\\n    }\\n  }\\n  function loadAddress(uint self) pure internal returns (address x) {\\n    assembly {\\n      x := shr(96, calldataload(self)) // 12 * 8 = 96\\n    }\\n  }\\n  function loadTokenFromArray(uint self) pure internal returns (address x) {\\n    assembly {\\n      x := shr(96, calldataload(add(73, mul(20, self)))) // 73 = 68 + 5\\n    }\\n  }\\n  function loadVariableUint(uint self, uint len) pure internal returns (uint x) {\\n    uint extra = uint(32).sub(len) << 3;\\n    assembly {\\n      x := shr(extra, calldataload(self))\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ETHRouter_V2_types.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\n//import \\\"hardhat/console.sol\\\";\\n\\nimport \\\"./libraries/openzeppelin-contracts/contracts/utils/math/SafeMath.sol\\\";\\n\\nimport \\\"./libraries/v2-core/contracts/interfaces/IERC20.sol\\\";\\n\\nimport \\\"./ETHRouter_V2_selectors.sol\\\";\\nimport \\\"./ETHRouter_V2_CalldataLoader.sol\\\";\\n\\nlibrary CallType_1_lib {\\n  using SafeMath for uint;\\n  using CalldataLoader for uint;\\n\\n  struct CallType_1_vars {\\n    uint flags;\\n//    uint next_uniswap_v2_token_ind;\\n//    uint uniswap_v2_or_sushi; // 0 uniswap V2, 1 sushi\\n    uint token_source_ind;\\n    uint token_target_ind;\\n    address token_source;\\n    address token_target;\\n    uint amount_in_expected;\\n    uint amount_out_expected;\\n    uint amount_to_be_sent;\\n    address v2pair;\\n    uint amount_out;\\n    uint minus_source;\\n    uint plus_target;\\n  }\\n\\n  using CallType_1_lib for CallType_1_vars;\\n\\n  uint internal constant CT_1_FROM_SENDER = 1;\\n  uint internal constant CT_1_TO_SENDER = 2;\\n  uint internal constant CT_1_UNISWAP_OR_SUSHISWAP = 4; // false == uniswap, true == sushiswap\\n  uint internal constant CT_1_SUSHISWAP = 4;\\n\\n  function load(CallType_1_vars memory self, uint ind, uint tokens_num) internal pure returns (uint new_ind) {\\n    self.flags = ind.loadUint8();\\n    ind++;\\n//        console.log(\\\"self.flags:\\\", self.flags);\\n\\n    self.token_source_ind = ind.loadUint8();// = uint8(data[ind]);\\n    ind++;\\n//        console.log(\\\"self.token_source_ind:\\\", self.token_source_ind);\\n    require(self.token_source_ind < tokens_num, \\\"1SI\\\");\\n    self.token_source = self.token_source_ind.loadTokenFromArray();\\n//        console.log(\\\"self.token_source:\\\", self.token_source);\\n\\n    self.token_target_ind = ind.loadUint8(); //= uint8(data[ind]);\\n    ind++;\\n//        console.log(\\\"self.token_target_ind:\\\", self.token_target_ind);\\n    require(self.token_target_ind < tokens_num, \\\"1TI\\\");\\n    self.token_target = self.token_target_ind.loadTokenFromArray();\\n//        console.log(\\\"self.token_target:\\\", self.token_target);\\n\\n    {\\n      uint amount_in_len = ind.loadUint8();// = uint(uint8(data[ind]));\\n      ind++;\\n      self.amount_in_expected = ind.loadVariableUint(amount_in_len);\\n      ind += amount_in_len;\\n//          console.log(\\\"self.amount_in_expected:\\\", self.amount_in_expected);\\n    }\\n\\n    {\\n      uint amount_out_len = ind.loadUint8();\\n      ind++;\\n      self.amount_out_expected = ind.loadVariableUint(amount_out_len);\\n      ind += amount_out_len;\\n//          console.log(\\\"self.amount_out_expected:\\\", self.amount_out_expected);\\n    }\\n    return ind;\\n  }\\n\\n  function doIt(CallType_1_vars memory self) internal {\\n//    console.log(\\\"doIt_\\\");\\n    if (self.token_source < self.token_target) {\\n      self.getUniV2Pair_direct_order();\\n      self.UniV2CalcAmount1();\\n      if (self.amount_out == 0) {\\n        return;\\n      }\\n      self.transferToUniV2Pair();\\n      self.fetchFromUniV2Pair_1();\\n    } else {\\n      self.getUniV2Pair_reverse_order();\\n      self.UniV2CalcAmount0();\\n      if (self.amount_out == 0) {\\n        return;\\n      }\\n      self.transferToUniV2Pair();\\n      self.fetchFromUniV2Pair_0();\\n    }\\n  }\\n\\n  function getFactory(CallType_1_vars memory self) internal pure returns(address) {\\n    address factory;\\n    uint switcher = self.flags & CT_1_UNISWAP_OR_SUSHISWAP;\\n    if (switcher == 0) {\\n      factory = Addrs.UNISWAP_V2_FACTORY;\\n    } else if (switcher != 0) {\\n      factory = Addrs.SUSHI_FACTORY;\\n    } else {\\n      revert(\\\"UOS\\\");\\n    }\\n    return factory;\\n  }\\n\\n  function getUniV2Pair_direct_order(CallType_1_vars memory self) internal view {\\n//    console.log(\\\"CT_1_lib.getuniV2Pair_direct_order\\\");\\n    (bool success, bytes memory res) = self.getFactory().staticcall(abi.encodeWithSelector(Selectors.UNISWAP_V2_GETPAIR_SELECTOR, self.token_source, self.token_target));\\n    require(success, \\\"1GPDO\\\");\\n    address v2pair;\\n    assembly {\\n      v2pair := mload(add(res, 32))\\n    }\\n    require(v2pair != address(0), \\\"1PRDO\\\");\\n    self.v2pair = v2pair;\\n  }\\n\\n  function getUniV2Pair_reverse_order(CallType_1_vars memory self) internal view {\\n//    console.log(\\\"CT_1_lib.getuniV2Pair_reverse_order\\\");\\n    (bool success, bytes memory res) = self.getFactory().staticcall(abi.encodeWithSelector(Selectors.UNISWAP_V2_GETPAIR_SELECTOR, self.token_target, self.token_source));\\n    require(success, \\\"1GPRO\\\");\\n    address v2pair;\\n    assembly {\\n      v2pair := mload(add(res, 32))\\n    }\\n    require(v2pair != address(0), \\\"1PRRO\\\");\\n    self.v2pair = v2pair;\\n  }\\n\\n  function transferToUniV2Pair(CallType_1_vars memory self) internal {\\n    if (self.flags & CT_1_FROM_SENDER != 0) {\\n      self.transferToUniV2Pair_from_sender();\\n      self.minus_source = 0;\\n    } else {\\n      self.transferToUniV2Pair_from_this();\\n      self.minus_source = self.amount_to_be_sent;\\n    }\\n  }\\n\\n  function transferToUniV2Pair_from_this(CallType_1_vars memory self) internal {\\n//    console.log(\\\"transferToUniV2Pair_from_this\\\");\\n    (bool success, ) = self.token_source.call(abi.encodeWithSelector(Selectors.TRANSFER_SELECTOR, self.v2pair, self.amount_to_be_sent));\\n    require(success, \\\"1TTUV2\\\");\\n  }\\n\\n  function transferToUniV2Pair_from_sender(CallType_1_vars memory self) internal {\\n//    console.log(\\\"transferToUniV2Pair from sender\\\");\\n    (bool success, ) = self.token_source.call(abi.encodeWithSelector(Selectors.TRANSFERFROM_SELECTOR, msg.sender, self.v2pair, self.amount_to_be_sent));\\n    require(success, \\\"1TTUV2F\\\");\\n  }\\n\\n  function fetchFromUniV2Pair_0(CallType_1_vars memory self) internal {\\n    if (self.flags & CT_1_TO_SENDER != 0) {\\n      self.fetchFromUniV2Pair_0_to_sender();\\n      self.plus_target = 0;\\n    } else {\\n      self.fetchFromUniV2Pair_0_to_this();\\n      self.plus_target = self.amount_out;\\n    }\\n  }\\n\\n  function fetchFromUniV2Pair_1(CallType_1_vars memory self) internal {\\n    if (self.flags & CT_1_TO_SENDER != 0) {\\n      self.fetchFromUniV2Pair_1_to_sender();\\n      self.plus_target = 0;\\n    } else {\\n      self.fetchFromUniV2Pair_1_to_this();\\n      self.plus_target = self.amount_out;\\n    }\\n  }\\n\\n  function fetchFromUniV2Pair_0_to_this(CallType_1_vars memory self) internal {\\n//    console.log(\\\"fetchFromUniV2Pair_0_to_this\\\");\\n    (bool success, ) = self.v2pair.call(abi.encodeWithSelector(Selectors.UNISWAP_V2_PAIR_SWAP_SELECTOR, self.amount_out, 0, address(this), new bytes(0)));\\n    require(success, \\\"1F0FUV2\\\");\\n  }\\n\\n  function fetchFromUniV2Pair_1_to_this(CallType_1_vars memory self) internal {\\n//    console.log(\\\"fetchFromUniV2Pair_1_to_this\\\");\\n    (bool success, ) = self.v2pair.call(abi.encodeWithSelector(Selectors.UNISWAP_V2_PAIR_SWAP_SELECTOR, 0, self.amount_out, address(this), new bytes(0)));\\n    require(success, \\\"1F1FUV2\\\");\\n  }\\n\\n  function fetchFromUniV2Pair_0_to_sender(CallType_1_vars memory self) internal {\\n//    console.log(\\\"fetchFromUniV2Pair_0_to_sender\\\");\\n    (bool success, ) = self.v2pair.call(abi.encodeWithSelector(Selectors.UNISWAP_V2_PAIR_SWAP_SELECTOR, self.amount_out, 0, msg.sender, new bytes(0)));\\n    require(success, \\\"1F0FUV2L\\\");\\n  }\\n\\n  function fetchFromUniV2Pair_1_to_sender(CallType_1_vars memory self) internal {\\n//    console.log(\\\"fetchFromUniV2Pair_1_to sender\\\");\\n    (bool success, ) = self.v2pair.call(abi.encodeWithSelector(Selectors.UNISWAP_V2_PAIR_SWAP_SELECTOR, 0, self.amount_out, msg.sender, new bytes(0)));\\n    require(success, \\\"1F1FUV2L\\\");\\n  }\\n\\n  function UniV2CalcAmount0(CallType_1_vars memory self) view internal {\\n    (bool success, bytes memory res) = self.v2pair.staticcall(abi.encodeWithSelector(Selectors.UNISWAP_V2_GETRESERVES_SELECTOR));\\n    require(success, \\\"1GR0\\\");\\n    (uint112 reserve_0, uint112 reserve_1, ) = abi.decode(res, (uint112, uint112, uint32));\\n    self.amount_out = calcUniswapV2Out(reserve_1, reserve_0, self.amount_to_be_sent);\\n  }\\n\\n  function UniV2CalcAmount1(CallType_1_vars memory self) view internal {\\n    (bool success, bytes memory res) = self.v2pair.staticcall(abi.encodeWithSelector(Selectors.UNISWAP_V2_GETRESERVES_SELECTOR));\\n    require(success, \\\"1GR1\\\");\\n    (uint112 reserve_0, uint112 reserve_1, ) = abi.decode(res, (uint112, uint112, uint32));\\n    self.amount_out = calcUniswapV2Out(reserve_0, reserve_1, self.amount_to_be_sent);\\n  }\\n\\n  function calcUniswapV2Out(uint r0, uint r1, uint a0) pure private returns (uint a1) {\\n    uint numer = r1.mul(a0).mul(997);\\n    uint denom = r0.mul(1000).add(a0.mul(997));\\n    a1 = numer.div(denom);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/ETHRouter_V2_selectors.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nlibrary Addrs {\\n  address internal constant UNISWAP_V2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // ON ETHER OR EVERYWHERE ?\\n  address internal constant SUSHI_FACTORY = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac; // ON ETHER\\n//  address internal constant SUSHI_FACTORY = 0xc35DADB65012eC5796536bD9864eD8773aBc74C4; // ON MOVR\\n//  address internal constant ANYSWAP_ETH_TO_MOVR_BRIDGE = 0x10c6b61DbF44a083Aec3780aCF769C77BE747E23;\\n//  address internal constant ANYCALLPROXY_ON_ETHER = 0x37414a8662bC1D25be3ee51Fb27C2686e2490A89;\\n}\\n\\nlibrary Selectors {\\n  bytes4 internal constant UNISWAP_V2_GETPAIR_SELECTOR = bytes4(keccak256(\\\"getPair(address,address)\\\"));\\n  bytes4 internal constant UNISWAP_V2_GETRESERVES_SELECTOR = bytes4(keccak256(\\\"getReserves()\\\"));\\n\\n  bytes4 internal constant UNISWAP_V2_PAIR_SWAP_SELECTOR = bytes4(keccak256(\\\"swap(uint256,uint256,address,bytes)\\\"));\\n\\n  uint internal constant SLIPPAGE_LIMIT = 200;\\n//  bytes4 internal constant ANYCALLPROXY_ANYCALL_SELECTOR = bytes4(keccak256(\\\"anyCall(address,bytes,address,uint256)\\\"));\\n\\n  bytes4 internal constant TRANSFER_SELECTOR = bytes4(keccak256(\\\"transfer(address,uint256)\\\"));\\n  bytes4 internal constant TRANSFERFROM_SELECTOR = bytes4(keccak256(\\\"transferFrom(address,address,uint256)\\\"));\\n  bytes4 internal constant BALANCEOF_SELECTOR = bytes4(keccak256(\\\"balanceOf(address)\\\"));\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"SLIPPAGE_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"exec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"network\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ETHRouter_V2", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://73c48bcb69c910e3352419337699390352d0f922b92d937781b204d78a839641"}]}