{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ninterface ERC721TokenReceiver {\r\n\r\n  /**\r\n   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\r\n   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n   * of other than the magic value MUST result in the transaction being reverted.\r\n   * Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` unless throwing.\r\n   * @notice The contract address is always the message sender. A wallet/broker/auction application\r\n   * MUST implement the wallet interface if it will accept safe transfers.\r\n   * @param _operator The address which called `safeTransferFrom` function.\r\n   * @param _from The address which previously owned the token.\r\n   * @param _tokenId The NFT identifier which is being transferred.\r\n   * @param _data Additional data with no specified format.\r\n   */\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) external returns(bytes4);\r\n}\r\n\r\ncontract BitTower {\r\n    address constant internal NULL_ADDRESS = 0x0000000000000000000000000000000000000000;\r\n    \r\n    // ERC721 requires ERC165\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n    \r\n    // ERC721\r\n    mapping (uint256 => address) internal idToOwner;\r\n    mapping (uint256 => address) internal idToApprovals;\r\n    mapping (address => uint256) internal ownerToNFTokenCount;\r\n    mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n    bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // IERC721Enumerable\r\n    \r\n    \r\n    // ERC721Metadata\r\n    string constant public name = \"BitTower\";\r\n    string constant public symbol = \"BITT\";\r\n    \r\n    // Custom\r\n    string internal baseUri = \"https://bit-tower-bit-tower-business.vercel.app/api/floor/\";\r\n    uint256[] internal tokenIDs;\r\n    mapping (uint256 => address) public originalTokenOwner;\r\n\r\n    mapping (address => bool) public preLaunchWhitelisted;\r\n    uint256 public mintCost = 0.09 ether;\r\n    uint256 public startTime = 0; // unixTime\r\n    uint256 public maxTotalSupply = 100;\r\n\r\n    address internal owner;\r\n    address internal newOwner;\r\n    \r\n    \r\n    \r\n    // ERC721 Events\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 indexed _tokenId\r\n    );\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _approved,\r\n        uint256 indexed _tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed _owner,\r\n        address indexed _operator,\r\n        bool _approved\r\n    );\r\n    \r\n    // Used for approvals\r\n    modifier canOperate(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender], \"ERR_ERC721_NOT_OWNED_OR_APPROVED\");\r\n        _;\r\n    }\r\n    // Self-explanitory\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(\r\n            tokenOwner == msg.sender\r\n            || getApproved(_tokenId) == msg.sender\r\n            || ownerToOperators[tokenOwner][msg.sender],\r\n            \"ERR_ERC721_NOT_OWNED_OR_APPROVED\"\r\n        );\r\n        _;\r\n    }\r\n    // Unminted tokens are invalid. These can't be burned anyway\r\n    modifier validNFToken(uint256 _tokenId) {\r\n        require(idToOwner[_tokenId] != NULL_ADDRESS, \"ERR_ERC721_NONEXISTANT\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"ERR_BITT_ONLY_OWNER\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPostLaunch {\r\n        require(block.timestamp > startTime || preLaunchWhitelisted[msg.sender], \"ERR_BITT_TOO_EARLY\");\r\n        _;\r\n    }\r\n    \r\n    constructor(uint256 _startTime) {\r\n        supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\r\n        supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\r\n        startTime = _startTime;\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    // Custom functions\r\n    function setNewOwner(address o) public onlyOwner {\r\n        newOwner = o;\r\n    }\r\n    \r\n    function acceptNewOwner() public {\r\n        require(msg.sender == newOwner);\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function setBaseUri(string memory _uri) public onlyOwner {\r\n        baseUri = _uri;\r\n    }\r\n\r\n    function setMintCost(uint256 _cost) public onlyOwner {\r\n        mintCost = _cost;\r\n    }\r\n\r\n    function setMaxTotalSupply(uint256 _maxSupply) public onlyOwner {\r\n        maxTotalSupply = _maxSupply;\r\n    }\r\n\r\n    function addToPreLaunch(address[] memory _addresses) public onlyOwner {\r\n        for(uint256 i = 0; i < _addresses.length; i += 1){\r\n            preLaunchWhitelisted[_addresses[i]] = true;\r\n        }\r\n    }\r\n\r\n    function withdrawFunds() public onlyOwner{\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function payToMint(address recipient, uint256 _tokenId) public payable onlyPostLaunch {\r\n        require(msg.value >= mintCost, \"ERR_BITT_UNDERPAY\");\r\n        _mint(recipient, _tokenId);\r\n    }\r\n\r\n    function allNFTsMintedSoFar() public view returns (uint256[] memory, address[] memory) {\r\n        // return idToOwner.length;\r\n        uint256[] memory resultTokenIDs = new uint256[](tokenIDs.length);\r\n        address[] memory resultOwners = new address[](tokenIDs.length);\r\n        for(uint256 i = 0; i < tokenIDs.length; i += 1){\r\n            resultTokenIDs[i] = tokenIDs[i];\r\n            resultOwners[i] = idToOwner[tokenIDs[i]];\r\n        }\r\n        return (resultTokenIDs, resultOwners);\r\n    }\r\n    \r\n    // ERC721Enumerable functions\r\n    \r\n    function totalSupply() external view returns(uint256) {\r\n        return tokenIDs.length;\r\n    }\r\n    \r\n    function tokenOfOwnerByIndex(uint256 _index) external view returns(address _owner) {\r\n        require(_index < tokenIDs.length, \"ERR_BITT_INDEX_OUT_OF_BOUNDS\");\r\n        _owner = idToOwner[tokenIDs[_index]];\r\n    }\r\n    \r\n    function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n        require(_index < tokenIDs.length, \"ERR_BITT_INDEX_OUT_OF_BOUNDS\");\r\n        return tokenIDs[_index];\r\n    }\r\n    \r\n    // ERC721Metadata functions\r\n    \r\n    function tokenURI(uint256 _tokenId) validNFToken(_tokenId) public view returns (string memory) {\r\n        return concatStrings(baseUri, uint256ToString(_tokenId));\r\n    }\r\n\r\n    function tokenProperty(uint256 _tokenId) validNFToken(_tokenId) public view returns (uint256) {\r\n        // no token data is stored on chain\r\n        return 0;\r\n    }\r\n    \r\n    // ERC721 functions\r\n    \r\n    function balanceOf(address _owner) external view returns(uint256) {\r\n        require(_owner != NULL_ADDRESS, \"ERR_ERC721_NULL_ADDRESS\");\r\n        return ownerToNFTokenCount[_owner];\r\n    }\r\n    \r\n    function ownerOf(uint256 _tokenId) external view returns(address _owner){\r\n        _owner = idToOwner[_tokenId];\r\n        require(_owner != NULL_ADDRESS, \"ERR_ERC721_NONEXISTANT\");\r\n    }\r\n    \r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external {\r\n        _safeTransferFrom(_from, _to, _tokenId, _data);\r\n    }\r\n    \r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n    \r\n    function supportsInterface(bytes4 _interfaceID) external view returns(bool) {\r\n        return supportedInterfaces[_interfaceID];\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from, \"ERR_ERC721_OWNER_MISMATCH\");\r\n        require(_to != NULL_ADDRESS, \"ERR_ERC721_NULL_ADDRESS\");\r\n        _transfer(_to, _tokenId);\r\n    }\r\n    \r\n    function approve(address _approved, uint256 _tokenId) external canOperate(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(_approved != tokenOwner, \"ERR_ERC721_SELF_APPROVE\");\r\n        \r\n        idToApprovals[_tokenId] = _approved;\r\n        emit Approval(tokenOwner, _approved, _tokenId);\r\n    }\r\n    \r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        require(_operator != NULL_ADDRESS);\r\n        ownerToOperators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n    \r\n    function getApproved(uint256 _tokenId) public view validNFToken(_tokenId) returns (address){\r\n        return idToApprovals[_tokenId];\r\n    }\r\n    \r\n    function isApprovedForAll(address _owner, address _operator) external view returns(bool) {\r\n        require(_owner != NULL_ADDRESS);\r\n        require(_operator != NULL_ADDRESS);\r\n        return ownerToOperators[_owner][_operator];\r\n    }\r\n    \r\n    // Internal/private functions\r\n\r\n    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) internal canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from, \"ERR_ERC721_OWNER_MISMATCH\");\r\n        require(_to != NULL_ADDRESS, \"ERR_ERC721_NULL_ADDRESS\");\r\n        \r\n        _transfer(_to, _tokenId);\r\n        \r\n        if (isContract(_to)) {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n            require(retval == MAGIC_ON_ERC721_RECEIVED);\r\n        }\r\n    }\r\n    \r\n    function _mint(address _to, uint256 _tokenId) private {\r\n        require(_to != NULL_ADDRESS, \"ERR_ERC721_NULL_ADDRESS\");\r\n        require(idToOwner[_tokenId] == NULL_ADDRESS, \"ERR_BITT_ALREADY_MINTED\");\r\n        require(tokenIDs.length < maxTotalSupply, \"ERR_BITT_MAX_SUPPLY\");\r\n        require(_tokenId >= 1  && _tokenId <= maxTotalSupply, \"ERR_BITT_TOKEN_ID_OUT_OF_RANGE\");\r\n        tokenIDs.push(_tokenId);\r\n        idToOwner[_tokenId] = _to;\r\n        unchecked {\r\n            // No individual user's balance will ever exceed 2 ** 256 - 1\r\n            ownerToNFTokenCount[_to] += 1;\r\n        }\r\n        \r\n        originalTokenOwner[_tokenId] = _to;\r\n        emit Transfer(NULL_ADDRESS, _to, _tokenId);\r\n    }\r\n\r\n    function _transfer(address _to, uint256 _tokenId) private {\r\n        address from = idToOwner[_tokenId];\r\n        clearApproval(_tokenId);\r\n        unchecked {\r\n            // These will never underflow or overlow\r\n            ownerToNFTokenCount[from] -= 1;\r\n            ownerToNFTokenCount[_to] += 1;\r\n        }\r\n        idToOwner[_tokenId] = _to;\r\n        emit Transfer(from, _to, _tokenId);\r\n    }\r\n    \r\n    function clearApproval(uint256 _tokenId) private {\r\n        if(idToApprovals[_tokenId] != NULL_ADDRESS){\r\n            delete idToApprovals[_tokenId];\r\n        }\r\n    }\r\n    \r\n    // If bytecode exists at _addr then the _addr is a contract.\r\n    function isContract(address _addr) internal view returns(bool) {\r\n        uint length;\r\n        assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        return (length > 0);\r\n    }\r\n    \r\n    // Functions used for generating the URI\r\n    function amountOfZeros(uint256 num, uint256 base) internal pure returns(uint256) {\r\n        uint256 result = 0;\r\n        num /= base;\r\n        while(num > 0) {\r\n            num /= base;\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    function uint256ToString(uint256 num) internal pure returns(string memory) {\r\n        if (num == 0){\r\n            return \"0\";\r\n        }\r\n        uint256 numLen = amountOfZeros(num, 10) + 1;\r\n        bytes memory result = new bytes(numLen);\r\n        while(num != 0) {\r\n            numLen -= 1;\r\n            result[numLen] = bytes1(uint8((num - (num / 10 * 10)) + 48));\r\n            num /= 10;\r\n        }\r\n        return string(result);\r\n    }\r\n    \r\n    function concatStrings(string memory str1, string memory str2) internal pure returns (string memory) {\r\n        uint256 str1Len = bytes(str1).length;\r\n        uint256 str2Len = bytes(str2).length;\r\n        uint256 resultLen = str1Len + str1Len;\r\n        bytes memory result = new bytes(resultLen);\r\n        uint256 i;\r\n        \r\n        for(i = 0; i < str1Len; i += 1) {\r\n            result[i] = bytes(str1)[i];\r\n        }\r\n        for(i = 0; i < str2Len; i += 1) {\r\n            result[i + str1Len] = bytes(str2)[i];\r\n        }\r\n        return string(result);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"addToPreLaunch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allNFTsMintedSoFar\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"originalTokenOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"payToMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"preLaunchWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setBaseUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"}],\"name\":\"setMaxTotalSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cost\",\"type\":\"uint256\"}],\"name\":\"setMintCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"o\",\"type\":\"address\"}],\"name\":\"setNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenProperty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BitTower", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000062801850", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://608333576524a0394492184d86a520360c8b3eeacf34c71bf5ecd9fe21af0280"}]}