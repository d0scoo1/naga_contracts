{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/StringBuffer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Holds a string that can expand dynamically.\\n */\\nstruct StringBuffer {\\n    string[] buffer;\\n    uint numberOfStrings;\\n    uint totalStringLength;\\n}\\n\\nlibrary StringBufferLibrary {\\n    /**\\n     * @dev Copies 32 bytes of `src` starting at `srcIndex` into `dst` starting at `dstIndex`.\\n     */\\n    function memcpy32(string memory src, uint srcIndex, bytes memory dst, uint dstIndex) internal pure {\\n        assembly {\\n            mstore(add(add(dst, 32), dstIndex), mload(add(add(src, 32), srcIndex)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Copies 1 bytes of `src` at `srcIndex` into `dst` at `dstIndex`.\\n     *      This uses the same amount of gas as `memcpy32`, so prefer `memcpy32` if at all possible.\\n     */\\n    function memcpy1(string memory src, uint srcIndex, bytes memory dst, uint dstIndex) internal pure {\\n        assembly {\\n            mstore8(add(add(dst, 32), dstIndex), shr(248, mload(add(add(src, 32), srcIndex))))\\n        }\\n    }\\n\\n    /**\\n     * @dev Copies a string into `dst` starting at `dstIndex` with a maximum length of `dstLen`.\\n     *      This function will not write beyond `dstLen`. However, if `dstLen` is not reached, it may write zeros beyond the length of the string.\\n     */\\n    function copyString(string memory src, bytes memory dst, uint dstIndex, uint dstLen) internal pure returns (uint) {\\n        uint srcIndex;\\n        uint srcLen = bytes(src).length;\\n\\n        for (; srcLen > 31 && srcIndex < srcLen && srcIndex < dstLen - 31; srcIndex += 32) {\\n            memcpy32(src, srcIndex, dst, dstIndex + srcIndex);\\n        }\\n        for (; srcIndex < srcLen && srcIndex < dstLen; ++srcIndex) {\\n            memcpy1(src, srcIndex, dst, dstIndex + srcIndex);\\n        }\\n\\n        return dstIndex + srcLen;\\n    }\\n\\n    /**\\n     * @dev Adds `str` to the end of the internal buffer.\\n     */\\n    function pushToStringBuffer(StringBuffer memory self, string memory str) internal pure returns (StringBuffer memory) {\\n        if (self.buffer.length == self.numberOfStrings) {\\n            string[] memory newBuffer = new string[](self.buffer.length * 2);\\n            for (uint i = 0; i < self.buffer.length; ++i) {\\n                newBuffer[i] = self.buffer[i];\\n            }\\n            self.buffer = newBuffer;\\n        }\\n\\n        self.buffer[self.numberOfStrings] = str;\\n        self.numberOfStrings++;\\n        self.totalStringLength += bytes(str).length;\\n\\n        return self;\\n    }\\n\\n    /**\\n     * @dev Concatenates `str` to the end of the last string in the internal buffer.\\n     */\\n    function concatToLastString(StringBuffer memory self, string memory str) internal pure {\\n        if (self.numberOfStrings == 0) {\\n            self.numberOfStrings++;\\n        }\\n        uint idx = self.numberOfStrings - 1;\\n        self.buffer[idx] = string(abi.encodePacked(self.buffer[idx], str));\\n\\n        self.totalStringLength += bytes(str).length;\\n    }\\n\\n    /**\\n     * @notice Creates a new empty StringBuffer\\n     * @dev The initial capacity is 16 strings\\n     */\\n    function empty() external pure returns (StringBuffer memory) {\\n        return StringBuffer(new string[](16), 0, 0);\\n    }\\n\\n    /**\\n     * @notice Converts the contents of the StringBuffer into a string.\\n     * @dev This runs in O(n) time.\\n     */\\n    function get(StringBuffer memory self) internal pure returns (string memory) {\\n        bytes memory output = new bytes(self.totalStringLength);\\n\\n        uint ptr = 0;\\n        for (uint i = 0; i < self.numberOfStrings; ++i) {\\n            ptr = copyString(self.buffer[i], output, ptr, self.totalStringLength);\\n        }\\n\\n        return string(output);\\n    }\\n\\n    /**\\n     * @notice Appends a string to the end of the StringBuffer\\n     * @dev Internally the StringBuffer keeps a `string[]` that doubles in size when extra capacity is needed.\\n     */\\n    function append(StringBuffer memory self, string memory str) internal pure {\\n        uint idx = self.numberOfStrings == 0 ? 0 : self.numberOfStrings - 1;\\n        if (bytes(self.buffer[idx]).length + bytes(str).length <= 1024) {\\n            concatToLastString(self, str);\\n        } else {\\n            pushToStringBuffer(self, str);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"empty\",\"outputs\":[{\"components\":[{\"internalType\":\"string[]\",\"name\":\"buffer\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"numberOfStrings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStringLength\",\"type\":\"uint256\"}],\"internalType\":\"struct StringBuffer\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "StringBufferLibrary", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}