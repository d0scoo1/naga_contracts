{"status": "1", "message": "OK", "result": [{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2022-02-05\r\n*/\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n// safe\r\n\r\ninterface IERC721 is IERC165 {\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n// safe\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n// safe\r\n\r\ninterface IERC721Metadata is IERC721 {\r\n    \r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n// safe\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n// safe\r\n\r\ncontract Initializable {\r\n    bool inited = false;\r\n\r\n    modifier initializer() {\r\n        require(!inited, \"already inited\");\r\n        _;\r\n        inited = true;\r\n    }\r\n}\r\n// safe oSEA\r\n\r\ncontract EIP712Base is Initializable {\r\n    struct EIP712Domain {\r\n        string name;\r\n        string version;\r\n        address verifyingContract;\r\n        bytes32 salt;\r\n    }\r\n\r\n    string constant public ERC712_VERSION = \"1\";\r\n\r\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\r\n        bytes(\r\n            \"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\"\r\n        )\r\n    );\r\n    bytes32 internal domainSeperator;\r\n\r\n    function _initializeEIP712(\r\n        string memory name\r\n    )\r\n        internal\r\n        initializer\r\n    {\r\n        _setDomainSeperator(name);\r\n    }\r\n\r\n    function _setDomainSeperator(string memory name) internal {\r\n        domainSeperator = keccak256(\r\n            abi.encode(\r\n                EIP712_DOMAIN_TYPEHASH,\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(ERC712_VERSION)),\r\n                address(this),\r\n                bytes32(getChainId())\r\n            )\r\n        );\r\n    }\r\n\r\n    function getDomainSeperator() public view returns (bytes32) {\r\n        return domainSeperator;\r\n    }\r\n\r\n    function getChainId() public view returns (uint256) {\r\n        uint256 id;\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n        return id;\r\n    }\r\n\r\n    function toTypedMessageHash(bytes32 messageHash)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(), messageHash)\r\n            );\r\n    }\r\n}\r\n// safe oSEA\r\n\r\ncontract NativeMetaTransaction is EIP712Base {\r\n    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(\r\n        bytes(\r\n            \"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\"\r\n        )\r\n    );\r\n    event MetaTransactionExecuted(\r\n        address userAddress,\r\n        address payable relayerAddress,\r\n        bytes functionSignature\r\n    );\r\n    mapping(address => uint256) nonces;\r\n\r\n    struct MetaTransaction {\r\n        uint256 nonce;\r\n        address from;\r\n        bytes functionSignature;\r\n    }\r\n\r\n    function executeMetaTransaction(\r\n        address userAddress,\r\n        bytes memory functionSignature,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        uint8 sigV\r\n    ) public payable returns (bytes memory) {\r\n        MetaTransaction memory metaTx = MetaTransaction({\r\n            nonce: nonces[userAddress],\r\n            from: userAddress,\r\n            functionSignature: functionSignature\r\n        });\r\n\r\n        require(\r\n            verify(userAddress, metaTx, sigR, sigS, sigV),\r\n            \"Signer and signature do not match\"\r\n        );\r\n\r\n        nonces[userAddress]++;\r\n\r\n        emit MetaTransactionExecuted(\r\n            userAddress,\r\n            payable(msg.sender),\r\n            functionSignature\r\n        );\r\n\r\n        (bool success, bytes memory returnData) = address(this).call(\r\n            abi.encodePacked(functionSignature, userAddress)\r\n        );\r\n        require(success, \"Function call not successful\");\r\n\r\n        return returnData;\r\n    }\r\n\r\n    function hashMetaTransaction(MetaTransaction memory metaTx)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    META_TRANSACTION_TYPEHASH,\r\n                    metaTx.nonce,\r\n                    metaTx.from,\r\n                    keccak256(metaTx.functionSignature)\r\n                )\r\n            );\r\n    }\r\n\r\n    function getNonce(address user) public view returns (uint256 nonce) {\r\n        nonce = nonces[user];\r\n    }\r\n\r\n    function verify(\r\n        address signer,\r\n        MetaTransaction memory metaTx,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        uint8 sigV\r\n    ) internal view returns (bool) {\r\n        require(signer != address(0), \"NativeMetaTransaction: INVALID_SIGNER\");\r\n        return\r\n            signer ==\r\n            ecrecover(\r\n                toTypedMessageHash(hashMetaTransaction(metaTx)),\r\n                sigV,\r\n                sigR,\r\n                sigS\r\n            );\r\n    }\r\n}\r\n// safe oSEA\r\n\r\nabstract contract Ownable{\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n// safe\r\n\r\ncontract OwnableDelegateProxy {}\r\ncontract ProxyRegistry {\r\n    mapping(address => OwnableDelegateProxy) public proxies;\r\n}\r\n// safe oSEA\r\n\r\ncontract PATRICIA is IERC721, IERC721Metadata, ERC165, NativeMetaTransaction{\r\n    address proxyRegistryAddress;\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    string private _baseURI;\r\n    bool private isJson = false;\r\n\r\n    struct Holder{\r\n        uint128 _balances;\r\n        uint128 _points; \r\n    }\r\n    struct Token{\r\n        uint32 key;\r\n        uint64 _lastseen;\r\n        address _owners;\r\n    }\r\n\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n    mapping(address => Holder) private holder;\r\n    mapping(uint256 => Token) private token;\r\n\r\n    constructor(string memory name_, string memory symbol_, address _proxyRegistryAddress) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        proxyRegistryAddress = _proxyRegistryAddress;\r\n        _initializeEIP712(_name);\r\n    }\r\n\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n        return holder[owner]._balances;\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = token[tokenId]._owners;\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n        return owner;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n        if(!isJson){\r\n            return bytes(_baseURI).length > 0 ? string(abi.encodePacked(_baseURI, toString(tokenId))) : \"\";\r\n        }\r\n        else{\r\n            return bytes(_baseURI).length > 0 ? string(abi.encodePacked(_baseURI, toString(tokenId), \".json\")) : \"\";\r\n        }\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = PATRICIA.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _setApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        override\r\n        public\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        // Whitelist OpenSea proxy contract for easy trading.\r\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\r\n        if (address(proxyRegistry.proxies(owner)) == operator) {\r\n            return true;\r\n        }\r\n\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        require(\r\n            _isApprovedOrOwner(msg.sender, tokenId), \r\n            \"ERC721: transfer caller is not owner nor approved\"\r\n        );\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n\r\n    function sweepPoint(uint256 _tokenId) public virtual {\r\n        address owner = PATRICIA.ownerOf(_tokenId);\r\n        unchecked{\r\n            uint128 points = (uint64(block.timestamp) - token[_tokenId]._lastseen) / 10;\r\n            holder[owner]._points += points;\r\n            token[_tokenId]._lastseen = uint64(block.timestamp);\r\n        } \r\n    }\r\n\r\n    function _switchJ() internal virtual {\r\n        isJson = !isJson;\r\n    }\r\n\r\n    function _setbaseURI(string memory xyz) internal virtual {\r\n        _baseURI = xyz;\r\n    }\r\n\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return token[tokenId]._owners != address(0);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = PATRICIA.ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n        holder[to]._balances++;\r\n        unchecked{\r\n            \r\n            token[tokenId]._owners = to;\r\n            token[tokenId]._lastseen = uint64(block.timestamp);\r\n        }\r\n        \r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n\r\n        _afterTokenTransfer(address(0), to, tokenId);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(PATRICIA.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        sweepPoint(tokenId);\r\n\r\n        holder[from]._balances--;\r\n        holder[to]._balances++;\r\n        token[tokenId]._owners = to;\r\n\r\n\r\n        emit Transfer(from, to, tokenId);\r\n\r\n        _afterTokenTransfer(from, to, tokenId);\r\n    }\r\n\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(PATRICIA.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) internal virtual {\r\n        require(owner != operator, \"ERC721: approve to caller\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (isContract(to)) {\r\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n\r\n\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function getToken(uint256 _id) public view returns(Token memory){\r\n        return(token[_id]);\r\n    }\r\n    function getHolder(address account) public view returns (Holder memory) {\r\n        return(holder[account]);\r\n    }\r\n    function _keyI(uint256 _id) internal {\r\n        token[_id].key++;\r\n    }\r\n    function _sweep(address _user) internal {\r\n        holder[_user]._points = 0;\r\n    }\r\n    function _credit(address _user, uint128 _point) internal {\r\n        holder[_user]._points += _point;\r\n    }\r\n}\r\n// safe oSEA-native\r\n\r\ncontract NFT is PATRICIA, Ownable {\r\n    \r\n    uint256 _nextTokenId;\r\n    uint256 constant public _MAX_TOKEN = 9999;\r\n\r\n    constructor() PATRICIA(\"KONGDO CLUB OFFICIAL\", \"KDC\", 0xa5409ec958C83C3f309868babACA7c86DCB077c1)\r\n    {\r\n        _setbaseURI(\"https://api.kongdoclub.com/v1/token/\");\r\n        _mintTo(msg.sender);\r\n    }\r\n\r\n    function _mintTo(address _to) internal {\r\n        //uint256 currentTokenId = _nextTokenId.current();\r\n        //_nextTokenId.increment();\r\n        require(_nextTokenId <= _MAX_TOKEN, \"NO MORE\");\r\n        _mint(_to, _nextTokenId);\r\n        _nextTokenId++;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return(_nextTokenId);\r\n    }\r\n\r\n}\r\n// safe\r\n\r\ncontract comptroller is NFT {\r\n\r\n    bool public isOpen = false;\r\n    bool public isU    = false;\r\n    bool public isH = true;\r\n\r\n    address public _3D_ADDRESS;\r\n    address public _COIN_ADDRESS;\r\n\r\n    uint256 public constant _PRICE = 77   *1e15;\r\n    uint256 public constant _WHITE_PRICE = 55  *1e15;\r\n\r\n    uint256 private _threshold = 20 * 1e18;\r\n    address private immutable contributor;\r\n    address private constant contributor2 = 0x0D08CBEF5671b9CB685FC34cd0562C012f8eBC57;\r\n    address private constant Asigner = 0x5050efFf71c7DbEb50173bFbCdF87720905B8e05;\r\n\r\n    event unboxEvent(uint256 id, address unboxer, uint256 luckyNumber, string wish);\r\n\r\n    constructor(){\r\n        contributor = msg.sender;\r\n    }\r\n\r\n    function withdraw() public {\r\n        uint256 _local_threshold = _threshold;\r\n\r\n        if(_local_threshold > 0){\r\n            uint256 balance = address(this).balance;\r\n                if(balance >= _local_threshold) {\r\n                    (bool success0,) = contributor.call{value: _local_threshold}(\"\");\r\n                    require(success0, \"Transfer failed\");\r\n                    _threshold = 0;\r\n                }\r\n                else{\r\n                    (bool success2,) = contributor.call{value: balance}(\"\");\r\n                    require(success2, \"Transfer failed\");\r\n                    _threshold -= balance;\r\n                }\r\n        }\r\n\r\n        uint256 ubalance = address(this).balance;\r\n        uint _amt1 = (ubalance * 750) / 1000;\r\n        uint _amt2 = ubalance - _amt1;\r\n\r\n        (bool success,) = contributor.call{value: _amt1}(\"\");\r\n        require(success, \"Transfer failed\");\r\n        (bool success1,) = contributor2.call{value: _amt2}(\"\");\r\n        require(success1, \"Transfer failed\");\r\n    }\r\n    \r\n    function regular(uint _amt) external payable {\r\n        require(isOpen, \"Closed\");\r\n        require(msg.value >= _PRICE*_amt, \"Insufficient\");\r\n        for(uint i = 0; i < _amt; i++){\r\n            _mintTo(msg.sender);\r\n        }\r\n    }\r\n\r\n    function whitelister(uint8 _v, bytes32 _r, bytes32 _s) external payable {\r\n        Holder memory wl = getHolder(msg.sender);\r\n        require(wl._points == 0 && isWhite(_v,_r,_s), \"Not whitelist\");\r\n        require(msg.value >= _WHITE_PRICE, \"insufficient\");\r\n        _mintTo(msg.sender);\r\n        _credit(msg.sender, 10000);\r\n    }\r\n\r\n    function unbox(uint256 _tokenId, string memory _wish) external {\r\n        Token memory tk = getToken(_tokenId);\r\n        require(isU, \"Cannot unbox now\");\r\n        require(tk._owners == msg.sender, \"Unauthorized\");\r\n        require(tk.key == 0, \"Already unboxed\");\r\n        _keyI(_tokenId);\r\n        emit unboxEvent(_tokenId,msg.sender, uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), msg.sender, _tokenId, _wish))) % 100000000000000000000000,_wish);\r\n    }\r\n\r\n    function redeem() external {\r\n        Holder memory hd = getHolder(msg.sender);\r\n        require( _COIN_ADDRESS != address(0), \"Closed\");\r\n        uint256 currentP = hd._points;\r\n        _sweep(msg.sender);\r\n        ICOIN(_COIN_ADDRESS).exchange(currentP, msg.sender);\r\n    }\r\n\r\n    function get3D(uint256 _tokenId) external {\r\n        Token memory tk = getToken(_tokenId);\r\n        require( _3D_ADDRESS != address(0), \"Closed\");\r\n        require(tk._owners == msg.sender, \"Unauthorize Access\");\r\n        require(tk.key == 1, \"Unopen or already used\");\r\n        _keyI(_tokenId);\r\n        I3D(_3D_ADDRESS).exchange3(_tokenId, msg.sender);\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n        if(isH){\r\n            return \"https://api.kondoclub.com/hidden.json\";\r\n        }\r\n        return PATRICIA.tokenURI(tokenId);\r\n    }\r\n\r\n    function walletOfOwner(address _owner)\r\n        public\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256 ownerTokenCount = balanceOf(_owner);\r\n        uint256[] memory ownedTokenIds = new uint256[](ownerTokenCount);\r\n        uint256 currentTokenId = 0;\r\n        uint256 ownedTokenIndex = 0;\r\n        uint256 maxSupply = totalSupply();\r\n\r\n        while (ownedTokenIndex < ownerTokenCount && currentTokenId <= maxSupply) {\r\n            address currentTokenOwner = ownerOf(currentTokenId);\r\n            if (currentTokenOwner == _owner) {\r\n                ownedTokenIds[ownedTokenIndex] = currentTokenId;\r\n\r\n                ownedTokenIndex++;\r\n            }\r\n            currentTokenId++;\r\n        }\r\n        return ownedTokenIds;\r\n    } // Hashlips/hashlips_nft_contract/contract/SimpleNftLowerGas.sol >> Line 66\r\n\r\n    function isWhite(uint8 _v, bytes32 _r, bytes32 _s) internal view returns (bool)\r\n    {\r\n        return ecrecover(ethSigned(), _v, _r, _s) == Asigner;\r\n    }\r\n    function ethSigned() internal view returns(bytes32){\r\n        return(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19Ethereum Signed Message:\\n32\", \r\n                        keccak256(\r\n                            abi.encodePacked(msg.sender)\r\n                        )\r\n                    )\r\n                )\r\n            );\r\n    }\r\n\r\n    function aUnbox(uint256 _tokenId, string memory _wish) external onlyOwner {\r\n        Token memory tk = getToken(_tokenId);\r\n        require(tk.key == 0, \"Already unboxed\");\r\n        _keyI(_tokenId);\r\n        emit unboxEvent(_tokenId,msg.sender, uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), msg.sender, _tokenId, _wish))) % 100000000000000000000000,_wish);\r\n    }\r\n    function aCredit(address _a, uint _p) external onlyOwner {\r\n        _credit(_a, uint128(_p));\r\n    }\r\n    function setCoin(address _xyz) external onlyOwner{\r\n        _COIN_ADDRESS = _xyz;\r\n    }\r\n    function set3D(address _xyz) external onlyOwner{\r\n        _3D_ADDRESS = _xyz;\r\n    }\r\n    function airdrop(address[] memory _target) external onlyOwner {\r\n        for(uint i = 0; i < _target.length; i++){\r\n            _mintTo(_target[i]);\r\n        }\r\n    }\r\n    function xCUR(address _curate, uint _amt) external onlyOwner {\r\n        for(uint i = 0; i < _amt; i++){\r\n            _mintTo(_curate);\r\n        }\r\n    }\r\n    function switchO() external onlyOwner {\r\n        isOpen = !isOpen;\r\n    }\r\n    function switchU() external onlyOwner {\r\n        isU = !isU;\r\n    }\r\n    function switchH() external onlyOwner {\r\n        isH = !isH;\r\n    }\r\n    function setbaseURI(string memory abc) external onlyOwner {\r\n        _setbaseURI(abc);\r\n    }\r\n}\r\n\r\ninterface ICOIN {\r\n    function exchange(uint256 _points, address _target) external;\r\n}\r\ninterface I3D {\r\n    function exchange3(uint256 _tokenId, address _target) external;\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"unboxer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"luckyNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"wish\",\"type\":\"string\"}],\"name\":\"unboxEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ERC712_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_3D_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_COIN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MAX_TOKEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_WHITE_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_p\",\"type\":\"uint256\"}],\"name\":\"aCredit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_wish\",\"type\":\"string\"}],\"name\":\"aUnbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_target\",\"type\":\"address[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"sigV\",\"type\":\"uint8\"}],\"name\":\"executeMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"get3D\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDomainSeperator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getHolder\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"_balances\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_points\",\"type\":\"uint128\"}],\"internalType\":\"struct PATRICIA.Holder\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getToken\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"key\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"_lastseen\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_owners\",\"type\":\"address\"}],\"internalType\":\"struct PATRICIA.Token\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isU\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"}],\"name\":\"regular\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_xyz\",\"type\":\"address\"}],\"name\":\"set3D\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_xyz\",\"type\":\"address\"}],\"name\":\"setCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"abc\",\"type\":\"string\"}],\"name\":\"setbaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"sweepPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"switchH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"switchO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"switchU\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_wish\",\"type\":\"string\"}],\"name\":\"unbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"walletOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"whitelister\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_curate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"}],\"name\":\"xCUR\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "comptroller", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d2cc575e7dee4c309a68152f523d1bb45ab5e875a89a9d1cfec36a2e9435a5b2"}]}