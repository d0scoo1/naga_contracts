{"status": "1", "message": "OK", "result": [{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2022-03-30\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2022-03-28\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2022-03-26\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT \r\npragma solidity 0.8.9;\r\n\r\n//library\r\nlibrary SafeMath {\r\n   function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n       uint256 c = a + b;\r\n       require(c >= a, \"SafeMath: addition overflow\");\r\n \r\n       return c;\r\n   }\r\n \r\n   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n       return sub(a, b, \"SafeMath: subtraction overflow\");\r\n   }\r\n \r\n   function sub(\r\n       uint256 a,\r\n       uint256 b,\r\n       string memory errorMessage\r\n   ) internal pure returns (uint256) {\r\n       require(b <= a, errorMessage);\r\n       uint256 c = a - b;\r\n \r\n       return c;\r\n   }\r\n \r\n   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n       if (a == 0) {\r\n           return 0;\r\n       }\r\n \r\n       uint256 c = a * b;\r\n       require(c / a == b, \"SafeMath: multiplication overflow\");\r\n \r\n       return c;\r\n   }\r\n \r\n   function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n       return div(a, b, \"SafeMath: division by zero\");\r\n   }\r\n \r\n   function div(\r\n       uint256 a,\r\n       uint256 b,\r\n       string memory errorMessage\r\n   ) internal pure returns (uint256) {\r\n       require(b > 0, errorMessage);\r\n       uint256 c = a / b;\r\n       return c;\r\n   }\r\n \r\n   function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n       return mod(a, b, \"SafeMath: modulo by zero\");\r\n   }\r\n \r\n   function mod(\r\n       uint256 a,\r\n       uint256 b,\r\n       string memory errorMessage\r\n   ) internal pure returns (uint256) {\r\n       require(b != 0, errorMessage);\r\n       return a % b;\r\n   }\r\n}\r\n  \r\n\r\n   interface IBEP20 {\r\n        function totalSupply() external view returns (uint256);\r\n        \r\n        function decimals() external view returns (uint8);\r\n        \r\n        function symbol() external view returns (string memory);\r\n        \r\n        function name() external view returns (string memory);\r\n        \r\n        function balanceOf(address account) external view returns (uint256);\r\n        \r\n        function transfer(address recipient, uint256 amount) external returns (bool);\r\n        \r\n        function allowance(address _owner, address spender) external view returns (uint256);\r\n        \r\n        function approve(address spender, uint256 amount) external returns (bool);\r\n        \r\n        function transferFrom(address sender,address recipient,uint256 amount) external returns (bool);\r\n        \r\n        event Transfer(address indexed from, address indexed to, uint256 value);\r\n        event Approval(address indexed owner,address indexed spender,uint256 value);\r\n    }\r\n \r\n    interface ADAMSTAKE{\r\n        function stakedetails(address, uint256) external view returns (uint256,uint256,uint256,uint256,bool); \r\n        function users(address)external returns(uint256,uint256,uint256);\r\n    }\r\n \r\n   contract StakeContract {\r\n        using SafeMath for uint256;\r\n        \r\n        //Variables\r\n        IBEP20 public wolveToken;\r\n        IBEP20 public amdToken;\r\n        ADAMSTAKE public stakeInstance;\r\n \r\n        address payable public owner;\r\n        bool public migrationCheck; \r\n        uint256 public totalUniqueStakers;\r\n        uint256 public totalStakedTokens;\r\n        uint256 public totalStaked;\r\n        uint256 public minStake;\r\n        uint256 public constant percentDivider = 100000;\r\n        \r\n        uint256 public newPercentage;\r\n        uint256 public endingTime;\r\n        uint256 public stakeTimeForEndind;\r\n\r\n        //arrays\r\n        uint256[4] public percentages = [0, 0, 0, 0];\r\n        uint256[4] public APY = [8000,9000,10000,11000];\r\n        uint256[4] public durations = [15 days, 30 days, 60 days, 90 days];\r\n\r\n \r\n        //structures\r\n        struct Stake {\r\n            uint256 stakeTime;\r\n            uint256 withdrawTime;\r\n            uint256 amount;\r\n            uint256 bonus;\r\n            uint256 beforeExtendBonus;\r\n            uint256 afterTimeBonus;\r\n            uint256 plan;\r\n            bool withdrawan;\r\n            bool migrated;\r\n            uint256 transactions;\r\n            uint256 rewardToken;\r\n            uint256 withdrawWith;\r\n        }\r\n        \r\n        struct User {\r\n            uint256 totalstakeduser;\r\n            uint256 stakecount;\r\n            uint256 claimedstakeTokens;\r\n            mapping(uint256 => Stake) stakerecord;\r\n        }\r\n        \r\n        //mappings\r\n        mapping(address => uint256) deductedAmount;\r\n        mapping(address => User) public users;\r\n        mapping(address => bool) public uniqueStaker;\r\n        uint256 public totalWolveStakeToken;\r\n        uint256 public totalAmdStakeToken;\r\n        uint256 public totalWolveRewardToken;\r\n        uint256 public totalAmdRewardToken;\r\n        \r\n        \r\n        //modifiers\r\n        modifier onlyOwner() {\r\n            require(msg.sender == owner, \"Ownable: Not an owner\");\r\n            _;\r\n        }\r\n        \r\n        //events\r\n        event Staked(address indexed _user, uint256 indexed _amount, uint256 indexed _Time);\r\n        event Withdrawn(address indexed _user, uint256 indexed _amount, uint256 indexed _Time);\r\n        event ExtenderStake(address indexed _user, uint256 indexed _amount, uint256 indexed _Time);\r\n        event UNIQUESTAKERS(address indexed _user);\r\n \r\n   // constructor\r\n   constructor(address wolve, address amd,address amdStaking) {\r\n       owner = payable(msg.sender);\r\n       wolveToken = IBEP20(wolve);\r\n       amdToken = IBEP20(amd);\r\n       stakeInstance=ADAMSTAKE(amdStaking);\r\n       minStake = 45522400000000;\r\n\r\n        for(uint256 i ; i < percentages.length;i++){\r\n            percentages[i] = APYtoPercentage(APY[i], durations[i].div(1 days));\r\n        }\r\n   }\r\n\r\n\r\n   // functions\r\n   // StakeWithWolve\r\n\r\n  uint256 public stakewolvTime;\r\n    function stakeWithWolve(uint256 amount, uint256 plan, uint rewardToken) public {\r\n       require(plan >= 0 && plan < 4, \"put valid plan details\");\r\n       require(amount >= minStake,\"cant deposit need to stake more than minimum amount\");\r\n     \r\n       if (!uniqueStaker[msg.sender]) {\r\n           uniqueStaker[msg.sender] = true;\r\n           totalUniqueStakers++;\r\n           emit UNIQUESTAKERS(msg.sender);\r\n       }\r\n        \r\n       User storage user = users[msg.sender];\r\n       wolveToken.transferFrom(msg.sender, owner, amount);\r\n \r\n\r\n       user.totalstakeduser += amount;\r\n       user.stakerecord[user.stakecount].plan = plan;\r\n       user.stakerecord[user.stakecount].stakeTime = block.timestamp;\r\n       stakewolvTime = user.stakerecord[user.stakecount].stakeTime;\r\n       user.stakerecord[user.stakecount].amount = amount;\r\n       user.stakerecord[user.stakecount].withdrawTime = block.timestamp.add(durations[plan]);\r\n       user.stakerecord[user.stakecount].bonus = amount.mul(percentages[plan]).div(percentDivider);\r\n       user.stakerecord[user.stakecount].transactions = 1;\r\n       user.stakerecord[user.stakecount].withdrawWith = 1;\r\n       user.stakerecord[user.stakecount].rewardToken = rewardToken;\r\n      \r\n       user.stakecount++;\r\n       totalStakedTokens += amount;\r\n       totalWolveStakeToken+=amount;\r\n       emit Staked(msg.sender, amount, block.timestamp);\r\n \r\n       uint256 value1 = 10; // percentage that how much amount that was deducted in Wolvrine token\r\n       uint256 deductedAmount1 = amount.mul(value1).div(100); //amount that was deducted in Wolvrine token\r\n \r\n       deductedAmount[msg.sender] = deductedAmount1;\r\n   }\r\n  \r\n  //StakeWithAmd\r\n   function stakeWithAmd(uint256 amount, uint256 plan, uint rewardToken) public {\r\n       require(plan >= 0 && plan < 4, \"put valid plan details\");\r\n       require(amount >= minStake,\"cant deposit need to stake more than minimum amount\");\r\n      \r\n       if (!uniqueStaker[msg.sender]) {\r\n           uniqueStaker[msg.sender] = true;\r\n           totalUniqueStakers++;\r\n           emit UNIQUESTAKERS(msg.sender);\r\n       }\r\n      \r\n       User storage user = users[msg.sender];\r\n       amdToken.transferFrom(msg.sender, owner, amount);\r\n \r\n      \r\n       user.totalstakeduser += amount;\r\n       user.stakerecord[user.stakecount].plan = plan;\r\n       user.stakerecord[user.stakecount].stakeTime = block.timestamp;\r\n       user.stakerecord[user.stakecount].amount = amount;\r\n       user.stakerecord[user.stakecount].withdrawTime = block.timestamp.add(durations[plan]);\r\n       user.stakerecord[user.stakecount].bonus = amount.mul(percentages[plan]).div(percentDivider);\r\n       user.stakerecord[user.stakecount].transactions = 2;\r\n       user.stakerecord[user.stakecount].withdrawWith = 2;\r\n       user.stakerecord[user.stakecount].rewardToken = rewardToken;\r\n \r\n       user.stakecount++;\r\n       totalStakedTokens += amount;\r\n       totalAmdStakeToken+=amount;\r\n       emit Staked(msg.sender, amount, block.timestamp);\r\n   }\r\n \r\n   function withdrawInWolve(uint256 count) public {\r\n        \r\n        User storage user = users[msg.sender];\r\n \r\n        require(user.stakecount >= count, \"Invalid Stake index\");\r\n        require(user.stakerecord[count].migrated != true,\"You canot withdraw migrated stake from volve.\");\r\n        require(user.stakerecord[count].withdrawWith == 1,\"You canot withdraw Admantium staked token from  Wolverinu.\");\r\n        require(!user.stakerecord[count].withdrawan,\" withdraw completed \");\r\n        require(wolveToken.balanceOf(owner) >= user.stakerecord[count].amount,\"owner doesnt have enough balance\");\r\n        require(user.stakerecord[count].amount != 0,\"User stake amount must be greater then zero. \");\r\n        \r\n        checkEndingTime(msg.sender, count, user.stakerecord[count].plan); \r\n        require(endingTime > stakeTimeForEndind, \"You cannot withdraw amount before Time.\");\r\n        \r\n        checkAfterTimeBonus(msg.sender,count);\r\n\r\n        wolveToken.transferFrom(owner,msg.sender,user.stakerecord[count].amount);\r\n \r\n        if( user.stakerecord[count].rewardToken == 1 ){\r\n           wolveToken.transferFrom(owner,msg.sender,user.stakerecord[count].bonus);\r\n        }else{\r\n            require(amdToken.balanceOf(owner) >= user.stakerecord[count].bonus,\"owner doesnt have enough balance in admantium token\");\r\n            amdToken.transferFrom(owner,msg.sender,user.stakerecord[count].bonus);\r\n        }\r\n        if(user.stakerecord[count].transactions == 1){\r\n            require(wolveToken.balanceOf(owner) >= user.stakerecord[count].amount,\"owner doesnt have enough balance for 10%\");\r\n           wolveToken.transferFrom(owner,msg.sender,deductedAmount[msg.sender]);\r\n        }\r\n       \r\n        if(user.stakerecord[count].beforeExtendBonus != 0){\r\n            if(user.stakerecord[count].rewardToken == 1){\r\n                wolveToken.transferFrom(owner,msg.sender,user.stakerecord[count].beforeExtendBonus);\r\n            }else{\r\n                amdToken.transferFrom(owner,msg.sender,user.stakerecord[count].beforeExtendBonus);\r\n            }\r\n        }\r\n\r\n        if(user.stakerecord[count].afterTimeBonus != 0){\r\n            if(user.stakerecord[count].rewardToken == 1){\r\n                wolveToken.transferFrom(owner,msg.sender,user.stakerecord[count].afterTimeBonus);\r\n            }\r\n            else{\r\n                amdToken.transferFrom(owner,msg.sender,user.stakerecord[count].afterTimeBonus);\r\n            }\r\n        }\r\n        user.stakerecord[count].withdrawan = true;\r\n       totalWolveRewardToken+= user.stakerecord[count].bonus;\r\n        emit Withdrawn(msg.sender,user.stakerecord[count].amount,block.timestamp);\r\n    }\r\n\r\n    function withdrawInAmd(uint256 count) public {\r\n\r\n       User storage user = users[msg.sender];\r\n\r\n        require(user.stakecount >= count, \"Invalid Stake index\");\r\n        require(user.stakerecord[count].withdrawWith == 2,\"You canot withdraw Wolverinu staked token from Admantium.\");\r\n        require(!user.stakerecord[count].withdrawan,\" withdraw completed \");\r\n        require(amdToken.balanceOf(owner) >= user.stakerecord[count].amount,\"This owner doesnt have enough balance\");\r\n        \r\n        \r\n        if(!user.stakerecord[count].migrated){\r\n            checkEndingTime(msg.sender, count, user.stakerecord[count].plan);\r\n            require(endingTime > stakeTimeForEndind, \"You cannot withdraw amount before Time.\");\r\n            checkAfterTimeBonus(msg.sender,count);\r\n        }\r\n\r\n\r\n        amdToken.transferFrom(owner,msg.sender,user.stakerecord[count].amount);\r\n \r\n        \r\n        if( user.stakerecord[count].rewardToken == 1 ) {\r\n     \r\n           wolveToken.transferFrom(owner,msg.sender,user.stakerecord[count].bonus);\r\n        }\r\n        else {\r\n            amdToken.transferFrom(owner,msg.sender,user.stakerecord[count].bonus);\r\n        }\r\n        \r\n        if(user.stakerecord[count].transactions == 1){\r\n            if(deductedAmount[msg.sender] > 0){\r\n                wolveToken.transferFrom(owner,msg.sender,deductedAmount[msg.sender]);\r\n            }\r\n        }\r\n        \r\n        \r\n        if(user.stakerecord[count].migrated){\r\n            \r\n            uint256 value1 = 10; // percentage that how much amount that was deducted in Wolvrine token\r\n            uint256 deductedAmount2 = user.stakerecord[count].amount.mul(value1).div(100);\r\n            amdToken.transferFrom(owner,msg.sender,deductedAmount2);   \r\n        }\r\n        \r\n        if(!user.stakerecord[count].migrated){\r\n            if(user.stakerecord[count].beforeExtendBonus != 0){\r\n                if(user.stakerecord[count].rewardToken == 1){\r\n                    wolveToken.transferFrom(owner,msg.sender,user.stakerecord[count].beforeExtendBonus);\r\n                }\r\n                else{\r\n                    amdToken.transferFrom(owner,msg.sender,user.stakerecord[count].beforeExtendBonus);\r\n                }\r\n            }\r\n\r\n            if(user.stakerecord[count].afterTimeBonus != 0){\r\n                if(user.stakerecord[count].rewardToken == 1){\r\n                    wolveToken.transferFrom(owner,msg.sender,user.stakerecord[count].afterTimeBonus);\r\n                }\r\n                else{\r\n                    amdToken.transferFrom(owner,msg.sender,user.stakerecord[count].afterTimeBonus);\r\n                }\r\n            }\r\n        }\r\n        \r\n \r\n        user.claimedstakeTokens += user.stakerecord[count].amount;\r\n        user.claimedstakeTokens += user.stakerecord[count].bonus;\r\n        user.stakerecord[count].withdrawan = true;\r\n        totalAmdRewardToken+= user.stakerecord[count].bonus;\r\n     \r\n       emit Withdrawn(msg.sender,user.stakerecord[count].amount,block.timestamp);\r\n    }\r\n\r\n    function extendStake(uint256 count,uint256 newplan) public {\r\n       \r\n       User storage user = users[msg.sender];\r\n       \r\n        require(user.stakerecord[count].withdrawan != true,\"This stake is already withdrawn.\");\r\n        require(user.stakecount >= count, \"Invalid Stake index\");\r\n        require(newplan >= 0 && newplan < 4 ,\"Enter Valid Plan\");\r\n        require(user.stakerecord[count].plan < newplan, \"Can not extend to lower plan\");\r\n        require(!user.stakerecord[count].migrated,\"You canot extend migrated stake.\");\r\n\r\n        checkEndingTime(msg.sender, count, user.stakerecord[count].plan);\r\n        \r\n        require(endingTime < stakeTimeForEndind, \"You cannot extend stake after Time is Over.\");\r\n      \r\n        uint256 timeBefore = user.stakerecord[count].stakeTime;\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 beforeDays = (currentTime  - timeBefore).div(1 days);\r\n        \r\n        calculateNewReward(msg.sender,count,user.stakerecord[count].amount, beforeDays,user.stakerecord[count].plan);\r\n\r\n        user.stakerecord[count].plan = newplan;\r\n        user.stakerecord[count].stakeTime = block.timestamp;\r\n        user.stakerecord[count].withdrawTime = block.timestamp.add(durations[newplan]);\r\n        user.stakerecord[count].bonus = user.stakerecord[count].amount.mul(percentages[newplan]).div(percentDivider);\r\n        \r\n        emit ExtenderStake(msg.sender,user.stakerecord[count].amount,block.timestamp);\r\n    }\r\n\r\n\r\n    function checkAfterTimeBonus(address userAddress,uint count) public {\r\n\r\n        User storage user = users[userAddress];\r\n       \r\n        uint256 timeBefore = user.stakerecord[count].withdrawTime;\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 nextDays = (currentTime  - timeBefore).div(1 days);\r\n        \r\n        calculateNextReward(userAddress, count, user.stakerecord[count].amount, nextDays, user.stakerecord[count].plan);\r\n    }\r\n\r\n    function checkEndingTime(address userAddress, uint256 count, uint plan) public returns(uint256){\r\n       \r\n        User storage user = users[userAddress];\r\n\r\n        endingTime = (block.timestamp - user.stakerecord[count].stakeTime).div(1 days);\r\n        stakeTimeForEndind = durations[plan].div(1 days);\r\n        return endingTime;\r\n    }\r\n    \r\n    function migrateV1(address[] memory userList) external onlyOwner returns (bool){\r\n      \r\n        require(!migrationCheck,\"Owner  can not called this function again.\");\r\n      \r\n       for (uint i=0; i< userList.length; i++){\r\n\r\n            require(userList[i] != address(0),\"This is not a valid address\");\r\n            \r\n            User storage user = users[userList[i]];\r\n            \r\n            (uint256 _totalstakeduser, uint256 _stakecount, uint256 _claimedstakeTokens) = stakeInstance.users(userList[i]);\r\n            require(_stakecount != 0,\"He is not an old invester\");\r\n            \r\n            uint256 count = user.stakecount;\r\n            user.totalstakeduser += _totalstakeduser;\r\n            user.stakecount +=  _stakecount;\r\n            user.claimedstakeTokens += _claimedstakeTokens;\r\n           \r\n            for(uint256 j = 0; j < _stakecount; j++){\r\n                \r\n                (uint256 _withdrawTime/*,uint256 _stakeTime*/,uint256 _amount,uint256 _bonus,uint256 _plan,\r\n                bool _withdrawan) = stakeInstance.stakedetails(userList[i],j);\r\n                \r\n                user.stakerecord[count].plan = _plan;\r\n            //    user.stakerecord[j].stakeTime = _stakeTime;\r\n                user.stakerecord[count].amount = _amount;\r\n                user.stakerecord[count].withdrawTime = _withdrawTime;\r\n                user.stakerecord[count].bonus = _bonus;\r\n                user.stakerecord[count].withdrawan = _withdrawan;\r\n                user.stakerecord[count].rewardToken = 2;\r\n                user.stakerecord[count].transactions = 1;\r\n                user.stakerecord[count].migrated = true;\r\n                user.stakerecord[count].withdrawWith = 2;\r\n                count++;\r\n            }\r\n        }\r\n            migrationCheck = true;\r\n            return migrationCheck;\r\n    }\r\n \r\n    function changeOwner(address payable _newOwner) external onlyOwner {\r\n       owner = _newOwner;\r\n    }\r\n    \r\n    function migrateStuckFunds() external onlyOwner {\r\n       owner.transfer(address(this).balance);\r\n    }\r\n    \r\n    function migratelostToken(address lostToken) external onlyOwner {\r\n       IBEP20(lostToken).transfer(owner,IBEP20(lostToken).balanceOf(address(this)));\r\n    }\r\n   \r\n    function setminimumtokens(uint256 amount) external onlyOwner {\r\n        minStake = amount;\r\n    }\r\n    \r\n    function setpercentages(uint256 amount1,uint256 amount2,uint256 amount3,uint256 amount4) external onlyOwner {\r\n        percentages[0] = amount1;\r\n        percentages[1] = amount2;\r\n        percentages[2] = amount3;\r\n        percentages[3] = amount4;\r\n    }\r\n    \r\n    function stakedetails(address add, uint256 count)public view returns ( Stake memory ){\r\n       return (users[add].stakerecord[count]);\r\n    }\r\n\r\n    function getAllStakeDetail(address add)public view returns (Stake[] memory ){\r\n        \r\n        Stake[] memory userStakingInfo = new Stake[](users[add].stakecount);\r\n        \r\n        for(uint counter=0; counter < users[add].stakecount; counter++) {\r\n            Stake storage member = users[add].stakerecord[counter];\r\n            userStakingInfo[counter] = member;\r\n        }\r\n       return userStakingInfo;\r\n    }\r\n\r\n    function calculateRewards(uint256 amount, uint256 plan) external view returns (uint256){\r\n       return amount.mul(percentages[plan]).div(percentDivider);\r\n    }\r\n    \r\n    function calculaateNewPercentage(uint256 _newDuration,uint256 plan) public {\r\n        \r\n        uint256 newDuration = 1 days;\r\n        newDuration = newDuration * _newDuration;\r\n        newPercentage = APYtoPercentage(APY[plan], newDuration.div(1 days));\r\n\r\n    }\r\n\r\n    function calculateNewReward(address userAddress, uint256 userStakeCount, uint256 amount, uint256 _newDuration, uint256 plan) public{\r\n        \r\n        User storage user = users[userAddress]; \r\n        \r\n        calculaateNewPercentage(_newDuration, plan);\r\n        user.stakerecord[userStakeCount].beforeExtendBonus += amount.mul(newPercentage).div(percentDivider);\r\n    }\r\n    \r\n    function calculateNextReward(address userAddress, uint256 userStakeCount, uint256 amount, uint256 _newDuration, uint256 plan) public {\r\n\r\n        User storage user = users[userAddress]; \r\n        \r\n        calculaateNewPercentage(_newDuration, plan);\r\n        user.stakerecord[userStakeCount].afterTimeBonus = amount.mul(newPercentage).div(percentDivider);\r\n    }\r\n    \r\n    function APYtoPercentage(uint256 apy, uint256 duration) public pure returns(uint256){\r\n        return apy.mul(duration).div(525600);\r\n    }\r\n\r\n    function currentStaked(address add) external view returns (uint256) {\r\n        uint256 currentstaked;\r\n        for (uint256 i; i < users[add].stakecount; i++) {\r\n            if (!users[add].stakerecord[i].withdrawan) {\r\n               currentstaked += users[add].stakerecord[i].amount;\r\n            }\r\n        }\r\n        return currentstaked;\r\n    }\r\n    \r\n    function getContractBalance() external view returns (uint256) {\r\n       return address(this).balance;\r\n    }\r\n    \r\n    function getContractstakeTokenBalanceOfWolve() external view returns (uint256) {\r\n       return wolveToken.allowance(owner, address(this));\r\n    }\r\n    \r\n    function getContractstakeTokenBalanceOfAmd() external view returns (uint256) {\r\n       return amdToken.allowance(owner, address(this));\r\n    }\r\n    \r\n    function getCurrentwithdrawTime() external view returns (uint256) {\r\n       return block.timestamp;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wolve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"amd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"amdStaking\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_Time\",\"type\":\"uint256\"}],\"name\":\"ExtenderStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_Time\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"UNIQUESTAKERS\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_Time\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"APY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"apy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"APYtoPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amdToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"}],\"name\":\"calculaateNewPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"userStakeCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"}],\"name\":\"calculateNewReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"userStakeCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"}],\"name\":\"calculateNextReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"}],\"name\":\"calculateRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"checkAfterTimeBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"}],\"name\":\"checkEndingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"currentStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"durations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newplan\",\"type\":\"uint256\"}],\"name\":\"extendStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"getAllStakeDetail\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"beforeExtendBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"afterTimeBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withdrawan\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"migrated\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"transactions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawWith\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeContract.Stake[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractstakeTokenBalanceOfAmd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractstakeTokenBalanceOfWolve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentwithdrawTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrateStuckFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"userList\",\"type\":\"address[]\"}],\"name\":\"migrateV1\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lostToken\",\"type\":\"address\"}],\"name\":\"migratelostToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrationCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentDivider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"percentages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setminimumtokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount4\",\"type\":\"uint256\"}],\"name\":\"setpercentages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeInstance\",\"outputs\":[{\"internalType\":\"contract ADAMSTAKE\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeTimeForEndind\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardToken\",\"type\":\"uint256\"}],\"name\":\"stakeWithAmd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardToken\",\"type\":\"uint256\"}],\"name\":\"stakeWithWolve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"stakedetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"beforeExtendBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"afterTimeBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withdrawan\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"migrated\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"transactions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawWith\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeContract.Stake\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakewolvTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAmdRewardToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAmdStakeToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUniqueStakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWolveRewardToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWolveStakeToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"uniqueStaker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalstakeduser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakecount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedstakeTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"withdrawInAmd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"withdrawInWolve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wolveToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StakeContract", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ca7b3ba66556c4da2e2a9afef9c64f909a59430a0000000000000000000000002f72ad04c549e1ab350e52e8437ec795309218b3000000000000000000000000313c4923df3ab94067980d1f472a7af7032aaa52", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d48436b3b6fb83e800dbdc14c3f20866528bd7f26309056f91f89aa313f1442c"}]}