{"status": "1", "message": "OK", "result": [{"SourceCode": "// Sources flattened with hardhat v2.9.0 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// File @uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol@v1.1.0-beta.0\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n  function factory() external pure returns (address);\r\n\r\n  function WETH() external pure returns (address);\r\n\r\n  function addLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 amountADesired,\r\n    uint256 amountBDesired,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  )\r\n    external\r\n    returns (\r\n      uint256 amountA,\r\n      uint256 amountB,\r\n      uint256 liquidity\r\n    );\r\n\r\n  function addLiquidityETH(\r\n    address token,\r\n    uint256 amountTokenDesired,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  )\r\n    external\r\n    payable\r\n    returns (\r\n      uint256 amountToken,\r\n      uint256 amountETH,\r\n      uint256 liquidity\r\n    );\r\n\r\n  function removeLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 liquidity,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n  function removeLiquidityETH(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n  function removeLiquidityWithPermit(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 liquidity,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline,\r\n    bool approveMax,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n  function removeLiquidityETHWithPermit(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline,\r\n    bool approveMax,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n  function swapExactTokensForTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapTokensForExactTokens(\r\n    uint256 amountOut,\r\n    uint256 amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapExactETHForTokens(\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256[] memory amounts);\r\n\r\n  function swapTokensForExactETH(\r\n    uint256 amountOut,\r\n    uint256 amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapExactTokensForETH(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapETHForExactTokens(\r\n    uint256 amountOut,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256[] memory amounts);\r\n\r\n  function quote(\r\n    uint256 amountA,\r\n    uint256 reserveA,\r\n    uint256 reserveB\r\n  ) external pure returns (uint256 amountB);\r\n\r\n  function getAmountOut(\r\n    uint256 amountIn,\r\n    uint256 reserveIn,\r\n    uint256 reserveOut\r\n  ) external pure returns (uint256 amountOut);\r\n\r\n  function getAmountIn(\r\n    uint256 amountOut,\r\n    uint256 reserveIn,\r\n    uint256 reserveOut\r\n  ) external pure returns (uint256 amountIn);\r\n\r\n  function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n    external\r\n    view\r\n    returns (uint256[] memory amounts);\r\n\r\n  function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n    external\r\n    view\r\n    returns (uint256[] memory amounts);\r\n}\r\n\r\n// File @uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol@v1.1.0-beta.0\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountETH);\r\n\r\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline,\r\n    bool approveMax,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external returns (uint256 amountETH);\r\n\r\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external;\r\n\r\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable;\r\n\r\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external;\r\n}\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `to`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `from` to `to` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File contracts/interfaces/IAdmin.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IAdmin {\r\n  function rootAdmin() external view returns (address);\r\n\r\n  function changeRootAdmin(address _newRootAdmin) external;\r\n}\r\n\r\n// File contracts/abstracts/Admin.sol\r\n\r\npragma solidity 0.8.11;\r\n\r\ncontract Admin is IAdmin {\r\n  address public override rootAdmin;\r\n\r\n  event RootAdminChanged(address indexed oldRoot, address indexed newRoot);\r\n\r\n  constructor(address _rootAdmin) {\r\n    rootAdmin = _rootAdmin;\r\n  }\r\n\r\n  modifier onlyRootAdmin() {\r\n    require(msg.sender == rootAdmin, \"must be root admin\");\r\n    _;\r\n  }\r\n\r\n  function changeRootAdmin(address _newRootAdmin) public onlyRootAdmin {\r\n    address oldRoot = rootAdmin;\r\n    rootAdmin = _newRootAdmin;\r\n    emit RootAdminChanged(oldRoot, rootAdmin);\r\n  }\r\n}\r\n\r\n// File contracts/interfaces/IFeeCollector.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IFeeCollector {\r\n  function feeClaimer() external returns (address);\r\n\r\n  function feeDecimals() external returns (uint256);\r\n\r\n  function shifter() external returns (uint256);\r\n\r\n  function fee() external returns (uint256);\r\n\r\n  function tokenFeeReserves(address token) external returns (uint256);\r\n\r\n  function collectFee(\r\n    address token,\r\n    uint256 amount,\r\n    address beneficiary\r\n  ) external;\r\n\r\n  function setFeeClaimer(address newFeeClaimer) external;\r\n\r\n  function setFee(uint256 newFee) external;\r\n}\r\n\r\n// File contracts/abstracts/FeeCollector.sol\r\n\r\npragma solidity 0.8.11;\r\n\r\nabstract contract FeeCollector is IFeeCollector {\r\n  uint256 public constant override feeDecimals = 4;\r\n  uint256 public constant override shifter = 10**feeDecimals;\r\n  uint256 public override fee = 100; // 4 decimals => 0.01 * 10^4\r\n  address public override feeClaimer;\r\n\r\n  mapping(address => uint256) public override tokenFeeReserves;\r\n\r\n  event FeeCollected(\r\n    address indexed beneficiary,\r\n    address indexed token,\r\n    uint256 amount\r\n  );\r\n  event FeeClaimerChanged(\r\n    address indexed oldFeeClaimer,\r\n    address indexed newFeeClaimer\r\n  );\r\n  event FeeChanged(uint256 oldFee, uint256 newFee);\r\n\r\n  modifier onlyFeeCalimer() {\r\n    require(msg.sender == feeClaimer, \"Only fee claimer\");\r\n    _;\r\n  }\r\n\r\n  constructor(address feeClaimer_) {\r\n    feeClaimer = feeClaimer_;\r\n  }\r\n\r\n  function deductFee(address token, uint256 amount)\r\n    internal\r\n    returns (uint256, uint256)\r\n  {\r\n    uint256 collectedFee = (amount * fee) / shifter;\r\n    uint256 output = amount - collectedFee;\r\n    tokenFeeReserves[token] += collectedFee;\r\n    return (output, collectedFee);\r\n  }\r\n\r\n  function collectFee(\r\n    address token,\r\n    uint256 amount,\r\n    address beneficiary\r\n  ) external override onlyFeeCalimer {\r\n    uint256 withdrewAmount = amount >= tokenFeeReserves[token]\r\n      ? tokenFeeReserves[token]\r\n      : amount;\r\n    IERC20(token).transfer(beneficiary, withdrewAmount);\r\n    tokenFeeReserves[token] -= withdrewAmount;\r\n    emit FeeCollected(beneficiary, token, withdrewAmount);\r\n  }\r\n\r\n  function _setFeeClaimer(address newFeeClaimer) internal {\r\n    address oldFeeCalimer = feeClaimer;\r\n    feeClaimer = newFeeClaimer;\r\n    emit FeeClaimerChanged(oldFeeCalimer, feeClaimer);\r\n  }\r\n\r\n  function _setFee(uint256 newFee) internal {\r\n    uint256 oldFee = fee;\r\n    fee = newFee;\r\n    emit FeeChanged(oldFee, fee);\r\n  }\r\n}\r\n\r\n// File contracts/interfaces/IBridge.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IBridge {\r\n  function bridge(\r\n    IERC20 _token,\r\n    uint256 _amount,\r\n    uint256 _destChainID,\r\n    address _to\r\n  ) external;\r\n}\r\n\r\n// File contracts/BKFBroker.sol\r\n\r\npragma solidity 0.8.11;\r\n\r\ncontract BKFBroker is Admin, FeeCollector {\r\n  uint256 private constant _NEW = 0;\r\n  uint256 private constant _COMPLETED = 1;\r\n\r\n  mapping(uint256 => uint256) public orderStatus;\r\n  address public swapRouter;\r\n  address public bridge;\r\n\r\n  event Purchased(\r\n    uint256 orderId,\r\n    address indexed payer,\r\n    address indexed merchant,\r\n    address inputToken,\r\n    address indexed outputToken,\r\n    uint256 amountIn,\r\n    uint256 amountOut,\r\n    uint256 fee,\r\n    uint256 destChainId\r\n  );\r\n\r\n  event SwapRouterChanged(address oldSwapRouter, address newSwapRouter);\r\n  event BridgeChanged(address oldBridge, address newBridge);\r\n\r\n  constructor(\r\n    address _router,\r\n    address _bridge,\r\n    address _rootAdmin,\r\n    address _feeClaimer\r\n  ) Admin(_rootAdmin) FeeCollector(_feeClaimer) {\r\n    swapRouter = _router;\r\n    bridge = _bridge;\r\n  }\r\n\r\n  function purchase(\r\n    uint256 orderId,\r\n    address merchant,\r\n    address inputToken,\r\n    address outputToken,\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    uint256 deadline,\r\n    uint256 destChainID\r\n  ) public {\r\n    require(orderStatus[orderId] == _NEW, \"Order was completed\");\r\n\r\n    uint256 amountOut;\r\n    uint256 deductedFee;\r\n\r\n    if (inputToken == outputToken) {\r\n      (amountOut, deductedFee) = deductFee(inputToken, amountIn);\r\n\r\n      IERC20(inputToken).transferFrom(msg.sender, address(this), amountOut);\r\n    } else {\r\n      uint256 swapOutput = swapTokensForExactTokens(\r\n        inputToken,\r\n        outputToken,\r\n        amountOutMin,\r\n        amountIn,\r\n        address(this),\r\n        deadline\r\n      );\r\n\r\n      (amountOut, deductedFee) = deductFee(outputToken, swapOutput);\r\n    }\r\n\r\n    if (getChainID() != destChainID) {\r\n      IERC20(outputToken).approve(bridge, amountOut);\r\n      IBridge(bridge).bridge(\r\n        IERC20(outputToken),\r\n        amountOut,\r\n        destChainID,\r\n        merchant\r\n      );\r\n    } else {\r\n      IERC20(outputToken).transfer(merchant, amountOut);\r\n    }\r\n\r\n    orderStatus[orderId] = _COMPLETED;\r\n\r\n    emit Purchased(\r\n      orderId,\r\n      msg.sender,\r\n      merchant,\r\n      inputToken,\r\n      outputToken,\r\n      amountIn,\r\n      amountOut,\r\n      deductedFee,\r\n      destChainID\r\n    );\r\n  }\r\n\r\n  function swapTokensForExactTokens(\r\n    address _tokenIn,\r\n    address _tokenOut,\r\n    uint256 _amountOut,\r\n    uint256 _amountInMax,\r\n    address _to,\r\n    uint256 _deadline\r\n  ) private returns (uint256) {\r\n    IERC20(_tokenIn).transferFrom(msg.sender, address(this), _amountInMax);\r\n    IERC20(_tokenIn).approve(swapRouter, _amountInMax);\r\n\r\n    address[] memory path = new address[](2);\r\n\r\n    path[0] = _tokenIn;\r\n    path[1] = _tokenOut;\r\n\r\n    // Receive an exact amount of output tokens for as few input tokens as possible\r\n    uint256[] memory amounts = IUniswapV2Router02(swapRouter)\r\n      .swapTokensForExactTokens(_amountOut, _amountInMax, path, _to, _deadline);\r\n\r\n    return amounts[amounts.length - 1];\r\n  }\r\n\r\n  function setFee(uint256 newFee) external onlyRootAdmin {\r\n    _setFee(newFee);\r\n  }\r\n\r\n  function setFeeClaimer(address newFeeClaimer) external onlyRootAdmin {\r\n    _setFeeClaimer(newFeeClaimer);\r\n  }\r\n\r\n  function setSwapRouter(address newSwapRouter) external onlyRootAdmin {\r\n    address oldSwapRouter = swapRouter;\r\n    swapRouter = newSwapRouter;\r\n    emit SwapRouterChanged(oldSwapRouter, newSwapRouter);\r\n  }\r\n\r\n  function setBridge(address newBridge) external onlyRootAdmin {\r\n    address oldBridge = bridge;\r\n    bridge = newBridge;\r\n    emit BridgeChanged(oldBridge, newBridge);\r\n  }\r\n\r\n  function getChainID() public view returns (uint256) {\r\n    uint256 id;\r\n    assembly {\r\n      id := chainid()\r\n    }\r\n    return id;\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rootAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeClaimer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldBridge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newBridge\",\"type\":\"address\"}],\"name\":\"BridgeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"FeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldFeeClaimer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFeeClaimer\",\"type\":\"address\"}],\"name\":\"FeeClaimerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeeCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destChainId\",\"type\":\"uint256\"}],\"name\":\"Purchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRoot\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRoot\",\"type\":\"address\"}],\"name\":\"RootAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldSwapRouter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSwapRouter\",\"type\":\"address\"}],\"name\":\"SwapRouterChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRootAdmin\",\"type\":\"address\"}],\"name\":\"changeRootAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"collectFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeClaimer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destChainID\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBridge\",\"type\":\"address\"}],\"name\":\"setBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeClaimer\",\"type\":\"address\"}],\"name\":\"setFeeClaimer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSwapRouter\",\"type\":\"address\"}],\"name\":\"setSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shifter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenFeeReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BKFBroker", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000009f1ee8b6a8ffc153ec92c61d8e0346f4119e358a0000000000000000000000008c89d9db9116e84e9ecd8471e4de138e8dc2f2880000000000000000000000008c89d9db9116e84e9ecd8471e4de138e8dc2f288", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1c196840db1bdad740863e2b46afcbd9bce32261dcba0e371d93cd9a5be15f82"}]}