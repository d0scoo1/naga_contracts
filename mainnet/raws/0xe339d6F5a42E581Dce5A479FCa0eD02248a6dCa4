{"status": "1", "message": "OK", "result": [{"SourceCode": "// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/EthTime.sol\n// SPDX-License-Identifier: MIT AND AGPL-3.0-only\npragma solidity =0.8.10 >=0.6.0 >=0.8.0 >=0.6.0 <0.9.0 >=0.8.0 <0.9.0;\n\n////// lib/BokkyPooBahsDateTimeLibrary/contracts/BokkyPooBahsDateTimeLibrary.sol\n/* pragma solidity >=0.6.0 <0.9.0; */\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary BokkyPooBahsDateTimeLibrary {\n\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n\n        int __days = _day\n          - 32075\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n          - OFFSET19700101;\n\n        _days = uint(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}\n\n////// lib/base64-sol/base64.sol\n\n/* pragma solidity >=0.6.0; */\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/utils/Context.sol\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n/* pragma solidity ^0.8.0; */\n\n/* import \"../utils/Context.sol\"; */\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/utils/Strings.sol\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n////// lib/solmate/src/tokens/ERC721.sol\n/* pragma solidity >=0.8.0; */\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(uint256 => address) public ownerOf;\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = ownerOf[id];\n\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            balanceOf[owner]--;\n        }\n\n        delete ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n////// lib/solmate/src/utils/ReentrancyGuard.sol\n/* pragma solidity >=0.8.0; */\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n\n////// src/CharitySplitter.sol\n/* pragma solidity 0.8.10; */\n\n\n/// @dev Emitted when trying to set the address to something invalid.\nerror CharitySplitter__InvalidCharityAddress();\n\n/// @dev Emitted when trying to set the fee to something invalid.\nerror CharitySplitter__InvalidCharityFee();\n\n/// @notice Tracks splitting profits with a charity.\n/// @dev This module essentialy does two things:\n///  * Tracks how much money goes to the charity and how much to someone else.\n///  * Implements a simple time-lock to avoid the contract owner changing the\n///    charity address to one they own.\n///\n/// Anyone can call the method to send the funds to the charity.\ncontract CharitySplitter {\n    //////////////////////////////////////////////////////////////////////////\n    //                                                                      //\n    //                            Constructor                               //\n    //                                                                      //\n    //////////////////////////////////////////////////////////////////////////\n\n    /// @dev Charity address, can be changed with a time-lock.\n    address payable public charity;\n\n    /// @dev Charity fee, in basis points. 1% = 100 bp.\n    uint256 public charityFeeBp;\n\n    constructor(address payable _charity, uint256 _charityFeeBp) {\n        // checks: address not zero. Don't want to burn eth.\n        if (_charity == address(0)) {\n            revert CharitySplitter__InvalidCharityAddress();\n        }\n\n        // checks: fee > 0%. Don't want to deal with no fee edge cases.\n        if (_charityFeeBp == 0) {\n            revert CharitySplitter__InvalidCharityFee();\n        }\n\n        charity = _charity;\n        charityFeeBp = _charityFeeBp;\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //                                                                      //\n    //                     Charity Address Management                       //\n    //                                                                      //\n    //////////////////////////////////////////////////////////////////////////\n\n    /// @dev Emitted when the charity address is updated.\n    event CharityUpdated(address charity);\n\n    /// @dev Update the charity address.\n    function _updateCharity(address payable _charity)\n        internal\n    {\n        if (_charity == address(0)) {\n            revert CharitySplitter__InvalidCharityAddress();\n        }\n\n        charity = _charity;\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //                                                                      //\n    //                         Profit Tracking                              //\n    //                                                                      //\n    //////////////////////////////////////////////////////////////////////////\n\n    /// @dev Balance owed to the charity.\n    uint256 public charityBalance;\n\n    /// @dev Balance owed to the owner.\n    uint256 public ownerBalance;\n\n    /// @dev Denominator used when computing fee. 100% in bp.\n    uint256 private constant BP_DENOMINATOR = 10000;\n\n    /// @dev Update charity and owner balance.\n    function _updateBalance(uint256 value)\n        internal\n    {\n        // checks: if value is zero nothing to update.\n        if (value == 0) {\n            return;\n        }\n\n        uint256 charityValue = (value * charityFeeBp) / BP_DENOMINATOR;\n        uint256 ownerValue = value - charityValue;\n\n        // effects: update balances.\n        charityBalance += charityValue;\n        ownerBalance += ownerValue;\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //                                                                      //\n    //                       Withdrawing Funds                              //\n    //                                                                      //\n    //////////////////////////////////////////////////////////////////////////\n\n    /// @notice Withdraw funds to charity address.\n    function _withdrawCharityBalance()\n        internal\n    {\n        uint256 value = charityBalance;\n\n        // checks: no money to withdraw.\n        if (value == 0) {\n            return;\n        }\n\n        // effects: reset charity balance to zero.\n        charityBalance = 0;\n\n        // interactions: send money to charity address.\n        (bool sent, ) = charity.call{value: value}(\"\");\n        require(sent);\n    }\n\n    /// @notice Withdraw funds to owner address.\n    /// @param destination the address that receives the funds.\n    function _withdrawOwnerBalance(address payable destination)\n        internal\n    {\n        uint256 value = ownerBalance;\n\n        // checks: no money to withdraw.\n        if (value == 0) {\n            return;\n        }\n\n        // effects: reset owner balance to zero.\n        ownerBalance = 0;\n\n        // interactions: send money to destination address.\n        (bool sent, ) = destination.call{value: value}(\"\");\n        require(sent);\n    }\n}\n\n////// src/EthTime.sol\n/* pragma solidity 0.8.10; */\n\n/* import {Base64} from \"@base64-sol/base64.sol\"; */\n/* import {BokkyPooBahsDateTimeLibrary} from \"@bpb-datetime/BokkyPooBahsDateTimeLibrary.sol\"; */\n/* import {ERC721, ERC721TokenReceiver} from \"@solmate/tokens/ERC721.sol\"; */\n/* import {ReentrancyGuard} from \"@solmate/utils/ReentrancyGuard.sol\"; */\n/* import {Strings} from \"@openzeppelin/utils/Strings.sol\"; */\n/* import {Ownable} from \"@openzeppelin/access/Ownable.sol\"; */\n\n/* import {CharitySplitter} from \"./CharitySplitter.sol\"; */\n\n\n/// @notice The NFT with the given id does not exist.\nerror EthTime__DoesNotExist();\n\n/// @notice The operation requires the sender to be the owner.\nerror EthTime__NotOwner();\n\n/// @notice Time offset (in minutes) is invalid.\nerror EthTime__InvalidTimeOffset();\n\n/// @notice The number is outside the supported range.\nerror EthTime__NumberOutOfRange();\n\n/// @notice The provided value is too low to mint.\nerror EthTime__InvalidMintValue();\n\n/// @notice Trying to mint more NFTs than the amount allowed.\nerror EthTime__InvalidMintAmount();\n\n/// @notice The collection has been completely minted.\nerror EthTime__CollectionMintClosed();\n\n/// @notice ETH-Time NFT contract.\ncontract EthTime is ERC721, CharitySplitter, Ownable, ReentrancyGuard {\n    //////////////////////////////////////////////////////////////////////////\n    //                                                                      //\n    //                            Constructor                               //\n    //                                                                      //\n    //////////////////////////////////////////////////////////////////////////\n\n    constructor(address payable charity, uint256 charityFeeBp)\n        ERC721(\"ETH Time\", \"ETHT\")\n        CharitySplitter(charity, charityFeeBp)\n    {\n    }\n\n    receive() external payable {}\n\n    //////////////////////////////////////////////////////////////////////////\n    //                                                                      //\n    //                     Transfer with History                            //\n    //                                                                      //\n    //////////////////////////////////////////////////////////////////////////\n\n    /// @notice The state of each NFT.\n    mapping(uint256 => uint160) public historyAccumulator;\n\n    function transferFrom(address from, address to, uint256 id)\n        public\n        nonReentrant\n        override\n    {\n        _transferFrom(from, to, id);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 id)\n        public\n        nonReentrant\n        override\n    {\n        _transferFrom(from, to, id);\n\n        // interactions: check destination can handle ERC721\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(address from, address to, uint256 id, bytes memory /* data */)\n        public\n        nonReentrant\n        override\n    {\n        _transferFrom(from, to, id);\n\n        // interactions: check destination can handle ERC721\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //                                                                      //\n    //                        Charity Splitter                              //\n    //                                                                      //\n    //////////////////////////////////////////////////////////////////////////\n\n    /// @notice Withdraw charity balance to charity address.\n    /// @dev Anyone can call this at any time.\n    function withdrawCharityBalance()\n        public\n        nonReentrant\n    {\n        _withdrawCharityBalance();\n    }\n\n    /// @notice Withdraw owner balance to the specified address.\n    /// @param destination the address that receives the owner balance.\n    function withdrawOwnerBalance(address payable destination)\n        public\n        onlyOwner\n        nonReentrant\n    {\n        _withdrawOwnerBalance(destination);\n    }\n\n    /// @notice Update the address that receives the charity fee.\n    /// @param charity the new charity address.\n    function updateCharity(address payable charity)\n        public\n        onlyOwner\n        nonReentrant\n    {\n        _updateCharity(charity);\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //                                                                      //\n    //                      Timezone Management                             //\n    //                                                                      //\n    //////////////////////////////////////////////////////////////////////////\n\n    mapping(uint256 => int128) public timeOffsetMinutes;\n\n    event TimeOffsetUpdated(uint256 indexed id, int128 offsetMinutes);\n\n    /// @notice Sets the time offset of the given token id.\n    /// @dev Use minutes because some timezones (like IST) are offset by half an hour.\n    /// @param id the NFT unique id.\n    /// @param offsetMinutes the offset in minutes.\n    function setTimeOffsetMinutes(uint256 id, int128 offsetMinutes)\n        public\n    {\n        // checks: id exists\n        if (ownerOf[id] == address(0)) {\n            revert EthTime__DoesNotExist();\n        }\n\n        // checks: sender is owner.\n        if (ownerOf[id] != msg.sender) {\n            revert EthTime__NotOwner();\n        }\n\n        // checks: validate time offset\n        _validateTimeOffset(offsetMinutes);\n\n        // effects: update time offset\n        timeOffsetMinutes[id] = offsetMinutes;\n\n        emit TimeOffsetUpdated(id, offsetMinutes);\n    }\n\n    function _validateTimeOffset(int128 offsetMinutes)\n        internal\n    {\n        int128 offsetSeconds = offsetMinutes * 60;\n\n        // checks: offset is  [-12, +14] hours UTC\n        if (offsetSeconds > 14 hours || offsetSeconds < -12 hours) {\n            revert EthTime__InvalidTimeOffset();\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //                                                                      //\n    //                              Minting                                 //\n    //                                                                      //\n    //////////////////////////////////////////////////////////////////////////\n\n    /// @dev The number of tokens minted.\n    uint256 public totalSupply;\n\n    /// @dev The maximum number of mintable tokens.\n    uint256 public constant maximumSupply = 100;\n\n    uint256 private constant TARGET_PRICE = 1 ether;\n    uint256 private constant PRICE_INCREMENT = TARGET_PRICE / maximumSupply * 2;\n\n    /// @notice Mint a new NFT, transfering ownership to the given account.\n    /// @dev If the token id already exists, this method fails.\n    /// @param to the NFT ower.\n    /// @param offsetMinutes the time offset in minutes.\n    /// @param id the NFT unique id.\n    function mint(address to, int128 offsetMinutes, uint256 id)\n        public\n        payable\n        nonReentrant\n        virtual\n    {\n        // interactions: mint.\n        uint256 valueLeft = _mint(to, offsetMinutes, id, msg.value);\n    \n        // interactions: send back leftover value.\n        if (valueLeft > 0) {\n            (bool success, ) = msg.sender.call{value: valueLeft}(\"\");\n            require(success);\n        }\n    }\n\n    /// @notice Mint new NFTs, transfering ownership to the given account.\n    /// @dev If any of the token ids already exists, this method fails.\n    /// @param to the NFT ower.\n    /// @param offsetMinutes the time offset in minutes.\n    /// @param ids the NFT unique ids.\n    function batchMint(address to, int128 offsetMinutes, uint256[] calldata ids)\n        public\n        payable\n        nonReentrant\n        virtual\n    {\n        uint256 count = ids.length;\n\n        // checks: can mint count nfts\n        _validateBatchMintCount(count);\n\n        uint256 valueLeft = msg.value;\n        for (uint256 i = 0; i < count; i++) {\n            // interactions: mint.\n            valueLeft = _mint(to, offsetMinutes, ids[i], valueLeft);\n        }\n\n        // interactions: send back leftover value.\n        if (valueLeft > 0) {\n            (bool success, ) = msg.sender.call{value: valueLeft}(\"\");\n            require(success);\n        }\n    }\n\n    /// @notice Get the price for minting the next `count` NFT.\n    function getBatchMintPrice(uint256 count)\n        public\n        view\n        returns (uint256)\n    {\n        // checks: can mint count nfts\n        _validateBatchMintCount(count);\n\n        uint256 supply = totalSupply;\n        uint256 price = 0;\n        for (uint256 i = 0; i < count; i++) {\n            price += _priceAtSupplyLevel(supply + i);\n        }\n        \n        return price;\n    }\n\n    /// @notice Get the price for minting the next NFT.\n    function getMintPrice()\n        public\n        view\n        returns (uint256)\n    {\n        return _priceAtSupplyLevel(totalSupply);\n    }\n\n    function _mint(address to, int128 offsetMinutes, uint256 id, uint256 value)\n        internal\n        returns (uint256 valueLeft)\n    {\n        uint256 price = _priceAtSupplyLevel(totalSupply);\n\n        // checks: value is enough to mint the nft.\n        if (value < price) {\n            revert EthTime__InvalidMintValue();\n        }\n\n        // checks: minting causes going over maximum supply.\n        if (totalSupply == maximumSupply) {\n            revert EthTime__CollectionMintClosed();\n        }\n\n        // checks: validate offset\n        _validateTimeOffset(offsetMinutes);\n\n        // effects: seed history with unique starting value.\n        historyAccumulator[id] = uint160(id >> 4);\n\n        // effects: increment total supply.\n        totalSupply += 1;\n\n        // effects: update charity split.\n        _updateBalance(value);\n\n        // effects: set time offset\n        timeOffsetMinutes[id] = offsetMinutes;\n\n        // interactions: safe mint\n        _safeMint(to, id);\n\n        // return value left to be sent back to user.\n        valueLeft = value - price;\n    }\n\n    function _priceAtSupplyLevel(uint256 supply)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 price = supply * PRICE_INCREMENT;\n\n        if (supply > 50) {\n            price = TARGET_PRICE;\n        }\n\n        return price;\n    }\n\n    function _validateBatchMintCount(uint256 count)\n        internal\n        view\n    {\n        // checks: no more than 10.\n        if (count > 10) {\n            revert EthTime__InvalidMintAmount();\n        }\n\n        // checks: minting does not push over the limit.\n        // notice that it would fail anyway.\n        if (totalSupply + count > maximumSupply) {\n            revert EthTime__InvalidMintAmount();\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //                                                                      //\n    //                           Token URI                                  //\n    //                                                                      //\n    //////////////////////////////////////////////////////////////////////////\n\n    /// @notice Returns the URI with the NFT metadata.\n    /// @dev Returns the base64 encoded metadata inline.\n    /// @param id the NFT unique id\n    function tokenURI(uint256 id)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        if (ownerOf[id] == address(0)) {\n            revert EthTime__DoesNotExist();\n        }\n\n        string memory tokenId = Strings.toString(id);\n\n        (uint256 hour, uint256 minute) = _adjustedHourMinutes(id);\n\n        bytes memory topHue = _computeHue(historyAccumulator[id], id);\n        bytes memory bottomHue = _computeHue(uint160(ownerOf[id]), id);\n\n        int128 offset = timeOffsetMinutes[id];\n        bytes memory offsetSign = offset >= 0 ? bytes('+') : bytes('-');\n        uint256 offsetUnsigned = offset >= 0 ? uint256(int256(offset)) : uint256(int256(-offset));\n\n        return\n            string(\n                bytes.concat(\n                    'data:application/json;base64,',\n                    bytes(\n                        Base64.encode(\n                            bytes.concat(\n                                '{\"name\": \"ETH Time #',\n                                bytes(tokenId),\n                                '\", \"description\": \"ETH Time\", \"image\": \"data:image/svg+xml;base64,',\n                                bytes(_tokenImage(topHue, bottomHue, hour, minute)),\n                                '\", \"attributes\": [{\"trait_type\": \"top_color\", \"value\": \"hsl(', topHue, ',100%,89%)\"},',\n                                '{\"trait_type\": \"bottom_color\", \"value\": \"hsl(', bottomHue, ',77%,36%)\"},',\n                                '{\"trait_type\": \"time_offset\", \"value\": \"', offsetSign, bytes(Strings.toString(offsetUnsigned)),  '\"},',\n                                '{\"trait_type\": \"time\", \"value\": \"', bytes(Strings.toString(hour)), ':', bytes(Strings.toString(minute)), '\"}]}'\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    /// @dev Generate a preview of the token that will be minted.\n    /// @param to the minter.\n    /// @param id the NFT unique id.\n    function tokenImagePreview(address to, uint256 id)\n        public\n        view\n        returns (string memory)\n    {\n        (uint256 hour, uint256 minute) = _adjustedHourMinutes(id);\n\n        bytes memory topHue = _computeHue(uint160(id >> 4), id);\n        bytes memory bottomHue = _computeHue(uint160(to), id);\n\n        return _tokenImage(topHue, bottomHue, hour, minute);\n    }\n\n    //////////////////////////////////////////////////////////////////////////\n    //                                                                      //\n    //                         Private Functions                            //\n    //                                                                      //\n    //////////////////////////////////////////////////////////////////////////\n\n    /// @dev Update the NFT history based on the transfer to the given account.\n    /// @param to the address that will receive the nft.\n    /// @param id the NFT unique id.\n    function _updateHistory(address to, uint256 id)\n        internal\n    {\n        // effects: xor existing value with address bytes content.\n        historyAccumulator[id] ^= uint160(to) << 2;\n    }\n\n    function _transferFrom(address from, address to, uint256 id)\n        internal\n    {\n        // checks: sender and destination\n        require(from == ownerOf[id], \"WRONG_FROM\");\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        // checks: can transfer\n        require(\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // effects: update balance\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n            balanceOf[to]++;\n        }\n\n        // effects: update owership\n        ownerOf[id] = to;\n\n        // effects: reclaim storage\n        delete getApproved[id];\n\n        // effects: update history\n        _updateHistory(to, id);\n\n        emit Transfer(from, to, id);\n    }\n\n    bytes constant onColor = \"FFF\";\n    bytes constant offColor = \"333\";\n\n    /// @dev Generate the SVG image for the given NFT.\n    function _tokenImage(bytes memory topHue, bytes memory bottomHue, uint256 hour, uint256 minute)\n        internal\n        pure\n        returns (string memory)\n    {\n\n        return\n            Base64.encode(\n                bytes.concat(\n                    '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1000 1000\">',\n                    '<linearGradient id=\"bg\" gradientTransform=\"rotate(90)\">',\n                    '<stop offset=\"0%\" stop-color=\"hsl(', topHue, ',100%,89%)\"/>',\n                    '<stop offset=\"100%\" stop-color=\"hsl(', bottomHue, ',77%,36%)\"/>',\n                    '</linearGradient>',\n                    '<rect x=\"0\" y=\"0\" width=\"1000\" height=\"1000\" fill=\"url(#bg)\"/>',\n                    _binaryHour(hour),\n                    _binaryMinute(minute),\n                    '</svg>'\n                )\n            );\n    }\n\n    function _binaryHour(uint256 hour)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (hour > 24) {\n            revert EthTime__NumberOutOfRange();\n        }\n\n        bytes[7] memory colors = _binaryColor(hour);\n\n        return\n            bytes.concat(\n                '<circle cx=\"665\" cy=\"875\" r=\"25\" fill=\"#', colors[0], '\"/>',\n                '<circle cx=\"665\" cy=\"805\" r=\"25\" fill=\"#', colors[1], '\"/>',\n                // skip colors[2]\n                '<circle cx=\"735\" cy=\"875\" r=\"25\" fill=\"#', colors[3], '\"/>',\n                '<circle cx=\"735\" cy=\"805\" r=\"25\" fill=\"#', colors[4], '\"/>',\n                '<circle cx=\"735\" cy=\"735\" r=\"25\" fill=\"#', colors[5], '\"/>',\n                '<circle cx=\"735\" cy=\"665\" r=\"25\" fill=\"#', colors[6], '\"/>'\n            );\n    }\n\n    function _binaryMinute(uint256 minute)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (minute > 59) {\n            revert EthTime__NumberOutOfRange();\n        }\n\n        bytes[7] memory colors = _binaryColor(minute);\n\n        return\n            bytes.concat(\n                '<circle cx=\"805\" cy=\"875\" r=\"25\" fill=\"#', colors[0], '\"/>',\n                '<circle cx=\"805\" cy=\"805\" r=\"25\" fill=\"#', colors[1], '\"/>',\n                '<circle cx=\"805\" cy=\"735\" r=\"25\" fill=\"#', colors[2], '\"/>',\n\n                '<circle cx=\"875\" cy=\"875\" r=\"25\" fill=\"#', colors[3], '\"/>',\n                '<circle cx=\"875\" cy=\"805\" r=\"25\" fill=\"#', colors[4], '\"/>',\n                '<circle cx=\"875\" cy=\"735\" r=\"25\" fill=\"#', colors[5], '\"/>',\n                '<circle cx=\"875\" cy=\"665\" r=\"25\" fill=\"#', colors[6], '\"/>'\n            );\n    }\n\n    /// @dev Returns the colors to be used to display the time.\n    /// The first 3 bytes are used for the first digit, the remaining 4 bytes\n    /// for the second digit.\n    function _binaryColor(uint256 n)\n        internal\n        pure\n        returns (bytes[7] memory)\n    {\n        unchecked {\n            uint256 firstDigit = n / 10;\n            uint256 secondDigit = n % 10;\n\n            return [\n                (firstDigit & 0x1 != 0) ? onColor : offColor,\n                (firstDigit & 0x2 != 0) ? onColor : offColor,\n                (firstDigit & 0x4 != 0) ? onColor : offColor,\n\n                (secondDigit & 0x1 != 0) ? onColor : offColor,\n                (secondDigit & 0x2 != 0) ? onColor : offColor,\n                (secondDigit & 0x4 != 0) ? onColor : offColor,\n                (secondDigit & 0x8 != 0) ? onColor : offColor\n            ];\n        }\n    }\n\n    function _computeHue(uint160 n, uint256 id)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        uint160 t = n ^ uint160(id);\n        uint160 acc = t % 360;\n        return bytes(Strings.toString(acc));\n    }\n\n    function _adjustedHourMinutes(uint256 id)\n        internal\n        view\n        returns (uint256 hour, uint256 minute)\n    {\n        int256 signedUserTimestamp = int256(block.timestamp) - 60 * timeOffsetMinutes[id];\n\n        uint256 userTimestamp;\n        // this won't realistically ever happen\n        if (signedUserTimestamp <= 0) {\n            userTimestamp = 0;\n        } else {\n            userTimestamp = uint256(signedUserTimestamp);\n        }\n        hour = BokkyPooBahsDateTimeLibrary.getHour(userTimestamp);\n        minute = BokkyPooBahsDateTimeLibrary.getMinute(userTimestamp);\n    }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"charity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"charityFeeBp\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CharitySplitter__InvalidCharityAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CharitySplitter__InvalidCharityFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EthTime__CollectionMintClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EthTime__DoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EthTime__InvalidMintAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EthTime__InvalidMintValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EthTime__InvalidTimeOffset\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EthTime__NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EthTime__NumberOutOfRange\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"charity\",\"type\":\"address\"}],\"name\":\"CharityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int128\",\"name\":\"offsetMinutes\",\"type\":\"int128\"}],\"name\":\"TimeOffsetUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"int128\",\"name\":\"offsetMinutes\",\"type\":\"int128\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charity\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityFeeBp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getBatchMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"historyAccumulator\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"int128\",\"name\":\"offsetMinutes\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"int128\",\"name\":\"offsetMinutes\",\"type\":\"int128\"}],\"name\":\"setTimeOffsetMinutes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"timeOffsetMinutes\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"\",\"type\":\"int128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenImagePreview\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"charity\",\"type\":\"address\"}],\"name\":\"updateCharity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawCharityBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"withdrawOwnerBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EthTime", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000001d4ca24e05e6471610e53ef550848d5ae7b53e5e0000000000000000000000000000000000000000000000000000000000000bb8", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}