{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/GaugeController.sol\": {\r\n      \"content\": \"pragma solidity 0.8.10;\\n\\n/***\\n *@title Gauge Controller\\n *@author InsureDAO\\n * SPDX-License-Identifier: MIT\\n *@notice Controls liquidity gauges and the issuance of INSURE token through the gauges\\n */\\n\\n//dao-contracts\\nimport \\\"./interfaces/dao/IInsureToken.sol\\\";\\nimport \\\"./interfaces/dao/IVotingEscrow.sol\\\";\\nimport \\\"./interfaces/pool/IOwnership.sol\\\";\\n\\ncontract GaugeController {\\n    // 7 * 86400 seconds - all future times are rounded by week\\n    uint256 constant WEEK = 604800;\\n\\n    // Cannot change weight votes more often than once in 10 days.\\n    uint256 constant WEIGHT_VOTE_DELAY = 10 * 86400;\\n\\n    struct Point {\\n        uint256 bias;\\n        uint256 slope;\\n    }\\n\\n    struct VotedSlope {\\n        uint256 slope;\\n        uint256 power;\\n        uint256 end;\\n    }\\n\\n    event AddType(string name, uint256 type_id);\\n    event NewTypeWeight(\\n        uint256 type_id,\\n        uint256 time,\\n        uint256 weight,\\n        uint256 total_weight\\n    );\\n\\n    event NewGaugeWeight(\\n        address gauge_address,\\n        uint256 time,\\n        uint256 weight,\\n        uint256 total_weight\\n    );\\n    event VoteForGauge(\\n        uint256 time,\\n        address user,\\n        address gauge_addr,\\n        uint256 weight\\n    );\\n    event NewGauge(address addr, uint256 gauge_type, uint256 weight);\\n\\n    uint256 constant MULTIPLIER = 10 ** 18;\\n\\n    IInsureToken public token;\\n    IVotingEscrow public voting_escrow;\\n\\n    // Gauge parameters\\n    // All numbers are \\\"fixed point\\\" on the basis of 1e18\\n    uint256 public n_gauge_types = 1; // There is [gauge_type(0) : unset] as default. [gauge_type(1) : LiquidityGauge] will be added as the contract is deployed, and \\\"n_gauge_types\\\" will be incremented to 2. This part is modified from Curve's contract.\\n    uint256 public n_gauges; //number of gauges\\n    mapping(uint256 => string) public gauge_type_names;\\n\\n    // Needed for enumeration\\n    address[1000000000] public gauges;\\n\\n    // \\\"0\\\" means that a gauge has not been set\\n    mapping(address => uint256) gauge_types_;\\n    mapping(address => mapping(address => VotedSlope)) public vote_user_slopes; // user -> gauge_addr -> VotedSlope\\n    mapping(address => uint256) public vote_user_power; // Total vote power used by user\\n    mapping(address => mapping(address => uint256)) public last_user_vote; // Last user vote's timestamp for each gauge address\\n\\n    // Past and scheduled points for gauge weight, sum of weights per type, total weight\\n    // Point is for bias+slope\\n    // changes_* are for changes in slope\\n    // time_* are for the last change timestamp\\n    // timestamps are rounded to whole weeks\\n\\n    mapping(address => mapping(uint256 => Point)) public points_weight; // gauge_addr -> time -> Point\\n    mapping(address => mapping(uint256 => uint256)) public changes_weight; // gauge_addr -> time -> slope\\n    mapping(address => uint256) public time_weight; // gauge_addr -> last scheduled time (next week)\\n\\n    mapping(uint256 => mapping(uint256 => Point)) public points_sum; // type_id -> time -> Point\\n    mapping(uint256 => mapping(uint256 => uint256)) public changes_sum; // type_id -> time -> slope\\n    uint256[1000000000] public time_sum; // type_id -> last scheduled time (next week)\\n\\n    mapping(uint256 => uint256) public points_total; // time -> total weight\\n    uint256 public time_total; // last scheduled time\\n\\n    mapping(uint256 => mapping(uint256 => uint256)) public points_type_weight; // type_id -> time -> type weight\\n    uint256[1000000000] public time_type_weight; // type_id -> last scheduled time (next week)\\n\\n\\n    IOwnership public immutable ownership;\\n\\n    modifier onlyOwner() {\\n        require(\\n            ownership.owner() == msg.sender,\\n            \\\"Caller is not allowed to operate\\\"\\n        );\\n        _;\\n    }\\n\\n    /***\\n     *@notice Contract constructor\\n     *@param _token `InsureToken` contract address\\n     *@param _voting_escrow `VotingEscrow` contract address\\n     */\\n    constructor(address _token, address _voting_escrow, address _ownership) {\\n        require(_token != address(0));\\n        require(_voting_escrow != address(0));\\n\\n        ownership = IOwnership(_ownership);\\n        token = IInsureToken(_token);\\n        voting_escrow = IVotingEscrow(_voting_escrow);\\n        time_total = (block.timestamp / WEEK) * WEEK;\\n    }\\n\\n    function get_voting_escrow() external view returns(address) {\\n        return address(voting_escrow);\\n    }\\n\\n    /***\\n     *@notice Get gauge type for address\\n     *@param _addr Gauge address\\n     *@return Gauge type id\\n     */\\n    function gauge_types(address _addr) external view returns(uint256) {\\n\\n        uint256 _gauge_type = gauge_types_[_addr];\\n\\n        return _gauge_type; //LG = 1\\n    }\\n\\n    /***\\n     *@notice Fill historic type weights week-over-week for missed checkins\\n     *        and return the type weight for the future week\\n     *@param _gauge_type Gauge type id\\n     *@return Type weight of next week\\n     */\\n    function _get_type_weight(uint256 _gauge_type) internal returns(uint256) {\\n\\n        require(_gauge_type != 0, \\\"unset\\\"); //s\\n        uint256 _t = time_type_weight[_gauge_type];\\n        if (_t > 0) {\\n            uint256 _w = points_type_weight[_gauge_type][_t];\\n            for (uint256 i; i < 500;) {\\n                if (_t > block.timestamp) {\\n                    break;\\n                }\\n                _t += WEEK;\\n                points_type_weight[_gauge_type][_t] = _w;\\n                if (_t > block.timestamp) {\\n                    time_type_weight[_gauge_type] = _t;\\n                }\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n            return _w;\\n        }\\n    }\\n\\n\\n    /***\\n     *@notice Fill sum of gauge weights for the same type week-over-week for\\n     *        missed checkins and return the sum for the future week\\n     *@param _gauge_type Gauge type id\\n     *@return Sum of weights\\n     */\\n    function _get_sum(uint256 _gauge_type) internal returns(uint256) {\\n\\n        require(_gauge_type != 0, \\\"unset\\\");\\n        uint256 _t = time_sum[_gauge_type];\\n        if (_t > 0) {\\n            Point memory _pt = points_sum[_gauge_type][_t];\\n            for (uint256 i; i < 500;) {\\n                if (_t > block.timestamp) {\\n                    break;\\n                }\\n                _t += WEEK;\\n                uint256 _d_bias = _pt.slope * WEEK;\\n                if (_pt.bias > _d_bias) {\\n                    _pt.bias -= _d_bias;\\n                    uint256 _d_slope = changes_sum[_gauge_type][_t];\\n                    _pt.slope -= _d_slope;\\n                } else {\\n                    _pt.bias = 0;\\n                    _pt.slope = 0;\\n                }\\n                points_sum[_gauge_type][_t] = _pt;\\n                if (_t > block.timestamp) {\\n                    time_sum[_gauge_type] = _t;\\n                }\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n            return _pt.bias;\\n        }\\n    }\\n\\n    /***\\n     *@notice Fill historic total weights week-over-week for missed checkins\\n     *        and return the total for the future week\\n     *@return Total weight\\n     */\\n    function _get_total() internal returns(uint256) {\\n\\n        uint256 _t = time_total;\\n        uint256 _n_gauge_types = n_gauge_types;\\n        if (_t > block.timestamp) {\\n            // If we have already checkpointed - still need to change the value\\n            _t -= WEEK;\\n        }\\n        uint256 _pt = points_total[_t];\\n\\n        for (uint256 _gauge_type = 1; _gauge_type < 100;) {\\n            if (_gauge_type == _n_gauge_types) {\\n                break;\\n            }\\n            _get_sum(_gauge_type);\\n            _get_type_weight(_gauge_type);\\n            unchecked {\\n                ++_gauge_type;\\n            }\\n        }\\n        for (uint256 i; i < 500;) {\\n            if (_t > block.timestamp) {\\n                break;\\n            }\\n            _t += WEEK;\\n            _pt = 0;\\n            // Scales as n_types * n_unchecked_weeks (hopefully 1 at most)\\n            for (uint256 _gauge_type = 1; _gauge_type < 100;) {\\n                if (_gauge_type == _n_gauge_types) {\\n                    break;\\n                }\\n                uint256 _type_sum = points_sum[_gauge_type][_t].bias;\\n                uint256 _type_weight = points_type_weight[_gauge_type][_t];\\n                _pt += _type_sum * _type_weight;\\n                unchecked {\\n                    ++_gauge_type;\\n                }\\n            }\\n            points_total[_t] = _pt;\\n\\n            if (_t > block.timestamp) {\\n                time_total = _t;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return _pt;\\n    }\\n\\n    /***\\n     *@notice Fill historic gauge weights week-over-week for missed checkins\\n     *        and return the total for the future week\\n     *@param _gauge_addr Address of the gauge\\n     *@return Gauge weight\\n     */\\n    function _get_weight(address _gauge_addr) internal returns(uint256) {\\n\\n        uint256 _t = time_weight[_gauge_addr];\\n        if (_t > 0) {\\n            Point memory _pt = points_weight[_gauge_addr][_t];\\n            for (uint256 i; i < 500;) {\\n                if (_t > block.timestamp) {\\n                    break;\\n                }\\n                _t += WEEK;\\n                uint256 _d_bias = _pt.slope * WEEK;\\n                if (_pt.bias > _d_bias) {\\n                    _pt.bias -= _d_bias;\\n                    uint256 _d_slope = changes_weight[_gauge_addr][_t];\\n                    _pt.slope -= _d_slope;\\n                } else {\\n                    _pt.bias = 0;\\n                    _pt.slope = 0;\\n                }\\n                points_weight[_gauge_addr][_t] = _pt;\\n                if (_t > block.timestamp) {\\n                    time_weight[_gauge_addr] = _t;\\n                }\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n            return _pt.bias;\\n        }\\n    }\\n\\n    /***\\n     *@notice Add gauge `addr` of type `gauge_type` with weight `weight`\\n     *@param _addr Gauge address\\n     *@param _gauge_type Gauge type\\n     *@param _weight Gauge weight\\n     */\\n    function add_gauge(\\n        address _addr,\\n        uint256 _gauge_type,\\n        uint256 _weight\\n    ) external onlyOwner {\\n        require((_gauge_type >= 1) && (_gauge_type < n_gauge_types)); //gauge_type 0 means unset\\n        require(\\n            gauge_types_[_addr] == 0,\\n            \\\"cannot add the same gauge twice\\\"\\n        ); //before adding, addr must be 0 in the mapping.\\n        uint256 _n = n_gauges;\\n        unchecked {\\n            n_gauges = _n + 1;\\n        }\\n        gauges[_n] = _addr;\\n\\n        gauge_types_[_addr] = _gauge_type;\\n        uint256 _next_time;\\n        unchecked {\\n            _next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\\n        }\\n\\n        if (_weight > 0) {\\n            uint256 _type_weight = _get_type_weight(_gauge_type);\\n            uint256 _old_sum = _get_sum(_gauge_type);\\n            uint256 _old_total = _get_total();\\n\\n            points_sum[_gauge_type][_next_time].bias = _weight + _old_sum;\\n            time_sum[_gauge_type] = _next_time;\\n            points_total[_next_time] = _old_total + (_type_weight * _weight);\\n            time_total = _next_time;\\n\\n            points_weight[_addr][_next_time].bias = _weight;\\n        }\\n        if (time_sum[_gauge_type] == 0) {\\n            time_sum[_gauge_type] = _next_time;\\n        }\\n        time_weight[_addr] = _next_time;\\n\\n        emit NewGauge(_addr, _gauge_type, _weight);\\n    }\\n\\n    /***\\n     * @notice Checkpoint to fill data common for all gauges\\n     */\\n    function checkpoint() external {\\n\\n        _get_total();\\n    }\\n\\n    /***\\n     *@notice Checkpoint to fill data for both a specific gauge and common for all gauges\\n     *@param _addr Gauge address\\n     */\\n    function checkpoint_gauge(address _addr) external {\\n\\n        _get_weight(_addr);\\n        _get_total();\\n    }\\n\\n    /***\\n     *@notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\\n     *        (e.g. 1.0 == 1e18). Inflation which will be received by it is\\n     *       inflation_rate * relative_weight / 1e18\\n     *@param _addr Gauge address\\n     *@param _time Relative weight at the specified timestamp in the past or present\\n     *@return Value of relative weight normalized to 1e18\\n     */\\n    function _gauge_relative_weight(address _addr, uint256 _time)\\n    internal\\n    view\\n    returns(uint256) {\\n\\n        uint256 _t = (_time / WEEK) * WEEK;\\n        uint256 _total_weight = points_total[_t];\\n\\n        if (_total_weight > 0) {\\n            uint256 _gauge_type = gauge_types_[_addr];\\n            uint256 _type_weight = points_type_weight[_gauge_type][_t];\\n            uint256 _gauge_weight = points_weight[_addr][_t].bias;\\n\\n            return (MULTIPLIER * _type_weight * _gauge_weight) / _total_weight;\\n        }\\n    }\\n\\n    /***\\n     *@notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\\n     *        (e.g. 1.0 == 1e18). Inflation which will be received by it is\\n     *        inflation_rate * relative_weight / 1e18\\n     *@param _addr Gauge address\\n     *@param _time Relative weight at the specified timestamp in the past or present\\n     *@return Value of relative weight normalized to 1e18\\n     */\\n    function gauge_relative_weight(address _addr, uint256 _time)\\n    external\\n    view\\n    returns(uint256) {\\n        //default value\\n        if (_time == 0) {\\n            _time = block.timestamp;\\n        }\\n\\n        return _gauge_relative_weight(_addr, _time);\\n    }\\n\\n    function gauge_relative_weight_write(address _addr, uint256 _time)\\n    external\\n    returns(uint256) {\\n        //default value\\n        if (_time == 0) {\\n            _time = block.timestamp;\\n        }\\n\\n        _get_weight(_addr);\\n        _get_total(); // Also calculates get_sum\\n        return _gauge_relative_weight(_addr, _time);\\n    }\\n\\n    /***\\n     *@notice Change type weight\\n     *@param _type_id Type id\\n     *@param _weight New type weight\\n     */\\n    function _change_type_weight(uint256 _type_id, uint256 _weight) internal {\\n        uint256 _old_weight = _get_type_weight(_type_id);\\n        uint256 _old_sum = _get_sum(_type_id);\\n        uint256 _total_weight = _get_total();\\n        uint256 _next_time;\\n        unchecked {\\n            _next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\\n        }\\n\\n        _total_weight =\\n            _total_weight +\\n            (_old_sum * _weight) -\\n            (_old_sum * _old_weight);\\n        points_total[_next_time] = _total_weight;\\n        points_type_weight[_type_id][_next_time] = _weight;\\n        time_total = _next_time;\\n        time_type_weight[_type_id] = _next_time;\\n\\n        emit NewTypeWeight(_type_id, _next_time, _weight, _total_weight);\\n    }\\n\\n    /***\\n     *@notice Add gauge type with name `_name` and weight `weight`\u3000//ex. type=1, Liquidity, 1*1e18\\n     *@param _name Name of gauge type\\n     *@param _weight Weight of gauge type\\n     */\\n    function add_type(string memory _name, uint256 _weight) external onlyOwner {\\n\\n        uint256 _type_id = n_gauge_types;\\n        gauge_type_names[_type_id] = _name;\\n        unchecked {\\n            n_gauge_types = _type_id + 1;\\n        }\\n        if (_weight != 0) {\\n            _change_type_weight(_type_id, _weight);\\n            emit AddType(_name, _type_id);\\n        }\\n    }\\n\\n    /***\\n     *@notice Change gauge type `type_id` weight to `weight`\\n     *@param _type_id Gauge type id\\n     *@param _weight New Gauge weight\\n     */\\n    function change_type_weight(uint256 _type_id, uint256 _weight) external onlyOwner {\\n\\n        _change_type_weight(_type_id, _weight);\\n    }\\n\\n    function _change_gauge_weight(address _addr, uint256 _weight) internal {\\n        // Change gauge weight\\n        // Only needed when testing in reality\\n        uint256 _gauge_type = gauge_types_[_addr];\\n        uint256 _old_gauge_weight = _get_weight(_addr);\\n        uint256 _type_weight = _get_type_weight(_gauge_type);\\n        uint256 _old_sum = _get_sum(_gauge_type);\\n        uint256 _total_weight = _get_total();\\n        uint256 _next_time;\\n        unchecked {\\n            _next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\\n        }\\n\\n        points_weight[_addr][_next_time].bias = _weight;\\n        time_weight[_addr] = _next_time;\\n\\n        uint256 new_sum = _old_sum + _weight - _old_gauge_weight;\\n        points_sum[_gauge_type][_next_time].bias = new_sum;\\n        time_sum[_gauge_type] = _next_time;\\n\\n        _total_weight =\\n            _total_weight +\\n            (new_sum * _type_weight) -\\n            (_old_sum * _type_weight);\\n        points_total[_next_time] = _total_weight;\\n        time_total = _next_time;\\n\\n        emit NewGaugeWeight(_addr, block.timestamp, _weight, _total_weight);\\n    }\\n\\n    /***\\n     *@notice Change weight of gauge `addr` to `weight`\\n     *@param _addr `GaugeController` contract address\\n     *@param _weight New Gauge weight\\n     */\\n    function change_gauge_weight(address _addr, uint256 _weight) external onlyOwner {\\n\\n        _change_gauge_weight(_addr, _weight);\\n    }\\n\\n    struct VotingParameter {\\n        //to avoid \\\"Stack too deep\\\" issue\\n        uint256 slope;\\n        uint256 lock_end;\\n        uint256 _n_gauges;\\n        uint256 next_time;\\n        uint256 gauge_type;\\n        uint256 old_dt;\\n        uint256 old_bias;\\n    }\\n\\n    /****\\n     *@notice Allocate voting power for changing pool weights\\n     *@param _gauge_addr Gauge which `msg.sender` votes for\\n     *@param _user_weight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0. bps = basis points\\n     */\\n    function vote_for_gauge_weights(address _gauge_addr, uint256 _user_weight) external {\\n        VotingParameter memory _vp;\\n        _vp.slope = uint256(voting_escrow.get_last_user_slope(msg.sender));\\n        _vp.lock_end = voting_escrow.locked__end(msg.sender);\\n        _vp._n_gauges = n_gauges;\\n        unchecked {\\n            _vp.next_time = ((block.timestamp + WEEK) / WEEK) * WEEK;\\n        }\\n        require(\\n            _vp.lock_end > _vp.next_time,\\n            \\\"Your token lock expires too soon\\\"\\n        );\\n        require(\\n            (_user_weight >= 0) && (_user_weight <= 10000),\\n            \\\"You used all your voting power\\\"\\n        );\\n        uint256 _voteTime;\\n        unchecked {\\n            require(\\n                block.timestamp >= last_user_vote[msg.sender][_gauge_addr] + WEIGHT_VOTE_DELAY,\\n                \\\"Cannot vote so often\\\"\\n            );\\n        }\\n\\n        _vp.gauge_type = gauge_types_[_gauge_addr];\\n        require(_vp.gauge_type >= 1, \\\"Gauge not added\\\");\\n        // Prepare slopes and biases in memory\\n        VotedSlope memory _old_slope = vote_user_slopes[msg.sender][\\n            _gauge_addr\\n        ];\\n        _vp.old_dt = 0;\\n        if (_old_slope.end > _vp.next_time) {\\n            _vp.old_dt = _old_slope.end - _vp.next_time;\\n        }\\n        _vp.old_bias = _old_slope.slope * _vp.old_dt;\\n        VotedSlope memory _new_slope = VotedSlope({\\n            slope: (_vp.slope * _user_weight) / 10000,\\n            power: _user_weight,\\n            end: _vp.lock_end\\n        });\\n        uint256 _new_dt = _vp.lock_end - _vp.next_time; // dev: raises when expired\\n        uint256 _new_bias = _new_slope.slope * _new_dt;\\n\\n        // Check and update powers (weights) used\\n        uint256 _power_used = vote_user_power[msg.sender];\\n        _power_used = _power_used + _new_slope.power - _old_slope.power;\\n        vote_user_power[msg.sender] = _power_used;\\n        require(\\n            (_power_used >= 0) && (_power_used <= 10000),\\n            \\\"Used too much power\\\"\\n        );\\n\\n        //// Remove old and schedule new slope changes\\n        // Remove slope changes for old slopes\\n        // Schedule recording of initial slope for next_time\\n        uint256 _old_weight_bias = _get_weight(_gauge_addr);\\n        uint256 _old_weight_slope = points_weight[_gauge_addr][_vp.next_time]\\n            .slope;\\n        uint256 _old_sum_bias = _get_sum(_vp.gauge_type);\\n        uint256 _old_sum_slope = points_sum[_vp.gauge_type][_vp.next_time]\\n            .slope;\\n\\n        points_weight[_gauge_addr][_vp.next_time].bias =\\n            max(_old_weight_bias + _new_bias, _vp.old_bias) -\\n            _vp.old_bias;\\n        points_sum[_vp.gauge_type][_vp.next_time].bias =\\n            max(_old_sum_bias + _new_bias, _vp.old_bias) -\\n            _vp.old_bias;\\n        if (_old_slope.end > _vp.next_time) {\\n            points_weight[_gauge_addr][_vp.next_time].slope =\\n                max(_old_weight_slope + _new_slope.slope, _old_slope.slope) -\\n                _old_slope.slope;\\n            points_sum[_vp.gauge_type][_vp.next_time].slope =\\n                max(_old_sum_slope + _new_slope.slope, _old_slope.slope) -\\n                _old_slope.slope;\\n        } else {\\n            points_weight[_gauge_addr][_vp.next_time].slope += _new_slope.slope;\\n            points_sum[_vp.gauge_type][_vp.next_time].slope += _new_slope.slope;\\n        }\\n        if (_old_slope.end > block.timestamp) {\\n            // Cancel old slope changes if they still didn't happen\\n            changes_weight[_gauge_addr][_old_slope.end] -= _old_slope.slope;\\n            changes_sum[_vp.gauge_type][_old_slope.end] -= _old_slope.slope;\\n        }\\n        // Add slope changes for new slopes\\n        changes_weight[_gauge_addr][_new_slope.end] += _new_slope.slope;\\n        changes_sum[_vp.gauge_type][_new_slope.end] += _new_slope.slope;\\n\\n        _get_total();\\n\\n        vote_user_slopes[msg.sender][_gauge_addr] = _new_slope;\\n\\n        // Record last action time\\n        last_user_vote[msg.sender][_gauge_addr] = block.timestamp;\\n\\n        emit VoteForGauge(\\n            block.timestamp,\\n            msg.sender,\\n            _gauge_addr,\\n            _user_weight\\n        );\\n    }\\n\\n    /***\\n     *@notice Get current gauge weight\\n     *@param _addr Gauge address\\n     *@return Gauge weight\\n     */\\n    function get_gauge_weight(address _addr) external view returns(uint256) {\\n        return points_weight[_addr][time_weight[_addr]].bias;\\n    }\\n\\n    /***\\n     *@notice Get current type weight\\n     *@param _type_id Type id\\n     *@return Type weight\\n     */\\n    function get_type_weight(uint256 _type_id) external view returns(uint256) {\\n\\n        return points_type_weight[_type_id][time_type_weight[_type_id]];\\n    }\\n\\n    /***\\n     *@notice Get current total (type-weighted) weight\\n     *@return Total weight\\n     */\\n    function get_total_weight() external view returns(uint256) {\\n        return points_total[time_total];\\n    }\\n\\n    /***\\n     *@notice Get sum of gauge weights per type\\n     *@param _type_id Type id\\n     *@return Sum of gauge weights\\n     */\\n    function get_weights_sum_per_type(uint256 _type_id) external view returns(uint256) {\\n        return points_sum[_type_id][time_sum[_type_id]].bias;\\n    }\\n\\n    function max(uint256 _a, uint256 _b) internal pure returns(uint256) {\\n        return _a >= _b ? _a : _b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/dao/IInsureToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\ninterface IInsureToken {\\n    function mint(address _to, uint256 _value)external returns(bool);\\n    function emergency_mint(uint256 _amountOut, address _to)external;\\n    function approve(address _spender, uint256 _value)external;\\n    function rate()external view returns(uint256);\\n    function future_epoch_time_write() external returns(uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/dao/IVotingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\ninterface IVotingEscrow {\\n    function get_last_user_slope(address _addr) external view returns (uint256);\\n\\n    function locked__end(address _addr) external view returns (uint256);\\n\\n    function balanceOf(address _addr, uint256 _t)\\n        external\\n        view\\n        returns (uint256);\\n\\n    //function balanceOf(address addr)external view returns (uint256);\\n    function totalSupply(uint256 _t) external view returns (uint256);\\n\\n    function get_user_point_epoch(address _user)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function user_point_history__ts(address _addr, uint256 _idx)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/pool/IOwnership.sol\": {\r\n      \"content\": \"pragma solidity 0.8.10;\\n\\n//SPDX-License-Identifier: MIT\\n\\ninterface IOwnership {\\n    function owner() external view returns (address);\\n\\n    function futureOwner() external view returns (address);\\n\\n    function commitTransferOwnership(address newOwner) external;\\n\\n    function acceptTransferOwnership() external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_voting_escrow\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ownership\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"type_id\",\"type\":\"uint256\"}],\"name\":\"AddType\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gauge_type\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"NewGauge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gauge_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total_weight\",\"type\":\"uint256\"}],\"name\":\"NewGaugeWeight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"type_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total_weight\",\"type\":\"uint256\"}],\"name\":\"NewTypeWeight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gauge_addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"VoteForGauge\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gauge_type\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"name\":\"add_gauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"name\":\"add_type\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"name\":\"change_gauge_weight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_type_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_weight\",\"type\":\"uint256\"}],\"name\":\"change_type_weight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"changes_sum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"changes_weight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkpoint_gauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"gauge_relative_weight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"gauge_relative_weight_write\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gauge_type_names\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"gauge_types\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gauges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"get_gauge_weight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_total_weight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_type_id\",\"type\":\"uint256\"}],\"name\":\"get_type_weight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_voting_escrow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_type_id\",\"type\":\"uint256\"}],\"name\":\"get_weights_sum_per_type\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"last_user_vote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"n_gauge_types\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"n_gauges\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownership\",\"outputs\":[{\"internalType\":\"contract IOwnership\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"points_sum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bias\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slope\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"points_total\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"points_type_weight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"points_weight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bias\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slope\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"time_sum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"time_total\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"time_type_weight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"time_weight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IInsureToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_user_weight\",\"type\":\"uint256\"}],\"name\":\"vote_for_gauge_weights\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vote_user_power\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vote_user_slopes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"slope\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"power\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voting_escrow\",\"outputs\":[{\"internalType\":\"contract IVotingEscrow\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GaugeController", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d83ae04c9ed29d6d3e6bf720c71bc7beb424393e0000000000000000000000003dc07e60ecb3d064d20c386217ceef8e3905916b00000000000000000000000056246e83f3148b05ce2d90b44fbb4e9fa9eaf5bb", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}