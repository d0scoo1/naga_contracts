{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// The line above is recommended and let you define the license of your contract\\n// Solidity files have to start with this pragma.\\n// It will be used by the Solidity compiler to validate its version.\\npragma solidity ^0.8.0;\\nimport \\\"./IRegistry.sol\\\";\\nimport \\\"./ISmartAccount.sol\\\";\\nimport \\\"./IPortal.sol\\\";\\nimport \\\"./socket/ISocketRegistry.sol\\\";\\n\\ninterface IConfig {\\n    function portal() external view returns (IPortal);\\n\\n    function smartAccountFactory() external view returns (ISmartAccountFactory);\\n\\n    function registry() external view returns (IRegistry);\\n\\n    function socketRegistry() external view returns (ISocketRegistry);\\n\\n    function setPortal(IPortal p) external;\\n\\n    function setRegistry(IRegistry p) external;\\n\\n    function setSocketRegistry(ISocketRegistry s) external;\\n\\n    function setSmartAccountFactory(ISmartAccountFactory b) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// The line above is recommended and let you define the license of your contract\\n// Solidity files have to start with this pragma.\\n// It will be used by the Solidity compiler to validate its version.\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"./IConfig.sol\\\";\\nimport \\\"./IInvestable.sol\\\";\\n\\ninterface IFarm is IInvestable {\\n    event TokenDeployed(\\n        address indexed onBehalfOf,\\n        IERC20MetadataUpgradeable indexed underlying,\\n        uint256 amount\\n    );\\n    event NativeDeployed(address indexed onBehalfOf, uint256 amount);\\n    event TokenWithdrawn(\\n        address indexed onBehalfOf,\\n        IERC20MetadataUpgradeable indexed underlying,\\n        uint256 amount\\n    );\\n    event NativeWithdrawn(address indexed onBehalfOf, uint256 amount);\\n    struct PositionToken {\\n        UnderlyingAsset underlying;\\n        address positionToken;\\n    }\\n\\n    function getUnderlyingSupported()\\n        external\\n        view\\n        returns (UnderlyingAsset[] memory);\\n\\n    function positionToken(IERC20MetadataUpgradeable underlying)\\n        external\\n        view\\n        returns (address);\\n\\n    function underlyingSupported(uint256 index)\\n        external\\n        view\\n        returns (\\n            bytes11 name,\\n            uint8 decimals,\\n            IERC20MetadataUpgradeable underlying\\n        );\\n\\n    function config() external view returns (IConfig);\\n\\n    function deployNative() external payable;\\n\\n    function deployToken(\\n        uint256 amountIn18,\\n        IERC20MetadataUpgradeable underlying\\n    ) external;\\n\\n    function deployTokenAll(IERC20MetadataUpgradeable underlying) external;\\n\\n    function withdrawNative() external payable;\\n\\n    function withdrawTokenAll(IERC20MetadataUpgradeable underlying) external;\\n\\n    function withdrawToken(\\n        IERC20MetadataUpgradeable underlying,\\n        uint256 underlyingAmount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IInvestable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// The line above is recommended and let you define the license of your contract\\n// Solidity files have to start with this pragma.\\n// It will be used by the Solidity compiler to validate its version.\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"./IConfig.sol\\\";\\n\\ninterface IInvestable {\\n    struct UnderlyingAsset {\\n        bytes11 name;\\n        uint8 decimals;\\n        IERC20MetadataUpgradeable token;\\n    }\\n    struct Position {\\n        UnderlyingAsset underlying;\\n        uint256 amount;\\n    }\\n\\n    function position(address user) external view returns (Position[] memory);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IPortal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// The line above is recommended and let you define the license of your contract\\n// Solidity files have to start with this pragma.\\n// It will be used by the Solidity compiler to validate its version.\\npragma solidity ^0.8.0;\\nimport \\\"./socket/ISocketRegistry.sol\\\";\\nimport \\\"./IConfig.sol\\\";\\nimport \\\"./ISmartAccount.sol\\\";\\n\\ninterface IPortal {\\n    event Outbound(\\n        uint256 indexed toChainId,\\n        address indexed receiverAddress,\\n        ISocketRegistry.UserRequest request,\\n        ISmartAccount.ExecuteParams execParam,\\n        uint256 toAmount\\n    );\\n\\n    function config() external view returns (IConfig);\\n\\n    function outboundERC20TransferTo(\\n        ISocketRegistry.UserRequest calldata b,\\n        ISmartAccount.ExecuteParams calldata execParams,\\n        uint256 toAmount\\n    ) external;\\n\\n    function outboundNativeTransferTo(\\n        ISocketRegistry.UserRequest calldata b,\\n        ISmartAccount.ExecuteParams calldata execParams\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// The line above is recommended and let you define the license of your contract\\n// Solidity files have to start with this pragma.\\n// It will be used by the Solidity compiler to validate its version.\\npragma solidity ^0.8.0;\\nimport \\\"./IConfig.sol\\\";\\nimport \\\"./IInvestable.sol\\\";\\n\\ninterface IRegistry {\\n    enum IntegrationType {\\n        Bridge,\\n        Farm\\n    }\\n\\n    struct Integration {\\n        bytes11 name;\\n        IntegrationType integrationType;\\n        address integration;\\n    }\\n\\n    struct AccountPosition {\\n        IRegistry.Integration integration;\\n        IInvestable.Position[] position;\\n    }\\n\\n    function config() external view returns (IConfig);\\n\\n    function getIntegrations(uint256)\\n        external\\n        view\\n        returns (Integration[] memory);\\n\\n    function registerIntegrations(Integration[] memory input, uint256 chainId)\\n        external;\\n\\n    function unregisterIntegrations(Integration[] memory dest, uint256 chainId)\\n        external;\\n\\n    function portfolio(address user, uint256 chainId)\\n        external\\n        view\\n        returns (AccountPosition[] memory result);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISmartAccount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// The line above is recommended and let you define the license of your contract\\n// Solidity files have to start with this pragma.\\n// It will be used by the Solidity compiler to validate its version.\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"./IConfig.sol\\\";\\nimport \\\"./IRegistry.sol\\\";\\nimport \\\"./IFarm.sol\\\";\\n\\ninterface ISmartAccountFactory {\\n    function beacon() external view returns (IBeaconUpgradeable);\\n\\n    function config() external view returns (IConfig);\\n\\n    function smartAccount(address user) external view returns (ISmartAccount);\\n\\n    function precomputeAddress(address user) external view returns (address);\\n\\n    function createSmartAccount(address user) external;\\n}\\n\\ninterface ISmartAccount {\\n    struct ExecuteParams {\\n        uint256 executeChainId;\\n        bytes32 nonce;\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        Operation[] operations;\\n    }\\n    struct Operation {\\n        address integration;\\n        address token;\\n        bytes data;\\n    }\\n    event TokenWithdrawn(\\n        IERC20MetadataUpgradeable indexed token,\\n        address indexed to,\\n        uint256 amount\\n    );\\n\\n    event NativeWithdrawn(address indexed to, uint256 amount);\\n\\n    function config() external view returns (IConfig);\\n\\n    function withdrawToken(IERC20MetadataUpgradeable token, uint256 amountIn18)\\n        external;\\n\\n    function withdrawNative(uint256 amountIn18) external;\\n\\n    function execute(ExecuteParams calldata x) external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/socket/ISocketRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n// @title Movr Regisrtry Contract.\\n// @notice This is the main contract that is called using fund movr.\\n// This contains all the bridge and middleware ids.\\n// RouteIds signify which bridge to be used.\\n// Middleware Id signifies which aggregator will be used for swapping if required.\\n*/\\ninterface ISocketRegistry {\\n    ///@notice RouteData stores information for a route\\n    struct RouteData {\\n        address route;\\n        bool isEnabled;\\n        bool isMiddleware;\\n    }\\n\\n    function routes(uint256) external view returns (RouteData memory);\\n\\n    //\\n    // Events\\n    //\\n    event NewRouteAdded(\\n        uint256 routeID,\\n        address route,\\n        bool isEnabled,\\n        bool isMiddleware\\n    );\\n    event RouteDisabled(uint256 routeID);\\n    event ExecutionCompleted(\\n        uint256 middlewareID,\\n        uint256 bridgeID,\\n        uint256 inputAmount\\n    );\\n\\n    /**\\n    // @param id route id of middleware to be used\\n    // @param optionalNativeAmount is the amount of native asset that the route requires\\n    // @param inputToken token address which will be swapped to\\n    // BridgeRequest inputToken\\n    // @param data to be used by middleware\\n    */\\n    struct MiddlewareRequest {\\n        uint256 id;\\n        uint256 optionalNativeAmount;\\n        address inputToken;\\n        bytes data;\\n    }\\n\\n    /**\\n    // @param id route id of bridge to be used\\n    // @param optionalNativeAmount optinal native amount, to be used\\n    // when bridge needs native token along with ERC20\\n    // @param inputToken token addresss which will be bridged\\n    // @param data bridgeData to be used by bridge\\n    */\\n    struct BridgeRequest {\\n        uint256 id;\\n        uint256 optionalNativeAmount;\\n        address inputToken;\\n        bytes data;\\n    }\\n\\n    /**\\n    // @param receiverAddress Recipient address to recieve funds on destination chain\\n    // @param toChainId Destination ChainId\\n    // @param amount amount to be swapped if middlewareId is 0  it will be\\n    // the amount to be bridged\\n    // @param middlewareRequest middleware Requestdata\\n    // @param bridgeRequest bridge request data\\n    */\\n    struct UserRequest {\\n        address receiverAddress;\\n        uint256 toChainId;\\n        uint256 amount;\\n        MiddlewareRequest middlewareRequest;\\n        BridgeRequest bridgeRequest;\\n    }\\n\\n    /**\\n    // @notice function responsible for calling the respective implementation\\n    // depending on the bridge to be used\\n    // If the middlewareId is 0 then no swap is required,\\n    // we can directly bridge the source token to wherever required,\\n    // else, we first call the Swap Impl Base for swapping to the required\\n    // token and then start the bridging\\n    // @dev It is required for isMiddleWare to be true for route 0 as it is a special case\\n    // @param _userRequest calldata follows the input data struct\\n    */\\n    function outboundTransferTo(UserRequest calldata _userRequest)\\n        external\\n        payable;\\n}\\n\"\r\n    },\r\n    \"src/libraries/XCC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// The line above is recommended and let you define the license of your contract\\n// Solidity files have to start with this pragma.\\n// It will be used by the Solidity compiler to validate its version.\\n\\npragma solidity ^0.8.0;\\nimport \\\"../interfaces/IRegistry.sol\\\";\\n\\nlibrary XCC {\\n    function findIntegration(\\n        IRegistry.Integration[] memory s,\\n        address integration\\n    )\\n        public\\n        pure\\n        returns (\\n            bool exist,\\n            uint8 index,\\n            IRegistry.Integration memory ypltfm\\n        )\\n    {\\n        uint256 len = s.length;\\n        require(len < type(uint8).max, \\\"XCC1\\\");\\n        require(integration != address(0), \\\"XCC2\\\");\\n        if (len > 0) {\\n            for (uint8 i; i < len; i++) {\\n                // load to memory\\n                IRegistry.Integration memory temp = s[i];\\n                if (temp.integration == integration) {\\n                    exist = true;\\n                    index = i;\\n                    ypltfm = temp;\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"bytes11\",\"name\":\"name\",\"type\":\"bytes11\"},{\"internalType\":\"enum IRegistry.IntegrationType\",\"name\":\"integrationType\",\"type\":\"IRegistry.IntegrationType\"},{\"internalType\":\"address\",\"name\":\"integration\",\"type\":\"address\"}],\"internalType\":\"struct IRegistry.Integration[]\",\"name\":\"s\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"integration\",\"type\":\"address\"}],\"name\":\"findIntegration\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exist\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"bytes11\",\"name\":\"name\",\"type\":\"bytes11\"},{\"internalType\":\"enum IRegistry.IntegrationType\",\"name\":\"integrationType\",\"type\":\"IRegistry.IntegrationType\"},{\"internalType\":\"address\",\"name\":\"integration\",\"type\":\"address\"}],\"internalType\":\"struct IRegistry.Integration\",\"name\":\"ypltfm\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "XCC", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}