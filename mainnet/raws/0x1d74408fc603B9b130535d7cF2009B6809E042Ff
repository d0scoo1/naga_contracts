{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"VeToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"IERC20.sol\\\";\\n\\nimport \\\"SafeOwnable.sol\\\";\\nimport \\\"Math.sol\\\";\\nimport \\\"ReentrancyGuard.sol\\\";\\nimport \\\"AddressLibrary.sol\\\";\\n\\n// veWILD is a non-transferrable governance token minted by locking up WILD\\n// The longer the lock period, the higher the reward\\n// 1 veWILD = WILD locked for 4 years\\n\\ncontract VeToken is SafeOwnable, ReentrancyGuard {\\n\\n  using AddressLibrary for address;\\n\\n  uint private constant MIN_LOCK_PERIOD = 1 weeks;\\n  uint private constant MAX_LOCK_PERIOD = 1460 days; // 4 years\\n  uint private constant WITHDRAW_DELAY  = 1 days;\\n\\n  mapping (address => uint) public balanceOf; // veBalanceOf\\n  mapping (address => uint) public lockedBalanceOf;\\n  mapping (address => uint) public lockedUntil;\\n  mapping (address => uint) public rewardSnapshot;\\n  mapping (address => uint) public withdrawAt;\\n\\n  string public constant name     = 'veWILD';\\n  string public constant symbol   = 'veWILD';\\n  uint8  public constant decimals = 18;\\n  uint   public totalSupply;\\n  uint   public totalLocked;\\n  uint   public distributionPeriod;\\n\\n  address public  lockedToken;     // WILD\\n  uint    public  lastAccrueBlock;\\n  uint    public  lastIncomeBlock;\\n  uint    public  rewardPerToken;  // Reward per veToken. Increases over time.\\n  uint    private rewardRateStored;\\n\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  event Lock            (address indexed account, uint lockedBalance, uint veBalance, uint lockedUntil);\\n  event WithdrawRequest (address indexed account, uint amount, uint withdrawAt);\\n  event Withdraw        (address indexed account, uint amount);\\n  event Claim           (address indexed account, uint veBalance, uint claimAmount);\\n  event NewIncome       (uint addAmount, uint remainingAmount, uint rewardRate);\\n  event NewDistributionPeriod(uint value);\\n\\n  function initialize(address _lockedToken, uint _distributionPeriod) external {\\n    require(lockedToken == address(0), \\\"VeToken: already initialized\\\");\\n\\n    lockedToken     = _lockedToken;\\n    lastAccrueBlock = block.number;\\n    _setDistributionPeriod(_distributionPeriod);\\n\\n    owner = msg.sender;\\n    emit OwnershipTransferConfirmed(address(0), msg.sender);\\n  }\\n\\n  function lock(uint _amount, uint _newLockedUntil) external nonReentrant {\\n    uint lockSeconds = _newLockedUntil - block.timestamp;\\n\\n    require(lockSeconds >= MIN_LOCK_PERIOD, \\\"VeToken: lock time too short\\\");\\n    require(lockSeconds <= MAX_LOCK_PERIOD, \\\"VeToken: lock time too long\\\");\\n    require(_newLockedUntil >= lockedUntil[msg.sender], \\\"VeToken: cannot reduce locked time\\\");\\n    require(!msg.sender.isContract(), \\\"VeToken: contract calls not allowed\\\");\\n\\n    _claim();\\n\\n    if (_amount > 0) {\\n      lockedBalanceOf[msg.sender] += _amount;\\n      totalLocked += _amount;\\n      IERC20(lockedToken).transferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    _updateLock(msg.sender, _newLockedUntil);\\n    _checkReserves();\\n\\n    // TODO: 5M total locked WILD limit. remove after the initial test period\\n    require(totalLocked < 5000000e18, \\\"lock limit reached\\\");\\n\\n    emit Lock(msg.sender, lockedBalanceOf[msg.sender], balanceOf[msg.sender], _newLockedUntil);\\n  }\\n\\n  function requestWithdraw() external nonReentrant {\\n    uint withdrawAmount = lockedBalanceOf[msg.sender];\\n\\n    require(withdrawAmount > 0, \\\"VeToken: nothing to withdraw\\\");\\n    require(block.timestamp > lockedUntil[msg.sender], \\\"VeToken: cannot withdraw before unlock\\\");\\n\\n    _claim();\\n    withdrawAt[msg.sender] = block.timestamp + WITHDRAW_DELAY;\\n\\n    emit WithdrawRequest(msg.sender, withdrawAmount, withdrawAt[msg.sender]);\\n  }\\n\\n  function withdraw() external nonReentrant {\\n    uint withdrawTime = withdrawAt[msg.sender];\\n    uint withdrawAmount = lockedBalanceOf[msg.sender];\\n\\n    require(withdrawTime > 0 && withdrawTime <= block.timestamp, \\\"VeToken: withdraw delay not over\\\");\\n\\n    withdrawAt[msg.sender] = 0;\\n\\n    totalLocked -= withdrawAmount;\\n    lockedBalanceOf[msg.sender] = 0;\\n    _setBalance(msg.sender, 0);\\n\\n    IERC20(lockedToken).transfer(msg.sender, withdrawAmount);\\n    _checkReserves();\\n\\n    emit Withdraw(msg.sender, withdrawAmount);\\n  }\\n\\n  // Claiming resets veWILD balance based on locked WILD and lock time remaining.\\n  function claim() external nonReentrant {\\n    _claim();\\n    _checkReserves();\\n  }\\n\\n  // Update rewardRateStored to distribute previous unvested income + new income\\n  // over the next distributionPeriod blocks\\n  function addIncome(uint _addAmount) external nonReentrant {\\n    _accrue();\\n    IERC20(lockedToken).transferFrom(msg.sender, address(this), _addAmount);\\n\\n    uint unvestedIncome = _updateRewardRate(_addAmount, distributionPeriod);\\n    _checkReserves();\\n\\n    emit NewIncome(_addAmount, unvestedIncome, rewardRateStored);\\n  }\\n\\n  function setDistributionPeriod(uint _blocks) external onlyOwner {\\n    _setDistributionPeriod(_blocks);\\n  }\\n\\n  // If no new income is added for more than distributionPeriod blocks,\\n  // then do not distribute any more rewards\\n  function rewardRate() public view returns(uint) {\\n    uint blocksElapsed = block.number - lastIncomeBlock;\\n\\n    if (blocksElapsed < distributionPeriod) {\\n      return rewardRateStored;\\n    } else {\\n      return 0;\\n    }\\n  }\\n\\n  function pendingAccountReward(address _account) public view returns(uint) {\\n    uint pedingRewardPerToken = rewardPerToken + _pendingRewardPerToken();\\n    uint rewardPerTokenDelta  = pedingRewardPerToken - rewardSnapshot[_account];\\n    return rewardPerTokenDelta * balanceOf[_account] / 1e18;\\n  }\\n\\n  function _claim() internal {\\n    _accrue();\\n    uint pendingReward = pendingAccountReward(msg.sender);\\n\\n    if(pendingReward > 0) {\\n      IERC20(lockedToken).transfer(msg.sender, pendingReward);\\n    }\\n\\n    rewardSnapshot[msg.sender] = rewardPerToken;\\n    _updateLock(msg.sender, lockedUntil[msg.sender]);\\n\\n    emit Claim(msg.sender, balanceOf[msg.sender], pendingReward);\\n  }\\n\\n  function _accrue() internal {\\n    rewardPerToken += _pendingRewardPerToken();\\n    lastAccrueBlock = block.number;\\n  }\\n\\n  function _setDistributionPeriod(uint _blocks) internal {\\n    require(_blocks > 0, \\\"VeToken: distribution period must be >= 100 blocks\\\");\\n    _accrue();\\n    _updateRewardRate(0, _blocks);\\n    emit NewDistributionPeriod(_blocks);\\n  }\\n\\n  function _updateRewardRate(uint _addAmount, uint _newDistributionPeriod) internal returns(uint) {\\n    // Avoid inflation of blocksElapsed inside of _pendingRewardPerToken()\\n    // Ensures _pendingRewardPerToken() is 0 and all rewards are accounted for\\n    require(block.number == lastAccrueBlock, \\\"VeToken: accrue first\\\");\\n\\n    uint blocksElapsed  = Math.min(distributionPeriod, block.number - lastIncomeBlock);\\n    uint unvestedIncome = rewardRateStored * (distributionPeriod - blocksElapsed);\\n\\n    rewardRateStored   = (unvestedIncome + _addAmount) / _newDistributionPeriod;\\n    distributionPeriod = _newDistributionPeriod;\\n    lastIncomeBlock    = block.number;\\n\\n    return unvestedIncome;\\n  }\\n\\n  function _updateLock(address _account, uint _newLockedUntil) internal {\\n    uint lockSeconds = _newLockedUntil > block.timestamp ? _newLockedUntil - block.timestamp : 0;\\n    uint newBalance = (lockedBalanceOf[_account] * lockSeconds) / MAX_LOCK_PERIOD;\\n    lockedUntil[msg.sender] = _newLockedUntil;\\n    _setBalance(_account, newBalance);\\n  }\\n\\n  function _setBalance(address _account, uint _amount) internal {\\n    // Balance must be updated after claiming as it's used to calculate pending rewards\\n    require(rewardSnapshot[msg.sender] == rewardPerToken, \\\"VeToken: claim first\\\");\\n\\n    if (balanceOf[_account] > _amount) {\\n      _burn(_account, balanceOf[_account] - _amount);\\n    } else if (balanceOf[_account] < _amount) {\\n      _mint(_account, _amount - balanceOf[_account]);\\n    }\\n  }\\n\\n  function _mint(address _account, uint _amount) internal {\\n    balanceOf[_account] += _amount;\\n    totalSupply += _amount;\\n    emit Transfer(address(0), _account, _amount);\\n  }\\n\\n  function _burn(address _account, uint _amount) internal {\\n    balanceOf[_account] -= _amount;\\n    totalSupply -= _amount;\\n    emit Transfer(_account, address(0), _amount);\\n  }\\n\\n  function _pendingRewardPerToken() internal view returns(uint) {\\n    if (totalSupply == 0) { return 0; }\\n\\n    uint blocksElapsed = block.number - lastAccrueBlock;\\n    return blocksElapsed * rewardRate() * 1e18 / totalSupply;\\n  }\\n\\n  function _checkReserves() internal view {\\n    uint reserveBalance = IERC20(lockedToken).balanceOf(address(this));\\n\\n    uint blocksElapsed  = Math.min(distributionPeriod, block.number - lastIncomeBlock);\\n    uint unvestedIncome = rewardRateStored * (distributionPeriod - blocksElapsed);\\n\\n    require(reserveBalance >= totalLocked + unvestedIncome, \\\"VeToken: reserve balance too low\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.7.0;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint);\\n  function balanceOf(address account) external view returns(uint);\\n  function transfer(address recipient, uint256 amount) external returns(bool);\\n  function allowance(address owner, address spender) external view returns(uint);\\n  function decimals() external view returns(uint8);\\n  function approve(address spender, uint amount) external returns(bool);\\n  function transferFrom(address sender, address recipient, uint amount) external returns(bool);\\n}\"\r\n    },\r\n    \"SafeOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"IOwnable.sol\\\";\\n\\ncontract SafeOwnable is IOwnable {\\n\\n  uint public constant RENOUNCE_TIMEOUT = 1 hours;\\n\\n  address public override owner;\\n  address public pendingOwner;\\n  uint public renouncedAt;\\n\\n  event OwnershipTransferInitiated(address indexed previousOwner, address indexed newOwner);\\n  event OwnershipTransferConfirmed(address indexed previousOwner, address indexed newOwner);\\n\\n  constructor() {\\n    owner = msg.sender;\\n    emit OwnershipTransferConfirmed(address(0), msg.sender);\\n  }\\n\\n  modifier onlyOwner() {\\n    require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n    _;\\n  }\\n\\n  function isOwner() public view returns (bool) {\\n    return msg.sender == owner;\\n  }\\n\\n  function transferOwnership(address _newOwner) external override onlyOwner {\\n    require(_newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n    emit OwnershipTransferInitiated(owner, _newOwner);\\n    pendingOwner = _newOwner;\\n  }\\n\\n  function acceptOwnership() external override {\\n    require(msg.sender == pendingOwner, \\\"Ownable: caller is not pending owner\\\");\\n    emit OwnershipTransferConfirmed(msg.sender, pendingOwner);\\n    owner = pendingOwner;\\n    pendingOwner = address(0);\\n  }\\n\\n  function initiateRenounceOwnership() external onlyOwner {\\n    require(renouncedAt == 0, \\\"Ownable: already initiated\\\");\\n    renouncedAt = block.timestamp;\\n  }\\n\\n  function acceptRenounceOwnership() external onlyOwner {\\n    require(renouncedAt > 0, \\\"Ownable: not initiated\\\");\\n    require(block.timestamp - renouncedAt > RENOUNCE_TIMEOUT, \\\"Ownable: too early\\\");\\n    owner = address(0);\\n    pendingOwner = address(0);\\n    renouncedAt = 0;\\n  }\\n\\n  function cancelRenounceOwnership() external onlyOwner {\\n    require(renouncedAt > 0, \\\"Ownable: not initiated\\\");\\n    renouncedAt = 0;\\n  }\\n}\"\r\n    },\r\n    \"IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.6;\\n\\ninterface IOwnable {\\n  function owner() external view returns(address);\\n  function transferOwnership(address _newOwner) external;\\n  function acceptOwnership() external;\\n}\"\r\n    },\r\n    \"Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.6;\\n\\nlibrary Math {\\n\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a >= b ? a : b;\\n  }\\n\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow, so we distribute.\\n    return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\\n  }\\n\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b - 1) / b can overflow on addition, so we distribute.\\n    return a / b + (a % b == 0 ? 0 : 1);\\n  }\\n}\"\r\n    },\r\n    \"ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.6;\\n\\ncontract ReentrancyGuard {\\n  uint256 private constant _NOT_ENTERED = 1;\\n  uint256 private constant _ENTERED = 2;\\n\\n  uint256 private _status;\\n\\n  constructor () {\\n    _status = _NOT_ENTERED;\\n  }\\n\\n  modifier nonReentrant() {\\n    require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n    _status = _ENTERED;\\n    _;\\n    _status = _NOT_ENTERED;\\n  }\\n}\"\r\n    },\r\n    \"AddressLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressLibrary {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"veBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"veBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewDistributionPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"addAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardRate\",\"type\":\"uint256\"}],\"name\":\"NewIncome\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawAt\",\"type\":\"uint256\"}],\"name\":\"WithdrawRequest\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"RENOUNCE_TIMEOUT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptRenounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_addAmount\",\"type\":\"uint256\"}],\"name\":\"addIncome\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelRenounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lockedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_distributionPeriod\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initiateRenounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastAccrueBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastIncomeBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newLockedUntil\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"pendingAccountReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardSnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blocks\",\"type\":\"uint256\"}],\"name\":\"setDistributionPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VeToken", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}