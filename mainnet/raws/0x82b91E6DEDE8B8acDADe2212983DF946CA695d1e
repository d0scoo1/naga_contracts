{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DixelClubV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\n\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./lib/StringUtils.sol\\\";\\nimport \\\"./Constants.sol\\\";\\nimport \\\"./Shared.sol\\\";\\nimport \\\"./IDixelClubV2NFT.sol\\\";\\n\\n/**\\n* @title Dixel Club (V2) NFT Factory\\n*\\n* Create an ERC721 Dixel Club NFTs using proxy pattern to save gas\\n*/\\ncontract DixelClubV2Factory is Constants, Ownable {\\n    error DixelClubV2Factory__BlankedName();\\n    error DixelClubV2Factory__BlankedSymbol();\\n    error DixelClubV2Factory__DescriptionTooLong();\\n    error DixelClubV2Factory__InvalidMaxSupply();\\n    error DixelClubV2Factory__InvalidRoyalty();\\n    error DixelClubV2Factory__NameContainedMalicious();\\n    error DixelClubV2Factory__SymbolContainedMalicious();\\n    error DixelClubV2Factory__DescriptionContainedMalicious();\\n    error DixelClubV2Factory__InvalidCreationFee();\\n    error DixelClubV2Factory__ZeroAddress();\\n    error DixelClubV2Factory__InvalidFee();\\n\\n    /**\\n     *  EIP-1167: Minimal Proxy Contract - ERC721 Token implementation contract\\n     *  REF: https://github.com/optionality/clone-factory\\n     */\\n    address public nftImplementation;\\n\\n    address public beneficiary = address(0x82CA6d313BffE56E9096b16633dfD414148D66b1);\\n    uint256 public creationFee = 0.02 ether; // 0.02 ETH (~$50)\\n    uint256 public mintingFee = 500; // 5%;\\n\\n    // Array of all created nft collections\\n    address[] public collections;\\n\\n    event CollectionCreated(address indexed nftAddress, string name, string symbol);\\n\\n    constructor(address DixelClubV2NFTImpl) {\\n        nftImplementation = DixelClubV2NFTImpl;\\n    }\\n\\n    function _createClone(address target) private returns (address result) {\\n        bytes20 targetBytes = bytes20(target);\\n        assembly {\\n            let clone := mload(0x40)\\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(clone, 0x14), targetBytes)\\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            result := create(0, clone, 0x37)\\n        }\\n    }\\n\\n    function createCollection(\\n        string calldata name,\\n        string calldata symbol,\\n        string calldata description,\\n        Shared.MetaData memory metaData,\\n        uint24[PALETTE_SIZE] calldata palette,\\n        uint8[PIXEL_ARRAY_SIZE] calldata pixels\\n    ) external payable returns (address) {\\n        if(msg.value != creationFee) revert DixelClubV2Factory__InvalidCreationFee();\\n        if(bytes(name).length == 0) revert DixelClubV2Factory__BlankedName();\\n        if(bytes(symbol).length == 0) revert DixelClubV2Factory__BlankedSymbol();\\n        if(bytes(description).length > 1000) revert DixelClubV2Factory__DescriptionTooLong(); // ~900 gas per character\\n        if(metaData.maxSupply == 0 || metaData.maxSupply > MAX_SUPPLY) revert DixelClubV2Factory__InvalidMaxSupply();\\n        if(metaData.royaltyFriction > MAX_ROYALTY_FRACTION) revert DixelClubV2Factory__InvalidRoyalty();\\n\\n        // Validate `symbol`, `name` and `description` to ensure generateJSON() creates a valid JSON\\n        if(!StringUtils.validJSONValue(name)) revert DixelClubV2Factory__NameContainedMalicious();\\n        if(!StringUtils.validJSONValue(symbol)) revert DixelClubV2Factory__SymbolContainedMalicious();\\n        if(!StringUtils.validJSONValue(description)) revert DixelClubV2Factory__DescriptionContainedMalicious();\\n\\n        // Neutralize minting starts date\\n        if (metaData.mintingBeginsFrom < block.timestamp) {\\n            metaData.mintingBeginsFrom = uint40(block.timestamp);\\n        }\\n\\n        if (creationFee > 0) {\\n            // Send fee to the beneficiary\\n            (bool sent, ) = beneficiary.call{ value: creationFee }(\\\"\\\");\\n            require(sent, \\\"CREATION_FEE_TRANSFER_FAILED\\\");\\n        }\\n\\n        address nftAddress = _createClone(nftImplementation);\\n        IDixelClubV2NFT newNFT = IDixelClubV2NFT(nftAddress);\\n        newNFT.init(msg.sender, name, symbol, description, metaData, palette, pixels);\\n\\n        collections.push(nftAddress);\\n\\n        emit CollectionCreated(nftAddress, name, symbol);\\n\\n        return nftAddress;\\n    }\\n\\n    // MARK: Admin functions\\n\\n    // This will update NFT contract implementaion and it won't affect existing collections\\n    function updateImplementation(address newImplementation) external onlyOwner {\\n        nftImplementation = newImplementation;\\n    }\\n\\n    function updateBeneficiary(address newAddress) external onlyOwner {\\n      if(newAddress == address(0)) revert DixelClubV2Factory__ZeroAddress();\\n      beneficiary = newAddress;\\n    }\\n\\n    function updateMintingFee(uint256 newMintingFee) external onlyOwner {\\n      if(newMintingFee > FRICTION_BASE) revert DixelClubV2Factory__InvalidFee();\\n      mintingFee = newMintingFee;\\n    }\\n\\n    function updateCreationFee(uint256 newCreationFee) external onlyOwner {\\n      creationFee = newCreationFee;\\n    }\\n\\n    // MARK: - Utility functions\\n\\n    function collectionCount() external view returns (uint256) {\\n        return collections.length;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/StringUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\npragma solidity ^0.8.13;\\n\\nlibrary StringUtils {\\n    // Check if haystack has any invalid character for JSON value:\\n    // - \\\": 0x22\\n    // - \\\\: 0x5c\\n    // - any control characters: 0x00-0x1f, 0x7f\\n    function validJSONValue(string calldata haystack) internal pure returns (bool) {\\n        bytes memory haystackBytes = bytes(haystack);\\n        uint256 length = haystackBytes.length;\\n        for (uint256 i; i != length;) {\\n            bytes1 char = haystackBytes[i];\\n            if (char < 0x20 || char == 0x22 || char == 0x5c || char == 0x7f) {\\n                return false;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    function address2str(address addr) internal pure returns (string memory) {\\n        return Strings.toHexString(uint160(addr), 20);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\n\\npragma solidity ^0.8.13;\\n\\nabstract contract Constants {\\n    uint256 public constant MAX_SUPPLY = 1000000; // 1M hardcap max\\n    uint256 public constant MAX_ROYALTY_FRACTION = 1000; // 10%\\n    uint256 public constant FRICTION_BASE = 10000;\\n\\n    uint256 internal constant PALETTE_SIZE = 16; // 16 colors max - equal to the data type max value of CANVAS_SIZE (2^8 = 16)\\n    uint256 internal constant CANVAS_SIZE = 24; // 24x24 pixels\\n    uint256 internal constant TOTAL_PIXEL_COUNT = CANVAS_SIZE * CANVAS_SIZE; // 24x24\\n    uint256 internal constant PIXEL_ARRAY_SIZE = TOTAL_PIXEL_COUNT / 2; // packing 2 pixels in each uint8\\n}\\n\"\r\n    },\r\n    \"contracts/Shared.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\n\\npragma solidity ^0.8.13;\\n\\nlibrary Shared {\\n    struct MetaData {\\n        bool whitelistOnly;\\n        bool hidden;\\n        uint24 maxSupply; // can be minted up to MAX_SUPPLY\\n        uint24 royaltyFriction; // used for `royaltyInfo` (ERC2981) and `seller_fee_basis_points` (Opeansea's Contract-level metadata)\\n        uint40 mintingBeginsFrom; // Timestamp that minting event begins\\n        uint152 mintingCost; // Native token (ETH, BNB, KLAY, etc)\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IDixelClubV2NFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\n\\npragma solidity ^0.8.13;\\n\\nimport \\\"./Shared.sol\\\";\\n\\ninterface IDixelClubV2NFT {\\n    function init(\\n        address owner_,\\n        string calldata name_,\\n        string calldata symbol_,\\n        string calldata description_,\\n        Shared.MetaData calldata metaData_,\\n        uint24[16] calldata palette_,\\n        uint8[288] calldata pixels_\\n    ) external;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"DixelClubV2NFTImpl\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DixelClubV2Factory__BlankedName\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DixelClubV2Factory__BlankedSymbol\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DixelClubV2Factory__DescriptionContainedMalicious\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DixelClubV2Factory__DescriptionTooLong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DixelClubV2Factory__InvalidCreationFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DixelClubV2Factory__InvalidFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DixelClubV2Factory__InvalidMaxSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DixelClubV2Factory__InvalidRoyalty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DixelClubV2Factory__NameContainedMalicious\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DixelClubV2Factory__SymbolContainedMalicious\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DixelClubV2Factory__ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"CollectionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FRICTION_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ROYALTY_FRACTION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"collections\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"whitelistOnly\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hidden\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"maxSupply\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"royaltyFriction\",\"type\":\"uint24\"},{\"internalType\":\"uint40\",\"name\":\"mintingBeginsFrom\",\"type\":\"uint40\"},{\"internalType\":\"uint152\",\"name\":\"mintingCost\",\"type\":\"uint152\"}],\"internalType\":\"struct Shared.MetaData\",\"name\":\"metaData\",\"type\":\"tuple\"},{\"internalType\":\"uint24[16]\",\"name\":\"palette\",\"type\":\"uint24[16]\"},{\"internalType\":\"uint8[288]\",\"name\":\"pixels\",\"type\":\"uint8[288]\"}],\"name\":\"createCollection\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCreationFee\",\"type\":\"uint256\"}],\"name\":\"updateCreationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"updateImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMintingFee\",\"type\":\"uint256\"}],\"name\":\"updateMintingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DixelClubV2Factory", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1500", "ConstructorArguments": "0000000000000000000000001f3af095cda17d63cad238358837321e95fc5915", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}