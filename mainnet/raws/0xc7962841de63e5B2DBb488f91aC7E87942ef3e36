{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Tokens/tok.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\n\\n/*\\n *  \\n *  https://www.apeture.org/\\n *  https://t.me/Apeture\\n */\\n \\n\\npragma solidity ^0.8.6;\\n\\n/**\\n * Standard SafeMath, stripped down to just add/sub/mul/div\\n */\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n}\\n\\n/**\\n * ERC20 standard interface.\\n */\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function decimals() external view returns (uint8);\\n    function symbol() external view returns (string memory);\\n    function name() external view returns (string memory);\\n    function getOwner() external view returns (address);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address _owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\\n/**\\n * Allows for contract ownership along with multi-address authorization\\n */\\nabstract contract Auth {\\n    address internal owner;\\n    mapping (address => bool) internal authorizations;\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n        authorizations[_owner] = true;\\n    }\\n\\n    /**\\n     * Function modifier to require caller to be contract deployer\\n     */\\n    modifier onlyDeployer() {\\n        require(isOwner(msg.sender), \\\"!D\\\"); _;\\n    }\\n\\n    /**\\n     * Function modifier to require caller to be owner\\n     */\\n    modifier onlyOwner() {\\n        require(isAuthorized(msg.sender), \\\"!OWNER\\\"); _;\\n    }\\n\\n    /**\\n     * Authorize address. Owner only\\n     */\\n    function authorize(address adr) public onlyDeployer {\\n        authorizations[adr] = true;\\n    }\\n\\n    /**\\n     * Remove address' authorization. Deployer only\\n     */\\n    function unauthorize(address adr) public onlyDeployer {\\n        authorizations[adr] = false;\\n    }\\n\\n    /**\\n     * Check if address is owner\\n     */\\n    function isOwner(address account) public view returns (bool) {\\n        return account == owner;\\n    }\\n\\n    /**\\n     * Return address' authorization status\\n     */\\n    function isAuthorized(address adr) public view returns (bool) {\\n        return authorizations[adr];\\n    }\\n\\n    /**\\n     * Transfer ownership to new address. Caller must be deployer. Leaves old deployer authorized\\n     */\\n    function transferOwnership(address payable adr) public onlyDeployer {\\n        owner = adr;\\n        authorizations[adr] = true;\\n        emit OwnershipTransferred(adr);\\n    }\\n\\n    event OwnershipTransferred(address owner);\\n}\\n\\ninterface IDEXFactory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IDEXRouter {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\ninterface IDividendDistributor {\\n    function setShare(address shareholder, uint256 amount) external;\\n    function deposit() external payable;\\n    function claimDividend(address shareholder) external;\\n    function setDividendToken(address dividendToken) external;\\n}\\n\\ncontract DividendDistributor is IDividendDistributor {\\n    using SafeMath for uint256;\\n\\n    address _token;\\n\\n    struct Share {\\n        uint256 amount;\\n        uint256 totalExcluded;\\n        uint256 totalRealised;\\n    }\\n\\n    IERC20 dividendToken;\\n    IDEXRouter router;\\n    \\n    address WETH;\\n\\n    address[] shareholders;\\n    mapping (address => uint256) shareholderIndexes;\\n    mapping (address => uint256) shareholderClaims;\\n\\n    mapping (address => Share) public shares;\\n\\n    uint256 public totalShares;\\n    uint256 public totalDividends;\\n    uint256 public totalDistributed;\\n    uint256 public dividendsPerShare;\\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;\\n    \\n    address owner;\\n\\n    uint256 currentIndex;\\n\\n    bool initialized;\\n    modifier initialization() {\\n        require(!initialized);\\n        _;\\n        initialized = true;\\n    }\\n\\n    modifier onlyToken() {\\n        require(msg.sender == _token); _;\\n    }\\n    \\n    modifier onlyOwner() {\\n        require(msg.sender == owner); _;\\n    }\\n    \\n    event DividendTokenUpdate(address dividendToken);\\n\\n    constructor (address _router, address _dividendToken, address _owner) {\\n        router = _router != address(0)\\n            ? IDEXRouter(_router)\\n            : IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n        _token = msg.sender;\\n        dividendToken = IERC20(_dividendToken);\\n        WETH = router.WETH();\\n        owner = _owner;\\n    }\\n\\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\\n        if(shares[shareholder].amount > 0){\\n            distributeDividend(shareholder);\\n        }\\n\\n        if(amount > 0 && shares[shareholder].amount == 0){\\n            addShareholder(shareholder);\\n        }else if(amount == 0 && shares[shareholder].amount > 0){\\n            removeShareholder(shareholder);\\n        }\\n\\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\\n        shares[shareholder].amount = amount;\\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\\n    }\\n\\n    function deposit() external payable override onlyToken {\\n        uint256 balanceBefore = dividendToken.balanceOf(address(this));\\n\\n        // address[] memory path = new address[](2);\\n        // path[0] = WETH;\\n        // path[1] = address(dividendToken);\\n\\n        // router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(\\n        //     0,\\n        //     path,\\n        //     address(this),\\n        //     block.timestamp\\n        // );\\n\\n        IWETH(WETH).deposit{value: msg.value}();\\n\\n        uint256 amount = dividendToken.balanceOf(address(this)).sub(balanceBefore);\\n\\n        totalDividends = totalDividends.add(amount);\\n        dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\\n    }\\n\\n    function distributeDividend(address shareholder) internal {\\n        if(shares[shareholder].amount == 0){ return; }\\n\\n        uint256 amount = getUnpaidEarnings(shareholder);\\n        if(amount > 0){\\n            totalDistributed = totalDistributed.add(amount);\\n            dividendToken.transfer(shareholder, amount);\\n            shareholderClaims[shareholder] = block.timestamp;\\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\\n        }\\n    }\\n    \\n    function claimDividend(address shareholder) external override onlyToken {\\n        distributeDividend(shareholder);\\n    }\\n\\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\\n        if(shares[shareholder].amount == 0){ return 0; }\\n\\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\\n\\n        if(shareholderTotalDividends <= shareholderTotalExcluded){ return 0; }\\n\\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\\n    }\\n\\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\\n        return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\\n    }\\n\\n    function addShareholder(address shareholder) internal {\\n        shareholderIndexes[shareholder] = shareholders.length;\\n        shareholders.push(shareholder);\\n    }\\n\\n    function removeShareholder(address shareholder) internal {\\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\\n        shareholders.pop();\\n    }\\n    \\n    function setDividendToken(address _dividendToken) external override onlyToken {\\n        dividendToken = IERC20(_dividendToken);\\n        emit DividendTokenUpdate(_dividendToken);\\n    }\\n    \\n    function getDividendToken() external view returns (address) {\\n        return address(dividendToken);\\n    }\\n    \\n    function sendDividend(address holder, uint256 amount) external onlyOwner {\\n        dividendToken.transfer(holder, amount);\\n    }\\n}\\n\\ncontract APETURE is IERC20, Auth {\\n    using SafeMath for uint256;\\n\\n    address WETH;\\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\\n\\n    string constant _name = \\\"APETURE\\\";\\n    string constant _symbol = \\\"ATURE\\\";\\n    uint8 constant _decimals = 9;\\n\\n    uint256 _totalSupply = 1000000000000 * (10 ** _decimals);\\n    uint256 public _maxTxAmountBuy = _totalSupply;\\n    uint256 public _maxTxAmountSell = _totalSupply / 100;\\n    \\n    uint256 _maxWalletToken = 10 * 10**9 * (10**_decimals);\\n\\n    mapping (address => uint256) _balances;\\n    mapping (address => mapping (address => uint256)) _allowances;\\n\\n    mapping (address => bool) isFeeExempt;\\n    mapping (address => bool) isTxLimitExempt;\\n    mapping (address => bool) isDividendExempt;\\n    mapping (address => bool) isBot;\\n\\n    uint256 initialBlockLimit = 15;\\n    \\n    uint256 reflectionFeeBuy = 4;\\n    uint256 marketingFeeBuy = 7;\\n    uint256 devFeeBuy = 4;\\n    uint256 totalFeeBuy = 15;\\n    uint256 feeDenominatorBuy = 100;\\n    \\n    uint256 reflectionFeeSell = 6;\\n    uint256 marketingFeeSell = 9;\\n    uint256 devFeeSell = 5;\\n    uint256 totalFeeSell = 20;\\n    uint256 feeDenominatorSell = 100;\\n\\n    address marketingReceiver;\\n    address devReceiver;\\n\\n    IDEXRouter public router;\\n    address public pair;\\n\\n    uint256 public launchedAt;\\n\\n    DividendDistributor distributor;\\n\\n    bool public swapEnabled = true;\\n    uint256 public swapThreshold = _totalSupply / 5000; // 200M\\n    bool inSwap;\\n    modifier swapping() { inSwap = true; _; inSwap = false; }\\n\\n    constructor (\\n        address _marketing,\\n        address _dev\\n    ) Auth(msg.sender) {\\n        router = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n            \\n        WETH = router.WETH();\\n        \\n        pair = IDEXFactory(router.factory()).createPair(WETH, address(this));\\n        \\n        _allowances[address(this)][address(router)] = type(uint256).max;\\n        \\n       address _token =  0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n        distributor = new DividendDistributor(address(router), _token, msg.sender);\\n\\n        isFeeExempt[msg.sender] = true;\\n        isTxLimitExempt[msg.sender] = true;\\n        isDividendExempt[pair] = true;\\n        isDividendExempt[address(this)] = true;\\n        isDividendExempt[DEAD] = true;\\n\\n        marketingReceiver = _marketing;\\n        devReceiver = _dev;\\n\\n        _balances[msg.sender] = _totalSupply;\\n    \\n        emit Transfer(address(0), msg.sender, _totalSupply);\\n    }\\n\\n    receive() external payable { }\\n\\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\\n    function decimals() external pure override returns (uint8) { return _decimals; }\\n    function symbol() external pure override returns (string memory) { return _symbol; }\\n    function name() external pure override returns (string memory) { return _name; }\\n    function getOwner() external view override returns (address) { return owner; }\\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\\n\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _allowances[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function approveMax(address spender) external returns (bool) {\\n        return approve(spender, type(uint256).max);\\n    }\\n\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\n        return _tF(msg.sender, recipient, amount);\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\n        if(_allowances[sender][msg.sender] != type(uint256).max){\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \\\"Insufficient Allowance\\\");\\n        }\\n\\n        return _tF(sender, recipient, amount);\\n    }\\n\\n    function _tF(address s, address r, uint256 amount) internal returns (bool) {\\n        if(inSwap){ return _basicTransfer(s, r, amount); }\\n        \\n        checkTxLimit(s, r, amount);\\n\\n        if(shouldSwapBack()){ swapBack(); }\\n\\n        if(!launched() && r == pair){ require(_balances[s] > 0); launch(); }\\n\\n        _balances[s] = _balances[s].sub(amount, \\\"Insufficient Balance\\\");\\n\\n        uint256 amountReceived = shouldTakeFee(s) ? takeFee(s, r, amount) : amount;\\n        \\n        if(r != pair && !isTxLimitExempt[r]){\\n            uint256 contractBalanceRecepient = balanceOf(r);\\n            require(contractBalanceRecepient + amountReceived <= _maxWalletToken, \\\"Exceeds maximum wallet token amount\\\"); \\n        }\\n        \\n        _balances[r] = _balances[r].add(amountReceived);\\n\\n        if(!isDividendExempt[s]){ try distributor.setShare(s, _balances[s]) {} catch {} }\\n        if(!isDividendExempt[r]){ try distributor.setShare(r, _balances[r]) {} catch {} }\\n\\n        emit Transfer(s, r, amountReceived);\\n        return true;\\n    }\\n    \\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\\n        _balances[sender] = _balances[sender].sub(amount, \\\"Insufficient Balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function checkTxLimit(address sender, address receiver, uint256 amount) internal view {\\n        sender == pair\\n            ? require(amount <= _maxTxAmountBuy || isTxLimitExempt[receiver], \\\"Buy TX Limit Exceeded\\\")\\n            : require(amount <= _maxTxAmountSell || isTxLimitExempt[sender], \\\"Sell TX Limit Exceeded\\\");\\n    }\\n\\n    function shouldTakeFee(address sender) internal view returns (bool) {\\n        return !isFeeExempt[sender];\\n    }\\n\\n    function getTotalFee(bool selling, bool bot) public view returns (uint256) {\\n        // Anti-bot, fees as 99% for the first block\\n        if(launchedAt + initialBlockLimit >= block.number || bot){ return selling ? feeDenominatorSell.sub(1) : feeDenominatorBuy.sub(1); }\\n        // If selling and buyback has happened in past 30 mins, then get the multiplied fees or otherwise get the normal fees\\n        return selling ? totalFeeSell : totalFeeBuy;\\n    }\\n\\n    function takeFee(address sender, address receiver, uint256 amount) internal returns (uint256) {\\n        // Add all the fees to the contract. In case of Sell, it will be multiplied fees.\\n        uint256 feeAmount = (receiver == pair) ? amount.mul(getTotalFee(true, isBot[sender])).div(feeDenominatorSell) : amount.mul(getTotalFee(false, isBot[receiver])).div(feeDenominatorBuy);\\n\\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\\n        emit Transfer(sender, address(this), feeAmount);\\n\\n        return amount.sub(feeAmount);\\n    }\\n\\n    function shouldSwapBack() internal view returns (bool) {\\n        return msg.sender != pair\\n        && !inSwap\\n        && swapEnabled\\n        && _balances[address(this)] >= swapThreshold;\\n    }\\n\\n    function swapBack() internal swapping {\\n        uint256 amountToSwap = swapThreshold;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = WETH;\\n\\n        uint256 balanceBefore = address(this).balance;\\n\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amountToSwap,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n        uint256 amountETH = address(this).balance.sub(balanceBefore);\\n        uint256 amountReflection = amountETH.mul(reflectionFeeSell).div(totalFeeSell);\\n        uint256 amountDev = amountETH.mul(devFeeSell).div(totalFeeSell);\\n        uint256 amountMarketing = amountETH.sub(amountReflection.add(amountDev));\\n\\n        try distributor.deposit{value: amountReflection}() {} catch {}\\n        \\n        (bool successDev, /* bytes memory data */) = payable(devReceiver).call{value: amountDev, gas: 30000}(\\\"\\\");\\n        (bool successMarketing, /* bytes memory data */) = payable(marketingReceiver).call{value: amountMarketing, gas: 30000}(\\\"\\\");\\n        require(successDev && successMarketing, \\\"receiver rejected ETH transfer\\\");\\n    }\\n\\n    function launched() internal view returns (bool) {\\n        return launchedAt != 0;\\n    }\\n\\n    function launch() internal {\\n        //To know when it was launched\\n        launchedAt = block.number;\\n    }\\n    \\n    function setInitialBlockLimit(uint256 blocks) external onlyOwner {\\n        require(blocks > 0, \\\"Blocks should be greater than 0\\\");\\n        initialBlockLimit = blocks;\\n    }\\n\\n    function setBuyTxLimit(uint256 amount) external onlyOwner {\\n        _maxTxAmountBuy = amount;\\n    }\\n    \\n    function setSellTxLimit(uint256 amount) external onlyOwner {\\n        _maxTxAmountSell = amount;\\n    }\\n    \\n    function setMaxWalletToken(uint256 amount) external onlyOwner {\\n        _maxWalletToken = amount;\\n    }\\n    \\n    function getMaxWalletToken() public view onlyOwner returns (uint256) {\\n        return _maxWalletToken;\\n    }\\n    \\n    function setBot(address _address, bool toggle) external onlyOwner {\\n        isBot[_address] = toggle;\\n        _setIsDividendExempt(_address, toggle);\\n    }\\n    \\n    function isInBot(address _address) public view onlyOwner returns (bool) {\\n        return isBot[_address];\\n    }\\n    \\n    function _setIsDividendExempt(address holder, bool exempt) internal {\\n        require(holder != address(this) && holder != pair);\\n        isDividendExempt[holder] = exempt;\\n        if(exempt){\\n            distributor.setShare(holder, 0);\\n        }else{\\n            distributor.setShare(holder, _balances[holder]);\\n        }\\n    }\\n\\n    function setIsDividendExempt(address holder, bool exempt) public onlyOwner {\\n        _setIsDividendExempt(holder, exempt);\\n    }\\n\\n    function setIsFeeExempt(address holder, bool exempt) external onlyOwner {\\n        isFeeExempt[holder] = exempt;\\n    }\\n\\n    function setIsTxLimitExempt(address holder, bool exempt) external onlyOwner {\\n        isTxLimitExempt[holder] = exempt;\\n    }\\n\\n    function setSellFees( uint256 _reflectionFee, uint256 _marketingFee, uint256 _feeDenominator) external onlyOwner {\\n        reflectionFeeSell = _reflectionFee;\\n        marketingFeeSell = _marketingFee;\\n        totalFeeSell = _reflectionFee.add(_marketingFee);\\n        feeDenominatorSell = _feeDenominator;\\n        //Total fees has be less than 25%\\n        require(totalFeeSell < feeDenominatorSell/4);\\n    }\\n    \\n    function setBuyFees(uint256 _reflectionFee, uint256 _marketingFee, uint256 _devFee, uint256 _feeDenominator) external onlyOwner {\\n        reflectionFeeBuy = _reflectionFee;\\n        marketingFeeBuy = _marketingFee;\\n        devFeeBuy = _devFee;\\n        totalFeeBuy = _reflectionFee.add(_marketingFee).add(_devFee);\\n        feeDenominatorBuy = _feeDenominator;\\n        //Total fees has be less than 25%\\n        require(totalFeeBuy < feeDenominatorBuy/4);\\n    }\\n\\n    function setFeeReceivers(address _marketingReceiver) external onlyOwner {\\n        marketingReceiver = _marketingReceiver;\\n    }\\n    \\n    function fixFeeIssue(uint256 amount) external onlyOwner {\\n        //Use in case marketing fees or dividends are stuck.\\n        uint256 contractETHBalance = address(this).balance;\\n        payable(marketingReceiver).transfer(amount > 0 ? amount.div(2) : contractETHBalance.div(2));\\n        payable(devReceiver).transfer(amount > 0 ? amount.div(2) : contractETHBalance.div(2));\\n    }\\n\\n    function setSwapBackSettings(bool _enabled, uint256 _amount) external onlyOwner {\\n        swapEnabled = _enabled;\\n        swapThreshold = _amount;\\n    }\\n    \\n    function claimDividend() external {\\n        distributor.claimDividend(msg.sender);\\n    }\\n    \\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\\n        return distributor.getUnpaidEarnings(shareholder);\\n    }\\n    \\n    function banMultipleBots(address[] calldata accounts, bool excluded) external onlyOwner {\\n        for(uint256 i = 0; i < accounts.length; i++) {\\n            isBot[accounts[i]] = excluded;\\n            isDividendExempt[accounts[i]] = excluded;\\n            if(excluded){\\n                distributor.setShare(accounts[i], 0);\\n            }else{\\n                distributor.setShare(accounts[i], _balances[accounts[i]]);\\n            }\\n        }\\n    }\\n    \\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketing\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dev\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_maxTxAmountBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmountSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"banMultipleBots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimDividend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fixFeeIssue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxWalletToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"selling\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"bot\",\"type\":\"bool\"}],\"name\":\"getTotalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shareholder\",\"type\":\"address\"}],\"name\":\"getUnpaidEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isInBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"toggle\",\"type\":\"bool\"}],\"name\":\"setBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reflectionFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_devFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeDenominator\",\"type\":\"uint256\"}],\"name\":\"setBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setBuyTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blocks\",\"type\":\"uint256\"}],\"name\":\"setInitialBlockLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsDividendExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reflectionFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeDenominator\",\"type\":\"uint256\"}],\"name\":\"setSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSellTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "APETURE", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008da020d727dcc13ea1744b6f3b4e98622626a7a80000000000000000000000003beb2d3630d648b38e4a7479c7a3ce6074dddf85", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}