{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TwapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\nimport './interfaces/ITwapOracle.sol';\\nimport './interfaces/IERC20.sol';\\nimport './libraries/SafeMath.sol';\\nimport '@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol';\\n\\ncontract TwapOracle is ITwapOracle {\\n    using SafeMath for uint256;\\n    using SafeMath for int256;\\n    uint8 public immutable override xDecimals;\\n    uint8 public immutable override yDecimals;\\n    int256 public immutable override decimalsConverter;\\n    address public override owner;\\n    address public override uniswapPair;\\n\\n    constructor(uint8 _xDecimals, uint8 _yDecimals) {\\n        require(_xDecimals <= 75 && _yDecimals <= 75, 'TO4F');\\n        if (_yDecimals > _xDecimals) {\\n            require(_yDecimals - _xDecimals <= 18, 'TO47');\\n        } else {\\n            require(_xDecimals - _yDecimals <= 18, 'TO47');\\n        }\\n        owner = msg.sender;\\n        xDecimals = _xDecimals;\\n        yDecimals = _yDecimals;\\n        decimalsConverter = (10**(18 + _xDecimals - _yDecimals)).toInt256();\\n\\n        emit OwnerSet(msg.sender);\\n    }\\n\\n    function isContract(address addr) private view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(addr)\\n        }\\n        return size > 0;\\n    }\\n\\n    function setOwner(address _owner) external override {\\n        require(msg.sender == owner, 'TO00');\\n        require(_owner != address(0), 'TO02');\\n        require(_owner != owner, 'TO01');\\n        owner = _owner;\\n        emit OwnerSet(_owner);\\n    }\\n\\n    function setUniswapPair(address _uniswapPair) external override {\\n        require(msg.sender == owner, 'TO00');\\n        require(_uniswapPair != uniswapPair, 'TO01');\\n        require(_uniswapPair != address(0), 'TO02');\\n        require(isContract(_uniswapPair), 'TO0B');\\n        uniswapPair = _uniswapPair;\\n\\n        IUniswapV2Pair pairContract = IUniswapV2Pair(_uniswapPair);\\n        require(\\n            IERC20(pairContract.token0()).decimals() == xDecimals &&\\n                IERC20(pairContract.token1()).decimals() == yDecimals,\\n            'TO45'\\n        );\\n\\n        (uint112 reserve0, uint112 reserve1, ) = pairContract.getReserves();\\n        require(reserve0 != 0 && reserve1 != 0, 'TO1F');\\n        emit UniswapPairSet(_uniswapPair);\\n    }\\n\\n    // based on: https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol\\n    function getPriceInfo() public view override returns (uint256 priceAccumulator, uint32 priceTimestamp) {\\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapPair);\\n        priceAccumulator = pair.price0CumulativeLast();\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = pair.getReserves();\\n\\n        // uint32 can be cast directly until Sun, 07 Feb 2106 06:28:15 GMT\\n        priceTimestamp = uint32(block.timestamp);\\n        if (blockTimestampLast != priceTimestamp) {\\n            // allow overflow to stay consistent with Uniswap code and save some gas\\n            uint32 timeElapsed = priceTimestamp - blockTimestampLast;\\n            priceAccumulator += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n        }\\n    }\\n\\n    function decodePriceInfo(bytes memory data) internal pure returns (uint256 price) {\\n        assembly {\\n            price := mload(add(data, 32))\\n        }\\n    }\\n\\n    function getSpotPrice() external view override returns (uint256) {\\n        (uint112 reserve0, uint112 reserve1, ) = IUniswapV2Pair(uniswapPair).getReserves();\\n        return uint256(reserve1).mul(uint256(decimalsConverter)).div(uint256(reserve0));\\n    }\\n\\n    function getAveragePrice(uint256 priceAccumulator, uint32 priceTimestamp) public view override returns (uint256) {\\n        (uint256 currentPriceAccumulator, uint32 currentPriceTimestamp) = getPriceInfo();\\n\\n        require(priceTimestamp < currentPriceTimestamp, 'TO20');\\n\\n        // timeElapsed = currentPriceTimestamp - priceTimestamp (overflow is desired)\\n        // averagePrice = (currentPriceAccumulator - priceAccumulator) / timeElapsed\\n        // return value = (averagePrice * decimalsConverter) / 2**112\\n        return\\n            ((currentPriceAccumulator - priceAccumulator) / (currentPriceTimestamp - priceTimestamp)).mul(\\n                uint256(decimalsConverter)\\n            ) >> 112;\\n    }\\n\\n    function tradeX(\\n        uint256 xAfter,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view override returns (uint256 yAfter) {\\n        int256 xAfterInt = xAfter.toInt256();\\n        int256 xBeforeInt = xBefore.toInt256();\\n        int256 yBeforeInt = yBefore.toInt256();\\n        int256 averagePriceInt = decodePriceInfo(data).toInt256();\\n\\n        int256 yTradedInt = xAfterInt.sub(xBeforeInt).mul(averagePriceInt);\\n\\n        // yAfter = yBefore - yTraded = yBefore - ((xAfter - xBefore) * price)\\n        // we are multiplying yBefore by decimalsConverter to push division to the very end\\n        int256 yAfterInt = yBeforeInt.mul(decimalsConverter).sub(yTradedInt).div(decimalsConverter);\\n        require(yAfterInt >= 0, 'TO27');\\n        yAfter = uint256(yAfterInt);\\n    }\\n\\n    function tradeY(\\n        uint256 yAfter,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view override returns (uint256 xAfter) {\\n        int256 yAfterInt = yAfter.toInt256();\\n        int256 xBeforeInt = xBefore.toInt256();\\n        int256 yBeforeInt = yBefore.toInt256();\\n        int256 averagePriceInt = decodePriceInfo(data).toInt256();\\n\\n        int256 xTradedInt = yAfterInt.sub(yBeforeInt).mul(decimalsConverter);\\n\\n        // xAfter = xBefore - xTraded = xBefore - ((yAfter - yBefore) * price)\\n        // we are multiplying xBefore by averagePriceInt to push division to the very end\\n        int256 xAfterInt = xBeforeInt.mul(averagePriceInt).sub(xTradedInt).div(averagePriceInt);\\n        require(xAfterInt >= 0, 'TO28');\\n\\n        xAfter = uint256(xAfterInt);\\n    }\\n\\n    function depositTradeXIn(\\n        uint256 xLeft,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view override returns (uint256) {\\n        if (xBefore == 0 || yBefore == 0) {\\n            return 0;\\n        }\\n\\n        // ratio after swap = ratio after second mint\\n        // (xBefore + xIn) / (yBefore - xIn * price) = (xBefore + xLeft) / yBefore\\n        // xIn = xLeft * yBefore / (price * (xLeft + xBefore) + yBefore)\\n        uint256 price = decodePriceInfo(data);\\n        uint256 numerator = xLeft.mul(yBefore);\\n        uint256 denominator = price.mul(xLeft.add(xBefore)).add(yBefore.mul(uint256(decimalsConverter)));\\n        uint256 xIn = numerator.mul(uint256(decimalsConverter)).div(denominator);\\n\\n        // Don't swap when numbers are too large. This should actually never happen.\\n        if (xIn.mul(price).div(uint256(decimalsConverter)) >= yBefore || xIn >= xLeft) {\\n            return 0;\\n        }\\n\\n        return xIn;\\n    }\\n\\n    function depositTradeYIn(\\n        uint256 yLeft,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view override returns (uint256) {\\n        if (xBefore == 0 || yBefore == 0) {\\n            return 0;\\n        }\\n\\n        // ratio after swap = ratio after second mint\\n        // (xBefore - yIn / price) / (yBefore + yIn) = xBefore / (yBefore + yLeft)\\n        // yIn = price * xBefore * yLeft / (price * xBefore + yLeft + yBefore)\\n        uint256 price = decodePriceInfo(data);\\n        uint256 numerator = price.mul(xBefore).mul(yLeft);\\n        uint256 denominator = price.mul(xBefore).add(yLeft.add(yBefore).mul(uint256(decimalsConverter)));\\n        uint256 yIn = numerator.div(denominator);\\n\\n        // Don't swap when numbers are too large. This should actually never happen.\\n        if (yIn.mul(uint256(decimalsConverter)).div(price) >= xBefore || yIn >= yLeft) {\\n            return 0;\\n        }\\n\\n        return yIn;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\ninterface ITwapOracle {\\n    event OwnerSet(address owner);\\n    event UniswapPairSet(address uniswapPair);\\n\\n    function decimalsConverter() external view returns (int256);\\n\\n    function xDecimals() external view returns (uint8);\\n\\n    function yDecimals() external view returns (uint8);\\n\\n    function owner() external view returns (address);\\n\\n    function uniswapPair() external view returns (address);\\n\\n    function getPriceInfo() external view returns (uint256 priceAccumulator, uint32 priceTimestamp);\\n\\n    function getSpotPrice() external view returns (uint256);\\n\\n    function getAveragePrice(uint256 priceAccumulator, uint32 priceTimestamp) external view returns (uint256);\\n\\n    function setOwner(address _owner) external;\\n\\n    function setUniswapPair(address _uniswapPair) external;\\n\\n    function tradeX(\\n        uint256 xAfter,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 yAfter);\\n\\n    function tradeY(\\n        uint256 yAfter,\\n        uint256 yBefore,\\n        uint256 xBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 xAfter);\\n\\n    function depositTradeXIn(\\n        uint256 xLeft,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 xIn);\\n\\n    function depositTradeYIn(\\n        uint256 yLeft,\\n        uint256 yBefore,\\n        uint256 xBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 yIn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    int256 private constant _INT256_MIN = -2**255;\\n\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, 'SM4E');\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = sub(x, y, 'SM12');\\n    }\\n\\n    function sub(\\n        uint256 x,\\n        uint256 y,\\n        string memory message\\n    ) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, message);\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, 'SM2A');\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, 'SM43');\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    function ceil_div(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = div(a, b);\\n        if (c == mul(a, b)) {\\n            return c;\\n        } else {\\n            return add(c, 1);\\n        }\\n    }\\n\\n    function toUint32(uint256 n) internal pure returns (uint32) {\\n        require(n <= type(uint32).max, 'SM50');\\n        return uint32(n);\\n    }\\n\\n    function toUint112(uint256 n) internal pure returns (uint112) {\\n        require(n <= type(uint112).max, 'SM51');\\n        return uint112(n);\\n    }\\n\\n    function toInt256(uint256 unsigned) internal pure returns (int256 signed) {\\n        require(unsigned <= uint256(type(int256).max), 'SM34');\\n        signed = int256(unsigned);\\n    }\\n\\n    // int256\\n\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), 'SM4D');\\n\\n        return c;\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), 'SM11');\\n\\n        return c;\\n    }\\n\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), 'SM29');\\n\\n        int256 c = a * b;\\n        require(c / a == b, 'SM29');\\n\\n        return c;\\n    }\\n\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, 'SM43');\\n        require(!(b == -1 && a == _INT256_MIN), 'SM42');\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2 ** 32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(\\n        address pair\\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/FixedPoint.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.0;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\\n        return uq112x112(self._x / uint224(x));\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\n        uint z;\\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_xDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_yDecimals\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"uniswapPair\",\"type\":\"address\"}],\"name\":\"UniswapPairSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"decimalsConverter\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"xLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"depositTradeXIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"yLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"depositTradeYIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"priceAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"priceTimestamp\",\"type\":\"uint32\"}],\"name\":\"getAveragePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriceInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"priceTimestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapPair\",\"type\":\"address\"}],\"name\":\"setUniswapPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"xAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tradeX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"yAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"yAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tradeY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"xAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TwapOracle", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000012", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}