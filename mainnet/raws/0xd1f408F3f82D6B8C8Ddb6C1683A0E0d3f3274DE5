{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.8.6;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address private nextOwner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    // modifiers\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"caller is not the owner.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyNextOwner() {\r\n        require(isNextOwner(), \"current owner must set caller as next owner.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Initialize contract by setting transaction submitter as initial owner.\r\n     */\r\n    constructor(address owner_) {\r\n        owner = owner_;\r\n        emit OwnershipTransferred(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Initiate ownership transfer by setting nextOwner.\r\n     */\r\n    function transferOwnership(address nextOwner_) external onlyOwner {\r\n        require(nextOwner_ != address(0), \"Next owner is the zero address.\");\r\n\r\n        nextOwner = nextOwner_;\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel ownership transfer by deleting nextOwner.\r\n     */\r\n    function cancelOwnershipTransfer() external onlyOwner {\r\n        delete nextOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Accepts ownership transfer by setting owner.\r\n     */\r\n    function acceptOwnership() external onlyNextOwner {\r\n        delete nextOwner;\r\n\r\n        owner = msg.sender;\r\n\r\n        emit OwnershipTransferred(owner, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Renounce ownership by setting owner to zero address.\r\n     */\r\n    function renounceOwnership() external onlyOwner {\r\n        owner = address(0);\r\n\r\n        emit OwnershipTransferred(owner, address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the next owner.\r\n     */\r\n    function isNextOwner() public view returns (bool) {\r\n        return msg.sender == nextOwner;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/lib/interface/IGovernable.sol\r\n\r\n\r\ninterface IGovernable {\r\n    function changeGovernor(address governor_) external;\r\n\r\n    function isGovernor() external view returns (bool);\r\n\r\n    function governor() external view returns (address);\r\n}\r\n\r\n\r\n// File contracts/lib/Governable.sol\r\n\r\n\r\n\r\ncontract Governable is Ownable, IGovernable {\r\n    // ============ Mutable Storage ============\r\n\r\n    // Mirror governance contract.\r\n    address public override governor;\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier onlyGovernance() {\r\n        require(isOwner() || isGovernor(), \"caller is not governance\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyGovernor() {\r\n        require(isGovernor(), \"caller is not governor\");\r\n        _;\r\n    }\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor(address owner_) Ownable(owner_) {}\r\n\r\n    // ============ Administration ============\r\n\r\n    function changeGovernor(address governor_) public override onlyGovernance {\r\n        governor = governor_;\r\n    }\r\n\r\n    // ============ Utility Functions ============\r\n\r\n    function isGovernor() public view override returns (bool) {\r\n        return msg.sender == governor;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/distribution/interface/IDistributionLogic.sol\r\n\r\n\r\ninterface IDistributionLogic {\r\n    function version() external returns (uint256);\r\n\r\n    function distribute(address tributary, uint256 contribution) external;\r\n\r\n    function claim(address claimant) external;\r\n\r\n    function claimable(address claimant) external view returns (uint256);\r\n\r\n    function increaseAwards(address member, uint256 amount) external;\r\n}\r\n\r\n\r\n// File contracts/interface/IENS.sol\r\n\r\ninterface IENS {\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n    // Logged when an operator is added or removed.\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    function setRecord(\r\n        bytes32 node,\r\n        address owner,\r\n        address resolver,\r\n        uint64 ttl\r\n    ) external;\r\n\r\n    function setSubnodeRecord(\r\n        bytes32 node,\r\n        bytes32 label,\r\n        address owner,\r\n        address resolver,\r\n        uint64 ttl\r\n    ) external;\r\n\r\n    function setSubnodeOwner(\r\n        bytes32 node,\r\n        bytes32 label,\r\n        address owner\r\n    ) external returns (bytes32);\r\n\r\n    function setResolver(bytes32 node, address resolver) external;\r\n\r\n    function setOwner(bytes32 node, address owner) external;\r\n\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function owner(bytes32 node) external view returns (address);\r\n\r\n    function resolver(bytes32 node) external view returns (address);\r\n\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n\r\n    function recordExists(bytes32 node) external view returns (bool);\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n\r\n// File contracts/distribution/interface/IDistributionStorage.sol\r\n\r\n\r\ninterface IDistributionStorage {\r\n    function registered(address claimant) external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/distribution/DistributionStorage.sol\r\n\r\n\r\n\r\n/**\r\n * @title DistributionStorage\r\n * @author MirrorXYZ\r\n */\r\ncontract DistributionStorage is IDistributionStorage {\r\n    // ============ Immutable Storage ============\r\n\r\n    // The node of the root name (e.g. namehash(mirror.xyz))\r\n    bytes32 public immutable rootNode;\r\n    /**\r\n     * The address of the public ENS registry.\r\n     * @dev Dependency-injectable for testing purposes, but otherwise this is the\r\n     * canonical ENS registry at 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e.\r\n     */\r\n    IENS public immutable ensRegistry;\r\n\r\n    // ============ Mutable Storage ============\r\n\r\n    // The address for Mirror team and investors.\r\n    address team;\r\n    // The address of the governance token that this contract is allowed to mint.\r\n    address token;\r\n    // The address that is allowed to distribute.\r\n    address treasury;\r\n    // The amount that has been contributed to the treasury.\r\n    mapping(address => uint256) public contributions;\r\n    mapping(address => uint256) public awards;\r\n    // The number of rewards that are created per 1 ETH contribution to the treasury.\r\n    uint256 contributionsFactor = 1000;\r\n    // The amount that has been claimed per address.\r\n    mapping(address => uint256) public claimed;\r\n    // The block number that an address last claimed\r\n    mapping(address => uint256) public lastClaimed;\r\n    // The block number that an address registered\r\n    mapping(address => uint256) public override registered;\r\n    // Banned accounts\r\n    mapping(address => bool) public banned;\r\n    // The percentage of tokens issued that are taken by the Mirror team.\r\n    uint256 teamRatio = 40;\r\n    uint256 public registrationReward = 100 * 1e18;\r\n    uint256 public registeredMembers;\r\n\r\n    struct DistributionEpoch {\r\n        uint256 startBlock;\r\n        uint256 claimablePerBlock;\r\n    }\r\n\r\n    DistributionEpoch[] public epochs;\r\n    uint256 numEpochs = 0;\r\n\r\n    constructor(bytes32 rootNode_, address ensRegistry_) {\r\n        rootNode = rootNode_;\r\n        ensRegistry = IENS(ensRegistry_);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/lib/upgradable/interface/IBeacon.sol\r\n\r\n\r\ninterface IBeacon {\r\n    /// @notice Logic for this contract.\r\n    function logic() external view returns (address);\r\n\r\n    /// @notice Emitted when the logic is updated.\r\n    event Update(address oldLogic, address newLogic);\r\n\r\n    /// @notice Updates logic address.\r\n    function update(address newLogic) external;\r\n}\r\n\r\n\r\n// File contracts/lib/upgradable/BeaconStorage.sol\r\n\r\n\r\ncontract BeaconStorage {\r\n    /// @notice Holds the address of the upgrade beacon\r\n    address internal immutable beacon;\r\n\r\n    constructor(address beacon_) {\r\n        beacon = beacon_;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/lib/Pausable.sol\r\n\r\n\r\ninterface IPausable {\r\n    /// @notice Emitted when the pause is triggered by `account`.\r\n    event Paused(address account);\r\n\r\n    /// @notice Emitted when the pause is lifted by `account`.\r\n    event Unpaused(address account);\r\n\r\n    function paused() external returns (bool);\r\n}\r\n\r\ncontract Pausable is IPausable {\r\n    bool public override paused;\r\n\r\n    // Modifiers\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Initializes the contract in unpaused state.\r\n    constructor(bool paused_) {\r\n        paused = paused_;\r\n    }\r\n\r\n    // ============ Internal Functions ============\r\n\r\n    function _pause() internal whenNotPaused {\r\n        paused = true;\r\n\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    function _unpause() internal whenPaused {\r\n        paused = false;\r\n\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/distribution/DistributionProxy.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title DistributionProxy\r\n * @author MirrorXYZ\r\n */\r\ncontract DistributionProxy is\r\n    BeaconStorage,\r\n    Governable,\r\n    DistributionStorage,\r\n    Pausable\r\n{\r\n    constructor(\r\n        address beacon_,\r\n        address owner_,\r\n        address team_,\r\n        address token_,\r\n        bytes32 rootNode_,\r\n        address ensRegistry_,\r\n        address treasury_\r\n    )\r\n        BeaconStorage(beacon_)\r\n        Governable(owner_)\r\n        DistributionStorage(rootNode_, ensRegistry_)\r\n        Pausable(true)\r\n    {\r\n        // Initialize the logic, supplying initialization calldata.\r\n        team = team_;\r\n        token = token_;\r\n        treasury = treasury_;\r\n    }\r\n\r\n    fallback() external payable {\r\n        address logic = IBeacon(beacon).logic();\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let result := delegatecall(gas(), logic, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 {\r\n                revert(ptr, size)\r\n            }\r\n            default {\r\n                return(ptr, size)\r\n            }\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beacon_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"team_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"rootNode_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"ensRegistry_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasury_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"awards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"banned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor_\",\"type\":\"address\"}],\"name\":\"changeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ensRegistry\",\"outputs\":[{\"internalType\":\"contract IENS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimablePerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNextOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registered\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registeredMembers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registrationReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootNode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DistributionProxy", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "00000000000000000000000025f4da52b8fcd80b38df63733e2406ddc2303d2b0000000000000000000000002330ee705ffd040bb0cba8cb7734dfe00e7c4b570000000000000000000000002330ee705ffd040bb0cba8cb7734dfe00e7c4b57000000000000000000000000b19d71a47569653e2069ac33d9d654e2eaabdb7f1aaf79d9b3323ad0212f6a2f34f8c627d8d45e45a55c774d080e3077334bfad900000000000000000000000000000000000c2e074ec69a0dfb2997ba6c7d2e1e000000000000000000000000138c3d30a724de380739aad9ec94e59e613a9008", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "1", "Implementation": "0x0ab831c39b9fc84be007bd008e5dd0e3380445eb", "SwarmSource": "ipfs://bbec471c3704aac83e5b92b3823ff13a9e0e7609b97c696064a8597b5aaaa68f"}]}