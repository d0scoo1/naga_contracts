{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity 0.5.14;\r\n\r\n\r\n/**\r\n * @notice Bitmap library to set or unset bits on bitmap value\r\n */\r\nlibrary BitmapLib {\r\n\r\n    /**\r\n     * @dev Sets the given bit in the bitmap value\r\n     * @param _bitmap Bitmap value to update the bit in\r\n     * @param _index Index range from 0 to 127\r\n     * @return Returns the updated bitmap value\r\n     */\r\n    function setBit(uint128 _bitmap, uint8 _index) internal pure returns (uint128) {\r\n        // Suppose `_bitmap` is in bit value:\r\n        // 0001 0100 = represents third(_index == 2) and fifth(_index == 4) bit is set\r\n\r\n        // Bit not set, hence, set the bit\r\n        if( ! isBitSet(_bitmap, _index)) {\r\n            // Suppose `_index` is = 3 = 4th bit\r\n            // mask = 0000 1000 = Left shift to create mask to find 4rd bit status\r\n            uint128 mask = uint128(1) << _index;\r\n\r\n            // Setting the corrospending bit in _bitmap\r\n            // Performing OR (|) operation\r\n            // 0001 0100 (_bitmap)\r\n            // 0000 1000 (mask)\r\n            // -------------------\r\n            // 0001 1100 (result)\r\n            return _bitmap | mask;\r\n        }\r\n\r\n        // Bit already set, just return without any change\r\n        return _bitmap;\r\n    }\r\n\r\n    /**\r\n     * @dev Unsets the bit in given bitmap\r\n     * @param _bitmap Bitmap value to update the bit in\r\n     * @param _index Index range from 0 to 127\r\n     * @return Returns the updated bitmap value\r\n     */\r\n    function unsetBit(uint128 _bitmap, uint8 _index) internal pure returns (uint128) {\r\n        // Suppose `_bitmap` is in bit value:\r\n        // 0001 0100 = represents third(_index == 2) and fifth(_index == 4) bit is set\r\n\r\n        // Bit is set, hence, unset the bit\r\n        if(isBitSet(_bitmap, _index)) {\r\n            // Suppose `_index` is = 2 = 3th bit\r\n            // mask = 0000 0100 = Left shift to create mask to find 3rd bit status\r\n            uint128 mask = uint128(1) << _index;\r\n\r\n            // Performing Bitwise NOT(~) operation\r\n            // 1111 1011 (mask)\r\n            mask = ~mask;\r\n\r\n            // Unsetting the corrospending bit in _bitmap\r\n            // Performing AND (&) operation\r\n            // 0001 0100 (_bitmap)\r\n            // 1111 1011 (mask)\r\n            // -------------------\r\n            // 0001 0000 (result)\r\n            return _bitmap & mask;\r\n        }\r\n\r\n        // Bit not set, just return without any change\r\n        return _bitmap;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the corrosponding bit set in the bitmap\r\n     * @param _bitmap Bitmap value to check\r\n     * @param _index Index to check. Index range from 0 to 127\r\n     * @return Returns true if bit is set, false otherwise\r\n     */\r\n    function isBitSet(uint128 _bitmap, uint8 _index) internal pure returns (bool) {\r\n        require(_index < 128, \"Index out of range for bit operation\");\r\n        // Suppose `_bitmap` is in bit value:\r\n        // 0001 0100 = represents third(_index == 2) and fifth(_index == 4) bit is set\r\n\r\n        // Suppose `_index` is = 2 = 3th bit\r\n        // 0000 0100 = Left shift to create mask to find 3rd bit status\r\n        uint128 mask = uint128(1) << _index;\r\n\r\n        // Example: When bit is set:\r\n        // Performing AND (&) operation\r\n        // 0001 0100 (_bitmap)\r\n        // 0000 0100 (mask)\r\n        // -------------------------\r\n        // 0000 0100 (bitSet > 0)\r\n\r\n        // Example: When bit is not set:\r\n        // Performing AND (&) operation\r\n        // 0001 0100 (_bitmap)\r\n        // 0000 1000 (mask)\r\n        // -------------------------\r\n        // 0000 0000 (bitSet == 0)\r\n\r\n        uint128 bitSet = _bitmap & mask;\r\n        // Bit is set when greater than zero, else not set\r\n        return bitSet > 0;\r\n    }\r\n}", "ABI": "[]", "ContractName": "BitmapLib", "CompilerVersion": "v0.5.14+commit.01f1aaa4", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv2.1", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://bff4b4370913d30fcc9365152a88c9ee5635e0890f33fe5a91e0492f5136ff64"}]}