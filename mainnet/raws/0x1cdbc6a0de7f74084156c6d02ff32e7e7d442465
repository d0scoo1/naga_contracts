{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Gachapon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM`MMM NMM MMM MMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMhMMMMMMM  MMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMM  MM-MMMMM   MMMM    MMMM   lMMMDMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMM jMMMMl   MM    MMM  M  MMM   M   MMMM MMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMM MMMMMMMMM  , `     M   Y   MM  MMM  BMMMMMM MMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMM MMMMMMMMMMMM  IM  MM  l  MMM  X   MM.  MMMMMMMMMM MMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.nlMMMMMMMMMMMMMMMMM]._  MMMMMMMMMMMMMMMNMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMM TMMMMMMMMMMMMMMMMMM          +MMMMMMMMMMMM:  rMMMMMMMMN MMMMMMMMMMMMMM\\n// MMMMMMMMMMMM MMMMMMMMMMMMMMMM                  MMMMMM           MMMMMMMM qMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMM^                   MMMb              .MMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMM MMMMMMMMMMMMMMM                     MM                  MMMMMMM MMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMM                     M                   gMMMMMMMMMMMMMMMMM\\n// MMMMMMMMu MMMMMMMMMMMMMMM                                           MMMMMMM .MMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMM                                           :MMMMMMMMMMMMMMMM\\n// MMMMMMM^ MMMMMMMMMMMMMMMl                                            MMMMMMMM MMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMM                                             MMMMMMMMMMMMMMMM\\n// MMMMMMM MMMMMMMMMMMMMMMM                                             MMMMMMMM MMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMM                                             MMMMMMMMMMMMMMMM\\n// MMMMMMr MMMMMMMMMMMMMMMM                                             MMMMMMMM .MMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMM                                           MMMMMMMMMMMMMMMMM\\n// MMMMMMM MMMMMMMMMMMMMMMMM                                         DMMMMMMMMMM MMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMM                              MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMM|`MMMMMMMMMMMMMMMM         q                      MMMMMMMMMMMMMMMMMMM  MMMMMMM\\n// MMMMMMMMMTMMMMMMMMMMMMMMM                               qMMMMMMMMMMMMMMMMMMgMMMMMMMMM\\n// MMMMMMMMq MMMMMMMMMMMMMMMh                             jMMMMMMMMMMMMMMMMMMM nMMMMMMMM\\n// MMMMMMMMMM MMMMMMMMMMMMMMMQ      nc    -MMMMMn        MMMMMMMMMMMMMMMMMMMM MMMMMMMMMM\\n// MMMMMMMMMM.MMMMMMMMMMMMMMMMMMl            M1       `MMMMMMMMMMMMMMMMMMMMMMrMMMMMMMMMM\\n// MMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMM               :MMMMMMMMMM MMMMMMMMMMMM qMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMMMX       MMMMMMMMMMMMMMM  uMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMM DMMMMMMMMM   IMMMMMMMMMMMMMMMMMMMMMMM   M   Y  MMMMMMMN MMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMM MMMMMM    ``    M      MM  MMM   , MMMM    Mv  MMM MMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMM MMh  Ml  .   M  MMMM  I  MMMT  M     :M   ,MMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMM MMMMMMMMt  MM  MMMMB m  ]MMM  MMMM   MMMMMM MMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMM MMMMM  MMM   TM   MM  9U  .MM  _MMMMM MMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMM YMMMMMMMn     MMMM    +MMMMMMM1`MMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.`MMM MMM MMMMM`.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM author: phaze MMM\\n\\nimport {Strings} from \\\"../lib/openzeppelin-contracts/contracts/utils/Strings.sol\\\";\\nimport {IERC20} from \\\"../lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\\\";\\nimport {IERC721} from \\\"../lib/openzeppelin-contracts/contracts/interfaces/IERC721.sol\\\";\\nimport {IERC721Metadata} from \\\"../lib/openzeppelin-contracts/contracts/interfaces/IERC721Metadata.sol\\\";\\n\\nimport {IGouda, IMadMouse} from \\\"./lib/interfaces.sol\\\";\\nimport {Ownable} from \\\"./lib/Ownable.sol\\\";\\nimport {Choice} from \\\"./lib/Choice.sol\\\";\\n\\nimport {SoulboundTickets as Tickets} from \\\"./SoulboundTickets.sol\\\";\\n\\nerror RaffleNotActive();\\nerror RaffleOngoing();\\nerror RaffleRandomSeedSet();\\nerror RaffleAlreadyCancelled();\\nerror TicketsMaxSupplyReached();\\n\\nerror RaffleUnrevealed();\\nerror PrizeAlreadyClaimed();\\n\\nerror BetterLuckNextTime();\\nerror MachineBeDoinWork();\\nerror NeedsMoarTickets();\\nerror TicketsImplementationUnset();\\nerror InvalidTimestamps();\\nerror InvalidTicketPrice();\\nerror RequirementNotFulfilled();\\n\\nerror ContractCallNotAllowed();\\n\\ncontract Gachapon is Ownable {\\n    using Strings for uint256;\\n\\n    event Chachingg();\\n    event GrappleGrapple();\\n    event BZZzzt();\\n\\n    struct Raffle {\\n        address prizeNFT;\\n        uint40 start;\\n        uint40 end;\\n        uint16 ticketPrice; // in multiples of 1e18\\n        // first slot\\n        uint16 ticketSupply;\\n        uint16 maxTicketSupply;\\n        uint8 refundRate; // set in range [0, 2^8 - 1] (0, 100%)\\n        uint8 requirement;\\n        bool cancelled;\\n        uint40 randomSeed;\\n        address tickets;\\n        // second slot\\n        uint32[] prizeTokenIds;\\n    }\\n\\n    string ticketURI = \\\"ipfs://QmSwrzsySKnkQmRQoZYmZ2XuJx3NMn2awdHwf1fezAJbq3/silver-ticket.json\\\";\\n    string losingTicketURI = \\\"ipfs://QmSwrzsySKnkQmRQoZYmZ2XuJx3NMn2awdHwf1fezAJbq3/red-ticket.json\\\";\\n    string winningTicketURI = \\\"ipfs://QmSwrzsySKnkQmRQoZYmZ2XuJx3NMn2awdHwf1fezAJbq3/gold-ticket.json\\\";\\n\\n    address ticketsImplementation;\\n\\n    uint256 public numRaffles;\\n    mapping(uint256 => Raffle) private raffles;\\n    mapping(address => uint256) public ticketsToRaffleId;\\n    mapping(uint256 => uint256) requestIdToLot;\\n\\n    mapping(uint256 => mapping(uint256 => bool)) public claimedPrize;\\n\\n    uint256 constant ONE_MONTH = 3600 * 24 * 28;\\n\\n    IGouda constant gouda = IGouda(0x3aD30C5E3496BE07968579169a96f00D56De4C1A);\\n    IMadMouse constant genesis = IMadMouse(0x3aD30c5e2985e960E89F4a28eFc91BA73e104b77);\\n    IMadMouse constant troupe = IMadMouse(0x74d9d90a7fc261FBe92eD47B606b6E0E00d75E70);\\n\\n    /* ------------- External ------------- */\\n\\n    function buyTicket(uint256 raffleId, uint256 requirementData) external noContract {\\n        unchecked {\\n            Raffle storage raffle = raffles[raffleId];\\n            uint256 ticketSupply = raffle.ticketSupply;\\n\\n            if (ticketSupply == raffle.maxTicketSupply) revert TicketsMaxSupplyReached();\\n            if (block.timestamp < raffle.start || raffle.end < block.timestamp || raffle.cancelled)\\n                revert RaffleNotActive();\\n\\n            uint256 requirement = raffle.requirement;\\n            if (requirement != 0 && !fulfillsRequirement(msg.sender, requirement, requirementData))\\n                revert RequirementNotFulfilled();\\n\\n            // verifies ownership\\n            gouda.burnFrom(msg.sender, uint256(raffle.ticketPrice) * 1e18);\\n\\n            uint256 ticketId = ++ticketSupply;\\n            raffle.ticketSupply = uint16(ticketSupply);\\n\\n            Tickets(raffle.tickets).mint(msg.sender, ticketId);\\n        }\\n    }\\n\\n    function claimPrize(uint256 raffleId, uint256 ticketId) external noContract {\\n        Raffle storage raffle = raffles[raffleId];\\n        Tickets tickets = Tickets(raffle.tickets);\\n\\n        uint256 randomSeed = raffle.randomSeed;\\n\\n        if (raffle.cancelled) revert RaffleNotActive();\\n        if (randomSeed == 0) revert RaffleUnrevealed();\\n\\n        uint256 numPrizes = raffle.prizeTokenIds.length;\\n        uint256 numEntries = raffle.ticketSupply;\\n        bool win;\\n        uint256 prizeId;\\n\\n        // ticketId starts at 1; ownerOf is checked, so underflow is no issue\\n        unchecked {\\n            (win, prizeId) = Choice.indexOfSelectNOfM(ticketId - 1, numPrizes, numEntries, randomSeed);\\n        }\\n\\n        if (tickets.ownerOf(ticketId) != msg.sender || !win) revert BetterLuckNextTime();\\n\\n        uint256 prizeTokenId = raffle.prizeTokenIds[prizeId];\\n\\n        // encode whether the user has claimed in with the tokenId by setting the first bit; saves a cold sload/sstore\\n        if (prizeTokenId > 0x7fffffff) revert PrizeAlreadyClaimed();\\n        raffle.prizeTokenIds[prizeId] = uint32(prizeTokenId) | 0x80000000;\\n\\n        IERC721 prizeNFT = IERC721(raffle.prizeNFT);\\n        prizeNFT.transferFrom(owner(), msg.sender, prizeTokenId & 0x0fffffff);\\n    }\\n\\n    function burnTickets(uint256[] calldata burnRaffleIds, uint256[] calldata burnTicketIds) external noContract {\\n        Raffle storage raffle;\\n\\n        uint256 refund;\\n        uint256 refundRate;\\n\\n        uint256 numBurnTickets = burnTicketIds.length;\\n        if (numBurnTickets == 0) revert NeedsMoarTickets();\\n\\n        unchecked {\\n            for (uint256 i; i < numBurnTickets; ++i) {\\n                raffle = raffles[burnRaffleIds[i]];\\n                Tickets tickets = Tickets(raffle.tickets);\\n\\n                tickets.burnFrom(msg.sender, burnTicketIds[i]);\\n\\n                refundRate = raffle.refundRate;\\n                // type(uint40).max * 1e18 * type(uint8).max < type(uint256).max\\n                if (refundRate > 0) refund += (uint256(raffle.ticketPrice) * 1e18 * (refundRate + 1)) >> 8; // slight imprecission is ok\\n            }\\n        }\\n\\n        gouda.mint(msg.sender, refund);\\n    }\\n\\n    /* ------------- View ------------- */\\n\\n    function isWinningTicket(uint256 raffleId, uint256 ticketId) public view returns (bool win) {\\n        Raffle storage raffle = raffles[raffleId];\\n        uint256 randomSeed = raffle.randomSeed;\\n\\n        if (raffle.cancelled || randomSeed == 0) return false;\\n\\n        uint256 numPrizes = raffle.prizeTokenIds.length;\\n        uint256 numEntrants = raffle.ticketSupply;\\n\\n        unchecked {\\n            (win, ) = Choice.indexOfSelectNOfM(ticketId - 1, numPrizes, numEntrants, randomSeed);\\n        }\\n        return win;\\n    }\\n\\n    function getWinningTickets(uint256 raffleId) public view returns (uint256[] memory ticketIds) {\\n        Raffle storage raffle = raffles[raffleId];\\n\\n        uint256 randomSeed = raffle.randomSeed;\\n\\n        if (raffle.cancelled || randomSeed == 0) return ticketIds;\\n\\n        uint256 numPrizes = raffle.prizeTokenIds.length;\\n        uint256 numEntrants = raffle.ticketSupply;\\n\\n        return Choice.selectNOfM(numPrizes, numEntrants, randomSeed, 1);\\n    }\\n\\n    function getWinners(uint256 raffleId) public view returns (address[] memory winners) {\\n        Tickets tickets = Tickets(raffles[raffleId].tickets);\\n\\n        uint256[] memory prizeTokenIds = getWinningTickets(raffleId);\\n        uint256 numIds = prizeTokenIds.length;\\n\\n        winners = new address[](numIds);\\n        for (uint256 i; i < numIds; ++i) winners[i] = tickets.ownerOf(prizeTokenIds[i]);\\n    }\\n\\n    function getRaffle(uint256 raffleId) external view returns (Raffle memory) {\\n        return raffles[raffleId];\\n    }\\n\\n    function fulfillsRequirement(\\n        address user,\\n        uint256 requirement,\\n        uint256 data\\n    ) public view returns (bool) {\\n        unchecked {\\n            if (requirement == 1 && genesis.numOwned(user) > 0) return true;\\n            else if (requirement == 2 && troupe.numOwned(user) > 0) return true;\\n            else if (\\n                requirement == 3 &&\\n                // specify data == 1 to direct that user is holding troupe and potentially save an sload;\\n                // or leave unspecified and worst-case check both\\n                ((data != 2 && troupe.numOwned(user) > 0) || (data != 1 && genesis.numOwned(user) > 0))\\n            ) return true;\\n            else if (\\n                requirement == 4 &&\\n                (\\n                    data > 5000 // specify owner-held id: data > 5000 refers to genesis collection\\n                        ? genesis.getLevel(data - 5000) > 1 && genesis.ownerOf(data - 5000) == user\\n                        : troupe.getLevel(data) > 1 && troupe.ownerOf(data) == user\\n                )\\n            ) return true;\\n            else if (\\n                requirement == 5 &&\\n                (\\n                    data > 5000\\n                        ? genesis.getLevel(data - 5000) > 2 && genesis.ownerOf(data - 5000) == user\\n                        : troupe.getLevel(data) > 2 && troupe.ownerOf(data) == user\\n                )\\n            ) return true;\\n            return false;\\n        }\\n    }\\n\\n    /* ------------- Tickets Callbacks ------------- */\\n\\n    function ticketsSupply() external view returns (uint256) {\\n        uint256 raffleId = ticketsToRaffleId[msg.sender];\\n        return raffles[raffleId].ticketSupply;\\n    }\\n\\n    function ticketsName() external view returns (string memory) {\\n        uint256 raffleId = ticketsToRaffleId[msg.sender];\\n        string memory prizeNFTName = IERC721Metadata(raffles[raffleId].prizeNFT).name();\\n        return string.concat(\\\"Gouda Slot Machine Raffle #\\\", raffleId.toString(), \\\": \\\", prizeNFTName);\\n    }\\n\\n    function ticketsSymbol() external view returns (string memory) {\\n        uint256 raffleId = ticketsToRaffleId[msg.sender];\\n        return string.concat(\\\"GRAFF\\\", raffleId.toString());\\n    }\\n\\n    function ticketsTokenURI(uint256 id) external view returns (string memory) {\\n        uint256 raffleId = ticketsToRaffleId[msg.sender];\\n        return\\n            raffles[raffleId].randomSeed != 0\\n                ? isWinningTicket(raffleId, id) ? winningTicketURI : losingTicketURI\\n                : ticketURI;\\n    }\\n\\n    /* ------------- Owner ------------- */\\n\\n    function feedToys(\\n        address prizeNFT,\\n        uint32[] calldata prizeTokenIds,\\n        uint40 start,\\n        uint40 end,\\n        uint16 ticketPrice,\\n        uint8 refundRate,\\n        uint16 maxTicketSupply,\\n        uint8 requirement\\n    ) external onlyOwner {\\n        unchecked {\\n            // don't transfer to contract to save gas\\n            // need to make sure that contract has allowance to transfer NFTs of owner\\n            // for (uint256 i; i < prizeTokenIds.length; ++i)\\n            //     IERC721(prizeNFT).transferFrom(msg.sender, address(this), prizeTokenIds[i]);\\n\\n            uint256 raffleId = ++numRaffles;\\n            Raffle storage raffle = raffles[raffleId];\\n\\n            if (ticketPrice >= 1e18) revert InvalidTicketPrice(); // sanity check, since ticketPrice is kept in multiples of 1e18\\n            if (ticketsImplementation == address(0)) revert TicketsImplementationUnset();\\n            if (ONE_MONTH < start - block.timestamp || ONE_MONTH < end - start) revert InvalidTimestamps(); // underflow desired\\n\\n            address tickets = createTicketsClone(ticketsImplementation);\\n            ticketsToRaffleId[tickets] = raffleId;\\n\\n            raffle.tickets = tickets;\\n            raffle.prizeNFT = prizeNFT;\\n            raffle.prizeTokenIds = prizeTokenIds;\\n            raffle.start = start;\\n            raffle.end = end;\\n            raffle.ticketPrice = ticketPrice;\\n            raffle.refundRate = refundRate;\\n            raffle.maxTicketSupply = maxTicketSupply;\\n            raffle.requirement = requirement;\\n\\n            emit Chachingg();\\n        }\\n    }\\n\\n    // should normally be ignored\\n    function incrementRaffleId(uint256 num) external onlyOwner {\\n        numRaffles += num;\\n    }\\n\\n    function editRaffle(\\n        uint256 raffleId,\\n        address prizeNFT,\\n        uint32[] calldata prizeTokenIds,\\n        uint40 start,\\n        uint40 end,\\n        uint16 ticketPrice,\\n        uint8 refundRate,\\n        uint16 maxTicketSupply,\\n        uint8 requirement,\\n        bool cancelled\\n    ) external onlyOwner {\\n        unchecked {\\n            if (ticketPrice >= 1e18) revert InvalidTicketPrice();\\n            if (block.timestamp + ONE_MONTH < start || ONE_MONTH < end - start) revert InvalidTimestamps();\\n\\n            Raffle storage raffle = raffles[raffleId];\\n\\n            raffle.prizeNFT = prizeNFT;\\n            raffle.prizeTokenIds = prizeTokenIds;\\n            raffle.start = start;\\n            raffle.end = end;\\n            raffle.ticketPrice = ticketPrice;\\n            raffle.refundRate = refundRate;\\n            raffle.maxTicketSupply = maxTicketSupply;\\n            raffle.requirement = requirement;\\n            raffle.cancelled = cancelled;\\n        }\\n    }\\n\\n    function rescueToys(IERC721 toy, uint256[] calldata toyIds) external onlyOwner {\\n        unchecked {\\n            for (uint256 i; i < toyIds.length; ++i) toy.transferFrom(address(this), msg.sender, toyIds[i]);\\n        }\\n    }\\n\\n    function rescueERC20(IERC20 token) external onlyOwner {\\n        token.transfer(msg.sender, token.balanceOf(address(this)));\\n    }\\n\\n    function triggerClaw(uint256 raffleId) external onlyOwner {\\n        Raffle storage raffle = raffles[raffleId];\\n\\n        if (raffle.cancelled) revert RaffleNotActive();\\n        if (block.timestamp < raffle.end) revert RaffleOngoing();\\n        if (raffle.randomSeed != 0) revert MachineBeDoinWork();\\n\\n        emit GrappleGrapple();\\n        emit BZZzzt();\\n\\n        raffle.randomSeed = uint40(uint256(blockhash(block.number - 1)));\\n    }\\n\\n    function setTicketsImplementation(address ticketsImplementation_) external onlyOwner {\\n        ticketsImplementation = ticketsImplementation_;\\n    }\\n\\n    function setTicketURIs(\\n        string calldata ticketURI_,\\n        string calldata losingTicketURI_,\\n        string calldata winningTicketURI_\\n    ) external onlyOwner {\\n        ticketURI = ticketURI_;\\n        losingTicketURI = losingTicketURI_;\\n        winningTicketURI = winningTicketURI_;\\n    }\\n\\n    /* ------------- Private ------------- */\\n\\n    // https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol\\n    function createTicketsClone(address target) private returns (address result) {\\n        bytes20 targetBytes = bytes20(target);\\n        assembly {\\n            let clone := mload(0x40)\\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(clone, 0x14), targetBytes)\\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            result := create(0, clone, 0x37)\\n        }\\n    }\\n\\n    /* ------------- Modifier ------------- */\\n\\n    modifier noContract() {\\n        if (msg.sender != tx.origin) revert ContractCallNotAllowed();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/extensions/IERC721Metadata.sol\\\";\\n\"\r\n    },\r\n    \"src/lib/interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\ninterface IGouda {\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function transfer(address to, uint256 amount) external;\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function mint(address user, uint256 amount) external;\\n\\n    function burnFrom(address account, uint256 amount) external;\\n}\\n\\ninterface IMadMouse {\\n    function numStaked(address user) external view returns (uint256);\\n\\n    function numOwned(address user) external view returns (uint256);\\n\\n    function balanceOf(address user) external view returns (uint256);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n\\n    function getLevel(uint256 tokenId) external view returns (uint256);\\n\\n    function getDNA(uint256 tokenId) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nerror CallerNotOwner();\\n\\nabstract contract Ownable {\\n    address _owner = msg.sender;\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        _owner = newOwner;\\n    }\\n\\n    modifier onlyOwner() {\\n        if (msg.sender != _owner) revert CallerNotOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/Choice.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\n// author: phaze\\n\\n// assumption: n << m\\n// caveats: splits random number into 16 parts for efficiency\\n// this means that 65536 is the highest random number\\n// (can skew uniform distributions when m is hight)\\nlibrary Choice {\\n    function selectNOfM(\\n        uint256 n,\\n        uint256 m,\\n        uint256 r\\n    ) internal pure returns (uint256[] memory) {\\n        unchecked {\\n            if (n > m) n = m;\\n\\n            uint256[] memory choice = new uint256[](n);\\n\\n            uint256 s;\\n            uint256 slot;\\n\\n            uint256 j;\\n            uint256 c;\\n\\n            bool invalidChoice;\\n\\n            for (uint256 i; i < n; ++i) {\\n                do {\\n                    slot = (s & 0xF) << 4;\\n                    if (slot == 0 && i != 0) r = uint256(keccak256(abi.encode(r, s)));\\n                    c = ((r >> slot) & 0xFFFF) % m;\\n                    invalidChoice = false;\\n                    for (j = 0; j < i && !invalidChoice; ++j) invalidChoice = choice[j] == c;\\n                    ++s;\\n                } while (invalidChoice);\\n\\n                choice[i] = c;\\n            }\\n            return choice;\\n        }\\n    }\\n\\n    function selectNOfM(\\n        uint256 n,\\n        uint256 m,\\n        uint256 r,\\n        uint256 offset\\n    ) internal pure returns (uint256[] memory) {\\n        unchecked {\\n            if (n > m) n = m;\\n\\n            uint256[] memory choice = new uint256[](n);\\n\\n            uint256 s;\\n            uint256 slot;\\n\\n            uint256 j;\\n            uint256 c;\\n\\n            bool invalidChoice;\\n\\n            for (uint256 i; i < n; ++i) {\\n                do {\\n                    slot = (s & 0xF) << 4;\\n                    if (slot == 0 && i != 0) r = uint256(keccak256(abi.encode(r, s)));\\n                    c = (((r >> slot) & 0xFFFF) % m) + offset;\\n                    invalidChoice = false;\\n                    for (j = 0; j < i && !invalidChoice; ++j) invalidChoice = choice[j] == c;\\n                    ++s;\\n                } while (invalidChoice);\\n\\n                choice[i] = c;\\n            }\\n            return choice;\\n        }\\n    }\\n\\n    function indexOfSelectNOfM(\\n        uint256 x,\\n        uint256 n,\\n        uint256 m,\\n        uint256 r\\n    ) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (n > m) n = m;\\n\\n            uint256[] memory choice = new uint256[](n);\\n\\n            uint256 s;\\n            uint256 slot;\\n\\n            uint256 j;\\n            uint256 c;\\n\\n            bool invalidChoice;\\n\\n            for (uint256 i; i < n; ++i) {\\n                do {\\n                    slot = (s & 0xF) << 4;\\n                    if (slot == 0 && i != 0) r = uint256(keccak256(abi.encode(r, s)));\\n                    c = ((r >> slot) & 0xFFFF) % m;\\n                    invalidChoice = false;\\n                    for (j = 0; j < i && !invalidChoice; ++j) invalidChoice = choice[j] == c;\\n                    ++s;\\n                } while (invalidChoice);\\n\\n                if (x == c) return (true, i);\\n\\n                choice[i] = c;\\n            }\\n            return (false, 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/SoulboundTickets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM`MMM NMM MMM MMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMhMMMMMMM  MMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMM  MM-MMMMM   MMMM    MMMM   lMMMDMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMM jMMMMl   MM    MMM  M  MMM   M   MMMM MMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMM MMMMMMMMM  , `     M   Y   MM  MMM  BMMMMMM MMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMM MMMMMMMMMMMM  IM  MM  l  MMM  X   MM.  MMMMMMMMMM MMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.nlMMMMMMMMMMMMMMMMM]._  MMMMMMMMMMMMMMMNMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMM TMMMMMMMMMMMMMMMMMM          +MMMMMMMMMMMM:  rMMMMMMMMN MMMMMMMMMMMMMM\\n// MMMMMMMMMMMM MMMMMMMMMMMMMMMM                  MMMMMM           MMMMMMMM qMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMM^                   MMMb              .MMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMM MMMMMMMMMMMMMMM                     MM                  MMMMMMM MMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMM                     M                   gMMMMMMMMMMMMMMMMM\\n// MMMMMMMMu MMMMMMMMMMMMMMM                                           MMMMMMM .MMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMM                                           :MMMMMMMMMMMMMMMM\\n// MMMMMMM^ MMMMMMMMMMMMMMMl                                            MMMMMMMM MMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMM                                             MMMMMMMMMMMMMMMM\\n// MMMMMMM MMMMMMMMMMMMMMMM                                             MMMMMMMM MMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMM                                             MMMMMMMMMMMMMMMM\\n// MMMMMMr MMMMMMMMMMMMMMMM                                             MMMMMMMM .MMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMM                                           MMMMMMMMMMMMMMMMM\\n// MMMMMMM MMMMMMMMMMMMMMMMM                                         DMMMMMMMMMM MMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMM                              MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMM|`MMMMMMMMMMMMMMMM         q                      MMMMMMMMMMMMMMMMMMM  MMMMMMM\\n// MMMMMMMMMTMMMMMMMMMMMMMMM                               qMMMMMMMMMMMMMMMMMMgMMMMMMMMM\\n// MMMMMMMMq MMMMMMMMMMMMMMMh                             jMMMMMMMMMMMMMMMMMMM nMMMMMMMM\\n// MMMMMMMMMM MMMMMMMMMMMMMMMQ      nc    -MMMMMn        MMMMMMMMMMMMMMMMMMMM MMMMMMMMMM\\n// MMMMMMMMMM.MMMMMMMMMMMMMMMMMMl            M1       `MMMMMMMMMMMMMMMMMMMMMMrMMMMMMMMMM\\n// MMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMM               :MMMMMMMMMM MMMMMMMMMMMM qMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMMMX       MMMMMMMMMMMMMMM  uMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMM DMMMMMMMMM   IMMMMMMMMMMMMMMMMMMMMMMM   M   Y  MMMMMMMN MMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMM MMMMMM    ``    M      MM  MMM   , MMMM    Mv  MMM MMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMM MMh  Ml  .   M  MMMM  I  MMMT  M     :M   ,MMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMM MMMMMMMMt  MM  MMMMB m  ]MMM  MMMM   MMMMMM MMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMM MMMMM  MMM   TM   MM  9U  .MM  _MMMMM MMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMM YMMMMMMMn     MMMM    +MMMMMMM1`MMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.`MMM MMM MMMMM`.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM author: phaze MMM\\n\\nimport {Gachapon} from \\\"./Gachapon.sol\\\";\\n\\nerror CallerNotOwner();\\nerror CallerNotApproved();\\nerror CallerNotOwnerNorApproved();\\n\\nerror MintExceedsLimit();\\n\\nerror TransferFromIncorrectOwner();\\nerror TransferToNonERC721Receiver();\\nerror TransferToZeroAddress();\\n\\nerror BurnFromIncorrectOwner();\\n\\ncontract SoulboundTickets {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    mapping(uint256 => address) public ownerOf;\\n    mapping(address => uint256) public balanceOf;\\n    mapping(uint256 => address) public getApproved;\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    Gachapon immutable gachapon;\\n\\n    constructor(Gachapon gachapon_) {\\n        gachapon = gachapon_;\\n    }\\n\\n    /* ------------- View ------------- */\\n\\n    function tokenURI(uint256 id) external view returns (string memory) {\\n        return gachapon.ticketsTokenURI(id);\\n    }\\n\\n    function name() external view returns (string memory) {\\n        return gachapon.ticketsName();\\n    }\\n\\n    function symbol() external view returns (string memory) {\\n        return gachapon.ticketsSymbol();\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) external view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /* ------------- Restricted ------------- */\\n\\n    // @note assumes correct handling by master contract in order to save gas\\n    function mint(address to, uint256 id) external onlyGachapon {\\n        if (balanceOf[to] == 1) revert MintExceedsLimit();\\n\\n        ownerOf[id] = to;\\n\\n        unchecked {\\n            ++balanceOf[to];\\n        }\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function burnFrom(address from, uint256 id) external onlyGachapon {\\n        if (ownerOf[id] != from) revert BurnFromIncorrectOwner();\\n\\n        unchecked {\\n            --balanceOf[from];\\n        }\\n\\n        emit Transfer(from, address(0), id);\\n\\n        delete ownerOf[id];\\n    }\\n\\n    modifier onlyGachapon() {\\n        if (msg.sender != address(gachapon)) revert CallerNotApproved();\\n        _;\\n    }\\n\\n    /* ------------- O(N) Read Only ------------- */\\n\\n    function ticketIdOf(address user) external view returns (uint256) {\\n        unchecked {\\n            uint256 supply = gachapon.ticketsSupply() + 1;\\n            for (uint256 id; id < supply; ++id) if (ownerOf[id] == user) return id;\\n            return 0;\\n        }\\n    }\\n}\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"BetterLuckNextTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractCallNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTicketPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTimestamps\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MachineBeDoinWork\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NeedsMoarTickets\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrizeAlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RaffleNotActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RaffleOngoing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RaffleUnrevealed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequirementNotFulfilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TicketsImplementationUnset\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TicketsMaxSupplyReached\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"BZZzzt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Chachingg\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"GrappleGrapple\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"burnRaffleIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"burnTicketIds\",\"type\":\"uint256[]\"}],\"name\":\"burnTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requirementData\",\"type\":\"uint256\"}],\"name\":\"buyTicket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ticketId\",\"type\":\"uint256\"}],\"name\":\"claimPrize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimedPrize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"prizeNFT\",\"type\":\"address\"},{\"internalType\":\"uint32[]\",\"name\":\"prizeTokenIds\",\"type\":\"uint32[]\"},{\"internalType\":\"uint40\",\"name\":\"start\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"end\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"ticketPrice\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"refundRate\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"maxTicketSupply\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"requirement\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"cancelled\",\"type\":\"bool\"}],\"name\":\"editRaffle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"prizeNFT\",\"type\":\"address\"},{\"internalType\":\"uint32[]\",\"name\":\"prizeTokenIds\",\"type\":\"uint32[]\"},{\"internalType\":\"uint40\",\"name\":\"start\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"end\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"ticketPrice\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"refundRate\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"maxTicketSupply\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"requirement\",\"type\":\"uint8\"}],\"name\":\"feedToys\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requirement\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"fulfillsRequirement\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"}],\"name\":\"getRaffle\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"prizeNFT\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"start\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"end\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"ticketPrice\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"ticketSupply\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxTicketSupply\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"refundRate\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"requirement\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"cancelled\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"randomSeed\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"tickets\",\"type\":\"address\"},{\"internalType\":\"uint32[]\",\"name\":\"prizeTokenIds\",\"type\":\"uint32[]\"}],\"internalType\":\"struct Gachapon.Raffle\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"}],\"name\":\"getWinners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"winners\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"}],\"name\":\"getWinningTickets\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ticketIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"incrementRaffleId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ticketId\",\"type\":\"uint256\"}],\"name\":\"isWinningTicket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"win\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numRaffles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rescueERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"toy\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"toyIds\",\"type\":\"uint256[]\"}],\"name\":\"rescueToys\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ticketURI_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"losingTicketURI_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"winningTicketURI_\",\"type\":\"string\"}],\"name\":\"setTicketURIs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ticketsImplementation_\",\"type\":\"address\"}],\"name\":\"setTicketsImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketsName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketsSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketsSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ticketsToRaffleId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ticketsTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"}],\"name\":\"triggerClaw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Gachapon", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}