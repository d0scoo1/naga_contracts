{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n/*\r\n    OpenLuckyCryptoSimple\r\n    This software is a simple lucky game running on the Ethereum Blockchain Networks (Mainnet and Rinkeby).\r\n\r\n    The rules of this game are as the following:\r\n    1. You have to transfer a given amount of ETH to this contract or call the \"registerBet()\" function to get a position.\r\n        The amount is returned by calling the function \"getBetMinmumValue()\" (0.0005 ETH by default).\r\n        WANING: Bigger values don't give you more chances to win, so you should tranfer only the minimum value necessary.\r\n        If you want more chances, you can just make more bets.\r\n    2. Each transfer stays registered into the blockchain for a given period of time (you can see the time in seconds by calling the \"getGameInterval()\" function).\r\n        When a new bet is registered after that time, arbitrary bets will be selected to receive the prizes.\r\n        DISCLAIMER: Due to Ethereum Blockchain techinical features, it's posible to a miner to influency the results for a short period of time.\r\n        However, to force the algorithm to return a specific value is a extremely hard and costly job.\r\n    3. The balance received by the contract is divied in 3 pieces:\r\n        5% as reserve for the next game;\r\n        20% to fund this project;\r\n        75% distributed to the winners (aka PRIZE).\r\n    4. There are 3 ranges of winners:\r\n        1st: 1% of the bets will share 80% of the PRIZE;\r\n        2nd: 3% of the bets will share 15% of the PRIZE;\r\n        3rd: 6% of the bets will share 5% of the PRIZE.\r\n    \r\n    How are the winners selected?\r\n    All the bets are registered in one array into the blockchain.\r\n    When a bet is received after the game interval, an arbitrary number is selected representing the position of the bet in the array.\r\n    This position represents the first winner bet and the next positions will compose all the tree winners ranges.\r\n    Eg.: Let's suppose a game with 1000 bets, the arbitrary number is 950, the winners will be:\r\n        1st range: 10 winners (1% of the bets) - from position 950 to 959\r\n        2nd range: 30 winners (3% of the bets) - from position 960 to 989\r\n        3rd range: 60 winners (6% of the bets) - from position 990 to 49 (position go to start of the array if it gets the last possible position)\r\n*/\r\n\r\npragma solidity >= 0.8.0;\r\n\r\n\r\n/**\r\n * @title OpenLuckyCryptoSimple\r\n * @dev Receive the bets, make the arbitrary drawing and share the prizes\r\n */\r\ncontract OpenLuckyCryptoSimple {\r\n    bool private dbg;               // Debug flag\r\n    bool private locked;            // Flag used to avoid array collisions\r\n    uint private max_int;           // Used to avoid uint overflows\r\n    bool private disabled;          // Flag used to suspend the game, is necessary for any reason\r\n    uint private game_interval;     // Seconds between each game round\r\n    uint private recursionDepth;    // Controls the depth of the arbitraryNumber() function\r\n    uint private last_game_time;    // Time mark to compute the next game round\r\n    uint8 constant postions = 30;   // Lastest bets from the bets array to generate the arbitrary numbers\r\n    uint private bet_mininum_value; // Ammount of wei necessary to register a Bet\r\n    address private owner;          // Address of the contract ownerOnly\r\n    address payable private wallet; // Address to store the funds for this project\r\n\r\n    // All bets registry for the current game.\r\n    // It'll be wiped everytime a new game start.\r\n    address[] private bets;\r\n\r\n    // Assert that only the owner executes restricted tasks\r\n    modifier ownerOnly() {\r\n        require(msg.sender == owner, \"Your are not allowed\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        locked = false;\r\n        owner = msg.sender;\r\n        wallet = payable(owner);\r\n        max_int = type(uint).max;\r\n        disableSystem(false);\r\n        setRecursionDepth(3);\r\n        setGameInterval(86400); // 1 day by default\r\n        setBetMinimumValue(500000 gwei); // 0.0005 ETH by default\r\n        setLastGameTime(block.timestamp); // Time mark to compute the next game time\r\n    }\r\n\r\n    function setDebug(bool _debug) public ownerOnly {\r\n        dbg = _debug;\r\n    }\r\n\r\n\r\n    // Logging facilities\r\n    event log(string text);\r\n    event log(string text, uint value);\r\n\r\n    // Debugger facilities\r\n    function debug(string memory text) private {\r\n        if (dbg)\r\n            emit log(text);\r\n    }\r\n\r\n    function debug(string memory text, uint value) private {\r\n        if (dbg)\r\n            emit log(text, value);\r\n    }\r\n    \r\n\r\n    function setLastGameTime(uint _last_game_time) private {\r\n        last_game_time = _last_game_time;\r\n    }\r\n\r\n    function getLastGameTime() private view returns (uint) {\r\n        return last_game_time;\r\n    }\r\n\r\n    // This function blocks all the system\r\n    // There is no plan to use this mechanism\r\n    // It exists to stop the transactions for debugging or other kind of problems\r\n    event evDisableSystem(bool disabled);\r\n    function disableSystem(bool _disabled) public ownerOnly {\r\n        emit evDisableSystem(_disabled);\r\n        disabled = _disabled;\r\n    }\r\n\r\n    // Allows the owner to set a different value for future bets\r\n    event evSetBetMinimumValue(uint min_value);\r\n    function setBetMinimumValue(uint _min_value) public ownerOnly {\r\n        emit evSetBetMinimumValue(_min_value);\r\n        bet_mininum_value = _min_value;\r\n    }\r\n\r\n    // Defines the recusion depth for the arbitrary number generator\r\n    event evSetRecursionDepth(uint8 recursionDepth);\r\n    function setRecursionDepth(uint8 _recursionDepth) public ownerOnly {\r\n        emit evSetBetMinimumValue(_recursionDepth);\r\n        recursionDepth = _recursionDepth;\r\n    }\r\n\r\n    // Allows the user to discover the current minimum bet value\r\n    function getBetMinimumValue() public view returns (uint) {\r\n        return bet_mininum_value;\r\n    }\r\n\r\n    // Changes the owner\r\n    event evSetOwner(address newOwner);\r\n    function setOwner(address _newOwner) public ownerOnly {\r\n        emit evSetOwner(_newOwner);\r\n        owner = _newOwner;\r\n    }\r\n\r\n    // Sets the interval between each game (in seconds)\r\n    event evSetGameInterval(uint interval);\r\n    function setGameInterval(uint interval) public ownerOnly {\r\n        require(interval >= 10, \"Minimum interval is 10s\");\r\n        emit evSetGameInterval(interval);\r\n        game_interval = interval;\r\n    }\r\n\r\n    // Allows the users to know when the next prizes will be shared and a new game will start\r\n    function nextGameTime(uint lastTime) private returns (uint) {\r\n        return lastTime + getGameInterval();\r\n    }\r\n\r\n    // Allows the users to know the interval between each game (in seconds)\r\n    function getGameInterval() public view returns (uint) {\r\n        return game_interval;\r\n    }\r\n\r\n    receive() external payable {\r\n        registerBet();\r\n    }\r\n\r\n    fallback() external payable {}\r\n\r\n    // Reset bets\r\n    function resetBets() private returns(bool) {\r\n        debug(\"Deleting all the previous bets\");\r\n        delete bets;\r\n        return true;\r\n    }\r\n\r\n    // Number generator\r\n    function arbitraryNumber(uint depth) private returns(uint) {\r\n        bytes32 stream;\r\n        uint n = numberOfBets();\r\n        if (n > postions) {\r\n            // Here, we create a copy of the last bets from the bets array (from blockchain)\r\n            // to generate input for the `arbitraryNumber` function\r\n            address[postions] memory payload;\r\n            uint start = n - 1 - postions;\r\n            for (uint c = 0; c < postions; c++) {\r\n                payload[c] = bets[start + c];\r\n            }\r\n            stream = keccak256(abi.encodePacked(payload));\r\n            delete payload; // wipe out the payload data\r\n        } else {\r\n            stream = keccak256(abi.encode(bets));\r\n        }\r\n\r\n        // Avoid attacks due to blockchain data changing\r\n        bytes memory liveData = abi.encodePacked(\r\n            (block.timestamp - getLastGameTime() + 1) * address(this).balance,\r\n            stream\r\n        );\r\n        return _arbitraryNumber(liveData, n, depth);\r\n    }\r\n\r\n\r\n    function _arbitraryNumber(bytes memory liveData, uint seed, uint depth) private returns(uint) {\r\n        if (depth > 0) {\r\n            depth--;\r\n            seed = _arbitraryNumber(liveData, seed, depth);\r\n        }\r\n\r\n        return uint(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    liveData,\r\n                    seed\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n\r\n    // Calc fund\r\n    function calcFund() private returns(uint) {\r\n        debug(\"calcFund 1\");\r\n        return address(this).balance / 10 * 2;\r\n    }\r\n\r\n    // Calc reserve\r\n    function calcReserve() private returns (uint) {\r\n        debug(\"calcReserve 1\");\r\n        return address(this).balance / 100 * 5;\r\n    }\r\n\r\n    // Calc prize total amount\r\n    function calcPrize() private returns (uint) {\r\n        debug(\"calcPrize 1\");\r\n        \r\n        // Save part of the balance for the next game\r\n        uint reserve = calcReserve();\r\n        debug(\"calcPrize 2\");\r\n\r\n        // Compute part of the balance to fund this project\r\n        uint fund = calcFund();\r\n        debug(\"calcPrize 3\");\r\n\r\n        // Prize value\r\n        return address(this).balance - reserve - fund;\r\n    }\r\n\r\n    function getBalance() public view ownerOnly returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    // Store fund\r\n    function storeFund(uint _fund) private returns (bool) {\r\n        debug(\"Storing funds\");\r\n        wallet.transfer(_fund);\r\n        return true;\r\n    }\r\n\r\n    // Verify if it time to share the prizes and start a new game\r\n    modifier checkGameTime () {\r\n        debug(\"checkGameTime 1\");\r\n        require(!disabled, \"The system is desabled. Please, try again later\");\r\n        require(!locked, \"We are closed to bets right now. Please, try again later\"); // Avoid array collisions\r\n        debug(\"checkGameTime 2\");\r\n\r\n        if(block.timestamp >= nextGameTime(getLastGameTime())){\r\n            debug(\"checkGameTime 3\");\r\n            locked = true;\r\n            sharePrize();\r\n            setNewGame();\r\n            locked = false;\r\n        }\r\n        _;\r\n    }\r\n\r\n    // Release the \"locked\" flag\r\n    // Only needed by a buggy scenario where the flag remains locked due to unknown errors\r\n    function forceUnlock() public ownerOnly {\r\n        debug(\"Forced unlock\");\r\n        locked = false;\r\n    }\r\n    \r\n    // Allows the users to know the number of bets\r\n    function numberOfBets() public view returns (uint) {\r\n        return bets.length;\r\n    }\r\n\r\n    // Setup new game\r\n    function setNewGame() private returns (bool) {\r\n        debug(\"Setting up a new game round\");\r\n        uint fund = calcFund();\r\n        storeFund(fund);\r\n        resetBets();\r\n        setLastGameTime(block.timestamp);\r\n        return true;\r\n    }\r\n\r\n    // Register a new bet\r\n    function registerBet() public payable checkGameTime {\r\n        debug(\"registerBet 1\");\r\n        require(\r\n            uint(msg.value) >= getBetMinimumValue(),\r\n            \"Bet must be greater that or equal to the value returned by the 'getBetMinmumValue()' function wei\"\r\n        );\r\n        bets.push(msg.sender);\r\n    }\r\n\r\n    // Share prize\r\n    event evSharePrize(uint _prizeAmount);\r\n    function sharePrize() private returns (bool) {\r\n\r\n        // Number of bets\r\n        uint n_bets = numberOfBets();\r\n        debug(\"sharePrize 1 - bets\", n_bets);\r\n\r\n        // Check if there is at leat one bet\r\n        if(n_bets == 0)\r\n            return(false);\r\n        debug(\"sharePrize 2 - bets > 0\");\r\n\r\n        // First winners range (1% of the players)\r\n        uint n_1 = n_bets >= 100 ? n_bets / 100 : 1;\r\n        debug(\"sharePrize 3 - no math problems\");\r\n\r\n        // Second winners range (3% of the players)\r\n        uint n_2;\r\n        if (n_bets > max_int / 3) { // Avoid uint overflow\r\n            n_2 = n_bets / 100 * 3; // Divide first to avoid overflow\r\n        } else {\r\n            n_2 = n_bets > 33 ?\r\n                n_bets * 3 / 100:   // Multiply first to avoid decimal precision cuts\r\n                1;                  // Garantee minimal of one winner in this range\r\n        }\r\n        debug(\"sharePrize 4 - no math problems\");\r\n\r\n        // Third winners range (6% of the players)\r\n        uint n_3;\r\n        if (n_bets > max_int / 6) { // Avoid uint overflow\r\n            n_3 = n_bets / 100 * 6; // Divide first to avoid overflow\r\n        } else {\r\n            n_3 = n_bets > 16 ?\r\n                n_bets * 6 / 100:   // Multiply first to avoid decimal precision cuts\r\n                1;                  // Garantee minimal of one winner in this range\r\n        }\r\n        debug(\"sharePrize 5 - no math problems\");\r\n\r\n\r\n        // Total prizes value\r\n        uint prize = calcPrize();\r\n        debug(\"sharePrize 6 - total prize\", prize);\r\n\r\n        // First range prize (80% of the total prize)\r\n        uint p_1 = prize / 10 * 8 / n_1;\r\n        emit log(\"1st range winners quantity\", n_1);\r\n        emit log(\"1st range total prize\", p_1);\r\n\r\n        // Guarantee the prize\r\n        if (p_1 == 0) {\r\n            emit log(\"No prize left\");\r\n            return(false);\r\n        }\r\n\r\n        // Second range prize (15% of the total prize)\r\n        uint p_2 = prize / 100 * 15 / n_2;\r\n        emit log(\"2nd range winners quantity\", n_2);\r\n        emit log(\"2nd range total prize\", p_2);\r\n\r\n        // Third range prize (5% of the total prize)\r\n        uint p_3 = prize / 100 * 5 / n_3;\r\n        emit log(\"3rd range winners quantity\", n_3);\r\n        emit log(\"3rd range total prize\", p_3);\r\n\r\n        // Get arbitary uint\r\n        uint r = arbitraryNumber(recursionDepth);\r\n        debug(\"sharePrize 7 - arbitrary number\", r);\r\n\r\n        // Select the position of the bets arrays\r\n        // to start giving the prize\r\n        uint win_mark = r > n_bets ? r % n_bets : n_bets % r;\r\n        debug(\"sharePrize 8 - winner position\", win_mark);\r\n\r\n        // Assert the value to a valid array position\r\n        if(win_mark >= n_bets)\r\n            win_mark = 0;\r\n\r\n        // First range receives prize\r\n        debug(\"sharePrize 9 - 1st range initial position\", win_mark);\r\n        uint nextRange = givePrizes(n_1, win_mark, p_1) + 1;\r\n\r\n        // Second range receives prize\r\n        debug(\"sharePrize 10 - 2nd range initial position\", nextRange);\r\n        if (p_2 > 0)\r\n            nextRange = givePrizes(n_2, nextRange, p_2) + 1;\r\n\r\n        // Third range receives prize\r\n        debug(\"sharePrize 11 - 3rd range initial position\", nextRange);\r\n        if (p_3 > 0)\r\n            givePrizes(n_3, nextRange, p_3);\r\n\r\n        // Happy winners!\r\n        debug(\"sharePrize 12 - finish\");\r\n        return(true);\r\n    }\r\n\r\n    event evGivePrizeError(address indexed player, uint prize, uint indexed time, bytes indexed message);\r\n    function givePrizes(uint n, uint position, uint prize) private returns (uint) {\r\n        if (prize == 0) {\r\n            emit evGivePrizeError(address(0), prize, block.timestamp, \"Not enough prize\");\r\n            return position;\r\n        }\r\n\r\n        if (n == 0) {\r\n            emit evGivePrizeError(address(0), prize, block.timestamp, \"No winners for this range\");\r\n            return position;\r\n        }\r\n\r\n        uint p;\r\n        uint n_bets = numberOfBets();\r\n        for(uint c = 0; c < n; c++) {\r\n            p = position + c;\r\n\r\n            // Avoid array out of range, restarting form position 0\r\n            if(p >= n_bets) {\r\n                n -= c;\r\n                position = 0;\r\n                p = 0;\r\n                c = 0;\r\n            }\r\n            \r\n\r\n            // Give prize to the winner\r\n            bool status = _givePrize(p, prize); // send() is less expensive than transfer()\r\n            if(status != true) {\r\n                emit evGivePrizeError(bets[p], prize, block.timestamp, \"Failed transferring the prize\");\r\n            }\r\n        }\r\n        \r\n\r\n        return p;\r\n    }\r\n\r\n    // Change wallet\r\n    event evChangeWallet(address indexed _owner, address indexed _oldWallet, address indexed _newWallet, uint time);\r\n    function changeWallet(address newWallet) public ownerOnly returns(address) {\r\n        emit evChangeWallet(owner, wallet, newWallet, block.timestamp);\r\n        wallet = payable(newWallet);\r\n        return wallet;\r\n    }\r\n\r\n    // Finish this contract forever and returns the prizes to the players.\r\n    // This may be necessary due to legal or security reasons\r\n    // We hope this will never happen...\r\n    event evGameOver(address indexed _owner, address indexed _wallet, uint _balance, uint timestamp, string comment);\r\n    function gameOver() public ownerOnly {\r\n        disableSystem(true);\r\n        uint n_bets = numberOfBets();\r\n        if (n_bets > 0) {\r\n            uint prize = calcPrize();\r\n            uint prize_per_bet = prize / n_bets;\r\n\r\n            // Return the prize to the players\r\n            for (uint c = 0; c < n_bets; c++) {\r\n                emit evGameOver(owner, bets[c], address(this).balance, block.timestamp, \"Returning prize...\");\r\n                if (_givePrize(c, prize_per_bet) == false) {\r\n                    emit evGameOver(owner, bets[c], address(this).balance, block.timestamp, \"Failed to return the prize.\");\r\n                }\r\n            }\r\n        }\r\n\r\n        emit evGameOver(owner, wallet, address(this).balance, block.timestamp, \"OpenLuckyCryptoSimple is dead.\");\r\n        selfdestruct(wallet);\r\n    }\r\n\r\n    function _givePrize(uint bet, uint prize) private returns(bool) {\r\n        return(payable(bets[bet]).send(prize));\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"evChangeWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"evDisableSystem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"comment\",\"type\":\"string\"}],\"name\":\"evGameOver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"evGivePrizeError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"min_value\",\"type\":\"uint256\"}],\"name\":\"evSetBetMinimumValue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"}],\"name\":\"evSetGameInterval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"evSetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"recursionDepth\",\"type\":\"uint8\"}],\"name\":\"evSetRecursionDepth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prizeAmount\",\"type\":\"uint256\"}],\"name\":\"evSharePrize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"text\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"text\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"log\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"changeWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_disabled\",\"type\":\"bool\"}],\"name\":\"disableSystem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameOver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBetMinimumValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGameInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfBets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registerBet\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_min_value\",\"type\":\"uint256\"}],\"name\":\"setBetMinimumValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_debug\",\"type\":\"bool\"}],\"name\":\"setDebug\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"}],\"name\":\"setGameInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_recursionDepth\",\"type\":\"uint8\"}],\"name\":\"setRecursionDepth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "OpenLuckyCryptoSimple", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d4070f4bf91bf033a745278bf015a1f48ac91d041e57645c2d3b8fa591d56eb4"}]}