{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity \\u003e=0.8.0;\\r\\n\\r\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\r\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\r\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\r\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\r\\nabstract contract ERC20 {\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                                  EVENTS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                             METADATA STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    string public name;\\r\\n\\r\\n    string public symbol;\\r\\n\\r\\n    uint8 public immutable decimals;\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                              ERC20 STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    uint256 public totalSupply;\\r\\n\\r\\n    mapping(address =\\u003e uint256) public balanceOf;\\r\\n\\r\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public allowance;\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                             EIP-2612 STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\r\\n\\r\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\r\\n\\r\\n    mapping(address =\\u003e uint256) public nonces;\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                               CONSTRUCTOR\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    constructor(\\r\\n        string memory _name,\\r\\n        string memory _symbol,\\r\\n        uint8 _decimals\\r\\n    ) {\\r\\n        name = _name;\\r\\n        symbol = _symbol;\\r\\n        decimals = _decimals;\\r\\n\\r\\n        INITIAL_CHAIN_ID = block.chainid;\\r\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\r\\n    }\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                              ERC20 LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\r\\n        allowance[msg.sender][spender] = amount;\\r\\n\\r\\n        emit Approval(msg.sender, spender, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\r\\n        balanceOf[msg.sender] -= amount;\\r\\n\\r\\n        // Cannot overflow because the sum of all user\\r\\n        // balances can\\u0027t exceed the max uint256 value.\\r\\n        unchecked {\\r\\n            balanceOf[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(msg.sender, to, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) public virtual returns (bool) {\\r\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\r\\n\\r\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\r\\n\\r\\n        balanceOf[from] -= amount;\\r\\n\\r\\n        // Cannot overflow because the sum of all user\\r\\n        // balances can\\u0027t exceed the max uint256 value.\\r\\n        unchecked {\\r\\n            balanceOf[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, amount);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                              EIP-2612 LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) public virtual {\\r\\n        require(deadline \\u003e= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\r\\n\\r\\n        // Unchecked because the only math done is incrementing\\r\\n        // the owner\\u0027s nonce which cannot realistically overflow.\\r\\n        unchecked {\\r\\n            address recoveredAddress = ecrecover(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(\\r\\n                        \\\"\\\\x19\\\\x01\\\",\\r\\n                        DOMAIN_SEPARATOR(),\\r\\n                        keccak256(\\r\\n                            abi.encode(\\r\\n                                keccak256(\\r\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\r\\n                                ),\\r\\n                                owner,\\r\\n                                spender,\\r\\n                                value,\\r\\n                                nonces[owner]++,\\r\\n                                deadline\\r\\n                            )\\r\\n                        )\\r\\n                    )\\r\\n                ),\\r\\n                v,\\r\\n                r,\\r\\n                s\\r\\n            );\\r\\n\\r\\n            require(recoveredAddress != address(0) \\u0026\\u0026 recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\r\\n\\r\\n            allowance[recoveredAddress][spender] = value;\\r\\n        }\\r\\n\\r\\n        emit Approval(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\r\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\r\\n    }\\r\\n\\r\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encode(\\r\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\r\\n                    keccak256(bytes(name)),\\r\\n                    keccak256(\\\"1\\\"),\\r\\n                    block.chainid,\\r\\n                    address(this)\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                       INTERNAL MINT/BURN LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function _mint(address to, uint256 amount) internal virtual {\\r\\n        totalSupply += amount;\\r\\n\\r\\n        // Cannot overflow because the sum of all user\\r\\n        // balances can\\u0027t exceed the max uint256 value.\\r\\n        unchecked {\\r\\n            balanceOf[to] += amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(address(0), to, amount);\\r\\n    }\\r\\n\\r\\n    function _burn(address from, uint256 amount) internal virtual {\\r\\n        balanceOf[from] -= amount;\\r\\n\\r\\n        // Cannot underflow because a user\\u0027s balance\\r\\n        // will never be larger than the total supply.\\r\\n        unchecked {\\r\\n            totalSupply -= amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, address(0), amount);\\r\\n    }\\r\\n}\"},\"IBentoBoxMinimal.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.7;\\r\\n\\r\\n/// @notice Minimal interface for BentoBox token vault interactions - `token` is aliased as `address` from `IERC20` for code simplicity.\\r\\ninterface IBentoBoxMinimal {\\r\\n\\r\\n    struct Rebase {\\r\\n        uint128 elastic;\\r\\n        uint128 base;\\r\\n    }\\r\\n\\r\\n    struct StrategyData {\\r\\n        uint64 strategyStartDate;\\r\\n        uint64 targetPercentage;\\r\\n        uint128 balance; // the balance of the strategy that BentoBox thinks is in there\\r\\n    }\\r\\n\\r\\n    function strategyData(address token) external view returns (StrategyData memory);\\r\\n\\r\\n    /// @notice Balance per ERC-20 token per account in shares.\\r\\n    function balanceOf(address, address) external view returns (uint256);\\r\\n\\r\\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\\r\\n    /// @param token_ The ERC-20 token to deposit.\\r\\n    /// @param from which account to pull the tokens.\\r\\n    /// @param to which account to push the tokens.\\r\\n    /// @param amount Token amount in native representation to deposit.\\r\\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\\r\\n    /// @return amountOut The amount deposited.\\r\\n    /// @return shareOut The deposited amount repesented in shares.\\r\\n    function deposit(\\r\\n        address token_,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        uint256 share\\r\\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\\r\\n\\r\\n    /// @notice Withdraws an amount of `token` from a user account.\\r\\n    /// @param token_ The ERC-20 token to withdraw.\\r\\n    /// @param from which user to pull the tokens.\\r\\n    /// @param to which user to push the tokens.\\r\\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\\r\\n    /// @param share Like above, but `share` takes precedence over `amount`.\\r\\n    function withdraw(\\r\\n        address token_,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        uint256 share\\r\\n    ) external returns (uint256 amountOut, uint256 shareOut);\\r\\n\\r\\n    /// @notice Transfer shares from a user account to another one.\\r\\n    /// @param token The ERC-20 token to transfer.\\r\\n    /// @param from which user to pull the tokens.\\r\\n    /// @param to which user to push the tokens.\\r\\n    /// @param share The amount of `token` in shares.\\r\\n    function transfer(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 share\\r\\n    ) external;\\r\\n\\r\\n    /// @dev Helper function to represent an `amount` of `token` in shares.\\r\\n    /// @param token The ERC-20 token.\\r\\n    /// @param amount The `token` amount.\\r\\n    /// @param roundUp If the result `share` should be rounded up.\\r\\n    /// @return share The token amount represented in shares.\\r\\n    function toShare(\\r\\n        address token,\\r\\n        uint256 amount,\\r\\n        bool roundUp\\r\\n    ) external view returns (uint256 share);\\r\\n\\r\\n    /// @dev Helper function to represent shares back into the `token` amount.\\r\\n    /// @param token The ERC-20 token.\\r\\n    /// @param share The amount of shares.\\r\\n    /// @param roundUp If the result should be rounded up.\\r\\n    /// @return amount The share amount back into native representation.\\r\\n    function toAmount(\\r\\n        address token,\\r\\n        uint256 share,\\r\\n        bool roundUp\\r\\n    ) external view returns (uint256 amount);\\r\\n\\r\\n    /// @notice Registers this contract so that users can approve it for the BentoBox.\\r\\n    function registerProtocol() external;\\r\\n\\r\\n    function totals(address token) external view returns (Rebase memory);\\r\\n\\r\\n    function harvest(\\r\\n        address token,\\r\\n        bool balance,\\r\\n        uint256 maxChangeAmount\\r\\n    ) external;\\r\\n}\"},\"IStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity 0.8.7;\\r\\n\\r\\ninterface IStrategy {\\r\\n    /// @notice Send the assets to the Strategy and call skim to invest them.\\r\\n    /// @param amount The amount of tokens to invest.\\r\\n    function skim(uint256 amount) external;\\r\\n\\r\\n    /// @notice Harvest any profits made converted to the asset and pass them to the caller.\\r\\n    /// @param balance The amount of tokens the caller thinks it has invested.\\r\\n    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.\\r\\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\\r\\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\\r\\n\\r\\n    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.\\r\\n    /// @dev The `actualAmount` should be very close to the amount.\\r\\n    /// The difference should NOT be used to report a loss. That\\u0027s what harvest is for.\\r\\n    /// @param amount The requested amount the caller wants to withdraw.\\r\\n    /// @return actualAmount The real amount that is withdrawn.\\r\\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\\r\\n\\r\\n    /// @notice Withdraw all assets in the safest way possible. This shouldn\\u0027t fail.\\r\\n    /// @param balance The amount of tokens the caller thinks it has invested.\\r\\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\\r\\n    function exit(uint256 balance) external returns (int256 amountAdded);\\r\\n}\"},\"SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity \\u003e=0.8.0;\\r\\n\\r\\nimport {ERC20} from \\\"ERC20.sol\\\";\\r\\n\\r\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\r\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\r\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\r\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\r\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\r\\nlibrary SafeTransferLib {\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                            ETH OPERATIONS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function safeTransferETH(address to, uint256 amount) internal {\\r\\n        bool callStatus;\\r\\n\\r\\n        assembly {\\r\\n            // Transfer the ETH and store if it succeeded or not.\\r\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\r\\n        }\\r\\n\\r\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\r\\n    }\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                           ERC20 OPERATIONS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        ERC20 token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        bool callStatus;\\r\\n\\r\\n        assembly {\\r\\n            // Get a pointer to some free memory.\\r\\n            let freeMemoryPointer := mload(0x40)\\r\\n\\r\\n            // Write the abi-encoded calldata to memory piece by piece:\\r\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\r\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\r\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\r\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it\\u0027s a full 32 byte value.\\r\\n\\r\\n            // Call the token and store if it succeeded or not.\\r\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\r\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\r\\n        }\\r\\n\\r\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\r\\n    }\\r\\n\\r\\n    function safeTransfer(\\r\\n        ERC20 token,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        bool callStatus;\\r\\n\\r\\n        assembly {\\r\\n            // Get a pointer to some free memory.\\r\\n            let freeMemoryPointer := mload(0x40)\\r\\n\\r\\n            // Write the abi-encoded calldata to memory piece by piece:\\r\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\r\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\r\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it\\u0027s a full 32 byte value.\\r\\n\\r\\n            // Call the token and store if it succeeded or not.\\r\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\r\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\r\\n        }\\r\\n\\r\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\r\\n    }\\r\\n\\r\\n    function safeApprove(\\r\\n        ERC20 token,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal {\\r\\n        bool callStatus;\\r\\n\\r\\n        assembly {\\r\\n            // Get a pointer to some free memory.\\r\\n            let freeMemoryPointer := mload(0x40)\\r\\n\\r\\n            // Write the abi-encoded calldata to memory piece by piece:\\r\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\r\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\r\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it\\u0027s a full 32 byte value.\\r\\n\\r\\n            // Call the token and store if it succeeded or not.\\r\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\r\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\r\\n        }\\r\\n\\r\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\r\\n    }\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                         INTERNAL HELPER LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\r\\n        assembly {\\r\\n            // If the call reverted:\\r\\n            if iszero(callStatus) {\\r\\n                // Copy the revert message into memory.\\r\\n                returndatacopy(0, 0, returndatasize())\\r\\n\\r\\n                // Revert with the same message.\\r\\n                revert(0, returndatasize())\\r\\n            }\\r\\n\\r\\n            switch returndatasize()\\r\\n            case 32 {\\r\\n                // Copy the return data into memory.\\r\\n                returndatacopy(0, 0, returndatasize())\\r\\n\\r\\n                // Set success to whether it returned true.\\r\\n                success := iszero(iszero(mload(0)))\\r\\n            }\\r\\n            case 0 {\\r\\n                // There was no return data.\\r\\n                success := 1\\r\\n            }\\r\\n            default {\\r\\n                // It returned some malformed output.\\r\\n                success := 0\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\"},\"USTMiddleLayer.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n// solhint-disable const-name-snakecase, not-rely-on-time\\r\\n\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"SafeTransferLib.sol\\\";\\r\\nimport \\\"ERC20.sol\\\";\\r\\nimport \\\"IStrategy.sol\\\";\\r\\nimport \\\"IBentoBoxMinimal.sol\\\";\\r\\n\\r\\ninterface IExchangeRateFeeder {\\r\\n    function exchangeRateOf(address _token, bool _simulate) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IUSTStrategy {\\r\\n    function feeder() external view returns (IExchangeRateFeeder);\\r\\n\\r\\n    function safeWithdraw(uint256 amount) external;\\r\\n\\r\\n    function safeHarvest(\\r\\n        uint256 maxBalance,\\r\\n        bool rebalance,\\r\\n        uint256 maxChangeAmount,\\r\\n        bool harvestRewards\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ncontract USTMiddleLayer {\\r\\n    using SafeTransferLib for ERC20;\\r\\n\\r\\n    error RedeemingNotReady();\\r\\n    error StrategyWouldAccountLoss();\\r\\n\\r\\n    ERC20 public constant UST = ERC20(0xa47c8bf37f92aBed4A126BDA807A7b7498661acD);\\r\\n    ERC20 public constant aUST = ERC20(0xa8De3e3c934e2A1BB08B010104CcaBBD4D6293ab);\\r\\n    IUSTStrategy private constant strategy = IUSTStrategy(0xE6191aA754F9a881e0a73F2028eDF324242F39E2);\\r\\n    IBentoBoxMinimal private constant bentoBox = IBentoBoxMinimal(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);\\r\\n\\r\\n    uint256 public lastWithdraw;\\r\\n\\r\\n    function accountEarnings() external {\\r\\n        uint256 balanceToKeep = IBentoBoxMinimal(bentoBox).strategyData(address(UST)).balance;\\r\\n        uint256 exchangeRate = strategy.feeder().exchangeRateOf(address(UST), true);\\r\\n        uint256 liquid = UST.balanceOf(address(strategy));\\r\\n        uint256 total = toUST(aUST.balanceOf(address(strategy)), exchangeRate) + liquid;\\r\\n\\r\\n        if (total \\u003c= balanceToKeep) {\\r\\n            revert StrategyWouldAccountLoss();\\r\\n        }\\r\\n\\r\\n        strategy.safeHarvest(type(uint256).max, false, type(uint256).max, false);\\r\\n    }\\r\\n\\r\\n    function redeemEarningsImproved() external {\\r\\n        if (lastWithdraw + 20 minutes \\u003e block.timestamp) {\\r\\n            revert RedeemingNotReady();\\r\\n        }\\r\\n\\r\\n        uint256 balanceToKeep = IBentoBoxMinimal(bentoBox).strategyData(address(UST)).balance;\\r\\n        uint256 exchangeRate = strategy.feeder().exchangeRateOf(address(UST), true);\\r\\n        uint256 liquid = UST.balanceOf(address(strategy));\\r\\n        uint256 total = toUST(aUST.balanceOf(address(strategy)), exchangeRate) + liquid;\\r\\n\\r\\n        lastWithdraw = block.timestamp;\\r\\n\\r\\n        if (total \\u003e balanceToKeep) {\\r\\n            strategy.safeWithdraw(total - balanceToKeep - liquid);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function toUST(uint256 amount, uint256 exchangeRate) public pure returns (uint256) {\\r\\n        return (amount * exchangeRate) / 1e18;\\r\\n    }\\r\\n\\r\\n    function toAUST(uint256 amount, uint256 exchangeRate) public pure returns (uint256) {\\r\\n        return (amount * 1e18) / exchangeRate;\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"name\":\"RedeemingNotReady\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StrategyWouldAccountLoss\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UST\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aUST\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accountEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemEarningsImproved\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangeRate\",\"type\":\"uint256\"}],\"name\":\"toAUST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangeRate\",\"type\":\"uint256\"}],\"name\":\"toUST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "USTMiddleLayer", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://86f5c5bb2ef4779a169d30e44a0ea27944517d725d3f29e78e38d9e00992078f"}]}