{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.11;\r\n\r\n/*\r\n*\r\n*                                                  \ud83d\udeac\r\n*                                               \ud83d\udeac\ud83d\udeac\r\n*                                             \ud83d\udeac\ud83d\udeac\r\n*                                           \ud83d\udeac\ud83d\udeac\r\n*                                            \ud83d\udeac\ud83d\udeac\r\n*                                             \ud83d\udeac\ud83d\udeac\r\n* \ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\r\n*           CryptoPunks 5th Birthday           \ud83d\udeac\ud83d\udeac\ud83d\udeac\r\n*             Gift from tycoon.eth            \ud83d\udeac\ud83d\udeac\ud83d\udeac\r\n* \ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\r\n*\r\n* This contract does not read/write into the CryptoPunks contract.\r\n* It does not require any approvals or permissions.\r\n* All distribution is done using a Merkle tree from a snapshot on 10th of\r\n* June 2022.\r\n*\r\n* Simply claim from the address where you had a punk on 10th of June 2022.\r\n* (Your punk does not have to be in the wallet while you claim, it only had\r\n* to be there in the 10th of June)\r\n*\r\n* Claim at: https://thedaonft.eth.limo/punks.html\r\n*\r\n* Only 500 items in the inventory!\r\n*\r\n* What is it? It's a NFT collection created by me, tycoon.eth around November\r\n* 2021.\r\n*\r\n* Like most of you, I've been fascinated with NFTs, so I got curious &\r\n* creative.\r\n* I'm also fascinated about the TheDAO, so I've put the two together,\r\n* See more details at thedaonft.eth.limo\r\n* After completion, the project was handed over to the \"DAO Museum Multisig\",\r\n* so I don't own it by myself, but as of writing, I'm still one of the signers\r\n* on the multisig and I can change the website.\r\n*\r\n* I mostly give these away to friends, and it's a great conversation starter!\r\n*\r\n* Each NFT has 1 DAO token inside, which is worth 0.01 ETH\r\n* You can burn the NFT to get the DAO token back. (The NFT can be restored,\r\n* but it will cost 4 DAO to restore)\r\n* 1 DAO will always be worth 0.01 ETH because there is a smart contract that\r\n* can instantly redeem 0.01 ETH for every DAO you have.\r\n*\r\n* Oh, if you have multiple addresses and received multiple pieces, consider\r\n* giving a spare to someone who missed out <3\r\n*\r\n* The Curator will shutdown this contract if there are no new claims for\r\n* longer than 30 days.\r\n*\r\n* Happy 5th Birthday CryptoPunks!\r\n*\r\n*\r\n* deployed with:\r\n* _THEDAO 0xbb9bc244d798123fde783fcc1c72d3bb8c189413\r\n* _THENFT 0x79a7d3559d73ea032120a69e59223d4375deb595\r\n*/\r\n\r\n\r\ncontract TheGift {\r\n\r\n    IERC20 private immutable theDAO;\r\n    ITheNFT private immutable theNFT;\r\n    mapping(address => uint256) public claims;\r\n    address payable public curator;\r\n    bytes32 public root;\r\n    mapping (uint256 => batch) private inventory;\r\n    uint256 public curBatch;\r\n    uint256 public nextBatch;\r\n    event Claim(address);\r\n    struct batch {\r\n        uint256 end;\r\n        uint256 progress;\r\n    }\r\n\r\n    constructor(address _theDAO, address _theNFT) {\r\n        curator = payable(msg.sender);\r\n        theDAO = IERC20(_theDAO);\r\n        theNFT = ITheNFT(_theNFT);\r\n        theDAO.approve(_theNFT, type(uint256).max); // approve TheNFT to spend our DAO tokens on contract's behalf\r\n    }\r\n\r\n    modifier onlyCurator {\r\n        require(\r\n            msg.sender == curator,\r\n            \"only curator can call this\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function setRoot(bytes32 _r) external onlyCurator {\r\n        root = _r;\r\n    }\r\n\r\n    function setCurator(address _a) external onlyCurator {\r\n        curator = payable(_a);\r\n    }\r\n\r\n    function bulkMint(uint256 rounds) external onlyCurator {\r\n        unchecked {\r\n            uint256[] memory ret = theNFT.getStats(address(this));\r\n            batch storage b = inventory[nextBatch];\r\n            b.progress = 1800-ret[2];\r\n            for (uint256 i = 0; i < rounds; i++) {\r\n                theNFT.mint(100);\r\n            }\r\n            b.end = 1800-ret[2]+100;\r\n            nextBatch++;\r\n        }\r\n    }\r\n\r\n    function shutdown(uint256[] calldata _ids, bool _destruct) external onlyCurator {\r\n        for (uint256 i; i < _ids.length; i++) {\r\n            theNFT.transferFrom(address(this), msg.sender, _ids[i]);\r\n        }\r\n        if (theDAO.balanceOf(address(this))>0) {\r\n            theDAO.transfer(msg.sender, theDAO.balanceOf(address(this)));\r\n        }\r\n        if (_destruct) {\r\n            selfdestruct(curator);\r\n        }\r\n    }\r\n\r\n    function verify(\r\n        address _to,\r\n        bytes32 _root,\r\n        bytes32[] memory _proof\r\n    ) public pure returns (bool) {\r\n        bytes32 computedHash = keccak256(abi.encodePacked(_to)); // leaf\r\n        for (uint256 i = 0; i < _proof.length; ) {\r\n            bytes32 proofElement = _proof[i];\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n            unchecked { i++; }\r\n        }\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == _root;\r\n    }\r\n\r\n    function claim(address _to, bytes32[] memory _proof) external {\r\n        require(claims[msg.sender] == 0, \"already claimed\");\r\n        require(verify(_to, root, _proof), \"invalid proof\");\r\n        require(theNFT.balanceOf(address(this)) > 0, \"no nfts available\");\r\n        uint256 id;\r\n        batch storage b = inventory[curBatch];\r\n        id = b.progress;\r\n        theNFT.transferFrom(address(this), _to, id); // will fail if already claimed\r\n        emit Claim(_to);\r\n        claims[_to] = id;\r\n        unchecked { b.progress++; }\r\n        if (b.progress >= b.end) {\r\n            unchecked { curBatch++; }\r\n        }\r\n    }\r\n\r\n    function getStats(address _user,  bytes32[] memory _proof) external view returns(uint256[] memory) {\r\n        uint[] memory ret = new uint[](10);\r\n        ret[0] = theNFT.balanceOf(_user);\r\n        ret[1] = theNFT.balanceOf(address(this));\r\n        if (verify(_user, root, _proof)) {\r\n            ret[2] = 1;\r\n        }\r\n        ret[3] = curBatch;\r\n        ret[4] = nextBatch;\r\n        batch storage b = inventory[curBatch];\r\n        ret[5] = b.progress;\r\n        return ret;\r\n    }\r\n}\r\n\r\n\r\n\r\n/*\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n * 0xTycoon was here\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IERC721TokenReceiver {\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns (bytes4);\r\n}\r\ninterface IERC721Enumerable {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n\r\ninterface ITheNFT is IERC721 {\r\n    function mint(uint256 i) external;\r\n    function getStats(address user) external view returns(uint256[] memory);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_theDAO\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_theNFT\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rounds\",\"type\":\"uint256\"}],\"name\":\"bulkMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claims\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curator\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"getStats\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"root\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"setCurator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"}],\"name\":\"setRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"_destruct\",\"type\":\"bool\"}],\"name\":\"shutdown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "TheGift", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "2000000", "ConstructorArguments": "000000000000000000000000bb9bc244d798123fde783fcc1c72d3bb8c18941300000000000000000000000079a7d3559d73ea032120a69e59223d4375deb595", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a87d2891052bd56a1fa1db6ce506b52b6eeb4eb303c4a49fb21df817651ef876"}]}