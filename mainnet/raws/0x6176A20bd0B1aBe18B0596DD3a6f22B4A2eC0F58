{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Reroller.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ChainScoutsExtension.sol\\\";\\nimport \\\"./IUtilityERC20.sol\\\";\\nimport \\\"./Rarities.sol\\\";\\nimport \\\"./Rng.sol\\\";\\n\\ncontract Reroller is ChainScoutsExtension {\\n    using RngLibrary for Rng;\\n\\n    Rng internal staticRng;\\n    IUtilityERC20 public token;\\n    uint256 public accessoryCost = 80 ether;\\n    uint256 public backAccessoryCost = type(uint256).max;\\n    uint256 public backgroundCost = 80 ether;\\n    uint256 public clothingCost = 80 ether;\\n\\n    constructor(IUtilityERC20 _token) {\\n        token = _token;\\n        enabled = false;\\n    }\\n\\n    function extensionKey() public pure override returns (string memory) {\\n        return \\\"reroller\\\";\\n    }\\n\\n    function adminSetAccessoryCostWei(uint256 _wei) external onlyAdmin {\\n        accessoryCost = _wei;\\n    }\\n\\n    function adminSetBackAccessoryCostWei(uint256 _wei) external onlyAdmin {\\n        backAccessoryCost = _wei;\\n    }\\n\\n    function adminSetBackgroundCostWei(uint256 _wei) external onlyAdmin {\\n        backgroundCost = _wei;\\n    }\\n\\n    function adminSetClothingCostWei(uint256 _wei) external onlyAdmin {\\n        clothingCost = _wei;\\n    }\\n\\n    function getRandom(\\n        Rng memory rng,\\n        uint256 raritySum,\\n        uint16[] memory rarities\\n    ) internal view returns (uint256) {\\n        uint256 rn = rng.generate(0, raritySum - 1);\\n\\n        for (uint256 i = 0; i < rarities.length; ++i) {\\n            if (rarities[i] > rn) {\\n                return i;\\n            }\\n            rn -= rarities[i];\\n        }\\n        revert(\\\"rn not selected\\\");\\n    }\\n\\n    function rerollAccessory(uint256 tokenId)\\n        external\\n        canAccessToken(tokenId)\\n        whenEnabled\\n    {\\n        token.burn(msg.sender, accessoryCost);\\n\\n        ChainScoutMetadata memory md = chainScouts.getChainScoutMetadata(\\n            tokenId\\n        );\\n        Rng memory rng = staticRng;\\n\\n        uint16[] memory rarities = Rarities.accessory();\\n        uint256 total = 10000;\\n\\n        total -= rarities[uint256(md.accessory)];\\n        rarities[uint256(md.accessory)] = 0;\\n\\n        if (md.backaccessory == BackAccessory.MINER) {\\n            total -= rarities[uint256(Accessory.CUBAN_LINK_GOLD_CHAIN)];\\n            rarities[uint256(Accessory.CUBAN_LINK_GOLD_CHAIN)] = 0;\\n        }\\n\\n        if (\\n            md.clothing == Clothing.FLEET_UNIFORM__BLUE ||\\n            md.clothing == Clothing.FLEET_UNIFORM__RED\\n        ) {\\n            Accessory[4] memory xs = [\\n                Accessory.AMULET,\\n                Accessory.CUBAN_LINK_GOLD_CHAIN,\\n                Accessory.FANNY_PACK,\\n                Accessory.GOLDEN_CHAIN\\n            ];\\n            for (uint256 i = 0; i < xs.length; ++i) {\\n                total -= rarities[uint256(xs[i])];\\n                rarities[uint256(xs[i])] = 0;\\n            }\\n        } else if (\\n            md.head == Head.CYBER_HELMET__BLUE ||\\n            md.head == Head.CYBER_HELMET__RED ||\\n            md.head == Head.SPACESUIT_HELMET\\n        ) {\\n            total -= rarities[uint256(Accessory.GOLD_EARRINGS)];\\n            rarities[uint256(Accessory.GOLD_EARRINGS)] = 0;\\n        }\\n\\n        md.accessory = Accessory(getRandom(rng, total, rarities));\\n\\n        staticRng = rng;\\n        chainScouts.adminSetChainScoutMetadata(tokenId, md);\\n    }\\n\\n    function rerollBackAccessory(uint256 tokenId)\\n        external\\n        canAccessToken(tokenId)\\n        whenEnabled\\n    {\\n        token.burn(msg.sender, backAccessoryCost);\\n\\n        ChainScoutMetadata memory md = chainScouts.getChainScoutMetadata(\\n            tokenId\\n        );\\n        Rng memory rng = staticRng;\\n\\n        uint16[] memory rarities = Rarities.backaccessory();\\n        uint256 total = 10000;\\n\\n        total -= rarities[uint256(md.backaccessory)];\\n        rarities[uint256(md.backaccessory)] = 0;\\n\\n        if (md.accessory == Accessory.CUBAN_LINK_GOLD_CHAIN) {\\n            total -= rarities[uint256(BackAccessory.MINER)];\\n            rarities[uint256(BackAccessory.MINER)] = 0;\\n        }\\n\\n        if (md.head == Head.ENERGY_FIELD) {\\n            total -= rarities[uint256(BackAccessory.PATHFINDER)];\\n            rarities[uint256(BackAccessory.PATHFINDER)] = 0;\\n        }\\n\\n        md.backaccessory = BackAccessory(getRandom(rng, total, rarities));\\n\\n        staticRng = rng;\\n        chainScouts.adminSetChainScoutMetadata(tokenId, md);\\n    }\\n\\n    function rerollBackground(uint256 tokenId)\\n        external\\n        canAccessToken(tokenId)\\n        whenEnabled\\n    {\\n        token.burn(msg.sender, backgroundCost);\\n\\n        ChainScoutMetadata memory md = chainScouts.getChainScoutMetadata(\\n            tokenId\\n        );\\n        Rng memory rng = staticRng;\\n\\n        uint16[] memory rarities = Rarities.background();\\n        uint256 total = 10000;\\n\\n        total -= rarities[uint256(md.background)];\\n        rarities[uint256(md.background)] = 0;\\n\\n        if (\\n            md.clothing == Clothing.FLEET_UNIFORM__BLUE ||\\n            md.clothing == Clothing.MARTIAL_SUIT ||\\n            md.clothing == Clothing.THUNDERDOME_ARMOR ||\\n            md.head == Head.ENERGY_FIELD\\n        ) {\\n            total -= rarities[uint256(Background.CITY__PURPLE)];\\n            rarities[uint256(Background.CITY__PURPLE)] = 0;\\n        }\\n\\n        if (md.head == Head.ENERGY_FIELD) {\\n            total -= rarities[uint256(Background.CITY__RED)];\\n            rarities[uint256(Background.CITY__RED)] = 0;\\n        }\\n\\n        md.background = Background(getRandom(rng, total, rarities));\\n\\n        staticRng = rng;\\n        chainScouts.adminSetChainScoutMetadata(tokenId, md);\\n    }\\n\\n    function rerollClothing(uint256 tokenId)\\n        external\\n        canAccessToken(tokenId)\\n        whenEnabled\\n    {\\n        token.burn(msg.sender, clothingCost);\\n\\n        ChainScoutMetadata memory md = chainScouts.getChainScoutMetadata(\\n            tokenId\\n        );\\n        Rng memory rng = staticRng;\\n\\n        uint16[] memory rarities = Rarities.clothing();\\n        uint256 total = 10000;\\n\\n        total -= rarities[uint256(md.clothing)];\\n        rarities[uint256(md.clothing)] = 0;\\n\\n        if (\\n            md.accessory == Accessory.AMULET ||\\n            md.accessory == Accessory.CUBAN_LINK_GOLD_CHAIN ||\\n            md.accessory == Accessory.FANNY_PACK ||\\n            md.accessory == Accessory.GOLDEN_CHAIN ||\\n            md.mouth == Mouth.CHROME_RESPIRATOR ||\\n            md.mouth == Mouth.GREEN_RESPIRATOR ||\\n            md.mouth == Mouth.MAGENTA_RESPIRATOR ||\\n            md.mouth == Mouth.NAVY_RESPIRATOR ||\\n            md.mouth == Mouth.RED_RESPIRATOR\\n        ) {\\n            Clothing[2] memory c = [\\n                Clothing.FLEET_UNIFORM__BLUE,\\n                Clothing.FLEET_UNIFORM__RED\\n            ];\\n\\n            for (uint256 i = 0; i < c.length; ++i) {\\n                uint256 cdx = uint256(c[i]);\\n                total -= rarities[cdx];\\n                rarities[cdx] = 0;\\n            }\\n        }\\n\\n        if (md.background == Background.CITY__PURPLE) {\\n            Clothing[3] memory c = [\\n                Clothing.FLEET_UNIFORM__BLUE,\\n                Clothing.MARTIAL_SUIT,\\n                Clothing.THUNDERDOME_ARMOR\\n            ];\\n\\n            for (uint256 i = 0; i < c.length; ++i) {\\n                uint256 cdx = uint256(c[i]);\\n                total -= rarities[cdx];\\n                rarities[cdx] = 0;\\n            }\\n        }\\n\\n        if (uint256(md.background) == 10 || uint256(md.background) == 19) {\\n            total -= rarities[uint256(Clothing.MARTIAL_SUIT)];\\n            rarities[uint256(Clothing.MARTIAL_SUIT)] = 0;\\n        }\\n\\n        if (uint256(md.background) == 10) {\\n            total -= rarities[uint256(Clothing.THUNDERDOME_ARMOR)];\\n            rarities[uint256(Clothing.THUNDERDOME_ARMOR)] = 0;\\n        }\\n\\n        md.clothing = Clothing(getRandom(rng, total, rarities));\\n\\n        staticRng = rng;\\n        chainScouts.adminSetChainScoutMetadata(tokenId, md);\\n    }\\n}\\n\\ncontract Reroller2 is ChainScoutsExtension {\\n    using RngLibrary for Rng;\\n\\n    Rng internal staticRng;\\n    IUtilityERC20 public token;\\n    uint256 public eyesCost = 80 ether;\\n    uint256 public furCost = 80 ether;\\n    uint256 public headCost = 80 ether;\\n    uint256 public mouthCost = 80 ether;\\n\\n    constructor(IUtilityERC20 _token) {\\n        token = _token;\\n        enabled = false;\\n    }\\n\\n    function extensionKey() public pure override returns (string memory) {\\n        return \\\"reroller2\\\";\\n    }\\n\\n    function adminSetEyesCostWei(uint256 _wei) external onlyAdmin {\\n        eyesCost = _wei;\\n    }\\n\\n    function adminSetFurCostWei(uint256 _wei) external onlyAdmin {\\n        furCost = _wei;\\n    }\\n\\n    function adminSetHeadCostWei(uint256 _wei) external onlyAdmin {\\n        headCost = _wei;\\n    }\\n\\n    function adminSetMouthCostWei(uint256 _wei) external onlyAdmin {\\n        mouthCost = _wei;\\n    }\\n\\n    function getRandom(\\n        Rng memory rng,\\n        uint256 raritySum,\\n        uint16[] memory rarities\\n    ) internal view returns (uint256) {\\n        uint256 rn = rng.generate(0, raritySum - 1);\\n\\n        for (uint256 i = 0; i < rarities.length; ++i) {\\n            if (rarities[i] > rn) {\\n                return i;\\n            }\\n            rn -= rarities[i];\\n        }\\n        revert(\\\"rn not selected\\\");\\n    }\\n\\n    function rerollEyes(uint256 tokenId)\\n        external\\n        canAccessToken(tokenId)\\n        whenEnabled\\n    {\\n        token.burn(msg.sender, eyesCost);\\n\\n        ChainScoutMetadata memory md = chainScouts.getChainScoutMetadata(\\n            tokenId\\n        );\\n        Rng memory rng = staticRng;\\n\\n        uint16[] memory rarities = Rarities.eyes();\\n        uint256 total = 10000;\\n\\n        total -= rarities[uint256(md.eyes)];\\n        rarities[uint256(md.eyes)] = 0;\\n\\n        if (\\n            md.head == Head.BANDANA ||\\n            md.head == Head.CYBER_HELMET__BLUE ||\\n            md.head == Head.CYBER_HELMET__RED ||\\n            md.head == Head.DORAG ||\\n            md.head == Head.SPACESUIT_HELMET ||\\n            md.mouth == Mouth.BANANA ||\\n            md.mouth == Mouth.CHROME_RESPIRATOR ||\\n            md.mouth == Mouth.GREEN_RESPIRATOR ||\\n            md.mouth == Mouth.MAGENTA_RESPIRATOR ||\\n            md.mouth == Mouth.MASK ||\\n            md.mouth == Mouth.MEMPO ||\\n            md.mouth == Mouth.NAVY_RESPIRATOR ||\\n            md.mouth == Mouth.PILOT_OXYGEN_MASK ||\\n            md.mouth == Mouth.RED_RESPIRATOR\\n        ) {\\n            Eyes[2] memory xs = [Eyes.BLUE_LASER, Eyes.RED_LASER];\\n            for (uint256 i = 0; i < xs.length; ++i) {\\n                total -= rarities[uint256(xs[i])];\\n                rarities[uint256(xs[i])] = 0;\\n            }\\n        }\\n\\n        if (\\n            md.head == Head.SPACESUIT_HELMET ||\\n            md.mouth == Mouth.CHROME_RESPIRATOR ||\\n            md.mouth == Mouth.GREEN_RESPIRATOR ||\\n            md.mouth == Mouth.MAGENTA_RESPIRATOR ||\\n            md.mouth == Mouth.MASK ||\\n            md.mouth == Mouth.NAVY_RESPIRATOR ||\\n            md.mouth == Mouth.RED_RESPIRATOR\\n        ) {\\n            Eyes[3] memory xs = [\\n                Eyes.BLUE_SHADES,\\n                Eyes.DARK_SUNGLASSES,\\n                Eyes.GOLDEN_SHADES\\n            ];\\n            for (uint256 i = 0; i < xs.length; ++i) {\\n                total -= rarities[uint256(xs[i])];\\n                rarities[uint256(xs[i])] = 0;\\n            }\\n        }\\n\\n        if (\\n            md.head == Head.DORAG ||\\n            md.head == Head.HEADBAND ||\\n            md.head == Head.SPACESUIT_HELMET\\n        ) {\\n            Eyes[3] memory xs = [\\n                Eyes.HUD_GLASSES,\\n                Eyes.HIVE_GOGGLES,\\n                Eyes.WHITE_SUNGLASSES\\n            ];\\n            for (uint256 i = 0; i < xs.length; ++i) {\\n                total -= rarities[uint256(xs[i])];\\n                rarities[uint256(xs[i])] = 0;\\n            }\\n        }\\n\\n        if (\\n            md.head == Head.CAP ||\\n            md.head == Head.LEATHER_COWBOY_HAT ||\\n            md.head == Head.PURPLE_COWBOY_HAT\\n        ) {\\n            total -= rarities[uint256(Eyes.HAPPY)];\\n            rarities[uint256(Eyes.HAPPY)] = 0;\\n        }\\n\\n        if (\\n            md.head == Head.BANDANA ||\\n            md.head == Head.CYBER_HELMET__BLUE ||\\n            md.head == Head.CYBER_HELMET__RED ||\\n            md.head == Head.DORAG ||\\n            md.head == Head.HEADBAND ||\\n            md.head == Head.SPACESUIT_HELMET ||\\n            md.mouth == Mouth.CHROME_RESPIRATOR ||\\n            md.mouth == Mouth.GREEN_RESPIRATOR ||\\n            md.mouth == Mouth.MAGENTA_RESPIRATOR ||\\n            md.mouth == Mouth.MASK ||\\n            md.mouth == Mouth.MEMPO ||\\n            md.mouth == Mouth.NAVY_RESPIRATOR ||\\n            md.mouth == Mouth.RED_RESPIRATOR\\n        ) {\\n            total -= rarities[uint256(Eyes.HIPSTER_GLASSES)];\\n            rarities[uint256(Eyes.HIPSTER_GLASSES)] = 0;\\n        }\\n\\n        if (md.head == Head.SPACESUIT_HELMET) {\\n            Eyes[2] memory xs = [\\n                Eyes.MATRIX_GLASSES,\\n                Eyes.NIGHT_VISION_GOGGLES\\n            ];\\n            for (uint256 i = 0; i < xs.length; ++i) {\\n                total -= rarities[uint256(xs[i])];\\n                rarities[uint256(xs[i])] = 0;\\n            }\\n        }\\n\\n        if (\\n            md.head == Head.BANDANA ||\\n            md.head == Head.DORAG ||\\n            md.head == Head.HEADBAND ||\\n            md.head == Head.SPACESUIT_HELMET ||\\n            md.mouth == Mouth.CHROME_RESPIRATOR ||\\n            md.mouth == Mouth.GREEN_RESPIRATOR ||\\n            md.mouth == Mouth.MAGENTA_RESPIRATOR ||\\n            md.mouth == Mouth.MASK ||\\n            md.mouth == Mouth.MEMPO ||\\n            md.mouth == Mouth.NAVY_RESPIRATOR ||\\n            md.mouth == Mouth.PILOT_OXYGEN_MASK ||\\n            md.mouth == Mouth.RED_RESPIRATOR\\n        ) {\\n            total -= rarities[uint256(Eyes.NOUNS_GLASSES)];\\n            rarities[uint256(Eyes.NOUNS_GLASSES)] = 0;\\n        }\\n\\n        if (\\n            md.head == Head.SPACESUIT_HELMET ||\\n            md.mouth == Mouth.MASK ||\\n            md.mouth == Mouth.MEMPO\\n        ) {\\n            total -= rarities[uint256(Eyes.PINCENEZ)];\\n            rarities[uint256(Eyes.PINCENEZ)] = 0;\\n        }\\n\\n        if (\\n            md.head == Head.DORAG ||\\n            md.head == Head.HEADBAND ||\\n            md.head == Head.SPACESUIT_HELMET ||\\n            md.mouth == Mouth.CHROME_RESPIRATOR ||\\n            md.mouth == Mouth.GREEN_RESPIRATOR ||\\n            md.mouth == Mouth.MAGENTA_RESPIRATOR ||\\n            md.mouth == Mouth.MEMPO ||\\n            md.mouth == Mouth.NAVY_RESPIRATOR ||\\n            md.mouth == Mouth.RED_RESPIRATOR\\n        ) {\\n            total -= rarities[uint256(Eyes.SPACE_VISOR)];\\n            rarities[uint256(Eyes.SPACE_VISOR)] = 0;\\n        }\\n\\n        if (md.head == Head.SPACESUIT_HELMET || md.mouth == Mouth.MASK) {\\n            total -= rarities[uint256(Eyes.SUNGLASSES)];\\n            rarities[uint256(Eyes.SUNGLASSES)] = 0;\\n        }\\n\\n        md.eyes = Eyes(getRandom(rng, total, rarities));\\n\\n        staticRng = rng;\\n        chainScouts.adminSetChainScoutMetadata(tokenId, md);\\n    }\\n\\n    function rerollFur(uint256 tokenId)\\n        external\\n        canAccessToken(tokenId)\\n        whenEnabled\\n    {\\n        token.burn(msg.sender, furCost);\\n\\n        ChainScoutMetadata memory md = chainScouts.getChainScoutMetadata(\\n            tokenId\\n        );\\n        Rng memory rng = staticRng;\\n\\n        uint16[] memory rarities = Rarities.fur();\\n        uint256 total = 10000;\\n\\n        md.fur = Fur(getRandom(rng, total, rarities));\\n\\n        staticRng = rng;\\n        chainScouts.adminSetChainScoutMetadata(tokenId, md);\\n    }\\n\\n    function rerollHead(uint256 tokenId)\\n        external\\n        canAccessToken(tokenId)\\n        whenEnabled\\n    {\\n        token.burn(msg.sender, headCost);\\n\\n        ChainScoutMetadata memory md = chainScouts.getChainScoutMetadata(\\n            tokenId\\n        );\\n        Rng memory rng = staticRng;\\n\\n        uint16[] memory rarities = Rarities.head();\\n        uint256 total = 10000;\\n\\n        total -= rarities[uint256(md.head)];\\n        rarities[uint256(md.head)] = 0;\\n\\n        if (\\n            md.eyes == Eyes.BLUE_LASER ||\\n            md.eyes == Eyes.HIPSTER_GLASSES ||\\n            md.eyes == Eyes.NOUNS_GLASSES ||\\n            md.eyes == Eyes.RED_LASER ||\\n            md.mouth == Mouth.CHROME_RESPIRATOR ||\\n            md.mouth == Mouth.GREEN_RESPIRATOR ||\\n            md.mouth == Mouth.MAGENTA_RESPIRATOR ||\\n            md.mouth == Mouth.NAVY_RESPIRATOR ||\\n            md.mouth == Mouth.RED_RESPIRATOR\\n        ) {\\n            total -= rarities[uint256(Head.BANDANA)];\\n            rarities[uint256(Head.BANDANA)] = 0;\\n        }\\n\\n        if (md.eyes == Eyes.HAPPY) {\\n            total -= rarities[uint256(Head.CAP)];\\n            rarities[uint256(Head.CAP)] = 0;\\n        }\\n\\n        if (\\n            md.accessory == Accessory.GOLD_EARRINGS ||\\n            md.eyes == Eyes.BLUE_LASER ||\\n            md.eyes == Eyes.HIPSTER_GLASSES ||\\n            md.eyes == Eyes.RED_LASER ||\\n            md.mouth == Mouth.CHROME_RESPIRATOR ||\\n            md.mouth == Mouth.CIGAR ||\\n            md.mouth == Mouth.GREEN_RESPIRATOR ||\\n            md.mouth == Mouth.MAGENTA_RESPIRATOR ||\\n            md.mouth == Mouth.MEMPO ||\\n            md.mouth == Mouth.NAVY_RESPIRATOR ||\\n            md.mouth == Mouth.PILOT_OXYGEN_MASK ||\\n            md.mouth == Mouth.PIPE ||\\n            md.mouth == Mouth.RED_RESPIRATOR ||\\n            md.mouth == Mouth.VAPE\\n        ) {\\n            Head[2] memory xs = [\\n                Head.CYBER_HELMET__BLUE,\\n                Head.CYBER_HELMET__RED\\n            ];\\n            for (uint256 i = 0; i < xs.length; ++i) {\\n                total -= rarities[uint256(xs[i])];\\n                rarities[uint256(xs[i])] = 0;\\n            }\\n        }\\n\\n        if (\\n            md.eyes == Eyes.BLUE_LASER ||\\n            md.eyes == Eyes.HUD_GLASSES ||\\n            md.eyes == Eyes.HIPSTER_GLASSES ||\\n            md.eyes == Eyes.HIVE_GOGGLES ||\\n            md.eyes == Eyes.NOUNS_GLASSES ||\\n            md.eyes == Eyes.RED_LASER ||\\n            md.eyes == Eyes.SPACE_VISOR ||\\n            md.eyes == Eyes.WHITE_SUNGLASSES ||\\n            md.mouth == Mouth.CHROME_RESPIRATOR ||\\n            md.mouth == Mouth.GREEN_RESPIRATOR ||\\n            md.mouth == Mouth.MAGENTA_RESPIRATOR ||\\n            md.mouth == Mouth.NAVY_RESPIRATOR ||\\n            md.mouth == Mouth.RED_RESPIRATOR\\n        ) {\\n            total -= rarities[uint256(Head.DORAG)];\\n            rarities[uint256(Head.DORAG)] = 0;\\n        }\\n\\n        if (\\n            md.backaccessory == BackAccessory.PATHFINDER ||\\n            md.background == Background.CITY__PURPLE ||\\n            md.background == Background.CITY__RED\\n        ) {\\n            total -= rarities[uint256(Head.ENERGY_FIELD)];\\n            rarities[uint256(Head.ENERGY_FIELD)] = 0;\\n        }\\n\\n        if (\\n            md.eyes == Eyes.HUD_GLASSES ||\\n            md.eyes == Eyes.HIPSTER_GLASSES ||\\n            md.eyes == Eyes.HIVE_GOGGLES ||\\n            md.eyes == Eyes.NOUNS_GLASSES ||\\n            md.eyes == Eyes.SPACE_VISOR ||\\n            md.eyes == Eyes.WHITE_SUNGLASSES\\n        ) {\\n            total -= rarities[uint256(Head.HEADBAND)];\\n            rarities[uint256(Head.HEADBAND)] = 0;\\n        }\\n\\n        if (md.eyes == Eyes.HAPPY) {\\n            Head[2] memory xs = [\\n                Head.LEATHER_COWBOY_HAT,\\n                Head.PURPLE_COWBOY_HAT\\n            ];\\n            for (uint256 i = 0; i < xs.length; ++i) {\\n                total -= rarities[uint256(xs[i])];\\n                rarities[uint256(xs[i])] = 0;\\n            }\\n        }\\n\\n        if (\\n            md.accessory == Accessory.GOLD_EARRINGS ||\\n            md.eyes == Eyes.BLUE_LASER ||\\n            md.eyes == Eyes.BLUE_SHADES ||\\n            md.eyes == Eyes.DARK_SUNGLASSES ||\\n            md.eyes == Eyes.GOLDEN_SHADES ||\\n            md.eyes == Eyes.HUD_GLASSES ||\\n            md.eyes == Eyes.HIPSTER_GLASSES ||\\n            md.eyes == Eyes.HIVE_GOGGLES ||\\n            md.eyes == Eyes.MATRIX_GLASSES ||\\n            md.eyes == Eyes.NIGHT_VISION_GOGGLES ||\\n            md.eyes == Eyes.NOUNS_GLASSES ||\\n            md.eyes == Eyes.PINCENEZ ||\\n            md.eyes == Eyes.RED_LASER ||\\n            md.eyes == Eyes.SPACE_VISOR ||\\n            md.eyes == Eyes.SUNGLASSES ||\\n            md.eyes == Eyes.WHITE_SUNGLASSES ||\\n            md.mouth == Mouth.BANANA ||\\n            md.mouth == Mouth.CHROME_RESPIRATOR ||\\n            md.mouth == Mouth.CIGAR ||\\n            md.mouth == Mouth.GREEN_RESPIRATOR ||\\n            md.mouth == Mouth.MAGENTA_RESPIRATOR ||\\n            md.mouth == Mouth.MASK ||\\n            md.mouth == Mouth.MEMPO ||\\n            md.mouth == Mouth.NAVY_RESPIRATOR ||\\n            md.mouth == Mouth.PILOT_OXYGEN_MASK ||\\n            md.mouth == Mouth.PIPE ||\\n            md.mouth == Mouth.RED_RESPIRATOR ||\\n            md.mouth == Mouth.VAPE\\n        ) {\\n            total -= rarities[uint256(Head.SPACESUIT_HELMET)];\\n            rarities[uint256(Head.SPACESUIT_HELMET)] = 0;\\n        }\\n\\n        md.head = Head(getRandom(rng, total, rarities));\\n\\n        staticRng = rng;\\n        chainScouts.adminSetChainScoutMetadata(tokenId, md);\\n    }\\n\\n    function rerollMouth(uint256 tokenId)\\n        external\\n        canAccessToken(tokenId)\\n        whenEnabled\\n    {\\n        token.burn(msg.sender, mouthCost);\\n\\n        ChainScoutMetadata memory md = chainScouts.getChainScoutMetadata(\\n            tokenId\\n        );\\n        Rng memory rng = staticRng;\\n\\n        uint16[] memory rarities = Rarities.mouth();\\n        uint256 total = 10000;\\n\\n        total -= rarities[uint256(md.mouth)];\\n        rarities[uint256(md.mouth)] = 0;\\n\\n        if (\\n            md.eyes == Eyes.BLUE_LASER ||\\n            md.eyes == Eyes.RED_LASER ||\\n            md.head == Head.CYBER_HELMET__BLUE ||\\n            md.head == Head.CYBER_HELMET__RED ||\\n            md.head == Head.SPACESUIT_HELMET\\n        ) {\\n            total -= rarities[uint256(Mouth.BANANA)];\\n            rarities[uint256(Mouth.BANANA)] = 0;\\n        }\\n\\n        if (\\n            md.clothing == Clothing.FLEET_UNIFORM__BLUE ||\\n            md.clothing == Clothing.FLEET_UNIFORM__RED ||\\n            md.eyes == Eyes.BLUE_LASER ||\\n            md.eyes == Eyes.BLUE_SHADES ||\\n            md.eyes == Eyes.DARK_SUNGLASSES ||\\n            md.eyes == Eyes.GOLDEN_SHADES ||\\n            md.eyes == Eyes.HIPSTER_GLASSES ||\\n            md.eyes == Eyes.NOUNS_GLASSES ||\\n            md.eyes == Eyes.RED_LASER ||\\n            md.eyes == Eyes.SPACE_VISOR ||\\n            md.head == Head.BANDANA ||\\n            md.head == Head.CYBER_HELMET__BLUE ||\\n            md.head == Head.CYBER_HELMET__RED ||\\n            md.head == Head.DORAG ||\\n            md.head == Head.SPACESUIT_HELMET\\n        ) {\\n            Mouth[5] memory xs = [\\n                Mouth.CHROME_RESPIRATOR,\\n                Mouth.GREEN_RESPIRATOR,\\n                Mouth.MAGENTA_RESPIRATOR,\\n                Mouth.NAVY_RESPIRATOR,\\n                Mouth.RED_RESPIRATOR\\n            ];\\n            for (uint256 i = 0; i < xs.length; ++i) {\\n                total -= rarities[uint256(xs[i])];\\n                rarities[uint256(xs[i])] = 0;\\n            }\\n        }\\n\\n        if (\\n            md.head == Head.CYBER_HELMET__BLUE ||\\n            md.head == Head.CYBER_HELMET__RED ||\\n            md.head == Head.SPACESUIT_HELMET\\n        ) {\\n            Mouth[3] memory xs = [Mouth.CIGAR, Mouth.PIPE, Mouth.VAPE];\\n            for (uint256 i = 0; i < xs.length; ++i) {\\n                total -= rarities[uint256(xs[i])];\\n                rarities[uint256(xs[i])] = 0;\\n            }\\n        }\\n\\n        if (\\n            uint256(md.eyes) == 0 ||\\n            uint256(md.eyes) == 13 ||\\n            uint256(md.eyes) == 25 ||\\n            uint256(md.eyes) == 26 ||\\n            uint256(md.eyes) == 27 ||\\n            uint256(md.eyes) == 28 ||\\n            uint256(md.eyes) == 30 ||\\n            uint256(md.eyes) == 32 ||\\n            uint256(md.head) == 14 ||\\n            uint256(md.head) == 18 ||\\n            uint256(md.head) == 19\\n        ) {\\n            Mouth[5] memory xs = [\\n                Mouth.CHROME_RESPIRATOR,\\n                Mouth.GREEN_RESPIRATOR,\\n                Mouth.MAGENTA_RESPIRATOR,\\n                Mouth.NAVY_RESPIRATOR,\\n                Mouth.RED_RESPIRATOR\\n            ];\\n            for (uint256 i = 0; i < xs.length; ++i) {\\n                total -= rarities[uint256(xs[i])];\\n                rarities[uint256(xs[i])] = 0;\\n            }\\n        }\\n\\n        if (\\n            md.eyes == Eyes.BLUE_LASER ||\\n            md.eyes == Eyes.BLUE_SHADES ||\\n            md.eyes == Eyes.DARK_SUNGLASSES ||\\n            md.eyes == Eyes.GOLDEN_SHADES ||\\n            md.eyes == Eyes.HIPSTER_GLASSES ||\\n            md.eyes == Eyes.NOUNS_GLASSES ||\\n            md.eyes == Eyes.PINCENEZ ||\\n            md.eyes == Eyes.RED_LASER ||\\n            md.eyes == Eyes.SUNGLASSES ||\\n            md.head == Head.SPACESUIT_HELMET\\n        ) {\\n            total -= rarities[uint256(Mouth.MASK)];\\n            rarities[uint256(Mouth.MASK)] = 0;\\n        }\\n\\n        if (\\n            md.eyes == Eyes.BLUE_LASER ||\\n            md.eyes == Eyes.HIPSTER_GLASSES ||\\n            md.eyes == Eyes.NOUNS_GLASSES ||\\n            md.eyes == Eyes.PINCENEZ ||\\n            md.eyes == Eyes.RED_LASER ||\\n            md.eyes == Eyes.SPACE_VISOR ||\\n            md.head == Head.CYBER_HELMET__BLUE ||\\n            md.head == Head.CYBER_HELMET__RED ||\\n            md.head == Head.SPACESUIT_HELMET\\n        ) {\\n            total -= rarities[uint256(Mouth.MEMPO)];\\n            rarities[uint256(Mouth.MEMPO)] = 0;\\n        }\\n\\n        if (\\n            md.eyes == Eyes.BLUE_LASER ||\\n            md.eyes == Eyes.NOUNS_GLASSES ||\\n            md.eyes == Eyes.RED_LASER ||\\n            md.head == Head.CYBER_HELMET__BLUE ||\\n            md.head == Head.CYBER_HELMET__RED ||\\n            md.head == Head.SPACESUIT_HELMET\\n        ) {\\n            total -= rarities[uint256(Mouth.PILOT_OXYGEN_MASK)];\\n            rarities[uint256(Mouth.PILOT_OXYGEN_MASK)] = 0;\\n        }\\n\\n        md.mouth = Mouth(getRandom(rng, total, rarities));\\n\\n        staticRng = rng;\\n        chainScouts.adminSetChainScoutMetadata(tokenId, md);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ChainScoutsExtension.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IChainScouts.sol\\\";\\n\\nabstract contract ChainScoutsExtension {\\n    IChainScouts internal chainScouts;\\n    bool public enabled = true;\\n\\n    modifier canAccessToken(uint tokenId) {\\n        require(chainScouts.canAccessToken(msg.sender, tokenId), \\\"ChainScoutsExtension: you don't own the token\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(chainScouts.isAdmin(msg.sender), \\\"ChainScoutsExtension: admins only\\\");\\n        _;\\n    }\\n\\n    modifier whenEnabled() {\\n        require(enabled, \\\"ChainScoutsExtension: currently disabled\\\");\\n        _;\\n    }\\n\\n    function adminSetEnabled(bool e) external onlyAdmin {\\n        enabled = e;\\n    }\\n\\n    function extensionKey() public virtual view returns (string memory);\\n\\n    function setChainScouts(IChainScouts _contract) external {\\n        require(address(0) == address(chainScouts) || chainScouts.isAdmin(msg.sender), \\\"ChainScoutsExtension: The Chain Scouts contract must not be set or you must be an admin\\\");\\n        chainScouts = _contract;\\n        chainScouts.adminSetExtension(extensionKey(), this);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IUtilityERC20.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IUtilityERC20 is IERC20 {\\n    function adminMint(address owner, uint amountWei) external;\\n\\n    function adminSetTokenTimestamp(uint tokenId, uint timestamp) external;\\n\\n    function burn(address owner, uint amountWei) external;\\n\\n    function claimRewards() external;\\n\\n    function stake(uint[] calldata tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Rarities.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Enums.sol\\\";\\n\\nlibrary Rarities {\\n    function accessory() internal pure returns (uint16[] memory ret) {\\n        ret = new uint16[](7);\\n        ret[0] = 1200;\\n        ret[1] = 800;\\n        ret[2] = 800;\\n        ret[3] = 400;\\n        ret[4] = 400;\\n        ret[5] = 400;\\n        ret[6] = 6000;\\n    }\\n\\n    function backaccessory() internal pure returns (uint16[] memory ret) {\\n        ret = new uint16[](8);\\n        ret[0] = 200;\\n        ret[1] = 1300;\\n        ret[2] = 800;\\n        ret[3] = 400;\\n        ret[4] = 1100;\\n        ret[5] = 700;\\n        ret[6] = 500;\\n        ret[7] = 5000;\\n    }\\n\\n    function background() internal pure returns (uint16[] memory ret) {\\n        ret = new uint16[](23);\\n        ret[0] = 600;\\n        ret[1] = 600;\\n        ret[2] = 600;\\n        ret[3] = 600;\\n        ret[4] = 500;\\n        ret[5] = 500;\\n        ret[6] = 500;\\n        ret[7] = 500;\\n        ret[8] = 500;\\n        ret[9] = 500;\\n        ret[10] = 100;\\n        ret[11] = 100;\\n        ret[12] = 100;\\n        ret[13] = 600;\\n        ret[14] = 600;\\n        ret[15] = 600;\\n        ret[16] = 100;\\n        ret[17] = 100;\\n        ret[18] = 400;\\n        ret[19] = 400;\\n        ret[20] = 500;\\n        ret[21] = 500;\\n        ret[22] = 500;\\n    }\\n\\n    function clothing() internal pure returns (uint16[] memory ret) {\\n        ret = new uint16[](24);\\n        ret[0] = 500;\\n        ret[1] = 500;\\n        ret[2] = 300;\\n        ret[3] = 300;\\n        ret[4] = 500;\\n        ret[5] = 400;\\n        ret[6] = 300;\\n        ret[7] = 250;\\n        ret[8] = 250;\\n        ret[9] = 500;\\n        ret[10] = 100;\\n        ret[11] = 500;\\n        ret[12] = 300;\\n        ret[13] = 500;\\n        ret[14] = 500;\\n        ret[15] = 500;\\n        ret[16] = 100;\\n        ret[17] = 400;\\n        ret[18] = 400;\\n        ret[19] = 250;\\n        ret[20] = 250;\\n        ret[21] = 250;\\n        ret[22] = 150;\\n        ret[23] = 2000;\\n    }\\n\\n    function eyes() internal pure returns (uint16[] memory ret) {\\n        ret = new uint16[](32);\\n        ret[0] = 250;\\n        ret[1] = 700;\\n        ret[2] = 225;\\n        ret[3] = 350;\\n        ret[4] = 125;\\n        ret[5] = 450;\\n        ret[6] = 700;\\n        ret[7] = 700;\\n        ret[8] = 350;\\n        ret[9] = 350;\\n        ret[10] = 600;\\n        ret[11] = 450;\\n        ret[12] = 250;\\n        ret[13] = 350;\\n        ret[14] = 350;\\n        ret[15] = 225;\\n        ret[16] = 125;\\n        ret[17] = 350;\\n        ret[18] = 200;\\n        ret[19] = 200;\\n        ret[20] = 200;\\n        ret[21] = 200;\\n        ret[22] = 200;\\n        ret[23] = 200;\\n        ret[24] = 50;\\n        ret[25] = 50;\\n        ret[26] = 450;\\n        ret[27] = 450;\\n        ret[28] = 400;\\n        ret[29] = 450;\\n        ret[30] = 25;\\n        ret[31] = 25;\\n    }\\n\\n    function fur() internal pure returns (uint16[] memory ret) {\\n        ret = new uint16[](16);\\n        ret[0] = 1100;\\n        ret[1] = 1100;\\n        ret[2] = 1100;\\n        ret[3] = 525;\\n        ret[4] = 350;\\n        ret[5] = 1100;\\n        ret[6] = 350;\\n        ret[7] = 1100;\\n        ret[8] = 1000;\\n        ret[9] = 525;\\n        ret[10] = 525;\\n        ret[11] = 500;\\n        ret[12] = 525;\\n        ret[13] = 100;\\n        ret[14] = 50;\\n        ret[15] = 50;\\n    }\\n\\n    function head() internal pure returns (uint16[] memory ret) {\\n        ret = new uint16[](21);\\n        ret[0] = 200;\\n        ret[1] = 200;\\n        ret[2] = 350;\\n        ret[3] = 350;\\n        ret[4] = 350;\\n        ret[5] = 150;\\n        ret[6] = 600;\\n        ret[7] = 350;\\n        ret[8] = 350;\\n        ret[9] = 350;\\n        ret[10] = 600;\\n        ret[11] = 600;\\n        ret[12] = 600;\\n        ret[13] = 200;\\n        ret[14] = 350;\\n        ret[15] = 600;\\n        ret[16] = 600;\\n        ret[17] = 50;\\n        ret[18] = 50;\\n        ret[19] = 100;\\n        ret[20] = 3000;\\n    }\\n\\n    function mouth() internal pure returns (uint16[] memory ret) {\\n        ret = new uint16[](21);\\n        ret[0] = 1000;\\n        ret[1] = 1000;\\n        ret[2] = 1000;\\n        ret[3] = 650;\\n        ret[4] = 1000;\\n        ret[5] = 900;\\n        ret[6] = 750;\\n        ret[7] = 650;\\n        ret[8] = 100;\\n        ret[9] = 50;\\n        ret[10] = 100;\\n        ret[11] = 100;\\n        ret[12] = 100;\\n        ret[13] = 100;\\n        ret[14] = 50;\\n        ret[15] = 100;\\n        ret[16] = 100;\\n        ret[17] = 600;\\n        ret[18] = 600;\\n        ret[19] = 50;\\n        ret[20] = 1000;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Rng.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title A pseudo random number generator\\n *\\n * @dev This is not a true random number generator because smart contracts must be deterministic (every node a transaction goes to must produce the same result).\\n *      True randomness requires an oracle which is both expensive in terms of gas and would take a critical part of the project off the chain.\\n */\\nstruct Rng {\\n    bytes32 state;\\n}\\n\\n/**\\n * @title A library for working with the Rng struct.\\n *\\n * @dev Rng cannot be a contract because then anyone could manipulate it by generating random numbers.\\n */\\nlibrary RngLibrary {\\n    /**\\n     * Creates a new Rng.\\n     */\\n    function newRng() internal view returns (Rng memory) {\\n        return Rng(getEntropy());\\n    }\\n\\n    /**\\n     * Creates a pseudo-random value from the current block miner's address and sender.\\n     */\\n    function getEntropy() internal view returns (bytes32) {\\n        return keccak256(abi.encodePacked(block.coinbase, msg.sender));\\n    }\\n\\n    /**\\n     * Generates a random uint256.\\n     */\\n    function generate(Rng memory self) internal view returns (uint256) {\\n        self.state = keccak256(abi.encodePacked(getEntropy(), self.state));\\n        return uint256(self.state);\\n    }\\n\\n    /**\\n     * Generates a random uint256 from min to max inclusive.\\n     *\\n     * @dev This function is not subject to modulo bias.\\n     *      The chance that this function has to reroll is astronomically unlikely, but it can theoretically reroll forever.\\n     */\\n    function generate(Rng memory self, uint min, uint max) internal view returns (uint256) {\\n        require(min <= max, \\\"min > max\\\");\\n\\n        uint delta = max - min;\\n\\n        if (delta == 0) {\\n            return min;\\n        }\\n\\n        return generate(self) % (delta + 1) + min;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IChainScouts.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IExtensibleERC721Enumerable.sol\\\";\\nimport \\\"./ChainScoutsExtension.sol\\\";\\nimport \\\"./ChainScoutMetadata.sol\\\";\\n\\ninterface IChainScouts is IExtensibleERC721Enumerable {\\n    function adminCreateChainScout(\\n        ChainScoutMetadata calldata tbd,\\n        address owner\\n    ) external;\\n\\n    function adminRemoveExtension(string calldata key) external;\\n\\n    function adminSetExtension(\\n        string calldata key,\\n        ChainScoutsExtension extension\\n    ) external;\\n\\n    function adminSetChainScoutMetadata(\\n        uint256 tokenId,\\n        ChainScoutMetadata calldata tbd\\n    ) external;\\n\\n    function getChainScoutMetadata(uint256 tokenId)\\n        external\\n        view\\n        returns (ChainScoutMetadata memory);\\n}\\n\"\r\n    },\r\n    \"contracts/IExtensibleERC721Enumerable.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\ninterface IExtensibleERC721Enumerable is IERC721Enumerable {\\n    function isAdmin(address addr) external view returns (bool);\\n\\n    function addAdmin(address addr) external;\\n\\n    function removeAdmin(address addr) external;\\n\\n    function canAccessToken(address addr, uint tokenId) external view returns (bool);\\n\\n    function adminBurn(uint tokenId) external;\\n\\n    function adminTransfer(address from, address to, uint tokenId) external;\\n}\"\r\n    },\r\n    \"contracts/ChainScoutMetadata.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Enums.sol\\\";\\n\\nstruct KeyValuePair {\\n    string key;\\n    string value;\\n}\\n\\nstruct ChainScoutMetadata {\\n    Accessory accessory;\\n    BackAccessory backaccessory;\\n    Background background;\\n    Clothing clothing;\\n    Eyes eyes;\\n    Fur fur;\\n    Head head;\\n    Mouth mouth;\\n    uint24 attack;\\n    uint24 defense;\\n    uint24 luck;\\n    uint24 speed;\\n    uint24 strength;\\n    uint24 intelligence;\\n    uint16 level;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Enums.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nenum Accessory {\\n    GOLD_EARRINGS,\\n    SCARS,\\n    GOLDEN_CHAIN,\\n    AMULET,\\n    CUBAN_LINK_GOLD_CHAIN,\\n    FANNY_PACK,\\n    NONE\\n}\\n\\nenum BackAccessory {\\n    NETRUNNER,\\n    MERCENARY,\\n    RONIN,\\n    ENCHANTER,\\n    VANGUARD,\\n    MINER,\\n    PATHFINDER,\\n    SCOUT\\n}\\n\\nenum Background {\\n    STARRY_PINK,\\n    STARRY_YELLOW,\\n    STARRY_PURPLE,\\n    STARRY_GREEN,\\n    NEBULA,\\n    STARRY_RED,\\n    STARRY_BLUE,\\n    SUNSET,\\n    MORNING,\\n    INDIGO,\\n    CITY__PURPLE,\\n    CONTROL_ROOM,\\n    LAB,\\n    GREEN,\\n    ORANGE,\\n    PURPLE,\\n    CITY__GREEN,\\n    CITY__RED,\\n    STATION,\\n    BOUNTY,\\n    BLUE_SKY,\\n    RED_SKY,\\n    GREEN_SKY\\n}\\n\\nenum Clothing {\\n    MARTIAL_SUIT,\\n    AMETHYST_ARMOR,\\n    SHIRT_AND_TIE,\\n    THUNDERDOME_ARMOR,\\n    FLEET_UNIFORM__BLUE,\\n    BANANITE_SHIRT,\\n    EXPLORER,\\n    COSMIC_GHILLIE_SUIT__BLUE,\\n    COSMIC_GHILLIE_SUIT__GOLD,\\n    CYBER_JUMPSUIT,\\n    ENCHANTER_ROBES,\\n    HOODIE,\\n    SPACESUIT,\\n    MECHA_ARMOR,\\n    LAB_COAT,\\n    FLEET_UNIFORM__RED,\\n    GOLD_ARMOR,\\n    ENERGY_ARMOR__BLUE,\\n    ENERGY_ARMOR__RED,\\n    MISSION_SUIT__BLACK,\\n    MISSION_SUIT__PURPLE,\\n    COWBOY,\\n    GLITCH_ARMOR,\\n    NONE\\n}\\n\\nenum Eyes {\\n    SPACE_VISOR,\\n    ADORABLE,\\n    VETERAN,\\n    SUNGLASSES,\\n    WHITE_SUNGLASSES,\\n    RED_EYES,\\n    WINK,\\n    CASUAL,\\n    CLOSED,\\n    DOWNCAST,\\n    HAPPY,\\n    BLUE_EYES,\\n    HUD_GLASSES,\\n    DARK_SUNGLASSES,\\n    NIGHT_VISION_GOGGLES,\\n    BIONIC,\\n    HIVE_GOGGLES,\\n    MATRIX_GLASSES,\\n    GREEN_GLOW,\\n    ORANGE_GLOW,\\n    RED_GLOW,\\n    PURPLE_GLOW,\\n    BLUE_GLOW,\\n    SKY_GLOW,\\n    RED_LASER,\\n    BLUE_LASER,\\n    GOLDEN_SHADES,\\n    HIPSTER_GLASSES,\\n    PINCENEZ,\\n    BLUE_SHADES,\\n    BLIT_GLASSES,\\n    NOUNS_GLASSES\\n}\\n\\nenum Fur {\\n    MAGENTA,\\n    BLUE,\\n    GREEN,\\n    RED,\\n    BLACK,\\n    BROWN,\\n    SILVER,\\n    PURPLE,\\n    PINK,\\n    SEANCE,\\n    TURQUOISE,\\n    CRIMSON,\\n    GREENYELLOW,\\n    GOLD,\\n    DIAMOND,\\n    METALLIC\\n}\\n\\nenum Head {\\n    HALO,\\n    ENERGY_FIELD,\\n    BLUE_TOP_HAT,\\n    RED_TOP_HAT,\\n    ENERGY_CRYSTAL,\\n    CROWN,\\n    BANDANA,\\n    BUCKET_HAT,\\n    HOMBURG_HAT,\\n    PROPELLER_HAT,\\n    HEADBAND,\\n    DORAG,\\n    PURPLE_COWBOY_HAT,\\n    SPACESUIT_HELMET,\\n    PARTY_HAT,\\n    CAP,\\n    LEATHER_COWBOY_HAT,\\n    CYBER_HELMET__BLUE,\\n    CYBER_HELMET__RED,\\n    SAMURAI_HAT,\\n    NONE\\n}\\n\\nenum Mouth {\\n    SMIRK,\\n    SURPRISED,\\n    SMILE,\\n    PIPE,\\n    OPEN_SMILE,\\n    NEUTRAL,\\n    MASK,\\n    TONGUE_OUT,\\n    GOLD_GRILL,\\n    DIAMOND_GRILL,\\n    NAVY_RESPIRATOR,\\n    RED_RESPIRATOR,\\n    MAGENTA_RESPIRATOR,\\n    GREEN_RESPIRATOR,\\n    MEMPO,\\n    VAPE,\\n    PILOT_OXYGEN_MASK,\\n    CIGAR,\\n    BANANA,\\n    CHROME_RESPIRATOR,\\n    STOIC\\n}\\n\\nlibrary Enums {\\n    function toString(Accessory v) external pure returns (string memory) {\\n        if (v == Accessory.GOLD_EARRINGS) {\\n            return \\\"Gold Earrings\\\";\\n        }\\n\\n        if (v == Accessory.SCARS) {\\n            return \\\"Scars\\\";\\n        }\\n\\n        if (v == Accessory.GOLDEN_CHAIN) {\\n            return \\\"Golden Chain\\\";\\n        }\\n\\n        if (v == Accessory.AMULET) {\\n            return \\\"Amulet\\\";\\n        }\\n\\n        if (v == Accessory.CUBAN_LINK_GOLD_CHAIN) {\\n            return \\\"Cuban Link Gold Chain\\\";\\n        }\\n\\n        if (v == Accessory.FANNY_PACK) {\\n            return \\\"Fanny Pack\\\";\\n        }\\n\\n        if (v == Accessory.NONE) {\\n            return \\\"None\\\";\\n        }\\n        revert(\\\"invalid accessory\\\");\\n    }\\n\\n    function toString(BackAccessory v) external pure returns (string memory) {\\n        if (v == BackAccessory.NETRUNNER) {\\n            return \\\"Netrunner\\\";\\n        }\\n\\n        if (v == BackAccessory.MERCENARY) {\\n            return \\\"Mercenary\\\";\\n        }\\n\\n        if (v == BackAccessory.RONIN) {\\n            return \\\"Ronin\\\";\\n        }\\n\\n        if (v == BackAccessory.ENCHANTER) {\\n            return \\\"Enchanter\\\";\\n        }\\n\\n        if (v == BackAccessory.VANGUARD) {\\n            return \\\"Vanguard\\\";\\n        }\\n\\n        if (v == BackAccessory.MINER) {\\n            return \\\"Miner\\\";\\n        }\\n\\n        if (v == BackAccessory.PATHFINDER) {\\n            return \\\"Pathfinder\\\";\\n        }\\n\\n        if (v == BackAccessory.SCOUT) {\\n            return \\\"Scout\\\";\\n        }\\n        revert(\\\"invalid back accessory\\\");\\n    }\\n\\n    function toString(Background v) external pure returns (string memory) {\\n        if (v == Background.STARRY_PINK) {\\n            return \\\"Starry Pink\\\";\\n        }\\n\\n        if (v == Background.STARRY_YELLOW) {\\n            return \\\"Starry Yellow\\\";\\n        }\\n\\n        if (v == Background.STARRY_PURPLE) {\\n            return \\\"Starry Purple\\\";\\n        }\\n\\n        if (v == Background.STARRY_GREEN) {\\n            return \\\"Starry Green\\\";\\n        }\\n\\n        if (v == Background.NEBULA) {\\n            return \\\"Nebula\\\";\\n        }\\n\\n        if (v == Background.STARRY_RED) {\\n            return \\\"Starry Red\\\";\\n        }\\n\\n        if (v == Background.STARRY_BLUE) {\\n            return \\\"Starry Blue\\\";\\n        }\\n\\n        if (v == Background.SUNSET) {\\n            return \\\"Sunset\\\";\\n        }\\n\\n        if (v == Background.MORNING) {\\n            return \\\"Morning\\\";\\n        }\\n\\n        if (v == Background.INDIGO) {\\n            return \\\"Indigo\\\";\\n        }\\n\\n        if (v == Background.CITY__PURPLE) {\\n            return \\\"City - Purple\\\";\\n        }\\n\\n        if (v == Background.CONTROL_ROOM) {\\n            return \\\"Control Room\\\";\\n        }\\n\\n        if (v == Background.LAB) {\\n            return \\\"Lab\\\";\\n        }\\n\\n        if (v == Background.GREEN) {\\n            return \\\"Green\\\";\\n        }\\n\\n        if (v == Background.ORANGE) {\\n            return \\\"Orange\\\";\\n        }\\n\\n        if (v == Background.PURPLE) {\\n            return \\\"Purple\\\";\\n        }\\n\\n        if (v == Background.CITY__GREEN) {\\n            return \\\"City - Green\\\";\\n        }\\n\\n        if (v == Background.CITY__RED) {\\n            return \\\"City - Red\\\";\\n        }\\n\\n        if (v == Background.STATION) {\\n            return \\\"Station\\\";\\n        }\\n\\n        if (v == Background.BOUNTY) {\\n            return \\\"Bounty\\\";\\n        }\\n\\n        if (v == Background.BLUE_SKY) {\\n            return \\\"Blue Sky\\\";\\n        }\\n\\n        if (v == Background.RED_SKY) {\\n            return \\\"Red Sky\\\";\\n        }\\n\\n        if (v == Background.GREEN_SKY) {\\n            return \\\"Green Sky\\\";\\n        }\\n        revert(\\\"invalid background\\\");\\n    }\\n\\n    function toString(Clothing v) external pure returns (string memory) {\\n        if (v == Clothing.MARTIAL_SUIT) {\\n            return \\\"Martial Suit\\\";\\n        }\\n\\n        if (v == Clothing.AMETHYST_ARMOR) {\\n            return \\\"Amethyst Armor\\\";\\n        }\\n\\n        if (v == Clothing.SHIRT_AND_TIE) {\\n            return \\\"Shirt and Tie\\\";\\n        }\\n\\n        if (v == Clothing.THUNDERDOME_ARMOR) {\\n            return \\\"Thunderdome Armor\\\";\\n        }\\n\\n        if (v == Clothing.FLEET_UNIFORM__BLUE) {\\n            return \\\"Fleet Uniform - Blue\\\";\\n        }\\n\\n        if (v == Clothing.BANANITE_SHIRT) {\\n            return \\\"Bananite Shirt\\\";\\n        }\\n\\n        if (v == Clothing.EXPLORER) {\\n            return \\\"Explorer\\\";\\n        }\\n\\n        if (v == Clothing.COSMIC_GHILLIE_SUIT__BLUE) {\\n            return \\\"Cosmic Ghillie Suit - Blue\\\";\\n        }\\n\\n        if (v == Clothing.COSMIC_GHILLIE_SUIT__GOLD) {\\n            return \\\"Cosmic Ghillie Suit - Gold\\\";\\n        }\\n\\n        if (v == Clothing.CYBER_JUMPSUIT) {\\n            return \\\"Cyber Jumpsuit\\\";\\n        }\\n\\n        if (v == Clothing.ENCHANTER_ROBES) {\\n            return \\\"Enchanter Robes\\\";\\n        }\\n\\n        if (v == Clothing.HOODIE) {\\n            return \\\"Hoodie\\\";\\n        }\\n\\n        if (v == Clothing.SPACESUIT) {\\n            return \\\"Spacesuit\\\";\\n        }\\n\\n        if (v == Clothing.MECHA_ARMOR) {\\n            return \\\"Mecha Armor\\\";\\n        }\\n\\n        if (v == Clothing.LAB_COAT) {\\n            return \\\"Lab Coat\\\";\\n        }\\n\\n        if (v == Clothing.FLEET_UNIFORM__RED) {\\n            return \\\"Fleet Uniform - Red\\\";\\n        }\\n\\n        if (v == Clothing.GOLD_ARMOR) {\\n            return \\\"Gold Armor\\\";\\n        }\\n\\n        if (v == Clothing.ENERGY_ARMOR__BLUE) {\\n            return \\\"Energy Armor - Blue\\\";\\n        }\\n\\n        if (v == Clothing.ENERGY_ARMOR__RED) {\\n            return \\\"Energy Armor - Red\\\";\\n        }\\n\\n        if (v == Clothing.MISSION_SUIT__BLACK) {\\n            return \\\"Mission Suit - Black\\\";\\n        }\\n\\n        if (v == Clothing.MISSION_SUIT__PURPLE) {\\n            return \\\"Mission Suit - Purple\\\";\\n        }\\n\\n        if (v == Clothing.COWBOY) {\\n            return \\\"Cowboy\\\";\\n        }\\n\\n        if (v == Clothing.GLITCH_ARMOR) {\\n            return \\\"Glitch Armor\\\";\\n        }\\n\\n        if (v == Clothing.NONE) {\\n            return \\\"None\\\";\\n        }\\n        revert(\\\"invalid clothing\\\");\\n    }\\n\\n    function toString(Eyes v) external pure returns (string memory) {\\n        if (v == Eyes.SPACE_VISOR) {\\n            return \\\"Space Visor\\\";\\n        }\\n\\n        if (v == Eyes.ADORABLE) {\\n            return \\\"Adorable\\\";\\n        }\\n\\n        if (v == Eyes.VETERAN) {\\n            return \\\"Veteran\\\";\\n        }\\n\\n        if (v == Eyes.SUNGLASSES) {\\n            return \\\"Sunglasses\\\";\\n        }\\n\\n        if (v == Eyes.WHITE_SUNGLASSES) {\\n            return \\\"White Sunglasses\\\";\\n        }\\n\\n        if (v == Eyes.RED_EYES) {\\n            return \\\"Red Eyes\\\";\\n        }\\n\\n        if (v == Eyes.WINK) {\\n            return \\\"Wink\\\";\\n        }\\n\\n        if (v == Eyes.CASUAL) {\\n            return \\\"Casual\\\";\\n        }\\n\\n        if (v == Eyes.CLOSED) {\\n            return \\\"Closed\\\";\\n        }\\n\\n        if (v == Eyes.DOWNCAST) {\\n            return \\\"Downcast\\\";\\n        }\\n\\n        if (v == Eyes.HAPPY) {\\n            return \\\"Happy\\\";\\n        }\\n\\n        if (v == Eyes.BLUE_EYES) {\\n            return \\\"Blue Eyes\\\";\\n        }\\n\\n        if (v == Eyes.HUD_GLASSES) {\\n            return \\\"HUD Glasses\\\";\\n        }\\n\\n        if (v == Eyes.DARK_SUNGLASSES) {\\n            return \\\"Dark Sunglasses\\\";\\n        }\\n\\n        if (v == Eyes.NIGHT_VISION_GOGGLES) {\\n            return \\\"Night Vision Goggles\\\";\\n        }\\n\\n        if (v == Eyes.BIONIC) {\\n            return \\\"Bionic\\\";\\n        }\\n\\n        if (v == Eyes.HIVE_GOGGLES) {\\n            return \\\"Hive Goggles\\\";\\n        }\\n\\n        if (v == Eyes.MATRIX_GLASSES) {\\n            return \\\"Matrix Glasses\\\";\\n        }\\n\\n        if (v == Eyes.GREEN_GLOW) {\\n            return \\\"Green Glow\\\";\\n        }\\n\\n        if (v == Eyes.ORANGE_GLOW) {\\n            return \\\"Orange Glow\\\";\\n        }\\n\\n        if (v == Eyes.RED_GLOW) {\\n            return \\\"Red Glow\\\";\\n        }\\n\\n        if (v == Eyes.PURPLE_GLOW) {\\n            return \\\"Purple Glow\\\";\\n        }\\n\\n        if (v == Eyes.BLUE_GLOW) {\\n            return \\\"Blue Glow\\\";\\n        }\\n\\n        if (v == Eyes.SKY_GLOW) {\\n            return \\\"Sky Glow\\\";\\n        }\\n\\n        if (v == Eyes.RED_LASER) {\\n            return \\\"Red Laser\\\";\\n        }\\n\\n        if (v == Eyes.BLUE_LASER) {\\n            return \\\"Blue Laser\\\";\\n        }\\n\\n        if (v == Eyes.GOLDEN_SHADES) {\\n            return \\\"Golden Shades\\\";\\n        }\\n\\n        if (v == Eyes.HIPSTER_GLASSES) {\\n            return \\\"Hipster Glasses\\\";\\n        }\\n\\n        if (v == Eyes.PINCENEZ) {\\n            return \\\"Pince-nez\\\";\\n        }\\n\\n        if (v == Eyes.BLUE_SHADES) {\\n            return \\\"Blue Shades\\\";\\n        }\\n\\n        if (v == Eyes.BLIT_GLASSES) {\\n            return \\\"Blit GLasses\\\";\\n        }\\n\\n        if (v == Eyes.NOUNS_GLASSES) {\\n            return \\\"Nouns Glasses\\\";\\n        }\\n        revert(\\\"invalid eyes\\\");\\n    }\\n\\n    function toString(Fur v) external pure returns (string memory) {\\n        if (v == Fur.MAGENTA) {\\n            return \\\"Magenta\\\";\\n        }\\n\\n        if (v == Fur.BLUE) {\\n            return \\\"Blue\\\";\\n        }\\n\\n        if (v == Fur.GREEN) {\\n            return \\\"Green\\\";\\n        }\\n\\n        if (v == Fur.RED) {\\n            return \\\"Red\\\";\\n        }\\n\\n        if (v == Fur.BLACK) {\\n            return \\\"Black\\\";\\n        }\\n\\n        if (v == Fur.BROWN) {\\n            return \\\"Brown\\\";\\n        }\\n\\n        if (v == Fur.SILVER) {\\n            return \\\"Silver\\\";\\n        }\\n\\n        if (v == Fur.PURPLE) {\\n            return \\\"Purple\\\";\\n        }\\n\\n        if (v == Fur.PINK) {\\n            return \\\"Pink\\\";\\n        }\\n\\n        if (v == Fur.SEANCE) {\\n            return \\\"Seance\\\";\\n        }\\n\\n        if (v == Fur.TURQUOISE) {\\n            return \\\"Turquoise\\\";\\n        }\\n\\n        if (v == Fur.CRIMSON) {\\n            return \\\"Crimson\\\";\\n        }\\n\\n        if (v == Fur.GREENYELLOW) {\\n            return \\\"Green-Yellow\\\";\\n        }\\n\\n        if (v == Fur.GOLD) {\\n            return \\\"Gold\\\";\\n        }\\n\\n        if (v == Fur.DIAMOND) {\\n            return \\\"Diamond\\\";\\n        }\\n\\n        if (v == Fur.METALLIC) {\\n            return \\\"Metallic\\\";\\n        }\\n        revert(\\\"invalid fur\\\");\\n    }\\n\\n    function toString(Head v) external pure returns (string memory) {\\n        if (v == Head.HALO) {\\n            return \\\"Halo\\\";\\n        }\\n\\n        if (v == Head.ENERGY_FIELD) {\\n            return \\\"Energy Field\\\";\\n        }\\n\\n        if (v == Head.BLUE_TOP_HAT) {\\n            return \\\"Blue Top Hat\\\";\\n        }\\n\\n        if (v == Head.RED_TOP_HAT) {\\n            return \\\"Red Top Hat\\\";\\n        }\\n\\n        if (v == Head.ENERGY_CRYSTAL) {\\n            return \\\"Energy Crystal\\\";\\n        }\\n\\n        if (v == Head.CROWN) {\\n            return \\\"Crown\\\";\\n        }\\n\\n        if (v == Head.BANDANA) {\\n            return \\\"Bandana\\\";\\n        }\\n\\n        if (v == Head.BUCKET_HAT) {\\n            return \\\"Bucket Hat\\\";\\n        }\\n\\n        if (v == Head.HOMBURG_HAT) {\\n            return \\\"Homburg Hat\\\";\\n        }\\n\\n        if (v == Head.PROPELLER_HAT) {\\n            return \\\"Propeller Hat\\\";\\n        }\\n\\n        if (v == Head.HEADBAND) {\\n            return \\\"Headband\\\";\\n        }\\n\\n        if (v == Head.DORAG) {\\n            return \\\"Do-rag\\\";\\n        }\\n\\n        if (v == Head.PURPLE_COWBOY_HAT) {\\n            return \\\"Purple Cowboy Hat\\\";\\n        }\\n\\n        if (v == Head.SPACESUIT_HELMET) {\\n            return \\\"Spacesuit Helmet\\\";\\n        }\\n\\n        if (v == Head.PARTY_HAT) {\\n            return \\\"Party Hat\\\";\\n        }\\n\\n        if (v == Head.CAP) {\\n            return \\\"Cap\\\";\\n        }\\n\\n        if (v == Head.LEATHER_COWBOY_HAT) {\\n            return \\\"Leather Cowboy Hat\\\";\\n        }\\n\\n        if (v == Head.CYBER_HELMET__BLUE) {\\n            return \\\"Cyber Helmet - Blue\\\";\\n        }\\n\\n        if (v == Head.CYBER_HELMET__RED) {\\n            return \\\"Cyber Helmet - Red\\\";\\n        }\\n\\n        if (v == Head.SAMURAI_HAT) {\\n            return \\\"Samurai Hat\\\";\\n        }\\n\\n        if (v == Head.NONE) {\\n            return \\\"None\\\";\\n        }\\n        revert(\\\"invalid head\\\");\\n    }\\n\\n    function toString(Mouth v) external pure returns (string memory) {\\n        if (v == Mouth.SMIRK) {\\n            return \\\"Smirk\\\";\\n        }\\n\\n        if (v == Mouth.SURPRISED) {\\n            return \\\"Surprised\\\";\\n        }\\n\\n        if (v == Mouth.SMILE) {\\n            return \\\"Smile\\\";\\n        }\\n\\n        if (v == Mouth.PIPE) {\\n            return \\\"Pipe\\\";\\n        }\\n\\n        if (v == Mouth.OPEN_SMILE) {\\n            return \\\"Open Smile\\\";\\n        }\\n\\n        if (v == Mouth.NEUTRAL) {\\n            return \\\"Neutral\\\";\\n        }\\n\\n        if (v == Mouth.MASK) {\\n            return \\\"Mask\\\";\\n        }\\n\\n        if (v == Mouth.TONGUE_OUT) {\\n            return \\\"Tongue Out\\\";\\n        }\\n\\n        if (v == Mouth.GOLD_GRILL) {\\n            return \\\"Gold Grill\\\";\\n        }\\n\\n        if (v == Mouth.DIAMOND_GRILL) {\\n            return \\\"Diamond Grill\\\";\\n        }\\n\\n        if (v == Mouth.NAVY_RESPIRATOR) {\\n            return \\\"Navy Respirator\\\";\\n        }\\n\\n        if (v == Mouth.RED_RESPIRATOR) {\\n            return \\\"Red Respirator\\\";\\n        }\\n\\n        if (v == Mouth.MAGENTA_RESPIRATOR) {\\n            return \\\"Magenta Respirator\\\";\\n        }\\n\\n        if (v == Mouth.GREEN_RESPIRATOR) {\\n            return \\\"Green Respirator\\\";\\n        }\\n\\n        if (v == Mouth.MEMPO) {\\n            return \\\"Mempo\\\";\\n        }\\n\\n        if (v == Mouth.VAPE) {\\n            return \\\"Vape\\\";\\n        }\\n\\n        if (v == Mouth.PILOT_OXYGEN_MASK) {\\n            return \\\"Pilot Oxygen Mask\\\";\\n        }\\n\\n        if (v == Mouth.CIGAR) {\\n            return \\\"Cigar\\\";\\n        }\\n\\n        if (v == Mouth.BANANA) {\\n            return \\\"Banana\\\";\\n        }\\n\\n        if (v == Mouth.CHROME_RESPIRATOR) {\\n            return \\\"Chrome Respirator\\\";\\n        }\\n\\n        if (v == Mouth.STOIC) {\\n            return \\\"Stoic\\\";\\n        }\\n        revert(\\\"invalid mouth\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IUtilityERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"accessoryCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wei\",\"type\":\"uint256\"}],\"name\":\"adminSetAccessoryCostWei\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wei\",\"type\":\"uint256\"}],\"name\":\"adminSetBackAccessoryCostWei\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wei\",\"type\":\"uint256\"}],\"name\":\"adminSetBackgroundCostWei\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wei\",\"type\":\"uint256\"}],\"name\":\"adminSetClothingCostWei\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"e\",\"type\":\"bool\"}],\"name\":\"adminSetEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"backAccessoryCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"backgroundCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clothingCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extensionKey\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"rerollAccessory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"rerollBackAccessory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"rerollBackground\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"rerollClothing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IChainScouts\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"setChainScouts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IUtilityERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Reroller", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ab3d58df8d3e4c33682e66f8d4137a565fe8c6a2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}