{"status": "1", "message": "OK", "result": [{"SourceCode": "//SPDX-License-Identifier: GPL-3.0\r\npragma solidity 0.7.3;\r\n\r\ninterface IVolatilityOracle {\r\n    function commit(address pool) external;\r\n\r\n    function twap(address pool) external returns (uint256 price);\r\n\r\n    function vol(address pool)\r\n        external\r\n        view\r\n        returns (uint256 standardDeviation);\r\n\r\n    function annualizedVol(address pool)\r\n        external\r\n        view\r\n        returns (uint256 annualStdev);\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\ninterface IPriceOracle {\r\n    function decimals() external view returns (uint256 _decimals);\r\n\r\n    function latestAnswer() external view returns (uint256 price);\r\n}\r\n\r\n\r\n\r\ncontract DSMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint256 constant WAD = 10**18;\r\n    uint256 constant RAY = 10**27;\r\n\r\n    //rounds to zero if x*WAD < y/2\r\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    //rounds to zero if x*RAY < y/2\r\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n\r\n    //rounds to zero if x*y < WAD / 2\r\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    //rounds to zero if x*y < RAY / 2\r\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\ninterface IERC20Detailed is IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string calldata);\r\n}\r\n\r\n\r\nlibrary Math {\r\n    uint256 constant FIXED_1 = 0x080000000000000000000000000000000;\r\n    uint256 constant FIXED_2 = 0x100000000000000000000000000000000;\r\n    uint256 constant SQRT_1 = 13043817825332782212;\r\n    uint256 constant LNX = 3988425491;\r\n    uint256 constant LOG_10_2 = 3010299957;\r\n    uint256 constant LOG_E_2 = 6931471806;\r\n    uint256 constant BASE = 1e10;\r\n\r\n    // solhint-disable-next-line\r\n    // Credit to Ryan Hendricks, https://github.com/RyanHendricks/Black-Scholes-Solidity/blob/master/contracts/BlackScholesEstimate.sol\r\n    /**\r\n     * @dev stddev calculates the standard deviation for an array of integers\r\n     * @dev precision is the same as sqrt above meaning for higher precision\r\n     * @dev the decimal place must be moved prior to passing the params\r\n     * @param numbers uint[] array of numbers to be used in calculation\r\n     */\r\n    function stddev(uint256[] memory numbers)\r\n        internal\r\n        pure\r\n        returns (uint256 sd)\r\n    {\r\n        uint256 sum = 0;\r\n        for (uint256 i = 0; i < numbers.length; i++) {\r\n            sum += numbers[i];\r\n        }\r\n        uint256 mean = sum / numbers.length; // Integral value; float not supported in Solidity\r\n        sum = 0;\r\n        uint256 i;\r\n        for (i = 0; i < numbers.length; i++) {\r\n            sum += (numbers[i] - mean)**2;\r\n        }\r\n        sd = sqrt(sum / (numbers.length - 1)); //Integral value; float not supported in Solidity\r\n        return sd;\r\n    }\r\n\r\n    function sqrt2(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n\r\n    // solhint-disable-next-line\r\n    // Credit to Paul Razvan Berg https://github.com/hifi-finance/prb-math/blob/main/contracts/PRBMath.sol\r\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // Set the initial guess to the closest power of two that is higher than x.\r\n        uint256 xAux = uint256(x);\r\n        result = 1;\r\n        if (xAux >= 0x100000000000000000000000000000000) {\r\n            xAux >>= 128;\r\n            result <<= 64;\r\n        }\r\n        if (xAux >= 0x10000000000000000) {\r\n            xAux >>= 64;\r\n            result <<= 32;\r\n        }\r\n        if (xAux >= 0x100000000) {\r\n            xAux >>= 32;\r\n            result <<= 16;\r\n        }\r\n        if (xAux >= 0x10000) {\r\n            xAux >>= 16;\r\n            result <<= 8;\r\n        }\r\n        if (xAux >= 0x100) {\r\n            xAux >>= 8;\r\n            result <<= 4;\r\n        }\r\n        if (xAux >= 0x10) {\r\n            xAux >>= 4;\r\n            result <<= 2;\r\n        }\r\n        if (xAux >= 0x8) {\r\n            result <<= 1;\r\n        }\r\n\r\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\r\n        result = (result + x / result) >> 1;\r\n        result = (result + x / result) >> 1;\r\n        result = (result + x / result) >> 1;\r\n        result = (result + x / result) >> 1;\r\n        result = (result + x / result) >> 1;\r\n        result = (result + x / result) >> 1;\r\n        result = (result + x / result) >> 1; // Seven iterations should be enough\r\n        uint256 roundedDownResult = x / result;\r\n        return result >= roundedDownResult ? roundedDownResult : result;\r\n    }\r\n\r\n    /**\r\n     * @dev computes e ^ (x / FIXED_1) * FIXED_1\r\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\r\n     * auto-generated via 'PrintFunctionOptimalExp.py'\r\n     * Detailed description:\r\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\r\n     * - The exponentiation of each binary exponent is given (pre-calculated)\r\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\r\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\r\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\r\n     */\r\n    function optimalExp(uint256 x) internal pure returns (uint256) {\r\n        uint256 res = 0;\r\n\r\n        uint256 y;\r\n        uint256 z;\r\n\r\n        z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\r\n        z = (z * y) / FIXED_1;\r\n        res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\r\n        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\r\n\r\n        if ((x & 0x010000000000000000000000000000000) != 0)\r\n            res =\r\n                (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) /\r\n                0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\r\n        if ((x & 0x020000000000000000000000000000000) != 0)\r\n            res =\r\n                (res * 0x18ebef9eac820ae8682b9793ac6d1e778) /\r\n                0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\r\n        if ((x & 0x040000000000000000000000000000000) != 0)\r\n            res =\r\n                (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) /\r\n                0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\r\n        if ((x & 0x080000000000000000000000000000000) != 0)\r\n            res =\r\n                (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) /\r\n                0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\r\n        if ((x & 0x100000000000000000000000000000000) != 0)\r\n            res =\r\n                (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) /\r\n                0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\r\n        if ((x & 0x200000000000000000000000000000000) != 0)\r\n            res =\r\n                (res * 0x00960aadc109e7a3bf4578099615711d7) /\r\n                0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\r\n        if ((x & 0x400000000000000000000000000000000) != 0)\r\n            res =\r\n                (res * 0x0002bf84208204f5977f9a8cf01fdc307) /\r\n                0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\r\n\r\n        return res;\r\n    }\r\n\r\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\r\n        uint8 res = 0;\r\n\r\n        if (_n < 256) {\r\n            // At most 8 iterations\r\n            while (_n > 1) {\r\n                _n >>= 1;\r\n                res += 1;\r\n            }\r\n        } else {\r\n            // Exactly 8 iterations\r\n            for (uint8 s = 128; s > 0; s >>= 1) {\r\n                if (_n >= (uint256(1) << s)) {\r\n                    _n >>= s;\r\n                    res |= s;\r\n                }\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    function ln(uint256 x) internal pure returns (uint256) {\r\n        uint256 res = 0;\r\n\r\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\r\n        if (x >= FIXED_2) {\r\n            uint8 count = floorLog2(x / FIXED_1);\r\n            x >>= count; // now x < 2\r\n            res = count * FIXED_1;\r\n        }\r\n\r\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\r\n        if (x > FIXED_1) {\r\n            for (uint8 i = 127; i > 0; --i) {\r\n                x = (x * x) / FIXED_1; // now 1 < x < 4\r\n                if (x >= FIXED_2) {\r\n                    x >>= 1; // now 1 < x < 2\r\n                    res += uint256(1) << (i - 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        return (res * LOG_E_2) / BASE;\r\n    }\r\n\r\n    /**\r\n     * @notice Takes the absolute value of a given number\r\n     * @dev Helper function\r\n     * @param _number The specified number\r\n     * @return The absolute value of the number\r\n     */\r\n    function abs(int256 _number) public pure returns (uint256) {\r\n        return _number < 0 ? uint256(_number * (-1)) : uint256(_number);\r\n    }\r\n\r\n    function ncdf(uint256 x) internal pure returns (uint256) {\r\n        int256 t1 = int256(1e7 + ((2316419 * x) / FIXED_1));\r\n        uint256 exp = ((x / 2) * x) / FIXED_1;\r\n        int256 d = int256((3989423 * FIXED_1) / optimalExp(uint256(exp)));\r\n        uint256 prob =\r\n            uint256(\r\n                (d *\r\n                    (3193815 +\r\n                        ((-3565638 +\r\n                            ((17814780 +\r\n                                ((-18212560 + (13302740 * 1e7) / t1) * 1e7) /\r\n                                t1) * 1e7) /\r\n                            t1) * 1e7) /\r\n                        t1) *\r\n                    1e7) / t1\r\n            );\r\n        if (x > 0) prob = 1e14 - prob;\r\n        return prob;\r\n    }\r\n\r\n    function cdf(int256 x) internal pure returns (uint256) {\r\n        int256 t1 = int256(1e7 + int256((2316419 * abs(x)) / FIXED_1));\r\n        uint256 exp = uint256((x / 2) * x) / FIXED_1;\r\n        int256 d = int256((3989423 * FIXED_1) / optimalExp(uint256(exp)));\r\n        uint256 prob =\r\n            uint256(\r\n                (d *\r\n                    (3193815 +\r\n                        ((-3565638 +\r\n                            ((17814780 +\r\n                                ((-18212560 + (13302740 * 1e7) / t1) * 1e7) /\r\n                                t1) * 1e7) /\r\n                            t1) * 1e7) /\r\n                        t1) *\r\n                    1e7) / t1\r\n            );\r\n        if (x > 0) prob = 1e14 - prob;\r\n        return prob;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract OptionsPremiumPricer is DSMath {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Immutables\r\n     */\r\n    address public immutable pool;\r\n    IVolatilityOracle public immutable volatilityOracle;\r\n    IPriceOracle public immutable priceOracle;\r\n    IPriceOracle public immutable stablesOracle;\r\n    uint256 private immutable priceOracleDecimals;\r\n    uint256 private immutable stablesOracleDecimals;\r\n\r\n    // For reference - IKEEP3rVolatility: 0xCCdfCB72753CfD55C5afF5d98eA5f9C43be9659d\r\n\r\n    /**\r\n     * @notice Constructor for pricer, deploy one for every pool\r\n     * @param _pool is the Uniswap v3 pool\r\n     * @param _volatilityOracle is the oracle for historical volatility\r\n     * @param _priceOracle is the Chainlink price oracle for the underlying asset\r\n     * @param _stablesOracle is the Chainlink price oracle for the strike asset (e.g. USDC)\r\n     */\r\n    constructor(\r\n        address _pool,\r\n        address _volatilityOracle,\r\n        address _priceOracle,\r\n        address _stablesOracle\r\n    ) {\r\n        require(_pool != address(0), \"!_pool\");\r\n        require(_volatilityOracle != address(0), \"!_volatilityOracle\");\r\n        require(_priceOracle != address(0), \"!_priceOracle\");\r\n        require(_stablesOracle != address(0), \"!_stablesOracle\");\r\n\r\n        pool = _pool;\r\n        volatilityOracle = IVolatilityOracle(_volatilityOracle);\r\n        priceOracle = IPriceOracle(_priceOracle);\r\n        stablesOracle = IPriceOracle(_stablesOracle);\r\n        priceOracleDecimals = IPriceOracle(_priceOracle).decimals();\r\n        stablesOracleDecimals = IPriceOracle(_stablesOracle).decimals();\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the premium of the provided option using Black-Scholes\r\n     * References for Black-Scholes:\r\n       https://www.macroption.com/black-scholes-formula/\r\n       https://www.investopedia.com/terms/b/blackscholes.asp\r\n       https://www.erieri.com/blackscholes\r\n       https://goodcalculators.com/black-scholes-calculator/\r\n       https://www.calkoo.com/en/black-scholes-option-pricing-model\r\n     * @param st is the strike price of the option\r\n     * @param expiryTimestamp is the unix timestamp of expiry\r\n     * @param isPut is whether the option is a put option\r\n     * @return premium for 100 contracts with 18 decimals i.e.\r\n     * 500*10**18 = 500 USDC for 100 contracts for puts,\r\n     * 5*10**18 = 5 of underlying asset (ETH, WBTC, etc.) for 100 contracts for calls,\r\n     */\r\n    function getPremium(\r\n        uint256 st,\r\n        uint256 expiryTimestamp,\r\n        bool isPut\r\n    ) external view returns (uint256 premium) {\r\n        require(\r\n            expiryTimestamp > block.timestamp,\r\n            \"Expiry must be in the future!\"\r\n        );\r\n\r\n        uint256 spotPrice = priceOracle.latestAnswer();\r\n\r\n        (uint256 sp, uint256 v, uint256 t) =\r\n            blackScholesParams(spotPrice, expiryTimestamp);\r\n\r\n        (uint256 call, uint256 put) = quoteAll(t, v, sp, st);\r\n\r\n        // Multiplier to convert oracle latestAnswer to 18 decimals\r\n        uint256 assetOracleMultiplier =\r\n            10 **\r\n                (\r\n                    uint256(18).sub(\r\n                        isPut ? stablesOracleDecimals : priceOracleDecimals\r\n                    )\r\n                );\r\n        // Make option premium denominated in the underlying\r\n        // asset for call vaults and USDC for put vaults\r\n        premium = isPut\r\n            ? wdiv(put, stablesOracle.latestAnswer().mul(assetOracleMultiplier))\r\n            : wdiv(call, spotPrice.mul(assetOracleMultiplier));\r\n\r\n        // Convert to 18 decimals\r\n        premium = premium.mul(assetOracleMultiplier);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the option's delta\r\n     * Formula reference: `d_1` in https://www.investopedia.com/terms/b/blackscholes.asp\r\n     * http://www.optiontradingpedia.com/options_delta.htm\r\n     * https://www.macroption.com/black-scholes-formula/\r\n     * @param st is the strike price of the option\r\n     * @param expiryTimestamp is the unix timestamp of expiry\r\n     * @return delta for given option. 4 decimals (ex: 8100 = 0.81 delta) as this is what strike selection\r\n     * module recognizes\r\n     */\r\n    function getOptionDelta(uint256 st, uint256 expiryTimestamp)\r\n        external\r\n        view\r\n        returns (uint256 delta)\r\n    {\r\n        require(\r\n            expiryTimestamp > block.timestamp,\r\n            \"Expiry must be in the future!\"\r\n        );\r\n\r\n        uint256 spotPrice = priceOracle.latestAnswer();\r\n        (uint256 sp, uint256 v, uint256 t) =\r\n            blackScholesParams(spotPrice, expiryTimestamp);\r\n\r\n        uint256 d1;\r\n        uint256 d2;\r\n\r\n        // Divide delta by 10 ** 10 to bring it to 4 decimals for strike selection\r\n        if (sp >= st) {\r\n            (d1, d2) = derivatives(t, v, sp, st);\r\n            delta = Math.ncdf((Math.FIXED_1 * d1) / 1e18).div(10**10);\r\n        } else {\r\n            // If underlying < strike price notice we switch st <-> sp passed into d\r\n            (d1, d2) = derivatives(t, v, st, sp);\r\n            delta = uint256(10)\r\n                .mul(10**13)\r\n                .sub(Math.ncdf((Math.FIXED_1 * d2) / 1e18))\r\n                .div(10**10);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the option's delta\r\n     * Formula reference: `d_1` in https://www.investopedia.com/terms/b/blackscholes.asp\r\n     * http://www.optiontradingpedia.com/options_delta.htm\r\n     * https://www.macroption.com/black-scholes-formula/\r\n     * @param sp is the spot price of the option\r\n     * @param st is the strike price of the option\r\n     * @param v is the annualized volatility of the underlying asset\r\n     * @param expiryTimestamp is the unix timestamp of expiry\r\n     * @return delta for given option. 4 decimals (ex: 8100 = 0.81 delta) as this is what strike selection\r\n     * module recognizes\r\n     */\r\n    function getOptionDelta(\r\n        uint256 sp,\r\n        uint256 st,\r\n        uint256 v,\r\n        uint256 expiryTimestamp\r\n    ) external view returns (uint256 delta) {\r\n        require(\r\n            expiryTimestamp > block.timestamp,\r\n            \"Expiry must be in the future!\"\r\n        );\r\n\r\n        // days until expiry\r\n        uint256 t = expiryTimestamp.sub(block.timestamp).div(1 days);\r\n\r\n        uint256 d1;\r\n        uint256 d2;\r\n\r\n        // Divide delta by 10 ** 10 to bring it to 4 decimals for strike selection\r\n        if (sp >= st) {\r\n            (d1, d2) = derivatives(t, v, sp, st);\r\n            delta = Math.ncdf((Math.FIXED_1 * d1) / 1e18).div(10**10);\r\n        } else {\r\n            // If underlying < strike price notice we switch st <-> sp passed into d\r\n            (d1, d2) = derivatives(t, v, st, sp);\r\n            delta = uint256(10)\r\n                .mul(10**13)\r\n                .sub(Math.ncdf((Math.FIXED_1 * d2) / 1e18))\r\n                .div(10**10);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates black scholes for both put and call\r\n     * @param t is the days until expiry\r\n     * @param v is the annualized volatility\r\n     * @param sp is the underlying price\r\n     * @param st is the strike price\r\n     * @return call is the premium of the call option given parameters\r\n     * @return put is the premium of the put option given parameters\r\n     */\r\n    function quoteAll(\r\n        uint256 t,\r\n        uint256 v,\r\n        uint256 sp,\r\n        uint256 st\r\n    ) private pure returns (uint256 call, uint256 put) {\r\n        uint256 _c;\r\n        uint256 _p;\r\n\r\n        if (sp > st) {\r\n            _c = blackScholes(t, v, sp, st);\r\n            _p = max(_c.add(st), sp) == sp ? 0 : _c.add(st).sub(sp);\r\n        } else {\r\n            _p = blackScholes(t, v, st, sp);\r\n            _c = max(_p.add(sp), st) == st ? 0 : _p.add(sp).sub(st);\r\n        }\r\n\r\n        return (_c, _p);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates black scholes for the ITM option at mint given strike\r\n     * price and underlying given the parameters (if underling >= strike price this is\r\n     * premium of call, and put otherwise)\r\n     * @param t is the days until expiry\r\n     * @param v is the annualized volatility\r\n     * @param sp is the underlying price\r\n     * @param st is the strike price\r\n     * @return premium is the premium of option\r\n     */\r\n    function blackScholes(\r\n        uint256 t,\r\n        uint256 v,\r\n        uint256 sp,\r\n        uint256 st\r\n    ) private pure returns (uint256 premium) {\r\n        (uint256 d1, uint256 d2) = derivatives(t, v, sp, st);\r\n\r\n        uint256 cdfD1 = Math.ncdf((Math.FIXED_1 * d1) / 1e18);\r\n        uint256 cdfD2 = Math.cdf((int256(Math.FIXED_1) * int256(d2)) / 1e18);\r\n\r\n        premium = (sp * cdfD1) / 1e14 - (st * cdfD2) / 1e14;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates d1 and d2 used in black scholes calculation\r\n     * as parameters to black scholes calculations\r\n     * @param t is the days until expiry\r\n     * @param v is the annualized volatility\r\n     * @param sp is the underlying price\r\n     * @param st is the strike price\r\n     * @return d1 and d2\r\n     */\r\n    function derivatives(\r\n        uint256 t,\r\n        uint256 v,\r\n        uint256 sp,\r\n        uint256 st\r\n    ) internal pure returns (uint256 d1, uint256 d2) {\r\n        require(sp > 0, \"!sp\");\r\n        require(st > 0, \"!st\");\r\n\r\n        uint256 sigma = ((v**2) / 2);\r\n        uint256 sigmaB = 1e36;\r\n\r\n        uint256 sig = (((1e18 * sigma) / sigmaB) * t) / 365;\r\n\r\n        uint256 sSQRT = (v * Math.sqrt2((1e18 * t) / 365)) / 1e9;\r\n        require(sSQRT > 0, \"!sSQRT\");\r\n\r\n        d1 = (1e18 * Math.ln((Math.FIXED_1 * sp) / st)) / Math.FIXED_1;\r\n        d1 = ((d1 + sig) * 1e18) / sSQRT;\r\n        d2 = d1 - sSQRT;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the current underlying price, annualized volatility, and days until expiry\r\n     * as parameters to black scholes calculations\r\n     * @param expiryTimestamp is the unix timestamp of expiry\r\n     * @return sp is the underlying\r\n     * @return v is the volatility\r\n     * @return t is the days until expiry\r\n     */\r\n    function blackScholesParams(uint256 spotPrice, uint256 expiryTimestamp)\r\n        private\r\n        view\r\n        returns (\r\n            uint256 sp,\r\n            uint256 v,\r\n            uint256 t\r\n        )\r\n    {\r\n        // chainlink oracle returns crypto / usd pairs with 8 decimals, like otoken strike price\r\n        sp = spotPrice.mul(10**8).div(10**priceOracleDecimals);\r\n        // annualized vol * 10 ** 8 because delta expects 18 decimals\r\n        // and annualizedVol is 8 decimals\r\n        v = volatilityOracle.annualizedVol(pool).mul(10**10);\r\n        t = expiryTimestamp.sub(block.timestamp).div(1 days);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the underlying assets price\r\n     */\r\n    function getUnderlyingPrice() external view returns (uint256 price) {\r\n        price = priceOracle.latestAnswer();\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_volatilityOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stablesOracle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"st\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTimestamp\",\"type\":\"uint256\"}],\"name\":\"getOptionDelta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"delta\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"st\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTimestamp\",\"type\":\"uint256\"}],\"name\":\"getOptionDelta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"delta\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"st\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPut\",\"type\":\"bool\"}],\"name\":\"getPremium\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"contract IPriceOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stablesOracle\",\"outputs\":[{\"internalType\":\"contract IPriceOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"volatilityOracle\",\"outputs\":[{\"internalType\":\"contract IVolatilityOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OptionsPremiumPricer", "CompilerVersion": "v0.7.3+commit.9bfce1f6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008ad599c3a0ff1de082011efddc58f1908eb6e6d80000000000000000000000007c0bfab993fbd54deadf43adff960e9c9e1163990000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b84190000000000000000000000008fffffd4afb6115b954bd326cbe7b4ba576818f6", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bd77b7ad5abb21d77a0f2d66fbb809167e8d8a2aa3a5f2b2e9f9370e28fce3ed"}]}