{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8;\r\n\r\ncontract ERC20PermitEverywhere {\r\n    struct PermitTransferFrom {\r\n        IERC20 token;\r\n        address spender;\r\n        uint256 maxAmount;\r\n        uint256 deadline;\r\n    }\r\n\r\n    struct Signature {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n    }\r\n\r\n    bytes32 public immutable DOMAIN_SEPARATOR;\r\n    bytes32 public immutable TRANSFER_PERMIT_TYPEHASH;\r\n\r\n    // Owner -> current nonce.\r\n    mapping (address => uint256) public currentNonce;\r\n\r\n    constructor() {\r\n        uint256 chainId;\r\n        assembly { chainId := chainid() }\r\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n            keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n            keccak256(bytes('ERC20PermitEverywhere')),\r\n            keccak256(bytes('1.0.0')),\r\n            chainId,\r\n            address(this)\r\n        ));\r\n        TRANSFER_PERMIT_TYPEHASH =\r\n            keccak256('PermitTransferFrom(address token,address spender,uint256 maxAmount,uint256 deadline,uint256 nonce)');\r\n    }\r\n\r\n    function executePermitTransferFrom(\r\n        address owner,\r\n        address to,\r\n        uint256 amount,\r\n        PermitTransferFrom memory permit,\r\n        Signature memory sig\r\n    )\r\n        external\r\n    {\r\n        require(msg.sender == permit.spender, 'SPENDER_NOT_PERMITTED');\r\n        require(permit.deadline >= block.timestamp, 'PERMIT_EXPIRED');\r\n        require(permit.maxAmount >= amount, 'EXCEEDS_PERMIT_AMOUNT');\r\n        uint256 nonce = currentNonce[owner]++;\r\n        require(owner == getSigner(hashPermit(permit, nonce), sig), 'INVALID_SIGNER');\r\n        _transferFrom(permit.token, owner, to, amount);\r\n    }\r\n\r\n    function hashPermit(PermitTransferFrom memory permit, uint256 nonce)\r\n        public\r\n        view\r\n        returns (bytes32 h)\r\n    {\r\n        bytes32 dh = DOMAIN_SEPARATOR;\r\n        bytes32 th = TRANSFER_PERMIT_TYPEHASH;\r\n        assembly {\r\n            if lt(permit, 0x20)  {\r\n                invalid()\r\n            }\r\n            let c1 := mload(sub(permit, 0x20))\r\n            let c2 := mload(add(permit, 0x80))\r\n            mstore(sub(permit, 0x20), th)\r\n            mstore(add(permit, 0x80), nonce)\r\n            let ph := keccak256(sub(permit, 0x20), 0xC0)\r\n            mstore(sub(permit, 0x20), c1)\r\n            mstore(add(permit, 0x80), c2)\r\n            let p:= mload(0x40)\r\n            mstore(p, 0x1901000000000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(p, 0x02), dh)\r\n            mstore(add(p, 0x22), ph)\r\n            h := keccak256(p, 0x42)\r\n        }\r\n    }\r\n\r\n    function getSigner(bytes32 hash, Signature memory sig) private pure returns (address signer) {\r\n        signer = ecrecover(hash, sig.v, sig.r, sig.s);\r\n        require(signer != address(0), 'INVALID_SIGNATURE');\r\n    }\r\n\r\n    function _transferFrom(IERC20 token, address owner, address to, uint256 amount) private {\r\n        bytes4 transferFromSelector = IERC20.transferFrom.selector;\r\n        bool s;\r\n        assembly {\r\n            let p:= mload(0x40)\r\n            mstore(p, transferFromSelector)\r\n            mstore(add(p, 0x04), owner)\r\n            mstore(add(p, 0x24), to)\r\n            mstore(add(p, 0x44), amount)\r\n            s:= call(gas(), token, 0, p, 0x64, 0, 0)\r\n            if iszero(s) {\r\n                returndatacopy(0, 0, returndatasize())\r\n                revert(0, returndatasize())\r\n            }\r\n            if gt(returndatasize(), 0x19) {\r\n                returndatacopy(p, 0, 0x20)\r\n                s := and(not(iszero(mload(p))), 1)\r\n            }\r\n        }\r\n        require(s, 'TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address owner, address to, uint256 amount) external returns (bool);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"currentNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC20PermitEverywhere.PermitTransferFrom\",\"name\":\"permit\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct ERC20PermitEverywhere.Signature\",\"name\":\"sig\",\"type\":\"tuple\"}],\"name\":\"executePermitTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC20PermitEverywhere.PermitTransferFrom\",\"name\":\"permit\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"hashPermit\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"h\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ERC20PermitEverywhere", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6126b7a810d9675bbc296c3bb71e4eaf617574faa16379d42ff626cf0791bf2e"}]}