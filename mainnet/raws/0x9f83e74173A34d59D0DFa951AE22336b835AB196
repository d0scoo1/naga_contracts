{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"src/Multi165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IERC165 {function supportsInterface(bytes4 interfaceId) external view returns (bool);}\\n\\ncontract Multi165 {\\n\\n    function supportsInterface(IERC165[] calldata contracts, bytes4 interfaceId) public view returns (bool[] memory result) {\\n        result = new bool[](contracts.length);\\n        bytes memory callData = new bytes(36);\\n        assembly {            \\n            mstore(add(callData, 32), 0x01ffc9a700000000000000000000000000000000000000000000000000000000)\\n            mstore(add(callData, 36), interfaceId)\\n        }\\n        for(uint256 i = 0; i < contracts.length; i++) {\\n            (bool success, bytes memory returndata) = address(contracts[i]).staticcall{gas: 30000}(callData);\\n            // ensure there was enough gas ( >= 30,000) given to the `supportsInterface` call\\n            // Note that `{gas: 30000}` do not ensure that, it only protect the caller to not spend more than 30,000.\\n            assert(gasleft() > 476); // 30,000 / 63\\n            if (success && returndata.length > 0 && returndata.length < 33) {\\n                bytes32 data;\\n                assembly {\\n                        data := mload(add(returndata, 32))\\n                }\\n                result[i] = uint256(data) != 0;\\n            }\\n        }\\n    }\\n\\n    function supportsMultipleInterfaces(IERC165[] calldata contracts, bytes4[] calldata interfaceIds) public view returns (bool[] memory result) {\\n        result = new bool[](contracts.length);\\n        uint256 numI = contracts.length;\\n        for(uint256 i = 0; i < numI; i++) {\\n            // asume true and set to false once one interfaceId is found to be not supported.\\n            result[i] = true;\\n            uint256 numJ = interfaceIds.length;\\n            for (uint256 j = 0; j < numJ; j ++) {\\n                bytes4 interfaceId = interfaceIds[j];\\n                bytes memory callData = new bytes(36);\\n                assembly {            \\n                    mstore(add(callData, 32), 0x01ffc9a700000000000000000000000000000000000000000000000000000000)\\n                    mstore(add(callData, 36), interfaceId)\\n                }\\n                (bool success, bytes memory returndata) = address(contracts[i]).staticcall{gas: 30000}(callData);\\n                // ensure there was enough gas ( >= 30,000) given to the `supportsInterface` call\\n                // Note that `{gas: 30000}` do not ensure that, it only protect the caller to not spend more than 30,000.\\n                assert(gasleft() > 476); // 30,000 / 63\\n                \\n                if (!success || returndata.length == 0 || returndata.length > 32) {\\n                    result[i] = false;\\n                    break;\\n                }\\n                bytes32 data;\\n                assembly {\\n                        data := mload(add(returndata, 32))\\n                }\\n                if(uint256(data) == 0) {\\n                    result[i] = false;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n}\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC165[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"result\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC165[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"bytes4[]\",\"name\":\"interfaceIds\",\"type\":\"bytes4[]\"}],\"name\":\"supportsMultipleInterfaces\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"result\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Multi165", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}