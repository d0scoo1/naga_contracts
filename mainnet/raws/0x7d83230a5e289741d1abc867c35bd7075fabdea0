{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\ninterface Ierc721Receiver {\r\n\r\n\r\nfunction onerc721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nlibrary Address {\r\n\r\n\r\nfunction isContract(address account) internal view returns (bool) {\r\n\r\n\r\n// This method relies on extcodesize, which returns 0 for contracts in\r\n\r\n\r\n// construction, since the code is only stored at the end of the\r\n\r\n\r\n// constructor execution.\r\n\r\n\r\n\r\nuint256 size;\r\n\r\n\r\n// solhint-disable-next-line no-inline-assembly\r\n\r\n\r\nassembly { size := extcodesize(account) }\r\n\r\n\r\nreturn size > 0;\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction sendValue(address payable recipient, uint256 amount) internal {\r\n\r\n\r\nrequire(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n\r\n\r\n// solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n\r\n\r\n(bool success, ) = recipient.call{ value: amount }(\"\");\r\n\r\n\r\nrequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\r\n\r\nreturn functionCall(target, data, \"Address: low-level call failed\");\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n\r\n\r\nreturn functionCallWithValue(target, data, 0, errorMessage);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n\r\n\r\nreturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n\r\n\r\nrequire(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n\r\n\r\nrequire(isContract(target), \"Address: call to non-contract\");\r\n\r\n\r\n\r\n// solhint-disable-next-line avoid-low-level-calls\r\n\r\n\r\n(bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n\r\n\r\nreturn _verifyCallResult(success, returndata, errorMessage);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n\r\n\r\nreturn functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n\r\n\r\nrequire(isContract(target), \"Address: static call to non-contract\");\r\n\r\n\r\n\r\n// solhint-disable-next-line avoid-low-level-calls\r\n\r\n\r\n(bool success, bytes memory returndata) = target.staticcall(data);\r\n\r\n\r\nreturn _verifyCallResult(success, returndata, errorMessage);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\r\n\r\nreturn functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n\r\n\r\n}\r\n\r\n\r\nfunction functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n\r\n\r\nrequire(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n\r\n\r\n// solhint-disable-next-line avoid-low-level-calls\r\n\r\n\r\n(bool success, bytes memory returndata) = target.delegatecall(data);\r\n\r\n\r\nreturn _verifyCallResult(success, returndata, errorMessage);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n\r\n\r\nif (success) {\r\n\r\n\r\nreturn returndata;\r\n\r\n\r\n} else {\r\n\r\n\r\n// Look for revert reason and bubble it up if present\r\n\r\n\r\nif (returndata.length > 0) {\r\n\r\n\r\n// The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n\r\n\r\n// solhint-disable-next-line no-inline-assembly\r\n\r\n\r\nassembly {\r\n\r\n\r\nlet returndata_size := mload(returndata)\r\n\r\n\r\nrevert(add(32, returndata), returndata_size)\r\n\r\n\r\n}\r\n\r\n\r\n} else {\r\n\r\n\r\nrevert(errorMessage);\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n\r\nabstract contract Context {\r\n\r\n\r\nfunction _msgSender() internal view virtual returns (address) {\r\n\r\n\r\nreturn msg.sender;\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _msgData() internal view virtual returns (bytes calldata) {\r\n\r\n\r\nthis; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n\r\n\r\nreturn msg.data;\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n\r\nlibrary Counters {\r\n\r\n\r\nstruct Counter {\r\n\r\n\r\nuint256 _value; // default: 0\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction current(Counter storage counter) internal view returns (uint256) {\r\n\r\n\r\nreturn counter._value;\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction increment(Counter storage counter) internal {\r\n\r\n\r\nunchecked {\r\n\r\n\r\ncounter._value += 1;\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction decrement(Counter storage counter) internal {\r\n\r\n\r\nuint256 value = counter._value;\r\n\r\n\r\nrequire(value > 0, \"Counter: decrement overflow\");\r\n\r\n\r\nunchecked {\r\n\r\n\r\ncounter._value = value - 1;\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n\r\ninterface Ierc165 {\r\n\r\n\r\nfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\nabstract contract erc165 is Ierc165 {\r\n\r\n\r\n\r\nfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n\r\n\r\nreturn interfaceId == type(Ierc165).interfaceId;\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\ninterface Ierc721 {\r\n\r\n\r\nevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n\r\nevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n\r\nevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n\r\n\r\nfunction balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n\r\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n\r\nfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n\r\nfunction transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n\r\nfunction approve(address to, uint256 tokenId) external;\r\n\r\n\r\nfunction getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n\r\nfunction setApprovalForAll(address operator, bool _approved) external;\r\n\r\n\r\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n\r\nfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\r\n\r\n}\r\n\r\n\r\n\r\ninterface Ierc721Enumerable is Ierc721 {\r\n\r\n\r\n\r\nfunction totalSupply() external view returns (uint256);\r\n\r\n\r\n\r\n\r\nfunction tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n\r\n\r\n\r\nfunction tokenByIndex(uint256 index) external view returns (uint256);\r\n\r\n\r\n}\r\n\r\n\r\n\r\ninterface Ierc721Metadata is Ierc721 {\r\n\r\n\r\nfunction name() external view returns (string memory);\r\n\r\n\r\nfunction symbol() external view returns (string memory);\r\n\r\n\r\nfunction tokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nlibrary Strings {\r\n\r\n\r\nbytes16 private constant alphabet = \"0123456789abcdef\";\r\n\r\n\r\n\r\nfunction toString(uint256 value) internal pure returns (string memory) {\r\n\r\n\r\n\r\nif (value == 0) {\r\n\r\n\r\nreturn \"0\";\r\n\r\n\r\n}\r\n\r\n\r\nuint256 temp = value;\r\n\r\n\r\nuint256 digits;\r\n\r\n\r\nwhile (temp != 0) {\r\n\r\n\r\ndigits++;\r\n\r\n\r\ntemp /= 10;\r\n\r\n\r\n}\r\n\r\n\r\nbytes memory buffer = new bytes(digits);\r\n\r\n\r\nwhile (value != 0) {\r\n\r\n\r\ndigits -= 1;\r\n\r\n\r\nbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n\r\n\r\nvalue /= 10;\r\n\r\n\r\n}\r\n\r\n\r\nreturn string(buffer);\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\nfunction toHexString(uint256 value) internal pure returns (string memory) {\r\n\r\n\r\nif (value == 0) {\r\n\r\n\r\nreturn \"0x00\";\r\n\r\n\r\n}\r\n\r\n\r\nuint256 temp = value;\r\n\r\n\r\nuint256 length = 0;\r\n\r\n\r\nwhile (temp != 0) {\r\n\r\n\r\nlength++;\r\n\r\n\r\ntemp >>= 8;\r\n\r\n\r\n}\r\n\r\n\r\nreturn toHexString(value, length);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n\r\n\r\nbytes memory buffer = new bytes(2 * length + 2);\r\n\r\n\r\nbuffer[0] = \"0\";\r\n\r\n\r\nbuffer[1] = \"x\";\r\n\r\n\r\nfor (uint256 i = 2 * length + 1; i > 1; --i) {\r\n\r\n\r\nbuffer[i] = alphabet[value & 0xf];\r\n\r\n\r\nvalue >>= 4;\r\n\r\n\r\n}\r\n\r\n\r\nrequire(value == 0, \"Strings: hex length insufficient\");\r\n\r\n\r\nreturn string(buffer);\r\n\r\n\r\n}\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\nabstract contract Pausable is Context {\r\n\r\n\r\n\r\nevent Paused(address account);\r\n\r\n\r\n\r\n\r\nevent Unpaused(address account);\r\n\r\n\r\n\r\nbool private _paused;\r\n\r\n\r\n\r\nconstructor () {\r\n\r\n\r\n_paused = false;\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction paused() public view virtual returns (bool) {\r\n\r\n\r\nreturn _paused;\r\n\r\n\r\n}\r\n\r\n\r\n\r\nmodifier whenNotPaused() {\r\n\r\n\r\nrequire(!paused(), \"Pausable: paused\");\r\n\r\n\r\n_;\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\nmodifier whenPaused() {\r\n\r\n\r\nrequire(paused(), \"Pausable: not paused\");\r\n\r\n\r\n_;\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _pause() internal virtual whenNotPaused {\r\n\r\n\r\n_paused = true;\r\n\r\n\r\nemit Paused(_msgSender());\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _unpause() internal virtual whenPaused {\r\n\r\n\r\n_paused = false;\r\n\r\n\r\nemit Unpaused(_msgSender());\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract erc721 is Context,erc165, Ierc721, Ierc721Metadata,Pausable {\r\n\r\n\r\n/*\r\n\r\n\r\nsupportsInterface\r\n\r\n\r\nerc721 0x80ac58cd\r\n\r\n\r\nerc165 0x01ffc9a7\r\n\r\n\r\nEnum 0x01ffc9a7\r\n\r\n\r\n*/\r\n\r\n\r\nusing Address for address;\r\n\r\n\r\nusing Strings for uint256;\r\n\r\n\r\n\r\nstring private _name;\r\n\r\n\r\nstring private _symbol;\r\n\r\n\r\n\r\nmapping (uint256 => address) private _owners;\r\n\r\n\r\nmapping (address => uint256) private _balances;\r\n\r\n\r\nmapping (uint256 => address) private _tokenApprovals;\r\n\r\n\r\nmapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n\r\nmapping (uint256 => NFT_INFO) public NFT_Infomation;\r\n\r\n\r\nstruct NFT_INFO {\r\n\r\nstring Text;\r\n\r\nstring URI;\r\n\r\n}\r\n\r\n\r\nconstructor (string memory name_, string memory symbol_) {\r\n\r\n\r\n_name = name_;\r\n\r\n\r\n_symbol = symbol_;\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n\r\n\r\nreturn interfaceId == type(Ierc721).interfaceId\r\n\r\n\r\n|| interfaceId == type(Ierc721Metadata).interfaceId\r\n\r\n\r\n|| super.supportsInterface(interfaceId);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction balanceOf(address owner) public view virtual override returns (uint256) {\r\n\r\n\r\nrequire(owner != address(0), \"erc721: balance query for the zero address\");\r\n\r\n\r\nreturn _balances[owner];\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n\r\n\r\naddress owner = _owners[tokenId];\r\n\r\n\r\nrequire(owner != address(0), \"erc721: owner query for nonexistent token\");\r\n\r\n\r\nreturn owner;\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction name() public view virtual override returns (string memory) {\r\n\r\n\r\nreturn _name;\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction symbol() public view virtual override returns (string memory) {\r\n\r\n\r\nreturn _symbol;\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n\r\n\r\nrequire(_exists(tokenId), \"erc721Metadata: URI query for nonexistent token\");\r\n\r\n\r\n\r\nstring memory baseURI = _baseURI();\r\n\r\n\r\nreturn bytes(baseURI).length > 0\r\n\r\n\r\n? string(abi.encodePacked(baseURI, tokenId.toString()))\r\n\r\n\r\n: '';\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _baseURI() internal view virtual returns (string memory) {\r\n\r\n\r\nreturn \"\";\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction burn(uint256 tokenId) public virtual whenNotPaused() {\r\n\r\n\r\nrequire(_isApprovedOrOwner(_msgSender(), tokenId), \"erc721Burnable: caller is not owner nor approved\");\r\n\r\n\r\n_burn(tokenId);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction approve(address to, uint256 tokenId) public virtual whenNotPaused() override {\r\n\r\n\r\naddress owner = erc721.ownerOf(tokenId);\r\n\r\n\r\nrequire(to != owner, \"erc721: approval to current owner\");\r\n\r\n\r\n\r\nrequire(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n\r\n\r\n\"erc721: approve caller is not owner nor approved for all\"\r\n\r\n\r\n);\r\n\r\n\r\n\r\n_approve(to, tokenId);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n\r\n\r\nrequire(_exists(tokenId), \"erc721: approved query for nonexistent token\");\r\n\r\n\r\n\r\nreturn _tokenApprovals[tokenId];\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction setApprovalForAll(address operator, bool approved) public virtual whenNotPaused() override {\r\n\r\n\r\nrequire(operator != _msgSender(), \"erc721: approve to caller\");\r\n\r\n\r\n\r\n_operatorApprovals[_msgSender()][operator] = approved;\r\n\r\n\r\nemit ApprovalForAll(_msgSender(), operator, approved);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n\r\n\r\nreturn _operatorApprovals[owner][operator];\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction transferFrom(address from, address to, uint256 tokenId) public virtual whenNotPaused() override {\r\n\r\n\r\n//solhint-disable-next-line max-line-length\r\n\r\n\r\nrequire(_isApprovedOrOwner(_msgSender(), tokenId), \"erc721: transfer caller is not owner nor approved\");\r\n\r\n\r\n\r\n_transfer(from, to, tokenId);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction safeTransferFrom(address from, address to, uint256 tokenId) public virtual whenNotPaused() override {\r\n\r\n\r\nsafeTransferFrom(from, to, tokenId, \"\");\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual whenNotPaused() override {\r\n\r\n\r\nrequire(_isApprovedOrOwner(_msgSender(), tokenId), \"erc721: transfer caller is not owner nor approved\");\r\n\r\n\r\n_safeTransfer(from, to, tokenId, _data);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\r\n\r\n\r\n_transfer(from, to, tokenId);\r\n\r\n\r\nrequire(_checkOnerc721Received(from, to, tokenId, _data), \"erc721: transfer to non erc721Receiver implementer\");\r\n\r\n\r\n}\r\n\r\n\r\nfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n\r\n\r\nreturn _owners[tokenId] != address(0);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n\r\n\r\nrequire(_exists(tokenId), \"erc721: operator query for nonexistent token\");\r\n\r\n\r\naddress owner = erc721.ownerOf(tokenId);\r\n\r\n\r\nreturn (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n\r\n\r\n_safeMint(to, tokenId, \"\");\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\r\n\r\n\r\n_mint(to, tokenId);\r\n\r\n\r\nrequire(_checkOnerc721Received(address(0), to, tokenId, _data), \"erc721: transfer to non erc721Receiver implementer\");\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _mint(address to, uint256 tokenId) internal virtual {\r\n\r\n\r\nrequire(to != address(0), \"erc721: mint to the zero address\");\r\n\r\n\r\nrequire(!_exists(tokenId), \"erc721: token already minted\");\r\n\r\n\r\n\r\n_beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n\r\n\r\n_balances[to] += 1;\r\n\r\n\r\n_owners[tokenId] = to;\r\n\r\n\r\n\r\nemit Transfer(address(0), to, tokenId);\r\n\r\n\r\n}\r\n\r\n\r\nfunction _burn(uint256 tokenId) internal virtual {\r\n\r\n\r\naddress owner = erc721.ownerOf(tokenId);\r\n\r\n\r\n\r\n_beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n\r\n\r\n// Clear approvals\r\n\r\n\r\n_approve(address(0), tokenId);\r\n\r\n\r\n\r\n_balances[owner] -= 1;\r\n\r\n\r\ndelete _owners[tokenId];\r\n\r\ndelete NFT_Infomation[tokenId];\r\n\r\n\r\nemit Transfer(owner, address(0), tokenId);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _transfer(address from, address to, uint256 tokenId) internal virtual {\r\n\r\n\r\nrequire(erc721.ownerOf(tokenId) == from, \"erc721: transfer of token that is not own\");\r\n\r\n\r\nrequire(to != address(0), \"erc721: transfer to the zero address\");\r\n\r\n\r\n\r\n_beforeTokenTransfer(from, to, tokenId);\r\n\r\n\r\n\r\n// Clear approvals from the previous owner\r\n\r\n\r\n_approve(address(0), tokenId);\r\n\r\n\r\n\r\n_balances[from] -= 1;\r\n\r\n\r\n_balances[to] += 1;\r\n\r\n\r\n_owners[tokenId] = to;\r\n\r\n\r\n\r\nemit Transfer(from, to, tokenId);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _approve(address to, uint256 tokenId) internal virtual {\r\n\r\n\r\n_tokenApprovals[tokenId] = to;\r\n\r\n\r\nemit Approval(erc721.ownerOf(tokenId), to, tokenId);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _checkOnerc721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n\r\n\r\nprivate returns (bool)\r\n\r\n\r\n{\r\n\r\n\r\nif (to.isContract()) {\r\n\r\n\r\ntry Ierc721Receiver(to).onerc721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n\r\n\r\nreturn retval == Ierc721Receiver(to).onerc721Received.selector;\r\n\r\n\r\n} catch (bytes memory reason) {\r\n\r\n\r\nif (reason.length == 0) {\r\n\r\n\r\nrevert(\"erc721: transfer to non erc721Receiver implementer\");\r\n\r\n\r\n} else {\r\n\r\n\r\n// solhint-disable-next-line no-inline-assembly\r\n\r\n\r\nassembly {\r\n\r\n\r\nrevert(add(32, reason), mload(reason))\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n} else {\r\n\r\n\r\nreturn true;\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nabstract contract erc721URIStorage is erc721{\r\n\r\n\r\nusing Strings for uint256;\r\n\r\n\r\n\r\n\r\nmapping (uint256 => string) private _tokenURIs;\r\n\r\n\r\n\r\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n\r\n\r\nrequire(_exists(tokenId), \"erc721URIStorage: URI query for nonexistent token\");\r\n\r\n\r\n\r\nstring memory _tokenURI = _tokenURIs[tokenId];\r\n\r\n\r\nstring memory base = _baseURI();\r\n\r\n\r\n\r\n// If there is no base URI, return the token URI.\r\n\r\n\r\nif (bytes(base).length == 0) {\r\n\r\n\r\nreturn _tokenURI;\r\n\r\n\r\n}\r\n\r\n\r\n// If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\r\n\r\n\r\nif (bytes(_tokenURI).length > 0) {\r\n\r\n\r\nreturn string(abi.encodePacked(base, _tokenURI));\r\n\r\n\r\n}\r\n\r\n\r\n\r\nreturn super.tokenURI(tokenId);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\r\n\r\n\r\nrequire(_exists(tokenId), \"erc721URIStorage: URI set of nonexistent token\");\r\n\r\n\r\n_tokenURIs[tokenId] = _tokenURI;\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _burn(uint256 tokenId) internal virtual override {\r\n\r\n\r\nsuper._burn(tokenId);\r\n\r\n\r\n\r\nif (bytes(_tokenURIs[tokenId]).length != 0) {\r\n\r\n\r\ndelete _tokenURIs[tokenId];\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n\r\nabstract contract erc721Enumerable is erc721URIStorage, Ierc721Enumerable {\r\n\r\n\r\n// Mapping from owner to list of owned token IDs\r\n\r\n\r\nmapping(address => mapping(uint256 => uint256)) private _ownedTokens;\r\n\r\n\r\n\r\n// Mapping from token ID to index of the owner tokens list\r\n\r\n\r\nmapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n\r\n\r\n// Array with all token ids, used for enumeration\r\n\r\n\r\nuint256[] private _allTokens;\r\n\r\n\r\n\r\n// Mapping from token id to position in the allTokens array\r\n\r\n\r\nmapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n\r\n\r\nfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n\r\n\r\nreturn interfaceId == type(Ierc721Enumerable).interfaceId\r\n\r\n\r\n|| super.supportsInterface(interfaceId);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\r\n\r\n\r\nrequire(index < erc721.balanceOf(owner), \"erc721Enumerable: owner index out of bounds\");\r\n\r\n\r\nreturn _ownedTokens[owner][index];\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction totalSupply() public view virtual override returns (uint256) {\r\n\r\n\r\nreturn _allTokens.length;\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction tokenByIndex(uint256 index) public view virtual override returns (uint256) {\r\n\r\n\r\nrequire(index < erc721Enumerable.totalSupply(), \"erc721Enumerable: global index out of bounds\");\r\n\r\n\r\nreturn _allTokens[index];\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\nfunction _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\r\n\r\n\r\nsuper._beforeTokenTransfer(from, to, tokenId);\r\n\r\n\r\n\r\nif (from == address(0)) {\r\n\r\n\r\n_addTokenToAllTokensEnumeration(tokenId);\r\n\r\n\r\n} else if (from != to) {\r\n\r\n\r\n_removeTokenFromOwnerEnumeration(from, tokenId);\r\n\r\n\r\n}\r\n\r\n\r\nif (to == address(0)) {\r\n\r\n\r\n_removeTokenFromAllTokensEnumeration(tokenId);\r\n\r\n\r\n} else if (to != from) {\r\n\r\n\r\n_addTokenToOwnerEnumeration(to, tokenId);\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n\r\n\r\nuint256 length = erc721.balanceOf(to);\r\n\r\n\r\n_ownedTokens[to][length] = tokenId;\r\n\r\n\r\n_ownedTokensIndex[tokenId] = length;\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n\r\n\r\n_allTokensIndex[tokenId] = _allTokens.length;\r\n\r\n\r\n_allTokens.push(tokenId);\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n\r\n\r\n// To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n\r\n\r\n// then delete the last slot (swap and pop).\r\n\r\n\r\n\r\nuint256 lastTokenIndex = erc721.balanceOf(from) - 1;\r\n\r\n\r\nuint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n\r\n\r\n// When the token to delete is the last token, the swap operation is unnecessary\r\n\r\n\r\nif (tokenIndex != lastTokenIndex) {\r\n\r\n\r\nuint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n\r\n\r\n_ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n\r\n\r\n_ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n\r\n}\r\n\r\n\r\n\r\n// This also deletes the contents at the last position of the array\r\n\r\n\r\ndelete _ownedTokensIndex[tokenId];\r\n\r\n\r\ndelete _ownedTokens[from][lastTokenIndex];\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n\r\n\r\n// To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n\r\n\r\n// then delete the last slot (swap and pop).\r\n\r\n\r\n\r\nuint256 lastTokenIndex = _allTokens.length - 1;\r\n\r\n\r\nuint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n\r\n\r\n// When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n\r\n\r\n// rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n\r\n\r\n// an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n\r\n\r\nuint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n\r\n\r\n_allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n\r\n\r\n_allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n\r\n\r\n// This also deletes the contents at the last position of the array\r\n\r\n\r\ndelete _allTokensIndex[tokenId];\r\n\r\n\r\n_allTokens.pop();\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n\r\nabstract contract Ownable is Context {\r\n\r\n\r\naddress private _owner;\r\n\r\n\r\n\r\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n\r\n/**\r\n\r\n\r\n* @dev Initializes the contract setting the deployer as the initial owner.\r\n\r\n\r\n*/\r\n\r\n\r\nconstructor () {\r\n\r\n\r\naddress msgSender = _msgSender();\r\n\r\n\r\n_owner = msgSender;\r\n\r\n\r\nemit OwnershipTransferred(address(0), msgSender);\r\n\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n\r\n\r\n* @dev Returns the address of the current owner.\r\n\r\n\r\n*/\r\n\r\n\r\nfunction owner() public view virtual returns (address) {\r\n\r\n\r\nreturn _owner;\r\n\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n\r\n\r\n* @dev Throws if called by any account other than the owner.\r\n\r\n\r\n*/\r\n\r\n\r\nmodifier onlyOwner() {\r\n\r\n\r\nrequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n\r\n\r\n_;\r\n\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n\r\n\r\n* @dev Leaves the contract without owner. It will not be possible to call\r\n\r\n\r\n* `onlyOwner` functions anymore. Can only be called by the current owner.\r\n\r\n\r\n*\r\n\r\n\r\n* NOTE: Renouncing ownership will leave the contract without an owner,\r\n\r\n\r\n* thereby removing any functionality that is only available to the owner.\r\n\r\n\r\n*/\r\n\r\n\r\nfunction renounceOwnership() public virtual onlyOwner {\r\n\r\n\r\nemit OwnershipTransferred(_owner, address(0));\r\n\r\n\r\n_owner = address(0);\r\n\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n\r\n\r\n* @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\r\n\r\n* Can only be called by the current owner.\r\n\r\n\r\n*/\r\n\r\n\r\nfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n\r\n\r\nrequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\r\n\r\nemit OwnershipTransferred(_owner, newOwner);\r\n\r\n\r\n_owner = newOwner;\r\n\r\n\r\n}\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract MTOMSNFT is erc721Enumerable,Ownable {\r\nusing Counters for Counters.Counter;\r\nCounters.Counter private _tokenIds;\r\nconstructor() erc721(\"METATOMS\", \"MTOMS\") payable {payable(0x728ea56043eE11388e71db3d455235225dDD3354).transfer(msg.value);}\r\n\r\n\r\nfunction Mint_NFT(string memory tokenURI,string memory tokenText) public onlyOwner() whenNotPaused() returns (uint256) {\r\n_tokenIds.increment();\r\n\r\n\r\nuint256 NewNFT = _tokenIds.current();\r\n\r\n\r\n_safeMint(msg.sender, NewNFT);\r\n\r\n\r\n_setTokenURI(NewNFT, tokenURI);\r\n\r\nNFT_Infomation[NewNFT] = NFT_INFO(tokenText,tokenURI);\r\n\r\nreturn NewNFT;\r\n\r\n\r\n}\r\n\r\n\r\nfunction pause() onlyOwner() public {\r\n\r\n\r\n_pause();\r\n\r\n\r\n}\r\n\r\n\r\nfunction unpause() onlyOwner() public {\r\n\r\n\r\n_unpause();\r\n\r\n\r\n}\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenText\",\"type\":\"string\"}],\"name\":\"Mint_NFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"NFT_Infomation\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"Text\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"URI\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MTOMSNFT", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0f3cd7ce9446ff576e4e9101f56e57e4549467e7a9b92b6b237f3471738afbf0"}]}