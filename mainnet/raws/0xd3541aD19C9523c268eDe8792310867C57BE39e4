{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PrimitiveEngine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity 0.8.6;\\r\\n\\r\\nimport \\\"./libraries/Margin.sol\\\";\\r\\nimport \\\"./libraries/ReplicationMath.sol\\\";\\r\\nimport \\\"./libraries/Reserve.sol\\\";\\r\\nimport \\\"./libraries/SafeCast.sol\\\";\\r\\nimport \\\"./libraries/Transfers.sol\\\";\\r\\nimport \\\"./libraries/Units.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/callback/IPrimitiveCreateCallback.sol\\\";\\r\\nimport \\\"./interfaces/callback/IPrimitiveDepositCallback.sol\\\";\\r\\nimport \\\"./interfaces/callback/IPrimitiveLiquidityCallback.sol\\\";\\r\\nimport \\\"./interfaces/callback/IPrimitiveSwapCallback.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/IERC20.sol\\\";\\r\\nimport \\\"./interfaces/IPrimitiveEngine.sol\\\";\\r\\nimport \\\"./interfaces/IPrimitiveFactory.sol\\\";\\r\\n\\r\\n/// @title   Primitive Engine\\r\\n/// @author  Primitive\\r\\n/// @notice  Replicating Market Maker\\r\\n/// @dev     RMM-01\\r\\ncontract PrimitiveEngine is IPrimitiveEngine {\\r\\n    using ReplicationMath for int128;\\r\\n    using Units for uint256;\\r\\n    using SafeCast for uint256;\\r\\n    using Reserve for mapping(bytes32 => Reserve.Data);\\r\\n    using Reserve for Reserve.Data;\\r\\n    using Margin for mapping(address => Margin.Data);\\r\\n    using Margin for Margin.Data;\\r\\n    using Transfers for IERC20;\\r\\n\\r\\n    /// @dev            Parameters of each pool\\r\\n    /// @param strike   Strike price of pool with stable token decimals\\r\\n    /// @param sigma    Implied volatility, with 1e4 decimals such that 10000 = 100%\\r\\n    /// @param maturity Timestamp of pool expiration, in seconds\\r\\n    /// @param lastTimestamp Timestamp of the pool's last update, in seconds\\r\\n    /// @param gamma    Multiplied against deltaIn amounts to apply swap fee, gamma = 1 - fee %, scaled up by 1e4\\r\\n    struct Calibration {\\r\\n        uint128 strike;\\r\\n        uint32 sigma;\\r\\n        uint32 maturity;\\r\\n        uint32 lastTimestamp;\\r\\n        uint32 gamma;\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IPrimitiveEngineView\\r\\n    uint256 public constant override PRECISION = 10**18;\\r\\n    /// @inheritdoc IPrimitiveEngineView\\r\\n    uint256 public constant override BUFFER = 120 seconds;\\r\\n    /// @inheritdoc IPrimitiveEngineView\\r\\n    uint256 public immutable override MIN_LIQUIDITY;\\r\\n    /// @inheritdoc IPrimitiveEngineView\\r\\n    uint256 public immutable override scaleFactorRisky;\\r\\n    /// @inheritdoc IPrimitiveEngineView\\r\\n    uint256 public immutable override scaleFactorStable;\\r\\n    /// @inheritdoc IPrimitiveEngineView\\r\\n    address public immutable override factory;\\r\\n    /// @inheritdoc IPrimitiveEngineView\\r\\n    address public immutable override risky;\\r\\n    /// @inheritdoc IPrimitiveEngineView\\r\\n    address public immutable override stable;\\r\\n    /// @dev Reentrancy guard initialized to state\\r\\n    uint256 private locked = 1;\\r\\n    /// @inheritdoc IPrimitiveEngineView\\r\\n    mapping(bytes32 => Calibration) public override calibrations;\\r\\n    /// @inheritdoc IPrimitiveEngineView\\r\\n    mapping(address => Margin.Data) public override margins;\\r\\n    /// @inheritdoc IPrimitiveEngineView\\r\\n    mapping(bytes32 => Reserve.Data) public override reserves;\\r\\n    /// @inheritdoc IPrimitiveEngineView\\r\\n    mapping(address => mapping(bytes32 => uint256)) public override liquidity;\\r\\n\\r\\n    modifier lock() {\\r\\n        if (locked != 1) revert LockedError();\\r\\n\\r\\n        locked = 2;\\r\\n        _;\\r\\n        locked = 1;\\r\\n    }\\r\\n\\r\\n    /// @notice Deploys an Engine with two tokens, a 'Risky' and 'Stable'\\r\\n    constructor() {\\r\\n        (factory, risky, stable, scaleFactorRisky, scaleFactorStable, MIN_LIQUIDITY) = IPrimitiveFactory(msg.sender)\\r\\n            .args();\\r\\n    }\\r\\n\\r\\n    /// @return Risky token balance of this contract\\r\\n    function balanceRisky() private view returns (uint256) {\\r\\n        (bool success, bytes memory data) = risky.staticcall(\\r\\n            abi.encodeWithSelector(IERC20.balanceOf.selector, address(this))\\r\\n        );\\r\\n        if (!success || data.length != 32) revert BalanceError();\\r\\n        return abi.decode(data, (uint256));\\r\\n    }\\r\\n\\r\\n    /// @return Stable token balance of this contract\\r\\n    function balanceStable() private view returns (uint256) {\\r\\n        (bool success, bytes memory data) = stable.staticcall(\\r\\n            abi.encodeWithSelector(IERC20.balanceOf.selector, address(this))\\r\\n        );\\r\\n        if (!success || data.length != 32) revert BalanceError();\\r\\n        return abi.decode(data, (uint256));\\r\\n    }\\r\\n\\r\\n    /// @notice Revert if expected amount does not exceed current balance\\r\\n    function checkRiskyBalance(uint256 expectedRisky) private view {\\r\\n        uint256 actualRisky = balanceRisky();\\r\\n        if (actualRisky < expectedRisky) revert RiskyBalanceError(expectedRisky, actualRisky);\\r\\n    }\\r\\n\\r\\n    /// @notice Revert if expected amount does not exceed current balance\\r\\n    function checkStableBalance(uint256 expectedStable) private view {\\r\\n        uint256 actualStable = balanceStable();\\r\\n        if (actualStable < expectedStable) revert StableBalanceError(expectedStable, actualStable);\\r\\n    }\\r\\n\\r\\n    /// @return blockTimestamp casted as a uint32\\r\\n    function _blockTimestamp() internal view virtual returns (uint32 blockTimestamp) {\\r\\n        // solhint-disable-next-line\\r\\n        blockTimestamp = uint32(block.timestamp);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IPrimitiveEngineActions\\r\\n    function updateLastTimestamp(bytes32 poolId) external override lock returns (uint32 lastTimestamp) {\\r\\n        lastTimestamp = _updateLastTimestamp(poolId);\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the lastTimestamp of `poolId` to `block.timestamp`, max value is `maturity`\\r\\n    /// @return lastTimestamp of the pool, used in calculating the time until expiry\\r\\n    function _updateLastTimestamp(bytes32 poolId) internal virtual returns (uint32 lastTimestamp) {\\r\\n        Calibration storage cal = calibrations[poolId];\\r\\n        if (cal.lastTimestamp == 0) revert UninitializedError();\\r\\n\\r\\n        lastTimestamp = _blockTimestamp();\\r\\n        uint32 maturity = cal.maturity;\\r\\n        if (lastTimestamp > maturity) lastTimestamp = maturity; // if expired, set to the maturity\\r\\n\\r\\n        cal.lastTimestamp = lastTimestamp; // set state\\r\\n        emit UpdateLastTimestamp(poolId);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IPrimitiveEngineActions\\r\\n    function create(\\r\\n        uint128 strike,\\r\\n        uint32 sigma,\\r\\n        uint32 maturity,\\r\\n        uint32 gamma,\\r\\n        uint256 riskyPerLp,\\r\\n        uint256 delLiquidity,\\r\\n        bytes calldata data\\r\\n    )\\r\\n        external\\r\\n        override\\r\\n        lock\\r\\n        returns (\\r\\n            bytes32 poolId,\\r\\n            uint256 delRisky,\\r\\n            uint256 delStable\\r\\n        )\\r\\n    {\\r\\n        (uint256 factor0, uint256 factor1) = (scaleFactorRisky, scaleFactorStable);\\r\\n        poolId = keccak256(abi.encodePacked(address(this), strike, sigma, maturity, gamma));\\r\\n        if (calibrations[poolId].lastTimestamp != 0) revert PoolDuplicateError();\\r\\n        if (sigma > 1e7 || sigma < 1) revert SigmaError(sigma);\\r\\n        if (strike == 0) revert StrikeError(strike);\\r\\n        if (delLiquidity <= MIN_LIQUIDITY) revert MinLiquidityError(delLiquidity);\\r\\n        if (riskyPerLp > PRECISION / factor0 || riskyPerLp == 0) revert RiskyPerLpError(riskyPerLp);\\r\\n        if (gamma > Units.PERCENTAGE || gamma < 9000) revert GammaError(gamma);\\r\\n\\r\\n        Calibration memory cal = Calibration({\\r\\n            strike: strike,\\r\\n            sigma: sigma,\\r\\n            maturity: maturity,\\r\\n            lastTimestamp: _blockTimestamp(),\\r\\n            gamma: gamma\\r\\n        });\\r\\n\\r\\n        if (cal.lastTimestamp > cal.maturity) revert PoolExpiredError();\\r\\n        uint32 tau = cal.maturity - cal.lastTimestamp; // time until expiry\\r\\n        delStable = ReplicationMath.getStableGivenRisky(0, factor0, factor1, riskyPerLp, cal.strike, cal.sigma, tau);\\r\\n        delRisky = (riskyPerLp * delLiquidity) / PRECISION; // riskyDecimals * 1e18 decimals / 1e18 = riskyDecimals\\r\\n        delStable = (delStable * delLiquidity) / PRECISION;\\r\\n        if (delRisky == 0 || delStable == 0) revert CalibrationError(delRisky, delStable);\\r\\n\\r\\n        calibrations[poolId] = cal; // state update\\r\\n        uint256 amount = delLiquidity - MIN_LIQUIDITY;\\r\\n        liquidity[msg.sender][poolId] += amount; // burn min liquidity, at cost of msg.sender\\r\\n        reserves[poolId].allocate(delRisky, delStable, delLiquidity, cal.lastTimestamp); // state update\\r\\n\\r\\n        (uint256 balRisky, uint256 balStable) = (balanceRisky(), balanceStable());\\r\\n        IPrimitiveCreateCallback(msg.sender).createCallback(delRisky, delStable, data);\\r\\n        checkRiskyBalance(balRisky + delRisky);\\r\\n        checkStableBalance(balStable + delStable);\\r\\n\\r\\n        emit Create(msg.sender, cal.strike, cal.sigma, cal.maturity, cal.gamma, delRisky, delStable, amount);\\r\\n    }\\r\\n\\r\\n    // ===== Margin =====\\r\\n\\r\\n    /// @inheritdoc IPrimitiveEngineActions\\r\\n    function deposit(\\r\\n        address recipient,\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable,\\r\\n        bytes calldata data\\r\\n    ) external override lock {\\r\\n        if (delRisky == 0 && delStable == 0) revert ZeroDeltasError();\\r\\n        margins[recipient].deposit(delRisky, delStable); // state update\\r\\n\\r\\n        uint256 balRisky;\\r\\n        uint256 balStable;\\r\\n        if (delRisky != 0) balRisky = balanceRisky();\\r\\n        if (delStable != 0) balStable = balanceStable();\\r\\n        IPrimitiveDepositCallback(msg.sender).depositCallback(delRisky, delStable, data); // agnostic payment\\r\\n        if (delRisky != 0) checkRiskyBalance(balRisky + delRisky);\\r\\n        if (delStable != 0) checkStableBalance(balStable + delStable);\\r\\n        emit Deposit(msg.sender, recipient, delRisky, delStable);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IPrimitiveEngineActions\\r\\n    function withdraw(\\r\\n        address recipient,\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable\\r\\n    ) external override lock {\\r\\n        if (delRisky == 0 && delStable == 0) revert ZeroDeltasError();\\r\\n        margins.withdraw(delRisky, delStable); // state update\\r\\n        if (delRisky != 0) IERC20(risky).safeTransfer(recipient, delRisky);\\r\\n        if (delStable != 0) IERC20(stable).safeTransfer(recipient, delStable);\\r\\n        emit Withdraw(msg.sender, recipient, delRisky, delStable);\\r\\n    }\\r\\n\\r\\n    // ===== Liquidity =====\\r\\n\\r\\n    /// @inheritdoc IPrimitiveEngineActions\\r\\n    function allocate(\\r\\n        bytes32 poolId,\\r\\n        address recipient,\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable,\\r\\n        bool fromMargin,\\r\\n        bytes calldata data\\r\\n    ) external override lock returns (uint256 delLiquidity) {\\r\\n        if (delRisky == 0 || delStable == 0) revert ZeroDeltasError();\\r\\n        Reserve.Data storage reserve = reserves[poolId];\\r\\n        if (reserve.blockTimestamp == 0) revert UninitializedError();\\r\\n        uint32 timestamp = _blockTimestamp();\\r\\n\\r\\n        uint256 liquidity0 = (delRisky * reserve.liquidity) / uint256(reserve.reserveRisky);\\r\\n        uint256 liquidity1 = (delStable * reserve.liquidity) / uint256(reserve.reserveStable);\\r\\n        delLiquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\\r\\n        if (delLiquidity == 0) revert ZeroLiquidityError();\\r\\n\\r\\n        liquidity[recipient][poolId] += delLiquidity; // increase position liquidity\\r\\n        reserve.allocate(delRisky, delStable, delLiquidity, timestamp); // increase reserves and liquidity\\r\\n\\r\\n        if (fromMargin) {\\r\\n            margins.withdraw(delRisky, delStable); // removes tokens from `msg.sender` margin account\\r\\n        } else {\\r\\n            (uint256 balRisky, uint256 balStable) = (balanceRisky(), balanceStable());\\r\\n            IPrimitiveLiquidityCallback(msg.sender).allocateCallback(delRisky, delStable, data); // agnostic payment\\r\\n            checkRiskyBalance(balRisky + delRisky);\\r\\n            checkStableBalance(balStable + delStable);\\r\\n        }\\r\\n\\r\\n        emit Allocate(msg.sender, recipient, poolId, delRisky, delStable, delLiquidity);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IPrimitiveEngineActions\\r\\n    function remove(bytes32 poolId, uint256 delLiquidity)\\r\\n        external\\r\\n        override\\r\\n        lock\\r\\n        returns (uint256 delRisky, uint256 delStable)\\r\\n    {\\r\\n        if (delLiquidity == 0) revert ZeroLiquidityError();\\r\\n        Reserve.Data storage reserve = reserves[poolId];\\r\\n        if (reserve.blockTimestamp == 0) revert UninitializedError();\\r\\n        (delRisky, delStable) = reserve.getAmounts(delLiquidity);\\r\\n\\r\\n        liquidity[msg.sender][poolId] -= delLiquidity; // state update\\r\\n        reserve.remove(delRisky, delStable, delLiquidity, _blockTimestamp());\\r\\n        margins[msg.sender].deposit(delRisky, delStable);\\r\\n\\r\\n        emit Remove(msg.sender, poolId, delRisky, delStable, delLiquidity);\\r\\n    }\\r\\n\\r\\n    struct SwapDetails {\\r\\n        address recipient;\\r\\n        bool riskyForStable;\\r\\n        bool fromMargin;\\r\\n        bool toMargin;\\r\\n        uint32 timestamp;\\r\\n        bytes32 poolId;\\r\\n        uint256 deltaIn;\\r\\n        uint256 deltaOut;\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IPrimitiveEngineActions\\r\\n    function swap(\\r\\n        address recipient,\\r\\n        bytes32 poolId,\\r\\n        bool riskyForStable,\\r\\n        uint256 deltaIn,\\r\\n        uint256 deltaOut,\\r\\n        bool fromMargin,\\r\\n        bool toMargin,\\r\\n        bytes calldata data\\r\\n    ) external override lock {\\r\\n        if (deltaIn == 0) revert DeltaInError();\\r\\n        if (deltaOut == 0) revert DeltaOutError();\\r\\n\\r\\n        SwapDetails memory details = SwapDetails({\\r\\n            recipient: recipient,\\r\\n            poolId: poolId,\\r\\n            deltaIn: deltaIn,\\r\\n            deltaOut: deltaOut,\\r\\n            riskyForStable: riskyForStable,\\r\\n            fromMargin: fromMargin,\\r\\n            toMargin: toMargin,\\r\\n            timestamp: _blockTimestamp()\\r\\n        });\\r\\n\\r\\n        uint32 lastTimestamp = _updateLastTimestamp(details.poolId); // updates lastTimestamp of `poolId`\\r\\n        if (details.timestamp > lastTimestamp + BUFFER) revert PoolExpiredError(); // 120s buffer to allow final swaps\\r\\n        int128 invariantX64 = invariantOf(details.poolId); // stored in memory to perform the invariant check\\r\\n\\r\\n        {\\r\\n            // swap scope, avoids stack too deep errors\\r\\n            Calibration memory cal = calibrations[details.poolId];\\r\\n            Reserve.Data storage reserve = reserves[details.poolId];\\r\\n            uint32 tau = cal.maturity - cal.lastTimestamp;\\r\\n            uint256 deltaInWithFee = (details.deltaIn * cal.gamma) / Units.PERCENTAGE; // amount * (1 - fee %)\\r\\n\\r\\n            uint256 adjustedRisky;\\r\\n            uint256 adjustedStable;\\r\\n            if (details.riskyForStable) {\\r\\n                adjustedRisky = uint256(reserve.reserveRisky) + deltaInWithFee;\\r\\n                adjustedStable = uint256(reserve.reserveStable) - deltaOut;\\r\\n            } else {\\r\\n                adjustedRisky = uint256(reserve.reserveRisky) - deltaOut;\\r\\n                adjustedStable = uint256(reserve.reserveStable) + deltaInWithFee;\\r\\n            }\\r\\n            adjustedRisky = (adjustedRisky * PRECISION) / reserve.liquidity;\\r\\n            adjustedStable = (adjustedStable * PRECISION) / reserve.liquidity;\\r\\n\\r\\n            int128 invariantAfter = ReplicationMath.calcInvariant(\\r\\n                scaleFactorRisky,\\r\\n                scaleFactorStable,\\r\\n                adjustedRisky,\\r\\n                adjustedStable,\\r\\n                cal.strike,\\r\\n                cal.sigma,\\r\\n                tau\\r\\n            );\\r\\n\\r\\n            if (invariantX64 > invariantAfter) revert InvariantError(invariantX64, invariantAfter);\\r\\n            reserve.swap(details.riskyForStable, details.deltaIn, details.deltaOut, details.timestamp); // state update\\r\\n        }\\r\\n\\r\\n        if (details.riskyForStable) {\\r\\n            if (details.toMargin) {\\r\\n                margins[details.recipient].deposit(0, details.deltaOut);\\r\\n            } else {\\r\\n                IERC20(stable).safeTransfer(details.recipient, details.deltaOut); // optimistic transfer out\\r\\n            }\\r\\n\\r\\n            if (details.fromMargin) {\\r\\n                margins.withdraw(details.deltaIn, 0); // pay for swap\\r\\n            } else {\\r\\n                uint256 balRisky = balanceRisky();\\r\\n                IPrimitiveSwapCallback(msg.sender).swapCallback(details.deltaIn, 0, data); // agnostic transfer in\\r\\n                checkRiskyBalance(balRisky + details.deltaIn);\\r\\n            }\\r\\n        } else {\\r\\n            if (details.toMargin) {\\r\\n                margins[details.recipient].deposit(details.deltaOut, 0);\\r\\n            } else {\\r\\n                IERC20(risky).safeTransfer(details.recipient, details.deltaOut); // optimistic transfer out\\r\\n            }\\r\\n\\r\\n            if (details.fromMargin) {\\r\\n                margins.withdraw(0, details.deltaIn); // pay for swap\\r\\n            } else {\\r\\n                uint256 balStable = balanceStable();\\r\\n                IPrimitiveSwapCallback(msg.sender).swapCallback(0, details.deltaIn, data); // agnostic transfer in\\r\\n                checkStableBalance(balStable + details.deltaIn);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit Swap(\\r\\n            msg.sender,\\r\\n            details.recipient,\\r\\n            details.poolId,\\r\\n            details.riskyForStable,\\r\\n            details.deltaIn,\\r\\n            details.deltaOut\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // ===== View =====\\r\\n\\r\\n    /// @inheritdoc IPrimitiveEngineView\\r\\n    function invariantOf(bytes32 poolId) public view override returns (int128 invariant) {\\r\\n        Calibration memory cal = calibrations[poolId];\\r\\n        uint32 tau = cal.maturity - cal.lastTimestamp; // cal maturity can never be less than lastTimestamp\\r\\n        (uint256 riskyPerLiquidity, uint256 stablePerLiquidity) = reserves[poolId].getAmounts(PRECISION); // 1e18 liquidity\\r\\n        invariant = ReplicationMath.calcInvariant(\\r\\n            scaleFactorRisky,\\r\\n            scaleFactorStable,\\r\\n            riskyPerLiquidity,\\r\\n            stablePerLiquidity,\\r\\n            cal.strike,\\r\\n            cal.sigma,\\r\\n            tau\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/Margin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport \\\"./SafeCast.sol\\\";\\r\\n\\r\\n/// @title   Margin Library\\r\\n/// @author  Primitive\\r\\n/// @dev     Uses a data struct with two uint128s to optimize for one storage slot\\r\\nlibrary Margin {\\r\\n    using SafeCast for uint256;\\r\\n\\r\\n    struct Data {\\r\\n        uint128 balanceRisky; // Balance of the risky token, aka underlying asset\\r\\n        uint128 balanceStable; // Balance of the stable token, aka \\\"quote\\\" asset\\r\\n    }\\r\\n\\r\\n    /// @notice             Adds to risky and stable token balances\\r\\n    /// @param  margin      Margin data of an account in storage to manipulate\\r\\n    /// @param  delRisky    Amount of risky tokens to add to margin\\r\\n    /// @param  delStable   Amount of stable tokens to add to margin\\r\\n    function deposit(\\r\\n        Data storage margin,\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable\\r\\n    ) internal {\\r\\n        if (delRisky != 0) margin.balanceRisky += delRisky.toUint128();\\r\\n        if (delStable != 0) margin.balanceStable += delStable.toUint128();\\r\\n    }\\r\\n\\r\\n    /// @notice             Removes risky and stable token balance from `msg.sender`'s internal margin account\\r\\n    /// @param  margins     Margin data mapping, uses `msg.sender`'s margin account\\r\\n    /// @param  delRisky    Amount of risky tokens to subtract from margin\\r\\n    /// @param  delStable   Amount of stable tokens to subtract from margin\\r\\n    /// @return margin      Data storage of a margin account\\r\\n    function withdraw(\\r\\n        mapping(address => Data) storage margins,\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable\\r\\n    ) internal returns (Data storage margin) {\\r\\n        margin = margins[msg.sender];\\r\\n        if (delRisky != 0) margin.balanceRisky -= delRisky.toUint128();\\r\\n        if (delStable != 0) margin.balanceStable -= delStable.toUint128();\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/ReplicationMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./ABDKMath64x64.sol\\\";\\r\\nimport \\\"./CumulativeNormalDistribution.sol\\\";\\r\\nimport \\\"./Units.sol\\\";\\r\\n\\r\\n/// @title   Replication Math\\r\\n/// @author  Primitive\\r\\n/// @notice  Alex Evans, Guillermo Angeris, and Tarun Chitra. Replicating Market Makers.\\r\\n///          https://stanford.edu/~guillean/papers/rmms.pdf\\r\\nlibrary ReplicationMath {\\r\\n    using ABDKMath64x64 for int128;\\r\\n    using ABDKMath64x64 for uint256;\\r\\n    using CumulativeNormalDistribution for int128;\\r\\n    using Units for int128;\\r\\n    using Units for uint256;\\r\\n\\r\\n    int128 internal constant ONE_INT = 0x10000000000000000;\\r\\n\\r\\n    /// @notice         Normalizes volatility with respect to square root of time until expiry\\r\\n    /// @param   sigma  Unsigned 256-bit percentage as an integer with precision of 1e4, 10000 = 100%\\r\\n    /// @param   tau    Time until expiry in seconds as an unsigned 256-bit integer\\r\\n    /// @return  vol    Signed fixed point 64.64 number equal to sigma * sqrt(tau)\\r\\n    function getProportionalVolatility(uint256 sigma, uint256 tau) internal pure returns (int128 vol) {\\r\\n        int128 sqrtTauX64 = tau.toYears().sqrt();\\r\\n        int128 sigmaX64 = sigma.percentageToX64();\\r\\n        vol = sigmaX64.mul(sqrtTauX64);\\r\\n    }\\r\\n\\r\\n    /// @notice                 Uses riskyPerLiquidity and invariant to calculate stablePerLiquidity\\r\\n    /// @dev                    Converts unsigned 256-bit values to fixed point 64.64 numbers w/ decimals of precision\\r\\n    /// @param   invariantLastX64   Signed 64.64 fixed point number. Calculated w/ same `tau` as the parameter `tau`\\r\\n    /// @param   scaleFactorRisky   Unsigned 256-bit integer scaling factor for `risky`, 10^(18 - risky.decimals())\\r\\n    /// @param   scaleFactorStable  Unsigned 256-bit integer scaling factor for `stable`, 10^(18 - stable.decimals())\\r\\n    /// @param   riskyPerLiquidity  Unsigned 256-bit integer of Pool's risky reserves *per liquidity*, 0 <= x <= 1\\r\\n    /// @param   strike         Unsigned 256-bit integer value with precision equal to 10^(18 - scaleFactorStable)\\r\\n    /// @param   sigma          Volatility of the Pool as an unsigned 256-bit integer w/ precision of 1e4, 10000 = 100%\\r\\n    /// @param   tau            Time until expiry in seconds as an unsigned 256-bit integer\\r\\n    /// @return  stablePerLiquidity = K*CDF(CDF^-1(1 - riskyPerLiquidity) - sigma*sqrt(tau)) + invariantLastX64 as uint\\r\\n    function getStableGivenRisky(\\r\\n        int128 invariantLastX64,\\r\\n        uint256 scaleFactorRisky,\\r\\n        uint256 scaleFactorStable,\\r\\n        uint256 riskyPerLiquidity,\\r\\n        uint256 strike,\\r\\n        uint256 sigma,\\r\\n        uint256 tau\\r\\n    ) internal pure returns (uint256 stablePerLiquidity) {\\r\\n        int128 strikeX64 = strike.scaleToX64(scaleFactorStable);\\r\\n        int128 riskyX64 = riskyPerLiquidity.scaleToX64(scaleFactorRisky); // mul by 2^64, div by precision\\r\\n        int128 oneMinusRiskyX64 = ONE_INT.sub(riskyX64);\\r\\n        if (tau != 0) {\\r\\n            int128 volX64 = getProportionalVolatility(sigma, tau);\\r\\n            int128 phi = oneMinusRiskyX64.getInverseCDF();\\r\\n            int128 input = phi.sub(volX64);\\r\\n            int128 stableX64 = strikeX64.mul(input.getCDF()).add(invariantLastX64);\\r\\n            stablePerLiquidity = stableX64.scaleFromX64(scaleFactorStable);\\r\\n        } else {\\r\\n            stablePerLiquidity = (strikeX64.mul(oneMinusRiskyX64).add(invariantLastX64)).scaleFromX64(\\r\\n                scaleFactorStable\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice                 Calculates the invariant of a curve\\r\\n    /// @dev                    Per unit of replication, aka per unit of liquidity\\r\\n    /// @param   scaleFactorRisky   Unsigned 256-bit integer scaling factor for `risky`, 10^(18 - risky.decimals())\\r\\n    /// @param   scaleFactorStable  Unsigned 256-bit integer scaling factor for `stable`, 10^(18 - stable.decimals())\\r\\n    /// @param   riskyPerLiquidity  Unsigned 256-bit integer of Pool's risky reserves *per liquidity*, 0 <= x <= 1\\r\\n    /// @param   stablePerLiquidity Unsigned 256-bit integer of Pool's stable reserves *per liquidity*, 0 <= x <= strike\\r\\n    /// @return  invariantX64       = stablePerLiquidity - K * CDF(CDF^-1(1 - riskyPerLiquidity) - sigma * sqrt(tau))\\r\\n    function calcInvariant(\\r\\n        uint256 scaleFactorRisky,\\r\\n        uint256 scaleFactorStable,\\r\\n        uint256 riskyPerLiquidity,\\r\\n        uint256 stablePerLiquidity,\\r\\n        uint256 strike,\\r\\n        uint256 sigma,\\r\\n        uint256 tau\\r\\n    ) internal pure returns (int128 invariantX64) {\\r\\n        uint256 output = getStableGivenRisky(\\r\\n            0,\\r\\n            scaleFactorRisky,\\r\\n            scaleFactorStable,\\r\\n            riskyPerLiquidity,\\r\\n            strike,\\r\\n            sigma,\\r\\n            tau\\r\\n        );\\r\\n        int128 outputX64 = output.scaleToX64(scaleFactorStable);\\r\\n        int128 stableX64 = stablePerLiquidity.scaleToX64(scaleFactorStable);\\r\\n        invariantX64 = stableX64.sub(outputX64);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/Reserve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport \\\"./SafeCast.sol\\\";\\r\\n\\r\\n/// @title   Reserves Library\\r\\n/// @author  Primitive\\r\\n/// @dev     Data structure library for an Engine's Reserves\\r\\nlibrary Reserve {\\r\\n    using SafeCast for uint256;\\r\\n\\r\\n    /// @notice                Stores global state of a pool\\r\\n    /// @param reserveRisky    Risky token reserve\\r\\n    /// @param reserveStable   Stable token reserve\\r\\n    /// @param liquidity       Total supply of liquidity\\r\\n    /// @param blockTimestamp  Last timestamp of which updated the accumulators\\r\\n    /// @param cumulativeRisky Cumulative sum of the risky reserves\\r\\n    /// @param cumulativeStable Cumulative sum of stable reserves\\r\\n    /// @param cumulativeLiquidity Cumulative sum of total liquidity supply\\r\\n    struct Data {\\r\\n        uint128 reserveRisky;\\r\\n        uint128 reserveStable;\\r\\n        uint128 liquidity;\\r\\n        uint32 blockTimestamp;\\r\\n        uint256 cumulativeRisky;\\r\\n        uint256 cumulativeStable;\\r\\n        uint256 cumulativeLiquidity;\\r\\n    }\\r\\n\\r\\n    /// @notice                 Adds to the cumulative reserves\\r\\n    /// @dev                    Overflow is desired on the cumulative values\\r\\n    /// @param  res             Reserve storage to update\\r\\n    /// @param  blockTimestamp  Checkpoint timestamp of update\\r\\n    function update(Data storage res, uint32 blockTimestamp) internal {\\r\\n        uint32 deltaTime = blockTimestamp - res.blockTimestamp;\\r\\n        // overflow is desired\\r\\n        if (deltaTime != 0) {\\r\\n            unchecked {\\r\\n                res.cumulativeRisky += uint256(res.reserveRisky) * deltaTime;\\r\\n                res.cumulativeStable += uint256(res.reserveStable) * deltaTime;\\r\\n                res.cumulativeLiquidity += uint256(res.liquidity) * deltaTime;\\r\\n            }\\r\\n            res.blockTimestamp = blockTimestamp;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice                 Increases one reserve value and decreases the other\\r\\n    /// @param  reserve         Reserve state to update\\r\\n    /// @param  riskyForStable  Direction of swap\\r\\n    /// @param  deltaIn         Amount of tokens paid, increases one reserve by\\r\\n    /// @param  deltaOut        Amount of tokens sent out, decreases the other reserve by\\r\\n    /// @param  blockTimestamp  Timestamp used to update cumulative reserves\\r\\n    function swap(\\r\\n        Data storage reserve,\\r\\n        bool riskyForStable,\\r\\n        uint256 deltaIn,\\r\\n        uint256 deltaOut,\\r\\n        uint32 blockTimestamp\\r\\n    ) internal {\\r\\n        update(reserve, blockTimestamp);\\r\\n        if (riskyForStable) {\\r\\n            reserve.reserveRisky += deltaIn.toUint128();\\r\\n            reserve.reserveStable -= deltaOut.toUint128();\\r\\n        } else {\\r\\n            reserve.reserveRisky -= deltaOut.toUint128();\\r\\n            reserve.reserveStable += deltaIn.toUint128();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice                 Add to both reserves and total supply of liquidity\\r\\n    /// @param  reserve         Reserve storage to manipulate\\r\\n    /// @param  delRisky        Amount of risky tokens to add to the reserve\\r\\n    /// @param  delStable       Amount of stable tokens to add to the reserve\\r\\n    /// @param  delLiquidity    Amount of liquidity created with the provided tokens\\r\\n    /// @param  blockTimestamp  Timestamp used to update cumulative reserves\\r\\n    function allocate(\\r\\n        Data storage reserve,\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable,\\r\\n        uint256 delLiquidity,\\r\\n        uint32 blockTimestamp\\r\\n    ) internal {\\r\\n        update(reserve, blockTimestamp);\\r\\n        reserve.reserveRisky += delRisky.toUint128();\\r\\n        reserve.reserveStable += delStable.toUint128();\\r\\n        reserve.liquidity += delLiquidity.toUint128();\\r\\n    }\\r\\n\\r\\n    /// @notice                 Remove from both reserves and total supply of liquidity\\r\\n    /// @param  reserve         Reserve storage to manipulate\\r\\n    /// @param  delRisky        Amount of risky tokens to remove to the reserve\\r\\n    /// @param  delStable       Amount of stable tokens to remove to the reserve\\r\\n    /// @param  delLiquidity    Amount of liquidity removed from total supply\\r\\n    /// @param  blockTimestamp  Timestamp used to update cumulative reserves\\r\\n    function remove(\\r\\n        Data storage reserve,\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable,\\r\\n        uint256 delLiquidity,\\r\\n        uint32 blockTimestamp\\r\\n    ) internal {\\r\\n        update(reserve, blockTimestamp);\\r\\n        reserve.reserveRisky -= delRisky.toUint128();\\r\\n        reserve.reserveStable -= delStable.toUint128();\\r\\n        reserve.liquidity -= delLiquidity.toUint128();\\r\\n    }\\r\\n\\r\\n    /// @notice                 Calculates risky and stable token amounts of `delLiquidity`\\r\\n    /// @param reserve          Reserve in memory to use reserves and liquidity of\\r\\n    /// @param delLiquidity     Amount of liquidity to fetch underlying tokens of\\r\\n    /// @return delRisky        Amount of risky tokens controlled by `delLiquidity`\\r\\n    /// @return delStable       Amount of stable tokens controlled by `delLiquidity`\\r\\n    function getAmounts(Data memory reserve, uint256 delLiquidity)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 delRisky, uint256 delStable)\\r\\n    {\\r\\n        uint256 liq = uint256(reserve.liquidity);\\r\\n        delRisky = (delLiquidity * uint256(reserve.reserveRisky)) / liq;\\r\\n        delStable = (delLiquidity * uint256(reserve.reserveStable)) / liq;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/// @title  SafeCast\\r\\n/// @notice Safely cast between uint256 and uint128\\r\\nlibrary SafeCast {\\r\\n    /// @notice reverts if x > type(uint128).max\\r\\n    function toUint128(uint256 x) internal pure returns (uint128 z) {\\r\\n        require(x <= type(uint128).max);\\r\\n        z = uint128(x);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/Transfers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity >=0.6.0;\\r\\n\\r\\nimport \\\"../interfaces/IERC20.sol\\\";\\r\\n\\r\\n/// @title  Transfers\\r\\nlibrary Transfers {\\r\\n    /// @notice         Performs an ERC20 `transfer` call and checks return data\\r\\n    /// @param  token   ERC20 token to transfer\\r\\n    /// @param  to      Recipient of the ERC20 token\\r\\n    /// @param  value   Amount of ERC20 to transfer\\r\\n    function safeTransfer(\\r\\n        IERC20 token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        (bool success, bytes memory returnData) = address(token).call(\\r\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\r\\n        );\\r\\n        require(success && (returnData.length == 0 || abi.decode(returnData, (bool))), \\\"Transfer fail\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/Units.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ABDKMath64x64.sol\\\";\\r\\n\\r\\n/// @title   Units library\\r\\n/// @author  Primitive\\r\\n/// @notice  Utility functions for unit conversions\\r\\nlibrary Units {\\r\\n    using ABDKMath64x64 for int128;\\r\\n    using ABDKMath64x64 for uint256;\\r\\n\\r\\n    uint256 internal constant YEAR = 31556952; // 365.24219 ephemeris day = 1 year, in seconds\\r\\n    uint256 internal constant PRECISION = 1e18; // precision to scale to\\r\\n    uint256 internal constant PERCENTAGE = 1e4; // precision of percentages\\r\\n\\r\\n    // ===== Unit Conversion =====\\r\\n\\r\\n    /// @notice             Scales a wei value to a precision of 1e18 using the scaling factor\\r\\n    /// @param   value      Unsigned 256-bit wei amount to convert with native decimals\\r\\n    /// @param   factor     Scaling factor to multiply by, i.e. 10^(18 - value.decimals())\\r\\n    /// @return  y          Unsigned 256-bit wei amount scaled to a precision of 1e18\\r\\n    function scaleUp(uint256 value, uint256 factor) internal pure returns (uint256 y) {\\r\\n        y = value * factor;\\r\\n    }\\r\\n\\r\\n    /// @notice             Scales a wei value from a precision of 1e18 to 10^(18 - precision)\\r\\n    /// @param   value      Unsigned 256-bit wei amount with 18 decimals\\r\\n    /// @param   factor     Scaling factor to divide by, i.e. 10^(18 - value.decimals())\\r\\n    /// @return  y          Unsigned 256-bit wei amount scaled to 10^(18 - factor)\\r\\n    function scaleDown(uint256 value, uint256 factor) internal pure returns (uint256 y) {\\r\\n        y = value / factor;\\r\\n    }\\r\\n\\r\\n    /// @notice             Converts unsigned 256-bit wei value into a fixed point 64.64 number\\r\\n    /// @param   value      Unsigned 256-bit wei amount, in native precision\\r\\n    /// @param   factor     Scaling factor for `value`, used to calculate decimals of `value`\\r\\n    /// @return  y          Signed 64.64 fixed point number scaled from native precision\\r\\n    function scaleToX64(uint256 value, uint256 factor) internal pure returns (int128 y) {\\r\\n        uint256 scaleFactor = PRECISION / factor;\\r\\n        y = value.divu(scaleFactor);\\r\\n    }\\r\\n\\r\\n    /// @notice             Converts signed fixed point 64.64 number into unsigned 256-bit wei value\\r\\n    /// @param   value      Signed fixed point 64.64 number to convert from precision of 10^18\\r\\n    /// @param   factor     Scaling factor for `value`, used to calculate decimals of `value`\\r\\n    /// @return  y          Unsigned 256-bit wei amount scaled to native precision of 10^(18 - factor)\\r\\n    function scaleFromX64(int128 value, uint256 factor) internal pure returns (uint256 y) {\\r\\n        uint256 scaleFactor = PRECISION / factor;\\r\\n        y = value.mulu(scaleFactor);\\r\\n    }\\r\\n\\r\\n    /// @notice         Converts denormalized percentage integer to a fixed point 64.64 number\\r\\n    /// @dev            Convert unsigned 256-bit integer number into signed 64.64 fixed point number\\r\\n    /// @param denorm   Unsigned percentage integer with precision of 1e4\\r\\n    /// @return         Signed 64.64 fixed point percentage with precision of 1e4\\r\\n    function percentageToX64(uint256 denorm) internal pure returns (int128) {\\r\\n        return denorm.divu(PERCENTAGE);\\r\\n    }\\r\\n\\r\\n    /// @notice         Converts unsigned seconds integer into years as a signed 64.64 fixed point number\\r\\n    /// @dev            Convert unsigned 256-bit integer number into signed 64.64 fixed point number\\r\\n    /// @param s        Unsigned 256-bit integer amount of seconds to convert into year units\\r\\n    /// @return         Fixed point 64.64 number of years equal to `seconds`\\r\\n    function toYears(uint256 s) internal pure returns (int128) {\\r\\n        return s.divu(YEAR);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/callback/IPrimitiveCreateCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/// @title  Primitive Create Callback\\r\\n/// @author Primitive\\r\\ninterface IPrimitiveCreateCallback {\\r\\n    /// @notice              Triggered when creating a new pool for an Engine\\r\\n    /// @param  delRisky     Amount of risky tokens required to initialize risky reserve\\r\\n    /// @param  delStable    Amount of stable tokens required to initialize stable reserve\\r\\n    /// @param  data         Calldata passed on create function call\\r\\n    function createCallback(\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/callback/IPrimitiveDepositCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/// @title  Primitive Deposit Callback\\r\\n/// @author Primitive\\r\\ninterface IPrimitiveDepositCallback {\\r\\n    /// @notice              Triggered when depositing tokens to an Engine\\r\\n    /// @param  delRisky     Amount of risky tokens required to deposit to risky margin balance\\r\\n    /// @param  delStable    Amount of stable tokens required to deposit to stable margin balance\\r\\n    /// @param  data         Calldata passed on deposit function call\\r\\n    function depositCallback(\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/callback/IPrimitiveLiquidityCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/// @title  Primitive Liquidity Callback\\r\\n/// @author Primitive\\r\\ninterface IPrimitiveLiquidityCallback {\\r\\n    /// @notice              Triggered when providing liquidity to an Engine\\r\\n    /// @param  delRisky     Amount of risky tokens required to provide to risky reserve\\r\\n    /// @param  delStable    Amount of stable tokens required to provide to stable reserve\\r\\n    /// @param  data         Calldata passed on allocate function call\\r\\n    function allocateCallback(\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/callback/IPrimitiveSwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/// @title  Primitive Swap Callback\\r\\n/// @author Primitive\\r\\ninterface IPrimitiveSwapCallback {\\r\\n    /// @notice              Triggered when swapping tokens in an Engine\\r\\n    /// @param  delRisky     Amount of risky tokens required to pay the swap with\\r\\n    /// @param  delStable    Amount of stable tokens required to pay the swap with\\r\\n    /// @param  data         Calldata passed on swap function call\\r\\n    function swapCallback(\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPrimitiveEngine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity >=0.8.4;\\r\\n\\r\\nimport \\\"./engine/IPrimitiveEngineActions.sol\\\";\\r\\nimport \\\"./engine/IPrimitiveEngineEvents.sol\\\";\\r\\nimport \\\"./engine/IPrimitiveEngineView.sol\\\";\\r\\nimport \\\"./engine/IPrimitiveEngineErrors.sol\\\";\\r\\n\\r\\n/// @title Primitive Engine Interface\\r\\ninterface IPrimitiveEngine is\\r\\n    IPrimitiveEngineActions,\\r\\n    IPrimitiveEngineEvents,\\r\\n    IPrimitiveEngineView,\\r\\n    IPrimitiveEngineErrors\\r\\n{\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPrimitiveFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity >=0.8.4;\\r\\n\\r\\n/// @title   Primitive Factory Interface\\r\\n/// @author  Primitive\\r\\ninterface IPrimitiveFactory {\\r\\n    /// @notice         Created a new engine contract!\\r\\n    /// @param  from    Calling `msg.sender` of deploy\\r\\n    /// @param  risky   Risky token of Engine to deploy\\r\\n    /// @param  stable  Stable token of Engine to deploy\\r\\n    /// @param  engine  Deployed engine address\\r\\n    event DeployEngine(address indexed from, address indexed risky, address indexed stable, address engine);\\r\\n\\r\\n    /// @notice         Deploys a new Engine contract and sets the `getEngine` mapping for the tokens\\r\\n    /// @param  risky   Risky token, the underlying token\\r\\n    /// @param  stable  Stable token, the quote token\\r\\n    function deploy(address risky, address stable) external returns (address engine);\\r\\n\\r\\n    // ===== View =====\\r\\n\\r\\n    /// @notice         Used to scale the minimum amount of liquidity to lowest precision\\r\\n    /// @dev            E.g. if the lowest decimal token is 6, min liquidity w/ 18 decimals\\r\\n    ///                 cannot be 1000 wei, therefore the token decimals\\r\\n    ///                 divided by the min liquidity factor is the amount of minimum liquidity\\r\\n    ///                 MIN_LIQUIDITY = 10 ^ (Decimals / MIN_LIQUIDITY_FACTOR)\\r\\n    function MIN_LIQUIDITY_FACTOR() external pure returns (uint256);\\r\\n\\r\\n    /// @notice                    Called within Engine constructor so Engine can set immutable\\r\\n    ///                            variables without constructor args\\r\\n    /// @return factory            Smart contract deploying the Engine contract\\r\\n    /// @return risky              Risky token\\r\\n    /// @return stable             Stable token\\r\\n    /// @return scaleFactorRisky   Scale factor of the risky token, 10^(18 - riskyTokenDecimals)\\r\\n    /// @return scaleFactorStable  Scale factor of the stable token, 10^(18 - stableTokenDecimals)\\r\\n    /// @return minLiquidity       Minimum amount of liquidity on pool creation\\r\\n    function args()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            address factory,\\r\\n            address risky,\\r\\n            address stable,\\r\\n            uint256 scaleFactorRisky,\\r\\n            uint256 scaleFactorStable,\\r\\n            uint256 minLiquidity\\r\\n        );\\r\\n\\r\\n    /// @notice         Fetches engine address of a token pair which has been deployed from this factory\\r\\n    /// @param risky    Risky token, the underlying token\\r\\n    /// @param stable   Stable token, the quote token\\r\\n    /// @return engine  Engine address for a risky and stable token\\r\\n    function getEngine(address risky, address stable) external view returns (address engine);\\r\\n\\r\\n    /// @notice         Deployer does not have any access controls to wield\\r\\n    /// @return         Deployer of this factory contract\\r\\n    function deployer() external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/ABDKMath64x64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-4-Clause\\r\\n/*\\r\\n * ABDK Math 64.64 Smart Contract Library.  Copyright \u00a9 2019 by ABDK Consulting.\\r\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\r\\n */\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * Smart contract library of mathematical functions operating with signed\\r\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\r\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\r\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\r\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\r\\n * represented by int128 type holding only the numerator.\\r\\n */\\r\\nlibrary ABDKMath64x64 {\\r\\n    /*\\r\\n     * Minimum value signed 64.64-bit fixed point number may have.\\r\\n     */\\r\\n    int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\r\\n\\r\\n    /*\\r\\n     * Maximum value signed 64.64-bit fixed point number may have.\\r\\n     */\\r\\n    int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n    /**\\r\\n     * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\r\\n     * number.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 256-bit integer number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function fromInt(int256 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\r\\n            return int128(x << 64);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert signed 64.64 fixed point number into signed 64-bit integer number\\r\\n     * rounding down.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64-bit integer number\\r\\n     */\\r\\n    function toInt(int128 x) internal pure returns (int64) {\\r\\n        unchecked {\\r\\n            return int64(x >> 64);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\r\\n     * number.  Revert on overflow.\\r\\n     *\\r\\n     * @param x unsigned 256-bit integer number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function fromUInt(uint256 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x <= 0x7FFFFFFFFFFFFFFF);\\r\\n            return int128(int256(x << 64));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\r\\n     * number rounding down.  Revert on underflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return unsigned 64-bit integer number\\r\\n     */\\r\\n    function toUInt(int128 x) internal pure returns (uint64) {\\r\\n        unchecked {\\r\\n            require(x >= 0);\\r\\n            return uint64(uint128(x >> 64));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\r\\n     * number rounding down.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 128.128-bin fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function from128x128(int256 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            int256 result = x >> 64;\\r\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\r\\n     * number.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 128.128 fixed point number\\r\\n     */\\r\\n    function to128x128(int128 x) internal pure returns (int256) {\\r\\n        unchecked {\\r\\n            return int256(x) << 64;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x + y.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @param y signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function add(int128 x, int128 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            int256 result = int256(x) + y;\\r\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x - y.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @param y signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function sub(int128 x, int128 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            int256 result = int256(x) - y;\\r\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x * y rounding down.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @param y signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function mul(int128 x, int128 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            int256 result = (int256(x) * y) >> 64;\\r\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\r\\n     * number and y is signed 256-bit integer number.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64 fixed point number\\r\\n     * @param y signed 256-bit integer number\\r\\n     * @return signed 256-bit integer number\\r\\n     */\\r\\n    function muli(int128 x, int256 y) internal pure returns (int256) {\\r\\n        unchecked {\\r\\n            if (x == MIN_64x64) {\\r\\n                require(\\r\\n                    y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\r\\n                        y <= 0x1000000000000000000000000000000000000000000000000\\r\\n                );\\r\\n                return -y << 63;\\r\\n            } else {\\r\\n                bool negativeResult = false;\\r\\n                if (x < 0) {\\r\\n                    x = -x;\\r\\n                    negativeResult = true;\\r\\n                }\\r\\n                if (y < 0) {\\r\\n                    y = -y; // We rely on overflow behavior here\\r\\n                    negativeResult = !negativeResult;\\r\\n                }\\r\\n                uint256 absoluteResult = mulu(x, uint256(y));\\r\\n                if (negativeResult) {\\r\\n                    require(absoluteResult <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\r\\n                    return -int256(absoluteResult); // We rely on overflow behavior here\\r\\n                } else {\\r\\n                    require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n                    return int256(absoluteResult);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\r\\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64 fixed point number\\r\\n     * @param y unsigned 256-bit integer number\\r\\n     * @return unsigned 256-bit integer number\\r\\n     */\\r\\n    function mulu(int128 x, uint256 y) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            if (y == 0) return 0;\\r\\n\\r\\n            require(x >= 0);\\r\\n\\r\\n            uint256 lo = (uint256(int256(x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\r\\n            uint256 hi = uint256(int256(x)) * (y >> 128);\\r\\n\\r\\n            require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n            hi <<= 64;\\r\\n\\r\\n            require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\\r\\n            return hi + lo;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\r\\n     * zero.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @param y signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function div(int128 x, int128 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(y != 0);\\r\\n            int256 result = (int256(x) << 64) / y;\\r\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\r\\n     * integer numbers.  Revert on overflow or when y is zero.\\r\\n     *\\r\\n     * @param x signed 256-bit integer number\\r\\n     * @param y signed 256-bit integer number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function divi(int256 x, int256 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(y != 0);\\r\\n\\r\\n            bool negativeResult = false;\\r\\n            if (x < 0) {\\r\\n                x = -x; // We rely on overflow behavior here\\r\\n                negativeResult = true;\\r\\n            }\\r\\n            if (y < 0) {\\r\\n                y = -y; // We rely on overflow behavior here\\r\\n                negativeResult = !negativeResult;\\r\\n            }\\r\\n            uint128 absoluteResult = divuu(uint256(x), uint256(y));\\r\\n            if (negativeResult) {\\r\\n                require(absoluteResult <= 0x80000000000000000000000000000000);\\r\\n                return -int128(absoluteResult); // We rely on overflow behavior here\\r\\n            } else {\\r\\n                require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n                return int128(absoluteResult); // We rely on overflow behavior here\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\r\\n     * integer numbers.  Revert on overflow or when y is zero.\\r\\n     *\\r\\n     * @param x unsigned 256-bit integer number\\r\\n     * @param y unsigned 256-bit integer number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function divu(uint256 x, uint256 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(y != 0);\\r\\n            uint128 result = divuu(x, y);\\r\\n            require(result <= uint128(MAX_64x64));\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate -x.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function neg(int128 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x != MIN_64x64);\\r\\n            return -x;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate |x|.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function abs(int128 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x != MIN_64x64);\\r\\n            return x < 0 ? -x : x;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\r\\n     * zero.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function inv(int128 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x != 0);\\r\\n            int256 result = int256(0x100000000000000000000000000000000) / x;\\r\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @param y signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function avg(int128 x, int128 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            return int128((int256(x) + int256(y)) >> 1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\r\\n     * Revert on overflow or in case x * y is negative.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @param y signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function gavg(int128 x, int128 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            int256 m = int256(x) * int256(y);\\r\\n            require(m >= 0);\\r\\n            require(m < 0x4000000000000000000000000000000000000000000000000000000000000000);\\r\\n            return int128(sqrtu(uint256(m)));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\r\\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @param y uint256 value\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function pow(int128 x, uint256 y) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            bool negative = x < 0 && y & 1 == 1;\\r\\n\\r\\n            uint256 absX = uint128(x < 0 ? -x : x);\\r\\n            uint256 absResult;\\r\\n            absResult = 0x100000000000000000000000000000000;\\r\\n\\r\\n            if (absX <= 0x10000000000000000) {\\r\\n                absX <<= 63;\\r\\n                while (y != 0) {\\r\\n                    if (y & 0x1 != 0) {\\r\\n                        absResult = (absResult * absX) >> 127;\\r\\n                    }\\r\\n                    absX = (absX * absX) >> 127;\\r\\n\\r\\n                    if (y & 0x2 != 0) {\\r\\n                        absResult = (absResult * absX) >> 127;\\r\\n                    }\\r\\n                    absX = (absX * absX) >> 127;\\r\\n\\r\\n                    if (y & 0x4 != 0) {\\r\\n                        absResult = (absResult * absX) >> 127;\\r\\n                    }\\r\\n                    absX = (absX * absX) >> 127;\\r\\n\\r\\n                    if (y & 0x8 != 0) {\\r\\n                        absResult = (absResult * absX) >> 127;\\r\\n                    }\\r\\n                    absX = (absX * absX) >> 127;\\r\\n\\r\\n                    y >>= 4;\\r\\n                }\\r\\n\\r\\n                absResult >>= 64;\\r\\n            } else {\\r\\n                uint256 absXShift = 63;\\r\\n                if (absX < 0x1000000000000000000000000) {\\r\\n                    absX <<= 32;\\r\\n                    absXShift -= 32;\\r\\n                }\\r\\n                if (absX < 0x10000000000000000000000000000) {\\r\\n                    absX <<= 16;\\r\\n                    absXShift -= 16;\\r\\n                }\\r\\n                if (absX < 0x1000000000000000000000000000000) {\\r\\n                    absX <<= 8;\\r\\n                    absXShift -= 8;\\r\\n                }\\r\\n                if (absX < 0x10000000000000000000000000000000) {\\r\\n                    absX <<= 4;\\r\\n                    absXShift -= 4;\\r\\n                }\\r\\n                if (absX < 0x40000000000000000000000000000000) {\\r\\n                    absX <<= 2;\\r\\n                    absXShift -= 2;\\r\\n                }\\r\\n                if (absX < 0x80000000000000000000000000000000) {\\r\\n                    absX <<= 1;\\r\\n                    absXShift -= 1;\\r\\n                }\\r\\n\\r\\n                uint256 resultShift = 0;\\r\\n                while (y != 0) {\\r\\n                    require(absXShift < 64);\\r\\n\\r\\n                    if (y & 0x1 != 0) {\\r\\n                        absResult = (absResult * absX) >> 127;\\r\\n                        resultShift += absXShift;\\r\\n                        if (absResult > 0x100000000000000000000000000000000) {\\r\\n                            absResult >>= 1;\\r\\n                            resultShift += 1;\\r\\n                        }\\r\\n                    }\\r\\n                    absX = (absX * absX) >> 127;\\r\\n                    absXShift <<= 1;\\r\\n                    if (absX >= 0x100000000000000000000000000000000) {\\r\\n                        absX >>= 1;\\r\\n                        absXShift += 1;\\r\\n                    }\\r\\n\\r\\n                    y >>= 1;\\r\\n                }\\r\\n\\r\\n                require(resultShift < 64);\\r\\n                absResult >>= 64 - resultShift;\\r\\n            }\\r\\n            int256 result = negative ? -int256(absResult) : int256(absResult);\\r\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate sqrt (x) rounding down.  Revert if x < 0.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function sqrt(int128 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x >= 0);\\r\\n            return int128(sqrtu(uint256(int256(x)) << 64));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate binary logarithm of x.  Revert if x <= 0.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function log_2(int128 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x > 0);\\r\\n\\r\\n            int256 msb = 0;\\r\\n            int256 xc = x;\\r\\n            if (xc >= 0x10000000000000000) {\\r\\n                xc >>= 64;\\r\\n                msb += 64;\\r\\n            }\\r\\n            if (xc >= 0x100000000) {\\r\\n                xc >>= 32;\\r\\n                msb += 32;\\r\\n            }\\r\\n            if (xc >= 0x10000) {\\r\\n                xc >>= 16;\\r\\n                msb += 16;\\r\\n            }\\r\\n            if (xc >= 0x100) {\\r\\n                xc >>= 8;\\r\\n                msb += 8;\\r\\n            }\\r\\n            if (xc >= 0x10) {\\r\\n                xc >>= 4;\\r\\n                msb += 4;\\r\\n            }\\r\\n            if (xc >= 0x4) {\\r\\n                xc >>= 2;\\r\\n                msb += 2;\\r\\n            }\\r\\n            if (xc >= 0x2) msb += 1; // No need to shift xc anymore\\r\\n\\r\\n            int256 result = (msb - 64) << 64;\\r\\n            uint256 ux = uint256(int256(x)) << uint256(127 - msb);\\r\\n            for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\r\\n                ux *= ux;\\r\\n                uint256 b = ux >> 255;\\r\\n                ux >>= 127 + b;\\r\\n                result += bit * int256(b);\\r\\n            }\\r\\n\\r\\n            return int128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate natural logarithm of x.  Revert if x <= 0.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function ln(int128 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x > 0);\\r\\n\\r\\n            return int128(int256((uint256(int256(log_2(x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate binary exponent of x.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function exp_2(int128 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x < 0x400000000000000000); // Overflow\\r\\n\\r\\n            if (x < -0x400000000000000000) return 0; // Underflow\\r\\n\\r\\n            uint256 result = 0x80000000000000000000000000000000;\\r\\n\\r\\n            if (x & 0x8000000000000000 > 0) result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\\r\\n            if (x & 0x4000000000000000 > 0) result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >> 128;\\r\\n            if (x & 0x2000000000000000 > 0) result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >> 128;\\r\\n            if (x & 0x1000000000000000 > 0) result = (result * 0x10B5586CF9890F6298B92B71842A98363) >> 128;\\r\\n            if (x & 0x800000000000000 > 0) result = (result * 0x1059B0D31585743AE7C548EB68CA417FD) >> 128;\\r\\n            if (x & 0x400000000000000 > 0) result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >> 128;\\r\\n            if (x & 0x200000000000000 > 0) result = (result * 0x10163DA9FB33356D84A66AE336DCDFA3F) >> 128;\\r\\n            if (x & 0x100000000000000 > 0) result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >> 128;\\r\\n            if (x & 0x80000000000000 > 0) result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679B) >> 128;\\r\\n            if (x & 0x40000000000000 > 0) result = (result * 0x1002C605E2E8CEC506D21BFC89A23A00F) >> 128;\\r\\n            if (x & 0x20000000000000 > 0) result = (result * 0x100162F3904051FA128BCA9C55C31E5DF) >> 128;\\r\\n            if (x & 0x10000000000000 > 0) result = (result * 0x1000B175EFFDC76BA38E31671CA939725) >> 128;\\r\\n            if (x & 0x8000000000000 > 0) result = (result * 0x100058BA01FB9F96D6CACD4B180917C3D) >> 128;\\r\\n            if (x & 0x4000000000000 > 0) result = (result * 0x10002C5CC37DA9491D0985C348C68E7B3) >> 128;\\r\\n            if (x & 0x2000000000000 > 0) result = (result * 0x1000162E525EE054754457D5995292026) >> 128;\\r\\n            if (x & 0x1000000000000 > 0) result = (result * 0x10000B17255775C040618BF4A4ADE83FC) >> 128;\\r\\n            if (x & 0x800000000000 > 0) result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >> 128;\\r\\n            if (x & 0x400000000000 > 0) result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >> 128;\\r\\n            if (x & 0x200000000000 > 0) result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\\r\\n            if (x & 0x100000000000 > 0) result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\\r\\n            if (x & 0x80000000000 > 0) result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128;\\r\\n            if (x & 0x40000000000 > 0) result = (result * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128;\\r\\n            if (x & 0x20000000000 > 0) result = (result * 0x100000162E430E5A18F6119E3C02282A5) >> 128;\\r\\n            if (x & 0x10000000000 > 0) result = (result * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128;\\r\\n            if (x & 0x8000000000 > 0) result = (result * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128;\\r\\n            if (x & 0x4000000000 > 0) result = (result * 0x10000002C5C8601CC6B9E94213C72737A) >> 128;\\r\\n            if (x & 0x2000000000 > 0) result = (result * 0x1000000162E42FFF037DF38AA2B219F06) >> 128;\\r\\n            if (x & 0x1000000000 > 0) result = (result * 0x10000000B17217FBA9C739AA5819F44F9) >> 128;\\r\\n            if (x & 0x800000000 > 0) result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128;\\r\\n            if (x & 0x400000000 > 0) result = (result * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128;\\r\\n            if (x & 0x200000000 > 0) result = (result * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128;\\r\\n            if (x & 0x100000000 > 0) result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\\r\\n            if (x & 0x80000000 > 0) result = (result * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128;\\r\\n            if (x & 0x40000000 > 0) result = (result * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128;\\r\\n            if (x & 0x20000000 > 0) result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\\r\\n            if (x & 0x10000000 > 0) result = (result * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128;\\r\\n            if (x & 0x8000000 > 0) result = (result * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128;\\r\\n            if (x & 0x4000000 > 0) result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128;\\r\\n            if (x & 0x2000000 > 0) result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\\r\\n            if (x & 0x1000000 > 0) result = (result * 0x10000000000B17217F7D20CF927C8E94C) >> 128;\\r\\n            if (x & 0x800000 > 0) result = (result * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128;\\r\\n            if (x & 0x400000 > 0) result = (result * 0x100000000002C5C85FDF477B662B26945) >> 128;\\r\\n            if (x & 0x200000 > 0) result = (result * 0x10000000000162E42FEFA3AE53369388C) >> 128;\\r\\n            if (x & 0x100000 > 0) result = (result * 0x100000000000B17217F7D1D351A389D40) >> 128;\\r\\n            if (x & 0x80000 > 0) result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDE) >> 128;\\r\\n            if (x & 0x40000 > 0) result = (result * 0x1000000000002C5C85FDF4741BEA6E77E) >> 128;\\r\\n            if (x & 0x20000 > 0) result = (result * 0x100000000000162E42FEFA39FE95583C2) >> 128;\\r\\n            if (x & 0x10000 > 0) result = (result * 0x1000000000000B17217F7D1CFB72B45E1) >> 128;\\r\\n            if (x & 0x8000 > 0) result = (result * 0x100000000000058B90BFBE8E7CC35C3F0) >> 128;\\r\\n            if (x & 0x4000 > 0) result = (result * 0x10000000000002C5C85FDF473E242EA38) >> 128;\\r\\n            if (x & 0x2000 > 0) result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;\\r\\n            if (x & 0x1000 > 0) result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\\r\\n            if (x & 0x800 > 0) result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\\r\\n            if (x & 0x400 > 0) result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;\\r\\n            if (x & 0x200 > 0) result = (result * 0x10000000000000162E42FEFA39EF44D91) >> 128;\\r\\n            if (x & 0x100 > 0) result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;\\r\\n            if (x & 0x80 > 0) result = (result * 0x10000000000000058B90BFBE8E7BCE544) >> 128;\\r\\n            if (x & 0x40 > 0) result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\\r\\n            if (x & 0x20 > 0) result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;\\r\\n            if (x & 0x10 > 0) result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\\r\\n            if (x & 0x8 > 0) result = (result * 0x100000000000000058B90BFBE8E7BCD6D) >> 128;\\r\\n            if (x & 0x4 > 0) result = (result * 0x10000000000000002C5C85FDF473DE6B2) >> 128;\\r\\n            if (x & 0x2 > 0) result = (result * 0x1000000000000000162E42FEFA39EF358) >> 128;\\r\\n            if (x & 0x1 > 0) result = (result * 0x10000000000000000B17217F7D1CF79AB) >> 128;\\r\\n\\r\\n            result >>= uint256(int256(63 - (x >> 64)));\\r\\n            require(result <= uint256(int256(MAX_64x64)));\\r\\n\\r\\n            return int128(int256(result));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate natural exponent of x.  Revert on overflow.\\r\\n     *\\r\\n     * @param x signed 64.64-bit fixed point number\\r\\n     * @return signed 64.64-bit fixed point number\\r\\n     */\\r\\n    function exp(int128 x) internal pure returns (int128) {\\r\\n        unchecked {\\r\\n            require(x < 0x400000000000000000); // Overflow\\r\\n\\r\\n            if (x < -0x400000000000000000) return 0; // Underflow\\r\\n\\r\\n            return exp_2(int128((int256(x) * 0x171547652B82FE1777D0FFDA0D23A7D12) >> 128));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\r\\n     * integer numbers.  Revert on overflow or when y is zero.\\r\\n     *\\r\\n     * @param x unsigned 256-bit integer number\\r\\n     * @param y unsigned 256-bit integer number\\r\\n     * @return unsigned 64.64-bit fixed point number\\r\\n     */\\r\\n    function divuu(uint256 x, uint256 y) private pure returns (uint128) {\\r\\n        unchecked {\\r\\n            require(y != 0);\\r\\n\\r\\n            uint256 result;\\r\\n\\r\\n            if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) result = (x << 64) / y;\\r\\n            else {\\r\\n                uint256 msb = 192;\\r\\n                uint256 xc = x >> 192;\\r\\n                if (xc >= 0x100000000) {\\r\\n                    xc >>= 32;\\r\\n                    msb += 32;\\r\\n                }\\r\\n                if (xc >= 0x10000) {\\r\\n                    xc >>= 16;\\r\\n                    msb += 16;\\r\\n                }\\r\\n                if (xc >= 0x100) {\\r\\n                    xc >>= 8;\\r\\n                    msb += 8;\\r\\n                }\\r\\n                if (xc >= 0x10) {\\r\\n                    xc >>= 4;\\r\\n                    msb += 4;\\r\\n                }\\r\\n                if (xc >= 0x4) {\\r\\n                    xc >>= 2;\\r\\n                    msb += 2;\\r\\n                }\\r\\n                if (xc >= 0x2) msb += 1; // No need to shift xc anymore\\r\\n\\r\\n                result = (x << (255 - msb)) / (((y - 1) >> (msb - 191)) + 1);\\r\\n                require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n\\r\\n                uint256 hi = result * (y >> 128);\\r\\n                uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n\\r\\n                uint256 xh = x >> 192;\\r\\n                uint256 xl = x << 64;\\r\\n\\r\\n                if (xl < lo) xh -= 1;\\r\\n                xl -= lo; // We rely on overflow behavior here\\r\\n                lo = hi << 128;\\r\\n                if (xl < lo) xh -= 1;\\r\\n                xl -= lo; // We rely on overflow behavior here\\r\\n\\r\\n                assert(xh == hi >> 128);\\r\\n\\r\\n                result += xl / y;\\r\\n            }\\r\\n\\r\\n            require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n            return uint128(result);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\r\\n     * number.\\r\\n     *\\r\\n     * @param x unsigned 256-bit integer number\\r\\n     * @return unsigned 128-bit integer number\\r\\n     */\\r\\n    function sqrtu(uint256 x) private pure returns (uint128) {\\r\\n        unchecked {\\r\\n            if (x == 0) return 0;\\r\\n            else {\\r\\n                uint256 xx = x;\\r\\n                uint256 r = 1;\\r\\n                if (xx >= 0x100000000000000000000000000000000) {\\r\\n                    xx >>= 128;\\r\\n                    r <<= 64;\\r\\n                }\\r\\n                if (xx >= 0x10000000000000000) {\\r\\n                    xx >>= 64;\\r\\n                    r <<= 32;\\r\\n                }\\r\\n                if (xx >= 0x100000000) {\\r\\n                    xx >>= 32;\\r\\n                    r <<= 16;\\r\\n                }\\r\\n                if (xx >= 0x10000) {\\r\\n                    xx >>= 16;\\r\\n                    r <<= 8;\\r\\n                }\\r\\n                if (xx >= 0x100) {\\r\\n                    xx >>= 8;\\r\\n                    r <<= 4;\\r\\n                }\\r\\n                if (xx >= 0x10) {\\r\\n                    xx >>= 4;\\r\\n                    r <<= 2;\\r\\n                }\\r\\n                if (xx >= 0x8) {\\r\\n                    r <<= 1;\\r\\n                }\\r\\n                r = (r + x / r) >> 1;\\r\\n                r = (r + x / r) >> 1;\\r\\n                r = (r + x / r) >> 1;\\r\\n                r = (r + x / r) >> 1;\\r\\n                r = (r + x / r) >> 1;\\r\\n                r = (r + x / r) >> 1;\\r\\n                r = (r + x / r) >> 1; // Seven iterations should be enough\\r\\n                uint256 r1 = x / r;\\r\\n                return uint128(r < r1 ? r : r1);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/CumulativeNormalDistribution.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./ABDKMath64x64.sol\\\";\\r\\n\\r\\n/// @title   Cumulative Normal Distribution Math Library\\r\\n/// @author  Primitive\\r\\nlibrary CumulativeNormalDistribution {\\r\\n    using ABDKMath64x64 for int128;\\r\\n    using ABDKMath64x64 for uint256;\\r\\n\\r\\n    /// @notice Thrown on passing an arg that is out of the input range for these math functions\\r\\n    error InverseOutOfBounds(int128 value);\\r\\n\\r\\n    int128 public constant ONE_INT = 0x10000000000000000;\\r\\n    int128 public constant TWO_INT = 0x20000000000000000;\\r\\n    int128 public constant CDF0 = 0x53dd02a4f5ee2e46;\\r\\n    int128 public constant CDF1 = 0x413c831bb169f874;\\r\\n    int128 public constant CDF2 = -0x48d4c730f051a5fe;\\r\\n    int128 public constant CDF3 = 0x16a09e667f3bcc908;\\r\\n    int128 public constant CDF4 = -0x17401c57014c38f14;\\r\\n    int128 public constant CDF5 = 0x10fb844255a12d72e;\\r\\n\\r\\n    /// @notice Uses Abramowitz and Stegun approximation:\\r\\n    ///         https://en.wikipedia.org/wiki/Abramowitz_and_Stegun\\r\\n    /// @dev    Maximum error: 3.15x10-3\\r\\n    /// @return Standard Normal Cumulative Distribution Function of `x`\\r\\n    function getCDF(int128 x) internal pure returns (int128) {\\r\\n        int128 z = x.div(CDF3);\\r\\n        int128 t = ONE_INT.div(ONE_INT.add(CDF0.mul(z.abs())));\\r\\n        int128 erf = getErrorFunction(z, t);\\r\\n        if (z < 0) {\\r\\n            erf = erf.neg();\\r\\n        }\\r\\n        int128 result = (HALF_INT).mul(ONE_INT.add(erf));\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /// @notice Uses Abramowitz and Stegun approximation:\\r\\n    ///         https://en.wikipedia.org/wiki/Error_function\\r\\n    /// @dev    Maximum error: 1.5\u00d710\u22127\\r\\n    /// @return Error Function for approximating the Standard Normal CDF\\r\\n    function getErrorFunction(int128 z, int128 t) internal pure returns (int128) {\\r\\n        int128 step1 = t.mul(CDF3.add(t.mul(CDF4.add(t.mul(CDF5)))));\\r\\n        int128 step2 = CDF1.add(t.mul(CDF2.add(step1)));\\r\\n        int128 result = ONE_INT.sub(t.mul(step2.mul((z.mul(z).neg()).exp())));\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    int128 public constant HALF_INT = 0x8000000000000000;\\r\\n    int128 public constant INVERSE0 = 0x26A8F3C1F21B336E;\\r\\n    int128 public constant INVERSE1 = -0x87C57E5DA70D3C90;\\r\\n    int128 public constant INVERSE2 = 0x15D71F5721242C787;\\r\\n    int128 public constant INVERSE3 = 0x21D0A04B0E9B94F1;\\r\\n    int128 public constant INVERSE4 = -0xC2BF5D74C724E53F;\\r\\n\\r\\n    int128 public constant LOW_TAIL = 0x666666666666666; // 0.025\\r\\n    int128 public constant HIGH_TAIL = 0xF999999999999999; // 0.975\\r\\n\\r\\n    /// @notice  Returns the inverse CDF, or quantile function of `p`.\\r\\n    /// @dev     Source: https://arxiv.org/pdf/1002.0567.pdf\\r\\n    ///          Maximum error of central region is 1.16x10\u22124\\r\\n    /// @return  fcentral(p) = q * (a2 + (a1r + a0) / (r^2 + b1r +b0))\\r\\n    function getInverseCDF(int128 p) internal pure returns (int128) {\\r\\n        if (p >= ONE_INT || p <= 0) revert InverseOutOfBounds(p);\\r\\n        // Short circuit for the central region, central region inclusive of tails\\r\\n        if (p <= HIGH_TAIL && p >= LOW_TAIL) {\\r\\n            return central(p);\\r\\n        } else if (p < LOW_TAIL) {\\r\\n            return tail(p);\\r\\n        } else {\\r\\n            int128 negativeTail = -tail(ONE_INT.sub(p));\\r\\n            return negativeTail;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev    Maximum error: 1.16x10\u22124\\r\\n    /// @return Inverse CDF around the central area of 0.025 <= p <= 0.975\\r\\n    function central(int128 p) internal pure returns (int128) {\\r\\n        int128 q = p.sub(HALF_INT);\\r\\n        int128 r = q.mul(q);\\r\\n        int128 result = q.mul(\\r\\n            INVERSE2.add((INVERSE1.mul(r).add(INVERSE0)).div((r.mul(r).add(INVERSE4.mul(r)).add(INVERSE3))))\\r\\n        );\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    int128 public constant C0 = 0x10E56D75CE8BCE9FAE;\\r\\n    int128 public constant C1 = -0x2CB2447D36D513DAE;\\r\\n    int128 public constant C2 = -0x8BB4226952BD69EDF;\\r\\n    int128 public constant C3 = -0x1000BF627FA188411;\\r\\n    int128 public constant C0_D = 0x10AEAC93F55267A9A5;\\r\\n    int128 public constant C1_D = 0x41ED34A2561490236;\\r\\n    int128 public constant C2_D = 0x7A1E70F720ECA43;\\r\\n    int128 public constant D0 = 0x72C7D592D021FB1DB;\\r\\n    int128 public constant D1 = 0x8C27B4617F5F800EA;\\r\\n\\r\\n    /// @dev    Maximum error: 2.458x10-5\\r\\n    /// @return Inverse CDF of the tail, defined for p < 0.0465, used with p < 0.025\\r\\n    function tail(int128 p) internal pure returns (int128) {\\r\\n        int128 r = ONE_INT.div(p.mul(p)).ln().sqrt();\\r\\n        int128 step0 = C3.mul(r).add(C2_D);\\r\\n        int128 numerator = C1_D.mul(r).add(C0_D);\\r\\n        int128 denominator = r.mul(r).add(D1.mul(r)).add(D0);\\r\\n        int128 result = step0.add(numerator.div(denominator));\\r\\n        return result;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/engine/IPrimitiveEngineActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/// @title  Action functions for the Primitive Engine contract\\r\\n/// @author Primitive\\r\\ninterface IPrimitiveEngineActions {\\r\\n    // ===== Pool Updates =====\\r\\n\\r\\n    /// @notice             Updates the time until expiry of the pool by setting its last timestamp value\\r\\n    /// @param  poolId      Keccak256 hash of engine address, strike, sigma, maturity, and gamma\\r\\n    /// @return lastTimestamp Timestamp loaded into the state of the pool's Calibration.lastTimestamp\\r\\n    function updateLastTimestamp(bytes32 poolId) external returns (uint32 lastTimestamp);\\r\\n\\r\\n    /// @notice             Initializes a curve with parameters in the `calibrations` storage mapping in the Engine\\r\\n    /// @param  strike      Marginal price of the pool's risky token at maturity, with the same decimals as the stable token, valid [0, 2^128-1]\\r\\n    /// @param  sigma       AKA Implied Volatility in basis points, determines the price impact of swaps, valid for (1, 10_000_000)\\r\\n    /// @param  maturity    Timestamp which starts the BUFFER countdown until swaps will cease, in seconds, valid for (block.timestamp, 2^32-1]\\r\\n    /// @param  gamma       Multiplied against swap in amounts to apply fee, equal to 1 - fee % but units are in basis points, valid for (9_000, 10_000)\\r\\n    /// @param  riskyPerLp  Risky reserve per liq. with risky decimals, = 1 - N(d1), d1 = (ln(S/K)+(r*\u03c3^2/2))/\u03c3\u221a\u03c4, valid for [0, 1e^(risky token decimals))\\r\\n    /// @param  delLiquidity Amount of liquidity units to allocate to the curve, wei value with 18 decimals of precision\\r\\n    /// @param  data        Arbitrary data that is passed to the createCallback function\\r\\n    /// @return poolId      Keccak256 hash of engine address, strike, sigma, maturity, and gamma\\r\\n    /// @return delRisky    Total amount of risky tokens provided to reserves\\r\\n    /// @return delStable   Total amount of stable tokens provided to reserves\\r\\n    function create(\\r\\n        uint128 strike,\\r\\n        uint32 sigma,\\r\\n        uint32 maturity,\\r\\n        uint32 gamma,\\r\\n        uint256 riskyPerLp,\\r\\n        uint256 delLiquidity,\\r\\n        bytes calldata data\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            bytes32 poolId,\\r\\n            uint256 delRisky,\\r\\n            uint256 delStable\\r\\n        );\\r\\n\\r\\n    // ===== Margin ====\\r\\n\\r\\n    /// @notice             Adds risky and/or stable tokens to a `recipient`'s internal balance account\\r\\n    /// @param  recipient   Recipient margin account of the deposited tokens\\r\\n    /// @param  delRisky    Amount of risky tokens to deposit\\r\\n    /// @param  delStable   Amount of stable tokens to deposit\\r\\n    /// @param  data        Arbitrary data that is passed to the depositCallback function\\r\\n    function deposit(\\r\\n        address recipient,\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    /// @notice             Removes risky and/or stable tokens from a `msg.sender`'s internal balance account\\r\\n    /// @param  recipient   Address that tokens are transferred to\\r\\n    /// @param  delRisky    Amount of risky tokens to withdraw\\r\\n    /// @param  delStable   Amount of stable tokens to withdraw\\r\\n    function withdraw(\\r\\n        address recipient,\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable\\r\\n    ) external;\\r\\n\\r\\n    // ===== Liquidity =====\\r\\n\\r\\n    /// @notice             Allocates risky and stable tokens to a specific curve with `poolId`\\r\\n    /// @param  poolId      Keccak256 hash of engine address, strike, sigma, maturity, and gamma\\r\\n    /// @param  recipient   Address to give the allocated liquidity to\\r\\n    /// @param  delRisky    Amount of risky tokens to add\\r\\n    /// @param  delStable   Amount of stable tokens to add\\r\\n    /// @param  fromMargin  Whether the `msg.sender` pays with their margin balance, or must send tokens\\r\\n    /// @param  data        Arbitrary data that is passed to the allocateCallback function\\r\\n    /// @return delLiquidity Amount of liquidity given to `recipient`\\r\\n    function allocate(\\r\\n        bytes32 poolId,\\r\\n        address recipient,\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable,\\r\\n        bool fromMargin,\\r\\n        bytes calldata data\\r\\n    ) external returns (uint256 delLiquidity);\\r\\n\\r\\n    /// @notice               Unallocates risky and stable tokens from a specific curve with `poolId`\\r\\n    /// @param  poolId        Keccak256 hash of engine address, strike, sigma, maturity, and gamma\\r\\n    /// @param  delLiquidity  Amount of liquidity to remove\\r\\n    /// @return delRisky      Amount of risky tokens received from removed liquidity\\r\\n    /// @return delStable     Amount of stable tokens received from removed liquidity\\r\\n    function remove(bytes32 poolId, uint256 delLiquidity) external returns (uint256 delRisky, uint256 delStable);\\r\\n\\r\\n    // ===== Swaps =====\\r\\n\\r\\n    /// @notice             Swaps between `risky` and `stable` tokens\\r\\n    /// @param  recipient   Address that receives output token `deltaOut` amount\\r\\n    /// @param  poolId      Keccak256 hash of engine address, strike, sigma, maturity, and gamma\\r\\n    /// @param  riskyForStable If true, swap risky to stable, else swap stable to risky\\r\\n    /// @param  deltaIn     Amount of tokens to swap in\\r\\n    /// @param  deltaOut    Amount of tokens to swap out\\r\\n    /// @param  fromMargin  Whether the `msg.sender` uses their margin balance, or must send tokens\\r\\n    /// @param  toMargin    Whether the `deltaOut` amount is transferred or deposited into margin\\r\\n    /// @param  data        Arbitrary data that is passed to the swapCallback function\\r\\n    function swap(\\r\\n        address recipient,\\r\\n        bytes32 poolId,\\r\\n        bool riskyForStable,\\r\\n        uint256 deltaIn,\\r\\n        uint256 deltaOut,\\r\\n        bool fromMargin,\\r\\n        bool toMargin,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/engine/IPrimitiveEngineEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/// @title  Events of the Primitive Engine contract\\r\\n/// @author Primitive\\r\\ninterface IPrimitiveEngineEvents {\\r\\n    /// @notice             Creates a pool with liquidity\\r\\n    /// @dev                Keccak256 hash of the engine address, strike, sigma, maturity, and gamma\\r\\n    /// @param  from        Calling `msg.sender` of the create function\\r\\n    /// @param  strike      Marginal price of the pool's risky token at maturity, with the same decimals as the stable token, valid [0, 2^128-1]\\r\\n    /// @param  sigma       AKA Implied Volatility in basis points, determines the price impact of swaps, valid for (1, 10_000_000)\\r\\n    /// @param  maturity    Timestamp which starts the BUFFER countdown until swaps will cease, in seconds, valid for (block.timestamp, 2^32-1]\\r\\n    /// @param  gamma       Multiplied against swap in amounts to apply fee, equal to 1 - fee % but units are in basis points, valid for (9000, 10_000)\\r\\n    /// @param  delRisky    Amount of risky tokens deposited\\r\\n    /// @param  delStable   Amount of stable tokens deposited\\r\\n    /// @param  delLiquidity Amount of liquidity granted to `recipient`\\r\\n    event Create(\\r\\n        address indexed from,\\r\\n        uint128 strike,\\r\\n        uint32 sigma,\\r\\n        uint32 indexed maturity,\\r\\n        uint32 indexed gamma,\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable,\\r\\n        uint256 delLiquidity\\r\\n    );\\r\\n\\r\\n    /// @notice             Updates the time until expiry of the pool with `poolId`\\r\\n    /// @param  poolId      Keccak256 hash of the engine address, strike, sigma, maturity, and gamma\\r\\n    event UpdateLastTimestamp(bytes32 indexed poolId);\\r\\n\\r\\n    // ===== Margin ====\\r\\n\\r\\n    /// @notice             Added stable and/or risky tokens to a margin account\\r\\n    /// @param  from        Method caller `msg.sender`\\r\\n    /// @param  recipient   Margin account recieving deposits\\r\\n    /// @param  delRisky    Amount of risky tokens deposited\\r\\n    /// @param  delStable   Amount of stable tokens deposited\\r\\n    event Deposit(address indexed from, address indexed recipient, uint256 delRisky, uint256 delStable);\\r\\n\\r\\n    /// @notice             Removes stable and/or risky from a margin account\\r\\n    /// @param  from        Method caller `msg.sender`\\r\\n    /// @param  recipient   Address that tokens are sent to\\r\\n    /// @param  delRisky    Amount of risky tokens withdrawn\\r\\n    /// @param  delStable   Amount of stable tokens withdrawn\\r\\n    event Withdraw(address indexed from, address indexed recipient, uint256 delRisky, uint256 delStable);\\r\\n\\r\\n    // ===== Liquidity =====\\r\\n\\r\\n    /// @notice             Adds liquidity of risky and stable tokens to a specified `poolId`\\r\\n    /// @param  from        Method caller `msg.sender`\\r\\n    /// @param  recipient   Address that receives liquidity\\r\\n    /// @param  poolId      Keccak256 hash of the engine address, strike, sigma, maturity, and gamma\\r\\n    /// @param  delRisky    Amount of risky tokens deposited\\r\\n    /// @param  delStable   Amount of stable tokens deposited\\r\\n    /// @param  delLiquidity Amount of liquidity granted to `recipient`\\r\\n    event Allocate(\\r\\n        address indexed from,\\r\\n        address indexed recipient,\\r\\n        bytes32 indexed poolId,\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable,\\r\\n        uint256 delLiquidity\\r\\n    );\\r\\n\\r\\n    /// @notice             Adds liquidity of risky and stable tokens to a specified `poolId`\\r\\n    /// @param  from        Method caller `msg.sender`\\r\\n    /// @param  poolId      Keccak256 hash of the engine address, strike, sigma, maturity, and gamma\\r\\n    /// @param  delRisky    Amount of risky tokens deposited\\r\\n    /// @param  delStable   Amount of stable tokens deposited\\r\\n    /// @param  delLiquidity Amount of liquidity decreased from `from`\\r\\n    event Remove(\\r\\n        address indexed from,\\r\\n        bytes32 indexed poolId,\\r\\n        uint256 delRisky,\\r\\n        uint256 delStable,\\r\\n        uint256 delLiquidity\\r\\n    );\\r\\n\\r\\n    // ===== Swaps =====\\r\\n\\r\\n    /// @notice             Swaps between `risky` and `stable` assets\\r\\n    /// @param  from        Method caller `msg.sender`\\r\\n    /// @param  recipient   Address that receives `deltaOut` amount of tokens\\r\\n    /// @param  poolId      Keccak256 hash of the engine address, strike, sigma, maturity, and gamma\\r\\n    /// @param  riskyForStable  If true, swaps risky to stable, else swaps stable to risky\\r\\n    /// @param  deltaIn     Amount of tokens added to reserves\\r\\n    /// @param  deltaOut    Amount of tokens removed from reserves\\r\\n    event Swap(\\r\\n        address indexed from,\\r\\n        address indexed recipient,\\r\\n        bytes32 indexed poolId,\\r\\n        bool riskyForStable,\\r\\n        uint256 deltaIn,\\r\\n        uint256 deltaOut\\r\\n    );\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/engine/IPrimitiveEngineView.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/// @title  View functions of the Primitive Engine contract\\r\\n/// @author Primitive\\r\\ninterface IPrimitiveEngineView {\\r\\n    // ===== View =====\\r\\n\\r\\n    /// @notice             Fetches the current invariant, notation is usually `k`, based on risky and stable token reserves of pool with `poolId`\\r\\n    /// @param  poolId      Keccak256 hash of the engine address, strike, sigma, maturity, and gamma\\r\\n    /// @return invariant   Signed fixed point 64.64 number, invariant of `poolId`\\r\\n    function invariantOf(bytes32 poolId) external view returns (int128 invariant);\\r\\n\\r\\n    // ===== Constants =====\\r\\n\\r\\n    /// @return Precision units to scale to when doing token related calculations\\r\\n    function PRECISION() external view returns (uint256);\\r\\n\\r\\n    /// @return Amount of seconds after pool expiry which allows swaps, no swaps after buffer\\r\\n    function BUFFER() external view returns (uint256);\\r\\n\\r\\n    // ===== Immutables =====\\r\\n\\r\\n    /// @return Amount of liquidity burned on `create()` calls\\r\\n    function MIN_LIQUIDITY() external view returns (uint256);\\r\\n\\r\\n    //// @return Factory address which deployed this engine contract\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    //// @return Risky token address, a more accurate name is the underlying token\\r\\n    function risky() external view returns (address);\\r\\n\\r\\n    /// @return Stable token address, a more accurate name is the quote token\\r\\n    function stable() external view returns (address);\\r\\n\\r\\n    /// @return Multiplier to scale amounts to/from, equal to 10^(18 - riskyDecimals)\\r\\n    function scaleFactorRisky() external view returns (uint256);\\r\\n\\r\\n    /// @return Multiplier to scale amounts to/from, equal to 10^(18 - stableDecimals)\\r\\n    function scaleFactorStable() external view returns (uint256);\\r\\n\\r\\n    // ===== Pool State =====\\r\\n\\r\\n    /// @notice                      Fetches the global reserve state for a pool with `poolId`\\r\\n    /// @param  poolId               Keccak256 hash of the engine address, strike, sigma, maturity, and gamma\\r\\n    /// @return reserveRisky         Risky token balance in the reserve\\r\\n    /// @return reserveStable        Stable token balance in the reserve\\r\\n    /// @return liquidity            Total supply of liquidity for the curve\\r\\n    /// @return blockTimestamp       Timestamp when the cumulative reserve values were last updated\\r\\n    /// @return cumulativeRisky      Cumulative sum of risky token reserves of the previous update\\r\\n    /// @return cumulativeStable     Cumulative sum of stable token reserves of the previous update\\r\\n    /// @return cumulativeLiquidity  Cumulative sum of total supply of liquidity of the previous update\\r\\n    function reserves(bytes32 poolId)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint128 reserveRisky,\\r\\n            uint128 reserveStable,\\r\\n            uint128 liquidity,\\r\\n            uint32 blockTimestamp,\\r\\n            uint256 cumulativeRisky,\\r\\n            uint256 cumulativeStable,\\r\\n            uint256 cumulativeLiquidity\\r\\n        );\\r\\n\\r\\n    /// @notice                 Fetches `Calibration` pool parameters\\r\\n    /// @param  poolId          Keccak256 hash of the engine address, strike, sigma, maturity, and gamma\\r\\n    /// @return strike          Marginal price of the pool's risky token at maturity, with the same decimals as the stable token, valid [0, 2^128-1]\\r\\n    /// @return sigma           AKA Implied Volatility in basis points, determines the price impact of swaps, valid for (1, 10_000_000)\\r\\n    /// @return maturity        Timestamp which starts the BUFFER countdown until swaps will cease, in seconds, valid for (block.timestamp, 2^32-1]\\r\\n    /// @return lastTimestamp   Last timestamp used to calculate time until expiry, aka \\\"tau\\\"\\r\\n    /// @return gamma           Multiplied against swap in amounts to apply fee, equal to 1 - fee % but units are in basis points, valid for (9_000, 10_000)\\r\\n    function calibrations(bytes32 poolId)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint128 strike,\\r\\n            uint32 sigma,\\r\\n            uint32 maturity,\\r\\n            uint32 lastTimestamp,\\r\\n            uint32 gamma\\r\\n        );\\r\\n\\r\\n    /// @notice             Fetches position liquidity an account address and poolId\\r\\n    /// @param  poolId      Keccak256 hash of the engine address, strike, sigma, maturity, and gamma\\r\\n    /// @return liquidity   Liquidity owned by `account` in `poolId`\\r\\n    function liquidity(address account, bytes32 poolId) external view returns (uint256 liquidity);\\r\\n\\r\\n    /// @notice                 Fetches the margin balances of `account`\\r\\n    /// @param  account         Margin account to fetch\\r\\n    /// @return balanceRisky    Balance of the risky token\\r\\n    /// @return balanceStable   Balance of the stable token\\r\\n    function margins(address account) external view returns (uint128 balanceRisky, uint128 balanceStable);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/engine/IPrimitiveEngineErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity >=0.8.4;\\r\\n\\r\\n/// @title  Errors for the Primitive Engine contract\\r\\n/// @author Primitive\\r\\n/// @notice Custom errors are encoded with their selector and arguments\\r\\n/// @dev    Peripheral smart contracts should try catch and check if data matches another custom error\\r\\ninterface IPrimitiveEngineErrors {\\r\\n    /// @notice Thrown on attempted re-entrancy on a function with a re-entrancy guard\\r\\n    error LockedError();\\r\\n\\r\\n    /// @notice Thrown when the balanceOf function is not successful and does not return data\\r\\n    error BalanceError();\\r\\n\\r\\n    /// @notice Thrown in create when a pool with computed poolId already exists\\r\\n    error PoolDuplicateError();\\r\\n\\r\\n    /// @notice Thrown when calling an expired pool, where block.timestamp > maturity, + BUFFER if swap\\r\\n    error PoolExpiredError();\\r\\n\\r\\n    /// @notice Thrown when liquidity is lower than or equal to the minimum amount of liquidity\\r\\n    error MinLiquidityError(uint256 value);\\r\\n\\r\\n    /// @notice Thrown when riskyPerLp is outside the range of acceptable values, 0 < riskyPerLp <= 1eRiskyDecimals\\r\\n    error RiskyPerLpError(uint256 value);\\r\\n\\r\\n    /// @notice Thrown when sigma is outside the range of acceptable values, 1 <= sigma <= 1e7 with 4 precision\\r\\n    error SigmaError(uint256 value);\\r\\n\\r\\n    /// @notice Thrown when strike is not valid, i.e. equal to 0 or greater than 2^128\\r\\n    error StrikeError(uint256 value);\\r\\n\\r\\n    /// @notice Thrown when gamma, equal to 1 - fee %, is outside its bounds: 9_000 <= gamma <= 10_000; 1_000 = 10% fee\\r\\n    error GammaError(uint256 value);\\r\\n\\r\\n    /// @notice Thrown when the parameters of a new pool are invalid, causing initial reserves to be 0\\r\\n    error CalibrationError(uint256 delRisky, uint256 delStable);\\r\\n\\r\\n    /// @notice         Thrown when the expected risky balance is less than the actual balance\\r\\n    /// @param expected Expected risky balance\\r\\n    /// @param actual   Actual risky balance\\r\\n    error RiskyBalanceError(uint256 expected, uint256 actual);\\r\\n\\r\\n    /// @notice         Thrown when the expected stable balance is less than the actual balance\\r\\n    /// @param expected Expected stable balance\\r\\n    /// @param actual   Actual stable balance\\r\\n    error StableBalanceError(uint256 expected, uint256 actual);\\r\\n\\r\\n    /// @notice Thrown when the pool with poolId has not been created\\r\\n    error UninitializedError();\\r\\n\\r\\n    /// @notice Thrown when the risky or stable amount is 0\\r\\n    error ZeroDeltasError();\\r\\n\\r\\n    /// @notice Thrown when the liquidity parameter is 0\\r\\n    error ZeroLiquidityError();\\r\\n\\r\\n    /// @notice Thrown when the deltaIn parameter is 0\\r\\n    error DeltaInError();\\r\\n\\r\\n    /// @notice Thrown when the deltaOut parameter is 0\\r\\n    error DeltaOutError();\\r\\n\\r\\n    /// @notice                 Thrown when the invariant check fails\\r\\n    /// @dev                    Most important check as it verifies the validity of a desired swap\\r\\n    /// @param  invariant       Pre-swap invariant updated with new tau\\r\\n    /// @param  nextInvariant   Post-swap invariant after the swap amounts are applied to reserves\\r\\n    error InvariantError(int128 invariant, int128 nextInvariant);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BalanceError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"delRisky\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delStable\",\"type\":\"uint256\"}],\"name\":\"CalibrationError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeltaInError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeltaOutError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"GammaError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int128\",\"name\":\"invariant\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"nextInvariant\",\"type\":\"int128\"}],\"name\":\"InvariantError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int128\",\"name\":\"value\",\"type\":\"int128\"}],\"name\":\"InverseOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LockedError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"MinLiquidityError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolDuplicateError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolExpiredError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"RiskyBalanceError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RiskyPerLpError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"SigmaError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"StableBalanceError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"StrikeError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UninitializedError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroDeltasError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroLiquidityError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delRisky\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delStable\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delLiquidity\",\"type\":\"uint256\"}],\"name\":\"Allocate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"strike\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"sigma\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"maturity\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"gamma\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delRisky\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delStable\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delLiquidity\",\"type\":\"uint256\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delRisky\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delStable\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delRisky\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delStable\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delLiquidity\",\"type\":\"uint256\"}],\"name\":\"Remove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"riskyForStable\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deltaIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deltaOut\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"}],\"name\":\"UpdateLastTimestamp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delRisky\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delStable\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BUFFER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_LIQUIDITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"delRisky\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delStable\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fromMargin\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"allocate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"delLiquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"calibrations\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"strike\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"sigma\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maturity\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lastTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"gamma\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"strike\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"sigma\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maturity\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"gamma\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"riskyPerLp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"delRisky\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delStable\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"delRisky\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delStable\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"}],\"name\":\"invariantOf\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"invariant\",\"type\":\"int128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"liquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"margins\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"balanceRisky\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"balanceStable\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"delLiquidity\",\"type\":\"uint256\"}],\"name\":\"remove\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"delRisky\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delStable\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"reserves\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"reserveRisky\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"reserveStable\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"blockTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeRisky\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeStable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cumulativeLiquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"risky\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scaleFactorRisky\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scaleFactorStable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stable\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"riskyForStable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deltaIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deltaOut\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"fromMargin\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"toMargin\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"}],\"name\":\"updateLastTimestamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"lastTimestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"delRisky\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delStable\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PrimitiveEngine", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}