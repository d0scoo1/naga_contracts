{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"LiquidFactory.sol\":{\"content\":\"// SPDX-License-Identifier: WISE\\n\\npragma solidity =0.8.12;\\n\\nimport \\\"./LiquidTransfer.sol\\\";\\n\\ninterface ILiquidLocker {\\n\\n    function initialize(\\n        uint256[] calldata _tokenId,\\n        address _tokenAddress,\\n        address _tokenOwner,\\n        uint256 _floorAsked,\\n        uint256 _totalAsked,\\n        uint256 _paymentTime,\\n        uint256 _paymentRate\\n    )\\n        external;\\n\\n    function makeContribution(\\n        uint256 _tokenAmount,\\n        address _tokenHolder\\n    )\\n        external\\n        returns (uint256, uint256);\\n\\n    function donateFunds(\\n        uint256 _donationAmount\\n    )\\n        external;\\n\\n    function payBackFunds(\\n        uint256 _paymentAmount,\\n        address _paymentAddress\\n    )\\n        external;\\n\\n    function PAYMENT_TOKEN()\\n        external\\n        view\\n        returns (address);\\n}\\n\\n/**\\n * @dev LiquidFactory: Factory is responsible for deploying new LiquidLockers.\\n * We use solidity assembly here to directly copy the bytes of a target contract into a new contract\\n * Contributions to lockers and Paybacks to lockers go through this factory as a middle contract\\n *\\n */\\ncontract LiquidFactory is LiquidTransfer {\\n\\n    // Precision factor for interest rate\\n    uint256 public constant RATE_MAX = 100E18;\\n\\n    // Team multisig address\\n    address public masterAddress;\\n\\n    // Contract we use an implementation if there is not a specific locker implementation for a given erc20 token address\\n    address public defaultTarget;\\n\\n    // This contract is used as a target for cloning new lockers. Each token has its own target implementation. These implementations can be updated.\\n    mapping(address =\\u003e address) public implementations;\\n\\n    // Zero address for value reference\\n    address constant ZERO_ADDRESS = address(0);\\n\\n    bytes4 constant TRANSFER_FROM = bytes4(\\n        keccak256(\\n            bytes(\\n                \\\"transferFrom(address,address,uint256)\\\"\\n            )\\n        )\\n    );\\n\\n    event NewLocker(\\n        address indexed lockerAddress,\\n        address indexed ownersAddress,\\n        address indexed tokensAddress\\n    );\\n\\n    event ContributeToLocker(\\n        address indexed lockerAddress,\\n        address indexed backerAddress,\\n        uint256 contributionAmount,\\n        uint256 totalIncreaseAmount\\n    );\\n\\n    event DonateToLocker(\\n        address indexed lockerAddress,\\n        address indexed payersAddress,\\n        uint256 donateAmount\\n    );\\n\\n    event PaybackToLocker(\\n        address indexed lockerAddress,\\n        address indexed payersAddress,\\n        uint256 paybackAmount\\n    );\\n\\n    event ImplementationChange(\\n        address indexed oldImplementation,\\n        address indexed newImplementation,\\n        address indexed tokenKeyAddress\\n    );\\n\\n    modifier onlyMaster() {\\n        require(\\n            msg.sender == masterAddress,\\n            \\\"LiquidFactory: INVALID_MASTER\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Set parameters and precompute some locker addresses.\\n     */\\n    constructor(\\n        address _defaultToken,\\n        address _defaultTarget\\n    ) {\\n        defaultTarget = _defaultTarget;\\n        implementations[_defaultToken] = _defaultTarget;\\n        masterAddress = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Change the default target contract. Only master address can do this.\\n     */\\n    function updateDefaultTarget(\\n        address _newDefaultTarget\\n    )\\n        external\\n        onlyMaster\\n    {\\n        defaultTarget = _newDefaultTarget;\\n    }\\n\\n    /**\\n     * @dev Add or modify the address used for cloning a locker based on a specific erc20 address.\\n     * This can be used to set an implementation for a new token when there is not yet one.\\n     * Only master can use this function.\\n     */\\n    function updateImplementation(\\n        address _tokenAddress,\\n        address _targetAddress\\n    )\\n        external\\n        onlyMaster\\n    {\\n        implementations[_tokenAddress] = _targetAddress;\\n    }\\n\\n    /**\\n     * @dev Transfer master permission\\n     */\\n    function updateMaster(\\n        address _newMaster\\n    )\\n        external\\n        onlyMaster\\n    {\\n        masterAddress = _newMaster;\\n    }\\n\\n    /**\\n     * @dev Destroy Master functionality\\n     */\\n    function revokeMaster()\\n        external\\n        onlyMaster\\n    {\\n        masterAddress = ZERO_ADDRESS;\\n    }\\n\\n    /**\\n     * @dev Clone the implemenation for a token into a new contract.\\n     * Call into initialize for the locker to begin the LiquidNFT loan process.\\n     * Transfer the NFT the user wants use for the loan into the locker.\\n     */\\n    function createLiquidLocker(\\n        uint256[] calldata _tokenId,\\n        address _tokenAddress,\\n        uint256 _floorAsked,\\n        uint256 _deltaAsked,\\n        uint256 _paymentTime,\\n        uint256 _paymentRate,\\n        address _paymentToken\\n    )\\n        external\\n        returns (address lockerAddress)\\n    {\\n        if (_paymentRate \\u003e RATE_MAX) revert(\\\"INVALID_RATE\\\");\\n\\n        lockerAddress = _generateLocker(\\n            _paymentToken\\n        );\\n\\n        ILiquidLocker(lockerAddress).initialize(\\n            _tokenId,\\n            _tokenAddress,\\n            msg.sender,\\n            _floorAsked,\\n            _floorAsked + _deltaAsked,\\n            _paymentTime,\\n            _paymentRate\\n        );\\n\\n        for (uint256 i = 0; i \\u003c _tokenId.length; i++) {\\n            _transferFromNFT(\\n                msg.sender,\\n                lockerAddress,\\n                _tokenAddress,\\n                _tokenId[i]\\n            );\\n        }\\n\\n        emit NewLocker(\\n            lockerAddress,\\n            msg.sender,\\n            _tokenAddress\\n        );\\n    }\\n\\n    /**\\n     * @dev Clone the byte code from one contract into a new contract. Uses solidity assembly.\\n     * This is a lot cheaper in gas than deploying a new contract.\\n     */\\n    function _generateLocker(\\n        address _paymentToken\\n    )\\n        internal\\n        returns (address lockerAddress)\\n    {\\n        bytes20 targetBytes = bytes20(\\n            getImplementation(_paymentToken)\\n        );\\n\\n        assembly {\\n\\n            let clone := mload(0x40)\\n\\n            mstore(\\n                clone,\\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\\n            )\\n\\n            mstore(\\n                add(clone, 0x14),\\n                targetBytes\\n            )\\n\\n            mstore(\\n                add(clone, 0x28),\\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\\n            )\\n\\n            lockerAddress := create(0, clone, 0x37)\\n        }\\n    }\\n\\n    /**\\n     * @dev Call contributeToLocker. Factory acts as a middle man between the user and the locker.\\n     * We do this so that the user only has to approve the factory and not each new locker.\\n     */\\n    function contributeToLocker(\\n        address _lockersAddress,\\n        uint256 _paymentAmount\\n    )\\n        external\\n        returns (\\n            uint256 totalIncrease,\\n            uint256 usersIncrease\\n        )\\n    {\\n        ILiquidLocker locker = ILiquidLocker(\\n            _lockersAddress\\n        );\\n\\n        (totalIncrease, usersIncrease) = locker.makeContribution(\\n            _paymentAmount,\\n            msg.sender\\n        );\\n\\n        _safeTransferFrom(\\n            locker.PAYMENT_TOKEN(),\\n            msg.sender,\\n            _lockersAddress,\\n            usersIncrease\\n        );\\n\\n        emit ContributeToLocker(\\n            _lockersAddress,\\n            msg.sender,\\n            usersIncrease,\\n            totalIncrease\\n        );\\n    }\\n\\n    /**\\n     * @dev Give tokens to a locker. These tokens do not go toward paying off the loan,\\n     * they are instead distributed among the contributors for the loan.\\n     * The result of this is that the value is transferred to the contributors not the owner because it does\\n     * not deduct from the balance the owner owes.\\n     */\\n    function donateToLocker(\\n        address _lockersAddress,\\n        uint256 _donationAmount\\n    )\\n        external\\n    {\\n        ILiquidLocker locker = ILiquidLocker(\\n            _lockersAddress\\n        );\\n\\n        locker.donateFunds(\\n            _donationAmount\\n        );\\n\\n        _safeTransferFrom(\\n            locker.PAYMENT_TOKEN(),\\n            msg.sender,\\n            _lockersAddress,\\n            _donationAmount\\n        );\\n\\n        emit DonateToLocker(\\n            _lockersAddress,\\n            msg.sender,\\n            _donationAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev Call paybackToLocker. Factory acts as a middle man between the user and the locker.\\n     * We do this so that the user only has to approve the factory and not each new locker.\\n     */\\n    function paybackToLocker(\\n        address _lockersAddress,\\n        uint256 _paymentAmount\\n    )\\n        external\\n    {\\n        ILiquidLocker locker = ILiquidLocker(\\n            _lockersAddress\\n        );\\n\\n        locker.payBackFunds(\\n            _paymentAmount,\\n            msg.sender\\n        );\\n\\n        _safeTransferFrom(\\n            locker.PAYMENT_TOKEN(),\\n            msg.sender,\\n            _lockersAddress,\\n            _paymentAmount\\n        );\\n\\n        emit PaybackToLocker(\\n            _lockersAddress,\\n            msg.sender,\\n            _paymentAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns the address that the factory will attempt to clone a locker from for a given token.\\n     */\\n    function getImplementation(\\n        address _paymentToken\\n    )\\n        public\\n        view\\n        returns (address implementation)\\n    {\\n        implementation = implementations[_paymentToken] == ZERO_ADDRESS\\n            ? defaultTarget\\n            : implementations[_paymentToken];\\n    }\\n\\n    /**\\n     * @dev Call ERC20 transferFrom and then check the returned bool for success.\\n     */\\n    function _safeTransferFrom(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        (bool success, bytes memory data) = _token.call(\\n            abi.encodeWithSelector(\\n                TRANSFER_FROM,\\n                _from,\\n                _to,\\n                _value\\n            )\\n        );\\n\\n        require(\\n            success \\u0026\\u0026 (\\n                data.length == 0 || abi.decode(\\n                    data, (bool)\\n                )\\n            ),\\n            \\\"LiquidFactory: TRANSFER_FROM_FAILED\\\"\\n        );\\n    }\\n}\\n\"},\"LiquidTransfer.sol\":{\"content\":\"// SPDX-License-Identifier: WISE\\n\\npragma solidity =0.8.12;\\n\\ncontract LiquidTransfer {\\n\\n    // cryptoPunks contract address\\n    address constant PUNKS = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\\n\\n    // local: 0xEb59fE75AC86dF3997A990EDe100b90DDCf9a826;\\n    // ropsten: 0x2f1dC6E3f732E2333A7073bc65335B90f07fE8b0;\\n    // mainnet: 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\\n\\n    // cryptoKitties contract address\\n    address constant KITTIES = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\\n\\n    /* @dev\\n    * Checks if contract is nonstandard, does transfer according to contract implementation\\n    */\\n    function _transferNFT(\\n        address _from,\\n        address _to,\\n        address _tokenAddress,\\n        uint256 _tokenId\\n    )\\n        internal\\n    {\\n        bytes memory data;\\n\\n        if (_tokenAddress == KITTIES) {\\n            data = abi.encodeWithSignature(\\n                \\\"transfer(address,uint256)\\\",\\n                _to,\\n                _tokenId\\n            );\\n        } else if (_tokenAddress == PUNKS) {\\n            data = abi.encodeWithSignature(\\n                \\\"transferPunk(address,uint256)\\\",\\n                _to,\\n                _tokenId\\n            );\\n        } else {\\n            data = abi.encodeWithSignature(\\n                \\\"safeTransferFrom(address,address,uint256)\\\",\\n                _from,\\n                _to,\\n                _tokenId\\n            );\\n        }\\n\\n        (bool success,) = address(_tokenAddress).call(\\n            data\\n        );\\n\\n        require(\\n            success == true,\\n            \\u0027NFT_TRANSFER_FAILED\\u0027\\n        );\\n    }\\n\\n    /* @dev\\n    * Checks if contract is nonstandard, does transferFrom according to contract implementation\\n    */\\n    function _transferFromNFT(\\n        address _from,\\n        address _to,\\n        address _tokenAddress,\\n        uint256 _tokenId\\n    )\\n        internal\\n    {\\n        bytes memory data;\\n\\n        if (_tokenAddress == KITTIES) {\\n            data = abi.encodeWithSignature(\\n                \\\"transferFrom(address,address,uint256)\\\",\\n                _from,\\n                _to,\\n                _tokenId\\n            );\\n        } else if (_tokenAddress == PUNKS) {\\n            bytes memory punkIndexToAddress = abi.encodeWithSignature(\\n                \\\"punkIndexToAddress(uint256)\\\",\\n                _tokenId\\n            );\\n\\n            (bool checkSuccess, bytes memory result) = address(_tokenAddress).staticcall(\\n                punkIndexToAddress\\n            );\\n\\n            (address owner) = abi.decode(\\n                result,\\n                (address)\\n            );\\n\\n            require(\\n                checkSuccess \\u0026\\u0026\\n                owner == msg.sender,\\n                \\u0027INVALID_OWNER\\u0027\\n            );\\n\\n            bytes memory buyData = abi.encodeWithSignature(\\n                \\\"buyPunk(uint256)\\\",\\n                _tokenId\\n            );\\n\\n            (bool buySuccess, bytes memory buyResultData) = address(_tokenAddress).call(\\n                buyData\\n            );\\n\\n            require(\\n                buySuccess,\\n                string(buyResultData)\\n            );\\n\\n            data = abi.encodeWithSignature(\\n                \\\"transferPunk(address,uint256)\\\",\\n                _to,\\n                _tokenId\\n            );\\n\\n        } else {\\n            data = abi.encodeWithSignature(\\n                \\\"safeTransferFrom(address,address,uint256)\\\",\\n                _from,\\n                _to,\\n                _tokenId\\n            );\\n        }\\n\\n        (bool success, bytes memory resultData) = address(_tokenAddress).call(\\n            data\\n        );\\n\\n        require(\\n            success,\\n            string(resultData)\\n        );\\n    }\\n\\n    event ERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes data\\n    );\\n\\n    function onERC721Received(\\n        address _operator,\\n        address _from,\\n        uint256 _tokenId,\\n        bytes calldata _data\\n    )\\n        external\\n        returns (bytes4)\\n    {\\n        emit ERC721Received(\\n            _operator,\\n            _from,\\n            _tokenId,\\n            _data\\n        );\\n\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_defaultToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defaultTarget\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lockerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"backerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contributionAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalIncreaseAmount\",\"type\":\"uint256\"}],\"name\":\"ContributeToLocker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lockerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payersAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"donateAmount\",\"type\":\"uint256\"}],\"name\":\"DonateToLocker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC721Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenKeyAddress\",\"type\":\"address\"}],\"name\":\"ImplementationChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lockerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ownersAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokensAddress\",\"type\":\"address\"}],\"name\":\"NewLocker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lockerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payersAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paybackAmount\",\"type\":\"uint256\"}],\"name\":\"PaybackToLocker\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"RATE_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lockersAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_paymentAmount\",\"type\":\"uint256\"}],\"name\":\"contributeToLocker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalIncrease\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usersIncrease\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenId\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_floorAsked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deltaAsked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_paymentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_paymentRate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_paymentToken\",\"type\":\"address\"}],\"name\":\"createLiquidLocker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"lockerAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultTarget\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lockersAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_donationAmount\",\"type\":\"uint256\"}],\"name\":\"donateToLocker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_paymentToken\",\"type\":\"address\"}],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"implementations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lockersAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_paymentAmount\",\"type\":\"uint256\"}],\"name\":\"paybackToLocker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeMaster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDefaultTarget\",\"type\":\"address\"}],\"name\":\"updateDefaultTarget\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_targetAddress\",\"type\":\"address\"}],\"name\":\"updateImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMaster\",\"type\":\"address\"}],\"name\":\"updateMaster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LiquidFactory", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000066a0f676479cee1d7373f3dc2e2952778bff5bd60000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://26bbeae762b00e41499caf7d3a0061fbcc7a88076b4468912c37d8328a5689d2"}]}