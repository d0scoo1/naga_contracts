{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// Inspired from the Wyvern V3 source code:\r\n// https://github.com/wyvernprotocol/wyvern-v3/blob/1d89d6a91faddf3c3494e6ebdcb07b46fe111fb4/contracts/lib/ArrayUtils.sol\r\n\r\nlibrary BytesUtils {\r\n    function drop(bytes memory array, uint256 start)\r\n        public\r\n        pure\r\n        returns (bytes memory result)\r\n    {\r\n        result = slice(array, start, array.length - start);\r\n    }\r\n\r\n    function slice(\r\n        bytes memory array,\r\n        uint256 start,\r\n        uint256 length\r\n    ) public pure returns (bytes memory result) {\r\n        assembly {\r\n            switch iszero(length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in `result`\r\n                result := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthMod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthMod := and(length, 31)\r\n\r\n                // The multiplication in the next line is necessary because when\r\n                // slicing multiples of 32 bytes (`lengthMod == 0`) the following\r\n                // copy loop was copying the origin's length and then ending in a\r\n                // premature way not copying everything it should.\r\n                let mc := add(\r\n                    add(result, lengthMod),\r\n                    mul(0x20, iszero(lengthMod))\r\n                )\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    // The multiplication below has the same exact purpose as the one above\r\n                    let cc := add(\r\n                        add(\r\n                            add(array, lengthMod),\r\n                            mul(0x20, iszero(lengthMod))\r\n                        ),\r\n                        start\r\n                    )\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(result, length)\r\n\r\n                // Update free-memory pointer, allocating the array padded to 32 bytes\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            // If we want a zero-length slice then simply return a zero-length array\r\n            default {\r\n                result := mload(0x40)\r\n\r\n                mstore(0x40, add(result, 0x20))\r\n            }\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"array\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"}],\"name\":\"drop\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"array\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"slice\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "BytesUtils", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8e74b8d21ceacc1a111795add2e7c8bbd9f2d719200576e394d4af146f53e433"}]}