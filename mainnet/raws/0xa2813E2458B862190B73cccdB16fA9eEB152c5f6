{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/mint/BlockMintAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./BaseMinter.sol\\\";\\n\\ncontract BlockMintAuthorizer is BaseMinter {\\n  address private immutable _minterAddress;\\n  uint256 private immutable _price;\\n\\n  constructor(\\n    address entryPoint,\\n    string memory mintName,\\n    uint256 totalMintLimit,\\n    address minterAddress,\\n    uint256 price,\\n    uint256 startTime,\\n    uint256 endTime\\n  ) BaseMinter(entryPoint, mintName, totalMintLimit, startTime, endTime) {\\n    _minterAddress = minterAddress;\\n    _price = price;\\n  }\\n\\n  function getProofRequired() external pure override returns (bool) {\\n    return false;\\n  }\\n\\n  function getUserMintPrice(address, bytes32[] memory) public view override returns (uint256) {\\n    return _price;\\n  }\\n\\n  function getUserMintLimit(address user, bytes32[] memory) external view override returns (uint256) {\\n    if (user == _minterAddress) {\\n      return _totalMintLimit;\\n    } else {\\n      return 0;\\n    }\\n  }\\n\\n  function getUserMintCount(address user) external view override returns (uint256) {\\n    if (user == _minterAddress) {\\n      return _totalMintCount;\\n    } else {\\n      return 0;\\n    }\\n  }\\n\\n  function authorizeMint(\\n    address sender,\\n    uint256 value,\\n    uint256 number,\\n    bytes32[] memory\\n  ) external override {\\n    _authorizeMint(number);\\n\\n    require(sender == _minterAddress, \\\"Unauthorized minter\\\");\\n    require(value >= _price * number, \\\"Insufficient payment\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/mint/BaseMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\\\";\\n\\nimport \\\"./IRebelsMintAuthorizer.sol\\\";\\nimport \\\"./IRebelsMintInfo.sol\\\";\\n\\nabstract contract BaseMinter is IRebelsMintAuthorizer, IRebelsMintInfo, ERC165Storage {\\n  address private immutable _entryPoint;\\n  string private _mintName;\\n\\n  uint256 internal immutable _totalMintLimit;\\n  uint256 internal _totalMintCount;\\n\\n  uint256 internal immutable _startTime;\\n  uint256 internal immutable _endTime;\\n\\n  constructor(\\n    address entryPoint,\\n    string memory mintName,\\n    uint256 totalMintLimit,\\n    uint256 startTime,\\n    uint256 endTime\\n  ) {\\n    require(startTime < endTime);\\n\\n    _entryPoint = entryPoint;\\n    _mintName = mintName;\\n    _totalMintLimit = totalMintLimit;\\n    _startTime = startTime;\\n    _endTime = endTime;\\n\\n    _registerInterface(type(IRebelsMintAuthorizer).interfaceId);\\n    _registerInterface(type(IRebelsMintInfo).interfaceId);\\n  }\\n\\n  function getMintName() external view override returns (string memory) {\\n    return _mintName;\\n  }\\n\\n  function getMintActive() public view override returns (bool) {\\n    return _startTime <= block.timestamp && block.timestamp < _endTime;\\n  }\\n\\n  function getMintStartTime() external view override returns (uint256) {\\n    return _startTime;\\n  }\\n\\n  function getMintEndTime() external view override returns (uint256) {\\n    return _endTime;\\n  }\\n\\n  function getTotalMintLimit() external view override returns (uint256) {\\n    return _totalMintLimit;\\n  }\\n\\n  function getTotalMintCount() external view override returns (uint256) {\\n    return _totalMintCount;\\n  }\\n\\n  function _authorizeMint(\\n    uint256 number\\n  ) internal {\\n    require(msg.sender == _entryPoint);\\n\\n    require(getMintActive(), \\\"Mint is not active\\\");\\n\\n    uint256 newTotalMintCount = _totalMintCount + number;\\n    require(newTotalMintCount <= _totalMintLimit,\\n            \\\"Trying to mint more than total allowed\\\");\\n    _totalMintCount = newTotalMintCount;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Storage.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC165.sol\\\";\\n\\n/**\\n * @dev Storage based implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165Storage is ERC165 {\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mint/IRebelsMintAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\ninterface IRebelsMintAuthorizer {\\n  function authorizeMint(\\n    address sender,\\n    uint256 value,\\n    uint256 number,\\n    bytes32[] memory senderData\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/mint/IRebelsMintInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\ninterface IRebelsMintInfo {\\n  function getMintName() external view returns (string memory);\\n  function getMintActive() external view returns (bool);\\n  function getMintStartTime() external view returns (uint256);\\n  function getMintEndTime() external view returns (uint256);\\n\\n  function getProofRequired() external view returns (bool);\\n  function getTotalMintLimit() external view returns (uint256);\\n  function getTotalMintCount() external view returns (uint256);\\n\\n  function getUserMintPrice(address user, bytes32[] memory senderData) external view returns (uint256);\\n  function getUserMintLimit(address user, bytes32[] memory senderData) external view returns (uint256);\\n  function getUserMintCount(address user) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"entryPoint\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"mintName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalMintLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"minterAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"name\":\"authorizeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProofRequired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMintCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMintLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserMintCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"name\":\"getUserMintLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"name\":\"getUserMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BlockMintAuthorizer", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000e9fca552b9eb110c2d170962af740725f71f564400000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000343000000000000000000000000b52f51b6e1e5d72dd15bc500f7529d2f8357833e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000062a556b00000000000000000000000000000000000000000000000000000000062a580e000000000000000000000000000000000000000000000000000000000000000124e69676874204c61627320526573657276650000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}