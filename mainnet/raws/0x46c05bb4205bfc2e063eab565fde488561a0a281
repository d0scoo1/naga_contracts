{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity ^0.8.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface ILendingPoolAddressesProvider {\r\n  event MarketIdSet(string newMarketId);\r\n  event LendingPoolUpdated(address indexed newAddress);\r\n  event IncentiveControllerUpdated(address indexed newAddress);\r\n  event IncentiveTokenUpdated(address indexed newAddress);\r\n  event ConfigurationAdminUpdated(address indexed newAddress);\r\n  event EmergencyAdminUpdated(address indexed newAddress);\r\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\r\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\r\n  event PriceOracleUpdated(address indexed newAddress);\r\n  event LendingRateOracleUpdated(address indexed newAddress);\r\n  event ProxyCreated(bytes32 id, address indexed newAddress);\r\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\r\n\r\n  function getMarketId() external view returns (string memory);\r\n\r\n  function setMarketId(string calldata marketId) external payable;\r\n\r\n  function setAddress(bytes32 id, address newAddress) external payable;\r\n\r\n  function setAddressAsProxy(bytes32 id, address impl) external payable;\r\n\r\n  function getAddress(bytes32 id) external view returns (address);\r\n\r\n  function getLendingPool() external view returns (address);\r\n\r\n  function setLendingPoolImpl(address pool) external payable;\r\n\r\n  function getIncentiveController() external view returns (address);\r\n\r\n  function setIncentiveControllerImpl(address incentiveController) external payable;\r\n\r\n  function getIncentiveToken() external view returns (address);\r\n\r\n  function setIncentiveTokenImpl(address incentiveToken) external payable;\r\n\r\n  function getLendingPoolConfigurator() external view returns (address);\r\n\r\n  function setLendingPoolConfiguratorImpl(address configurator) external payable;\r\n\r\n  function getLendingPoolCollateralManager() external view returns (address);\r\n\r\n  function setLendingPoolCollateralManager(address manager) external payable;\r\n\r\n  function getPoolAdmin() external view returns (address);\r\n\r\n  function setPoolAdmin(address admin) external payable;\r\n\r\n  function getEmergencyAdmin() external view returns (address);\r\n\r\n  function setEmergencyAdmin(address admin) external payable;\r\n\r\n  function getPriceOracle() external view returns (address);\r\n\r\n  function setPriceOracle(address priceOracle) external payable;\r\n\r\n  function getLendingRateOracle() external view returns (address);\r\n\r\n  function setLendingRateOracle(address lendingRateOracle) external payable;\r\n}\r\n\r\ninterface ISturdyIncentivesController {\r\n  event RewardsAccrued(address indexed user, uint256 amount);\r\n\r\n  event RewardsClaimed(address indexed user, address indexed to, uint256 amount);\r\n\r\n  event RewardsClaimed(\r\n    address indexed user,\r\n    address indexed to,\r\n    address indexed claimer,\r\n    uint256 amount\r\n  );\r\n\r\n  event ClaimerSet(address indexed user, address indexed claimer);\r\n\r\n  /*\r\n   * @dev Returns the configuration of the distribution for a certain asset\r\n   * @param asset The address of the reference asset of the distribution\r\n   * @return The asset index, the emission per second and the last updated timestamp\r\n   **/\r\n  function getAssetData(address asset)\r\n    external\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    );\r\n\r\n  /**\r\n   * @dev Whitelists an address to claim the rewards on behalf of another address\r\n   * @param user The address of the user\r\n   * @param claimer The address of the claimer\r\n   */\r\n  function setClaimer(address user, address claimer) external payable;\r\n\r\n  /**\r\n   * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\r\n   * @param user The address of the user\r\n   * @return The claimer address\r\n   */\r\n  function getClaimer(address user) external view returns (address);\r\n\r\n  /**\r\n   * @dev Configure assets for a certain rewards emission\r\n   * @param assets The assets to incentivize\r\n   * @param emissionsPerSecond The emission for each asset\r\n   */\r\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\r\n    external\r\n    payable;\r\n\r\n  /**\r\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\r\n   * @param user The address of the user\r\n   * @param userBalance The balance of the user of the asset in the lending pool\r\n   * @param totalSupply The total supply of the asset in the lending pool\r\n   **/\r\n  function handleAction(\r\n    address user,\r\n    uint256 totalSupply,\r\n    uint256 userBalance\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Returns the total of rewards of an user, already accrued + not yet accrued\r\n   * @param user The address of the user\r\n   * @return The rewards\r\n   **/\r\n  function getRewardsBalance(address[] calldata assets, address user)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\r\n   * @param amount Amount of rewards to claim\r\n   * @param to Address that will be receiving the rewards\r\n   * @return Rewards claimed\r\n   **/\r\n  function claimRewards(\r\n    address[] calldata assets,\r\n    uint256 amount,\r\n    address to\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\r\n   * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\r\n   * @param amount Amount of rewards to claim\r\n   * @param user Address to check and claim rewards\r\n   * @param to Address that will be receiving the rewards\r\n   * @return Rewards claimed\r\n   **/\r\n  function claimRewardsOnBehalf(\r\n    address[] calldata assets,\r\n    uint256 amount,\r\n    address user,\r\n    address to\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev returns the unclaimed rewards of the user\r\n   * @param user the address of the user\r\n   * @return the unclaimed user rewards\r\n   */\r\n  function getUserUnclaimedRewards(address user) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev returns the unclaimed rewards of the user\r\n   * @param user the address of the user\r\n   * @param asset The asset to incentivize\r\n   * @return the user index for the asset\r\n   */\r\n  function getUserAssetData(address user, address asset) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev for backward compatibility with previous implementation of the Incentives controller\r\n   */\r\n  function REWARD_TOKEN() external view returns (address);\r\n\r\n  /**\r\n   * @dev for backward compatibility with previous implementation of the Incentives controller\r\n   */\r\n  function PRECISION() external view returns (uint8);\r\n\r\n  /**\r\n   * @dev Gets the distribution end timestamp of the emissions\r\n   */\r\n  function DISTRIBUTION_END() external view returns (uint256);\r\n}\r\n\r\ninterface IUiIncentiveDataProvider {\r\n  struct AggregatedReserveIncentiveData {\r\n    address underlyingAsset;\r\n    IncentiveData aIncentiveData;\r\n    IncentiveData vIncentiveData;\r\n    IncentiveData sIncentiveData;\r\n    RewardData rewardData;\r\n  }\r\n\r\n  struct IncentiveData {\r\n    uint256 emissionPerSecond;\r\n    uint256 incentivesLastUpdateTimestamp;\r\n    uint256 tokenIncentivesIndex;\r\n    uint256 emissionEndTimestamp;\r\n    address tokenAddress;\r\n    address rewardTokenAddress;\r\n    address incentiveControllerAddress;\r\n    uint8 rewardTokenDecimals;\r\n    uint8 precision;\r\n  }\r\n\r\n  struct RewardData {\r\n    // stable reward info\r\n    uint256 emissionPerSecond;\r\n    uint256 incentivesLastUpdateTimestamp;\r\n    uint256 emissionEndTimestamp;\r\n    // variable reward info\r\n    uint256 incentiveRatio;\r\n    uint256 lastAvailableRewards;\r\n    // common reward info\r\n    uint256 tokenIncentivesIndex;\r\n    address tokenAddress;\r\n    address rewardTokenAddress;\r\n    address distributorAddress;\r\n    uint8 rewardTokenDecimals;\r\n  }\r\n\r\n  struct UserReserveIncentiveData {\r\n    address underlyingAsset;\r\n    UserIncentiveData aTokenIncentivesUserData;\r\n    UserIncentiveData vTokenIncentivesUserData;\r\n    UserIncentiveData sTokenIncentivesUserData;\r\n    UserRewardData rewardUserData;\r\n  }\r\n\r\n  struct UserIncentiveData {\r\n    uint256 tokenincentivesUserIndex;\r\n    uint256 userUnclaimedRewards;\r\n    address tokenAddress;\r\n    address rewardTokenAddress;\r\n    address incentiveControllerAddress;\r\n    uint8 rewardTokenDecimals;\r\n  }\r\n\r\n  struct UserRewardData {\r\n    uint256 tokenincentivesUserIndex;\r\n    uint256 userUnclaimedRewards;\r\n    address tokenAddress;\r\n    address rewardTokenAddress;\r\n    address distributorAddress;\r\n    uint8 rewardTokenDecimals;\r\n  }\r\n\r\n  function getReservesIncentivesData(ILendingPoolAddressesProvider provider)\r\n    external\r\n    view\r\n    returns (AggregatedReserveIncentiveData[] memory);\r\n\r\n  function getUserReservesIncentivesData(ILendingPoolAddressesProvider provider, address user)\r\n    external\r\n    view\r\n    returns (UserReserveIncentiveData[] memory);\r\n\r\n  // generic method with full data\r\n  function getFullReservesIncentiveData(ILendingPoolAddressesProvider provider, address user)\r\n    external\r\n    view\r\n    returns (AggregatedReserveIncentiveData[] memory, UserReserveIncentiveData[] memory);\r\n}\r\n\r\nlibrary DataTypes {\r\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\r\n  struct ReserveData {\r\n    //stores the reserve configuration\r\n    ReserveConfigurationMap configuration;\r\n    //the liquidity index. Expressed in ray\r\n    uint128 liquidityIndex;\r\n    //variable borrow index. Expressed in ray\r\n    uint128 variableBorrowIndex;\r\n    //the current supply rate. Expressed in ray\r\n    uint128 currentLiquidityRate;\r\n    //the current variable borrow rate. Expressed in ray\r\n    uint128 currentVariableBorrowRate;\r\n    //the current stable borrow rate. Expressed in ray\r\n    uint128 currentStableBorrowRate;\r\n    uint40 lastUpdateTimestamp;\r\n    //tokens addresses\r\n    address aTokenAddress;\r\n    address stableDebtTokenAddress;\r\n    address variableDebtTokenAddress;\r\n    //address of the interest rate strategy\r\n    address interestRateStrategyAddress;\r\n    //address of the yield contract\r\n    address yieldAddress;\r\n    //the id of the reserve. Represents the position in the list of the active reserves\r\n    uint8 id;\r\n  }\r\n\r\n  struct ReserveConfigurationMap {\r\n    //bit 0-15: LTV\r\n    //bit 16-31: Liq. threshold\r\n    //bit 32-47: Liq. bonus\r\n    //bit 48-55: Decimals\r\n    //bit 56: Reserve is active\r\n    //bit 57: reserve is frozen\r\n    //bit 58: borrowing is enabled\r\n    //bit 59: stable rate borrowing enabled\r\n    //bit 60-63: reserved\r\n    //bit 64-79: reserve factor\r\n    uint256 data;\r\n  }\r\n\r\n  struct UserConfigurationMap {\r\n    uint256 data;\r\n  }\r\n\r\n  enum InterestRateMode {\r\n    NONE,\r\n    STABLE,\r\n    VARIABLE\r\n  }\r\n}\r\n\r\ninterface ILendingPool {\r\n  /**\r\n   * @dev Emitted on deposit()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address initiating the deposit\r\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\r\n   * @param amount The amount deposited\r\n   * @param referral The referral code used\r\n   **/\r\n  event Deposit(\r\n    address indexed reserve,\r\n    address user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint16 indexed referral\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on withdraw()\r\n   * @param reserve The address of the underlyng asset being withdrawn\r\n   * @param user The address initiating the withdrawal, owner of aTokens\r\n   * @param to Address that will receive the underlying\r\n   * @param amount The amount to be withdrawn\r\n   **/\r\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\r\n\r\n  /**\r\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\r\n   * @param reserve The address of the underlying asset being borrowed\r\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\r\n   * initiator of the transaction on flashLoan()\r\n   * @param onBehalfOf The address that will be getting the debt\r\n   * @param amount The amount borrowed out\r\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\r\n   * @param borrowRate The numeric rate at which the user has borrowed\r\n   * @param referral The referral code used\r\n   **/\r\n  event Borrow(\r\n    address indexed reserve,\r\n    address user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint256 borrowRateMode,\r\n    uint256 borrowRate,\r\n    uint16 indexed referral\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on repay()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The beneficiary of the repayment, getting his debt reduced\r\n   * @param repayer The address of the user initiating the repay(), providing the funds\r\n   * @param amount The amount repaid\r\n   **/\r\n  event Repay(\r\n    address indexed reserve,\r\n    address indexed user,\r\n    address indexed repayer,\r\n    uint256 amount\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted on setUserUseReserveAsCollateral()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user enabling the usage as collateral\r\n   **/\r\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted on setUserUseReserveAsCollateral()\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param user The address of the user enabling the usage as collateral\r\n   **/\r\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\r\n\r\n  /**\r\n   * @dev Emitted on flashLoan()\r\n   * @param target The address of the flash loan receiver contract\r\n   * @param initiator The address initiating the flash loan\r\n   * @param asset The address of the asset being flash borrowed\r\n   * @param amount The amount flash borrowed\r\n   * @param premium The fee flash borrowed\r\n   * @param referralCode The referral code used\r\n   **/\r\n  event FlashLoan(\r\n    address indexed target,\r\n    address indexed initiator,\r\n    address indexed asset,\r\n    uint256 amount,\r\n    uint256 premium,\r\n    uint16 referralCode\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the pause is triggered.\r\n   */\r\n  event Paused();\r\n\r\n  /**\r\n   * @dev Emitted when the pause is lifted.\r\n   */\r\n  event Unpaused();\r\n\r\n  /**\r\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\r\n   * LendingPoolCollateral manager using a DELEGATECALL\r\n   * This allows to have the events in the generated ABI for LendingPool.\r\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n   * @param user The address of the borrower getting liquidated\r\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\r\n   * @param liquidator The address of the liquidator\r\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n   * to receive the underlying collateral asset directly\r\n   **/\r\n  event LiquidationCall(\r\n    address indexed collateralAsset,\r\n    address indexed debtAsset,\r\n    address indexed user,\r\n    uint256 debtToCover,\r\n    uint256 liquidatedCollateralAmount,\r\n    address liquidator,\r\n    bool receiveAToken\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\r\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\r\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\r\n   * gets added to the LendingPool ABI\r\n   * @param reserve The address of the underlying asset of the reserve\r\n   * @param liquidityRate The new liquidity rate\r\n   * @param stableBorrowRate The new stable borrow rate\r\n   * @param variableBorrowRate The new variable borrow rate\r\n   * @param liquidityIndex The new liquidity index\r\n   * @param variableBorrowIndex The new variable borrow index\r\n   **/\r\n  event ReserveDataUpdated(\r\n    address indexed reserve,\r\n    uint256 liquidityRate,\r\n    uint256 stableBorrowRate,\r\n    uint256 variableBorrowRate,\r\n    uint256 liquidityIndex,\r\n    uint256 variableBorrowIndex\r\n  );\r\n\r\n  /**\r\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\r\n   * @param asset The address of the underlying asset to deposit\r\n   * @param amount The amount to be deposited\r\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n   *   is a different wallet\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   **/\r\n  function deposit(\r\n    address asset,\r\n    uint256 amount,\r\n    address onBehalfOf,\r\n    uint16 referralCode\r\n  ) external;\r\n\r\n  function depositYield(address asset, uint256 amount) external;\r\n\r\n  function getYield(address asset, uint256 amount) external;\r\n\r\n  function getTotalBalanceOfAssetPair(address asset) external view returns (uint256, uint256);\r\n\r\n  function getBorrowingAssetAndVolumes()\r\n    external\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256[] memory,\r\n      address[] memory,\r\n      uint256\r\n    );\r\n\r\n  function registerVault(address _vaultAddress) external payable;\r\n\r\n  /**\r\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n   * @param asset The address of the underlying asset to withdraw\r\n   * @param amount The underlying amount to be withdrawn\r\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n   * @param to Address that will receive the underlying, same as msg.sender if the user\r\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n   *   different wallet\r\n   * @return The final amount withdrawn\r\n   **/\r\n  function withdraw(\r\n    address asset,\r\n    uint256 amount,\r\n    address to\r\n  ) external returns (uint256);\r\n\r\n  function withdrawFrom(\r\n    address asset,\r\n    uint256 amount,\r\n    address from,\r\n    address to\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\r\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n   * @param asset The address of the underlying asset to borrow\r\n   * @param amount The amount to be borrowed\r\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n   *   0 if the action is executed directly by the user, without any middle-man\r\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\r\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n   * if he has been given credit delegation allowance\r\n   **/\r\n  function borrow(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 interestRateMode,\r\n    uint16 referralCode,\r\n    address onBehalfOf\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n   * @param asset The address of the borrowed underlying asset previously borrowed\r\n   * @param amount The amount to repay\r\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n   * other borrower whose debt should be removed\r\n   * @return The final amount repaid\r\n   **/\r\n  function repay(\r\n    address asset,\r\n    uint256 amount,\r\n    uint256 rateMode,\r\n    address onBehalfOf\r\n  ) external returns (uint256);\r\n\r\n  /**\r\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\r\n   * @param asset The address of the underlying asset deposited\r\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\r\n   **/\r\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\r\n\r\n  /**\r\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n   * @param user The address of the borrower getting liquidated\r\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n   * to receive the underlying collateral asset directly\r\n   **/\r\n  function liquidationCall(\r\n    address collateralAsset,\r\n    address debtAsset,\r\n    address user,\r\n    uint256 debtToCover,\r\n    bool receiveAToken\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Returns the user account data across all the reserves\r\n   * @param user The address of the user\r\n   * @return totalCollateralETH the total collateral in ETH of the user\r\n   * @return totalDebtETH the total debt in ETH of the user\r\n   * @return availableBorrowsETH the borrowing power left of the user\r\n   * @return currentLiquidationThreshold the liquidation threshold of the user\r\n   * @return ltv the loan to value of the user\r\n   * @return healthFactor the current health factor of the user\r\n   **/\r\n  function getUserAccountData(address user)\r\n    external\r\n    view\r\n    returns (\r\n      uint256 totalCollateralETH,\r\n      uint256 totalDebtETH,\r\n      uint256 availableBorrowsETH,\r\n      uint256 currentLiquidationThreshold,\r\n      uint256 ltv,\r\n      uint256 healthFactor\r\n    );\r\n\r\n  function initReserve(\r\n    address reserve,\r\n    address yieldAddress,\r\n    address aTokenAddress,\r\n    address stableDebtAddress,\r\n    address variableDebtAddress,\r\n    address interestRateStrategyAddress\r\n  ) external payable;\r\n\r\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\r\n    external\r\n    payable;\r\n\r\n  function setConfiguration(address reserve, uint256 configuration) external payable;\r\n\r\n  /**\r\n   * @dev Returns the configuration of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The configuration of the reserve\r\n   **/\r\n  function getConfiguration(address asset)\r\n    external\r\n    view\r\n    returns (DataTypes.ReserveConfigurationMap memory);\r\n\r\n  /**\r\n   * @dev Returns the configuration of the user across all the reserves\r\n   * @param user The user address\r\n   * @return The configuration of the user\r\n   **/\r\n  function getUserConfiguration(address user)\r\n    external\r\n    view\r\n    returns (DataTypes.UserConfigurationMap memory);\r\n\r\n  /**\r\n   * @dev Returns the normalized income normalized income of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The reserve's normalized income\r\n   */\r\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the normalized variable debt per unit of asset\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The reserve normalized variable debt\r\n   */\r\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the state and configuration of the reserve\r\n   * @param asset The address of the underlying asset of the reserve\r\n   * @return The state of the reserve\r\n   **/\r\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\r\n\r\n  function finalizeTransfer(\r\n    address asset,\r\n    address from,\r\n    address to,\r\n    uint256 amount,\r\n    uint256 balanceFromAfter,\r\n    uint256 balanceToBefore\r\n  ) external;\r\n\r\n  function getReservesList() external view returns (address[] memory);\r\n\r\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\r\n\r\n  function setPause(bool val) external payable;\r\n\r\n  function paused() external view returns (bool);\r\n}\r\n\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IScaledBalanceToken {\r\n  /**\r\n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\r\n   * updated stored balance divided by the reserve's liquidity index at the moment of the update\r\n   * @param user The user whose balance is calculated\r\n   * @return The scaled balance of the user\r\n   **/\r\n  function scaledBalanceOf(address user) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the scaled balance of the user and the scaled total supply.\r\n   * @param user The address of the user\r\n   * @return The scaled balance of the user\r\n   * @return The scaled balance and the scaled total supply\r\n   **/\r\n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\r\n\r\n  /**\r\n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\r\n   * @return The scaled total supply\r\n   **/\r\n  function scaledTotalSupply() external view returns (uint256);\r\n}\r\n\r\ninterface IInitializableAToken {\r\n  /**\r\n   * @dev Emitted when an aToken is initialized\r\n   * @param underlyingAsset The address of the underlying asset\r\n   * @param pool The address of the associated lending pool\r\n   * @param treasury The address of the treasury\r\n   * @param incentivesController The address of the incentives controller for this aToken\r\n   * @param aTokenDecimals the decimals of the underlying\r\n   * @param aTokenName the name of the aToken\r\n   * @param aTokenSymbol the symbol of the aToken\r\n   * @param params A set of encoded parameters for additional initialization\r\n   **/\r\n  event Initialized(\r\n    address indexed underlyingAsset,\r\n    address indexed pool,\r\n    address treasury,\r\n    address incentivesController,\r\n    uint8 aTokenDecimals,\r\n    string aTokenName,\r\n    string aTokenSymbol,\r\n    bytes params\r\n  );\r\n\r\n  /**\r\n   * @dev Initializes the aToken\r\n   * @param pool The address of the lending pool where this aToken will be used\r\n   * @param treasury The address of the Sturdy treasury, receiving the fees on this aToken\r\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n   * @param incentivesController The smart contract managing potential incentives distribution\r\n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\r\n   * @param aTokenName The name of the aToken\r\n   * @param aTokenSymbol The symbol of the aToken\r\n   */\r\n  function initialize(\r\n    ILendingPool pool,\r\n    address treasury,\r\n    address underlyingAsset,\r\n    ISturdyIncentivesController incentivesController,\r\n    uint8 aTokenDecimals,\r\n    string calldata aTokenName,\r\n    string calldata aTokenSymbol,\r\n    bytes calldata params\r\n  ) external;\r\n}\r\n\r\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\r\n  /**\r\n   * @dev Emitted after the mint action\r\n   * @param from The address performing the mint\r\n   * @param value The amount being\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  event Mint(address indexed from, uint256 value, uint256 index);\r\n\r\n  /**\r\n   * @dev Mints `amount` aTokens to `user`\r\n   * @param user The address receiving the minted tokens\r\n   * @param amount The amount of tokens getting minted\r\n   * @param index The new liquidity index of the reserve\r\n   * @return `true` if the the previous balance of the user was 0\r\n   */\r\n  function mint(\r\n    address user,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external payable returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted after aTokens are burned\r\n   * @param from The owner of the aTokens, getting them burned\r\n   * @param target The address that will receive the underlying\r\n   * @param value The amount being burned\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\r\n\r\n  /**\r\n   * @dev Emitted during the transfer action\r\n   * @param from The user whose tokens are being transferred\r\n   * @param to The recipient\r\n   * @param value The amount being transferred\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\r\n\r\n  /**\r\n   * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\r\n   * @param user The owner of the aTokens, getting them burned\r\n   * @param receiverOfUnderlying The address that will receive the underlying\r\n   * @param amount The amount being burned\r\n   * @param index The new liquidity index of the reserve\r\n   **/\r\n  function burn(\r\n    address user,\r\n    address receiverOfUnderlying,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external payable;\r\n\r\n  /**\r\n   * @dev Mints aTokens to the reserve treasury\r\n   * @param amount The amount of tokens getting minted\r\n   * @param index The new liquidity index of the reserve\r\n   */\r\n  function mintToTreasury(uint256 amount, uint256 index) external payable;\r\n\r\n  /**\r\n   * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\r\n   * @param from The address getting liquidated, current owner of the aTokens\r\n   * @param to The recipient\r\n   * @param value The amount of tokens getting transferred\r\n   **/\r\n  function transferOnLiquidation(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) external payable;\r\n\r\n  /**\r\n   * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\r\n   * assets in borrow(), withdraw() and flashLoan()\r\n   * @param user The recipient of the underlying\r\n   * @param amount The amount getting transferred\r\n   * @return The amount transferred\r\n   **/\r\n  function transferUnderlyingTo(address user, uint256 amount) external payable returns (uint256);\r\n\r\n  /**\r\n   * @dev Invoked to execute actions on the aToken side after a repayment.\r\n   * @param user The user executing the repayment\r\n   * @param amount The amount getting repaid\r\n   **/\r\n  function handleRepayment(address user, uint256 amount) external;\r\n\r\n  /**\r\n   * @dev Returns the address of the incentives controller contract\r\n   **/\r\n  function getIncentivesController() external view returns (ISturdyIncentivesController);\r\n\r\n  /**\r\n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n   **/\r\n  function UNDERLYING_ASSET_ADDRESS() external view returns (address);\r\n}\r\n\r\ninterface IInitializableDebtToken {\r\n  /**\r\n   * @dev Emitted when a debt token is initialized\r\n   * @param underlyingAsset The address of the underlying asset\r\n   * @param pool The address of the associated lending pool\r\n   * @param incentivesController The address of the incentives controller for this aToken\r\n   * @param debtTokenDecimals the decimals of the debt token\r\n   * @param debtTokenName the name of the debt token\r\n   * @param debtTokenSymbol the symbol of the debt token\r\n   * @param params A set of encoded parameters for additional initialization\r\n   **/\r\n  event Initialized(\r\n    address indexed underlyingAsset,\r\n    address indexed pool,\r\n    address incentivesController,\r\n    uint8 debtTokenDecimals,\r\n    string debtTokenName,\r\n    string debtTokenSymbol,\r\n    bytes params\r\n  );\r\n\r\n  /**\r\n   * @dev Initializes the debt token.\r\n   * @param pool The address of the lending pool where this aToken will be used\r\n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\r\n   * @param incentivesController The smart contract managing potential incentives distribution\r\n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's\r\n   * @param debtTokenName The name of the token\r\n   * @param debtTokenSymbol The symbol of the token\r\n   */\r\n  function initialize(\r\n    ILendingPool pool,\r\n    address underlyingAsset,\r\n    ISturdyIncentivesController incentivesController,\r\n    uint8 debtTokenDecimals,\r\n    string memory debtTokenName,\r\n    string memory debtTokenSymbol,\r\n    bytes calldata params\r\n  ) external;\r\n}\r\n\r\ninterface IVariableDebtToken is IScaledBalanceToken, IInitializableDebtToken {\r\n  /**\r\n   * @dev Emitted after the mint action\r\n   * @param from The address performing the mint\r\n   * @param onBehalfOf The address of the user on which behalf minting has been performed\r\n   * @param value The amount to be minted\r\n   * @param index The last index of the reserve\r\n   **/\r\n  event Mint(address indexed from, address indexed onBehalfOf, uint256 value, uint256 index);\r\n\r\n  /**\r\n   * @dev Mints debt token to the `onBehalfOf` address\r\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\r\n   * of credit delegate, or same as `onBehalfOf` otherwise\r\n   * @param onBehalfOf The address receiving the debt tokens\r\n   * @param amount The amount of debt being minted\r\n   * @param index The variable debt index of the reserve\r\n   * @return `true` if the the previous balance of the user is 0\r\n   **/\r\n  function mint(\r\n    address user,\r\n    address onBehalfOf,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external payable returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when variable debt is burnt\r\n   * @param user The user which debt has been burned\r\n   * @param amount The amount of debt being burned\r\n   * @param index The index of the user\r\n   **/\r\n  event Burn(address indexed user, uint256 amount, uint256 index);\r\n\r\n  /**\r\n   * @dev Burns user variable debt\r\n   * @param user The user which debt is burnt\r\n   * @param index The variable debt index of the reserve\r\n   **/\r\n  function burn(\r\n    address user,\r\n    uint256 amount,\r\n    uint256 index\r\n  ) external payable;\r\n\r\n  /**\r\n   * @dev Returns the address of the incentives controller contract\r\n   **/\r\n  function getIncentivesController() external view returns (ISturdyIncentivesController);\r\n}\r\n\r\ninterface IStableDebtToken is IInitializableDebtToken {\r\n  /**\r\n   * @dev Emitted when new stable debt is minted\r\n   * @param user The address of the user who triggered the minting\r\n   * @param onBehalfOf The recipient of stable debt tokens\r\n   * @param amount The amount minted\r\n   * @param currentBalance The current balance of the user\r\n   * @param balanceIncrease The increase in balance since the last action of the user\r\n   * @param newRate The rate of the debt after the minting\r\n   * @param avgStableRate The new average stable rate after the minting\r\n   * @param newTotalSupply The new total supply of the stable debt token after the action\r\n   **/\r\n  event Mint(\r\n    address indexed user,\r\n    address indexed onBehalfOf,\r\n    uint256 amount,\r\n    uint256 currentBalance,\r\n    uint256 balanceIncrease,\r\n    uint256 newRate,\r\n    uint256 avgStableRate,\r\n    uint256 newTotalSupply\r\n  );\r\n\r\n  /**\r\n   * @dev Emitted when new stable debt is burned\r\n   * @param user The address of the user\r\n   * @param amount The amount being burned\r\n   * @param currentBalance The current balance of the user\r\n   * @param balanceIncrease The the increase in balance since the last action of the user\r\n   * @param avgStableRate The new average stable rate after the burning\r\n   * @param newTotalSupply The new total supply of the stable debt token after the action\r\n   **/\r\n  event Burn(\r\n    address indexed user,\r\n    uint256 amount,\r\n    uint256 currentBalance,\r\n    uint256 balanceIncrease,\r\n    uint256 avgStableRate,\r\n    uint256 newTotalSupply\r\n  );\r\n\r\n  /**\r\n   * @dev Mints debt token to the `onBehalfOf` address.\r\n   * - The resulting rate is the weighted average between the rate of the new debt\r\n   * and the rate of the previous debt\r\n   * @param user The address receiving the borrowed underlying, being the delegatee in case\r\n   * of credit delegate, or same as `onBehalfOf` otherwise\r\n   * @param onBehalfOf The address receiving the debt tokens\r\n   * @param amount The amount of debt tokens to mint\r\n   * @param rate The rate of the debt being minted\r\n   **/\r\n  function mint(\r\n    address user,\r\n    address onBehalfOf,\r\n    uint256 amount,\r\n    uint256 rate\r\n  ) external payable returns (bool);\r\n\r\n  /**\r\n   * @dev Burns debt of `user`\r\n   * - The resulting rate is the weighted average between the rate of the new debt\r\n   * and the rate of the previous debt\r\n   * @param user The address of the user getting his debt burned\r\n   * @param amount The amount of debt tokens getting burned\r\n   **/\r\n  function burn(address user, uint256 amount) external payable;\r\n\r\n  /**\r\n   * @dev Returns the average rate of all the stable rate loans.\r\n   * @return The average stable rate\r\n   **/\r\n  function getAverageStableRate() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the stable rate of the user debt\r\n   * @return The stable rate of the user\r\n   **/\r\n  function getUserStableRate(address user) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the timestamp of the last update of the user\r\n   * @return The timestamp\r\n   **/\r\n  function getUserLastUpdated(address user) external view returns (uint40);\r\n\r\n  /**\r\n   * @dev Returns the principal, the total supply and the average stable rate\r\n   **/\r\n  function getSupplyData()\r\n    external\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint40\r\n    );\r\n\r\n  /**\r\n   * @dev Returns the timestamp of the last update of the total supply\r\n   * @return The timestamp\r\n   **/\r\n  function getTotalSupplyLastUpdated() external view returns (uint40);\r\n\r\n  /**\r\n   * @dev Returns the total supply and the average stable rate\r\n   **/\r\n  function getTotalSupplyAndAvgRate() external view returns (uint256, uint256);\r\n\r\n  /**\r\n   * @dev Returns the principal debt balance of the user\r\n   * @return The debt balance of the user since the last burn/mint action\r\n   **/\r\n  function principalBalanceOf(address user) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the address of the incentives controller contract\r\n   **/\r\n  function getIncentivesController() external view returns (ISturdyIncentivesController);\r\n}\r\n\r\nlibrary Errors {\r\n  //common errors\r\n  string internal constant CALLER_NOT_POOL_ADMIN = '33'; // 'The caller must be the pool admin'\r\n  string internal constant BORROW_ALLOWANCE_NOT_ENOUGH = '59'; // User borrows on behalf, but allowance are too small\r\n\r\n  //contract specific errors\r\n  string internal constant VL_INVALID_AMOUNT = '1'; // 'Amount must be greater than 0'\r\n  string internal constant VL_NO_ACTIVE_RESERVE = '2'; // 'Action requires an active reserve'\r\n  string internal constant VL_RESERVE_FROZEN = '3'; // 'Action cannot be performed because the reserve is frozen'\r\n  string internal constant VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH = '4'; // 'The current liquidity is not enough'\r\n  string internal constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = '5'; // 'User cannot withdraw more than the available balance'\r\n  string internal constant VL_TRANSFER_NOT_ALLOWED = '6'; // 'Transfer cannot be allowed.'\r\n  string internal constant VL_BORROWING_NOT_ENABLED = '7'; // 'Borrowing is not enabled'\r\n  string internal constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = '8'; // 'Invalid interest rate mode selected'\r\n  string internal constant VL_COLLATERAL_BALANCE_IS_0 = '9'; // 'The collateral balance is 0'\r\n  string internal constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = '10'; // 'Health factor is lesser than the liquidation threshold'\r\n  string internal constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = '11'; // 'There is not enough collateral to cover a new borrow'\r\n  string internal constant VL_STABLE_BORROWING_NOT_ENABLED = '12'; // stable borrowing not enabled\r\n  string internal constant VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY = '13'; // collateral is (mostly) the same currency that is being borrowed\r\n  string internal constant VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = '14'; // 'The requested amount is greater than the max loan size in stable rate mode\r\n  string internal constant VL_NO_DEBT_OF_SELECTED_TYPE = '15'; // 'for repayment of stable debt, the user needs to have stable debt, otherwise, he needs to have variable debt'\r\n  string internal constant VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = '16'; // 'To repay on behalf of an user an explicit amount to repay is needed'\r\n  string internal constant VL_NO_STABLE_RATE_LOAN_IN_RESERVE = '17'; // 'User does not have a stable rate loan in progress on this reserve'\r\n  string internal constant VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE = '18'; // 'User does not have a variable rate loan in progress on this reserve'\r\n  string internal constant VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0 = '19'; // 'The underlying balance needs to be greater than 0'\r\n  string internal constant VL_DEPOSIT_ALREADY_IN_USE = '20'; // 'User deposit is already being used as collateral'\r\n  string internal constant LP_NOT_ENOUGH_STABLE_BORROW_BALANCE = '21'; // 'User does not have any stable rate loan for this reserve'\r\n  string internal constant LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = '22'; // 'Interest rate rebalance conditions were not met'\r\n  string internal constant LP_LIQUIDATION_CALL_FAILED = '23'; // 'Liquidation call failed'\r\n  string internal constant LP_NOT_ENOUGH_LIQUIDITY_TO_BORROW = '24'; // 'There is not enough liquidity available to borrow'\r\n  string internal constant LP_REQUESTED_AMOUNT_TOO_SMALL = '25'; // 'The requested amount is too small for a FlashLoan.'\r\n  string internal constant LP_INCONSISTENT_PROTOCOL_ACTUAL_BALANCE = '26'; // 'The actual balance of the protocol is inconsistent'\r\n  string internal constant LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR = '27'; // 'The caller of the function is not the lending pool configurator'\r\n  string internal constant LP_INCONSISTENT_FLASHLOAN_PARAMS = '28';\r\n  string internal constant CT_CALLER_MUST_BE_LENDING_POOL = '29'; // 'The caller of this function must be a lending pool'\r\n  string internal constant CT_CANNOT_GIVE_ALLOWANCE_TO_HIMSELF = '30'; // 'User cannot give allowance to himself'\r\n  string internal constant CT_TRANSFER_AMOUNT_NOT_GT_0 = '31'; // 'Transferred amount needs to be greater than zero'\r\n  string internal constant RL_RESERVE_ALREADY_INITIALIZED = '32'; // 'Reserve has already been initialized'\r\n  string internal constant LPC_RESERVE_LIQUIDITY_NOT_0 = '34'; // 'The liquidity of the reserve needs to be 0'\r\n  string internal constant LPC_INVALID_ATOKEN_POOL_ADDRESS = '35'; // 'The liquidity of the reserve needs to be 0'\r\n  string internal constant LPC_INVALID_STABLE_DEBT_TOKEN_POOL_ADDRESS = '36'; // 'The liquidity of the reserve needs to be 0'\r\n  string internal constant LPC_INVALID_VARIABLE_DEBT_TOKEN_POOL_ADDRESS = '37'; // 'The liquidity of the reserve needs to be 0'\r\n  string internal constant LPC_INVALID_STABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = '38'; // 'The liquidity of the reserve needs to be 0'\r\n  string internal constant LPC_INVALID_VARIABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = '39'; // 'The liquidity of the reserve needs to be 0'\r\n  string internal constant LPC_INVALID_ADDRESSES_PROVIDER_ID = '40'; // 'The liquidity of the reserve needs to be 0'\r\n  string internal constant LPC_INVALID_CONFIGURATION = '75'; // 'Invalid risk parameters for the reserve'\r\n  string internal constant LPC_CALLER_NOT_EMERGENCY_ADMIN = '76'; // 'The caller must be the emergency admin'\r\n  string internal constant LPAPR_PROVIDER_NOT_REGISTERED = '41'; // 'Provider is not registered'\r\n  string internal constant LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = '42'; // 'Health factor is not below the threshold'\r\n  string internal constant LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED = '43'; // 'The collateral chosen cannot be liquidated'\r\n  string internal constant LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = '44'; // 'User did not borrow the specified currency'\r\n  string internal constant LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE = '45'; // \"There isn't enough liquidity available to liquidate\"\r\n  string internal constant LPCM_NO_ERRORS = '46'; // 'No errors'\r\n  string internal constant LP_INVALID_FLASHLOAN_MODE = '47'; //Invalid flashloan mode selected\r\n  string internal constant MATH_MULTIPLICATION_OVERFLOW = '48';\r\n  string internal constant MATH_ADDITION_OVERFLOW = '49';\r\n  string internal constant MATH_DIVISION_BY_ZERO = '50';\r\n  string internal constant RL_LIQUIDITY_INDEX_OVERFLOW = '51'; //  Liquidity index overflows uint128\r\n  string internal constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = '52'; //  Variable borrow index overflows uint128\r\n  string internal constant RL_LIQUIDITY_RATE_OVERFLOW = '53'; //  Liquidity rate overflows uint128\r\n  string internal constant RL_VARIABLE_BORROW_RATE_OVERFLOW = '54'; //  Variable borrow rate overflows uint128\r\n  string internal constant RL_STABLE_BORROW_RATE_OVERFLOW = '55'; //  Stable borrow rate overflows uint128\r\n  string internal constant CT_INVALID_MINT_AMOUNT = '56'; //invalid amount to mint\r\n  string internal constant LP_FAILED_REPAY_WITH_COLLATERAL = '57';\r\n  string internal constant CT_INVALID_BURN_AMOUNT = '58'; //invalid amount to burn\r\n  string internal constant LP_FAILED_COLLATERAL_SWAP = '60';\r\n  string internal constant LP_INVALID_EQUAL_ASSETS_TO_SWAP = '61';\r\n  string internal constant LP_REENTRANCY_NOT_ALLOWED = '62';\r\n  string internal constant LP_CALLER_MUST_BE_AN_ATOKEN = '63';\r\n  string internal constant LP_IS_PAUSED = '64'; // 'Pool is paused'\r\n  string internal constant LP_NO_MORE_RESERVES_ALLOWED = '65';\r\n  string internal constant LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN = '66';\r\n  string internal constant RC_INVALID_LTV = '67';\r\n  string internal constant RC_INVALID_LIQ_THRESHOLD = '68';\r\n  string internal constant RC_INVALID_LIQ_BONUS = '69';\r\n  string internal constant RC_INVALID_DECIMALS = '70';\r\n  string internal constant RC_INVALID_RESERVE_FACTOR = '71';\r\n  string internal constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = '72';\r\n  string internal constant VL_INCONSISTENT_FLASHLOAN_PARAMS = '73';\r\n  string internal constant LP_INCONSISTENT_PARAMS_LENGTH = '74';\r\n  string internal constant UL_INVALID_INDEX = '77';\r\n  string internal constant LP_NOT_CONTRACT = '78';\r\n  string internal constant SDT_STABLE_DEBT_OVERFLOW = '79';\r\n  string internal constant SDT_BURN_EXCEEDS_BALANCE = '80';\r\n  string internal constant VT_COLLATERAL_DEPOSIT_REQUIRE_ETH = '81'; //Only accept ETH for collateral deposit\r\n  string internal constant VT_COLLATERAL_DEPOSIT_INVALID = '82'; //Collateral deposit failed\r\n  string internal constant VT_LIQUIDITY_DEPOSIT_INVALID = '83'; //Only accept USDC, USDT, DAI for liquidity deposit\r\n  string internal constant VT_COLLATERAL_WITHDRAW_INVALID = '84'; //Collateral withdraw failed\r\n  string internal constant VT_COLLATERAL_WITHDRAW_INVALID_AMOUNT = '85'; //Collateral withdraw has not enough amount\r\n  string internal constant VT_CONVERT_ASSET_BY_CURVE_INVALID = '86'; //Convert asset by curve invalid\r\n  string internal constant VT_PROCESS_YIELD_INVALID = '87'; //Processing yield is invalid\r\n  string internal constant VT_TREASURY_INVALID = '88'; //Treasury is invalid\r\n  string internal constant LP_ATOKEN_INIT_INVALID = '89'; //aToken invalid init\r\n  string internal constant VT_FEE_TOO_BIG = '90'; //Fee is too big\r\n  string internal constant VT_COLLATERAL_DEPOSIT_VAULT_UNAVAILABLE = '91';\r\n  string internal constant LP_LIQUIDATION_CONVERT_FAILED = '92';\r\n  string internal constant VT_DEPLOY_FAILED = '93'; // Vault deploy failed\r\n  string internal constant VT_INVALID_CONFIGURATION = '94'; // Invalid vault configuration\r\n  string internal constant VL_OVERFLOW_MAX_RESERVE_CAPACITY = '95'; // overflow max capacity of reserve\r\n  string internal constant VT_WITHDRAW_AMOUNT_MISMATCH = '96'; // not performed withdraw 100%\r\n  string internal constant VT_SWAP_MISMATCH_RETURNED_AMOUNT = '97'; //Returned amount is not enough\r\n  string internal constant CALLER_NOT_YIELD_PROCESSOR = '98'; // 'The caller must be the pool admin'\r\n  string internal constant VT_EXTRA_REWARDS_INDEX_INVALID = '99'; // Invalid extraRewards index\r\n  string internal constant VT_SWAP_PATH_LENGTH_INVALID = '100'; // Invalid token or fee length\r\n  string internal constant VT_SWAP_PATH_TOKEN_INVALID = '101'; // Invalid token information\r\n  string internal constant CLAIMER_UNAUTHORIZED = '102'; // 'The claimer is not authorized'\r\n  string internal constant YD_INVALID_CONFIGURATION = '103'; // 'The yield distribution's invalid configuration'\r\n  string internal constant CALLER_NOT_EMISSION_MANAGER = '104'; // 'The caller must be emission manager'\r\n  string internal constant CALLER_NOT_INCENTIVE_CONTROLLER = '105'; // 'The caller must be incentive controller'\r\n  string internal constant YD_VR_ASSET_ALREADY_IN_USE = '106'; // Vault is already registered\r\n  string internal constant YD_VR_INVALID_VAULT = '107'; // Invalid vault is used for an asset\r\n  string internal constant YD_VR_INVALID_REWARDS_AMOUNT = '108'; // Rewards amount should be bigger than before\r\n  string internal constant YD_VR_REWARD_TOKEN_NOT_VALID = '109'; // The reward token must be same with configured address\r\n  string internal constant YD_VR_ASSET_NOT_REGISTERED = '110';\r\n  string internal constant YD_VR_CALLER_NOT_VAULT = '111'; // The caller must be same with configured vault address\r\n\r\n  enum CollateralManagerErrors {\r\n    NO_ERROR,\r\n    NO_COLLATERAL_AVAILABLE,\r\n    COLLATERAL_CANNOT_BE_LIQUIDATED,\r\n    CURRRENCY_NOT_BORROWED,\r\n    HEALTH_FACTOR_ABOVE_THRESHOLD,\r\n    NOT_ENOUGH_LIQUIDITY,\r\n    NO_ACTIVE_RESERVE,\r\n    HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD,\r\n    INVALID_EQUAL_ASSETS_TO_SWAP,\r\n    FROZEN_RESERVE\r\n  }\r\n}\r\n\r\nlibrary UserConfiguration {\r\n  uint256 internal constant BORROWING_MASK =\r\n    0x5555555555555555555555555555555555555555555555555555555555555555;\r\n\r\n  /**\r\n   * @dev Sets if the user is borrowing the reserve identified by reserveIndex\r\n   * @param self The configuration object\r\n   * @param reserveIndex The index of the reserve in the bitmap\r\n   * @param borrowing True if the user is borrowing the reserve, false otherwise\r\n   **/\r\n  function setBorrowing(\r\n    DataTypes.UserConfigurationMap storage self,\r\n    uint256 reserveIndex,\r\n    bool borrowing\r\n  ) internal {\r\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\r\n    self.data =\r\n      (self.data & ~(1 << (reserveIndex * 2))) |\r\n      (uint256(borrowing ? 1 : 0) << (reserveIndex * 2));\r\n  }\r\n\r\n  /**\r\n   * @dev Sets if the user is using as collateral the reserve identified by reserveIndex\r\n   * @param self The configuration object\r\n   * @param reserveIndex The index of the reserve in the bitmap\r\n   * @param usingAsCollateral True if the user is usin the reserve as collateral, false otherwise\r\n   **/\r\n  function setUsingAsCollateral(\r\n    DataTypes.UserConfigurationMap storage self,\r\n    uint256 reserveIndex,\r\n    bool usingAsCollateral\r\n  ) internal {\r\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\r\n    self.data =\r\n      (self.data & ~(1 << (reserveIndex * 2 + 1))) |\r\n      (uint256(usingAsCollateral ? 1 : 0) << (reserveIndex * 2 + 1));\r\n  }\r\n\r\n  /**\r\n   * @dev Used to validate if a user has been using the reserve for borrowing or as collateral\r\n   * @param self The configuration object\r\n   * @param reserveIndex The index of the reserve in the bitmap\r\n   * @return True if the user has been using a reserve for borrowing or as collateral, false otherwise\r\n   **/\r\n  function isUsingAsCollateralOrBorrowing(\r\n    DataTypes.UserConfigurationMap memory self,\r\n    uint256 reserveIndex\r\n  ) internal pure returns (bool) {\r\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\r\n    return (self.data >> (reserveIndex * 2)) & 3 != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Used to validate if a user has been using the reserve for borrowing\r\n   * @param self The configuration object\r\n   * @param reserveIndex The index of the reserve in the bitmap\r\n   * @return True if the user has been using a reserve for borrowing, false otherwise\r\n   **/\r\n  function isBorrowing(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex)\r\n    internal\r\n    pure\r\n    returns (bool)\r\n  {\r\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\r\n    return (self.data >> (reserveIndex * 2)) & 1 != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Used to validate if a user has been using the reserve as collateral\r\n   * @param self The configuration object\r\n   * @param reserveIndex The index of the reserve in the bitmap\r\n   * @return True if the user has been using a reserve as collateral, false otherwise\r\n   **/\r\n  function isUsingAsCollateral(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex)\r\n    internal\r\n    pure\r\n    returns (bool)\r\n  {\r\n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX);\r\n    return (self.data >> (reserveIndex * 2 + 1)) & 1 != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Used to validate if a user has been borrowing from any reserve\r\n   * @param self The configuration object\r\n   * @return True if the user has been borrowing any reserve, false otherwise\r\n   **/\r\n  function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\r\n    return self.data & BORROWING_MASK != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Used to validate if a user has not been using any reserve\r\n   * @param self The configuration object\r\n   * @return True if the user has been borrowing any reserve, false otherwise\r\n   **/\r\n  function isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) {\r\n    return self.data == 0;\r\n  }\r\n}\r\n\r\ninterface IERC20Detailed is IERC20 {\r\n  function name() external view returns (string memory);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface IReserveInterestRateStrategy {\r\n  function variableRateSlope1() external view returns (uint256);\r\n\r\n  function variableRateSlope2() external view returns (uint256);\r\n\r\n  function baseVariableBorrowRate() external view returns (uint256);\r\n\r\n  function reserveCapacity() external view returns (uint256);\r\n\r\n  function yieldDistributor() external view returns (address);\r\n\r\n  function getMaxVariableBorrowRate() external view returns (uint256);\r\n\r\n  function calculateInterestRates(\r\n    address reserve,\r\n    uint256 availableLiquidity,\r\n    uint256 totalStableDebt,\r\n    uint256 totalVariableDebt,\r\n    uint256 averageStableBorrowRate,\r\n    uint256 reserveFactor\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    );\r\n\r\n  function calculateInterestRates(\r\n    address reserve,\r\n    address aToken,\r\n    uint256 liquidityAdded,\r\n    uint256 liquidityTaken,\r\n    uint256 totalStableDebt,\r\n    uint256 totalVariableDebt,\r\n    uint256 averageStableBorrowRate,\r\n    uint256 reserveFactor\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256 liquidityRate,\r\n      uint256 stableBorrowRate,\r\n      uint256 variableBorrowRate\r\n    );\r\n}\r\n\r\ninterface IYieldDistribution {\r\n  /**\r\n   * @dev Called by the incentiveController or vault on any update that affects the rewards distribution\r\n   * @param user The address of the user\r\n   * @param asset The address of the sToken\r\n   * @param userBalance The balance of the user of the asset in the lending pool\r\n   * @param totalSupply The total supply of the asset in the lending pool\r\n   **/\r\n  function handleAction(\r\n    address user,\r\n    address asset,\r\n    uint256 totalSupply,\r\n    uint256 userBalance\r\n  ) external;\r\n}\r\n\r\ninterface IStableYieldDistribution {\r\n  function claimRewards(\r\n    address[] calldata assets,\r\n    uint256 amount,\r\n    address to\r\n  ) external returns (uint256);\r\n\r\n  function getRewardsBalance(address[] calldata assets, address user)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function REWARD_TOKEN() external view returns (address);\r\n\r\n  function getDistributionEnd() external view returns (uint256);\r\n\r\n  function getAssetData(address asset)\r\n    external\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    );\r\n\r\n  function getUserAssetData(address user, address asset) external view returns (uint256);\r\n}\r\n\r\nstruct AggregatedRewardsData {\r\n  address asset;\r\n  address rewardToken;\r\n  uint256 balance;\r\n}\r\n\r\ninterface IVariableYieldDistribution {\r\n  function claimRewards(\r\n    address asset,\r\n    uint256 amount,\r\n    address to\r\n  ) external returns (uint256);\r\n\r\n  function getRewardsBalance(address[] calldata assets, address user)\r\n    external\r\n    view\r\n    returns (AggregatedRewardsData[] memory);\r\n\r\n  function getAssetData(address asset)\r\n    external\r\n    view\r\n    returns (\r\n      uint256,\r\n      address,\r\n      address,\r\n      uint256\r\n    );\r\n\r\n  function getUserAssetData(address user, address asset)\r\n    external\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    );\r\n}\r\n\r\ninterface IIncentiveVault {\r\n  function getIncentiveRatio() external view returns (uint256);\r\n}\r\n\r\ncontract UiIncentiveDataProvider is IUiIncentiveDataProvider {\r\n  using UserConfiguration for DataTypes.UserConfigurationMap;\r\n\r\n  constructor() {}\r\n\r\n  function getFullReservesIncentiveData(ILendingPoolAddressesProvider provider, address user)\r\n    external\r\n    view\r\n    override\r\n    returns (AggregatedReserveIncentiveData[] memory, UserReserveIncentiveData[] memory)\r\n  {\r\n    return (_getReservesIncentivesData(provider), _getUserReservesIncentivesData(provider, user));\r\n  }\r\n\r\n  function getReservesIncentivesData(ILendingPoolAddressesProvider provider)\r\n    external\r\n    view\r\n    override\r\n    returns (AggregatedReserveIncentiveData[] memory)\r\n  {\r\n    return _getReservesIncentivesData(provider);\r\n  }\r\n\r\n  function _getReservesIncentivesData(ILendingPoolAddressesProvider provider)\r\n    private\r\n    view\r\n    returns (AggregatedReserveIncentiveData[] memory)\r\n  {\r\n    ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\r\n    address[] memory reserves = lendingPool.getReservesList();\r\n    uint256 length = reserves.length;\r\n    AggregatedReserveIncentiveData[]\r\n      memory reservesIncentiveData = new AggregatedReserveIncentiveData[](length);\r\n\r\n    for (uint256 i; i < length; ++i) {\r\n      AggregatedReserveIncentiveData memory reserveIncentiveData = reservesIncentiveData[i];\r\n      reserveIncentiveData.underlyingAsset = reserves[i];\r\n\r\n      DataTypes.ReserveData memory baseData = lendingPool.getReserveData(reserves[i]);\r\n\r\n      try IStableDebtToken(baseData.aTokenAddress).getIncentivesController() returns (\r\n        ISturdyIncentivesController aTokenIncentiveController\r\n      ) {\r\n        if (address(aTokenIncentiveController) != address(0)) {\r\n          address aRewardToken = aTokenIncentiveController.REWARD_TOKEN();\r\n\r\n          try aTokenIncentiveController.getAssetData(baseData.aTokenAddress) returns (\r\n            uint256 aTokenIncentivesIndex,\r\n            uint256 aEmissionPerSecond,\r\n            uint256 aIncentivesLastUpdateTimestamp\r\n          ) {\r\n            reserveIncentiveData.aIncentiveData = IncentiveData(\r\n              aEmissionPerSecond,\r\n              aIncentivesLastUpdateTimestamp,\r\n              aTokenIncentivesIndex,\r\n              aTokenIncentiveController.DISTRIBUTION_END(),\r\n              baseData.aTokenAddress,\r\n              aRewardToken,\r\n              address(aTokenIncentiveController),\r\n              IERC20Detailed(aRewardToken).decimals(),\r\n              aTokenIncentiveController.PRECISION()\r\n            );\r\n          } catch (\r\n            bytes memory /*lowLevelData*/\r\n          ) {}\r\n        }\r\n      } catch (\r\n        bytes memory /*lowLevelData*/\r\n      ) {\r\n        // Will not get here\r\n      }\r\n\r\n      try IStableDebtToken(baseData.stableDebtTokenAddress).getIncentivesController() returns (\r\n        ISturdyIncentivesController sTokenIncentiveController\r\n      ) {\r\n        if (address(sTokenIncentiveController) != address(0)) {\r\n          address sRewardToken = sTokenIncentiveController.REWARD_TOKEN();\r\n          try sTokenIncentiveController.getAssetData(baseData.stableDebtTokenAddress) returns (\r\n            uint256 sTokenIncentivesIndex,\r\n            uint256 sEmissionPerSecond,\r\n            uint256 sIncentivesLastUpdateTimestamp\r\n          ) {\r\n            reserveIncentiveData.sIncentiveData = IncentiveData(\r\n              sEmissionPerSecond,\r\n              sIncentivesLastUpdateTimestamp,\r\n              sTokenIncentivesIndex,\r\n              sTokenIncentiveController.DISTRIBUTION_END(),\r\n              baseData.stableDebtTokenAddress,\r\n              sRewardToken,\r\n              address(sTokenIncentiveController),\r\n              IERC20Detailed(sRewardToken).decimals(),\r\n              sTokenIncentiveController.PRECISION()\r\n            );\r\n          } catch (\r\n            bytes memory /*lowLevelData*/\r\n          ) {}\r\n        }\r\n      } catch (\r\n        bytes memory /*lowLevelData*/\r\n      ) {\r\n        // Will not get here\r\n      }\r\n\r\n      try IStableDebtToken(baseData.variableDebtTokenAddress).getIncentivesController() returns (\r\n        ISturdyIncentivesController vTokenIncentiveController\r\n      ) {\r\n        if (address(vTokenIncentiveController) != address(0)) {\r\n          address vRewardToken = vTokenIncentiveController.REWARD_TOKEN();\r\n\r\n          try vTokenIncentiveController.getAssetData(baseData.variableDebtTokenAddress) returns (\r\n            uint256 vTokenIncentivesIndex,\r\n            uint256 vEmissionPerSecond,\r\n            uint256 vIncentivesLastUpdateTimestamp\r\n          ) {\r\n            reserveIncentiveData.vIncentiveData = IncentiveData(\r\n              vEmissionPerSecond,\r\n              vIncentivesLastUpdateTimestamp,\r\n              vTokenIncentivesIndex,\r\n              vTokenIncentiveController.DISTRIBUTION_END(),\r\n              baseData.variableDebtTokenAddress,\r\n              vRewardToken,\r\n              address(vTokenIncentiveController),\r\n              IERC20Detailed(vRewardToken).decimals(),\r\n              vTokenIncentiveController.PRECISION()\r\n            );\r\n          } catch (\r\n            bytes memory /*lowLevelData*/\r\n          ) {}\r\n        }\r\n      } catch (\r\n        bytes memory /*lowLevelData*/\r\n      ) {\r\n        // Will not get here\r\n      }\r\n\r\n      address yieldDistributor = IReserveInterestRateStrategy(baseData.interestRateStrategyAddress)\r\n        .yieldDistributor();\r\n      if (yieldDistributor != address(0)) {\r\n        // get stable reward data\r\n        try IStableYieldDistribution(yieldDistributor).REWARD_TOKEN() returns (\r\n          address rewardToken\r\n        ) {\r\n          if (rewardToken != address(0)) {\r\n            (\r\n              uint256 tokenIncentivesIndex,\r\n              uint256 emissionPerSecond,\r\n              uint256 incentivesLastUpdateTimestamp\r\n            ) = IStableYieldDistribution(yieldDistributor).getAssetData(baseData.aTokenAddress);\r\n\r\n            reserveIncentiveData.rewardData = RewardData(\r\n              // stable reward info\r\n              emissionPerSecond,\r\n              incentivesLastUpdateTimestamp,\r\n              IStableYieldDistribution(yieldDistributor).getDistributionEnd(),\r\n              // variable reward info\r\n              0,\r\n              0,\r\n              // common reward info\r\n              tokenIncentivesIndex,\r\n              baseData.aTokenAddress,\r\n              rewardToken,\r\n              yieldDistributor,\r\n              IERC20Detailed(rewardToken).decimals()\r\n            );\r\n          }\r\n        } catch (\r\n          bytes memory /*lowLevelData*/\r\n        ) {\r\n          // get variable reward data\r\n          (\r\n            uint256 tokenIncentivesIndex,\r\n            address vaultAddress,\r\n            address rewardToken,\r\n            uint256 lastAvailableRewards\r\n          ) = IVariableYieldDistribution(yieldDistributor).getAssetData(baseData.aTokenAddress);\r\n          uint256 incentiveRatio = IIncentiveVault(vaultAddress).getIncentiveRatio();\r\n\r\n          reserveIncentiveData.rewardData = RewardData(\r\n            // stable reward info\r\n            0,\r\n            0,\r\n            0,\r\n            // variable reward info\r\n            incentiveRatio,\r\n            lastAvailableRewards,\r\n            // common reward info\r\n            tokenIncentivesIndex,\r\n            baseData.aTokenAddress,\r\n            rewardToken,\r\n            yieldDistributor,\r\n            IERC20Detailed(rewardToken).decimals()\r\n          );\r\n        }\r\n      }\r\n    }\r\n    return (reservesIncentiveData);\r\n  }\r\n\r\n  function getUserReservesIncentivesData(ILendingPoolAddressesProvider provider, address user)\r\n    external\r\n    view\r\n    override\r\n    returns (UserReserveIncentiveData[] memory)\r\n  {\r\n    return _getUserReservesIncentivesData(provider, user);\r\n  }\r\n\r\n  function _getUserReservesIncentivesData(ILendingPoolAddressesProvider provider, address user)\r\n    private\r\n    view\r\n    returns (UserReserveIncentiveData[] memory)\r\n  {\r\n    ILendingPool lendingPool = ILendingPool(provider.getLendingPool());\r\n    address[] memory reserves = lendingPool.getReservesList();\r\n    uint256 length = reserves.length;\r\n\r\n    UserReserveIncentiveData[] memory userReservesIncentivesData = new UserReserveIncentiveData[](\r\n      user != address(0) ? length : 0\r\n    );\r\n\r\n    for (uint256 i; i < length; ++i) {\r\n      DataTypes.ReserveData memory baseData = lendingPool.getReserveData(reserves[i]);\r\n\r\n      // user reserve data\r\n      userReservesIncentivesData[i].underlyingAsset = reserves[i];\r\n\r\n      IUiIncentiveDataProvider.UserIncentiveData memory aUserIncentiveData;\r\n\r\n      try IAToken(baseData.aTokenAddress).getIncentivesController() returns (\r\n        ISturdyIncentivesController aTokenIncentiveController\r\n      ) {\r\n        if (address(aTokenIncentiveController) != address(0)) {\r\n          address aRewardToken = aTokenIncentiveController.REWARD_TOKEN();\r\n          aUserIncentiveData.tokenincentivesUserIndex = aTokenIncentiveController.getUserAssetData(\r\n            user,\r\n            baseData.aTokenAddress\r\n          );\r\n          aUserIncentiveData.userUnclaimedRewards = aTokenIncentiveController\r\n            .getUserUnclaimedRewards(user);\r\n          aUserIncentiveData.tokenAddress = baseData.aTokenAddress;\r\n          aUserIncentiveData.rewardTokenAddress = aRewardToken;\r\n          aUserIncentiveData.incentiveControllerAddress = address(aTokenIncentiveController);\r\n          aUserIncentiveData.rewardTokenDecimals = IERC20Detailed(aRewardToken).decimals();\r\n        }\r\n      } catch (\r\n        bytes memory /*lowLevelData*/\r\n      ) {}\r\n\r\n      userReservesIncentivesData[i].aTokenIncentivesUserData = aUserIncentiveData;\r\n\r\n      UserIncentiveData memory vUserIncentiveData;\r\n\r\n      try IVariableDebtToken(baseData.variableDebtTokenAddress).getIncentivesController() returns (\r\n        ISturdyIncentivesController vTokenIncentiveController\r\n      ) {\r\n        if (address(vTokenIncentiveController) != address(0)) {\r\n          address vRewardToken = vTokenIncentiveController.REWARD_TOKEN();\r\n          vUserIncentiveData.tokenincentivesUserIndex = vTokenIncentiveController.getUserAssetData(\r\n            user,\r\n            baseData.variableDebtTokenAddress\r\n          );\r\n          vUserIncentiveData.userUnclaimedRewards = vTokenIncentiveController\r\n            .getUserUnclaimedRewards(user);\r\n          vUserIncentiveData.tokenAddress = baseData.variableDebtTokenAddress;\r\n          vUserIncentiveData.rewardTokenAddress = vRewardToken;\r\n          vUserIncentiveData.incentiveControllerAddress = address(vTokenIncentiveController);\r\n          vUserIncentiveData.rewardTokenDecimals = IERC20Detailed(vRewardToken).decimals();\r\n        }\r\n      } catch (\r\n        bytes memory /*lowLevelData*/\r\n      ) {}\r\n\r\n      userReservesIncentivesData[i].vTokenIncentivesUserData = vUserIncentiveData;\r\n\r\n      UserIncentiveData memory sUserIncentiveData;\r\n\r\n      try IStableDebtToken(baseData.stableDebtTokenAddress).getIncentivesController() returns (\r\n        ISturdyIncentivesController sTokenIncentiveController\r\n      ) {\r\n        if (address(sTokenIncentiveController) != address(0)) {\r\n          address sRewardToken = sTokenIncentiveController.REWARD_TOKEN();\r\n          sUserIncentiveData.tokenincentivesUserIndex = sTokenIncentiveController.getUserAssetData(\r\n            user,\r\n            baseData.stableDebtTokenAddress\r\n          );\r\n          sUserIncentiveData.userUnclaimedRewards = sTokenIncentiveController\r\n            .getUserUnclaimedRewards(user);\r\n          sUserIncentiveData.tokenAddress = baseData.stableDebtTokenAddress;\r\n          sUserIncentiveData.rewardTokenAddress = sRewardToken;\r\n          sUserIncentiveData.incentiveControllerAddress = address(sTokenIncentiveController);\r\n          sUserIncentiveData.rewardTokenDecimals = IERC20Detailed(sRewardToken).decimals();\r\n        }\r\n      } catch (\r\n        bytes memory /*lowLevelData*/\r\n      ) {}\r\n\r\n      userReservesIncentivesData[i].sTokenIncentivesUserData = sUserIncentiveData;\r\n\r\n      address yieldDistributor = IReserveInterestRateStrategy(baseData.interestRateStrategyAddress)\r\n        .yieldDistributor();\r\n      if (yieldDistributor != address(0)) {\r\n        UserRewardData memory rewardUserData;\r\n\r\n        // get stable reward user data\r\n        try IStableYieldDistribution(yieldDistributor).REWARD_TOKEN() returns (\r\n          address rewardToken\r\n        ) {\r\n          rewardUserData = _getUserStableRewardData(\r\n            user,\r\n            baseData.aTokenAddress,\r\n            rewardToken,\r\n            yieldDistributor\r\n          );\r\n        } catch (\r\n          bytes memory /*lowLevelData*/\r\n        ) {\r\n          // get variable reward user data\r\n          rewardUserData = _getUserVariableRewardData(\r\n            user,\r\n            baseData.aTokenAddress,\r\n            yieldDistributor\r\n          );\r\n        }\r\n\r\n        userReservesIncentivesData[i].rewardUserData = rewardUserData;\r\n      }\r\n    }\r\n\r\n    return (userReservesIncentivesData);\r\n  }\r\n\r\n  function _getUserStableRewardData(\r\n    address user,\r\n    address asset,\r\n    address rewardToken,\r\n    address yieldDistributor\r\n  ) private view returns (UserRewardData memory rewardUserData) {\r\n    rewardUserData.tokenincentivesUserIndex = IStableYieldDistribution(yieldDistributor)\r\n      .getUserAssetData(user, asset);\r\n    address[] memory assets = new address[](1);\r\n    assets[0] = asset;\r\n    rewardUserData.userUnclaimedRewards = IStableYieldDistribution(yieldDistributor)\r\n      .getRewardsBalance(assets, user);\r\n    rewardUserData.tokenAddress = asset;\r\n    rewardUserData.rewardTokenAddress = rewardToken;\r\n    rewardUserData.distributorAddress = yieldDistributor;\r\n    rewardUserData.rewardTokenDecimals = IERC20Detailed(rewardToken).decimals();\r\n  }\r\n\r\n  function _getUserVariableRewardData(\r\n    address user,\r\n    address asset,\r\n    address yieldDistributor\r\n  ) private view returns (UserRewardData memory rewardUserData) {\r\n    (rewardUserData.tokenincentivesUserIndex, , ) = IVariableYieldDistribution(yieldDistributor)\r\n      .getUserAssetData(user, asset);\r\n    address[] memory assets = new address[](1);\r\n    assets[0] = asset;\r\n    AggregatedRewardsData[] memory rewardData = IVariableYieldDistribution(yieldDistributor)\r\n      .getRewardsBalance(assets, user);\r\n    rewardUserData.userUnclaimedRewards = rewardData[0].balance;\r\n    rewardUserData.tokenAddress = asset;\r\n    rewardUserData.rewardTokenAddress = rewardData[0].rewardToken;\r\n    rewardUserData.distributorAddress = yieldDistributor;\r\n    rewardUserData.rewardTokenDecimals = IERC20Detailed(rewardData[0].rewardToken).decimals();\r\n  }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"contract ILendingPoolAddressesProvider\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getFullReservesIncentiveData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"emissionPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentivesLastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIncentivesIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emissionEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"incentiveControllerAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"precision\",\"type\":\"uint8\"}],\"internalType\":\"struct IUiIncentiveDataProvider.IncentiveData\",\"name\":\"aIncentiveData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"emissionPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentivesLastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIncentivesIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emissionEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"incentiveControllerAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"precision\",\"type\":\"uint8\"}],\"internalType\":\"struct IUiIncentiveDataProvider.IncentiveData\",\"name\":\"vIncentiveData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"emissionPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentivesLastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIncentivesIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emissionEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"incentiveControllerAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"precision\",\"type\":\"uint8\"}],\"internalType\":\"struct IUiIncentiveDataProvider.IncentiveData\",\"name\":\"sIncentiveData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"emissionPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentivesLastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emissionEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentiveRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastAvailableRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIncentivesIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributorAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct IUiIncentiveDataProvider.RewardData\",\"name\":\"rewardData\",\"type\":\"tuple\"}],\"internalType\":\"struct IUiIncentiveDataProvider.AggregatedReserveIncentiveData[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenincentivesUserIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userUnclaimedRewards\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"incentiveControllerAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct IUiIncentiveDataProvider.UserIncentiveData\",\"name\":\"aTokenIncentivesUserData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenincentivesUserIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userUnclaimedRewards\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"incentiveControllerAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct IUiIncentiveDataProvider.UserIncentiveData\",\"name\":\"vTokenIncentivesUserData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenincentivesUserIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userUnclaimedRewards\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"incentiveControllerAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct IUiIncentiveDataProvider.UserIncentiveData\",\"name\":\"sTokenIncentivesUserData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenincentivesUserIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userUnclaimedRewards\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributorAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct IUiIncentiveDataProvider.UserRewardData\",\"name\":\"rewardUserData\",\"type\":\"tuple\"}],\"internalType\":\"struct IUiIncentiveDataProvider.UserReserveIncentiveData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILendingPoolAddressesProvider\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"getReservesIncentivesData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"emissionPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentivesLastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIncentivesIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emissionEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"incentiveControllerAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"precision\",\"type\":\"uint8\"}],\"internalType\":\"struct IUiIncentiveDataProvider.IncentiveData\",\"name\":\"aIncentiveData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"emissionPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentivesLastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIncentivesIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emissionEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"incentiveControllerAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"precision\",\"type\":\"uint8\"}],\"internalType\":\"struct IUiIncentiveDataProvider.IncentiveData\",\"name\":\"vIncentiveData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"emissionPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentivesLastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIncentivesIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emissionEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"incentiveControllerAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"precision\",\"type\":\"uint8\"}],\"internalType\":\"struct IUiIncentiveDataProvider.IncentiveData\",\"name\":\"sIncentiveData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"emissionPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentivesLastUpdateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emissionEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentiveRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastAvailableRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenIncentivesIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributorAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct IUiIncentiveDataProvider.RewardData\",\"name\":\"rewardData\",\"type\":\"tuple\"}],\"internalType\":\"struct IUiIncentiveDataProvider.AggregatedReserveIncentiveData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILendingPoolAddressesProvider\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserReservesIncentivesData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlyingAsset\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenincentivesUserIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userUnclaimedRewards\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"incentiveControllerAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct IUiIncentiveDataProvider.UserIncentiveData\",\"name\":\"aTokenIncentivesUserData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenincentivesUserIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userUnclaimedRewards\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"incentiveControllerAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct IUiIncentiveDataProvider.UserIncentiveData\",\"name\":\"vTokenIncentivesUserData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenincentivesUserIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userUnclaimedRewards\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"incentiveControllerAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct IUiIncentiveDataProvider.UserIncentiveData\",\"name\":\"sTokenIncentivesUserData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenincentivesUserIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userUnclaimedRewards\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"distributorAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"rewardTokenDecimals\",\"type\":\"uint8\"}],\"internalType\":\"struct IUiIncentiveDataProvider.UserRewardData\",\"name\":\"rewardUserData\",\"type\":\"tuple\"}],\"internalType\":\"struct IUiIncentiveDataProvider.UserReserveIncentiveData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "UiIncentiveDataProvider", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c96ec7370bd474aba3df3014cf12b41025f8239c990f90c4ea4ddd0403534d5d"}]}