{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/HardBlocksFreshman.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport \\\"./Base64.sol\\\";\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./HardBlocksStudent.sol\\\";\\n\\ncontract HardBlocksFreshman is IHardBlocksStudent {\\n    using Strings for uint256;\\n\\n    function tokenURI(\\n        uint256 tokenId,\\n        string memory studentName,\\n        uint256 score\\n    ) override external pure returns (string memory) {\\n        return string(\\n            abi.encodePacked(\\n                \\\"data:application/json;base64,\\\",\\n                Base64.encode(\\n                    bytes(\\n                        string(\\n                            abi.encodePacked(\\n                                '{\\\"name\\\": \\\"', studentName,'\\\",',\\n                                '\\\"description\\\": \\\"For the self-taught web3 developer: ',\\n                                'School of Hard Blocks. Freshman year now enrolling.\\\",',\\n                                '\\\"image\\\": \\\"data:image/svg+xml;base64,',\\n                                genSVG(tokenId, studentName, score),\\n                                '\\\",\\\"attributes\\\":',\\n                                '[{\\\"trait_type\\\": \\\"Score\\\", \\\"value\\\": ', score.toString(), '}]',\\n                                \\\"}\\\"\\n                            )\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    function genSVG(uint256 tokenId, string memory studentName, uint256 currentScore)\\n        private \\n        pure \\n        returns (string memory)  {\\n\\n            require(currentScore < 6, 'OutOfBounds'); \\n            require(currentScore > 0, 'OutOfBounds');\\n\\n            string[32] memory canvas; \\n            uint256 length  = bytes(studentName).length; \\n            string memory wholeOutput;\\n\\n            // for shimmer only.\\n            string memory seqStr = '0.1;0.2;0.3;0.4;0.5';\\n            uint8[9] memory sequence = [9, 7, 4, 7, 9, 7, 4, 7, 9];\\n            \\n            string[6] memory extraText; \\n            bytes1 emptyChar = bytes(\\\" \\\")[0];\\n\\n            extraText[0] = '<text x=\\\"5\\\" y=\\\"';\\n            extraText[1] = '\\\" xml:space=\\\"preserve\\\"  class=\\\"';\\n            extraText[2] = '\\\">';\\n            extraText[3] = '<animate attributeName=\\\"opacity\\\"  values=\\\"'; \\n            extraText[4] = '\\\" dur=\\\"3s\\\" repeatCount=\\\"indefinite\\\"/>';\\n            extraText[5] = '</text>';\\n\\n            wholeOutput = '<g transform=\\\"scale(4)\\\"> <rect width=\\\"200\\\" height=\\\"345\\\" fill=\\\"#010101\\\" />';\\n            \\n            uint256 yVal;\\n\\n            // prepare the string array of text values for the ground section. \\n            canvas = _drawGround(canvas, tokenId, emptyChar);\\n\\n            canvas[31] = _text(canvas[31],   studentName,    length,   0); \\n            canvas[31] = _text(canvas[31],   string(abi.encodePacked(\\\"0x_0\\\", currentScore.toString(), \\\" \\\")),    6,   26); \\n\\n            for (uint256 thisLine = 0; thisLine < 32; thisLine++) {\\n\\n                yVal = thisLine*10 + 20;\\n            \\n                if (currentScore == 5) {\\n                    seqStr = rotateByX(thisLine, sequence, seqStr);\\n                    wholeOutput = string(abi.encodePacked(\\n                        wholeOutput, extraText[0], yVal.toString(), \\n                        extraText[1], \\\"ground\\\", extraText[2], extraText[3],\\n                        seqStr,\\n                        extraText[4]\\n                        ));\\n\\n                    wholeOutput = string(abi.encodePacked(\\n                        wholeOutput,\\n                        canvas[thisLine], \\n                        extraText[5]\\n                        ));\\n                } else {\\n                    wholeOutput = string(abi.encodePacked(\\n                        wholeOutput, extraText[0], yVal.toString(), \\n                        extraText[1], \\\"ground\\\", extraText[2], \\n                        canvas[thisLine], \\n                        extraText[5]));\\n                }\\n\\n            }\\n\\n            // template\\n            wholeOutput = string(abi.encodePacked(wholeOutput, \\n                rw(80, 70, 35, 20, 'hair'), \\n                rw(75, 80, 5, 50, 'hair'),\\n                rw(115, 80, 5, 50, 'hair'),\\n                rw(70, 90, 5, 20, 'hair'),\\n                rw(120, 90, 5, 20, 'hair'),\\n                rw(80, 130, 35, 40, 'skin'),\\n                rw(75, 130, 5, 30, 'skin'),\\n                rw(115, 130, 5, 20, 'skin')\\n                ));\\n\\n            wholeOutput = string(abi.encodePacked(wholeOutput, \\n                rw(85, 170, 25, 10, 'skin'),\\n                rw(90, 180, 10, 10, 'skin'),\\n                rw(70, 110, 5, 20, 'skin'),\\n                rw(120, 110, 5, 20, 'skin'),\\n                rw(80, 90, 5, 40, 'skin'),\\n                rw(80, 90, 35, 10, 'skin'),\\n                rw(95, 90, 5, 40, 'skin'),\\n                rw(110, 90, 5, 40, 'skin')\\n                ));\\n\\n            wholeOutput = string(abi.encodePacked(wholeOutput, \\n                rw(80, 190, 35, 40, 'shirt'),\\n                rw(85, 180, 5, 10, 'shirt'),\\n                rw(100, 180, 10, 10, 'shirt'),\\n                rw(75, 200, 5, 20, 'skin'),\\n                rw(110, 200, 5, 20, 'skin'),\\n                rw(100, 210, 10, 10, 'skin'),\\n                rw(80, 230, 15, 20, 'pants'),\\n                rw(95, 230, 5, 10, 'pants')\\n                ));\\n\\n            wholeOutput = string(abi.encodePacked(wholeOutput, \\n                rw(100, 230, 15, 20, 'pants'),\\n                rw(80, 250, 10, 10, 'pants'),\\n                rw(105, 250, 10, 10, 'pants'),\\n                rw(80, 260, 10, 10, 'grey'),\\n                rw(105, 260, 10, 10, 'grey'),\\n                rw(90, 160, 15, 10, 'black'),\\n                rw(85, 120, 5, 10, 'white'),\\n                rw(100, 120, 5, 10, 'white')\\n                ));\\n\\n            // beards: \\n            if (tokenId % 13 == 0) {\\n                // large beard\\n                wholeOutput = string(abi.encodePacked(wholeOutput, \\n                    rw(75, 130, 5, 30, 'hair'),\\n                    rw(115, 130, 5, 30, 'hair'),\\n                    rw(90, 150, 10, 10, 'hair'),\\n                    rw(80, 160, 10, 10, 'hair'),\\n                    rw(100, 160, 10, 20, 'hair'),\\n                    rw(110, 150, 5, 20, 'hair'),\\n                    rw(85, 170, 5, 10, 'hair'),\\n                    rw(90, 170, 10, 20, 'hair')\\n                )); \\n            } else if (tokenId % 13 == 1) {\\n                //small beard\\n                wholeOutput = string(abi.encodePacked(wholeOutput, \\n                    rw(85, 150, 5, 30, 'hair'),\\n                    rw(100, 150, 5, 30, 'hair'),\\n                    rw(90, 150, 10, 10, 'hair'),\\n                    rw(90, 170, 10, 20, 'hair')\\n                ));\\n            }\\n        \\n            // hair (only for score > 1; and not everyone with score > 1).\\n            if (currentScore > 1) {\\n                if (tokenId % 7 == 0) {\\n                    // bald\\n                    wholeOutput = string(abi.encodePacked(wholeOutput, \\n                        rw(80, 70, 35, 10, 'skin'),\\n                        rw(85, 80, 25, 10, 'skin')\\n                    ));\\n                } else if (tokenId % 7 == 1) {\\n                    // bob\\n                    wholeOutput = string(abi.encodePacked(wholeOutput, \\n                        rw(60, 160, 5, 10, 'hair'),\\n                        rw(65, 170, 10, 10, 'hair'),\\n                        rw(70, 130, 5, 30, 'hair'),\\n                        rw(70, 130, 10, 10, 'hair'),\\n                        rw(70, 160, 10, 10, 'hair')\\n                    ));\\n                    wholeOutput = string(abi.encodePacked(wholeOutput, \\n                        rw(115, 130, 5, 50, 'hair'),\\n                        rw(120, 130, 5, 60, 'hair'),\\n                        rw(125, 110, 5, 40, 'hair'),\\n                        rw(125, 180, 5, 10, 'hair'),\\n                        rw(130, 170, 5, 10, 'hair')\\n                    ));\\n                } else if (tokenId % 7 == 2) {\\n                    // fringe\\n                    wholeOutput = string(abi.encodePacked(wholeOutput, \\n                        rw(80, 90, 5, 50, 'hair'),\\n                        rw(85, 90, 5, 30, 'hair'),\\n                        rw(75, 130, 5, 30, 'hair'),\\n                        rw(105, 90, 5, 20, 'hair'),\\n                        rw(110, 90, 5, 50, 'hair'),\\n                        rw(120, 130, 5, 30, 'hair')\\n                    ));\\n                } else if (tokenId % 7 == 3) {\\n                    // long hair\\n                    wholeOutput = string(abi.encodePacked(wholeOutput, \\n                        rw(75, 130, 5, 40, 'hair'),\\n                        rw(125, 110, 5, 50, 'hair'),\\n                        rw(120, 130, 5, 40, 'hair'),\\n                        rw(115, 130, 5, 50, 'hair')\\n                    ));\\n                }\\n            }\\n\\n            // accessories (only for score > 2).\\n            if (currentScore > 2) {\\n                if (tokenId % 5 == 0) {\\n                    // phone\\n                    wholeOutput = string(abi.encodePacked(wholeOutput, \\n                        rw(95, 190, 10, 20, 'black'),\\n                        rw(95, 210, 5, 10, 'black')\\n                    ));\\n                } else if (tokenId % 5 == 1 ) {\\n                    // bag\\n                    wholeOutput = string(abi.encodePacked(wholeOutput, \\n                        rw(105, 210, 5, 20, 'acc'),\\n                        rw(100, 230, 15, 30, 'acc')\\n                    ));\\n                } else if ( tokenId % 5 == 2) {\\n                    // cape\\n                    wholeOutput = string(abi.encodePacked(wholeOutput, \\n                        rw(85, 180, 5, 10, 'acc'),\\n                        rw(90, 190, 10, 10, 'acc'),\\n                        rw(100, 180, 15, 10, 'acc'),\\n                        rw(115, 190, 5, 80, 'acc'),\\n                        rw(90, 250, 15, 10, 'acc'),\\n                        rw(95, 240, 5, 10, 'acc'),\\n                        rw(90, 260, 5, 10, 'acc')\\n                    ));\\n                } else if ( tokenId % 5 == 3) {\\n                    // book\\n                    wholeOutput = string(abi.encodePacked(wholeOutput, \\n                        rw(90, 200, 10, 40, 'acc'),\\n                        rw(100, 200, 5, 10, 'acc'),\\n                        rw(100, 220, 5, 20, 'acc')\\n                    ));\\n                } else {\\n                    // tie \\n                    wholeOutput = string(abi.encodePacked(wholeOutput, \\n                        rw(93, 190, 4, 30, 'acc'),\\n                        rw(90, 180, 10, 10, 'acc')\\n                    ));\\n                }\\n            }\\n\\n\\n        // hats (everyone score > 3)\\n            if (currentScore > 3) {\\n                if (tokenId % 4 == 0) {\\n                    // crown\\n                    wholeOutput = string(abi.encodePacked(wholeOutput, \\n                        rw(75, 70, 45, 20, 'gold'),\\n                        rw(70, 60, 5, 10, 'gold'),\\n                        rw(120, 60, 5, 10, 'gold'),\\n                        rw(90, 60, 15, 10, 'gold'),\\n                        rw(95, 50, 5, 10, 'gold'),\\n                        rw(90, 60, 15, 10, 'gold')\\n                    ));\\n                    wholeOutput = string(abi.encodePacked(wholeOutput, \\n                        rw(95, 70, 5, 10, 'acc')\\n                    ));\\n                } else if (tokenId % 4 == 1) {\\n                    // cap\\n                    wholeOutput = string(abi.encodePacked(wholeOutput, \\n                        rw(75, 50, 35, 40, 'acc'),\\n                        rw(55, 80, 20, 10, 'acc'),\\n                        rw(110, 60, 5, 30, 'acc'),\\n                        rw(115, 70, 5, 20, 'acc'),\\n                        rw(80, 60, 10, 20, 'shirt')\\n                    ));\\n                } else if (tokenId % 4 == 2) {\\n                    // ponytail + bow.\\n                    wholeOutput = string(abi.encodePacked(wholeOutput, \\n                        rw(120, 50, 10, 10, 'hair'),\\n                        rw(120, 60, 15, 10, 'hair'),\\n                        rw(120, 70, 20, 10, 'hair'),\\n                        rw(130, 80, 10, 20, 'hair'),\\n                        rw(135, 100, 5, 10, 'hair')\\n                    ));\\n                    wholeOutput = string(abi.encodePacked(wholeOutput, \\n                        rw(110, 50, 5, 10, 'acc'),\\n                        rw(110, 60, 10, 10, 'acc'),\\n                        rw(105, 70, 15, 10, 'acc'),\\n                        rw(120, 80, 10, 10, 'acc'),\\n                        rw(120, 90, 15, 10, 'acc'),\\n                        rw(125, 100, 5, 10, 'acc')\\n                    ));\\n                } else {\\n                    // graduate\\n                    wholeOutput = string(abi.encodePacked(wholeOutput, \\n                        rw(70, 50, 55, 10, 'grey'),\\n                        rw(85, 60, 25, 10, 'grey'),\\n                        rw(115, 50, 5, 30, 'shirt')\\n                    ));\\n                }\\n            }\\n\\n\\n            // reuse the canvas variable to select colours.\\n            canvas = _drawColours(canvas);\\n\\n\\n            // no, not random. But not simple. \\n            sequence[0] = uint8(26 + (uint256(keccak256(abi.encodePacked(tokenId.toString(), 'text')))) % 6);\\n            sequence[1] = uint8(0 + (uint256(keccak256(abi.encodePacked(tokenId.toString(), 'skin')))) % 4);\\n            sequence[2] = uint8(4 + (uint256(keccak256(abi.encodePacked(tokenId.toString(), 'hair')))) % 6);\\n            sequence[3] = uint8(10 + (uint256(keccak256(abi.encodePacked(tokenId.toString(), 'shirt')))) % 6);\\n            sequence[4] = uint8(16 + (uint256(keccak256(abi.encodePacked(tokenId.toString(), 'pants')))) % 4);\\n            sequence[5] = uint8(20 + (uint256(keccak256(abi.encodePacked(tokenId.toString(), 'acc')))) % 6);\\n\\n            wholeOutput = string(abi.encodePacked(wholeOutput, \\n                '<rect x = \\\"191\\\" y = \\\"321\\\" width=\\\"5\\\" height=\\\"12\\\" style=\\\"fill:rgb(255,255,255)\\\" >',\\n                '<animate attributeName=\\\"fill\\\" values=\\\"black;black;black;white;white;white\\\" dur=\\\"1s\\\" repeatCount=\\\"indefinite\\\" />',\\n                '</rect> <!-- DadJokeLabs-->  </g> </svg>'));\\n\\n            wholeOutput = string(abi.encodePacked(\\n                '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 800 1380\\\">',\\n                '<style>.ground { fill: ',\\n                canvas[sequence[0]],\\n                ';font-family: monospace; font-size: 10px; } .skin { fill: ',\\n                canvas[sequence[1]],\\n                ';} .hair {fill: ',\\n                canvas[sequence[2]],\\n                ';}.shirt {fill: ',\\n                canvas[sequence[3]],\\n                ';}.pants {fill: ',\\n                canvas[sequence[4]],\\n                ';}.acc {fill: ',\\n                canvas[sequence[5]],\\n                ';} .black {fill: #000000;} .white {fill: #FFFFFF;}',\\n                '.gold {fill: #FCE500;} .grey {fill: #222222;}',\\n                '</style>',\\n                wholeOutput));\\n\\n            return Base64.encode(abi.encodePacked(wholeOutput));\\n\\n    }  // of _draw function\\n\\n    function _drawGround(string[32] memory canvas, uint256 tokenId, bytes1 emptyChar) \\n    private \\n    pure \\n    returns (string[32] memory) {\\n        \\n        string memory holder;\\n\\n        for (uint256 k = 0; k < 17; k++) {\\n\\n            if ((tokenId+k) % 8 == 0) {\\n                holder = 'struct Transaction { address to;';\\n            } else if ((tokenId+k) % 8 == 1) {\\n                holder = 'unit value; bytes data; bool exe';\\n            } else if ((tokenId+k) % 8 == 2) {\\n                holder = 'uint numConfirmations uint value';\\n            } else if ((tokenId+k) % 8 == 3) {\\n                holder = 'public pure returns (bool) {byte';\\n            } else if ((tokenId+k) % 8 == 4) {            \\n                holder = 'mapping(address => bool) public ';\\n            } else if ((tokenId+k) % 8 == 5) {    \\n                holder = ' interface IERC721 is IERC165 { ';\\n            } else if ((tokenId+k) % 8 == 6) {    \\n                holder = 'require(isOwner[msg.sender],xy);';\\n            } else if ((tokenId+k) % 8 == 7) {    \\n                holder = 'function isApprovedForAll(addres';\\n            }\\n\\n            if (k == 15 || k == 16) {\\n                canvas[k] = holder;\\n            } else if  (k < 8) {\\n                canvas[k] = '                                ';\\n                    for (uint thisChar = (15-k); thisChar < (16+k); thisChar++) {\\n                        bytes(canvas[k])[thisChar] = bytes(holder)[thisChar];\\n                    }\\n                canvas[31-k] = string(copyBytes(bytes(canvas[k])));\\n            } else if ( k < 15) {\\n                canvas[k] = holder;\\n                    for (uint thisChar = 0; thisChar < (15-k); thisChar++) {\\n                        bytes(canvas[k])[thisChar] = emptyChar;\\n                    }\\n                    for (uint thisChar = (17+k); thisChar < 32; thisChar++) {\\n                        bytes(canvas[k])[thisChar] = emptyChar;\\n                    }\\n                canvas[31-k] = string(copyBytes(bytes(canvas[k])));\\n            }\\n\\n        }\\n        return canvas; \\n    } // of _drawGround function.\\n\\n    function copyBytes(bytes memory _bytes) private pure returns (bytes memory) {\\n        bytes memory bytesCopy = new bytes(_bytes.length);\\n        uint256 bytesLength = _bytes.length + 31;\\n        for (uint256 i = 32; i <= bytesLength; i += 32)\\n        {\\n            assembly { mstore(add(bytesCopy, i), mload(add(_bytes, i))) }\\n        }\\n        return bytesCopy;\\n    }\\n\\n    function _text(string memory baseline, string memory message, uint256 messageLength, uint256 x) \\n    private \\n    pure \\n    returns (string memory) {\\n        for (uint256 i = 0; i < messageLength; i++) {\\n            bytes(baseline)[x + i] = bytes(message)[i];\\n        }\\n        return baseline;\\n    } // of _text function.\\n\\n\\n    function rotateByX(uint256 move, uint8[9] memory sequence, string memory seqStr) \\n    private \\n    pure \\n    returns (string memory)  {\\n\\n        if (move >= 5) {\\n            move = move % 5;\\n        }\\n        \\n        for (uint8 thisChar = 0; thisChar < 5; thisChar++) {\\n            bytes(seqStr) [(4*thisChar) + 2] = bytes(uint256(sequence[move + thisChar]).toString())[0];\\n        }\\n\\n        return seqStr;\\n\\n    } // of rotationFunction.\\n\\n\\n    function _drawColours(string[32] memory canvas)\\n    private \\n    pure\\n    returns (string[32] memory) {\\n        // skin: 4 options.\\n        canvas[0] =  '#ffcc99'; // Lightest skin\\n        canvas[1] =  '#f1c27d'; // Middle light\\n        canvas[2] =  '#c68642'; // Middle dark\\n        canvas[3] =  '#8d5524'; // Darkest skin\\n        // hair: 6 options. \\n        canvas[4] =  '#a2826d'; // Brown\\n        canvas[5] =  '#3a1413'; // Maroon\\n        canvas[6] =  '#191207'; // Black\\n        canvas[7] =  '#FFF5e1'; // White Blonde\\n        canvas[8] = '#4bc8f4'; // Blue\\n        canvas[9] = '#e27589'; // Pink\\n        // shirt: 6 options \\n        canvas[10] =  '#1166ff'; // Heroic Blue\\n        canvas[11] =  '#00ff7c'; // Spring Grass\\n        canvas[12] =  '#ff7f50'; // Coral\\n        canvas[13] = '#f1ff62'; // Lemon Pie\\n        canvas[14] =  '#FFFFFF'; // White\\n        canvas[15] =  '#00fdff'; // Fluorescent Turquoise\\n        // pants: 4 options \\n        canvas[16] = '#373e02'; // Dark Olive\\n        canvas[17] = '#4f1507'; // Earth Brown\\n        canvas[18] = '#112222'; // Dark Water\\n        canvas[19] = '#1560bd'; // Denim\\n        // acc: 6 options \\n        canvas[20] =  '#fe01b1'; // Bright Pink\\n        canvas[21] =  '#87fd05'; // Bright Lime\\n        canvas[22] =  '#9f00ff'; // Vivid Violet\\n        canvas[23] =  '#89939a'; // Bright Silver\\n        canvas[24] = '#ffff14 '; // YellowSubmarine\\n        canvas[25] = '#FF0080'; // Fuschia\\n        // text: 6 options\\n        canvas[26] = '#C39953'; // Burnt Gold\\n        canvas[27] = '#FF404C'; // 'Sunburnt cyclops'\\n        canvas[28] = '#0066FF'; // Bright Blue\\n        canvas[29] = '#33FF33'; // Apple II green.\\n        canvas[30] = '#676767'; // grey\\n        canvas[31] = '#5946B2'; // purple\\n    \\n        return canvas;\\n    }\\n\\n    function rw(uint256 x, uint256 y, uint256 width, uint256 height, string memory class) \\n    private \\n    pure \\n    returns (string memory) {\\n        class = string(abi.encodePacked(\\n            '<rect x = \\\"',\\n            x.toString(),\\n            '\\\" y = \\\"',\\n            y.toString(),\\n            '\\\" width=\\\"',\\n            width.toString(),\\n            '\\\" height=\\\"',\\n            height.toString(),\\n            '\\\" class=\\\"',\\n            class,\\n            '\\\" />'\\n        ));\\n        return class;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Base64.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Base64 {\\n    bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n\\n    function ENCODE(string memory) internal pure returns (string memory) {\\n        return \\\"CaSe mAttERs\\\";\\n    }\\n}\"\r\n    },\r\n    \"contracts/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Strings {\\n    //from:  \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\"\r\n    },\r\n    \"contracts/HardBlocksStudent.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\ninterface IHardBlocksStudent {\\n    function tokenURI(\\n        uint256 tokenId,\\n        string memory studentName,\\n        uint256 score\\n    ) external view returns (string memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10,\r\n      \"details\": {\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true,\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\"\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"studentName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "HardBlocksFreshman", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}