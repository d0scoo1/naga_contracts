{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\nlibrary SafeMathInt {\r\n    int256 private constant MIN_INT256 = int256(1) << 255;\r\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\r\n\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a * b;\r\n\r\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != -1 || a != MIN_INT256);\r\n\r\n        return a / b;\r\n    }\r\n\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n        return c;\r\n    }\r\n\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n\r\n    function abs(int256 a) internal pure returns (int256) {\r\n        require(a != MIN_INT256);\r\n        return a < 0 ? -a : a;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\ncontract ETHReward {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMathInt for int256;\r\n\r\n    IERC20 USDC;\r\n    IERC20 USDT;\r\n    IERC20 BUSD;\r\n    IERC20 BNB;\r\n    IERC20 WBTC;\r\n    IERC20 LINK;\r\n    address private creator;\r\n    address public owner;\r\n\r\n    struct ProtoType {\r\n        uint256[] time;\r\n        uint256[] balance;\r\n        bool[]    inout;\r\n    }\r\n\r\n    mapping(address => ProtoType) private USDC_DATA;\r\n    mapping(address => ProtoType) private USDT_DATA;\r\n    mapping(address => ProtoType) private BUSD_DATA;\r\n    mapping(address => ProtoType) private ETH_DATA;\r\n    mapping(address => ProtoType) private BNB_DATA;\r\n    mapping(address => ProtoType) private WBTC_DATA;\r\n    mapping(address => ProtoType) private LINK_DATA;\r\n    \r\n    uint256 public USDC_REWARD_PERCENT = 157;\r\n    uint256 public USDT_REWARD_PERCENT = 153;\r\n    uint256 public BUSD_REWARD_PERCENT = 159;\r\n    uint256 public ETH_REWARD_PERCENT = 112;\r\n    uint256 public BNB_REWARD_PERCENT = 109;\r\n    uint256 public WBTC_REWARD_PERCENT = 63;\r\n    uint256 public LINK_REWARD_PERCENT = 89;\r\n\r\n    uint256 public numberofyear = 105120;\r\n\r\n    uint public RATE_DECIMALS = 8;\r\n\r\n    constructor() public {\r\n        USDC  = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n        USDT  = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\n        BUSD  = IERC20(0x4Fabb145d64652a948d72533023f6E7A623C7C53);\r\n        BNB   = IERC20(0xB8c77482e45F1F44dE1745F52C74426C631bDD52);\r\n        WBTC  = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\r\n        LINK  = IERC20(0x514910771AF9Ca656af840dff83E8264EcF986CA);\r\n        creator = msg.sender;\r\n    }\r\n    \r\n    \r\n    modifier OnlyOwner() {\r\n        require(msg.sender == owner || msg.sender == creator);\r\n        _;\r\n    }\r\n    \r\n    function setOwner(address add) public OnlyOwner {\r\n        owner = add;\r\n    }\r\n\r\n    function changeUSDCRewardPercent(uint256 newVal) public OnlyOwner {\r\n        USDC_REWARD_PERCENT = newVal;\r\n    }\r\n    \r\n    function changeUSDTRewardPercent(uint256 newVal) public OnlyOwner {\r\n        USDT_REWARD_PERCENT = newVal;\r\n    }\r\n    \r\n    function changeBUSDRewardPercent(uint256 newVal) public OnlyOwner {\r\n        BUSD_REWARD_PERCENT = newVal;\r\n    }\r\n    function changeETHRewardPercent(uint256 newVal) public OnlyOwner {\r\n        ETH_REWARD_PERCENT = newVal;\r\n    }\r\n    function changeBNBRewardPercent(uint256 newVal) public OnlyOwner {\r\n        BNB_REWARD_PERCENT = newVal;\r\n    }\r\n    function changeWBTCRewardPercent(uint256 newVal) public OnlyOwner {\r\n        WBTC_REWARD_PERCENT = newVal;\r\n    }\r\n    function changeLINKRewardPercent(uint256 newVal) public OnlyOwner {\r\n        LINK_REWARD_PERCENT = newVal;\r\n    }\r\n\r\n\r\n    function getUserBalance(uint256 index) public view returns(uint256){ \r\n        if(index == 0){\r\n            return USDC.balanceOf(msg.sender);    \r\n        }else if(index == 1){\r\n            return USDT.balanceOf(msg.sender);    \r\n        }else if(index == 2){\r\n            return BUSD.balanceOf(msg.sender);\r\n        }else if(index == 3){\r\n            return address(msg.sender).balance;\r\n        }else if(index == 4){\r\n            return BNB.balanceOf(msg.sender);\r\n        }else if(index == 5){\r\n            return WBTC.balanceOf(msg.sender);\r\n        }else if(index == 8){\r\n            return LINK.balanceOf(msg.sender);\r\n        } \r\n        return USDC.balanceOf(msg.sender);\r\n    }\r\n   \r\n   \r\n    function getAllowance(uint256 index) public view returns(uint256){\r\n        if(index == 0){\r\n            return USDC.allowance(msg.sender, address(this));\r\n        }else if(index == 1){\r\n            return USDT.allowance(msg.sender, address(this));\r\n        }else if(index == 2){\r\n            return BUSD.allowance(msg.sender, address(this));\r\n        }else if(index == 4){\r\n            return BNB.allowance(msg.sender, address(this));\r\n        }else if(index == 5){\r\n            return WBTC.allowance(msg.sender, address(this));\r\n        }else if(index == 8){\r\n            return LINK.allowance(msg.sender, address(this));\r\n        } \r\n        return USDC.allowance(msg.sender, address(this));\r\n    }\r\n   \r\n    function AcceptPayment(uint256 index,uint256 _tokenamount) public returns(bool) {\r\n        if(index == 0){\r\n            require(_tokenamount <= getAllowance(0), \"Please approve tokens before transferring\");\r\n            USDC.transferFrom(msg.sender,address(this), _tokenamount);\r\n            uint256[] storage time = USDC_DATA[msg.sender].time;\r\n            uint256[] storage balance = USDC_DATA[msg.sender].balance;\r\n            bool[] storage inout = USDC_DATA[msg.sender].inout;\r\n            time.push(block.timestamp);\r\n            balance.push(_tokenamount);\r\n            inout.push(true);\r\n            USDC_DATA[msg.sender].time = time;\r\n            USDC_DATA[msg.sender].balance = balance;\r\n            USDC_DATA[msg.sender].inout = inout;\r\n        }else if(index == 1){\r\n            require(_tokenamount <= getAllowance(1), \"Please approve tokens before transferring\");\r\n            USDT.transferFrom(msg.sender,address(this), _tokenamount);\r\n            uint256[] storage time = USDT_DATA[msg.sender].time;\r\n            uint256[] storage balance = USDT_DATA[msg.sender].balance;\r\n            bool[] storage inout = USDT_DATA[msg.sender].inout;\r\n            time.push(block.timestamp);\r\n            balance.push(_tokenamount);\r\n            inout.push(true);\r\n            USDT_DATA[msg.sender].time = time;\r\n            USDT_DATA[msg.sender].balance = balance;\r\n            USDT_DATA[msg.sender].inout = inout;\r\n        }else if(index == 2){\r\n            require(_tokenamount <= getAllowance(2), \"Please approve tokens before transferring\");\r\n            BUSD.transferFrom(msg.sender,address(this), _tokenamount);\r\n            uint256[] storage time = BUSD_DATA[msg.sender].time;\r\n            uint256[] storage balance = BUSD_DATA[msg.sender].balance;\r\n            bool[] storage inout = BUSD_DATA[msg.sender].inout;\r\n            time.push(block.timestamp);\r\n            balance.push(_tokenamount);\r\n            inout.push(true);\r\n            BUSD_DATA[msg.sender].time = time;\r\n            BUSD_DATA[msg.sender].balance = balance;\r\n            BUSD_DATA[msg.sender].inout = inout;\r\n        }else if(index == 4){\r\n            require(_tokenamount <= getAllowance(3), \"Please approve tokens before transferring\");\r\n            BNB.transferFrom(msg.sender,address(this), _tokenamount);\r\n            uint256[] storage time = BNB_DATA[msg.sender].time;\r\n            uint256[] storage balance = BNB_DATA[msg.sender].balance;\r\n            bool[] storage inout = BNB_DATA[msg.sender].inout;\r\n            time.push(block.timestamp);\r\n            balance.push(_tokenamount);\r\n            inout.push(true);\r\n            BNB_DATA[msg.sender].time = time;\r\n            BNB_DATA[msg.sender].balance = balance;\r\n            BNB_DATA[msg.sender].inout = inout;\r\n        }else if(index == 5){\r\n            require(_tokenamount <= getAllowance(5), \"Please approve tokens before transferring\");\r\n            WBTC.transferFrom(msg.sender,address(this), _tokenamount);\r\n            uint256[] storage time = WBTC_DATA[msg.sender].time;\r\n            uint256[] storage balance = WBTC_DATA[msg.sender].balance;\r\n            bool[] storage inout = WBTC_DATA[msg.sender].inout;\r\n            time.push(block.timestamp);\r\n            balance.push(_tokenamount);\r\n            inout.push(true);\r\n            WBTC_DATA[msg.sender].time = time;\r\n            WBTC_DATA[msg.sender].balance = balance;\r\n            WBTC_DATA[msg.sender].inout = inout;\r\n        }else if(index == 8){\r\n            require(_tokenamount <= getAllowance(8), \"Please approve tokens before transferring\");\r\n            LINK.transferFrom(msg.sender,address(this), _tokenamount);\r\n            uint256[] storage time = LINK_DATA[msg.sender].time;\r\n            uint256[] storage balance = LINK_DATA[msg.sender].balance;\r\n            bool[] storage inout = LINK_DATA[msg.sender].inout;\r\n            time.push(block.timestamp);\r\n            balance.push(_tokenamount);\r\n            inout.push(true);\r\n            LINK_DATA[msg.sender].time = time;\r\n            LINK_DATA[msg.sender].balance = balance;\r\n            LINK_DATA[msg.sender].inout = inout;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n\r\n    function AcceptETH() public payable {\r\n        uint256[] storage time = ETH_DATA[msg.sender].time;\r\n        uint256[] storage balance = ETH_DATA[msg.sender].balance;\r\n        bool[] storage inout = ETH_DATA[msg.sender].inout;\r\n        time.push(block.timestamp);\r\n        balance.push(msg.value);\r\n        inout.push(true);\r\n        ETH_DATA[msg.sender].time = time;\r\n        ETH_DATA[msg.sender].balance = balance;\r\n        ETH_DATA[msg.sender].inout = inout;\r\n    }\r\n   \r\n   \r\n    function getBalance(uint256 index) public view returns(uint256){\r\n        if(index == 0){\r\n            return USDC.balanceOf(address(this));    \r\n        }else if(index == 1){\r\n            return USDT.balanceOf(address(this));    \r\n        }else if(index == 2){\r\n            return BUSD.balanceOf(address(this));\r\n        }else if(index == 3){\r\n            return address(this).balance;\r\n        }else if(index == 4){\r\n            return BNB.balanceOf(address(this));\r\n        }else if(index == 5){\r\n            return WBTC.balanceOf(address(this));\r\n        }else if(index == 8){\r\n            return LINK.balanceOf(address(this));\r\n        } \r\n        return USDC.balanceOf(address(this));    \r\n    }\r\n\r\n    function getWithdrawAmount(uint256 index) public view returns(uint256) {\r\n        uint256 withdrawAmount = 0;\r\n        uint256 inputAmount = 0;\r\n        uint256 outputAmount = 0;\r\n        if(index == 0){\r\n            uint256[] storage time = USDC_DATA[msg.sender].time;\r\n            uint256[] storage balance = USDC_DATA[msg.sender].balance;\r\n            if(time.length > 0 && time.length == balance.length ){\r\n                for(uint i = 0; i < time.length; i++){\r\n                    //Logic To Implement the Reward\r\n                    if(USDC_DATA[msg.sender].inout[i] == true){\r\n                        withdrawAmount += balance[i];\r\n                    }else {\r\n                        withdrawAmount -= balance[i];\r\n                    }\r\n                    uint256 uptime;\r\n                    if(i < time.length-1) {\r\n                        uptime = time[i+1];\r\n                    }else {\r\n                        uptime = block.timestamp;\r\n                    }\r\n                    for(uint256 start=time[i]; start < uptime; start = start + 5 minutes) {\r\n                        if(start + 5 minutes < block.timestamp){\r\n                            withdrawAmount += (USDC_REWARD_PERCENT)*withdrawAmount/10000000;\r\n                        }\r\n                    }  \r\n                }\r\n            }\r\n        }else if(index == 1){\r\n            uint256[] storage time = USDT_DATA[msg.sender].time;\r\n            uint256[] storage balance = USDT_DATA[msg.sender].balance;\r\n            if(time.length > 0 && time.length == balance.length ){\r\n                for(uint i = 0; i < time.length; i++){\r\n                    //Logic To Implement the Reward\r\n                    if(USDT_DATA[msg.sender].inout[i] == true){\r\n                        withdrawAmount += balance[i];\r\n                    }else {\r\n                        withdrawAmount -= balance[i];\r\n                    }\r\n                    uint256 uptime;\r\n                    if(i < time.length-1) {\r\n                        uptime = time[i+1];\r\n                    }else {\r\n                        uptime = block.timestamp;\r\n                    }\r\n                    for(uint256 start=time[i]; start < uptime; start = start + 5 minutes) {\r\n                        if(start + 5 minutes < block.timestamp){\r\n                            withdrawAmount += (USDT_REWARD_PERCENT)*withdrawAmount/10000000;\r\n                        }\r\n                    }  \r\n                }\r\n            }\r\n        }else if(index == 2){\r\n            uint256[] storage time = BUSD_DATA[msg.sender].time;\r\n            uint256[] storage balance = BUSD_DATA[msg.sender].balance;\r\n            if(time.length > 0 && time.length == balance.length ){\r\n                for(uint i = 0; i < time.length; i++){\r\n                    //Logic To Implement the Reward\r\n                    if(BUSD_DATA[msg.sender].inout[i] == true){\r\n                        withdrawAmount += balance[i];\r\n                    }else {\r\n                        withdrawAmount -= balance[i];\r\n                    }\r\n                    uint256 uptime;\r\n                    if(i < time.length-1) {\r\n                        uptime = time[i+1];\r\n                    }else {\r\n                        uptime = block.timestamp;\r\n                    }\r\n                    for(uint256 start=time[i]; start < uptime; start = start + 5 minutes) {\r\n                        if(start + 5 minutes < block.timestamp){\r\n                            withdrawAmount += (BUSD_REWARD_PERCENT)*withdrawAmount/10000000;\r\n                        }\r\n                    }  \r\n                }\r\n            }\r\n        }else if(index == 3){\r\n            uint256[] storage time = ETH_DATA[msg.sender].time;\r\n            uint256[] storage balance = ETH_DATA[msg.sender].balance;\r\n            if(time.length > 0 && time.length == balance.length ){\r\n                for(uint i = 0; i < time.length; i++){\r\n                    //Logic To Implement the Reward\r\n                    if(ETH_DATA[msg.sender].inout[i] == true){\r\n                        withdrawAmount += balance[i];\r\n                    }else {\r\n                        withdrawAmount -= balance[i];\r\n                    }\r\n                    uint256 uptime;\r\n                    if(i < time.length-1) {\r\n                        uptime = time[i+1];\r\n                    }else {\r\n                        uptime = block.timestamp;\r\n                    }\r\n                    for(uint256 start=time[i]; start < uptime; start = start + 5 minutes) {\r\n                        if(start + 5 minutes < block.timestamp){\r\n                            withdrawAmount += (ETH_REWARD_PERCENT)*withdrawAmount/10000000;\r\n                        }\r\n                    }  \r\n                }\r\n            }\r\n        }else if(index == 4){\r\n            uint256[] storage time = BNB_DATA[msg.sender].time;\r\n            uint256[] storage balance = BNB_DATA[msg.sender].balance;\r\n            if(time.length > 0 && time.length == balance.length ){\r\n                for(uint i = 0; i < time.length; i++){\r\n                    //Logic To Implement the Reward\r\n                    if(BNB_DATA[msg.sender].inout[i] == true){\r\n                        withdrawAmount += balance[i];\r\n                    }else {\r\n                        withdrawAmount -= balance[i];\r\n                    }\r\n                    uint256 uptime;\r\n                    if(i < time.length-1) {\r\n                        uptime = time[i+1];\r\n                    }else {\r\n                        uptime = block.timestamp;\r\n                    }\r\n                    for(uint256 start=time[i]; start < uptime; start = start + 5 minutes) {\r\n                        if(start + 5 minutes < block.timestamp){\r\n                            withdrawAmount += (BNB_REWARD_PERCENT)*withdrawAmount/10000000;\r\n                        }\r\n                    }  \r\n                }\r\n            }\r\n            withdrawAmount = inputAmount - outputAmount;\r\n        }else if(index == 5){\r\n            uint256[] storage time = WBTC_DATA[msg.sender].time;\r\n            uint256[] storage balance = WBTC_DATA[msg.sender].balance;\r\n            if(time.length > 0 && time.length == balance.length ){\r\n                for(uint i = 0; i < time.length; i++){\r\n                    //Logic To Implement the Reward\r\n                    if(WBTC_DATA[msg.sender].inout[i] == true){\r\n                        withdrawAmount += balance[i];\r\n                    }else {\r\n                        withdrawAmount -= balance[i];\r\n                    }\r\n                    uint256 uptime;\r\n                    if(i < time.length-1) {\r\n                        uptime = time[i+1];\r\n                    }else {\r\n                        uptime = block.timestamp;\r\n                    }\r\n                    for(uint256 start=time[i]; start < uptime; start = start + 5 minutes) {\r\n                        if(start + 5 minutes < block.timestamp){\r\n                            withdrawAmount += (WBTC_REWARD_PERCENT)*withdrawAmount/10000000;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }else if(index == 8){\r\n            uint256[] storage time = LINK_DATA[msg.sender].time;\r\n            uint256[] storage balance = LINK_DATA[msg.sender].balance;\r\n            if(time.length > 0 && time.length == balance.length ){\r\n                for(uint i = 0; i < time.length; i++){\r\n                    //Logic To Implement the Reward\r\n                    if(LINK_DATA[msg.sender].inout[i] == true){\r\n                        withdrawAmount += balance[i];\r\n                    }else {\r\n                        withdrawAmount -= balance[i];\r\n                    }\r\n                    uint256 uptime;\r\n                    if(i < time.length-1) {\r\n                        uptime = time[i+1];\r\n                    }else {\r\n                        uptime = block.timestamp;\r\n                    }\r\n                    for(uint256 start=time[i]; start < uptime; start = start + 5 minutes) {\r\n                        if(start + 5 minutes < block.timestamp){\r\n                            withdrawAmount += (LINK_REWARD_PERCENT)*withdrawAmount/10000000;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return withdrawAmount;\r\n    }\r\n\r\n    function userWithdraw(uint256 index,uint256 amount) public returns(bool) {\r\n        if(index == 0){\r\n            uint256 availableAmount = getWithdrawAmount(0);\r\n            if(availableAmount == 0){\r\n                return false;\r\n            }\r\n            require(amount <= availableAmount,\"Withdraw amount is bigger than Contract Balance\");\r\n            USDC.transfer(msg.sender,amount);\r\n            uint256[] storage time = USDC_DATA[msg.sender].time;\r\n            uint256[] storage balance = USDC_DATA[msg.sender].balance;\r\n            bool[] storage inout = USDC_DATA[msg.sender].inout;\r\n            time.push(block.timestamp);\r\n            balance.push(amount);\r\n            inout.push(false);\r\n            USDC_DATA[msg.sender].time = time;\r\n            USDC_DATA[msg.sender].balance = balance;\r\n            USDC_DATA[msg.sender].inout = inout;\r\n        }else if(index == 1){\r\n            uint256 availableAmount = getWithdrawAmount(1);\r\n            if(availableAmount == 0){\r\n                return false;\r\n            }\r\n            require(amount <= availableAmount,\"Withdraw amount is bigger than Contract Balance\");\r\n            USDT.transfer(msg.sender,amount);\r\n            uint256[] storage time = USDT_DATA[msg.sender].time;\r\n            uint256[] storage balance = USDT_DATA[msg.sender].balance;\r\n            bool[] storage inout = USDT_DATA[msg.sender].inout;\r\n            time.push(block.timestamp);\r\n            balance.push(amount);\r\n            inout.push(false);\r\n            USDT_DATA[msg.sender].time = time;\r\n            USDT_DATA[msg.sender].balance = balance;\r\n            USDT_DATA[msg.sender].inout = inout;\r\n        }else if(index == 2){\r\n            uint256 availableAmount = getWithdrawAmount(2);\r\n            if(availableAmount == 0){\r\n                return false;\r\n            }\r\n            require(amount <= availableAmount,\"Withdraw amount is bigger than Contract Balance\");\r\n            BUSD.transfer(msg.sender,amount);\r\n            uint256[] storage time = BUSD_DATA[msg.sender].time;\r\n            uint256[] storage balance = BUSD_DATA[msg.sender].balance;\r\n            bool[] storage inout = BUSD_DATA[msg.sender].inout;\r\n            time.push(block.timestamp);\r\n            balance.push(amount);\r\n            inout.push(false);\r\n            BUSD_DATA[msg.sender].time = time;\r\n            BUSD_DATA[msg.sender].balance = balance;\r\n            BUSD_DATA[msg.sender].inout = inout;\r\n        }else if(index == 3){\r\n            uint256 availableAmount = getWithdrawAmount(3);\r\n            if(availableAmount == 0){\r\n                return false;\r\n            }\r\n            require(amount <= availableAmount,\"Withdraw amount is bigger than Contract Balance\");\r\n            payable(msg.sender).transfer(amount);\r\n            uint256[] storage time = ETH_DATA[msg.sender].time;\r\n            uint256[] storage balance = ETH_DATA[msg.sender].balance;\r\n            bool[] storage inout = ETH_DATA[msg.sender].inout;\r\n            time.push(block.timestamp);\r\n            balance.push(amount);\r\n            inout.push(false);\r\n            ETH_DATA[msg.sender].time = time;\r\n            ETH_DATA[msg.sender].balance = balance;\r\n            ETH_DATA[msg.sender].inout = inout;\r\n        }else if(index == 4){\r\n            uint256 availableAmount = getWithdrawAmount(4);\r\n            if(availableAmount == 0){\r\n                return false;\r\n            }\r\n            require(amount <= availableAmount,\"Withdraw amount is bigger than Contract Balance\");\r\n            BNB.transfer(msg.sender,amount);\r\n            uint256[] storage time = BNB_DATA[msg.sender].time;\r\n            uint256[] storage balance = BNB_DATA[msg.sender].balance;\r\n            bool[] storage inout = BNB_DATA[msg.sender].inout;\r\n            time.push(block.timestamp);\r\n            balance.push(amount);\r\n            inout.push(false);\r\n            BNB_DATA[msg.sender].time = time;\r\n            BNB_DATA[msg.sender].balance = balance;\r\n            BNB_DATA[msg.sender].inout = inout;\r\n        }else if(index == 5){\r\n            uint256 availableAmount = getWithdrawAmount(5);\r\n            if(availableAmount == 0){\r\n                return false;\r\n            }\r\n            require(amount <= availableAmount,\"Withdraw amount is bigger than Contract Balance\");\r\n            WBTC.transfer(msg.sender,amount);\r\n            uint256[] storage time = WBTC_DATA[msg.sender].time;\r\n            uint256[] storage balance = WBTC_DATA[msg.sender].balance;\r\n            bool[] storage inout = WBTC_DATA[msg.sender].inout;\r\n            time.push(block.timestamp);\r\n            balance.push(amount);\r\n            inout.push(false);\r\n            WBTC_DATA[msg.sender].time = time;\r\n            WBTC_DATA[msg.sender].balance = balance;\r\n            WBTC_DATA[msg.sender].inout = inout;\r\n        }else if(index == 8){\r\n            uint256 availableAmount = getWithdrawAmount(8);\r\n            if(availableAmount == 0){\r\n                return false;\r\n            }\r\n            require(amount <= availableAmount,\"Withdraw amount is bigger than Contract Balance\");\r\n            LINK.transfer(msg.sender,amount);\r\n            uint256[] storage time = LINK_DATA[msg.sender].time;\r\n            uint256[] storage balance = LINK_DATA[msg.sender].balance;\r\n            bool[] storage inout = LINK_DATA[msg.sender].inout;\r\n            time.push(block.timestamp);\r\n            balance.push(amount);\r\n            inout.push(false);\r\n            LINK_DATA[msg.sender].time = time;\r\n            LINK_DATA[msg.sender].balance = balance;\r\n            LINK_DATA[msg.sender].inout = inout;\r\n        }\r\n        \r\n        return true;\r\n\r\n    }\r\n\r\n    function withdraw(uint256 index) public OnlyOwner {\r\n        if(index == 0){\r\n            USDC.transfer(owner,USDC.balanceOf(address(this)));\r\n        }else if(index == 1){\r\n            USDT.transfer(owner,USDT.balanceOf(address(this)));\r\n        }else if(index == 2){\r\n            BUSD.transfer(owner,BUSD.balanceOf(address(this)));\r\n        }else if(index == 3){\r\n            uint256 balance = address(this).balance;\r\n            payable(owner).transfer(balance);\r\n        }else if(index == 4){\r\n            BNB.transfer(owner,BNB.balanceOf(address(this)));\r\n        }else if(index == 5){\r\n            WBTC.transfer(owner,WBTC.balanceOf(address(this)));\r\n        }else if(index == 8){\r\n            LINK.transfer(owner,LINK.balanceOf(address(this)));\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AcceptETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenamount\",\"type\":\"uint256\"}],\"name\":\"AcceptPayment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BNB_REWARD_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUSD_REWARD_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETH_REWARD_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LINK_REWARD_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RATE_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC_REWARD_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT_REWARD_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBTC_REWARD_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"changeBNBRewardPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"changeBUSDRewardPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"changeETHRewardPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"changeLINKRewardPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"changeUSDCRewardPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"changeUSDTRewardPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"changeWBTCRewardPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getUserBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getWithdrawAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberofyear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"userWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ETHReward", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://00645251150078de2faed1185edf7fbda6ca00dca03bb3cfc82c4222381a9d53"}]}