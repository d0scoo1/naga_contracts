{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/merge/Anime2Merger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n//        ___       ___                    ___           ___                       ___           ___     \\n//       /\\\\__\\\\     /\\\\  \\\\                  /\\\\  \\\\         /\\\\__\\\\          ___        /\\\\__\\\\         /\\\\  \\\\    \\n//      /:/  /    /::\\\\  \\\\                /::\\\\  \\\\       /::|  |        /\\\\  \\\\      /::|  |       /::\\\\  \\\\   \\n//     /:/  /    /:/\\\\:\\\\  \\\\              /:/\\\\:\\\\  \\\\     /:|:|  |        \\\\:\\\\  \\\\    /:|:|  |      /:/\\\\:\\\\  \\\\  \\n//    /:/  /    /::\\\\~\\\\:\\\\  \\\\            /::\\\\~\\\\:\\\\  \\\\   /:/|:|  |__      /::\\\\__\\\\  /:/|:|__|__   /::\\\\~\\\\:\\\\  \\\\ \\n//   /:/__/    /:/\\\\:\\\\ \\\\:\\\\__\\\\          /:/\\\\:\\\\ \\\\:\\\\__\\\\ /:/ |:| /\\\\__\\\\  __/:/\\\\/__/ /:/ |::::\\\\__\\\\ /:/\\\\:\\\\ \\\\:\\\\__\\\\\\n//   \\\\:\\\\  \\\\    \\\\:\\\\~\\\\:\\\\ \\\\/__/          \\\\/__\\\\:\\\\/:/  / \\\\/__|:|/:/  / /\\\\/:/  /    \\\\/__/~~/:/  / \\\\:\\\\~\\\\:\\\\ \\\\/__/\\n//    \\\\:\\\\  \\\\    \\\\:\\\\ \\\\:\\\\__\\\\                 \\\\::/  /      |:/:/  /  \\\\::/__/           /:/  /   \\\\:\\\\ \\\\:\\\\__\\\\  \\n//     \\\\:\\\\  \\\\    \\\\:\\\\ \\\\/__/                 /:/  /       |::/  /    \\\\:\\\\__\\\\          /:/  /     \\\\:\\\\ \\\\/__/  \\n//      \\\\:\\\\__\\\\    \\\\:\\\\__\\\\                  /:/  /        /:/  /      \\\\/__/         /:/  /       \\\\:\\\\__\\\\    \\n//       \\\\/__/     \\\\/__/                  \\\\/__/         \\\\/__/                     \\\\/__/         \\\\/__/    \\n\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nimport \\\"@rari-capital/solmate/src/utils/SSTORE2.sol\\\";\\n\\n\\n// interface of Le Anime V2 wrapper contract + IERC721Metadata\\ninterface IWrapper is IERC721Metadata {\\n\\n    function transferFromBatch(address from, address to, uint256[] calldata tokenId) external;\\n\\n}\\n\\n// interface for merger callback contract - for future implementation\\ninterface IMerger {\\n    function afterDeposit(uint256 heroId) external;\\n    function afterWithdrawAll(uint256 heroId) external;\\n    function afterWithdrawBatch(uint256 heroId) external;\\n    function afterMergeHeroes(uint256 mainHeroId, uint256 mergedHeroId) external;\\n\\n    function afterLayerDeposit(uint256 heroId) external;\\n    function afterLayerWithdrawal(uint256 heroId) external;\\n}\\n\\n// Merging Rules\\nstruct MergeParameters {\\n    uint256[] rankThresholds; // Hero levels thresholds\\n\\n    mapping(uint256 => uint256) additionalExtrasForRank; // number of additional extra slots for Hero Level\\n    mapping(uint256 => mapping(uint256 => uint256[])) traitsLevelsCut; // traits levels thresholds\\n}\\n\\n// Hero Storage of Traits and Parameters\\nstruct heroParams { \\n    uint32 score; // max score of merged heroes is 255*10627*20 = 54'197'700 and uint32 is 4'294'967'295\\n    uint32 extraScore; //same as above for additional scoring\\n\\n    uint16 imageIdx; // image displayed - max is 10627 variants - uint16 is 65536\\n    uint8 visibleBG; // max is 255 - this is the full colour BG overlay\\n    bool state; // anime&spirits vs hero state\\n    bool locked; // locker \\n    \\n    bytes params; // hero traits\\n    bytes upper; // hero more traits\\n    bytes extraLayers; // additional layers\\n    bytes[] moreParams; // more additional layers\\n}\\n\\n///////////////////////\\n// LOCKER CONTRACT\\n///////////////////////\\n\\ncontract SoulsLocker is Ownable {\\n\\n    event DepositedSouls(uint256 indexed heroId, uint256[] tokenId);\\n    event ReleasedAllSouls(uint256 indexed heroId);\\n    event ReleasedSouls(uint256 indexed heroId, uint256[] index);\\n    event MergedHeroes(uint256 indexed mainHeroId, uint256 indexed mergedHeroId);\\n\\n    uint256 private constant OFFSETAN2 = 100000;\\n\\n    // WRAPPER CONTRACT\\n    IWrapper public wrapper;\\n\\n    // MERGER CONTRACT - for callback implementation\\n    IMerger public merger;\\n\\n    // Is merger contract closed? allows to render that immutable\\n    bool public closedMergerUpdate = false;\\n\\n    // SOULS IN HERO\\n    mapping(uint256 => uint16[]) public soulsInHero;\\n\\n    // Max units that can be merged\\n    uint256 public maxMergeUnits = 1000;\\n\\n    // activate extra functionalities\\n    bool public isMergeHeroesActive = false;\\n\\n    bool public isMergeHeroesBatchActive = false;\\n\\n    bool public isWithdrawSoulsBatchActive = false;\\n\\n    // EMERGENCY RECOVER FUNCTION TO BE REVOKED\\n    bool public emergencyRevoked = false;\\n\\n    constructor(address wrapperAddress_) {\\n        wrapper = IWrapper(wrapperAddress_);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ADMIN FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function updateMerger(address mergerAddress_) external onlyOwner {\\n        require(!closedMergerUpdate, \\\"Update Closed\\\");\\n        merger = IMerger(mergerAddress_);\\n    }\\n\\n    function closeUpdateMerger() external onlyOwner {\\n        closedMergerUpdate = true;\\n    }\\n\\n    function changeMaxMergeUnits(uint256 maxMergeUnits_) external onlyOwner {\\n        require(!closedMergerUpdate, \\\"Update Closed\\\");\\n        maxMergeUnits = maxMergeUnits_;\\n    }\\n\\n    function activateMergeHeroes() external onlyOwner {\\n        isMergeHeroesActive = true;\\n    }\\n\\n    function activateMergeHeroesBatch() external onlyOwner {\\n        isMergeHeroesBatchActive = true;\\n    }\\n\\n    function activateWithdrawSoulBatch() external onlyOwner {\\n        isWithdrawSoulsBatchActive = true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            EMERGENCY FUNCTION\\n    //////////////////////////////////////////////////////////////*/\\n\\n    \\n    // revokes the temporary emergency function - only owner can trigger it and will be disabled in the future\\n    function revokeEmergency() external onlyOwner  {\\n        emergencyRevoked = true;\\n    }\\n\\n    // *** EMERGENCY FUNCTION *** emergency withdrawal to recover stuck ERC721 sent to the contract\\n    function emergencyRecoverBatch(address to, uint256[] calldata tokenId) external onlyOwner {\\n        require(emergencyRevoked == false, \\\"Emergency power revoked\\\");\\n\\n        wrapper.transferFromBatch(address(this), to, tokenId);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            STORAGE GETTERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function getSoulsInHero(uint256 heroId) external view returns (uint16[] memory) {\\n        return soulsInHero[heroId];\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            DEPOSIT/WITHDRAW\\n    //////////////////////////////////////////////////////////////*/\\n\\n    // deposit only Souls And Spirits into Main token\\n    function depositSoulsBatch(uint256 heroId, uint256[] calldata tokenId) external {\\n        \\n        require(msg.sender == wrapper.ownerOf(heroId + OFFSETAN2), \\\"Not the owner\\\");\\n\\n        uint256 totalHeroLength = soulsInHero[heroId].length + 1;\\n\\n        require(totalHeroLength + tokenId.length <= maxMergeUnits, \\\"Max units: 1000\\\");\\n\\n        // Max id mintable in anime contract is 110627 so (max - OFFSETAN2) is 10627\\n        wrapper.transferFromBatch(msg.sender, address(this), tokenId);\\n\\n        uint16 currTokenId;\\n\\n        for (uint256 i = 0; i < tokenId.length ; i++){\\n\\n            currTokenId = uint16(tokenId[i] - OFFSETAN2);\\n\\n            require(heroId != currTokenId, \\\"Cannot add itself\\\");\\n            require(soulsInHero[currTokenId].length == 0, \\\"Cannot add a hero\\\");\\n\\n            soulsInHero[heroId].push(currTokenId);  \\n            \\n        }\\n\\n        // call function after deposit - future implementation\\n        if (address(merger) != address(0)) {\\n            merger.afterDeposit(heroId);\\n        }\\n\\n        emit DepositedSouls(heroId, tokenId);\\n        \\n    }\\n\\n    // deposit Souls, Spirits and Heroes into Main token - activate later\\n    function depositSoulsBatchHeroes(uint256 heroId, uint256[] calldata tokenId) external {\\n        require(isMergeHeroesBatchActive, \\\"Hero batch merge not active\\\");\\n        \\n        // check if caller is the owner of the hero\\n        require(msg.sender == wrapper.ownerOf(heroId + OFFSETAN2), \\\"Not the owner\\\");\\n\\n        // batch transfer tokens into this contract\\n        wrapper.transferFromBatch(msg.sender, address(this), tokenId);\\n\\n        // store variable for the temporary current token id to add to the hero\\n        uint16 currTokenId;\\n\\n        for (uint256 i = 0; i < tokenId.length ; i++){\\n            currTokenId = uint16(tokenId[i] - OFFSETAN2);\\n\\n            // check hero is not adding itself\\n            require(heroId != currTokenId, \\\"Cannot add itself\\\");\\n            \\n            // check if the token to add contains already tokens or not\\n            // if not simply add token, else process internal tokens\\n\\n            if (soulsInHero[currTokenId].length == 0) {\\n\\n                soulsInHero[heroId].push(currTokenId); \\n            }\\n            else {\\n                // process hero into hero\\n                // add main hero token - this one is outside the contract\\n                soulsInHero[heroId].push(currTokenId); \\n\\n                // adds the internal tokens already in the contract, into the new hero\\n                uint16[] memory currentSouls = soulsInHero[currTokenId];\\n\\n                // add all internal tokens to new hero and counts length\\n                for (uint256 j = 0; j < currentSouls.length ; j++){\\n                    soulsInHero[heroId].push(currentSouls[j]);\\n                }\\n                \\n                // clears the added hero\\n                delete soulsInHero[currTokenId];\\n                \\n            }\\n\\n        }\\n\\n        // check the hero is not larger than max units\\n        require(soulsInHero[heroId].length + 1 <= maxMergeUnits, \\\"Max units: 1000\\\");\\n        \\n        // callback function after deposit\\n        if (address(merger) != address(0)) {\\n            merger.afterDeposit(heroId);\\n        }\\n\\n        emit DepositedSouls(heroId, tokenId);  \\n    }\\n\\n    // Withdraw all the tokens from main token\\n    function withdrawSoulsBatchAll(uint256 heroId) external {\\n\\n        // check caller is the Hero owner\\n        require(msg.sender == wrapper.ownerOf(heroId + OFFSETAN2), \\\"Not the owner\\\");\\n        \\n        uint16[] memory soulsToWithdraw = soulsInHero[heroId];\\n\\n        // transfer all the souls out\\n        for (uint256 i = 0; i < soulsToWithdraw.length; i++) {\\n            wrapper.transferFrom(address(this), msg.sender, soulsToWithdraw[i] + OFFSETAN2);\\n        }\\n\\n        //removes the list of locked souls\\n        delete soulsInHero[heroId];\\n\\n        // callback - for future implementation\\n        if (address(merger) != address(0)) {\\n            merger.afterWithdrawAll(heroId);\\n        }\\n\\n        emit ReleasedAllSouls(heroId);\\n    }\\n\\n    function withdrawSoulsBatch(uint256 heroId, uint256[] calldata index) external {\\n        require(isWithdrawSoulsBatchActive, \\\"Batch withdrawal not active\\\");\\n        // check the  caller is the hero owner\\n        require(msg.sender == wrapper.ownerOf(heroId + OFFSETAN2), \\\"Not the owner\\\");\\n\\n        // pointer to storage for easy access\\n        uint16[] storage array = soulsInHero[heroId];\\n\\n        wrapper.transferFrom(address(this), msg.sender, array[index[0]] + OFFSETAN2);\\n        \\n        array[index[0]] = array[array.length - 1];\\n        array.pop();\\n\\n        for (uint256 i = 1; i < index.length; i++) {\\n\\n            // makes sure the indexes are in descending order \\n            require(index[i] < index[i - 1], \\\"not in descending order\\\");\\n\\n            // first transfer\\n            wrapper.transferFrom(address(this), msg.sender, array[index[i]] + OFFSETAN2);\\n\\n            array[index[i]] = array[array.length - 1];\\n            array.pop();\\n        }\\n\\n        //cALLBACK\\n        if (address(merger) != address(0)) {\\n            merger.afterWithdrawBatch(heroId);\\n        }\\n\\n        emit ReleasedSouls(heroId, index);\\n    }\\n\\n    // merge hero 2 into hero 1 - activate later\\n    function mergeHeroes(uint256 mainHeroId, uint256 mergedHeroId) external {\\n        require(isMergeHeroesActive, \\\"Hero merge not active\\\");\\n        require(mainHeroId != mergedHeroId, \\\"Cannot add itself\\\");\\n\\n        require(msg.sender == wrapper.ownerOf(mainHeroId + OFFSETAN2), \\\"Not the owner\\\");\\n        require(msg.sender == wrapper.ownerOf(mergedHeroId + OFFSETAN2), \\\"Not the owner\\\");\\n\\n        uint16[] storage mainHeroSouls = soulsInHero[mainHeroId];\\n\\n        uint16[] memory mergedHeroSouls = soulsInHero[mergedHeroId];\\n\\n        require(mainHeroSouls.length + 1 + mergedHeroSouls.length + 1 <= maxMergeUnits, \\\"Max units: 1000\\\");\\n\\n        // transfer the mergedHero token\\n        wrapper.transferFrom(msg.sender, address(this), mergedHeroId + OFFSETAN2);\\n\\n        // adds the mergedHero token\\n        mainHeroSouls.push(uint16(mergedHeroId));\\n\\n        // adds tokens inside mergedHero token - already locked\\n        for (uint256 i = 0; i < mergedHeroSouls.length ; i++){ \\n            mainHeroSouls.push(mergedHeroSouls[i]);\\n        }\\n\\n        // delete token list in mergedHero\\n        delete soulsInHero[mergedHeroId];\\n\\n        // After Merge Callback - future implementation\\n        if (address(merger) != address(0)) {\\n            merger.afterMergeHeroes(mainHeroId, mergedHeroId);\\n        }\\n\\n    }\\n}\\n\\n///////////////////////\\n// HERO DATA CONTRACT\\n///////////////////////\\n\\ncontract HeroDataStorage is Ownable {\\n\\n    event NewHeroData(uint256 indexed heroId, heroParams newParams);\\n\\n    uint256 private constant OFFSETAN2 = 100000;\\n\\n    // WRAPPER CONTRACT\\n    IWrapper public wrapper;\\n\\n    // MERGER CONTRACT ADDRESS\\n    address public mergerAddress;\\n\\n    // merger contract update closed?\\n    bool public closedMergerUpdate = false;\\n\\n    // HERO STORAGE\\n    heroParams[10628] public dataHero;\\n\\n    constructor(address wrapperAddress_) {\\n        \\n        wrapper = IWrapper(wrapperAddress_);\\n\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ADMIN FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function updateMerger(address mergerAddress_) external onlyOwner {\\n        require(!closedMergerUpdate, \\\"Update Closed\\\");\\n        mergerAddress = mergerAddress_;    \\n    }\\n\\n    function closeUpdateMerger() external onlyOwner {\\n        closedMergerUpdate = true;\\n    }\\n\\n    \\n    /*///////////////////////////////////////////////////////////////\\n                                GETTERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function getData(uint256 heroId) external view returns (heroParams memory) {\\n        return dataHero[heroId];\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                SETTERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    //this function will be used by the merge contracts to set data\\n    function setData(uint256 heroId, heroParams calldata newHeroData) external { \\n        require(msg.sender == mergerAddress, \\\"Not allowed - only merger\\\");\\n        dataHero[heroId] = newHeroData;\\n\\n        emit NewHeroData(heroId, dataHero[heroId]);\\n    }\\n\\n    //this functions will be used by the hero owner to set data\\n    function setDataOwner(uint256 heroId, bytes calldata params_) external { \\n        require(msg.sender == wrapper.ownerOf(heroId + OFFSETAN2), \\\"Not the owner\\\");\\n\\n        dataHero[heroId].params = params_;\\n\\n        emit NewHeroData(heroId, dataHero[heroId]);\\n\\n    }\\n\\n    function setDataOwner(uint256 heroId, bytes calldata params_, uint8 bg_) external { \\n        require(msg.sender == wrapper.ownerOf(heroId + OFFSETAN2), \\\"Not the owner\\\");\\n\\n        dataHero[heroId].params = params_;\\n\\n        dataHero[heroId].visibleBG = bg_;\\n\\n        emit NewHeroData(heroId, dataHero[heroId]);\\n\\n    }\\n\\n    function setDataOwner(uint256 heroId, bytes calldata params_, uint16 image_, uint8 bg_) external { \\n        require(msg.sender == wrapper.ownerOf(heroId + OFFSETAN2), \\\"Not the owner\\\");\\n\\n        dataHero[heroId].params = params_;\\n\\n        dataHero[heroId].imageIdx = image_;\\n\\n        dataHero[heroId].visibleBG = bg_;\\n\\n        emit NewHeroData(heroId, dataHero[heroId]);\\n\\n    }\\n\\n    function setDataOwner(uint256 heroId, bytes[3] calldata heroP_, uint16 image_, uint8 bg_) external { \\n        require(msg.sender == wrapper.ownerOf(heroId + OFFSETAN2), \\\"Not the owner\\\");\\n\\n        dataHero[heroId].params = heroP_[0];\\n        dataHero[heroId].extraLayers = heroP_[1];\\n        dataHero[heroId].upper = heroP_[2];\\n\\n        dataHero[heroId].imageIdx = image_;\\n        dataHero[heroId].visibleBG = bg_;\\n\\n        emit NewHeroData(heroId, dataHero[heroId]);\\n\\n    }\\n\\n    function setDataOwner(uint256 heroId, heroParams calldata newHeroData) external { \\n        require(msg.sender == wrapper.ownerOf(heroId + OFFSETAN2), \\\"Not the owner\\\");\\n\\n        dataHero[heroId] = newHeroData;\\n\\n        emit NewHeroData(heroId, dataHero[heroId]);\\n    }\\n  \\n}\\n\\n///////////////////////\\n// MERGE DATA CONTRACTS\\n///////////////////////\\n\\ncontract StoreCharacters is Ownable {\\n\\n    // ANIME / SPIRITS - METADATA STORAGE IN A CONTRACT\\n    address[] public pointers;\\n\\n    // is the contract closed to modify souls and spirits data?\\n    bool public closedCharacters = false;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        ADMIN FUNCTIONS MERGE\\n    //////////////////////////////////////////////////////////////*/\\n    \\n    function closeCharacters() external onlyOwner  {\\n        closedCharacters = true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       STORE METADATA IN CONTRACTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setTraitsBytes(bytes calldata params) external onlyOwner {\\n            require(!closedCharacters, \\\"Closed\\\");\\n            pointers.push(SSTORE2.write(params));   \\n    }\\n\\n    function setPointers(address[] calldata pointersList) external onlyOwner {\\n        require(!closedCharacters, \\\"Closed\\\");\\n        pointers = pointersList;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       READ METADATA FROM CONTRACTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function getTraitsData(uint256 pointerId) external view returns (bytes memory) {\\n        return SSTORE2.read(pointers[pointerId]);\\n    }\\n\\n    function getCharTraits(uint256 tokenId) external view returns (bytes memory) {\\n        //you can save 3000 tokens traits per contract\\n        uint256 pointer = (tokenId - 1) / 3000;\\n        uint256 idx = (tokenId - 1) % 3000 * 8;\\n        return SSTORE2.read(pointers[pointer], idx, idx + 8);\\n    }\\n\\n    function getCharTraitsUInt8(uint256 tokenId) external view returns (uint8[8] memory) {\\n        uint256 pointer = (tokenId - 1) / 3000;\\n        uint256 idx = (tokenId - 1) % 3000 * 8;\\n        bytes memory temp =  SSTORE2.read(pointers[pointer], idx, idx + 8);\\n        \\n        return [\\n            uint8(temp[0]), uint8(temp[1]), uint8(temp[2]), uint8(temp[3]), \\n            uint8(temp[4]), uint8(temp[5]), uint8(temp[6]), uint8(temp[7])\\n            ];\\n    }\\n\\n}\\n\\ncontract LeAnimeV2MergerLAB is StoreCharacters {\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    // SETTING MERGE CONSTANTS\\n    uint256 private constant OFFSETAN2 = 100000;\\n\\n    // MERGE PARAMETERS\\n    MergeParameters private mergeP;\\n\\n    bool public mergeActive;\\n\\n    // WRAPPER CONTRACT\\n    IWrapper public wrapper;\\n\\n    // SOULS LOCKER\\n    SoulsLocker public locker;\\n\\n    // HERO STORAGE \\n    HeroDataStorage public heroStorage;\\n    \\n    constructor(address wrapperAddr) {  \\n        wrapper = IWrapper(wrapperAddr);\\n       \\n        mergeP.rankThresholds = [1,30,70,170,390,800,1500,2000,2500,2900,6000,10000,15000,20000,25000];\\n        \\n        // Set additionalExtrasForRank slots -  mapping(uint256 => uint256)\\n        mergeP.additionalExtrasForRank[0] = 0;\\n        mergeP.additionalExtrasForRank[1] = 1;\\n        mergeP.additionalExtrasForRank[2] = 1;\\n        mergeP.additionalExtrasForRank[3] = 2;\\n        mergeP.additionalExtrasForRank[4] = 2;\\n        mergeP.additionalExtrasForRank[5] = 3;\\n        mergeP.additionalExtrasForRank[6] = 3;\\n        mergeP.additionalExtrasForRank[7] = 3;\\n        mergeP.additionalExtrasForRank[8] = 4;\\n        mergeP.additionalExtrasForRank[9] = 4;\\n        mergeP.additionalExtrasForRank[10] = 4;\\n        mergeP.additionalExtrasForRank[11] = 5;\\n        mergeP.additionalExtrasForRank[12] = 5;\\n        mergeP.additionalExtrasForRank[13] = 5;\\n        mergeP.additionalExtrasForRank[14] = 6;\\n        \\n        // extra levels thresholds\\n        mergeP.traitsLevelsCut[7][0] = [1]; // 0 invisible\\n        mergeP.traitsLevelsCut[7][1] = [1,4,7,14,27,53,103,201]; // 1 book\\n        mergeP.traitsLevelsCut[7][2] = [1,5,12,28,64]; // 2 sword\\n        mergeP.traitsLevelsCut[7][3] = [1,6,16,39,98]; // 3 laurel\\n        mergeP.traitsLevelsCut[7][4] = [1,4,9,18,36,74,152,312]; // 4 heart\\n        mergeP.traitsLevelsCut[7][5] = [1,4,7,13,25,47,89,170,323,613]; // 5 skull\\n        mergeP.traitsLevelsCut[7][6] = [1,4,8,17,35,72,147,300]; // 6 lyre\\n        mergeP.traitsLevelsCut[7][7] = [1,4,8,15,30,58,115,227,447]; // 7 crystal\\n        mergeP.traitsLevelsCut[7][8] = [1]; // 8 upOnly\\n        mergeP.traitsLevelsCut[7][9] = [1]; // 9 69\\n        mergeP.traitsLevelsCut[7][10] = [1]; // 10 777\\n        mergeP.traitsLevelsCut[7][11] = [1]; // Lightsaber\\n        mergeP.traitsLevelsCut[7][12] = [1]; // Gold Book\\n        mergeP.traitsLevelsCut[7][13] = [1]; // Gold Bow\\n        mergeP.traitsLevelsCut[7][14] = [1]; // Gold Lyre\\n        mergeP.traitsLevelsCut[7][15] = [1]; // Gold Scyte\\n        mergeP.traitsLevelsCut[7][16] = [1]; // Gold Staff\\n        mergeP.traitsLevelsCut[7][17] = [1]; // Gold Sword\\n        mergeP.traitsLevelsCut[7][18] = [1]; // Gold Wings\\n        mergeP.traitsLevelsCut[7][19] = [1]; // 420 special!\\n            \\n    \\n        // runes levels thresholds    \\n        mergeP.traitsLevelsCut[6][0] = [1]; // 0 invisible\\n        mergeP.traitsLevelsCut[6][1] = [1,3,6,11,21,39,71,131,242,445]; // 1 fish\\n        mergeP.traitsLevelsCut[6][2] = [1,3,5,10,17,30,52,92,162,285]; // 2 R\\n        mergeP.traitsLevelsCut[6][3] = [1,3,6,10,18,33,59,105,189,338]; // 3 I\\n        mergeP.traitsLevelsCut[6][4] = [1,3,6,12,22,41,77,143,266,496]; // 4 Mother\\n        mergeP.traitsLevelsCut[6][5] = [1,3,5,9,15,26,45,77,132,227]; // 5 Up Only\\n        mergeP.traitsLevelsCut[6][6] = [1,3,5,8,14,23,39,67,112,190]; // 6 Burning S\\n        mergeP.traitsLevelsCut[6][7] = [1]; // 7 Daemon Face\\n        mergeP.traitsLevelsCut[6][8] = [1]; // 8 Up Only fish\\n        mergeP.traitsLevelsCut[6][9] = [1,3,4,7,11,18,29,47,77,124]; // 9 roman\\n        mergeP.traitsLevelsCut[6][10] = [1,2,4,6,10,16,25,39,61,97]; // 10 hieroglyphs\\n        mergeP.traitsLevelsCut[6][11] = [1]; // Andrea  \\n        mergeP.traitsLevelsCut[6][12] = [1]; // gm\\n        mergeP.traitsLevelsCut[6][13] = [1]; // Loom\\n        mergeP.traitsLevelsCut[6][14] = [1]; // path\\n        mergeP.traitsLevelsCut[6][15] = [1]; // Abana\\n    }\\n\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        ADMIN FUNCTIONS MERGE\\n    //////////////////////////////////////////////////////////////*/\\n    \\n    // set the SoulsLocker and HeroDataStorage modules\\n    function setupModules(address locker_, address heroStorage_) external onlyOwner {\\n        locker = SoulsLocker(locker_);\\n        \\n        heroStorage = HeroDataStorage(heroStorage_);\\n    }\\n\\n    function activateMerge() external onlyOwner  {\\n        mergeActive = true;\\n    }\\n\\n    function activateMergeLABMaster() external {\\n        require(callerIsLabMaster(), \\\"Not the L.A.B Master\\\");\\n        mergeActive = true;\\n    }\\n\\n    function callerIsLabMaster() public view returns (bool) {\\n        // gets owner of The L.A.B. from SuperRare contract\\n        address labMaster = IERC721Metadata(0xb932a70A57673d89f4acfFBE830E8ed7f75Fb9e0).ownerOf(28554);\\n        return (labMaster == msg.sender);\\n    }\\n\\n    // Get and Set Merge parameters functions\\n    function getRankThresholds() external view returns (uint256[] memory) {\\n        return mergeP.rankThresholds;\\n    }\\n\\n    function setRankThresholds(uint256[] calldata newRanks) external onlyOwner {\\n        mergeP.rankThresholds = newRanks;\\n    }\\n\\n    function getTraitsLevelsCut(uint256 idx1, uint256 idx2) external view returns (uint256[] memory) {\\n        return mergeP.traitsLevelsCut[idx1][idx2];\\n    }\\n\\n    function setTraitsLevelsCut(uint256 idx1, uint256 idx2, uint256[] calldata traitsCuts) external onlyOwner {\\n        mergeP.traitsLevelsCut[idx1][idx2] = traitsCuts;\\n    }\\n\\n    function getAdditionalExtras(uint256 idx1) external view returns (uint256) {\\n        return mergeP.additionalExtrasForRank[idx1];\\n    }\\n\\n    function setAdditionalExtras(uint256 idx1, uint256 additionalSlots) external onlyOwner {\\n        mergeP.additionalExtrasForRank[idx1] = additionalSlots;\\n    }\\n    \\n    /*///////////////////////////////////////////////////////////////\\n                        CHECK HERO FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function checkParamsValidity(\\n        uint256 heroId,\\n        uint16[] memory tokenId,\\n        bytes memory params\\n    )   public view returns (uint256)\\n    {   \\n        // merge is not active yet\\n        if (mergeActive == false) {\\n            return 0;\\n        }\\n        \\n        //makes sure the params encoding is valid\\n        if (params.length < 10 || params.length % 2 != 0) { \\n            return 0; // not a valid hero\\n        }\\n\\n        // block to check for extra duplicates - doing it at the beginning to avoid computing more if this fails\\n        {\\n            bytes memory usedExtras = new bytes(7);\\n                \\n            usedExtras[0] = params[8]; //first extra\\n\\n            \\n            //returns false if additional there is a duplicate extra\\n            for (uint256 i = 10; i < params.length; i+=2) {\\n                for (uint256 j = 0; j < (i-8)/2; j++) {\\n                    if (params[i] == usedExtras[j]) { \\n                        return 0; //false\\n                    }\\n                }\\n                usedExtras[(i-8)/2] = params[i];   \\n            }\\n        }\\n\\n        \\n        uint256 totScore;\\n\\n        //number of additional extras:\\n        uint256 addExtraSlots = (params.length - 10)/2;\\n\\n        uint256[] memory rarityCount = new uint256[](7 + addExtraSlots);\\n\\n        \\n        //block to count traits\\n        {\\n            // load Allcharacters from on chain contracts in one go\\n            bytes[4] memory allData = [\\n                SSTORE2.read(pointers[0]), \\n                SSTORE2.read(pointers[1]), \\n                SSTORE2.read(pointers[2]), \\n                SSTORE2.read(pointers[3])\\n            ];\\n            \\n            //count the heroId first\\n            uint256 idx = (heroId - 1) % 3000 * 8;\\n            uint256 ptr = (heroId - 1) / 3000;\\n\\n            // checks anime vs spirit multiplier\\n            uint256 multiplier = heroId <= 1573 ? 20 : 1;\\n\\n            //starts the count with the token associated with heroId\\n            totScore += uint8(allData[ptr][idx]) * multiplier;\\n\\n            if (allData[ptr][idx+1] == params[1]) { // skin\\n                rarityCount[0] += multiplier;\\n            }\\n            if (allData[ptr][idx+2] == params[2]) { // clA\\n                rarityCount[1] += multiplier;\\n            }\\n            if (allData[ptr][idx+3] == params[3]) { // clB\\n                rarityCount[2] += multiplier;\\n            }\\n            if (allData[ptr][idx+4] == params[4]) { // bg\\n                rarityCount[3] += multiplier;\\n            }\\n            if (allData[ptr][idx+5] == params[5]) { // halo\\n                rarityCount[4] += multiplier;\\n            }\\n            if (allData[ptr][idx+6] == params[6]) { // runes\\n                rarityCount[5] += multiplier;\\n            }\\n            if (allData[ptr][idx+7] == params[8]) { // extra\\n                rarityCount[6] += multiplier;\\n            }\\n            \\n            // additional extras\\n            for (uint256 j = 0;  j < addExtraSlots; j++) {\\n                    if (allData[ptr][idx+7] == params[j*2 + 10]) {\\n                        rarityCount[j + 7] += multiplier;\\n                    }\\n                    \\n            }\\n            \\n            \\n            for (uint256 i = 0; i < tokenId.length ; i++){\\n        \\n                idx = (tokenId[i] - 1) % 3000 * 8;\\n                ptr = (tokenId[i] - 1) / 3000;\\n\\n                multiplier = tokenId[i] <= 1573 ? 20 : 1;\\n\\n                totScore += uint8(allData[ptr][idx]) * multiplier;\\n\\n                if (allData[ptr][idx+1] == params[1]) { // skin\\n                    rarityCount[0] += multiplier;\\n                }\\n                if (allData[ptr][idx+2] == params[2]) { // clA\\n                    rarityCount[1] += multiplier;\\n                }\\n                if (allData[ptr][idx+3] == params[3]) { // clB\\n                    rarityCount[2] += multiplier;\\n                }\\n                if (allData[ptr][idx+4] == params[4]) { // bg\\n                    rarityCount[3] += multiplier;\\n                }\\n                if (allData[ptr][idx+5] == params[5]) { // halo\\n                    rarityCount[4] += multiplier;\\n                }\\n                if (allData[ptr][idx+6] == params[6]) { // runes\\n                    rarityCount[5] += multiplier;\\n                }\\n                if (allData[ptr][idx+7] == params[8]) { // extra\\n                    rarityCount[6] += multiplier;\\n                }\\n                \\n                // additional extras - if any\\n                for (uint256 j = 0;  j < addExtraSlots; j++) { \\n                        if (allData[ptr][idx+7] == params[j*2 + 10]) {\\n                            rarityCount[j + 7] += multiplier;\\n                        }     \\n                }\\n                    \\n\\n            }\\n        }\\n\\n        //check that rank is valid - not above the MAX rank possible at the time\\n        if (uint8(params[0]) >= mergeP.rankThresholds.length) {\\n            return 0; //false\\n        }\\n\\n        //check if rarity sum of souls is enough to match the rank of the requested hero\\n        if (totScore < mergeP.rankThresholds[uint8(params[0])]) {\\n            return 0; //false\\n        }\\n\\n        // block that finds the max rank possible for the current total score\\n        // need to know to allocate the right nr of extras\\n        {\\n            uint8 maxRank = uint8(params[0]);\\n\\n            for (uint8 i = uint8(params[0]); i < mergeP.rankThresholds.length; i++) {\\n                if (totScore >= mergeP.rankThresholds[i]) {\\n                    maxRank = i;\\n                }\\n            }\\n            \\n            //check that add extra slots are not more than the allowed ones for the rank\\n            if (addExtraSlots > mergeP.additionalExtrasForRank[maxRank]) {\\n                return 0;\\n            }\\n        }\\n        \\n\\n        // block that checks that the level of the extras are allowed\\n        {\\n            uint256 levelCut;\\n            \\n            //cycle through traits with no leveling up (skin to halo)\\n            for (uint256 i = 1; i <= 5; i++) { \\n                //check that there is at least one occurence of the trait or return 0\\n                if (rarityCount[i-1] == 0) {\\n                    return 0;\\n                }\\n            }\\n\\n            //check that runes level is valid - not above the MAX level possible for the specific rune\\n            if (uint8(params[7]) >= mergeP.traitsLevelsCut[6][uint8(params[6])].length) {\\n                return 0; //false\\n            }\\n\\n            // checks runes (leveling up and not)\\n            if (mergeP.traitsLevelsCut[6][uint8(params[6])].length > 1) {\\n                    levelCut = mergeP.traitsLevelsCut[6][uint8(params[6])][uint8(params[7])];\\n                    \\n                    //check if you have enough points on this trait\\n                    if (rarityCount[5] < levelCut) { \\n                       return 0;\\n                    }                  \\n                    \\n            }\\n            else { //this is for unique traits that are not possible to level up \\n                //check that the level is 0 and that there is one available\\n                if (rarityCount[5] == 0 || params[7] > 0) {\\n                    return 0;\\n                }\\n            }\\n\\n\\n            //cycle through extras with possible leveling up \\n            for (uint256 i = 0; i < 1 + addExtraSlots; i++) {\\n                uint256 slotIdx = 8 + i * 2;\\n\\n                //check that extra level is valid - not above the MAX level possible for the specific extra\\n                if (uint8(params[slotIdx + 1]) >= mergeP.traitsLevelsCut[7][uint8(params[slotIdx])].length) {\\n                    return 0; //false\\n                }\\n                \\n                if (mergeP.traitsLevelsCut[7][uint8(params[slotIdx])].length > 1) {\\n                    levelCut = mergeP.traitsLevelsCut[7][uint8(params[slotIdx])][uint8(params[slotIdx + 1])];\\n                    \\n                    // check if you have enough points on this trait\\n                    if (rarityCount[i + 6] < levelCut) { \\n                       return 0;\\n                    }                  \\n                    \\n                }\\n                else { //this is for unique traits that are not possible to level up \\n                    //check that the level is 0 and that there is one available\\n                    if (rarityCount[i + 6] == 0 || params[slotIdx + 1] > 0) {\\n                        return 0;\\n                    }\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        // if all the checks pass you get here and return the totScore\\n        return totScore;\\n    }\\n\\n    function checkHeroValidity(uint256 heroId) external view returns (uint256){\\n        uint16[] memory soulsLocked = locker.getSoulsInHero(heroId);\\n       \\n        heroParams memory currentHero = heroStorage.getData(heroId);\\n        \\n        return checkParamsValidity(heroId, soulsLocked, currentHero.params);\\n\\n    }\\n\\n    function getHeroScore(uint256 heroId) external view returns (uint256){\\n        uint256 totScore;\\n        uint16[] memory tokenId = locker.getSoulsInHero(heroId);\\n\\n        // block to count score\\n        {\\n            // loadAllcharacters in one go\\n            bytes[4] memory allData = [\\n                SSTORE2.read(pointers[0]), \\n                SSTORE2.read(pointers[1]), \\n                SSTORE2.read(pointers[2]), \\n                SSTORE2.read(pointers[3])\\n            ];\\n\\n            //count the heroId first\\n            uint256 idx = (heroId - 1) % 3000 * 8;\\n            uint256 ptr = (heroId - 1) / 3000;\\n\\n            // checks anime vs spirit multiplier\\n            uint256 multiplier = heroId <= 1573 ? 20 : 1;\\n\\n            //starts the count with the token associated with heroId\\n            totScore += uint8(allData[ptr][idx]) * multiplier;\\n\\n            // add the score for each token contained\\n            for (uint256 i = 0; i < tokenId.length ; i++){\\n\\n                idx = (tokenId[i] - 1) % 3000 * 8;\\n                ptr = (tokenId[i] - 1) / 3000;\\n\\n                multiplier = tokenId[i] <= 1573 ? 20 : 1;\\n\\n                totScore += uint8(allData[ptr][idx]) * multiplier;\\n\\n            }\\n        }\\n\\n        return totScore;\\n    }\\n\\n}\\n\\n///////////////////////\\n// CUSTOM URI CONTRACT\\n///////////////////////\\n\\ninterface IMergerURI {\\n    function checkHeroValidity(uint256 heroId) external view returns (uint256);\\n}\\n\\ncontract TokenURICustom {\\n    // Merger Interface\\n    IMergerURI public merger;\\n\\n    // Hero Data Storage \\n    HeroDataStorage public heroStorage;\\n\\n    string public baseURI = \\\"https://leanime.art/heroes/metadata/\\\";\\n\\n    string public heroURI = \\\"https://api.leanime.art/heroes/metadata/\\\";\\n\\n    constructor(address mergerAddress_, address heroStorage_) {\\n        merger = IMergerURI(mergerAddress_);\\n        heroStorage = HeroDataStorage(heroStorage_);\\n    }\\n\\n    function constructTokenURI(uint256 tokenId) external view returns (string memory) {\\n        string memory str = \\\"H\\\";\\n\\n        uint256 heroId = tokenId - 100000;\\n        \\n        // minimal hero parameters\\n        uint256 score = merger.checkHeroValidity(heroId);\\n        \\n        if (score > 0) {\\n            str = string(abi.encodePacked(Strings.toString(heroId), \\\"S\\\" , Strings.toString(score), str));\\n            heroParams memory dataHero = heroStorage.getData(heroId);\\n            \\n            \\n            bytes memory params = dataHero.params;\\n\\n            for (uint256 i = 0; i < params.length; i++){\\n                str = string(abi.encodePacked(str, itoh8(uint8(params[i]))));\\n            }\\n            \\n            //fixed BG\\n            str = string(abi.encodePacked(str, \\\"G\\\"));\\n            str = string(abi.encodePacked(str, itoh8(dataHero.visibleBG)));\\n            \\n            \\n            str = string(abi.encodePacked(heroURI, str));\\n        }\\n        else {\\n            str = string(abi.encodePacked(baseURI, Strings.toString(tokenId)));\\n        }\\n        return str;\\n    }\\n    \\n    // convert uint8 into hex string\\n    function itoh8(uint8 x) private pure returns (string memory) {\\n        if (x > 0) {\\n            string memory str;\\n            \\n            str = string(abi.encodePacked(uint8(x % 16 + (x % 16 < 10 ? 48 : 87)), str));\\n            x /= 16;\\n            str = string(abi.encodePacked(uint8(x % 16 + (x % 16 < 10 ? 48 : 87)), str));\\n            \\n            return str;\\n        }\\n        return \\\"00\\\";\\n    }\\n\\n}\\n\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SSTORE2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Read and write to persistent storage at a fraction of the cost.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SSTORE2.sol)\\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\\nlibrary SSTORE2 {\\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               WRITE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function write(bytes memory data) internal returns (address pointer) {\\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\\n        bytes memory runtimeCode = abi.encodePacked(hex\\\"00\\\", data);\\n\\n        bytes memory creationCode = abi.encodePacked(\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            hex\\\"60_0B_59_81_38_03_80_92_59_39_F3\\\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\\n        );\\n\\n        assembly {\\n            // Deploy a new contract with the generated creation code.\\n            // We start 32 bytes into the code to avoid copying the byte length.\\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\\n        }\\n\\n        require(pointer != address(0), \\\"DEPLOYMENT_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               READ LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function read(address pointer) internal view returns (bytes memory) {\\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\\n    }\\n\\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n\\n        return readBytecode(pointer, start, pointer.code.length - start);\\n    }\\n\\n    function read(\\n        address pointer,\\n        uint256 start,\\n        uint256 end\\n    ) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n        end += DATA_OFFSET;\\n\\n        require(pointer.code.length >= end, \\\"OUT_OF_BOUNDS\\\");\\n\\n        return readBytecode(pointer, start, end - start);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function readBytecode(\\n        address pointer,\\n        uint256 start,\\n        uint256 size\\n    ) private view returns (bytes memory data) {\\n        assembly {\\n            // Get a pointer to some free memory.\\n            data := mload(0x40)\\n\\n            // Update the free memory pointer to prevent overriding our data.\\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\\n            // Adding 31 to size and running the result through the logic above ensures\\n            // the memory pointer remains word-aligned, following the Solidity convention.\\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\\n\\n            // Store the size of the data in the first 32 byte chunk of free memory.\\n            mstore(data, size)\\n\\n            // Copy the code into memory right after the 32 bytes we used to store the size.\\n            extcodecopy(pointer, add(data, 32), start, size)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@rari-capital/solmate/=lib/solmate/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\"\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mergerAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"heroStorage_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"constructTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"heroStorage\",\"outputs\":[{\"internalType\":\"contract HeroDataStorage\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"heroURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merger\",\"outputs\":[{\"internalType\":\"contract IMergerURI\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TokenURICustom", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000003121836fd30e13bb4e25f69a0d1deed2778748b0000000000000000000000002f6c681bbcdeb34d0d6788f258289d11587072ea", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}