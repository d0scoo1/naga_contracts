{"status": "1", "message": "OK", "result": [{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.12;\r\n\r\n/**\r\n * This is an interface of OwnershipInstructor\r\n * The goal of this contract is to allow people to integrate their contract into OwnershipChecker.sol\r\n * by generalising the obtention of the owner of NFTs.\r\n * The reason for this solution was because NFTs nowadays have standards, but not all NFTs support these standards.\r\n * The interface id for this is 0xb0f6fd7f;\r\n */\r\ninterface IOwnershipInstructor{\r\n\r\n/**\r\n * isValidInterface()\r\n * This function should be public and should be overriden.\r\n * It should obtain an address as input and should return a boolean value;\r\n * A positive result means the given address supports your contract's interface.\r\n * @dev This should be overriden and replaced with a set of instructions to check the given _impl if your contract's interface.\r\n * See ERC165 for help on interface support.\r\n * @param _impl address we want to check.\r\n * @return bool\r\n * \r\n */\r\n  function isValidInterface (address _impl) external view returns (bool);\r\n\r\n    /**\r\n    * This function should be public or External and should be overriden.\r\n    * It should obtain an address as implementation, a uint256 token Id and an optional _potentialOwner;\r\n    * It should return an address (or address zero is no owner);\r\n    * @dev This should be overriden and replaced with a set of instructions obtaining the owner of the given tokenId;\r\n    *\r\n    * @param _tokenId token id we want to grab the owner of.\r\n    * @param _impl Address of the NFT contract\r\n    * @param _potentialOwner (OPTIONAL) A potential owner, set address zero if no potentialOwner; Necessary for ERC1155\r\n    * @return a non zero address if the given tokenId has an owner; else if the token Id does not exist or has no owner, return zero address\r\n    * \r\n    */\r\n    function ownerOfTokenOnImplementation(address _impl,uint256 _tokenId,address _potentialOwner) external view  returns (address);\r\n}\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: contracts/CryptoPunkOwnershipInstructor.sol\r\n\r\n\r\ninterface ICryptoPunkContract {\r\n    function punkIndexToAddress(uint256) external view returns (address);\r\n}\r\n\r\n/**\r\n * Ownership Instructor Wrapper that wraps around the Cryptopunk contract,\r\n * It tells us if _impl is the cryptopunk contract and let's us standardise ownerOf;\r\n *\r\n * The goal of this contract is to allow people to integrate their contract into OwnershipChecker.sol\r\n * by generalising the obtention of the owner of NFTs.\r\n * The reason for this solution was because NFTs nowadays have standards, but not all NFTs support these standards.\r\n */\r\ncontract CryptoPunkOwnershipInstructor is IERC165,IOwnershipInstructor{\r\n    address immutable cryptopunk_impl = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\r\n    constructor(){\r\n    }\r\n\r\n/**\r\n * Checks if the given contract is the cryptopunk address\r\n * It should obtain an address as input and should return a boolean value;\r\n * @dev Contains a set of instructions to check the given _impl is the cryptopunk contract\r\n * @param _impl address we want to check.\r\n * @return bool\r\n * \r\n */\r\n    function isValidInterface (address _impl) public view override returns (bool){\r\n        return _impl == cryptopunk_impl;\r\n    }\r\n\r\n    /**\r\n    * See {OwnershipInstructor.sol}\r\n    * It should obtain a uint256 token Id as input and the address of the implementation \r\n    * It should return an address (or address zero is no owner);\r\n    *\r\n    * @param _tokenId token id we want to grab the owner of.\r\n    * @param _impl Address of the NFT contract\r\n    * @param _potentialOwner (OPTIONAL) A potential owner, set address zero if no potentialOwner;\r\n    * @return address\r\n    * \r\n    */\r\n    function ownerOfTokenOnImplementation(address _impl,uint256 _tokenId,address _potentialOwner) public view override returns (address){\r\n        require(isValidInterface(_impl),\"Invalid interface\");\r\n        return ICryptoPunkContract(_impl).punkIndexToAddress(_tokenId);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\r\n        return interfaceId == type(IOwnershipInstructor).interfaceId || interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"}],\"name\":\"isValidInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_potentialOwner\",\"type\":\"address\"}],\"name\":\"ownerOfTokenOnImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "CryptoPunkOwnershipInstructor", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ecd823e7ced13267af7e72df1fe5c864bdc625084b16a8e8f31afebf8e835195"}]}