{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n\r\npragma solidity >=0.8.9;\r\n\r\n/// @notice Emitted when the result overflows uint256.\r\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\r\n\r\n/// @notice Emitted when the result overflows uint256.\r\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\r\n\r\n/// @notice Emitted when one of the inputs is type(int256).min.\r\nerror PRBMath__MulDivSignedInputTooSmall();\r\n\r\n/// @notice Emitted when the intermediary absolute result overflows int256.\r\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\r\n\r\n/// @notice Emitted when the input is MIN_SD59x18.\r\nerror PRBMathSD59x18__AbsInputTooSmall();\r\n\r\n/// @notice Emitted when ceiling a number overflows SD59x18.\r\nerror PRBMathSD59x18__CeilOverflow(int256 x);\r\n\r\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\r\nerror PRBMathSD59x18__DivInputTooSmall();\r\n\r\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\r\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\r\n\r\n/// @notice Emitted when the input is greater than 133.084258667509499441.\r\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\r\n\r\n/// @notice Emitted when the input is greater than 192.\r\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\r\n\r\n/// @notice Emitted when flooring a number underflows SD59x18.\r\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\r\n\r\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\r\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\r\n\r\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\r\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\r\n\r\n/// @notice Emitted when the product of the inputs is negative.\r\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\r\n\r\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\r\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\r\n\r\n/// @notice Emitted when the input is less than or equal to zero.\r\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\r\n\r\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\r\nerror PRBMathSD59x18__MulInputTooSmall();\r\n\r\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\r\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\r\n\r\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\r\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\r\n\r\n/// @notice Emitted when the input is negative.\r\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\r\n\r\n/// @notice Emitted when the calculating the square root overflows SD59x18.\r\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\r\n\r\n/// @notice Emitted when addition overflows UD60x18.\r\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\r\n\r\n/// @notice Emitted when ceiling a number overflows UD60x18.\r\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\r\n\r\n/// @notice Emitted when the input is greater than 133.084258667509499441.\r\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\r\n\r\n/// @notice Emitted when the input is greater than 192.\r\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\r\n\r\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\r\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\r\n\r\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\r\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\r\n\r\n/// @notice Emitted when the input is less than 1.\r\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\r\n\r\n/// @notice Emitted when the calculating the square root overflows UD60x18.\r\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\r\n\r\n/// @notice Emitted when subtraction underflows UD60x18.\r\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\r\n\r\n\r\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\r\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\r\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\r\nlibrary PRBMath {\r\n    /// STRUCTS ///\r\n\r\n    struct SD59x18 {\r\n        int256 value;\r\n    }\r\n\r\n    struct UD60x18 {\r\n        uint256 value;\r\n    }\r\n\r\n    /// STORAGE ///\r\n\r\n    /// @dev How many trailing decimals can be represented.\r\n    uint256 internal constant SCALE = 1e18;\r\n\r\n    /// @dev Largest power of two divisor of SCALE.\r\n    uint256 internal constant SCALE_LPOTD = 262144;\r\n\r\n    /// @dev SCALE inverted mod 2^256.\r\n    uint256 internal constant SCALE_INVERSE =\r\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\r\n\r\n    /// FUNCTIONS ///\r\n\r\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\r\n    /// @dev Has to use 192.64-bit fixed-point numbers.\r\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\r\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function exp2(uint256 x) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // Start from 0.5 in the 192.64-bit fixed-point format.\r\n            result = 0x800000000000000000000000000000000000000000000000;\r\n\r\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\r\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\r\n            if (x & 0x8000000000000000 > 0) {\r\n                result = (result * 0x16A09E667F3BCC909) >> 64;\r\n            }\r\n            if (x & 0x4000000000000000 > 0) {\r\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\r\n            }\r\n            if (x & 0x2000000000000000 > 0) {\r\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\r\n            }\r\n            if (x & 0x1000000000000000 > 0) {\r\n                result = (result * 0x10B5586CF9890F62A) >> 64;\r\n            }\r\n            if (x & 0x800000000000000 > 0) {\r\n                result = (result * 0x1059B0D31585743AE) >> 64;\r\n            }\r\n            if (x & 0x400000000000000 > 0) {\r\n                result = (result * 0x102C9A3E778060EE7) >> 64;\r\n            }\r\n            if (x & 0x200000000000000 > 0) {\r\n                result = (result * 0x10163DA9FB33356D8) >> 64;\r\n            }\r\n            if (x & 0x100000000000000 > 0) {\r\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\r\n            }\r\n            if (x & 0x80000000000000 > 0) {\r\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\r\n            }\r\n            if (x & 0x40000000000000 > 0) {\r\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\r\n            }\r\n            if (x & 0x20000000000000 > 0) {\r\n                result = (result * 0x100162F3904051FA1) >> 64;\r\n            }\r\n            if (x & 0x10000000000000 > 0) {\r\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\r\n            }\r\n            if (x & 0x8000000000000 > 0) {\r\n                result = (result * 0x100058BA01FB9F96D) >> 64;\r\n            }\r\n            if (x & 0x4000000000000 > 0) {\r\n                result = (result * 0x10002C5CC37DA9492) >> 64;\r\n            }\r\n            if (x & 0x2000000000000 > 0) {\r\n                result = (result * 0x1000162E525EE0547) >> 64;\r\n            }\r\n            if (x & 0x1000000000000 > 0) {\r\n                result = (result * 0x10000B17255775C04) >> 64;\r\n            }\r\n            if (x & 0x800000000000 > 0) {\r\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\r\n            }\r\n            if (x & 0x400000000000 > 0) {\r\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\r\n            }\r\n            if (x & 0x200000000000 > 0) {\r\n                result = (result * 0x10000162E43F4F831) >> 64;\r\n            }\r\n            if (x & 0x100000000000 > 0) {\r\n                result = (result * 0x100000B1721BCFC9A) >> 64;\r\n            }\r\n            if (x & 0x80000000000 > 0) {\r\n                result = (result * 0x10000058B90CF1E6E) >> 64;\r\n            }\r\n            if (x & 0x40000000000 > 0) {\r\n                result = (result * 0x1000002C5C863B73F) >> 64;\r\n            }\r\n            if (x & 0x20000000000 > 0) {\r\n                result = (result * 0x100000162E430E5A2) >> 64;\r\n            }\r\n            if (x & 0x10000000000 > 0) {\r\n                result = (result * 0x1000000B172183551) >> 64;\r\n            }\r\n            if (x & 0x8000000000 > 0) {\r\n                result = (result * 0x100000058B90C0B49) >> 64;\r\n            }\r\n            if (x & 0x4000000000 > 0) {\r\n                result = (result * 0x10000002C5C8601CC) >> 64;\r\n            }\r\n            if (x & 0x2000000000 > 0) {\r\n                result = (result * 0x1000000162E42FFF0) >> 64;\r\n            }\r\n            if (x & 0x1000000000 > 0) {\r\n                result = (result * 0x10000000B17217FBB) >> 64;\r\n            }\r\n            if (x & 0x800000000 > 0) {\r\n                result = (result * 0x1000000058B90BFCE) >> 64;\r\n            }\r\n            if (x & 0x400000000 > 0) {\r\n                result = (result * 0x100000002C5C85FE3) >> 64;\r\n            }\r\n            if (x & 0x200000000 > 0) {\r\n                result = (result * 0x10000000162E42FF1) >> 64;\r\n            }\r\n            if (x & 0x100000000 > 0) {\r\n                result = (result * 0x100000000B17217F8) >> 64;\r\n            }\r\n            if (x & 0x80000000 > 0) {\r\n                result = (result * 0x10000000058B90BFC) >> 64;\r\n            }\r\n            if (x & 0x40000000 > 0) {\r\n                result = (result * 0x1000000002C5C85FE) >> 64;\r\n            }\r\n            if (x & 0x20000000 > 0) {\r\n                result = (result * 0x100000000162E42FF) >> 64;\r\n            }\r\n            if (x & 0x10000000 > 0) {\r\n                result = (result * 0x1000000000B17217F) >> 64;\r\n            }\r\n            if (x & 0x8000000 > 0) {\r\n                result = (result * 0x100000000058B90C0) >> 64;\r\n            }\r\n            if (x & 0x4000000 > 0) {\r\n                result = (result * 0x10000000002C5C860) >> 64;\r\n            }\r\n            if (x & 0x2000000 > 0) {\r\n                result = (result * 0x1000000000162E430) >> 64;\r\n            }\r\n            if (x & 0x1000000 > 0) {\r\n                result = (result * 0x10000000000B17218) >> 64;\r\n            }\r\n            if (x & 0x800000 > 0) {\r\n                result = (result * 0x1000000000058B90C) >> 64;\r\n            }\r\n            if (x & 0x400000 > 0) {\r\n                result = (result * 0x100000000002C5C86) >> 64;\r\n            }\r\n            if (x & 0x200000 > 0) {\r\n                result = (result * 0x10000000000162E43) >> 64;\r\n            }\r\n            if (x & 0x100000 > 0) {\r\n                result = (result * 0x100000000000B1721) >> 64;\r\n            }\r\n            if (x & 0x80000 > 0) {\r\n                result = (result * 0x10000000000058B91) >> 64;\r\n            }\r\n            if (x & 0x40000 > 0) {\r\n                result = (result * 0x1000000000002C5C8) >> 64;\r\n            }\r\n            if (x & 0x20000 > 0) {\r\n                result = (result * 0x100000000000162E4) >> 64;\r\n            }\r\n            if (x & 0x10000 > 0) {\r\n                result = (result * 0x1000000000000B172) >> 64;\r\n            }\r\n            if (x & 0x8000 > 0) {\r\n                result = (result * 0x100000000000058B9) >> 64;\r\n            }\r\n            if (x & 0x4000 > 0) {\r\n                result = (result * 0x10000000000002C5D) >> 64;\r\n            }\r\n            if (x & 0x2000 > 0) {\r\n                result = (result * 0x1000000000000162E) >> 64;\r\n            }\r\n            if (x & 0x1000 > 0) {\r\n                result = (result * 0x10000000000000B17) >> 64;\r\n            }\r\n            if (x & 0x800 > 0) {\r\n                result = (result * 0x1000000000000058C) >> 64;\r\n            }\r\n            if (x & 0x400 > 0) {\r\n                result = (result * 0x100000000000002C6) >> 64;\r\n            }\r\n            if (x & 0x200 > 0) {\r\n                result = (result * 0x10000000000000163) >> 64;\r\n            }\r\n            if (x & 0x100 > 0) {\r\n                result = (result * 0x100000000000000B1) >> 64;\r\n            }\r\n            if (x & 0x80 > 0) {\r\n                result = (result * 0x10000000000000059) >> 64;\r\n            }\r\n            if (x & 0x40 > 0) {\r\n                result = (result * 0x1000000000000002C) >> 64;\r\n            }\r\n            if (x & 0x20 > 0) {\r\n                result = (result * 0x10000000000000016) >> 64;\r\n            }\r\n            if (x & 0x10 > 0) {\r\n                result = (result * 0x1000000000000000B) >> 64;\r\n            }\r\n            if (x & 0x8 > 0) {\r\n                result = (result * 0x10000000000000006) >> 64;\r\n            }\r\n            if (x & 0x4 > 0) {\r\n                result = (result * 0x10000000000000003) >> 64;\r\n            }\r\n            if (x & 0x2 > 0) {\r\n                result = (result * 0x10000000000000001) >> 64;\r\n            }\r\n            if (x & 0x1 > 0) {\r\n                result = (result * 0x10000000000000001) >> 64;\r\n            }\r\n\r\n            // We're doing two things at the same time:\r\n            //\r\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\r\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\r\n            //      rather than 192.\r\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\r\n            //\r\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\r\n            result *= SCALE;\r\n            result >>= (191 - (x >> 64));\r\n        }\r\n    }\r\n\r\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\r\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\r\n    /// @param x The uint256 number for which to find the index of the most significant bit.\r\n    /// @return msb The index of the most significant bit as an uint256.\r\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\r\n        if (x >= 2**128) {\r\n            x >>= 128;\r\n            msb += 128;\r\n        }\r\n        if (x >= 2**64) {\r\n            x >>= 64;\r\n            msb += 64;\r\n        }\r\n        if (x >= 2**32) {\r\n            x >>= 32;\r\n            msb += 32;\r\n        }\r\n        if (x >= 2**16) {\r\n            x >>= 16;\r\n            msb += 16;\r\n        }\r\n        if (x >= 2**8) {\r\n            x >>= 8;\r\n            msb += 8;\r\n        }\r\n        if (x >= 2**4) {\r\n            x >>= 4;\r\n            msb += 4;\r\n        }\r\n        if (x >= 2**2) {\r\n            x >>= 2;\r\n            msb += 2;\r\n        }\r\n        if (x >= 2**1) {\r\n            // No need to shift x any more.\r\n            msb += 1;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision.\r\n    ///\r\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\r\n    ///\r\n    /// Requirements:\r\n    /// - The denominator cannot be zero.\r\n    /// - The result must fit within uint256.\r\n    ///\r\n    /// Caveats:\r\n    /// - This function does not work with fixed-point numbers.\r\n    ///\r\n    /// @param x The multiplicand as an uint256.\r\n    /// @param y The multiplier as an uint256.\r\n    /// @param denominator The divisor as an uint256.\r\n    /// @return result The result as an uint256.\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n        // variables such that product = prod1 * 2^256 + prod0.\r\n        uint256 prod0; // Least significant 256 bits of the product\r\n        uint256 prod1; // Most significant 256 bits of the product\r\n        assembly {\r\n            let mm := mulmod(x, y, not(0))\r\n            prod0 := mul(x, y)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        // Handle non-overflow cases, 256 by 256 division.\r\n        if (prod1 == 0) {\r\n            unchecked {\r\n                result = prod0 / denominator;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n        if (prod1 >= denominator) {\r\n            revert PRBMath__MulDivOverflow(prod1, denominator);\r\n        }\r\n\r\n        ///////////////////////////////////////////////\r\n        // 512 by 256 division.\r\n        ///////////////////////////////////////////////\r\n\r\n        // Make division exact by subtracting the remainder from [prod1 prod0].\r\n        uint256 remainder;\r\n        assembly {\r\n            // Compute remainder using mulmod.\r\n            remainder := mulmod(x, y, denominator)\r\n\r\n            // Subtract 256 bit number from 512 bit number.\r\n            prod1 := sub(prod1, gt(remainder, prod0))\r\n            prod0 := sub(prod0, remainder)\r\n        }\r\n\r\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n        // See https://cs.stackexchange.com/q/138556/92363.\r\n        unchecked {\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 lpotdod = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by lpotdod.\r\n                denominator := div(denominator, lpotdod)\r\n\r\n                // Divide [prod1 prod0] by lpotdod.\r\n                prod0 := div(prod0, lpotdod)\r\n\r\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\r\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * lpotdod;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates floor(x*y\u00f71e18) with full precision.\r\n    ///\r\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\r\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\r\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\r\n    ///\r\n    /// Requirements:\r\n    /// - The result must fit within uint256.\r\n    ///\r\n    /// Caveats:\r\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\r\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\r\n    ///     1. x * y = type(uint256).max * SCALE\r\n    ///     2. (x * y) % SCALE >= SCALE / 2\r\n    ///\r\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        uint256 prod0;\r\n        uint256 prod1;\r\n        assembly {\r\n            let mm := mulmod(x, y, not(0))\r\n            prod0 := mul(x, y)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        if (prod1 >= SCALE) {\r\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\r\n        }\r\n\r\n        uint256 remainder;\r\n        uint256 roundUpUnit;\r\n        assembly {\r\n            remainder := mulmod(x, y, SCALE)\r\n            roundUpUnit := gt(remainder, 499999999999999999)\r\n        }\r\n\r\n        if (prod1 == 0) {\r\n            unchecked {\r\n                result = (prod0 / SCALE) + roundUpUnit;\r\n                return result;\r\n            }\r\n        }\r\n\r\n        assembly {\r\n            result := add(\r\n                mul(\r\n                    or(\r\n                        div(sub(prod0, remainder), SCALE_LPOTD),\r\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\r\n                    ),\r\n                    SCALE_INVERSE\r\n                ),\r\n                roundUpUnit\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision.\r\n    ///\r\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\r\n    ///\r\n    /// Requirements:\r\n    /// - None of the inputs can be type(int256).min.\r\n    /// - The result must fit within int256.\r\n    ///\r\n    /// @param x The multiplicand as an int256.\r\n    /// @param y The multiplier as an int256.\r\n    /// @param denominator The divisor as an int256.\r\n    /// @return result The result as an int256.\r\n    function mulDivSigned(\r\n        int256 x,\r\n        int256 y,\r\n        int256 denominator\r\n    ) internal pure returns (int256 result) {\r\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\r\n            revert PRBMath__MulDivSignedInputTooSmall();\r\n        }\r\n\r\n        // Get hold of the absolute values of x, y and the denominator.\r\n        uint256 ax;\r\n        uint256 ay;\r\n        uint256 ad;\r\n        unchecked {\r\n            ax = x < 0 ? uint256(-x) : uint256(x);\r\n            ay = y < 0 ? uint256(-y) : uint256(y);\r\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\r\n        }\r\n\r\n        // Compute the absolute value of (x*y)\u00f7denominator. The result must fit within int256.\r\n        uint256 rAbs = mulDiv(ax, ay, ad);\r\n        if (rAbs > uint256(type(int256).max)) {\r\n            revert PRBMath__MulDivSignedOverflow(rAbs);\r\n        }\r\n\r\n        // Get the signs of x, y and the denominator.\r\n        uint256 sx;\r\n        uint256 sy;\r\n        uint256 sd;\r\n        assembly {\r\n            sx := sgt(x, sub(0, 1))\r\n            sy := sgt(y, sub(0, 1))\r\n            sd := sgt(denominator, sub(0, 1))\r\n        }\r\n\r\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\r\n        // If yes, the result should be negative.\r\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\r\n    }\r\n\r\n    /// @notice Calculates the square root of x, rounding down.\r\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\r\n    ///\r\n    /// Caveats:\r\n    /// - This function does not work with fixed-point numbers.\r\n    ///\r\n    /// @param x The uint256 number for which to calculate the square root.\r\n    /// @return result The result as an uint256.\r\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\r\n        uint256 xAux = uint256(x);\r\n        result = 1;\r\n        if (xAux >= 0x100000000000000000000000000000000) {\r\n            xAux >>= 128;\r\n            result <<= 64;\r\n        }\r\n        if (xAux >= 0x10000000000000000) {\r\n            xAux >>= 64;\r\n            result <<= 32;\r\n        }\r\n        if (xAux >= 0x100000000) {\r\n            xAux >>= 32;\r\n            result <<= 16;\r\n        }\r\n        if (xAux >= 0x10000) {\r\n            xAux >>= 16;\r\n            result <<= 8;\r\n        }\r\n        if (xAux >= 0x100) {\r\n            xAux >>= 8;\r\n            result <<= 4;\r\n        }\r\n        if (xAux >= 0x10) {\r\n            xAux >>= 4;\r\n            result <<= 2;\r\n        }\r\n        if (xAux >= 0x8) {\r\n            result <<= 1;\r\n        }\r\n\r\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\r\n        unchecked {\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1; // Seven iterations should be enough\r\n            uint256 roundedDownResult = x / result;\r\n            return result >= roundedDownResult ? roundedDownResult : result;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @title PRBMathSD59x18\r\n/// @author Paul Razvan Berg\r\n/// @notice Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18\r\n/// trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have\r\n/// a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers\r\n/// are bound by the minimum and the maximum values permitted by the Solidity type int256.\r\nlibrary PRBMathSD59x18 {\r\n    /// @dev log2(e) as a signed 59.18-decimal fixed-point number.\r\n    int256 internal constant LOG2_E = 1_442695040888963407;\r\n\r\n    /// @dev Half the SCALE number.\r\n    int256 internal constant HALF_SCALE = 5e17;\r\n\r\n    /// @dev The maximum value a signed 59.18-decimal fixed-point number can have.\r\n    int256 internal constant MAX_SD59x18 =\r\n        57896044618658097711785492504343953926634992332820282019728_792003956564819967;\r\n\r\n    /// @dev The maximum whole value a signed 59.18-decimal fixed-point number can have.\r\n    int256 internal constant MAX_WHOLE_SD59x18 =\r\n        57896044618658097711785492504343953926634992332820282019728_000000000000000000;\r\n\r\n    /// @dev The minimum value a signed 59.18-decimal fixed-point number can have.\r\n    int256 internal constant MIN_SD59x18 =\r\n        -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\r\n\r\n    /// @dev The minimum whole value a signed 59.18-decimal fixed-point number can have.\r\n    int256 internal constant MIN_WHOLE_SD59x18 =\r\n        -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\r\n\r\n    /// @dev How many trailing decimals can be represented.\r\n    int256 internal constant SCALE = 1e18;\r\n\r\n    /// INTERNAL FUNCTIONS ///\r\n\r\n    /// @notice Calculate the absolute value of x.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x must be greater than MIN_SD59x18.\r\n    ///\r\n    /// @param x The number to calculate the absolute value for.\r\n    /// @param result The absolute value of x.\r\n    function abs(int256 x) internal pure returns (int256 result) {\r\n        unchecked {\r\n            if (x == MIN_SD59x18) {\r\n                revert PRBMathSD59x18__AbsInputTooSmall();\r\n            }\r\n            result = x < 0 ? -x : x;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\r\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\r\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\r\n    /// @return result The arithmetic average as a signed 59.18-decimal fixed-point number.\r\n    function avg(int256 x, int256 y) internal pure returns (int256 result) {\r\n        // The operations can never overflow.\r\n        unchecked {\r\n            int256 sum = (x >> 1) + (y >> 1);\r\n            if (sum < 0) {\r\n                // If at least one of x and y is odd, we add 1 to the result. This is because shifting negative numbers to the\r\n                // right rounds down to infinity.\r\n                assembly {\r\n                    result := add(sum, and(or(x, y), 1))\r\n                }\r\n            } else {\r\n                // If both x and y are odd, we add 1 to the result. This is because if both numbers are odd, the 0.5\r\n                // remainder gets truncated twice.\r\n                result = sum + (x & y & 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x.\r\n    ///\r\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\r\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be less than or equal to MAX_WHOLE_SD59x18.\r\n    ///\r\n    /// @param x The signed 59.18-decimal fixed-point number to ceil.\r\n    /// @param result The least integer greater than or equal to x, as a signed 58.18-decimal fixed-point number.\r\n    function ceil(int256 x) internal pure returns (int256 result) {\r\n        if (x > MAX_WHOLE_SD59x18) {\r\n            revert PRBMathSD59x18__CeilOverflow(x);\r\n        }\r\n        unchecked {\r\n            int256 remainder = x % SCALE;\r\n            if (remainder == 0) {\r\n                result = x;\r\n            } else {\r\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\r\n                result = x - remainder;\r\n                if (x > 0) {\r\n                    result += SCALE;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number.\r\n    ///\r\n    /// @dev Variant of \"mulDiv\" that works with signed numbers. Works by computing the signs and the absolute values separately.\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"PRBMath.mulDiv\".\r\n    /// - None of the inputs can be MIN_SD59x18.\r\n    /// - The denominator cannot be zero.\r\n    /// - The result must fit within int256.\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"PRBMath.mulDiv\".\r\n    ///\r\n    /// @param x The numerator as a signed 59.18-decimal fixed-point number.\r\n    /// @param y The denominator as a signed 59.18-decimal fixed-point number.\r\n    /// @param result The quotient as a signed 59.18-decimal fixed-point number.\r\n    function div(int256 x, int256 y) internal pure returns (int256 result) {\r\n        if (x == MIN_SD59x18 || y == MIN_SD59x18) {\r\n            revert PRBMathSD59x18__DivInputTooSmall();\r\n        }\r\n\r\n        // Get hold of the absolute values of x and y.\r\n        uint256 ax;\r\n        uint256 ay;\r\n        unchecked {\r\n            ax = x < 0 ? uint256(-x) : uint256(x);\r\n            ay = y < 0 ? uint256(-y) : uint256(y);\r\n        }\r\n\r\n        // Compute the absolute value of (x*SCALE)\u00f7y. The result must fit within int256.\r\n        uint256 rAbs = PRBMath.mulDiv(ax, uint256(SCALE), ay);\r\n        if (rAbs > uint256(MAX_SD59x18)) {\r\n            revert PRBMathSD59x18__DivOverflow(rAbs);\r\n        }\r\n\r\n        // Get the signs of x and y.\r\n        uint256 sx;\r\n        uint256 sy;\r\n        assembly {\r\n            sx := sgt(x, sub(0, 1))\r\n            sy := sgt(y, sub(0, 1))\r\n        }\r\n\r\n        // XOR over sx and sy. This is basically checking whether the inputs have the same sign. If yes, the result\r\n        // should be positive. Otherwise, it should be negative.\r\n        result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\r\n    }\r\n\r\n    /// @notice Returns Euler's number as a signed 59.18-decimal fixed-point number.\r\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\r\n    function e() internal pure returns (int256 result) {\r\n        result = 2_718281828459045235;\r\n    }\r\n\r\n    /// @notice Calculates the natural exponent of x.\r\n    ///\r\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"log2\".\r\n    /// - x must be less than 133.084258667509499441.\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"exp2\".\r\n    /// - For any x less than -41.446531673892822322, the result is zero.\r\n    ///\r\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\r\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\r\n    function exp(int256 x) internal pure returns (int256 result) {\r\n        // Without this check, the value passed to \"exp2\" would be less than -59.794705707972522261.\r\n        if (x < -41_446531673892822322) {\r\n            return 0;\r\n        }\r\n\r\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\r\n        if (x >= 133_084258667509499441) {\r\n            revert PRBMathSD59x18__ExpInputTooBig(x);\r\n        }\r\n\r\n        // Do the fixed-point multiplication inline to save gas.\r\n        unchecked {\r\n            int256 doubleScaleProduct = x * LOG2_E;\r\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\r\n    ///\r\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be 192 or less.\r\n    /// - The result must fit within MAX_SD59x18.\r\n    ///\r\n    /// Caveats:\r\n    /// - For any x less than -59.794705707972522261, the result is zero.\r\n    ///\r\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\r\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\r\n    function exp2(int256 x) internal pure returns (int256 result) {\r\n        // This works because 2^(-x) = 1/2^x.\r\n        if (x < 0) {\r\n            // 2^59.794705707972522262 is the maximum number whose inverse does not truncate down to zero.\r\n            if (x < -59_794705707972522261) {\r\n                return 0;\r\n            }\r\n\r\n            // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\r\n            unchecked {\r\n                result = 1e36 / exp2(-x);\r\n            }\r\n        } else {\r\n            // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\r\n            if (x >= 192e18) {\r\n                revert PRBMathSD59x18__Exp2InputTooBig(x);\r\n            }\r\n\r\n            unchecked {\r\n                // Convert x to the 192.64-bit fixed-point format.\r\n                uint256 x192x64 = (uint256(x) << 64) / uint256(SCALE);\r\n\r\n                // Safe to convert the result to int256 directly because the maximum input allowed is 192.\r\n                result = int256(PRBMath.exp2(x192x64));\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x.\r\n    ///\r\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\r\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be greater than or equal to MIN_WHOLE_SD59x18.\r\n    ///\r\n    /// @param x The signed 59.18-decimal fixed-point number to floor.\r\n    /// @param result The greatest integer less than or equal to x, as a signed 58.18-decimal fixed-point number.\r\n    function floor(int256 x) internal pure returns (int256 result) {\r\n        if (x < MIN_WHOLE_SD59x18) {\r\n            revert PRBMathSD59x18__FloorUnderflow(x);\r\n        }\r\n        unchecked {\r\n            int256 remainder = x % SCALE;\r\n            if (remainder == 0) {\r\n                result = x;\r\n            } else {\r\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\r\n                result = x - remainder;\r\n                if (x < 0) {\r\n                    result -= SCALE;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right\r\n    /// of the radix point for negative numbers.\r\n    /// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\r\n    /// @param x The signed 59.18-decimal fixed-point number to get the fractional part of.\r\n    /// @param result The fractional part of x as a signed 59.18-decimal fixed-point number.\r\n    function frac(int256 x) internal pure returns (int256 result) {\r\n        unchecked {\r\n            result = x % SCALE;\r\n        }\r\n    }\r\n\r\n    /// @notice Converts a number from basic integer form to signed 59.18-decimal fixed-point representation.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x must be greater than or equal to MIN_SD59x18 divided by SCALE.\r\n    /// - x must be less than or equal to MAX_SD59x18 divided by SCALE.\r\n    ///\r\n    /// @param x The basic integer to convert.\r\n    /// @param result The same number in signed 59.18-decimal fixed-point representation.\r\n    function fromInt(int256 x) internal pure returns (int256 result) {\r\n        unchecked {\r\n            if (x < MIN_SD59x18 / SCALE) {\r\n                revert PRBMathSD59x18__FromIntUnderflow(x);\r\n            }\r\n            if (x > MAX_SD59x18 / SCALE) {\r\n                revert PRBMathSD59x18__FromIntOverflow(x);\r\n            }\r\n            result = x * SCALE;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x * y must fit within MAX_SD59x18, lest it overflows.\r\n    /// - x * y cannot be negative.\r\n    ///\r\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\r\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\r\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\r\n    function gm(int256 x, int256 y) internal pure returns (int256 result) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        unchecked {\r\n            // Checking for overflow this way is faster than letting Solidity do it.\r\n            int256 xy = x * y;\r\n            if (xy / x != y) {\r\n                revert PRBMathSD59x18__GmOverflow(x, y);\r\n            }\r\n\r\n            // The product cannot be negative.\r\n            if (xy < 0) {\r\n                revert PRBMathSD59x18__GmNegativeProduct(x, y);\r\n            }\r\n\r\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\r\n            // during multiplication. See the comments within the \"sqrt\" function.\r\n            result = int256(PRBMath.sqrt(uint256(xy)));\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates 1 / x, rounding toward zero.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x cannot be zero.\r\n    ///\r\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the inverse.\r\n    /// @return result The inverse as a signed 59.18-decimal fixed-point number.\r\n    function inv(int256 x) internal pure returns (int256 result) {\r\n        unchecked {\r\n            // 1e36 is SCALE * SCALE.\r\n            result = 1e36 / x;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the natural logarithm of x.\r\n    ///\r\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"log2\".\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"log2\".\r\n    /// - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision.\r\n    ///\r\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm.\r\n    /// @return result The natural logarithm as a signed 59.18-decimal fixed-point number.\r\n    function ln(int256 x) internal pure returns (int256 result) {\r\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\r\n        // can return is 195205294292027477728.\r\n        unchecked {\r\n            result = (log2(x) * SCALE) / LOG2_E;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the common logarithm of x.\r\n    ///\r\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\r\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"log2\".\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"log2\".\r\n    ///\r\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the common logarithm.\r\n    /// @return result The common logarithm as a signed 59.18-decimal fixed-point number.\r\n    function log10(int256 x) internal pure returns (int256 result) {\r\n        if (x <= 0) {\r\n            revert PRBMathSD59x18__LogInputTooSmall(x);\r\n        }\r\n\r\n        // Note that the \"mul\" in this block is the assembly mul operation, not the \"mul\" function defined in this contract.\r\n        // prettier-ignore\r\n        assembly {\r\n            switch x\r\n            case 1 { result := mul(SCALE, sub(0, 18)) }\r\n            case 10 { result := mul(SCALE, sub(1, 18)) }\r\n            case 100 { result := mul(SCALE, sub(2, 18)) }\r\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\r\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\r\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\r\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\r\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\r\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\r\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\r\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\r\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\r\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\r\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\r\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\r\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\r\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\r\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\r\n            case 1000000000000000000 { result := 0 }\r\n            case 10000000000000000000 { result := SCALE }\r\n            case 100000000000000000000 { result := mul(SCALE, 2) }\r\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\r\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\r\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\r\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\r\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\r\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\r\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\r\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\r\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\r\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\r\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\r\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\r\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\r\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\r\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\r\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\r\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\r\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\r\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\r\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\r\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\r\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\r\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\r\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\r\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\r\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\r\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\r\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\r\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\r\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\r\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\r\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\r\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\r\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\r\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\r\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\r\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\r\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\r\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\r\n            default {\r\n                result := MAX_SD59x18\r\n            }\r\n        }\r\n\r\n        if (result == MAX_SD59x18) {\r\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\r\n            unchecked {\r\n                result = (log2(x) * SCALE) / 3_321928094887362347;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the binary logarithm of x.\r\n    ///\r\n    /// @dev Based on the iterative approximation algorithm.\r\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be greater than zero.\r\n    ///\r\n    /// Caveats:\r\n    /// - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\r\n    ///\r\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm.\r\n    /// @return result The binary logarithm as a signed 59.18-decimal fixed-point number.\r\n    function log2(int256 x) internal pure returns (int256 result) {\r\n        if (x <= 0) {\r\n            revert PRBMathSD59x18__LogInputTooSmall(x);\r\n        }\r\n        unchecked {\r\n            // This works because log2(x) = -log2(1/x).\r\n            int256 sign;\r\n            if (x >= SCALE) {\r\n                sign = 1;\r\n            } else {\r\n                sign = -1;\r\n                // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\r\n                assembly {\r\n                    x := div(1000000000000000000000000000000000000, x)\r\n                }\r\n            }\r\n\r\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\r\n            uint256 n = PRBMath.mostSignificantBit(uint256(x / SCALE));\r\n\r\n            // The integer part of the logarithm as a signed 59.18-decimal fixed-point number. The operation can't overflow\r\n            // because n is maximum 255, SCALE is 1e18 and sign is either 1 or -1.\r\n            result = int256(n) * SCALE;\r\n\r\n            // This is y = x * 2^(-n).\r\n            int256 y = x >> n;\r\n\r\n            // If y = 1, the fractional part is zero.\r\n            if (y == SCALE) {\r\n                return result * sign;\r\n            }\r\n\r\n            // Calculate the fractional part via the iterative approximation.\r\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\r\n            for (int256 delta = int256(HALF_SCALE); delta > 0; delta >>= 1) {\r\n                y = (y * y) / SCALE;\r\n\r\n                // Is y^2 > 2 and so in the range [2,4)?\r\n                if (y >= 2 * SCALE) {\r\n                    // Add the 2^(-m) factor to the logarithm.\r\n                    result += delta;\r\n\r\n                    // Corresponds to z/2 on Wikipedia.\r\n                    y >>= 1;\r\n                }\r\n            }\r\n            result *= sign;\r\n        }\r\n    }\r\n\r\n    /// @notice Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal\r\n    /// fixed-point number.\r\n    ///\r\n    /// @dev Variant of \"mulDiv\" that works with signed numbers and employs constant folding, i.e. the denominator is\r\n    /// always 1e18.\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"PRBMath.mulDivFixedPoint\".\r\n    /// - None of the inputs can be MIN_SD59x18\r\n    /// - The result must fit within MAX_SD59x18.\r\n    ///\r\n    /// Caveats:\r\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\r\n    ///\r\n    /// @param x The multiplicand as a signed 59.18-decimal fixed-point number.\r\n    /// @param y The multiplier as a signed 59.18-decimal fixed-point number.\r\n    /// @return result The product as a signed 59.18-decimal fixed-point number.\r\n    function mul(int256 x, int256 y) internal pure returns (int256 result) {\r\n        if (x == MIN_SD59x18 || y == MIN_SD59x18) {\r\n            revert PRBMathSD59x18__MulInputTooSmall();\r\n        }\r\n\r\n        unchecked {\r\n            uint256 ax;\r\n            uint256 ay;\r\n            ax = x < 0 ? uint256(-x) : uint256(x);\r\n            ay = y < 0 ? uint256(-y) : uint256(y);\r\n\r\n            uint256 rAbs = PRBMath.mulDivFixedPoint(ax, ay);\r\n            if (rAbs > uint256(MAX_SD59x18)) {\r\n                revert PRBMathSD59x18__MulOverflow(rAbs);\r\n            }\r\n\r\n            uint256 sx;\r\n            uint256 sy;\r\n            assembly {\r\n                sx := sgt(x, sub(0, 1))\r\n                sy := sgt(y, sub(0, 1))\r\n            }\r\n            result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\r\n        }\r\n    }\r\n\r\n    /// @notice Returns PI as a signed 59.18-decimal fixed-point number.\r\n    function pi() internal pure returns (int256 result) {\r\n        result = 3_141592653589793238;\r\n    }\r\n\r\n    /// @notice Raises x to the power of y.\r\n    ///\r\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"exp2\", \"log2\" and \"mul\".\r\n    /// - z cannot be zero.\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"exp2\", \"log2\" and \"mul\".\r\n    /// - Assumes 0^0 is 1.\r\n    ///\r\n    /// @param x Number to raise to given power y, as a signed 59.18-decimal fixed-point number.\r\n    /// @param y Exponent to raise x to, as a signed 59.18-decimal fixed-point number.\r\n    /// @return result x raised to power y, as a signed 59.18-decimal fixed-point number.\r\n    function pow(int256 x, int256 y) internal pure returns (int256 result) {\r\n        if (x == 0) {\r\n            result = y == 0 ? SCALE : int256(0);\r\n        } else {\r\n            result = exp2(mul(log2(x), y));\r\n        }\r\n    }\r\n\r\n    /// @notice Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\r\n    /// famous algorithm \"exponentiation by squaring\".\r\n    ///\r\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"abs\" and \"PRBMath.mulDivFixedPoint\".\r\n    /// - The result must fit within MAX_SD59x18.\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"PRBMath.mulDivFixedPoint\".\r\n    /// - Assumes 0^0 is 1.\r\n    ///\r\n    /// @param x The base as a signed 59.18-decimal fixed-point number.\r\n    /// @param y The exponent as an uint256.\r\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\r\n    function powu(int256 x, uint256 y) internal pure returns (int256 result) {\r\n        uint256 xAbs = uint256(abs(x));\r\n\r\n        // Calculate the first iteration of the loop in advance.\r\n        uint256 rAbs = y & 1 > 0 ? xAbs : uint256(SCALE);\r\n\r\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\r\n        uint256 yAux = y;\r\n        for (yAux >>= 1; yAux > 0; yAux >>= 1) {\r\n            xAbs = PRBMath.mulDivFixedPoint(xAbs, xAbs);\r\n\r\n            // Equivalent to \"y % 2 == 1\" but faster.\r\n            if (yAux & 1 > 0) {\r\n                rAbs = PRBMath.mulDivFixedPoint(rAbs, xAbs);\r\n            }\r\n        }\r\n\r\n        // The result must fit within the 59.18-decimal fixed-point representation.\r\n        if (rAbs > uint256(MAX_SD59x18)) {\r\n            revert PRBMathSD59x18__PowuOverflow(rAbs);\r\n        }\r\n\r\n        // Is the base negative and the exponent an odd number?\r\n        bool isNegative = x < 0 && y & 1 == 1;\r\n        result = isNegative ? -int256(rAbs) : int256(rAbs);\r\n    }\r\n\r\n    /// @notice Returns 1 as a signed 59.18-decimal fixed-point number.\r\n    function scale() internal pure returns (int256 result) {\r\n        result = SCALE;\r\n    }\r\n\r\n    /// @notice Calculates the square root of x, rounding down.\r\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\r\n    ///\r\n    /// Requirements:\r\n    /// - x cannot be negative.\r\n    /// - x must be less than MAX_SD59x18 / SCALE.\r\n    ///\r\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the square root.\r\n    /// @return result The result as a signed 59.18-decimal fixed-point .\r\n    function sqrt(int256 x) internal pure returns (int256 result) {\r\n        unchecked {\r\n            if (x < 0) {\r\n                revert PRBMathSD59x18__SqrtNegativeInput(x);\r\n            }\r\n            if (x > MAX_SD59x18 / SCALE) {\r\n                revert PRBMathSD59x18__SqrtOverflow(x);\r\n            }\r\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two signed\r\n            // 59.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\r\n            result = int256(PRBMath.sqrt(uint256(x * SCALE)));\r\n        }\r\n    }\r\n\r\n    /// @notice Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process.\r\n    /// @param x The signed 59.18-decimal fixed-point number to convert.\r\n    /// @return result The same number in basic integer form.\r\n    function toInt(int256 x) internal pure returns (int256 result) {\r\n        unchecked {\r\n            result = x / SCALE;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary VORSafeMath {\r\n     /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function saveDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function safeMod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20_Ex {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ninterface IVORCoordinator {\r\n    function getProviderAddress(bytes32 _keyHash) external view returns (address);\r\n    function getProviderFee(bytes32 _keyHash) external view returns (uint96);\r\n    function getProviderGranularFee(bytes32 _keyHash, address _consumer) external view returns (uint96);\r\n    function randomnessRequest(bytes32 keyHash, uint256 consumerSeed, uint256 feePaid) external;\r\n}\r\n\r\n\r\n/**\r\n * @title VORRequestIDBase\r\n */\r\ncontract VORRequestIDBase {\r\n    /**\r\n     * @notice returns the seed which is actually input to the VOR coordinator\r\n     *\r\n     * @dev To prevent repetition of VOR output due to repetition of the\r\n     * @dev user-supplied seed, that seed is combined in a hash with the\r\n     * @dev user-specific nonce, and the address of the consuming contract. The\r\n     * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\r\n     * @dev the final seed, but the nonce does protect against repetition in\r\n     * @dev requests which are included in a single block.\r\n     *\r\n     * @param _userSeed VOR seed input provided by user\r\n     * @param _requester Address of the requesting contract\r\n     * @param _nonce User-specific nonce at the time of the request\r\n     */\r\n    function makeVORInputSeed(\r\n        bytes32 _keyHash,\r\n        uint256 _userSeed,\r\n        address _requester,\r\n        uint256 _nonce\r\n    ) internal pure returns (uint256) {\r\n        return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the id for this request\r\n     * @param _keyHash The serviceAgreement ID to be used for this request\r\n     * @param _vORInputSeed The seed to be passed directly to the VOR\r\n     * @return The id for this request\r\n     *\r\n     * @dev Note that _vORInputSeed is not the seed passed by the consuming\r\n     * @dev contract, but the one generated by makeVORInputSeed\r\n     */\r\n    function makeRequestId(bytes32 _keyHash, uint256 _vORInputSeed) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_keyHash, _vORInputSeed));\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title VORConsumerBase\r\n * @notice Interface for contracts using VOR randomness\r\n * @dev PURPOSE\r\n *\r\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\r\n * to Vera the verifier in such a way that Vera can be sure he's not\r\n * making his output up to suit himself. Reggie provides Vera a public key\r\n * to which he knows the secret key. Each time Vera provides a seed to\r\n * Reggie, he gives back a value which is computed completely\r\n * deterministically from the seed and the secret key.\r\n *\r\n * @dev Reggie provides a proof by which Vera can verify that the output was\r\n * correctly computed once Reggie tells it to her, but without that proof,\r\n * the output is indistinguishable to her from a uniform random sample\r\n * from the output space.\r\n *\r\n * @dev The purpose of this contract is to make it easy for unrelated contracts\r\n * to talk to Vera the verifier about the work Reggie is doing, to provide\r\n * simple access to a verifiable source of randomness.\r\n *\r\n * @dev USAGE\r\n *\r\n * @dev Calling contracts must inherit from VORConsumerBase, and can\r\n * initialize VORConsumerBase's attributes in their constructor as\r\n * shown:\r\n *\r\n * ```\r\n *   contract VORConsumer {\r\n *     constuctor(<other arguments>, address _vorCoordinator, address _xfund)\r\n *       VORConsumerBase(_vorCoordinator, _xfund) public {\r\n *         <initialization with other arguments goes here>\r\n *       }\r\n *   }\r\n * ```\r\n * @dev The oracle will have given you an ID for the VOR keypair they have\r\n * committed to (let's call it keyHash), and have told you the minimum xFUND\r\n * price for VOR service. Make sure your contract has sufficient xFUND, and\r\n * call requestRandomness(keyHash, fee, seed), where seed is the input you\r\n * want to generate randomness from.\r\n *\r\n * @dev Once the VORCoordinator has received and validated the oracle's response\r\n * to your request, it will call your contract's fulfillRandomness method.\r\n *\r\n * @dev The randomness argument to fulfillRandomness is the actual random value\r\n * generated from your seed.\r\n *\r\n * @dev The requestId argument is generated from the keyHash and the seed by\r\n * makeRequestId(keyHash, seed). If your contract could have concurrent\r\n * requests open, you can use the requestId to track which seed is\r\n * associated with which randomness. See VORRequestIDBase.sol for more\r\n * details. (See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\r\n * if your contract could have multiple requests in flight simultaneously.)\r\n *\r\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\r\n * differ. (Which is critical to making unpredictable randomness! See the\r\n * next section.)\r\n *\r\n * @dev SECURITY CONSIDERATIONS\r\n *\r\n * @dev A method with the ability to call your fulfillRandomness method directly\r\n * could spoof a VOR response with any random value, so it's critical that\r\n * it cannot be directly called by anything other than this base contract\r\n * (specifically, by the VORConsumerBase.rawFulfillRandomness method).\r\n *\r\n * @dev For your users to trust that your contract's random behavior is free\r\n * from malicious interference, it's best if you can write it so that all\r\n * behaviors implied by a VOR response are executed *during* your\r\n * fulfillRandomness method. If your contract must store the response (or\r\n * anything derived from it) and use it later, you must ensure that any\r\n * user-significant behavior which depends on that stored value cannot be\r\n * manipulated by a subsequent VOR request.\r\n *\r\n * @dev Similarly, both miners and the VOR oracle itself have some influence\r\n * over the order in which VOR responses appear on the blockchain, so if\r\n * your contract could have multiple VOR requests in flight simultaneously,\r\n * you must ensure that the order in which the VOR responses arrive cannot\r\n * be used to manipulate your contract's user-significant behavior.\r\n *\r\n * @dev Since the ultimate input to the VOR is mixed with the block hash of the\r\n * block in which the request is made, user-provided seeds have no impact\r\n * on its economic security properties. They are only included for API\r\n * compatability with previous versions of this contract.\r\n *\r\n * @dev Since the block hash of the block which contains the requestRandomness\r\n * call is mixed into the input to the VOR *last*, a sufficiently powerful\r\n * miner could, in principle, fork the blockchain to evict the block\r\n * containing the request, forcing the request to be included in a\r\n * different block with a different hash, and therefore a different input\r\n * to the VOR. However, such an attack would incur a substantial economic\r\n * cost. This cost scales with the number of blocks the VOR oracle waits\r\n * until it calls responds to a request.\r\n */\r\nabstract contract VORConsumerBase is VORRequestIDBase {\r\n    using VORSafeMath for uint256;\r\n\r\n    /**\r\n     * @notice fulfillRandomness handles the VOR response. Your contract must\r\n     * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\r\n     * @notice principles to keep in mind when implementing your fulfillRandomness\r\n     * @notice method.\r\n     *\r\n     * @dev VORConsumerBase expects its subcontracts to have a method with this\r\n     * signature, and will call it once it has verified the proof\r\n     * associated with the randomness. (It is triggered via a call to\r\n     * rawFulfillRandomness, below.)\r\n     *\r\n     * @param requestId The Id initially returned by requestRandomness\r\n     * @param randomness the VOR output\r\n     */\r\n    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\r\n\r\n    /**\r\n     * @notice requestRandomness initiates a request for VOR output given _seed\r\n     *\r\n     * @dev The fulfillRandomness method receives the output, once it's provided\r\n     * by the Oracle, and verified by the vorCoordinator.\r\n     *\r\n     * @dev The _keyHash must already be registered with the VORCoordinator, and\r\n     * the _fee must exceed the fee specified during registration of the\r\n     * _keyHash.\r\n     *\r\n     * @dev The _seed parameter is vestigial, and is kept only for API\r\n     * compatibility with older versions. It can't *hurt* to mix in some of\r\n     * your own randomness, here, but it's not necessary because the VOR\r\n     * oracle will mix the hash of the block containing your request into the\r\n     * VOR seed it ultimately uses.\r\n     *\r\n     * @param _keyHash ID of public key against which randomness is generated\r\n     * @param _fee The amount of xFUND to send with the request\r\n     * @param _seed seed mixed into the input of the VOR.\r\n     *\r\n     * @return requestId unique ID for this request\r\n     *\r\n     * The returned requestId can be used to distinguish responses to\r\n     * concurrent requests. It is passed as the first argument to\r\n     * fulfillRandomness.\r\n     */\r\n    function requestRandomness(bytes32 _keyHash, uint256 _fee, uint256 _seed) internal returns (bytes32 requestId) {\r\n        IVORCoordinator(vorCoordinator).randomnessRequest(_keyHash, _seed, _fee);\r\n        // This is the seed passed to VORCoordinator. The oracle will mix this with\r\n        // the hash of the block containing this request to obtain the seed/input\r\n        // which is finally passed to the VOR cryptographic machinery.\r\n        uint256 vORSeed = makeVORInputSeed(_keyHash, _seed, address(this), nonces[_keyHash]);\r\n        // nonces[_keyHash] must stay in sync with\r\n        // VORCoordinator.nonces[_keyHash][this], which was incremented by the above\r\n        // successful VORCoordinator.randomnessRequest.\r\n        // This provides protection against the user repeating their input seed,\r\n        // which would result in a predictable/duplicate output, if multiple such\r\n        // requests appeared in the same block.\r\n        nonces[_keyHash] = nonces[_keyHash].safeAdd(1);\r\n        return makeRequestId(_keyHash, vORSeed);\r\n    }\r\n\r\n    /**\r\n     * @notice _increaseVorCoordinatorAllowance is a helper function to increase token allowance for\r\n     * the VORCoordinator\r\n     * Allows this contract to increase the xFUND allowance for the VORCoordinator contract\r\n     * enabling it to pay request fees on behalf of this contract.\r\n     * NOTE: it is hightly recommended to wrap this around a function that uses,\r\n     * for example, OpenZeppelin's onlyOwner modifier\r\n     *\r\n     * @param _amount uint256 amount to increase allowance by\r\n     */\r\n    function _increaseVorCoordinatorAllowance(uint256 _amount) internal returns (bool) {\r\n        require(xFUND.increaseAllowance(vorCoordinator, _amount), \"failed to increase allowance\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice _setVORCoordinator is a helper function to enable setting the VORCoordinator address\r\n     * NOTE: it is hightly recommended to wrap this around a function that uses,\r\n     * for example, OpenZeppelin's onlyOwner modifier\r\n     *\r\n     * @param _vorCoordinator address new VORCoordinator address\r\n     */\r\n    function _setVORCoordinator(address _vorCoordinator) internal {\r\n        vorCoordinator = _vorCoordinator;\r\n    }\r\n\r\n    address internal immutable xFUNDAddress;\r\n    IERC20_Ex internal immutable xFUND;\r\n    address internal vorCoordinator;\r\n\r\n    // Nonces for each VOR key from which randomness has been requested.\r\n    //\r\n    // Must stay in sync with VORCoordinator[_keyHash][this]\r\n    /* keyHash */\r\n    /* nonce */\r\n    mapping(bytes32 => uint256) private nonces;\r\n\r\n    /**\r\n     * @param _vorCoordinator address of VORCoordinator contract\r\n     * @param _xfund address of xFUND token contract\r\n     */\r\n    constructor(address _vorCoordinator, address _xfund) internal {\r\n        vorCoordinator = _vorCoordinator;\r\n        xFUNDAddress = _xfund;\r\n        xFUND = IERC20_Ex(_xfund);\r\n    }\r\n\r\n    /**\r\n     * @notice rawFulfillRandomness is called by VORCoordinator when it receives a valid VOR\r\n     * proof. rawFulfillRandomness then calls fulfillRandomness, after validating\r\n     * the origin of the call\r\n     */\r\n    function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\r\n        require(msg.sender == vorCoordinator, \"Only VORCoordinator can fulfill\");\r\n        fulfillRandomness(requestId, randomness);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\r\n * {ERC721Enumerable}.\r\n */\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint256 => address) private _owners;\r\n\r\n    // Mapping owner address to token count\r\n    mapping(address => uint256) private _balances;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = _owners[tokenId];\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, can be overriden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n     */\r\n    function _safeMint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, _data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n\r\n        _beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n        // Clear approvals\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[owner] -= 1;\r\n        delete _owners[tokenId];\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[from] -= 1;\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits a {Approval} event.\r\n     */\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Enumerable is IERC721 {\r\n    /**\r\n     * @dev Returns the total amount of tokens stored by the contract.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n     * Use along with {totalSupply} to enumerate all tokens.\r\n     */\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\r\n * enumerability of all the token ids in the contract as well as all token ids owned by each\r\n * account.\r\n */\r\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] private _allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\r\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\r\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-tokenByIndex}.\r\n     */\r\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\r\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n        return _allTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n        if (from == address(0)) {\r\n            _addTokenToAllTokensEnumeration(tokenId);\r\n        } else if (from != to) {\r\n            _removeTokenFromOwnerEnumeration(from, tokenId);\r\n        }\r\n        if (to == address(0)) {\r\n            _removeTokenFromAllTokensEnumeration(tokenId);\r\n        } else if (to != from) {\r\n            _addTokenToOwnerEnumeration(to, tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n     * @param to address representing the new owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        uint256 length = ERC721.balanceOf(to);\r\n        _ownedTokens[to][length] = tokenId;\r\n        _ownedTokensIndex[tokenId] = length;\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's token tracking data structures.\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list\r\n     */\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\r\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n        }\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete _ownedTokensIndex[tokenId];\r\n        delete _ownedTokens[from][lastTokenIndex];\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's token tracking data structures.\r\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n     */\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _allTokens.length - 1;\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete _allTokensIndex[tokenId];\r\n        _allTokens.pop();\r\n    }\r\n}\r\n\r\n\r\n// @title Base64\r\n// @notice Provides a function for encoding some bytes in base64\r\n// @author Brecht Devos <brecht@loopring.org>\r\nlibrary Base64 {\r\n    bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n    /// @notice Encodes some bytes to the base64 representation\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        uint256 len = data.length;\r\n        if (len == 0) return \"\";\r\n\r\n        // multiply by 4/3 rounded up\r\n        uint256 encodedLen = 4 * ((len + 2) / 3);\r\n\r\n        // Add some extra buffer at the end\r\n        bytes memory result = new bytes(encodedLen + 32);\r\n\r\n        bytes memory table = TABLE;\r\n\r\n        assembly {\r\n            let tablePtr := add(table, 1)\r\n            let resultPtr := add(result, 32)\r\n\r\n            for {\r\n                let i := 0\r\n            } lt(i, len) {\r\n\r\n            } {\r\n                i := add(i, 3)\r\n                let input := and(mload(add(data, i)), 0xffffff)\r\n\r\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\r\n                out := shl(224, out)\r\n\r\n                mstore(resultPtr, out)\r\n\r\n                resultPtr := add(resultPtr, 4)\r\n            }\r\n\r\n            switch mod(len, 3)\r\n            case 1 {\r\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\r\n            }\r\n            case 2 {\r\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\r\n            }\r\n\r\n            mstore(result, encodedLen)\r\n        }\r\n\r\n        return string(result);\r\n    }\r\n}\r\n\r\n\r\ninterface IPlayingCards {\r\n    function getCardNumberAsUint(uint8 cardId) external view returns (uint8);\r\n    function getCardSuitAsUint(uint8 cardId) external view returns (uint8);\r\n    function getCardNumberAsStr(uint8 cardId) external view returns (string memory);\r\n    function getCardSuitAsStr(uint8 cardId) external view returns (string memory);\r\n    function getCardAsString(uint8 cardId) external view returns (string memory);\r\n    function getCardAsSvg(uint8 cardId) external view returns (string memory);\r\n    function getCardAsComponents(uint8 cardId) external view returns (uint8 number, uint8 suit);\r\n    function getCardBody(uint8 numberId, uint8 suitId, uint256 fX, uint256 sX, uint256 rX) external pure returns (string memory);\r\n    function getSuitPath(uint8 suitId) external pure returns (string memory);\r\n    function getNumberPath(uint8 numberId) external pure returns (string memory);\r\n}\r\n\r\n\r\ncontract HoldemHeroesBase is ERC721Enumerable, Ownable  {\r\n\r\n    // a start-hand combination\r\n    struct Hand {\r\n        uint8 card1; // 0 - 51\r\n        uint8 card2; // 0 - 51\r\n    }\r\n\r\n    uint256 public constant MAX_NFT_SUPPLY = 1326; // final totalSupply of NFTs\r\n\r\n    // sha256 hash of all generated and shuffled hands\r\n    bytes32 public constant HAND_PROVENANCE = 0xbcd1a23f7cca99ec419590e58d82db68573d59d2cdf88a901c5c25edea2c075d;\r\n\r\n    // start index for mapping tokenId on to handId - set during the distribution phase\r\n    uint256 public startingIndex;\r\n    // time after which hands are randomised and allocated to token Ids\r\n    uint256 public REVEAL_TIMESTAMP;\r\n\r\n    // hands have been revealed\r\n    bool public REVEALED;\r\n    // ranks uploaded - used only during uploadHandRanks function\r\n    bool public RANKS_UPLOADED;\r\n    // the block number in which the final hands were revealed\r\n    uint256 public revealBlock;\r\n\r\n    // IPFS hash for provenance JSON - will be set when the last hand batch is revealed\r\n    string public PROVENANCE_IPFS;\r\n\r\n    // array of 1326 possible start hand combinations\r\n    Hand[1326] public hands;\r\n\r\n    // used during reveal function to ensure batches are uploaded sequentially\r\n    // according to provenance\r\n    uint16 public handUploadId;\r\n    uint8 public nextExpectedBatchId = 0;\r\n    // mapping to ensure batch is not re-uploaded. Only used during reveal function\r\n    mapping(bytes32 => bool) private isHandRevealed;\r\n\r\n    // Mapping to hold hand ranks. Requires populating during contract initialisation\r\n    mapping (bytes32 => uint8) public handRanks;\r\n\r\n    // The playing cards contract on which HEH is built\r\n    IPlayingCards public immutable playingCards;\r\n\r\n    /*\r\n     * EVENTS\r\n     */\r\n\r\n    event BatchRevealed(uint16 startHandId, uint16 endHandId, bytes32 batchHash, uint8 batchId);\r\n    event RanksInitialised();\r\n\r\n    /**\r\n     * @dev constructor\r\n     * @dev initialises some basic variables.\r\n     *\r\n     * @param _revealTimestamp uint256 - unix timestamp for when cards will be revealed and distributed\r\n     * @param _playingCards address - address of Playing Cards contract\r\n     */\r\n    constructor(uint256 _revealTimestamp, address _playingCards)\r\n    ERC721(\"Holdem Heroes\", \"HEH\")\r\n    Ownable() {\r\n        REVEAL_TIMESTAMP = _revealTimestamp;\r\n        REVEALED = false;\r\n        RANKS_UPLOADED = false;\r\n        handUploadId = 0;\r\n        playingCards = IPlayingCards(_playingCards);\r\n    }\r\n\r\n    /*\r\n    * ADMIN FUNCTIONS\r\n    */\r\n\r\n    /**\r\n     * @dev uploadHandRanks upload the 169 start hand ranks, which are referenced\r\n     * @dev by the hand getter functions. Hand ranks are stored as a mapping of a\r\n     * @dev sha256 hash and the integer rank value. The hash is generated from a\r\n     * @dev concatenation of the word \"rank\" and the hand's name. e.g.\r\n     * keccak256(\"rankA5s\") => 28\r\n     *\r\n     * @param rankHashes bytes32[] array of sha256 hashes\r\n     * @param ranks uint8[] array of corresponding ranks for rankHashes\r\n     */\r\n    function uploadHandRanks(bytes32[] memory rankHashes, uint8[] memory ranks) external onlyOwner {\r\n        require(!RANKS_UPLOADED, \"uploaded\");\r\n        for (uint8 i = 0; i < rankHashes.length; i++) {\r\n            handRanks[rankHashes[i]] = ranks[i];\r\n        }\r\n        RANKS_UPLOADED = true;\r\n        emit RanksInitialised();\r\n    }\r\n\r\n    /**\r\n     * @dev withdrawETH allows contract owner to withdraw ether\r\n     */\r\n    function withdrawETH() external onlyOwner {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * @dev reveal is used to upload and reveal the generated start hand combinations.\r\n     * @dev hands are uploaded in batches, with each batch containing n\r\n     * @dev hands. each hand is a uint8[] array of card IDs, e.g. [2, 3]\r\n     * @dev with each batch represented as a 2d array of hands, for example, [[2, 3], [3, 4], ...]\r\n     * @dev Batches must be uploaded sequentially according to provenance.\r\n     *\r\n     * @param inputs uint8[2][] batch of hands\r\n     * @param batchId uint8 id of the batch being revealed\r\n     * @param ipfs string IPFS hash of provenance.json. Sent with final batch only\r\n     */\r\n    function reveal(uint8[2][] memory inputs, uint8 batchId, string memory ipfs) public onlyOwner {\r\n        require(block.timestamp >= REVEAL_TIMESTAMP, \"not yet\");\r\n        require(handUploadId < 1325, \"revealed\");\r\n        require(batchId == nextExpectedBatchId, \"seq incorrect\");\r\n        bytes32 dataHash = keccak256(abi.encodePacked(inputs));\r\n        require(!isHandRevealed[dataHash], \"already added\");\r\n        isHandRevealed[dataHash] = true;\r\n        for (uint8 i = 0; i < inputs.length; i++) {\r\n            hands[handUploadId] = Hand(inputs[i][0],inputs[i][1]);\r\n            handUploadId = handUploadId + 1;\r\n        }\r\n        emit BatchRevealed(handUploadId - uint16(inputs.length), handUploadId - 1, dataHash, batchId);\r\n        if (handUploadId == 1326) {\r\n            REVEALED = true;\r\n            PROVENANCE_IPFS = ipfs;\r\n            revealBlock = block.number;\r\n        } else {\r\n            nextExpectedBatchId = nextExpectedBatchId + 1;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * PUBLIC GETTERS\r\n     */\r\n\r\n    /**\r\n     * @dev getHandShape returns the shape for a given hand ID, for example \"Suited\" or \"s\"\r\n     *\r\n     * @param handId uint16 ID of the hand from 0 - 1325\r\n     * @param abbreviate bool whether or not to abbreviate (\"s\" instead of Suited\" if true)\r\n     * @return string shape of hand\r\n     */\r\n    function getHandShape(uint16 handId, bool abbreviate) public validHandId(handId) view returns (string memory) {\r\n        uint8 card1N = playingCards.getCardNumberAsUint(hands[handId].card1);\r\n        uint8 card2N = playingCards.getCardNumberAsUint(hands[handId].card2);\r\n\r\n        uint8 card1S = playingCards.getCardSuitAsUint(hands[handId].card1);\r\n        uint8 card2S = playingCards.getCardSuitAsUint(hands[handId].card2);\r\n\r\n        if (card1N == card2N) {\r\n            return abbreviate ? \"\" : \"Pair\";\r\n        } else if (card1S == card2S) {\r\n            return abbreviate ? \"s\" : \"Suited\";\r\n        } else {\r\n            return abbreviate ? \"o\" : \"Offsuit\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev getHandAsCardIds returns the card IDs (0 - 51) for a given hand ID, for example 12,24\r\n     *\r\n     * @param handId uint16 ID of the hand from 0 - 1325\r\n     * @return card1 uint8 ID of card 1 (0 - 51)\r\n     * @return card2 uint8 ID of card 2 (0 - 51)\r\n     */\r\n    function getHandAsCardIds(uint16 handId) public validHandId(handId) view returns (uint8 card1, uint8 card2) {\r\n        Hand storage hand = hands[handId];\r\n        if (playingCards.getCardNumberAsUint(hand.card1) > playingCards.getCardNumberAsUint(hand.card2)) {\r\n            return (hand.card1, hand.card2);\r\n        } else {\r\n            return (hand.card2, hand.card1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev getHandName returns the canonical name for a given hand ID. This is a concatenation of\r\n     * @dev Card1 + Card2 + Shape, with the cards ordered by card number in descending order.\r\n     * @dev E.g. A5s\r\n     *\r\n     * @param handId uint16 ID of the hand from 0 - 1325\r\n     * @return string hand name\r\n     */\r\n    function getHandName(uint16 handId) public validHandId(handId) view returns (string memory) {\r\n        string memory shape = getHandShape(handId, true);\r\n        (uint8 card1, uint8 card2) = getHandAsCardIds(handId);\r\n\r\n        return string(abi.encodePacked(playingCards.getCardNumberAsStr(card1), playingCards.getCardNumberAsStr(card2), shape));\r\n    }\r\n\r\n    /**\r\n     * @dev getHandRank returns the canonical rank for a given hand ID. Lower is better\r\n     *\r\n     * @param handId uint16 ID of the hand from 0 - 1325\r\n     * @return string hand rank\r\n     */\r\n    function getHandRank(uint16 handId) public validHandId(handId) view returns (uint8) {\r\n        return handRanks[keccak256(abi.encodePacked(\"rank\", getHandName(handId)))];\r\n    }\r\n\r\n    /**\r\n     * @dev getHandAsString returns a concatenation of the card names\r\n     *\r\n     * @param handId uint16 ID of the hand from 0 - 1325\r\n     * @return string hand - cards names concatenated, e.g. AsAc\r\n     */\r\n    function getHandAsString(uint16 handId) public validHandId(handId) view returns (string memory) {\r\n        (uint8 card1, uint8 card2) = getHandAsCardIds(handId);\r\n        return string(abi.encodePacked(playingCards.getCardAsString(card1), playingCards.getCardAsString(card2)));\r\n    }\r\n\r\n    /**\r\n     * @dev getHandAsSvg returns the SVG XML for a hand, which can be rendered as an img src in a UI\r\n     *\r\n     * @param handId uint16 ID of the hand from 0 - 1325\r\n     * @return string SVG XML of a hand of 2 cards\r\n     */\r\n    function getHandAsSvg(uint16 handId) public validHandId(handId) view returns (string memory) {\r\n        (uint8 card1, uint8 card2) = getHandAsCardIds(handId);\r\n\r\n        string[4] memory parts;\r\n        parts[0] = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" viewBox=\\\"0 0 148 62\\\" width=\\\"5in\\\" height=\\\"2.147in\\\">\";\r\n        parts[1] = playingCards.getCardBody(playingCards.getCardNumberAsUint(card1), playingCards.getCardSuitAsUint(card1), 7, 32, 2);\r\n        parts[2] = playingCards.getCardBody(playingCards.getCardNumberAsUint(card2), playingCards.getCardSuitAsUint(card2), 82, 107, 76);\r\n        parts[3] = \"</svg>\";\r\n\r\n        string memory output = string(\r\n            abi.encodePacked(parts[0], parts[1], parts[2], parts[3])\r\n        );\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * @dev getHandHash returns a hand's hash, which can be used to match against the\r\n     * @dev published provenance. Hand hashes can be sequentially concatenated and the\r\n     * @dev concatenation itself hashed (after removing each hand hash's 0x prefix)\r\n     * @dev to get the provenance hash. This provenance hash should match both the published\r\n     * @dev hash and the HAND_PROVENANCE constant in this contract\r\n     *\r\n     * @param handId uint16 ID of the hand from 0 - 1325\r\n     * @return string hash of the hand\r\n     */\r\n    function getHandHash(uint16 handId) public validHandId(handId) view returns (bytes32) {\r\n        (uint8 card1, uint8 card2) = getHandAsCardIds(handId);\r\n        return keccak256(abi.encodePacked(\r\n                toString(handId),\r\n                getHandAsString(handId),\r\n                toString(card1),\r\n                toString(playingCards.getCardNumberAsUint(card1)),\r\n                toString(playingCards.getCardSuitAsUint(card1)),\r\n                toString(card2),\r\n                toString(playingCards.getCardNumberAsUint(card2)),\r\n                toString(playingCards.getCardSuitAsUint(card2))\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev tokenIdToHandId maps a given token ID onto its distributed hand ID\r\n     * @dev Note - this will only run after all hands have been revealed\r\n     * @dev and distributed.\r\n     *\r\n     * @param _tokenId uint256 ID of the NFT token from 0 - 1325\r\n     * @return uint16 hand ID associate to the token\r\n     */\r\n    function tokenIdToHandId(uint256 _tokenId) public view returns (uint16) {\r\n        require(_tokenId >= 0 && _tokenId < 1326, \"invalid id\");\r\n        require(startingIndex > 0, \"not distributed\");\r\n        return uint16((_tokenId + startingIndex) % MAX_NFT_SUPPLY);\r\n    }\r\n\r\n    /**\r\n     * @dev tokenURI generates the base64 encoded JSON of the NFT itself. tokenURI will first call\r\n     * @dev tokenIdToHandId to find which hand the token is for. It will then generate\r\n     * @dev and output the encoded JSON containing the SVG image, name, description and\r\n     * @dev attributes.\r\n     * @dev Note - this will only run after all hands have been revealed\r\n     * @dev and distributed.\r\n     *\r\n     * @param _tokenId uint256 ID of the NFT token from 0 - 1325\r\n     * @return string the token's NFT JSON\r\n     */\r\n    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\r\n        // we need to map the token ID onto the assigned hand ID,\r\n        // based on the distribution's startingIndex. This is only available\r\n        // AFTER distribution has occurred, and will return an error otherwise\r\n        uint16 handId = tokenIdToHandId(_tokenId);\r\n\r\n        string memory handName = getHandAsString(handId);\r\n        string memory shape = getHandShape(handId, false);\r\n        string memory hand = getHandName(handId);\r\n        string memory rank = toString(getHandRank(handId));\r\n\r\n        string memory json = Base64.encode(\r\n            bytes(\r\n                string(\r\n                    abi.encodePacked(\r\n                        \"{\\\"name\\\": \\\"\", handName,\r\n                        \"\\\", \\\"description\\\": \\\"holdemheroes.com\\\",\",\r\n                        getAttributes(shape, hand, rank),\r\n                        \"\\\"image\\\": \\\"data:image/svg+xml;base64,\",\r\n                        Base64.encode(bytes(getHandAsSvg(handId))),\r\n                        \"\\\"}\"\r\n                    )\r\n                )\r\n            )\r\n        );\r\n        string memory output = string(abi.encodePacked(\"data:application/json;base64,\", json));\r\n\r\n        return output;\r\n    }\r\n\r\n    /*\r\n     * PRIVATE FUNCTIONS\r\n     */\r\n\r\n    /**\r\n     * @dev getAttributes will generate the attributes JSON for embedding into the NFT JSON\r\n     *\r\n     * @param shape string shape\r\n     * @param hand string hand\r\n     * @param rank string rank\r\n     * @return string attribute JSON\r\n     */\r\n    function getAttributes(string memory shape, string memory hand, string memory rank) private pure returns (string memory) {\r\n        return string(\r\n            abi.encodePacked(\r\n                \"\\\"attributes\\\": [{ \\\"trait_type\\\": \\\"Shape\\\", \\\"value\\\": \\\"\", shape, \"\\\"},\",\r\n                \"{ \\\"trait_type\\\": \\\"Hand\\\", \\\"value\\\": \\\"\", hand, \"\\\"},\",\r\n                \"{ \\\"trait_type\\\": \\\"Rank\\\", \\\"value\\\": \\\"\", rank, \"\\\"}],\"\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev toString converts a given uint256 to a string. Primarily used in SVG, JSON, string name,\r\n     * @dev and hash generation\r\n     *\r\n     * @param value uint256 number to convert\r\n     * @return string number as a string\r\n     */\r\n    function toString(uint256 value) private pure returns (string memory) {\r\n        // Inspired by OraclizeAPI\"s implementation - MIT license\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n        uint256 _tmpN = value;\r\n        if (_tmpN == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = _tmpN;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (_tmpN != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(_tmpN % 10)));\r\n            _tmpN /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /*\r\n     * MODIFIERS\r\n     */\r\n\r\n    /**\r\n     * @dev validHandId ensures a given hand Id is valid\r\n     *\r\n     * @param handId uint16 id of hand\r\n     */\r\n    modifier validHandId(uint16 handId) {\r\n        require(handId >= 0 && handId < 1326, \"invalid handId\");\r\n        require(REVEALED, \"not revealed\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\ncontract HoldemHeroes is Ownable, HoldemHeroesBase, VORConsumerBase  {\r\n    using PRBMathSD59x18 for int256;\r\n\r\n    // max number of NFTs allowed per address\r\n    uint256 public MAX_PER_ADDRESS_OR_TX;\r\n    // block number for when public sale opens\r\n    uint256 public SALE_START_BLOCK_NUM;\r\n\r\n    uint256 public basePostRevealPrice = 1 ether;\r\n\r\n    /// ---------------------------\r\n    /// ------- CRISP STATE -------\r\n    /// ---------------------------\r\n\r\n    ///@notice block on which last purchase occurred\r\n    uint256 public lastPurchaseBlock;\r\n\r\n    ///@notice block on which we start decaying price\r\n    uint256 public priceDecayStartBlock;\r\n\r\n    ///@notice Starting EMS, before time decay. 59.18-decimal fixed-point\r\n    int256 public nextPurchaseStartingEMS;\r\n\r\n    ///@notice Starting price for next purchase, before time decay. 59.18-decimal fixed-point\r\n    int256 public nextPurchaseStartingPrice;\r\n\r\n    /// ---------------------------\r\n    /// ---- CRISP PARAMETERS -----\r\n    /// ---------------------------\r\n\r\n    ///@notice EMS target. 59.18-decimal fixed-point\r\n    int256 public immutable targetEMS;\r\n\r\n    ///@notice controls decay of sales in EMS. 59.18-decimal fixed-point\r\n    int256 public immutable saleHalflife;\r\n\r\n    ///@notice controls upward price movement. 59.18-decimal fixed-point\r\n    int256 public immutable priceSpeed;\r\n\r\n    ///@notice controls price decay. 59.18-decimal fixed-point\r\n    int256 public immutable priceHalflife;\r\n\r\n    /*\r\n     * EVENTS\r\n     */\r\n\r\n    event DistributionBegun(bytes32 requestId, address sender);\r\n    event DistributionResult(bytes32 requestId, uint256 randomness, uint256 startingIndex);\r\n\r\n    /**\r\n     * @dev constructor\r\n     * @dev initialises some basic variables.\r\n     * @dev CRISP implementation from https://github.com/FrankieIsLost/CRISP/blob/master/src/CRISP.sol\r\n     *\r\n     * @param _vorCoordinator address - address of VORCoordinator contract\r\n     * @param _xfund address - address of xFUND contract\r\n     * @param _playingCards address - address of Playing Cards contract\r\n     * @param _saleStartBlockNum uint256 - block number for when pre-reveal sale starts. Allows time for card/rank init\r\n     * @param _revealTimestamp uint256 - unix timestamp for when cards will be revealed and distributed\r\n     * @param _maxNfts address - max number of NFTs a single wallet address can mint\r\n     * @param _targetBlocksPerSale int256, e.g. 100\r\n     * @param _saleHalflife int256, e.g. 700\r\n     * @param _priceSpeed int256, e.g. 1\r\n     * @param _priceSpeedDenominator int256, e.g. 4. If _priceSpeed param is 1, final priceSpeed will be 0.25\r\n     * @param _priceHalflife int256, e.g. 100\r\n     * @param _startingPrice int256, e.g. 100\r\n     */\r\n    constructor(\r\n        address _vorCoordinator,\r\n        address _xfund,\r\n        address _playingCards,\r\n        uint256 _saleStartBlockNum,\r\n        uint256 _revealTimestamp,\r\n        uint256 _maxNfts,\r\n        int256 _targetBlocksPerSale,\r\n        int256 _saleHalflife,\r\n        int256 _priceSpeed,\r\n        int256 _priceSpeedDenominator,\r\n        int256 _priceHalflife,\r\n        int256 _startingPrice\r\n    )\r\n    VORConsumerBase(_vorCoordinator, _xfund)\r\n    HoldemHeroesBase(_revealTimestamp, _playingCards)\r\n    {\r\n        SALE_START_BLOCK_NUM = (_saleStartBlockNum > block.number) ? _saleStartBlockNum : block.number;\r\n\r\n        MAX_PER_ADDRESS_OR_TX = _maxNfts;\r\n\r\n        // CRISP\r\n        lastPurchaseBlock = SALE_START_BLOCK_NUM;\r\n        priceDecayStartBlock = SALE_START_BLOCK_NUM;\r\n\r\n        // scale parameters - see https://github.com/FrankieIsLost/CRISP/blob/master/src/test/CRISP.t.sol\r\n        int256 targetBlocksPerSale = PRBMathSD59x18.fromInt(\r\n            _targetBlocksPerSale\r\n        );\r\n\r\n        saleHalflife = PRBMathSD59x18.fromInt(_saleHalflife);\r\n        priceSpeed = PRBMathSD59x18.fromInt(_priceSpeed).div(PRBMathSD59x18.fromInt(_priceSpeedDenominator));\r\n        priceHalflife = PRBMathSD59x18.fromInt(_priceHalflife);\r\n\r\n        //calculate target EMS from target blocks per sale\r\n        targetEMS = PRBMathSD59x18.fromInt(1).div(\r\n            PRBMathSD59x18.fromInt(1) -\r\n            PRBMathSD59x18.fromInt(2).pow(\r\n                -targetBlocksPerSale.div(saleHalflife)\r\n            )\r\n        );\r\n\r\n        nextPurchaseStartingEMS = targetEMS;\r\n\r\n        nextPurchaseStartingPrice = PRBMathSD59x18.fromInt(int256(_startingPrice));\r\n    }\r\n\r\n    /*\r\n     * ADMIN\r\n     */\r\n\r\n    /**\r\n     * @dev setBasePostRevealPrice allows owner to adjust post-reveal price according to market\r\n     *\r\n     * @param newPrice uint256 new base price in wei\r\n     */\r\n    function setBasePostRevealPrice(uint256 newPrice) external onlyOwner {\r\n        basePostRevealPrice = newPrice;\r\n    }\r\n\r\n    /*\r\n     * CRISP FUNCTIONS\r\n     */\r\n\r\n    /**\r\n     * @dev getCurrentEMS gets current EMS based on block number.\r\n     * @dev implemented from https://github.com/FrankieIsLost/CRISP/blob/master/src/CRISP.sol\r\n     *\r\n     * @return result int256 59.18-decimal fixed-point\r\n     */\r\n    function getCurrentEMS() public view returns (int256 result) {\r\n        int256 blockInterval = int256(block.number - lastPurchaseBlock);\r\n        blockInterval = blockInterval.fromInt();\r\n        int256 weightOnPrev = PRBMathSD59x18.fromInt(2).pow(\r\n            -blockInterval.div(saleHalflife)\r\n        );\r\n        result = nextPurchaseStartingEMS.mul(weightOnPrev);\r\n    }\r\n\r\n    /**\r\n     * @dev _getNftPrice get quote for purchasing in current block, decaying price as needed.\r\n     * @dev implemented from https://github.com/FrankieIsLost/CRISP/blob/master/src/CRISP.sol\r\n     *\r\n     * @return result int256 59.18-decimal fixed-point\r\n     */\r\n    function _getNftPrice() internal view returns (int256 result) {\r\n        if (block.number <= priceDecayStartBlock) {\r\n            result = nextPurchaseStartingPrice;\r\n        }\r\n        //decay price if we are past decay start block\r\n        else {\r\n            int256 decayInterval = int256(block.number - priceDecayStartBlock)\r\n            .fromInt();\r\n            int256 decay = (-decayInterval).div(priceHalflife).exp();\r\n            result = nextPurchaseStartingPrice.mul(decay);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev getNftPrice get quote for purchasing in current block, decaying price as needed\r\n     * @dev implemented from https://github.com/FrankieIsLost/CRISP/blob/master/src/CRISP.sol\r\n     *\r\n     * @return result uint256 current price in wei\r\n     */\r\n    function getNftPrice() public view returns (uint256 result) {\r\n        int256 pricePerNft = _getNftPrice();\r\n        result = uint256(pricePerNft.toInt());\r\n    }\r\n\r\n    /**\r\n     * @dev getPostRevealNftPrice get mint price for revealed tokens, based on the hand Rank\r\n     * @dev lower rank = better hand = higher price. e.g. AA = rank 1 = high price\r\n     * @dev Note - this can only be used in the event that there are unminted tokens\r\n     * @dev once the pre-reveal sale has ended.\r\n     *\r\n     * @return result uint256 price in wei\r\n     */\r\n    function getPostRevealNftPrice(uint256 _tokenId) public view returns (uint256 result) {\r\n        uint256 rank = uint256(getHandRank(tokenIdToHandId(_tokenId)));\r\n        if(rank == 1) {\r\n            result = basePostRevealPrice;\r\n        } else {\r\n            uint256 m = 100 - ((rank * 100) / 169); // get % as int\r\n            m = (m < 10) ? 10 : m;\r\n            result = (basePostRevealPrice * m) / 100;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev getNextStartingPriceGet starting price for next purchase before time decay\r\n     * @dev implemented from https://github.com/FrankieIsLost/CRISP/blob/master/src/CRISP.sol\r\n     *\r\n     * @param lastPurchasePrice int256 last price as 59.18-decimal fixed-point\r\n     * @return result int256 59.18-decimal fixed-point\r\n     */\r\n    function getNextStartingPrice(int256 lastPurchasePrice)\r\n    public\r\n    view\r\n    returns (int256 result)\r\n    {\r\n        int256 mismatchRatio = nextPurchaseStartingEMS.div(targetEMS);\r\n        if (mismatchRatio > PRBMathSD59x18.fromInt(1)) {\r\n            result = lastPurchasePrice.mul(\r\n                PRBMathSD59x18.fromInt(1) + mismatchRatio.mul(priceSpeed)\r\n            );\r\n        } else {\r\n            result = lastPurchasePrice;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev getPriceDecayStartBlock Find block in which time based price decay should start\r\n     * @dev implemented from https://github.com/FrankieIsLost/CRISP/blob/master/src/CRISP.sol\r\n     *\r\n     * @return result uint256 block number\r\n     */\r\n    function getPriceDecayStartBlock() internal view returns (uint256 result) {\r\n        int256 mismatchRatio = nextPurchaseStartingEMS.div(targetEMS);\r\n        //if mismatch ratio above 1, decay should start in future\r\n        if (mismatchRatio > PRBMathSD59x18.fromInt(1)) {\r\n            uint256 decayInterval = uint256(\r\n                saleHalflife.mul(mismatchRatio.log2()).ceil().toInt()\r\n            );\r\n            result = block.number + decayInterval;\r\n        }\r\n        //else decay should start at the current block\r\n        else {\r\n            result = block.number;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * MINT & DISTRIBUTION FUNCTIONS\r\n     */\r\n\r\n    /**\r\n     * @dev mintNFTPreReveal is a public payable function which any user can call during the pre-reveal\r\n     * @dev sale phase. This allows a user to mint up to MAX_PER_ADDRESS_OR_TX tokens. Tokens are\r\n     * @dev minted sequentially. Mapping of token IDs on to hand IDs (according to provenance) is\r\n     * @dev executed during the reveal & distribution phase, via a call to VOR.\r\n     * @dev Correct ether value is expected to pay for tokens.\r\n     *\r\n     * @param _numberOfNfts uint256 number of NFTs to mint in this Tx\r\n     */\r\n    function mintNFTPreReveal(uint256 _numberOfNfts) external payable {\r\n        uint256 numberOfNfts = (_numberOfNfts > 0) ? _numberOfNfts : 1;\r\n        require(block.number >= SALE_START_BLOCK_NUM, \"not started\");\r\n        require(totalSupply() < MAX_NFT_SUPPLY, \"sold out\");\r\n        require(block.timestamp < REVEAL_TIMESTAMP, \"ended\");\r\n        require(numberOfNfts <= MAX_PER_ADDRESS_OR_TX, \"> max per tx\");\r\n        require(balanceOf(msg.sender) + numberOfNfts <= MAX_PER_ADDRESS_OR_TX, \"> mint limit\");\r\n        require(totalSupply() + numberOfNfts <= MAX_NFT_SUPPLY, \"exceeds supply\");\r\n\r\n        int256 pricePerNft = _getNftPrice();\r\n        uint256 pricePerNftScaled = uint256(pricePerNft.toInt());\r\n        uint256 totalCost = pricePerNftScaled * numberOfNfts;\r\n\r\n        require(msg.value >= totalCost, \"eth too low\");\r\n\r\n        for (uint256 i = 0; i < numberOfNfts; i++) {\r\n            uint256 mintIndex = totalSupply();\r\n            _safeMint(msg.sender, mintIndex);\r\n        }\r\n\r\n        //update CRISP state\r\n        updateCrispState(pricePerNft, numberOfNfts);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev mintNFTPostReveal is a public payable function which any user can call AFTER the pre-reveal\r\n     * @dev sale phase. This allows a user to mint any available token ID that hasn't been sold yet.\r\n     * @dev This function cannot be executed until hands have been revealed and distributed.\r\n     * @dev Correct ether value is expected to pay for token.\r\n     *\r\n     * @param tokenId uint256 NFT Token ID to purchase\r\n     */\r\n    function mintNFTPostReveal(uint256 tokenId) external payable {\r\n        uint256 price = getPostRevealNftPrice(tokenId);\r\n        require(msg.value >= price, \"eth too low\");\r\n\r\n        _safeMint(msg.sender, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev beginDistribution is called to initiate distribution and makes a VOR request to generate\r\n     * @dev a random value. Can only be called after hands have been revealed according to provenance.\r\n     *\r\n     * @param _keyHash bytes32 key hash of the VOR Oracle that will handle the request\r\n     * @param _fee uint256 xFUND fee to pay the VOR Oracle\r\n     */\r\n    function beginDistribution(bytes32 _keyHash, uint256 _fee) public onlyOwner canDistribute {\r\n        _increaseVorCoordinatorAllowance(_fee);\r\n        bytes32 requestId = requestRandomness(_keyHash, _fee, uint256(blockhash(block.number-10)));\r\n        emit DistributionBegun(requestId, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev fallbackDistribution is an emergency fallback function which can be called in the event\r\n     * @dev of the fulfillRandomness function failing. It can only be called by the contract owner\r\n     * @dev and should only be called if beginDistribution failed.\r\n     */\r\n    function fallbackDistribution() public onlyOwner canDistribute {\r\n        uint256 sourceBlock = revealBlock;\r\n\r\n        // Just a sanity check (EVM only stores last 256 block hashes)\r\n        if (block.number - revealBlock > 255) {\r\n            sourceBlock = block.number-1;\r\n        }\r\n\r\n        uint256 randomness = uint(blockhash(sourceBlock));\r\n\r\n        checkAndSetStartIdx(randomness);\r\n\r\n        emit DistributionResult(0x0, 0, startingIndex);\r\n    }\r\n\r\n    /**\r\n     * @dev checkAndSetStartIdx is an internal function which will take the generated randomness\r\n     * @dev and calculate/set the startingIndex mapping value.\r\n     *\r\n     * @param _randomness uint256 generated randomness value from VOR etc.\r\n     */\r\n    function checkAndSetStartIdx(uint256 _randomness) internal {\r\n        // calculate based on randomness\r\n        startingIndex = _randomness % (MAX_NFT_SUPPLY-1);\r\n        // Prevent default sequence\r\n        if (startingIndex == 0) {\r\n            startingIndex = 1;\r\n        }\r\n        if (startingIndex > 1325) {\r\n            startingIndex = 1325;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev fulfillRandomness is called by the VOR Oracle to fulfil the randomness request.\r\n     * @dev The randomness value sent is used to calculate the start array Idx onto which\r\n     * @dev hand IDs are mapped on to the NFT Token IDs.\r\n     * @dev Can only be called by the correct VOR Oracle, and only via the VORCoordinator contract.\r\n     *\r\n     * @param _requestId bytes32 ID of the request fulfilled by the Oracle\r\n     * @param _randomness uint256 the random number generated by the VOR Oracle\r\n     */\r\n    function fulfillRandomness(bytes32 _requestId, uint256 _randomness) internal override {\r\n        require(startingIndex == 0, \"already done\");\r\n        checkAndSetStartIdx(_randomness);\r\n        emit DistributionResult(_requestId, _randomness, startingIndex);\r\n    }\r\n\r\n    /**\r\n     * @dev updateCrispState updates the CRISP parameters for dynamic pricing\r\n     *\r\n     * @param price int256 current price per NFT paid by user\r\n     * @param numMinted uint256 number minted in this Tx\r\n     */\r\n    function updateCrispState(int256 price, uint256 numMinted) internal {\r\n        nextPurchaseStartingEMS = getCurrentEMS() + PRBMathSD59x18.fromInt(int256(numMinted));\r\n        nextPurchaseStartingPrice = getNextStartingPrice(price);\r\n        priceDecayStartBlock = getPriceDecayStartBlock();\r\n        lastPurchaseBlock = block.number;\r\n    }\r\n\r\n    /*\r\n     * MODIFIERS\r\n     */\r\n\r\n    /**\r\n     * @dev canDistribute checks it's time to distribute\r\n     */\r\n    modifier canDistribute() {\r\n        require(startingIndex == 0, \"already done\");\r\n        require(REVEALED, \"not revealed\");\r\n        _;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vorCoordinator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_xfund\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_playingCards\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_saleStartBlockNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_revealTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxNfts\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"_targetBlocksPerSale\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_saleHalflife\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_priceSpeed\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_priceSpeedDenominator\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_priceHalflife\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_startingPrice\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__CeilOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PRBMathSD59x18__DivInputTooSmall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAbs\",\"type\":\"uint256\"}],\"name\":\"PRBMathSD59x18__DivOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__Exp2InputTooBig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__ExpInputTooBig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__FromIntOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__FromIntUnderflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__LogInputTooSmall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PRBMathSD59x18__MulInputTooSmall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAbs\",\"type\":\"uint256\"}],\"name\":\"PRBMathSD59x18__MulOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prod1\",\"type\":\"uint256\"}],\"name\":\"PRBMath__MulDivFixedPointOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prod1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"PRBMath__MulDivOverflow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"startHandId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"endHandId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"batchHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"batchId\",\"type\":\"uint8\"}],\"name\":\"BatchRevealed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"DistributionBegun\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingIndex\",\"type\":\"uint256\"}],\"name\":\"DistributionResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RanksInitialised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HAND_PROVENANCE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_NFT_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PER_ADDRESS_OR_TX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROVENANCE_IPFS\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RANKS_UPLOADED\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REVEALED\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REVEAL_TIMESTAMP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SALE_START_BLOCK_NUM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePostRevealPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"beginDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fallbackDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEMS\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"result\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"handId\",\"type\":\"uint16\"}],\"name\":\"getHandAsCardIds\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"card1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"card2\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"handId\",\"type\":\"uint16\"}],\"name\":\"getHandAsString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"handId\",\"type\":\"uint16\"}],\"name\":\"getHandAsSvg\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"handId\",\"type\":\"uint16\"}],\"name\":\"getHandHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"handId\",\"type\":\"uint16\"}],\"name\":\"getHandName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"handId\",\"type\":\"uint16\"}],\"name\":\"getHandRank\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"handId\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"abbreviate\",\"type\":\"bool\"}],\"name\":\"getHandShape\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"lastPurchasePrice\",\"type\":\"int256\"}],\"name\":\"getNextStartingPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"result\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNftPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getPostRevealNftPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"handRanks\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"handUploadId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hands\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"card1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"card2\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPurchaseBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mintNFTPostReveal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberOfNfts\",\"type\":\"uint256\"}],\"name\":\"mintNFTPreReveal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextExpectedBatchId\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextPurchaseStartingEMS\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextPurchaseStartingPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"playingCards\",\"outputs\":[{\"internalType\":\"contract IPlayingCards\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceDecayStartBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceHalflife\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceSpeed\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"rawFulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[2][]\",\"name\":\"inputs\",\"type\":\"uint8[2][]\"},{\"internalType\":\"uint8\",\"name\":\"batchId\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"ipfs\",\"type\":\"string\"}],\"name\":\"reveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revealBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleHalflife\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setBasePostRevealPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetEMS\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenIdToHandId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"rankHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint8[]\",\"name\":\"ranks\",\"type\":\"uint8[]\"}],\"name\":\"uploadHandRanks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HoldemHeroes", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ceb679de692660dd701837c25a4181492050ed8f000000000000000000000000892a6f9df0147e5f079b0993f486f9aca3c87881000000000000000000000000c3a3d9f2263a82b740b921fbb386ec5820fddf9e0000000000000000000000000000000000000000000000000000000000df1e5c00000000000000000000000000000000000000000000000000000000626406600000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000c40000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000c4000000000000000000000000000000000000000000000000016345785d8a0000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2368e0dc7711ed437a6113708eefa64ae68ccb1c529d3cb7b5d18ec918aec2ad"}]}