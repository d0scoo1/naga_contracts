{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: contracts/Owned.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Caller should be Owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/Interfaces/IVoting.sol\r\n\r\n\r\n\r\npragma solidity >=0.8.4;\r\n\r\ninterface IVoting {\r\n\r\n    struct Votes {\r\n        uint256 approvals;\r\n        uint256 disapprovals;\r\n    }\r\n\r\n    struct VotingAmount{\r\n        uint256 approvedTimes;\r\n        uint256 dissaprovedTimes;\r\n    }\r\n\r\n    struct Voter {\r\n        string proposal;\r\n        address voterAddress;\r\n        bool vote;\r\n        uint40 timestamp;\r\n    }\r\n    \r\n    enum Status {\r\n      Vote_now,\r\n      soon,\r\n      Closed\r\n    }\r\n\r\n    enum Type {\r\n        core,\r\n        community\r\n    }\r\n\r\n    struct Proposal {\r\n        string proposal;\r\n        bool exists;\r\n        uint256 voteCount;\r\n        Type proposalType;\r\n        Status proposalStatus;\r\n        uint40 startTime;\r\n        uint40 endTime;\r\n        Votes votes;\r\n    }\r\n\r\n    event addedProposal (string newProposals, uint40 timestamp);\r\n    event votedProposal(string proposal, bool choice);\r\n    function changeWithdrawAddress(address _newWithdrawAddress) external;\r\n    function voteProposal(string memory proposal, bool choice) external; \r\n    function isBlocked(address _addr) external view  returns (bool);\r\n    function blockAddress(address target, bool freeze) external;\r\n    \r\n}\r\n// File: contracts/SPJVoting.sol\r\n\r\n\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n\r\n\r\n\r\n\r\ncontract SPJVoting is IVoting, owned {\r\n\r\n    IERC20 public SPJ;\r\n\r\n    mapping(address => bool) public coreMember;\r\n    mapping(address => bool) public blocked;\r\n    mapping(string => Proposal) public proposals;\r\n    mapping(string => Voter) public voters;\r\n    mapping(address => mapping(string => VotingAmount)) public votingAmount;\r\n    uint8 public decimals = 18;\r\n\r\n    address public withdrawAddress;\r\n    uint256 public proposalFee;\r\n\r\n    bool proposingLive;\r\n\r\n    constructor(IERC20 coinAddress) {\r\n        SPJ = coinAddress;\r\n        withdrawAddress = msg.sender;\r\n        proposalFee = 100;\r\n    }\r\n\r\n    function changeWithdrawAddress(address _newWithdrawAddress) public onlyOwner override {\r\n        withdrawAddress = _newWithdrawAddress;\r\n    }\r\n\r\n    function proposalFeeAmount(uint256 _newAmount) public onlyOwner {\r\n        proposalFee = _newAmount;\r\n    }\r\n\r\n    function blockAddress(address target, bool freeze) public onlyOwner override {\r\n        blocked[target] = freeze;\r\n    }\r\n\r\n    function whitelist_as_core(address target, bool state) public onlyOwner {\r\n        coreMember[target] = state;\r\n    }\r\n    \r\n    function isBlocked(address _addr) public view  override returns (bool) {\r\n        return blocked[_addr];\r\n    }\r\n\r\n     function toggleproposingStatus() public onlyOwner {\r\n        proposingLive = !proposingLive;\r\n    }\r\n\r\n    string[] allProposals;\r\n    Voter[] allVoters;\r\n\r\n\r\n    function getAllProposals () public view returns(Proposal[] memory) {\r\n        Proposal[] memory availableProposals = new Proposal[](allProposals.length);\r\n        \r\n        for (uint256 i = 0; i < allProposals.length; i++) {\r\n                availableProposals[i] = proposals[allProposals[i]];\r\n        }\r\n\r\n        return availableProposals;\r\n    }\r\n\r\n    function getAllVoters () public view returns(Voter[] memory) {\r\n        Voter[] memory availableVoters = new Voter[](allVoters.length);\r\n        \r\n        for (uint256 i = 0; i < allVoters.length; i++) {\r\n                availableVoters[i] = allVoters[i];\r\n        }\r\n\r\n        return availableVoters;\r\n    }\r\n\r\n\r\n    function addProposals (string memory newProposal, uint40 startTime, uint40 endTime) public {\r\n        require(proposingLive, \"Not allowed to make a proposal yet\");\r\n        require(!isBlocked(msg.sender), \"Sender is blocked\");\r\n        require(!proposals[newProposal].exists, \"proposal already exists\");\r\n        require(endTime > startTime, \"proposal timeline invalid\");\r\n\r\n        if(coreMember[msg.sender] || msg.sender == owner){\r\n            proposals[newProposal].proposalType = Type(0);\r\n        }\r\n        else{\r\n            proposals[newProposal].proposalType = Type(1);\r\n        }\r\n        proposals[newProposal].proposal = newProposal;\r\n        proposals[newProposal].exists = true;\r\n        proposals[newProposal].voteCount = 0;\r\n        proposals[newProposal].startTime = startTime;\r\n        proposals[newProposal].endTime = endTime;\r\n\r\n        if(startTime <= uint40(block.timestamp)){\r\n        proposals[newProposal].proposalStatus = Status(0);\r\n        }\r\n        else{\r\n        proposals[newProposal].proposalStatus = Status(1);\r\n        }\r\n\r\n        proposals[newProposal].votes = Votes({approvals: 0, disapprovals: 0});\r\n\r\n        allProposals.push(newProposal);\r\n        IERC20(SPJ).transferFrom(msg.sender, address(this), (proposalFee * 10 ** uint256(decimals)));\r\n        emit addedProposal(newProposal, startTime);\r\n\r\n    }\r\n\r\n    function updateProposalStatus (string memory proposal, uint8 _status) public onlyOwner{\r\n        require(proposals[proposal].exists, \"proposal does not exist\");\r\n        proposals[proposal].proposalStatus = Status(_status);\r\n    }\r\n\r\n    function voteProposal(string memory proposal, bool choice) public override {\r\n        require(!isBlocked(msg.sender), \"Sender is blocked\");\r\n        require(proposals[proposal].exists, \"proposal does not exist\");\r\n        require(proposals[proposal].proposalStatus != Status.Closed, \"proposal has been closed\");\r\n        require(proposals[proposal].startTime <= uint40(block.timestamp), \"Not allowed to Vote yet\");\r\n        require(proposals[proposal].endTime > uint40(block.timestamp), \"Voting has ended\");\r\n\r\n        uint256 amount;\r\n\r\n        proposals[proposal].voteCount += 1;\r\n        if(choice == true){\r\n            votingAmount[msg.sender][proposal].approvedTimes += 1;\r\n            proposals[proposal].votes.approvals += 1;\r\n            amount = votingAmount[msg.sender][proposal].approvedTimes * votingAmount[msg.sender][proposal].approvedTimes;\r\n        }\r\n        else{\r\n            votingAmount[msg.sender][proposal].dissaprovedTimes += 1;\r\n            proposals[proposal].votes.disapprovals += 1;\r\n            amount = votingAmount[msg.sender][proposal].dissaprovedTimes * votingAmount[msg.sender][proposal].dissaprovedTimes;\r\n        }\r\n        voters[proposal].proposal = proposal;\r\n        voters[proposal].voterAddress = msg.sender;\r\n        voters[proposal].vote = choice;\r\n        voters[proposal].timestamp = uint40(block.timestamp);\r\n\r\n        allVoters.push(voters[proposal]);\r\n        IERC20(SPJ).transferFrom(msg.sender, address(this), (amount * 10 ** uint256(decimals)));\r\n        emit votedProposal(proposal, choice);\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n      require(IERC20(SPJ).balanceOf(address(this)) > 0, \"Balance is 0\");\r\n      require(withdrawAddress != address(0), \"the withdraw address is invalid\");\r\n        (bool os, ) = payable(withdrawAddress).call{\r\n            value: address(this).balance\r\n        }(\"\");\r\n        IERC20(SPJ).transfer(withdrawAddress, IERC20(SPJ).balanceOf(address(this)));\r\n        require(os);\r\n   }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"coinAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newProposals\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"}],\"name\":\"addedProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"proposal\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"choice\",\"type\":\"bool\"}],\"name\":\"votedProposal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SPJ\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newProposal\",\"type\":\"string\"},{\"internalType\":\"uint40\",\"name\":\"startTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"endTime\",\"type\":\"uint40\"}],\"name\":\"addProposals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"blockAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWithdrawAddress\",\"type\":\"address\"}],\"name\":\"changeWithdrawAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"coreMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllProposals\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"proposal\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"voteCount\",\"type\":\"uint256\"},{\"internalType\":\"enum IVoting.Type\",\"name\":\"proposalType\",\"type\":\"uint8\"},{\"internalType\":\"enum IVoting.Status\",\"name\":\"proposalStatus\",\"type\":\"uint8\"},{\"internalType\":\"uint40\",\"name\":\"startTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"endTime\",\"type\":\"uint40\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"approvals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"disapprovals\",\"type\":\"uint256\"}],\"internalType\":\"struct IVoting.Votes\",\"name\":\"votes\",\"type\":\"tuple\"}],\"internalType\":\"struct IVoting.Proposal[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllVoters\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"proposal\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"voterAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"vote\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"}],\"internalType\":\"struct IVoting.Voter[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isBlocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newAmount\",\"type\":\"uint256\"}],\"name\":\"proposalFeeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"proposal\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"voteCount\",\"type\":\"uint256\"},{\"internalType\":\"enum IVoting.Type\",\"name\":\"proposalType\",\"type\":\"uint8\"},{\"internalType\":\"enum IVoting.Status\",\"name\":\"proposalStatus\",\"type\":\"uint8\"},{\"internalType\":\"uint40\",\"name\":\"startTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"endTime\",\"type\":\"uint40\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"approvals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"disapprovals\",\"type\":\"uint256\"}],\"internalType\":\"struct IVoting.Votes\",\"name\":\"votes\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleproposingStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"proposal\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_status\",\"type\":\"uint8\"}],\"name\":\"updateProposalStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"proposal\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"choice\",\"type\":\"bool\"}],\"name\":\"voteProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"voters\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"proposal\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"voterAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"vote\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"votingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"approvedTimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dissaprovedTimes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"whitelist_as_core\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SPJVoting", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000003f5919205a01fa0c44e8f4c4ba897629b26b076a", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://37164e0f3b6df755dae819297b26b942a4c2d1c447cc3965918c992df1435dd2"}]}