{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/core/MosaicVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\r\\n\\r\\nimport \\\"../interfaces/IMosaicHolding.sol\\\";\\r\\nimport \\\"../interfaces/IMosaicExchange.sol\\\";\\r\\nimport \\\"../interfaces/IReceiptBase.sol\\\";\\r\\nimport \\\"../interfaces/ITokenFactory.sol\\\";\\r\\nimport \\\"../interfaces/IMosaicVaultConfig.sol\\\";\\r\\nimport \\\"../interfaces/IWETH.sol\\\";\\r\\nimport \\\"../interfaces/IMosaicVault.sol\\\";\\r\\nimport \\\"../interfaces/IInvestmentStrategy.sol\\\";\\r\\nimport \\\"../interfaces/IMosaicNativeSwapper.sol\\\";\\r\\n\\r\\nimport \\\"../libraries/FeeOperations.sol\\\";\\r\\n\\r\\n//@title: Composable Finance Mosaic ERC20 Vault\\r\\ncontract MosaicVault is\\r\\n    IMosaicVault,\\r\\n    OwnableUpgradeable,\\r\\n    ReentrancyGuardUpgradeable,\\r\\n    PausableUpgradeable\\r\\n{\\r\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\r\\n\\r\\n    struct DepositInfo {\\r\\n        address token;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    struct TemporaryWithdrawData {\\r\\n        address tokenIn;\\r\\n        address remoteTokenIn;\\r\\n        bytes32 id;\\r\\n    }\\r\\n\\r\\n    /// @notice Public mapping to keep track of all the withdrawn funds\\r\\n    mapping(bytes32 => bool) public hasBeenWithdrawn;\\r\\n\\r\\n    /// @notice Public mapping to keep track of all the refunded funds\\r\\n    mapping(bytes32 => bool) public hasBeenRefunded;\\r\\n\\r\\n    /// @dev mapping userAddress => tokenAddress => activeLiquidityAvailableAfterBlock (block number)\\r\\n    mapping(address => mapping(address => uint256)) private activeLiquidityAvailableAfterBlock;\\r\\n\\r\\n    /// @dev mapping userAddress => tokenAddress => passiveLiquidityAvailableAfterTimestamp (block timestamp)\\r\\n    mapping(address => mapping(address => uint256)) public passiveLiquidityAvailableAfterTimestamp;\\r\\n\\r\\n    /// @notice Public mapping to track the user deposits\\r\\n    /// @dev bytes32 => DepositInfo struct (token address, amount)\\r\\n    mapping(bytes32 => DepositInfo) public deposits;\\r\\n\\r\\n    /// @notice Store the last withdrawn ID\\r\\n    bytes32 public lastWithdrawID;\\r\\n\\r\\n    /// @notice Store the last refunded ID\\r\\n    bytes32 public lastRefundedID;\\r\\n\\r\\n    /// @notice Relayer address\\r\\n    address public relayer;\\r\\n\\r\\n    IMosaicVaultConfig public override vaultConfig;\\r\\n\\r\\n    /// @notice Initialize function to set up the contract\\r\\n    /// @dev it should be called immediately after deploy\\r\\n    /// @param _mosaicVaultConfig Address of the MosaicVaultConfig\\r\\n    function initialize(address _mosaicVaultConfig) public initializer {\\r\\n        __Ownable_init();\\r\\n        __Pausable_init();\\r\\n        __ReentrancyGuard_init();\\r\\n\\r\\n        vaultConfig = IMosaicVaultConfig(_mosaicVaultConfig);\\r\\n    }\\r\\n\\r\\n    /// @notice External callable function to set the relayer address\\r\\n    function setRelayer(address _relayer) external override onlyOwner {\\r\\n        emit RelayerSet(relayer, _relayer);\\r\\n        relayer = _relayer;\\r\\n    }\\r\\n\\r\\n    /// @notice External callable function to set the vault config address\\r\\n    function setVaultConfig(address _vaultConfig) external override onlyOwner {\\r\\n        emit ConfigSet(address(vaultConfig), _vaultConfig);\\r\\n        vaultConfig = IMosaicVaultConfig(_vaultConfig);\\r\\n    }\\r\\n\\r\\n    /// @notice External function used by the user to provide active liquidity to the vault\\r\\n    ///         User will receive equal amount of IOU tokens\\r\\n    /// @param _amount Amount of tokens he want to deposit; 0 for ETH\\r\\n    /// @param _tokenAddress Address of the token he want to deposit; 0x0 for ETH\\r\\n    /// @param _blocksForActiveLiquidity For how many blocks the liquidity is locked\\r\\n    function provideActiveLiquidity(\\r\\n        uint256 _amount,\\r\\n        address _tokenAddress,\\r\\n        uint256 _blocksForActiveLiquidity\\r\\n    )\\r\\n        public\\r\\n        payable\\r\\n        override\\r\\n        nonReentrant\\r\\n        whenNotPaused\\r\\n        inBlockApproveRange(_blocksForActiveLiquidity)\\r\\n    {\\r\\n        require(_amount > 0 || msg.value > 0, \\\"ERR: AMOUNT\\\");\\r\\n        if (msg.value > 0) {\\r\\n            require(\\r\\n                vaultConfig.getUnderlyingIOUAddress(vaultConfig.wethAddress()) != address(0),\\r\\n                \\\"ERR: WETH\\\"\\r\\n            );\\r\\n            _provideLiquidity(msg.value, vaultConfig.wethAddress(), _blocksForActiveLiquidity);\\r\\n        } else {\\r\\n            require(_tokenAddress != address(0), \\\"ERR: INVALID\\\");\\r\\n            require(vaultConfig.getUnderlyingIOUAddress(_tokenAddress) != address(0), \\\"ERR: TOKEN\\\");\\r\\n            _provideLiquidity(_amount, _tokenAddress, _blocksForActiveLiquidity);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice External function used by the user to provide passive liquidity to the vault\\r\\n    ///         User will receive equal amount of Receipt tokens\\r\\n    /// @param _amount Deposited token's amount; 0 for ETH\\r\\n    /// @param _tokenAddress Deposited token's address; 0x0 for ETH\\r\\n    function providePassiveLiquidity(uint256 _amount, address _tokenAddress)\\r\\n        external\\r\\n        payable\\r\\n        override\\r\\n        nonReentrant\\r\\n        whenNotPaused\\r\\n    {\\r\\n        require(_amount > 0 || msg.value > 0, \\\"ERR: AMOUNT\\\");\\r\\n        if (msg.value > 0) {\\r\\n            require(\\r\\n                vaultConfig.getUnderlyingReceiptAddress(vaultConfig.wethAddress()) != address(0),\\r\\n                \\\"ERR: WETH \\\"\\r\\n            );\\r\\n            _provideLiquidity(msg.value, vaultConfig.wethAddress(), 0);\\r\\n        } else {\\r\\n            require(_tokenAddress != address(0), \\\"ERR: INVALID\\\");\\r\\n            require(\\r\\n                vaultConfig.getUnderlyingReceiptAddress(_tokenAddress) != address(0),\\r\\n                \\\"ERR: TOKEN\\\"\\r\\n            );\\r\\n            _provideLiquidity(_amount, _tokenAddress, 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Internal function called to deposit liquidity, both passive and active liquidity\\r\\n    /// @param _amount Deposited token's amount; 0 for ETH\\r\\n    /// @param _tokenAddress Deposited token's address; WETH address for ETH\\r\\n    /// @param _blocksForActiveLiquidity For how many blocks the liquidity is locked.\\r\\n    ///                                  Should be 0 if liquidity is passive\\r\\n    function _provideLiquidity(\\r\\n        uint256 _amount,\\r\\n        address _tokenAddress,\\r\\n        uint256 _blocksForActiveLiquidity\\r\\n    ) private {\\r\\n        uint256 finalAmount = _amount;\\r\\n        //ETH\\r\\n        if (msg.value > 0) {\\r\\n            uint256 previousWethAmount = IWETH(_tokenAddress).balanceOf(address(this));\\r\\n            IWETH(_tokenAddress).deposit{value: msg.value}();\\r\\n            uint256 currentWethAmount = IWETH(_tokenAddress).balanceOf(address(this));\\r\\n            finalAmount = currentWethAmount - previousWethAmount;\\r\\n            require(finalAmount >= msg.value, \\\"ERR: WRAP\\\");\\r\\n\\r\\n            IERC20Upgradeable(_tokenAddress).safeTransfer(\\r\\n                vaultConfig.getMosaicHolding(),\\r\\n                finalAmount\\r\\n            );\\r\\n        } else {\\r\\n            IERC20Upgradeable(_tokenAddress).safeTransferFrom(\\r\\n                msg.sender,\\r\\n                vaultConfig.getMosaicHolding(),\\r\\n                finalAmount\\r\\n            );\\r\\n        }\\r\\n        if (_blocksForActiveLiquidity > 0) {\\r\\n            //active liquidity\\r\\n            IReceiptBase(vaultConfig.getUnderlyingIOUAddress(_tokenAddress)).mint(\\r\\n                msg.sender,\\r\\n                finalAmount\\r\\n            );\\r\\n            _updateActiveLiquidityAvailableAfterBlock(_tokenAddress, _blocksForActiveLiquidity);\\r\\n            emit DepositActiveLiquidity(\\r\\n                _tokenAddress,\\r\\n                msg.sender,\\r\\n                finalAmount,\\r\\n                _blocksForActiveLiquidity\\r\\n            );\\r\\n        } else {\\r\\n            //passive liquidity\\r\\n            IReceiptBase(vaultConfig.getUnderlyingReceiptAddress(_tokenAddress)).mint(\\r\\n                msg.sender,\\r\\n                finalAmount\\r\\n            );\\r\\n            _updatePassiveLiquidityAvailableAfterTimestamp(_tokenAddress);\\r\\n            emit DepositPassiveLiquidity(_tokenAddress, msg.sender, finalAmount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Internal function called to update the availability of the active liquidity for a token and user\\r\\n    /// @param _token address of the token which availability will be updated\\r\\n    /// @param _blocksForActiveLiquidity number of blocks the active liquidity will last\\r\\n    function _updateActiveLiquidityAvailableAfterBlock(\\r\\n        address _token,\\r\\n        uint256 _blocksForActiveLiquidity\\r\\n    ) private {\\r\\n        uint256 _availableAfter = activeLiquidityAvailableAfterBlock[msg.sender][_token];\\r\\n        uint256 _newAvailability = block.number + _blocksForActiveLiquidity;\\r\\n        if (_availableAfter < _newAvailability) {\\r\\n            activeLiquidityAvailableAfterBlock[msg.sender][_token] = _newAvailability;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Internal function called to update the availability of the passive liquidity for a token and user\\r\\n    /// @param _token address of the token which availability will be updated\\r\\n    function _updatePassiveLiquidityAvailableAfterTimestamp(address _token) private {\\r\\n        uint256 _availableAfter = passiveLiquidityAvailableAfterTimestamp[msg.sender][_token];\\r\\n        uint256 _newAvailability = block.timestamp + vaultConfig.passiveLiquidityLocktime();\\r\\n        if (_availableAfter < _newAvailability) {\\r\\n            passiveLiquidityAvailableAfterTimestamp[msg.sender][_token] = _newAvailability;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice External function called to add withdraw liquidity request\\r\\n    /// @param _receiptToken Address of the iou token provider have\\r\\n    /// @param _amountIn Amount of tokens provider want to withdraw\\r\\n    /// @param _tokenOut Address of the token which LP wants to receive\\r\\n    /// @param _ammID the amm to use for swapping\\r\\n    /// @param _data extra call data\\r\\n    /// @param _destinationNetworkId networkId of the _receiptToken's underlying token\\r\\n    /// @param _withdrawRequestData set of data for withdraw\\r\\n    function withdrawLiquidityRequest(\\r\\n        address _receiptToken,\\r\\n        uint256 _amountIn,\\r\\n        address _tokenOut,\\r\\n        address _destinationAddress,\\r\\n        uint256 _ammID,\\r\\n        bytes calldata _data,\\r\\n        uint256 _destinationNetworkId,\\r\\n        WithdrawRequestData calldata _withdrawRequestData\\r\\n    ) external override nonReentrant returns (bytes32) {\\r\\n        require(_amountIn > 0, \\\"ERR: AMOUNT\\\");\\r\\n        require(paused() == false, \\\"ERR: PAUSED\\\");\\r\\n        require(vaultConfig.pausedNetwork(_destinationNetworkId) == false, \\\"ERR: PAUSED NETWORK\\\");\\r\\n\\r\\n        TemporaryWithdrawData memory tempData = _getTemporaryWithdrawData(\\r\\n            _receiptToken,\\r\\n            _tokenOut,\\r\\n            _destinationNetworkId\\r\\n        );\\r\\n\\r\\n        require(IReceiptBase(_receiptToken).balanceOf(msg.sender) >= _amountIn, \\\"ERR: BALANCE\\\");\\r\\n        IReceiptBase(_receiptToken).burn(msg.sender, _amountIn);\\r\\n\\r\\n        emit WithdrawRequest(\\r\\n            msg.sender,\\r\\n            _receiptToken,\\r\\n            tempData.tokenIn,\\r\\n            _amountIn,\\r\\n            _tokenOut,\\r\\n            tempData.remoteTokenIn,\\r\\n            _destinationAddress,\\r\\n            _ammID,\\r\\n            _destinationNetworkId,\\r\\n            _data,\\r\\n            tempData.id,\\r\\n            _withdrawRequestData\\r\\n        );\\r\\n\\r\\n        return tempData.id;\\r\\n    }\\r\\n\\r\\n    /// @dev for solving stack too deep error\\r\\n    /// @param _receiptToken Address of the iou token provider have\\r\\n    /// @param _tokenOut Address of the token which LP wants to receive\\r\\n    /// @param _networkId networkId of the _receiptToken's underlying token\\r\\n    function _getTemporaryWithdrawData(\\r\\n        address _receiptToken,\\r\\n        address _tokenOut,\\r\\n        uint256 _networkId\\r\\n    ) private validAddress(_tokenOut) returns (TemporaryWithdrawData memory) {\\r\\n        address tokenIn = IReceiptBase(_receiptToken).underlyingToken();\\r\\n        address remoteTokenIn;\\r\\n        // this condition is needed when the withdraw liquidity is requested on another network\\r\\n        if (_networkId != block.chainid) {\\r\\n            remoteTokenIn = vaultConfig.remoteTokenAddress(_networkId, tokenIn);\\r\\n            require(remoteTokenIn != address(0), \\\"ERR: TOKEN\\\");\\r\\n        } else {\\r\\n            remoteTokenIn = tokenIn;\\r\\n        }\\r\\n\\r\\n        if (vaultConfig.getUnderlyingIOUAddress(tokenIn) == _receiptToken) {\\r\\n            // active liquidity\\r\\n            // check if active liquidity is still locked\\r\\n            require(\\r\\n                activeLiquidityAvailableAfterBlock[msg.sender][tokenIn] <= block.number,\\r\\n                \\\"ERR: LIQUIDITY\\\"\\r\\n            );\\r\\n        } else if (vaultConfig.getUnderlyingReceiptAddress(tokenIn) == _receiptToken) {\\r\\n            // passive liquidity\\r\\n            // check if passive liquidity is still locked\\r\\n            require(\\r\\n                passiveLiquidityAvailableAfterTimestamp[msg.sender][tokenIn] <= block.timestamp,\\r\\n                \\\"ERR: LIQUIDITY\\\"\\r\\n            );\\r\\n            // passive liquidity can only be withdrawn in the same token\\r\\n            require(remoteTokenIn == _tokenOut, \\\"ERR: TOKEN OUT\\\");\\r\\n        } else {\\r\\n            revert(\\\"ERR: TOKEN NOT WHITELISTED\\\");\\r\\n        }\\r\\n        return TemporaryWithdrawData(tokenIn, remoteTokenIn, vaultConfig.generateId());\\r\\n    }\\r\\n\\r\\n    /// @notice Called by relayer to withdraw liquidity from the vault\\r\\n    /// @param _accountTo eth address to send the withdrawal tokens\\r\\n    /// @param _amount amount requested by user + rewards for token in\\r\\n    /// @param _requestedAmount amount requested by user for token in\\r\\n    /// @param _tokenIn address of the token in\\r\\n    /// @param _tokenOut address of the token out\\r\\n    /// @param _amountOutMin minimum amount out user wants\\r\\n    /// @param _withdrawData set of data for withdraw\\r\\n    /// @param _data additional data required for each AMM implementation\\r\\n    function withdrawLiquidity(\\r\\n        address _accountTo,\\r\\n        uint256 _amount,\\r\\n        uint256 _requestedAmount,\\r\\n        address _tokenIn,\\r\\n        address _tokenOut,\\r\\n        uint256 _amountOutMin,\\r\\n        WithdrawData calldata _withdrawData,\\r\\n        bytes calldata _data\\r\\n    ) external override {\\r\\n        uint256 withdrawAmount = _withdraw(\\r\\n            _accountTo,\\r\\n            _amount,\\r\\n            _tokenIn,\\r\\n            _tokenOut,\\r\\n            _amountOutMin,\\r\\n            _withdrawData,\\r\\n            _data\\r\\n        );\\r\\n\\r\\n        emit LiquidityWithdrawn(\\r\\n            _accountTo,\\r\\n            _tokenIn,\\r\\n            _tokenOut,\\r\\n            _amount,\\r\\n            _requestedAmount,\\r\\n            withdrawAmount,\\r\\n            _withdrawData.baseFee,\\r\\n            _withdrawData.feePercentage,\\r\\n            _withdrawData.amountToSwapToNative > 0,\\r\\n            _withdrawData.id\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice method called by the relayer to release transfer funds\\r\\n    /// @param _accountTo eth address to send the withdrawal tokens\\r\\n    /// @param _amount amount of token in\\r\\n    /// @param _tokenIn address of the token in\\r\\n    /// @param _tokenOut address of the token out\\r\\n    /// @param _amountOutMin minimum amount out user wants\\r\\n    /// @param _withdrawData set of data for withdraw\\r\\n    /// @param _data additional data required for each AMM implementation\\r\\n    function withdrawTo(\\r\\n        address _accountTo,\\r\\n        uint256 _amount,\\r\\n        address _tokenIn,\\r\\n        address _tokenOut,\\r\\n        uint256 _amountOutMin,\\r\\n        WithdrawData calldata _withdrawData,\\r\\n        bytes calldata _data\\r\\n    ) external override {\\r\\n        uint256 withdrawAmount = _withdraw(\\r\\n            _accountTo,\\r\\n            _amount,\\r\\n            _tokenIn,\\r\\n            _tokenOut,\\r\\n            _amountOutMin,\\r\\n            _withdrawData,\\r\\n            _data\\r\\n        );\\r\\n\\r\\n        emit WithdrawalCompleted(\\r\\n            _accountTo,\\r\\n            _amount,\\r\\n            withdrawAmount,\\r\\n            _tokenOut,\\r\\n            _withdrawData.id,\\r\\n            _withdrawData.amountToSwapToNative > 0\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev internal function called by `withdrawLiquidity` and `withdrawTo`\\r\\n    /// @param _accountTo eth address to send the withdrawal tokens\\r\\n    /// @param _amount amount of token in\\r\\n    /// @param _tokenIn address of the token in\\r\\n    /// @param _tokenOut address of the token out\\r\\n    /// @param _amountOutMin minimum amount out user wants\\r\\n    /// @param _withdrawData set of data for withdraw\\r\\n    /// @param _data additional data required for each AMM implementation\\r\\n    function _withdraw(\\r\\n        address _accountTo,\\r\\n        uint256 _amount,\\r\\n        address _tokenIn,\\r\\n        address _tokenOut,\\r\\n        uint256 _amountOutMin,\\r\\n        WithdrawData memory _withdrawData,\\r\\n        bytes calldata _data\\r\\n    )\\r\\n        internal\\r\\n        onlyWhitelistedToken(_tokenIn)\\r\\n        validAddress(_tokenOut)\\r\\n        nonReentrant\\r\\n        onlyOwnerOrRelayer\\r\\n        whenNotPaused\\r\\n        returns (uint256 withdrawAmount)\\r\\n    {\\r\\n        IMosaicHolding mosaicHolding = IMosaicHolding(vaultConfig.getMosaicHolding());\\r\\n        require(hasBeenWithdrawn[_withdrawData.id] == false, \\\"ERR: WITHDRAWN\\\");\\r\\n        if (_tokenOut == _tokenIn) {\\r\\n            require(\\r\\n                mosaicHolding.getTokenLiquidity(_tokenIn, _withdrawData.investmentStrategies) >=\\r\\n                    _amount,\\r\\n                \\\"ERR: VAULT BAL\\\"\\r\\n            );\\r\\n        }\\r\\n        if (_withdrawData.amountToSwapToNative > 0) {\\r\\n            require(vaultConfig.ableToPerformSmallBalanceSwap(), \\\"ERR: UNABLE\\\");\\r\\n        }\\r\\n        require(_withdrawData.amountToSwapToNative <= _amount, \\\"ERR: TOO HIGH\\\");\\r\\n        hasBeenWithdrawn[_withdrawData.id] = true;\\r\\n        lastWithdrawID = _withdrawData.id;\\r\\n\\r\\n        withdrawAmount = _takeFees(\\r\\n            _tokenIn,\\r\\n            _amount,\\r\\n            _accountTo,\\r\\n            _withdrawData.id,\\r\\n            _withdrawData.baseFee,\\r\\n            _withdrawData.feePercentage\\r\\n        );\\r\\n\\r\\n        mosaicHolding.coverWithdrawRequest(\\r\\n            _withdrawData.investmentStrategies,\\r\\n            _withdrawData.investmentStrategiesData,\\r\\n            _tokenIn,\\r\\n            withdrawAmount\\r\\n        );\\r\\n        if (_withdrawData.amountToSwapToNative > 0) {\\r\\n            if (_withdrawData.amountToSwapToNative > withdrawAmount) {\\r\\n                _withdrawData.amountToSwapToNative = withdrawAmount;\\r\\n            }\\r\\n            swapToNativeAndTransfer(\\r\\n                _tokenIn,\\r\\n                _accountTo,\\r\\n                _withdrawData.amountToSwapToNative,\\r\\n                _withdrawData.minAmountOutNative,\\r\\n                _withdrawData.nativeSwapperId\\r\\n            );\\r\\n            withdrawAmount -= _withdrawData.amountToSwapToNative;\\r\\n        }\\r\\n\\r\\n        if (_tokenOut != _tokenIn) {\\r\\n            withdrawAmount = _swap(\\r\\n                withdrawAmount,\\r\\n                _amountOutMin,\\r\\n                _tokenIn,\\r\\n                _tokenOut,\\r\\n                _withdrawData.ammId,\\r\\n                _data\\r\\n            );\\r\\n        }\\r\\n\\r\\n        mosaicHolding.transfer(_tokenOut, _accountTo, withdrawAmount);\\r\\n    }\\r\\n\\r\\n    /// @notice Swaps `_amountToNative` from `_tokenIn` to native token and sends it to `_accountTo`\\r\\n    /// @dev moved to function to avoid Stack too deep\\r\\n    /// @param _tokenIn address of the token to be swapped\\r\\n    /// @param _accountTo address which will receive the native tokens\\r\\n    /// @param _amountToNative amount in `tokenIn` tokens that will be converted to native tokens\\r\\n    function swapToNativeAndTransfer(\\r\\n        address _tokenIn,\\r\\n        address _accountTo,\\r\\n        uint256 _amountToNative,\\r\\n        uint256 _minAmountOutNative,\\r\\n        uint256 _nativeSwapperId\\r\\n    ) internal {\\r\\n        address mosaicNativeSwapperAddress = vaultConfig.supportedMosaicNativeSwappers(\\r\\n            _nativeSwapperId\\r\\n        );\\r\\n        require(mosaicNativeSwapperAddress != address(0), \\\"ERR: NOT SET\\\");\\r\\n        IMosaicNativeSwapper mosaicNativeSwapper = IMosaicNativeSwapper(mosaicNativeSwapperAddress);\\r\\n\\r\\n        // holding => vault\\r\\n        IMosaicHolding(vaultConfig.getMosaicHolding()).transfer(\\r\\n            _tokenIn,\\r\\n            address(this),\\r\\n            _amountToNative\\r\\n        );\\r\\n\\r\\n        // vault => nativeSwapper\\r\\n        IERC20Upgradeable(_tokenIn).safeIncreaseAllowance(\\r\\n            mosaicNativeSwapperAddress,\\r\\n            _amountToNative\\r\\n        );\\r\\n        mosaicNativeSwapper.swapToNative(\\r\\n            _tokenIn,\\r\\n            _amountToNative,\\r\\n            _minAmountOutNative,\\r\\n            _accountTo,\\r\\n            \\\"\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice in case of liquidity withdrawal request fails, the owner or the relayer calls this method to refund the user with his receipt tokens\\r\\n    /// @param _user user's address\\r\\n    /// @param _amount refunded amount which should be a bit smaller than the original one to cover the transaction cost\\r\\n    /// @param _receiptToken receipt token user had\\r\\n    /// @param _id request's id\\r\\n    function revertLiquidityWithdrawalRequest(\\r\\n        address _user,\\r\\n        uint256 _amount,\\r\\n        address _receiptToken,\\r\\n        bytes32 _id\\r\\n    ) external override onlyOwnerOrRelayer nonReentrant {\\r\\n        require(_amount > 0, \\\"ERR: AMOUNT\\\");\\r\\n        require(hasBeenRefunded[_id] == false, \\\"REFUNDED\\\");\\r\\n\\r\\n        address tokenAddress = IReceiptBase(_receiptToken).underlyingToken();\\r\\n        hasBeenRefunded[_id] = true;\\r\\n        lastRefundedID = _id;\\r\\n\\r\\n        require(\\r\\n            tokenAddress != address(0) &&\\r\\n                (vaultConfig.getUnderlyingReceiptAddress(tokenAddress) != address(0) ||\\r\\n                    vaultConfig.getUnderlyingIOUAddress(tokenAddress) != address(0)),\\r\\n            \\\"ERR: TOKEN NOT WHITELISTED\\\"\\r\\n        );\\r\\n\\r\\n        if (vaultConfig.getUnderlyingIOUAddress(tokenAddress) == _receiptToken) {\\r\\n            IReceiptBase(vaultConfig.getUnderlyingIOUAddress(tokenAddress)).mint(_user, _amount);\\r\\n        } else if (vaultConfig.getUnderlyingReceiptAddress(tokenAddress) == _receiptToken) {\\r\\n            IReceiptBase(vaultConfig.getUnderlyingReceiptAddress(tokenAddress)).mint(\\r\\n                _user,\\r\\n                _amount\\r\\n            );\\r\\n        }\\r\\n\\r\\n        emit LiquidityRefunded(tokenAddress, _receiptToken, _user, _amount, _id);\\r\\n    }\\r\\n\\r\\n    /// @dev internal function called to calculate the on-chain fees\\r\\n    /// @param _token address of the token in\\r\\n    /// @param _amount amount of token in\\r\\n    /// @param _accountTo address who will receive the withdrawn liquidity\\r\\n    /// @param _withdrawRequestId id of the withdraw request\\r\\n    /// @param _baseFee base fee of the withdraw\\r\\n    /// @param _feePercentage fee percentage of the withdraw\\r\\n    function _takeFees(\\r\\n        address _token,\\r\\n        uint256 _amount,\\r\\n        address _accountTo,\\r\\n        bytes32 _withdrawRequestId,\\r\\n        uint256 _baseFee,\\r\\n        uint256 _feePercentage\\r\\n    ) private returns (uint256) {\\r\\n        if (_baseFee > 0) {\\r\\n            IMosaicHolding(vaultConfig.getMosaicHolding()).transfer(_token, relayer, _baseFee);\\r\\n        }\\r\\n        uint256 fee = 0;\\r\\n        if (_feePercentage > 0) {\\r\\n            require(\\r\\n                _feePercentage >= vaultConfig.minFee() && _feePercentage <= vaultConfig.maxFee(),\\r\\n                \\\"ERR: OUT OF RANGE\\\"\\r\\n            );\\r\\n\\r\\n            fee = FeeOperations.getFeeAbsolute(_amount, _feePercentage);\\r\\n\\r\\n            IMosaicHolding(vaultConfig.getMosaicHolding()).transfer(\\r\\n                _token,\\r\\n                vaultConfig.getMosaicHolding(),\\r\\n                fee\\r\\n            );\\r\\n        }\\r\\n\\r\\n        uint256 totalFee = _baseFee + fee;\\r\\n        require(totalFee < _amount, \\\"ERR: FEE AMOUNT\\\");\\r\\n        if (totalFee > 0) {\\r\\n            emit FeeTaken(\\r\\n                msg.sender,\\r\\n                _accountTo,\\r\\n                _token,\\r\\n                _amount,\\r\\n                fee,\\r\\n                _baseFee,\\r\\n                fee + _baseFee,\\r\\n                _withdrawRequestId\\r\\n            );\\r\\n        }\\r\\n        return _amount - totalFee;\\r\\n    }\\r\\n\\r\\n    /// @dev internal function used to swap tokens\\r\\n    /// _amountIn amount of the token in\\r\\n    /// _amountOutMin min amount expected of the token out after the swap\\r\\n    /// _tokenIn address of the token in\\r\\n    /// _tokenOut address of the token out\\r\\n    /// _ammID the amm to use for swapping\\r\\n    /// _data extra call data for the swap\\r\\n    function _swap(\\r\\n        uint256 _amountIn,\\r\\n        uint256 _amountOutMin,\\r\\n        address _tokenIn,\\r\\n        address _tokenOut,\\r\\n        uint256 _ammID,\\r\\n        bytes memory _data\\r\\n    ) private returns (uint256) {\\r\\n        address mosaicHolding = vaultConfig.getMosaicHolding();\\r\\n        IMosaicHolding(mosaicHolding).transfer(_tokenIn, address(this), _amountIn);\\r\\n        address ammAddress = vaultConfig.supportedAMMs(_ammID);\\r\\n        require(ammAddress != address(0), \\\"ERR: AMM\\\");\\r\\n\\r\\n        IERC20Upgradeable(_tokenIn).safeApprove(ammAddress, _amountIn);\\r\\n\\r\\n        uint256 amountToSend = IMosaicExchange(ammAddress).swap(\\r\\n            _tokenIn,\\r\\n            _tokenOut,\\r\\n            _amountIn,\\r\\n            _amountOutMin,\\r\\n            _data\\r\\n        );\\r\\n        require(amountToSend >= _amountOutMin, \\\"ERR: PRICE\\\");\\r\\n        IERC20Upgradeable(_tokenOut).safeTransfer(mosaicHolding, amountToSend);\\r\\n        return amountToSend;\\r\\n    }\\r\\n\\r\\n    /// @notice transfer ERC20 token to another Mosaic vault\\r\\n    /// @param _amount amount of tokens to transfer\\r\\n    /// @param _tokenAddress SC address of the ERC20 token to transfer\\r\\n    /// @param _remoteDestinationAddress address that will receive the transfer on destination\\r\\n    /// @param _remoteNetworkID destination network\\r\\n    /// @param _maxTransferDelay delay in seconds for the relayer to execute the transaction\\r\\n    /// @param _tokenOut SC address of the ERC20 token that will be received in the destination network\\r\\n    /// @param _remoteAmmId id of the AMM that will be used in the destination network\\r\\n    /// @param _amountOutMin min amount of the token out the user expects to receive\\r\\n    /// @param _swapToNative true if a part will be swapped to native token in destination\\r\\n    function transferERC20ToLayer(\\r\\n        uint256 _amount,\\r\\n        address _tokenAddress,\\r\\n        address _remoteDestinationAddress,\\r\\n        uint256 _remoteNetworkID,\\r\\n        uint256 _maxTransferDelay,\\r\\n        address _tokenOut,\\r\\n        uint256 _remoteAmmId,\\r\\n        uint256 _amountOutMin,\\r\\n        bool _swapToNative\\r\\n    )\\r\\n        external\\r\\n        override\\r\\n        onlyWhitelistedRemoteTokens(_remoteNetworkID, _tokenAddress)\\r\\n        nonReentrant\\r\\n        whenNotPausedNetwork(_remoteNetworkID)\\r\\n        returns (bytes32 transferId)\\r\\n    {\\r\\n        require(_amount > 0, \\\"ERR: AMOUNT\\\");\\r\\n\\r\\n        transferId = vaultConfig.generateId();\\r\\n\\r\\n        uint256[3] memory ammConfig;\\r\\n        ammConfig[0] = _remoteAmmId;\\r\\n        ammConfig[1] = _maxTransferDelay;\\r\\n        ammConfig[2] = _amountOutMin;\\r\\n\\r\\n        _transferERC20ToLayer(\\r\\n            _amount,\\r\\n            _tokenAddress,\\r\\n            _remoteDestinationAddress,\\r\\n            _remoteNetworkID,\\r\\n            _tokenOut,\\r\\n            ammConfig,\\r\\n            transferId,\\r\\n            _swapToNative\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice transfer ETH converted to WETH to another Mosaic vault\\r\\n    /// @param _remoteDestinationAddress address that will receive the transfer on destination\\r\\n    /// @param _remoteNetworkID destination network\\r\\n    /// @param _maxTransferDelay delay in seconds for the relayer to execute the transaction\\r\\n    /// @param _tokenOut SC address of the ERC20 token that will be received in the destination network\\r\\n    /// @param _remoteAmmId id of the AMM that will be used in the destination network\\r\\n    /// @param _amountOutMin min amount of the token out the user expects to receive\\r\\n    /// @param _swapToNative true if a part will be swapped to native token in destination\\r\\n    function transferETHToLayer(\\r\\n        address _remoteDestinationAddress,\\r\\n        uint256 _remoteNetworkID,\\r\\n        uint256 _maxTransferDelay,\\r\\n        address _tokenOut,\\r\\n        uint256 _remoteAmmId,\\r\\n        uint256 _amountOutMin,\\r\\n        bool _swapToNative\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        override\\r\\n        nonReentrant\\r\\n        whenNotPausedNetwork(_remoteNetworkID)\\r\\n        returns (bytes32 transferId)\\r\\n    {\\r\\n        require(msg.value > 0, \\\"ERR: AMOUNT\\\");\\r\\n        address weth = vaultConfig.wethAddress();\\r\\n        require(weth != address(0), \\\"ERR: WETH\\\");\\r\\n        require(\\r\\n            vaultConfig.getUnderlyingIOUAddress(weth) != address(0),\\r\\n            \\\"ERR: WETH NOT WHITELISTED\\\"\\r\\n        );\\r\\n        // check if ETH transfer is possible\\r\\n        require(\\r\\n            vaultConfig.remoteTokenAddress(_remoteNetworkID, weth) != address(0),\\r\\n            \\\"ERR: ETH NOT WHITELISTED REMOTE\\\"\\r\\n        );\\r\\n\\r\\n        uint256[3] memory ammConfig;\\r\\n        ammConfig[0] = _remoteAmmId;\\r\\n        ammConfig[1] = _maxTransferDelay;\\r\\n        ammConfig[2] = _amountOutMin;\\r\\n\\r\\n        transferId = vaultConfig.generateId();\\r\\n        _transferERC20ToLayer(\\r\\n            msg.value,\\r\\n            vaultConfig.wethAddress(),\\r\\n            _remoteDestinationAddress,\\r\\n            _remoteNetworkID,\\r\\n            _tokenOut,\\r\\n            ammConfig,\\r\\n            transferId,\\r\\n            _swapToNative\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Internal function called to transfer ERC20 to another Mosaic vault\\r\\n    /// @param _amount amount of tokens to transfer\\r\\n    /// @param _tokenAddress SC address of the ERC20 token to transfer\\r\\n    /// @param _remoteDestinationAddress address that will receive the transfer on destination\\r\\n    /// @param _remoteNetworkID destination network\\r\\n    /// @param _tokenOut SC address of the ERC20 token that will be received in the destination network\\r\\n    /// @param _ammConfig => 0 - amm id , 1 - delay, 2, amount out\\r\\n    /// @param _id id of the transfer\\r\\n    /// @param _swapToNative true if a part will be swapped to native token in destination\\r\\n    function _transferERC20ToLayer(\\r\\n        uint256 _amount,\\r\\n        address _tokenAddress,\\r\\n        address _remoteDestinationAddress,\\r\\n        uint256 _remoteNetworkID,\\r\\n        address _tokenOut,\\r\\n        uint256[3] memory _ammConfig, // 0 - amm id , 1 - delay, 2, amount out\\r\\n        bytes32 _id,\\r\\n        bool _swapToNative\\r\\n    ) private inTokenTransferLimits(_tokenAddress, _amount) {\\r\\n        if (_tokenAddress == vaultConfig.wethAddress()) {\\r\\n            // convert to WETH\\r\\n            IWETH(_tokenAddress).deposit{value: _amount}();\\r\\n            // transfer funds to holding\\r\\n            IERC20Upgradeable(_tokenAddress).safeTransfer(vaultConfig.getMosaicHolding(), _amount);\\r\\n        } else {\\r\\n            // transfer funds to holding\\r\\n            IERC20Upgradeable(_tokenAddress).safeTransferFrom(\\r\\n                msg.sender,\\r\\n                vaultConfig.getMosaicHolding(),\\r\\n                _amount\\r\\n            );\\r\\n        }\\r\\n\\r\\n        deposits[_id] = DepositInfo({token: _tokenAddress, amount: _amount});\\r\\n\\r\\n        // NOTE: _tokenOut == address(0) is reserved for\\r\\n        //       the native token of the destination layer\\r\\n        //       for eg: MATIC for Polygon\\r\\n        emit TransferInitiated(\\r\\n            msg.sender,\\r\\n            _tokenAddress,\\r\\n            vaultConfig.remoteTokenAddress(_remoteNetworkID, _tokenAddress),\\r\\n            _remoteNetworkID,\\r\\n            _amount,\\r\\n            _remoteDestinationAddress,\\r\\n            _id,\\r\\n            _ammConfig[1],\\r\\n            _tokenOut,\\r\\n            _ammConfig[0],\\r\\n            _ammConfig[2],\\r\\n            _swapToNative\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice called by the owner of the contract or by the relayer to return funds back to the user in case of a failed transfer\\r\\n    ///         This method will mark the `id` as used and emit the event that funds have been refunded\\r\\n    /// @param _token address of the ERC20 token\\r\\n    /// @param _user address of the user that will receive the tokens\\r\\n    /// @param _amount amount of tokens to be refunded\\r\\n    /// @param _originalAmount amount of tokens transfered in the first place\\r\\n    /// @param _id id of the original transfer\\r\\n    /// @param _investmentStrategies list of addresses of the investment strategies\\r\\n    /// @param _investmentStrategiesData list of extra data for investment strategies\\r\\n    function refundTransferFunds(\\r\\n        address _token,\\r\\n        address _user,\\r\\n        uint256 _amount,\\r\\n        uint256 _originalAmount,\\r\\n        bytes32 _id,\\r\\n        address[] calldata _investmentStrategies,\\r\\n        bytes[] calldata _investmentStrategiesData\\r\\n    ) external override nonReentrant onlyOwnerOrRelayer {\\r\\n        // should not be refunded\\r\\n        require(hasBeenRefunded[_id] == false, \\\"ERR: REFUNDED\\\");\\r\\n\\r\\n        // check if the vault has enough locked balance\\r\\n        require(\\r\\n            IMosaicHolding(vaultConfig.getMosaicHolding()).getTokenLiquidity(\\r\\n                _token,\\r\\n                _investmentStrategies\\r\\n            ) >= _amount,\\r\\n            \\\"ERR: BAL\\\"\\r\\n        );\\r\\n\\r\\n        // check if the deposit data matches\\r\\n        require(\\r\\n            deposits[_id].token == _token && deposits[_id].amount == _originalAmount,\\r\\n            \\\"ERR: DEPOSIT\\\"\\r\\n        );\\r\\n\\r\\n        hasBeenRefunded[_id] = true;\\r\\n        lastRefundedID = _id;\\r\\n\\r\\n        IMosaicHolding mosaicHolding = IMosaicHolding(vaultConfig.getMosaicHolding());\\r\\n        mosaicHolding.coverWithdrawRequest(\\r\\n            _investmentStrategies,\\r\\n            _investmentStrategiesData,\\r\\n            _token,\\r\\n            _amount\\r\\n        );\\r\\n        mosaicHolding.transfer(_token, _user, _amount);\\r\\n\\r\\n        delete deposits[_id];\\r\\n\\r\\n        emit TransferFundsRefunded(_token, _user, _amount, _originalAmount, _id);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Used to transfer randomly sent tokens to this contract to the Mosaic holding\\r\\n     * @param _token Token's address\\r\\n     */\\r\\n    function digestFunds(address _token) external override onlyOwner validAddress(_token) {\\r\\n        uint256 balance = IERC20Upgradeable(_token).balanceOf(address(this));\\r\\n        require(balance > 0, \\\"ERR: BAL\\\");\\r\\n        IERC20Upgradeable(_token).safeTransfer(vaultConfig.getMosaicHolding(), balance);\\r\\n        emit FundsDigested(_token, balance);\\r\\n    }\\r\\n\\r\\n    /// @notice External payable function called when ether is sent to the contract\\r\\n    ///         Receiving ether is considered an active liquidity\\r\\n    receive() external payable {\\r\\n        provideActiveLiquidity(0, address(0), vaultConfig.maxLimitLiquidityBlocks());\\r\\n    }\\r\\n\\r\\n    /// @notice External callable function to pause the contract\\r\\n    function pause() external override whenNotPaused onlyOwner {\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    /// @notice External callable function to unpause the contract\\r\\n    function unpause() external override whenPaused onlyOwner {\\r\\n        _unpause();\\r\\n    }\\r\\n\\r\\n    modifier validAddress(address _address) {\\r\\n        require(_address != address(0), \\\"ERR: INVALID ADDRESS\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyWhitelistedToken(address _tokenAddress) {\\r\\n        require(\\r\\n            vaultConfig.getUnderlyingIOUAddress(_tokenAddress) != address(0),\\r\\n            \\\"ERR: TOKEN NOT WHITELISTED\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyWhitelistedRemoteTokens(uint256 _networkID, address _tokenAddress) {\\r\\n        require(\\r\\n            vaultConfig.remoteTokenAddress(_networkID, _tokenAddress) != address(0),\\r\\n            \\\"ERR: TOKEN NOT WHITELISTED DESTINATION\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier whenNotPausedNetwork(uint256 _networkID) {\\r\\n        require(paused() == false, \\\"ERR: PAUSED\\\");\\r\\n        require(vaultConfig.pausedNetwork(_networkID) == false, \\\"ERR: PAUSED NETWORK\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwnerOrRelayer() {\\r\\n        require(_msgSender() == owner() || _msgSender() == relayer, \\\"ERR: PERMISSIONS\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier inTokenTransferLimits(address _token, uint256 _amount) {\\r\\n        require(vaultConfig.inTokenTransferLimits(_token, _amount), \\\"ERR: TRANSFER LIMITS\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier inBlockApproveRange(uint256 _blocksForActiveLiquidity) {\\r\\n        require(\\r\\n            _blocksForActiveLiquidity >= vaultConfig.minLimitLiquidityBlocks() &&\\r\\n                _blocksForActiveLiquidity <= vaultConfig.maxLimitLiquidityBlocks(),\\r\\n            \\\"ERR: BLOCK RANGE\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal initializer {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal initializer {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal initializer {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMosaicHolding.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../interfaces/IInvestmentStrategy.sol\\\";\\r\\n\\r\\ninterface IMosaicHolding {\\r\\n    event FoundsInvested(address indexed strategy, address indexed admin, uint256 cTokensReceived);\\r\\n\\r\\n    event InvestmentWithdrawn(address indexed strategy, address indexed admin);\\r\\n\\r\\n    event RebalancingThresholdChanged(\\r\\n        address indexed admin,\\r\\n        address indexed token,\\r\\n        uint256 oldAmount,\\r\\n        uint256 newAmount\\r\\n    );\\r\\n\\r\\n    event RebalancingInitiated(\\r\\n        address indexed by,\\r\\n        address indexed token,\\r\\n        address indexed receiver,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    event TokenClaimed(address indexed strategy, address indexed rewardTokenAddress);\\r\\n\\r\\n    event SaveFundsStarted(address owner, address token, address receiver);\\r\\n\\r\\n    event LiquidityMoved(address indexed to, address indexed tokenAddress, uint256 amount);\\r\\n\\r\\n    event SaveFundsLockUpTimerStarted(address owner, uint256 time, uint256 durationToChangeTime);\\r\\n\\r\\n    event SaveFundsLockUpTimeSet(address owner, uint256 time, uint256 durationToChangeTime);\\r\\n\\r\\n    event ETHTransfered(address receiver, uint256 amount);\\r\\n\\r\\n    function getTokenLiquidity(address _token, address[] calldata _investmentStrategies)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function saveFundsLockupTime() external view returns (uint256);\\r\\n\\r\\n    function newSaveFundsLockUpTime() external view returns (uint256);\\r\\n\\r\\n    function durationToChangeTimer() external view returns (uint256);\\r\\n\\r\\n    function transfer(\\r\\n        address _token,\\r\\n        address _receiver,\\r\\n        uint256 _amount\\r\\n    ) external;\\r\\n\\r\\n    function transferETH(address _receiver, uint256 _amount) external;\\r\\n\\r\\n    function setUniqRole(bytes32 _role, address _address) external;\\r\\n\\r\\n    function approve(\\r\\n        address _spender,\\r\\n        address _token,\\r\\n        uint256 _amount\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev starts save funds transfer.\\r\\n     * @param _token Token's balance the owner wants to withdraw\\r\\n     * @param _to Receiver address\\r\\n     */\\r\\n    function startSaveFunds(address _token, address _to) external;\\r\\n\\r\\n    /**\\r\\n     * @dev manually moves funds back to L1.\\r\\n     */\\r\\n    function executeSaveFunds() external;\\r\\n\\r\\n    /**\\r\\n     * @dev starts save funds lockup timer change.\\r\\n     * @param _time lock up time duration\\r\\n     */\\r\\n    function startSaveFundsLockUpTimerChange(uint256 _time) external;\\r\\n\\r\\n    /**\\r\\n     * @dev set save funds lock up time.\\r\\n     */\\r\\n    function setSaveFundsLockUpTime() external;\\r\\n\\r\\n    function invest(\\r\\n        IInvestmentStrategy.Investment[] calldata _investments,\\r\\n        address _investmentStrategy,\\r\\n        bytes calldata _data\\r\\n    ) external;\\r\\n\\r\\n    function withdrawInvestment(\\r\\n        IInvestmentStrategy.Investment[] calldata _investments,\\r\\n        address _investmentStrategy,\\r\\n        bytes calldata _data\\r\\n    ) external;\\r\\n\\r\\n    function coverWithdrawRequest(\\r\\n        address[] calldata _investmentStrategies,\\r\\n        bytes[] calldata _data,\\r\\n        address _token,\\r\\n        uint256 _amount\\r\\n    ) external;\\r\\n\\r\\n    function claim(address _investmentStrategy, bytes calldata _data) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IMosaicExchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IMosaicExchange {\\n    function swap(\\n        address _tokenA,\\n        address _tokenB,\\n        uint256 _amountIn,\\n        uint256 _amountOut,\\n        bytes calldata _data\\n    ) external returns (uint256);\\n\\n    function getAmountsOut(\\n        address _tokenIn,\\n        address _tokenOut,\\n        uint256 _amountIn,\\n        bytes calldata _data\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IReceiptBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IReceiptBase is IERC20 {\\n    function burn(address _from, uint256 _amount) external;\\n\\n    function mint(address _to, uint256 _amount) external;\\n\\n    function underlyingToken() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface ITokenFactory {\\n    function createIOU(\\n        address _underlyingAddress,\\n        string calldata _tokenName,\\n        address _owner\\n    ) external returns (address);\\n\\n    function createReceipt(\\n        address _underlyingAddress,\\n        string calldata _tokenName,\\n        address _owner\\n    ) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMosaicVaultConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IMosaicHolding.sol\\\";\\nimport \\\"./IVaultConfigBase.sol\\\";\\n\\ninterface IMosaicVaultConfig is IVaultConfigBase {\\n    event MinFeeChanged(uint256 newMinFee);\\n    event MaxFeeChanged(uint256 newMaxFee);\\n    event MinLiquidityBlockChanged(uint256 newMinLimitLiquidityBlocks);\\n    event MaxLiquidityBlockChanged(uint256 newMaxLimitLiquidityBlocks);\\n    event LockupTimeChanged(address indexed owner, uint256 oldVal, uint256 newVal, string valType);\\n    event TokenWhitelisted(\\n        address indexed erc20,\\n        address indexed newIou,\\n        address indexed newReceipt\\n    );\\n    event TokenWhitelistRemoved(address indexed erc20);\\n    event RemoteTokenAdded(\\n        address indexed erc20,\\n        address indexed remoteErc20,\\n        uint256 indexed remoteNetworkID,\\n        uint256 remoteTokenRatio\\n    );\\n    event RemoteTokenRemoved(address indexed erc20, uint256 indexed remoteNetworkID);\\n\\n    event PauseNetwork(address admin, uint256 networkID);\\n\\n    event UnpauseNetwork(address admin, uint256 networkID);\\n\\n    event AMMAdded(uint256 _id, address indexed _address);\\n\\n    event AMMRemoved(uint256 _id);\\n\\n    struct WhitelistedToken {\\n        uint256 minTransferAllowed;\\n        uint256 maxTransferAllowed;\\n        address underlyingIOUAddress;\\n        address underlyingReceiptAddress;\\n    }\\n\\n    function passiveLiquidityLocktime() external view returns (uint256);\\n\\n    function minFee() external view returns (uint256);\\n\\n    function maxFee() external view returns (uint256);\\n\\n    function maxLimitLiquidityBlocks() external view returns (uint256);\\n\\n    function minLimitLiquidityBlocks() external view returns (uint256);\\n\\n    function wethAddress() external view returns (address);\\n\\n    function remoteTokenAddress(uint256 _id, address _token) external view returns (address);\\n\\n    function remoteTokenRatio(uint256 _id, address _token) external view returns (uint256);\\n\\n    function supportedAMMs(uint256 _ammID) external view returns (address);\\n\\n    function pausedNetwork(uint256) external view returns (bool);\\n\\n    function ableToPerformSmallBalanceSwap() external view returns (bool);\\n\\n    function supportedMosaicNativeSwappers(uint256 _mosaicNativeSwapperID)\\n        external\\n        view\\n        returns (address);\\n\\n    /**\\n     * @dev used to set the passive liquidity lock time\\n     * @param _locktime  Lock time in seconds until the passive liquidity withdrawal is unavailable\\n     */\\n    function setPassiveLiquidityLocktime(uint256 _locktime) external;\\n\\n    /**\\n     * @dev used to set WETH address\\n     * @param _weth  Address of WETH token\\n     * @param _minTransferAmount Minimum transfer allowed amount\\n     * @param _maxTransferAmount Maximum transfer allowed amount\\n     */\\n    function setWethAddress(\\n        address _weth,\\n        uint256 _minTransferAmount,\\n        uint256 _maxTransferAmount\\n    ) external;\\n\\n    function getUnderlyingIOUAddress(address _token) external view returns (address);\\n\\n    function getUnderlyingReceiptAddress(address _token) external view returns (address);\\n\\n    /**\\n     * @dev used to add address of the AMM used to swap tokens.\\n     * @param _ammID the integer constant for the AMM\\n     * @param _ammAddress Address of the AMM\\n     */\\n    function addSupportedAMM(uint256 _ammID, address _ammAddress) external;\\n\\n    /**\\n     * @dev used to remove address of the AMM.\\n     * @param _ammID the integer constant for the AMM\\n     */\\n    function removeSupportedAMM(uint256 _ammID) external;\\n\\n    function changeRemoteTokenRatio(\\n        address _tokenAddress,\\n        uint256 _remoteNetworkID,\\n        uint256 _remoteTokenRatio\\n    ) external;\\n\\n    /**\\n     * @dev used to adds a whitelisted token to the contract.\\n     * @param _tokenAddress  SC address of the ERC20 token to add to supported tokens\\n     * @param _minTransferAmount Minimum amount of token can be transferred\\n     * @param _maxTransferAmount  Maximum amount of token can be transferred\\n     */\\n    function addWhitelistedToken(\\n        address _tokenAddress,\\n        uint256 _minTransferAmount,\\n        uint256 _maxTransferAmount\\n    ) external;\\n\\n    /**\\n     * @dev used to removes whitelisted token from the contract.\\n     * @param _token  SC address of the ERC20 token to remove from supported tokens\\n     */\\n    function removeWhitelistedToken(address _token) external;\\n\\n    function addTokenInNetwork(\\n        address _tokenAddress,\\n        address _tokenAddressRemote,\\n        uint256 _remoteNetworkID,\\n        uint256 _remoteTokenRatio\\n    ) external;\\n\\n    function removeTokenInNetwork(address _tokenAddress, uint256 _remoteNetworkID) external;\\n\\n    /**\\n     * @dev updates the minimum fee.\\n     * @param _newMinFee  value to be set as new minimum fee\\n     */\\n    function setMinFee(uint256 _newMinFee) external;\\n\\n    /**\\n     * @dev updates the maximum fee.\\n     * @param _newMaxFee  value to be set as new minimum fee\\n     */\\n    function setMaxFee(uint256 _newMaxFee) external;\\n\\n    /**\\n     * @dev updates the minimum limit liquidity block.\\n     * @param _newMinLimitLiquidityBlocks value to be set as new minimum limit liquidity block\\n     */\\n    function setMinLimitLiquidityBlocks(uint256 _newMinLimitLiquidityBlocks) external;\\n\\n    /**\\n     * @dev updates the maximum limit liquidity block.\\n     * @param _newMaxLimitLiquidityBlocks value to be set as new maximum limit liquidity block\\n     */\\n    function setMaxLimitLiquidityBlocks(uint256 _newMaxLimitLiquidityBlocks) external;\\n\\n    function generateId() external returns (bytes32);\\n\\n    function inTokenTransferLimits(address, uint256) external view returns (bool);\\n\\n    /**\\n     * @dev used to pause a network.\\n     * @param _networkID  network ID of remote token\\n     */\\n    function pauseNetwork(uint256 _networkID) external;\\n\\n    /**\\n     * @dev used to unpause a network.\\n     * @param _networkID  network ID of remote token\\n     */\\n    function unpauseNetwork(uint256 _networkID) external;\\n\\n    function setAbleToPerformSmallBalanceSwap(bool _flag) external;\\n\\n    function addSupportedMosaicNativeSwapper(\\n        uint256 _mosaicNativeSwapperID,\\n        address _mosaicNativeSwapperAddress\\n    ) external;\\n\\n    function removeSupportedMosaicNativeSwapper(uint256 _mosaicNativeSwapperID) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 _wad) external;\\n\\n    function balanceOf(address _account) external view returns (uint256);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMosaicVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IInvestmentStrategy.sol\\\";\\r\\nimport \\\"./IMosaicVaultConfig.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface of L1Vault.\\r\\n */\\r\\ninterface IMosaicVault {\\r\\n    event TransferInitiated(\\r\\n        address indexed owner,\\r\\n        address indexed erc20,\\r\\n        address remoteTokenAddress,\\r\\n        uint256 indexed remoteNetworkID,\\r\\n        uint256 value,\\r\\n        address remoteDestinationAddress,\\r\\n        bytes32 uniqueId,\\r\\n        uint256 maxTransferDelay,\\r\\n        address tokenOut,\\r\\n        uint256 ammID,\\r\\n        uint256 amountOutMin,\\r\\n        bool _swapToNative\\r\\n    );\\r\\n\\r\\n    event WithdrawalCompleted(\\r\\n        address indexed accountTo,\\r\\n        uint256 amount,\\r\\n        uint256 netAmount,\\r\\n        address indexed tokenAddress,\\r\\n        bytes32 indexed uniqueId,\\r\\n        bool swapToNative\\r\\n    );\\r\\n\\r\\n    event TransferFundsRefunded(\\r\\n        address indexed tokenAddress,\\r\\n        address indexed user,\\r\\n        uint256 amount,\\r\\n        uint256 fullAmount,\\r\\n        bytes32 indexed uniqueId\\r\\n    );\\r\\n    event FundsDigested(address indexed tokenAddress, uint256 amount);\\r\\n\\r\\n    event FeeTaken(\\r\\n        address indexed owner,\\r\\n        address indexed user,\\r\\n        address indexed token,\\r\\n        uint256 amount,\\r\\n        uint256 fee,\\r\\n        uint256 baseFee,\\r\\n        uint256 totalFee,\\r\\n        bytes32 uniqueId\\r\\n    );\\r\\n\\r\\n    event DepositActiveLiquidity(\\r\\n        address indexed tokenAddress,\\r\\n        address indexed provider,\\r\\n        uint256 amount,\\r\\n        uint256 blocks\\r\\n    );\\r\\n\\r\\n    event DepositPassiveLiquidity(\\r\\n        address indexed tokenAddress,\\r\\n        address indexed provider,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    event LiquidityWithdrawn(\\r\\n        address indexed user,\\r\\n        address indexed tokenIn,\\r\\n        address indexed tokenOut,\\r\\n        uint256 amountIn,\\r\\n        uint256 requestedAmountIn,\\r\\n        uint256 amountOut,\\r\\n        uint256 baseFee,\\r\\n        uint256 mosaicFee,\\r\\n        bool swapToNative,\\r\\n        bytes32 id\\r\\n    );\\r\\n\\r\\n    event LiquidityRefunded(\\r\\n        address indexed tokenAddress,\\r\\n        address indexed receiptAddress,\\r\\n        address indexed user,\\r\\n        uint256 amount,\\r\\n        bytes32 uniqueId\\r\\n    );\\r\\n\\r\\n    event WithdrawRequest(\\r\\n        address indexed user,\\r\\n        address receiptToken,\\r\\n        address indexed tokenIn,\\r\\n        uint256 amountIn,\\r\\n        address indexed tokenOut,\\r\\n        address remoteTokenInAddress,\\r\\n        address destinationAddress,\\r\\n        uint256 ammId,\\r\\n        uint256 destinationNetworkID,\\r\\n        bytes data,\\r\\n        bytes32 uniqueId,\\r\\n        WithdrawRequestData _withdrawData\\r\\n    );\\r\\n\\r\\n    event RelayerSet(address indexed _old, address indexed _new);\\r\\n    event ConfigSet(address indexed _old, address indexed _new);\\r\\n\\r\\n    enum TransferState {\\r\\n        UNKNOWN, // Default state\\r\\n        SUCCESS,\\r\\n        REFUNDED\\r\\n    }\\r\\n\\r\\n    struct WithdrawRequestData {\\r\\n        uint256 amountOutMin;\\r\\n        uint256 maxDelay;\\r\\n        bool _swapToNative;\\r\\n    }\\r\\n\\r\\n    struct WithdrawData {\\r\\n        uint256 feePercentage;\\r\\n        uint256 baseFee;\\r\\n        address[] investmentStrategies;\\r\\n        bytes[] investmentStrategiesData;\\r\\n        uint256 ammId;\\r\\n        bytes32 id;\\r\\n        uint256 amountToSwapToNative;\\r\\n        uint256 minAmountOutNative;\\r\\n        uint256 nativeSwapperId;\\r\\n    }\\r\\n\\r\\n    function setRelayer(address _relayer) external;\\r\\n\\r\\n    function setVaultConfig(address _vaultConfig) external;\\r\\n\\r\\n    function vaultConfig() external view returns (IMosaicVaultConfig);\\r\\n\\r\\n    /**\\r\\n     * @dev used to provide active liquidity.\\r\\n     * @param _amount amount of tokens to deposit\\r\\n     * @param _tokenAddress  SC address of the ERC20 token to deposit\\r\\n     * @param _blocksForActiveLiquidity users choice of active liquidity\\r\\n     */\\r\\n    function provideActiveLiquidity(\\r\\n        uint256 _amount,\\r\\n        address _tokenAddress,\\r\\n        uint256 _blocksForActiveLiquidity\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @dev used to provide passive liquidity.\\r\\n     * @param _amount amount of tokens to deposit\\r\\n     * @param _tokenAddress  SC address of the ERC20 token to deposit\\r\\n     */\\r\\n    function providePassiveLiquidity(uint256 _amount, address _tokenAddress) external payable;\\r\\n\\r\\n    /// @notice External function called to add withdraw liquidity request\\r\\n    /// @param _receiptToken Address of the iou token provider have\\r\\n    /// @param _amountIn Amount of tokens provider want to withdraw\\r\\n    /// @param _tokenOut Address of the token which LP wants to receive\\r\\n    /// @param _ammID the amm to use for swapping\\r\\n    /// @param _data extra call data\\r\\n    /// @param _destinationNetworkId networkId of the _receiptToken's underlying token\\r\\n    /// @param _withdrawRequestData set of data for withdraw\\r\\n    function withdrawLiquidityRequest(\\r\\n        address _receiptToken,\\r\\n        uint256 _amountIn,\\r\\n        address _tokenOut,\\r\\n        address _destinationAddress,\\r\\n        uint256 _ammID,\\r\\n        bytes calldata _data,\\r\\n        uint256 _destinationNetworkId,\\r\\n        WithdrawRequestData calldata _withdrawRequestData\\r\\n    ) external returns (bytes32 transferId);\\r\\n\\r\\n    /**\\r\\n     *  @notice Called by relayer to withdraw liquidity from the vault\\r\\n     *  @param _accountTo eth address to send the withdrawal tokens\\r\\n     *  @param _amount requested by user + rewards for token in\\r\\n     *  @param _requestedAmount amount requested by user for token in\\r\\n     *  @param _tokenIn address of the token in\\r\\n     *  @param _tokenOut address of the token out\\r\\n     *  @param _amountOutMin minimum amount out user wants\\r\\n     *  @param _withdrawData set of data for withdraw\\r\\n     *  @param _data additional _data required for each AMM implementation\\r\\n     */\\r\\n    function withdrawLiquidity(\\r\\n        address _accountTo,\\r\\n        uint256 _amount,\\r\\n        uint256 _requestedAmount,\\r\\n        address _tokenIn,\\r\\n        address _tokenOut,\\r\\n        uint256 _amountOutMin,\\r\\n        WithdrawData calldata _withdrawData,\\r\\n        bytes calldata _data\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev used to release funds\\r\\n     * @param _accountTo eth address to send the withdrawal tokens\\r\\n     * @param _amount amount of token in\\r\\n     * @param _tokenIn address of the token in\\r\\n     * @param _tokenOut address of the token out\\r\\n     * @param _amountOutMin minimum amount out user want\\r\\n     * @param _data additional data required for each AMM implementation\\r\\n     * @param _withdrawData set of data for withdraw\\r\\n     */\\r\\n    function withdrawTo(\\r\\n        address _accountTo,\\r\\n        uint256 _amount,\\r\\n        address _tokenIn,\\r\\n        address _tokenOut,\\r\\n        uint256 _amountOutMin,\\r\\n        WithdrawData calldata _withdrawData,\\r\\n        bytes calldata _data\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev used by the relayer or by the owner to refund a failed withdrawal request\\r\\n     * @param _user user's address\\r\\n     * @param _amount amount to be refunded out of which the transaction cost was substracted\\r\\n     * @param _receiptToken receipt's address\\r\\n     * @param _id withdrawal id generated by the relayer.\\r\\n     */\\r\\n    function revertLiquidityWithdrawalRequest(\\r\\n        address _user,\\r\\n        uint256 _amount,\\r\\n        address _receiptToken,\\r\\n        bytes32 _id\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev transfer ERC20 token to another Mosaic vault.\\r\\n     * @param _amount amount of tokens to deposit\\r\\n     * @param _tokenAddress  SC address of the ERC20 token to deposit\\r\\n     * @param _remoteDestinationAddress SC address of the ERC20 supported tokens in a diff network\\r\\n     * @param _remoteNetworkID  network ID of remote token\\r\\n     * @param _maxTransferDelay delay in seconds for the relayer to execute the transaction\\r\\n     * @param _swapToNative true if a part will be swapped to native token in destination\\r\\n     * @return transferId - transfer unique identifier\\r\\n     */\\r\\n    function transferERC20ToLayer(\\r\\n        uint256 _amount,\\r\\n        address _tokenAddress,\\r\\n        address _remoteDestinationAddress,\\r\\n        uint256 _remoteNetworkID,\\r\\n        uint256 _maxTransferDelay,\\r\\n        address _tokenOut,\\r\\n        uint256 _remoteAmmId,\\r\\n        uint256 _amountOutMin,\\r\\n        bool _swapToNative\\r\\n    ) external returns (bytes32 transferId);\\r\\n\\r\\n    /**\\r\\n     * @dev transfer ETH to another Mosaic vault\\r\\n     * @param _remoteDestinationAddress SC address of the ERC20 supported tokens in a diff network\\r\\n     * @param _remoteNetworkID  network ID of remote token\\r\\n     * @param _maxTransferDelay delay in seconds for the relayer to execute the transaction\\r\\n     * @param _swapToNative true if a part will be swapped to native token in destination\\r\\n     * @return transferId - transfer unique identifier\\r\\n     */\\r\\n    function transferETHToLayer(\\r\\n        address _remoteDestinationAddress,\\r\\n        uint256 _remoteNetworkID,\\r\\n        uint256 _maxTransferDelay,\\r\\n        address _tokenOut,\\r\\n        uint256 _remoteAmmId,\\r\\n        uint256 _amountOutMin,\\r\\n        bool _swapToNative\\r\\n    ) external payable returns (bytes32 transferId);\\r\\n\\r\\n    /**\\r\\n     * @dev called by the relayer or by the owner to refund a failed transfer transaction\\r\\n     * @param _token address of token user want to withdraw.\\r\\n     * @param _user user's address.\\r\\n     * @param _amount amount of tokens to be refunded.\\r\\n     * @param _originalAmount amount of tokens user initiated a transfer for.\\r\\n     * @param _id id generated by the relayer.\\r\\n     * @param _investmentStrategies list of addresses of the investment strategies\\r\\n     * @param _investmentStrategiesData list of extra data for investment strategies\\r\\n     */\\r\\n    function refundTransferFunds(\\r\\n        address _token,\\r\\n        address _user,\\r\\n        uint256 _amount,\\r\\n        uint256 _originalAmount,\\r\\n        bytes32 _id,\\r\\n        address[] calldata _investmentStrategies,\\r\\n        bytes[] calldata _investmentStrategiesData\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev used to send random tokens to the holding.\\r\\n     * @param _token Address of the ERC20 token\\r\\n     */\\r\\n    function digestFunds(address _token) external;\\r\\n\\r\\n    /**\\r\\n     * @dev used to pause the contract.\\r\\n     */\\r\\n\\r\\n    function pause() external;\\r\\n\\r\\n    /**\\r\\n     * @dev used to unpause the contract.\\r\\n     */\\r\\n\\r\\n    function unpause() external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IInvestmentStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IInvestmentStrategy {\\n    struct Investment {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    function makeInvestment(Investment[] calldata _investments, bytes calldata _data)\\n        external\\n        returns (uint256);\\n\\n    function withdrawInvestment(Investment[] calldata _investments, bytes calldata _data) external;\\n\\n    function claimTokens(bytes calldata _data) external returns (address);\\n\\n    function investmentAmount(address _token) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMosaicNativeSwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IMosaicNativeSwapper {\\n    event SwappedToNative(address _tokenIn, uint256 amountIn, uint256 amountOut, address addressTo);\\n\\n    function swapToNative(\\n        address _tokenIn,\\n        uint256 _amount,\\n        uint256 _minAmountOut,\\n        address _to,\\n        bytes calldata _data\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/FeeOperations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary FeeOperations {\\n    uint256 internal constant FEE_FACTOR = 10000;\\n\\n    function getFeeAbsolute(uint256 amount, uint256 fee) internal pure returns (uint256) {\\n        return (amount * fee) / FEE_FACTOR;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVaultConfigBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IVaultConfigBase {\\n    event TokenCreated(address _underlyingToken);\\n\\n    function getMosaicHolding() external view returns (address);\\n\\n    function setTokenFactoryAddress(address _tokenFactoryAddress) external;\\n\\n    function setVault(address _vault) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"ConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blocks\",\"type\":\"uint256\"}],\"name\":\"DepositActiveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositPassiveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"uniqueId\",\"type\":\"bytes32\"}],\"name\":\"FeeTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsDigested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiptAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"uniqueId\",\"type\":\"bytes32\"}],\"name\":\"LiquidityRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestedAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mosaicFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"swapToNative\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"LiquidityWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"RelayerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fullAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"uniqueId\",\"type\":\"bytes32\"}],\"name\":\"TransferFundsRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"remoteTokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"remoteNetworkID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"remoteDestinationAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"uniqueId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTransferDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ammID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_swapToNative\",\"type\":\"bool\"}],\"name\":\"TransferInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiptToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"remoteTokenInAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destinationAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ammId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destinationNetworkID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"uniqueId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDelay\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_swapToNative\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct IMosaicVault.WithdrawRequestData\",\"name\":\"_withdrawData\",\"type\":\"tuple\"}],\"name\":\"WithdrawRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"accountTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"netAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"uniqueId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"swapToNative\",\"type\":\"bool\"}],\"name\":\"WithdrawalCompleted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"digestFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hasBeenRefunded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hasBeenWithdrawn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mosaicVaultConfig\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRefundedID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastWithdrawID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"passiveLiquidityAvailableAfterTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blocksForActiveLiquidity\",\"type\":\"uint256\"}],\"name\":\"provideActiveLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"providePassiveLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_originalAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"_investmentStrategies\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_investmentStrategiesData\",\"type\":\"bytes[]\"}],\"name\":\"refundTransferFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiptToken\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"revertLiquidityWithdrawalRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"setRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultConfig\",\"type\":\"address\"}],\"name\":\"setVaultConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_remoteDestinationAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_remoteNetworkID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTransferDelay\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_remoteAmmId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_swapToNative\",\"type\":\"bool\"}],\"name\":\"transferERC20ToLayer\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"transferId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_remoteDestinationAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_remoteNetworkID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTransferDelay\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_remoteAmmId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_swapToNative\",\"type\":\"bool\"}],\"name\":\"transferETHToLayer\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"transferId\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultConfig\",\"outputs\":[{\"internalType\":\"contract IMosaicVaultConfig\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_accountTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_requestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"investmentStrategies\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"investmentStrategiesData\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"ammId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amountToSwapToNative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOutNative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nativeSwapperId\",\"type\":\"uint256\"}],\"internalType\":\"struct IMosaicVault.WithdrawData\",\"name\":\"_withdrawData\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"withdrawLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiptToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_destinationAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ammID\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_destinationNetworkId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDelay\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_swapToNative\",\"type\":\"bool\"}],\"internalType\":\"struct IMosaicVault.WithdrawRequestData\",\"name\":\"_withdrawRequestData\",\"type\":\"tuple\"}],\"name\":\"withdrawLiquidityRequest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_accountTo\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"investmentStrategies\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"investmentStrategiesData\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"ammId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amountToSwapToNative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOutNative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nativeSwapperId\",\"type\":\"uint256\"}],\"internalType\":\"struct IMosaicVault.WithdrawData\",\"name\":\"_withdrawData\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MosaicVault", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}