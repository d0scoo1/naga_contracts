{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Factory.sol\": {\r\n      \"content\": \"/**\\n * @title Factory\\n * @author @InsureDAO\\n * @notice This contract is the functory contract that manages functions related to market creation activities.\\n * SPDX-License-Identifier: GPL-3.0\\n */\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"./interfaces/IOwnership.sol\\\";\\nimport \\\"./interfaces/IUniversalMarket.sol\\\";\\nimport \\\"./interfaces/IRegistry.sol\\\";\\nimport \\\"./interfaces/IFactory.sol\\\";\\n\\ncontract Factory is IFactory {\\n    event MarketCreated(\\n        address indexed market,\\n        address indexed template,\\n        string _metaData,\\n        uint256[] conditions,\\n        address[] references\\n    );\\n    event TemplateApproval(\\n        IUniversalMarket indexed template,\\n        bool approval,\\n        bool isOpen,\\n        bool duplicate\\n    );\\n    event ReferenceApproval(\\n        IUniversalMarket indexed template,\\n        uint256 indexed slot,\\n        address target,\\n        bool approval\\n    );\\n    event ConditionApproval(\\n        IUniversalMarket indexed template,\\n        uint256 indexed slot,\\n        uint256 target\\n    );\\n\\n    struct Template {\\n        bool approval; //true if the template exists\\n        bool isOpen; //true if the market allows anyone to create a market\\n        bool allowDuplicate; //true if the market with same ID is allowed\\n    }\\n    mapping(address => Template) public templates;\\n    //mapping of authorized market template address\\n\\n    mapping(address => mapping(uint256 => mapping(address => bool)))\\n        public reflist;\\n    //Authorized reference(address) list for market market template\\n    //Each template has different set of references\\n    //true if that address is authorized within the template\\n    // Example reference list for pool template v1\\n    // references[0] = target governance token address\\n    // references[1] = underlying token address\\n    // references[2] = registry\\n    // references[3] = parameter\\n\\n    mapping(address => mapping(uint256 => uint256)) public conditionlist;\\n    //Authorized condition(uint256) list for market temaplate\\n    //Each template has different set of conditions\\n    //true if that address is authorized within the template\\n    // Example condition list for pool template v1\\n    // conditions[0] = minimim deposit amount\\n\\n    address public immutable registry;\\n    IOwnership public immutable ownership;\\n\\n    modifier onlyOwner() {\\n        require(\\n            ownership.owner() == msg.sender,\\n            \\\"Caller is not allowed to operate\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(address _registry, address _ownership) {\\n        require(_registry != address(0), \\\"ERROR: ZERO_ADDRESS\\\");\\n        require(_ownership != address(0), \\\"ERROR: ZERO_ADDRESS\\\");\\n        \\n        registry = _registry;\\n        ownership = IOwnership(_ownership);\\n    }\\n\\n    /**\\n     * @notice A function to approve or disapprove templates.\\n     * Only owner of the contract can operate.\\n     * @param _template template address, which must be registered\\n     * @param _approval true if a market is allowed to create based on the template\\n     * @param _isOpen true if anyone can create a market based on the template\\n     * @param _duplicate true if a market with duplicate target id is allowed\\n     */\\n    function approveTemplate(\\n        IUniversalMarket _template,\\n        bool _approval,\\n        bool _isOpen,\\n        bool _duplicate\\n    ) external override onlyOwner {\\n        require(address(_template) != address(0), \\\"ERROR_ZERO_ADDRESS\\\");\\n        Template memory approvedTemplate = Template(_approval, _isOpen, _duplicate);\\n        templates[address(_template)] = approvedTemplate;\\n        emit TemplateApproval(_template, _approval, _isOpen, _duplicate);\\n    }\\n\\n    /**\\n     * @notice A function to preset reference.\\n     * Only owner of the contract can operate.\\n     * @param _template template address, which must be registered\\n     * @param _slot the index within reference array\\n     * @param _target the reference  address\\n     * @param _approval true if the reference is approved\\n     */\\n    function approveReference(\\n        IUniversalMarket _template,\\n        uint256 _slot,\\n        address _target,\\n        bool _approval\\n    ) external override onlyOwner {\\n        require(\\n            templates[address(_template)].approval,\\n            \\\"ERROR: UNAUTHORIZED_TEMPLATE\\\"\\n        );\\n        reflist[address(_template)][_slot][_target] = _approval;\\n        emit ReferenceApproval(_template, _slot, _target, _approval);\\n    }\\n\\n    /**\\n     * @notice A function to preset reference.\\n     * Only owner of the contract can operate.\\n     * @param _template template address, which must be registered\\n     * @param _slot the index within condition array\\n     * @param _target the condition uint\\n     */\\n    function setCondition(\\n        IUniversalMarket _template,\\n        uint256 _slot,\\n        uint256 _target\\n    ) external override onlyOwner {\\n        require(\\n            templates[address(_template)].approval,\\n            \\\"ERROR: UNAUTHORIZED_TEMPLATE\\\"\\n        );\\n        conditionlist[address(_template)][_slot] = _target;\\n        emit ConditionApproval(_template, _slot, _target);\\n    }\\n\\n    /**\\n     * @notice A function to create markets.\\n     * This function is market model agnostic.\\n     * @param _template template address, which must be registered\\n     * @param _metaData arbitrary string to store market information\\n     * @param _conditions array of conditions\\n     * @param _references array of references\\n     * @return created market address\\n     */\\n    function createMarket(\\n        IUniversalMarket _template,\\n        string calldata _metaData,\\n        uint256[] memory _conditions,\\n        address[] calldata _references\\n    ) external override returns (address) {\\n        //check eligibility\\n        require(\\n            templates[address(_template)].approval,\\n            \\\"ERROR: UNAUTHORIZED_TEMPLATE\\\"\\n        );\\n        if (!templates[address(_template)].isOpen) {\\n            require(\\n                ownership.owner() == msg.sender,\\n                \\\"ERROR: UNAUTHORIZED_SENDER\\\"\\n            );\\n        }\\n\\n        uint256 refLength = _references.length;\\n        for (uint256 i; i < refLength;) {\\n            require(\\n                reflist[address(_template)][i][_references[i]] || reflist[address(_template)][i][address(0)],\\n                \\\"ERROR: UNAUTHORIZED_REFERENCE\\\"\\n            );\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        uint256 conLength = _conditions.length;\\n        for (uint256 i; i < conLength;) {\\n            if (conditionlist[address(_template)][i] != 0) {\\n                _conditions[i] = conditionlist[address(_template)][i];\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        address _registry = registry;\\n        if (\\n            !IRegistry(_registry).confirmExistence(\\n                address(_template),\\n                _references[0]\\n            )\\n        ) {\\n            IRegistry(_registry).setExistence(\\n                address(_template),\\n                _references[0]\\n            );\\n        } else if (!templates[address(_template)].allowDuplicate) {\\n            revert(\\\"ERROR: DUPLICATE_MARKET\\\");\\n        }\\n\\n        //create market\\n        IUniversalMarket market = IUniversalMarket(\\n            _createClone(address(_template))\\n        );\\n        \\n        IRegistry(_registry).supportMarket(address(market));\\n\\n        //initialize\\n        market.initialize(msg.sender, _metaData, _conditions, _references);\\n\\n        emit MarketCreated(\\n            address(market),\\n            address(_template),\\n            _metaData,\\n            _conditions,\\n            _references\\n        );\\n\\n        return address(market);\\n    }\\n\\n    /**\\n     * @notice Template Code for the create clone method:\\n     * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1167.md\\n     */\\n    function _createClone(address target) internal returns (address result) {\\n        // convert address to bytes20 for assembly use\\n        bytes20 targetBytes = bytes20(target);\\n        assembly {\\n            // allocate clone memory\\n            let clone := mload(0x40)\\n            // store initial portion of the delegation contract code in bytes form\\n            mstore(\\n                clone,\\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\\n            )\\n            // store the provided address\\n            mstore(add(clone, 0x14), targetBytes)\\n            // store the remaining delegation contract code\\n            mstore(\\n                add(clone, 0x28),\\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\\n            )\\n            // create the actual delegate contract reference and return its address\\n            result := create(0, clone, 0x37)\\n        }\\n        require(result != address(0), \\\"ERROR: ZERO_ADDRESS\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOwnership.sol\": {\r\n      \"content\": \"pragma solidity 0.8.10;\\n\\n//SPDX-License-Identifier: MIT\\n\\ninterface IOwnership {\\n    function owner() external view returns (address);\\n\\n    function futureOwner() external view returns (address);\\n\\n    function commitTransferOwnership(address newOwner) external;\\n\\n    function acceptTransferOwnership() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniversalMarket.sol\": {\r\n      \"content\": \"pragma solidity 0.8.10;\\n\\ninterface IUniversalMarket {\\n    function initialize(\\n        address _depositor,\\n        string calldata _metaData,\\n        uint256[] calldata _conditions,\\n        address[] calldata _references\\n    ) external;\\n\\n    //onlyOwner\\n    function setPaused(bool state) external;\\n    function changeMetadata(string calldata _metadata) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRegistry.sol\": {\r\n      \"content\": \"pragma solidity 0.8.10;\\n\\ninterface IRegistry {\\n    function isListed(address _market) external view returns (bool);\\n\\n    function getCDS(address _address) external view returns (address);\\n\\n    function confirmExistence(address _template, address _target)\\n        external\\n        view\\n        returns (bool);\\n\\n    //onlyOwner\\n    function setFactory(address _factory) external;\\n\\n    function supportMarket(address _market) external;\\n\\n    function setExistence(address _template, address _target) external;\\n\\n    function setCDS(address _address, address _cds) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"./IUniversalMarket.sol\\\";\\n\\ninterface IFactory {\\n    function approveTemplate(\\n        IUniversalMarket _template,\\n        bool _approval,\\n        bool _isOpen,\\n        bool _duplicate\\n    ) external;\\n\\n    function approveReference(\\n        IUniversalMarket _template,\\n        uint256 _slot,\\n        address _target,\\n        bool _approval\\n    ) external;\\n\\n    function setCondition(\\n        IUniversalMarket _template,\\n        uint256 _slot,\\n        uint256 _target\\n    ) external;\\n\\n    function createMarket(\\n        IUniversalMarket _template,\\n        string memory _metaData,\\n        uint256[] memory _conditions,\\n        address[] memory _references\\n    ) external returns (address);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ownership\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IUniversalMarket\",\"name\":\"template\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"}],\"name\":\"ConditionApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"template\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_metaData\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"conditions\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"references\",\"type\":\"address[]\"}],\"name\":\"MarketCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IUniversalMarket\",\"name\":\"template\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approval\",\"type\":\"bool\"}],\"name\":\"ReferenceApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IUniversalMarket\",\"name\":\"template\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approval\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"duplicate\",\"type\":\"bool\"}],\"name\":\"TemplateApproval\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IUniversalMarket\",\"name\":\"_template\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_slot\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approval\",\"type\":\"bool\"}],\"name\":\"approveReference\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniversalMarket\",\"name\":\"_template\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approval\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isOpen\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_duplicate\",\"type\":\"bool\"}],\"name\":\"approveTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"conditionlist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniversalMarket\",\"name\":\"_template\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_metaData\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"_conditions\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_references\",\"type\":\"address[]\"}],\"name\":\"createMarket\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownership\",\"outputs\":[{\"internalType\":\"contract IOwnership\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"reflist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniversalMarket\",\"name\":\"_template\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_slot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_target\",\"type\":\"uint256\"}],\"name\":\"setCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"templates\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"approval\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowDuplicate\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Factory", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a035dfd0d16f238493b374a1743b77448d9c8524000000000000000000000000f4db9926ae02469d730a25ad7422764bbd45d36f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}