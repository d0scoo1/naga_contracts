{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ninterface IOracle {\n    function value() external view returns (int256, bool);\n\n    function nextValue() external view returns (int256);\n\n    function update() external returns (bool);\n}\n/// @notice Emitted when paused\nerror Pausable__whenNotPaused_paused();\n\n/// @notice Emitted when not paused\nerror Pausable__whenPaused_notPaused();\n\n/// @title Guarded\n/// @notice Mixin implementing an authentication scheme on a method level\nabstract contract Guarded {\n    /// ======== Custom Errors ======== ///\n\n    error Guarded__notRoot();\n    error Guarded__notGranted();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Wildcard for granting a caller to call every guarded method\n    bytes32 public constant ANY_SIG = keccak256(\"ANY_SIG\");\n    /// @notice Wildcard for granting a caller to call every guarded method\n    address public constant ANY_CALLER =\n        address(uint160(uint256(bytes32(keccak256(\"ANY_CALLER\")))));\n\n    /// @notice Mapping storing who is granted to which method\n    /// @dev Method Signature => Caller => Bool\n    mapping(bytes32 => mapping(address => bool)) private _canCall;\n\n    /// ======== Events ======== ///\n\n    event AllowCaller(bytes32 sig, address who);\n    event BlockCaller(bytes32 sig, address who);\n\n    constructor() {\n        // set root\n        _setRoot(msg.sender);\n    }\n\n    /// ======== Auth ======== ///\n\n    modifier callerIsRoot() {\n        if (_canCall[ANY_SIG][msg.sender]) {\n            _;\n        } else revert Guarded__notRoot();\n    }\n\n    modifier checkCaller() {\n        if (canCall(msg.sig, msg.sender)) {\n            _;\n        } else revert Guarded__notGranted();\n    }\n\n    /// @notice Grant the right to call method `sig` to `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig_ Method signature (4Byte)\n    /// @param who_ Address of who should be able to call `sig`\n    function allowCaller(bytes32 sig_, address who_) public callerIsRoot {\n        _canCall[sig_][who_] = true;\n        emit AllowCaller(sig_, who_);\n    }\n\n    /// @notice Revoke the right to call method `sig` from `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig_ Method signature (4Byte)\n    /// @param who_ Address of who should not be able to call `sig` anymore\n    function blockCaller(bytes32 sig_, address who_) public callerIsRoot {\n        _canCall[sig_][who_] = false;\n        emit BlockCaller(sig_, who_);\n    }\n\n    /// @notice Returns if `who` can call `sig`\n    /// @param sig_ Method signature (4Byte)\n    /// @param who_ Address of who should be able to call `sig`\n    function canCall(bytes32 sig_, address who_) public view returns (bool) {\n        return (_canCall[sig_][who_] ||\n            _canCall[ANY_SIG][who_] ||\n            _canCall[sig_][ANY_CALLER]);\n    }\n\n    /// @notice Sets the root user (granted `ANY_SIG`)\n    /// @param root_ Address of who should be set as root\n    function _setRoot(address root_) internal {\n        _canCall[ANY_SIG][root_] = true;\n        emit AllowCaller(ANY_SIG, root_);\n    }\n}\ncontract Pausable is Guarded {\n    event Paused(address who);\n    event Unpaused(address who);\n\n    bool private _paused;\n\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    modifier whenNotPaused() {\n        // If the contract is paused, throw an error\n        if (_paused) {\n            revert Pausable__whenNotPaused_paused();\n        }\n        _;\n    }\n\n    modifier whenPaused() {\n        // If the contract is not paused, throw an error\n        if (_paused == false) {\n            revert Pausable__whenPaused_notPaused();\n        }\n        _;\n    }\n\n    function _pause() internal whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function _unpause() internal whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\nabstract contract Oracle is Pausable, IOracle {\n    /// @notice Emitted when a method is reentered\n    error Oracle__nonReentrant();\n\n    /// ======== Events ======== ///\n\n    event ValueInvalid();\n    event ValueUpdated(int256 currentValue, int256 nextValue);\n    event OracleReset();\n\n    /// ======== Storage ======== ///\n    // Time interval between the value updates\n    uint256 public immutable timeUpdateWindow;\n\n    // Timestamp of the current value\n    uint256 public lastTimestamp;\n\n    // The next value that will replace the current value once the timeUpdateWindow has passed\n    int256 public override(IOracle) nextValue;\n\n    // Current value that will be returned by the Oracle\n    int256 private _currentValue;\n\n    // Flag that tells if the value provider returned successfully\n    bool private _validReturnedValue;\n\n    // Reentrancy constants\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    // Reentrancy guard flag\n    uint256 private _reentrantGuard = _NOT_ENTERED;\n\n    /// ======== Modifiers ======== ///\n\n    modifier nonReentrant() {\n        // Check if the guard is set\n        if (_reentrantGuard != _NOT_ENTERED) {\n            revert Oracle__nonReentrant();\n        }\n\n        // Set the guard\n        _reentrantGuard = _ENTERED;\n\n        // Allow execution\n        _;\n\n        // Reset the guard\n        _reentrantGuard = _NOT_ENTERED;\n    }\n\n    constructor(uint256 timeUpdateWindow_) {\n        timeUpdateWindow = timeUpdateWindow_;\n        _validReturnedValue = false;\n    }\n\n    /// @notice Get the current value of the oracle\n    /// @return The current value of the oracle\n    /// @return Whether the value is valid\n    function value()\n        public\n        view\n        override(IOracle)\n        whenNotPaused\n        returns (int256, bool)\n    {\n        // Value is considered valid if the value provider successfully returned a value\n        return (_currentValue, _validReturnedValue);\n    }\n\n    function getValue() external virtual returns (int256);\n\n    function update()\n        public\n        override(IOracle)\n        checkCaller\n        nonReentrant\n        returns (bool)\n    {\n        // Not enough time has passed since the last update\n        if (lastTimestamp + timeUpdateWindow > block.timestamp) {\n            // Exit early if no update is needed\n            return false;\n        }\n\n        // Oracle update should not fail even if the value provider fails to return a value\n        try this.getValue() returns (int256 returnedValue) {\n            // Update the value using an exponential moving average\n            if (_currentValue == 0) {\n                // First update takes the current value\n                nextValue = returnedValue;\n                _currentValue = nextValue;\n            } else {\n                // Update the current value with the next value\n                _currentValue = nextValue;\n                // Set the returnedValue as the next value\n                nextValue = returnedValue;\n            }\n\n            // Save when the value was last updated\n            lastTimestamp = block.timestamp;\n            _validReturnedValue = true;\n\n            emit ValueUpdated(_currentValue, nextValue);\n\n            return true;\n        } catch {\n            // When a value provider fails, we update the valid flag which will\n            // invalidate the value instantly\n            _validReturnedValue = false;\n            emit ValueInvalid();\n        }\n\n        return false;\n    }\n\n    function pause() public checkCaller {\n        _pause();\n    }\n\n    function unpause() public checkCaller {\n        _unpause();\n    }\n\n    function reset() public whenPaused checkCaller {\n        _currentValue = 0;\n        nextValue = 0;\n        lastTimestamp = 0;\n        _validReturnedValue = false;\n\n        emit OracleReset();\n    }\n}\ncontract Convert {\n    function convert(\n        int256 x_,\n        uint256 currentPrecision_,\n        uint256 targetPrecision_\n    ) internal pure returns (int256) {\n        if (targetPrecision_ > currentPrecision_)\n            return x_ * int256(10**(targetPrecision_ - currentPrecision_));\n\n        return x_ / int256(10**(currentPrecision_ - targetPrecision_));\n    }\n\n    function uconvert(\n        uint256 x_,\n        uint256 currentPrecision_,\n        uint256 targetPrecision_\n    ) internal pure returns (uint256) {\n        if (targetPrecision_ > currentPrecision_)\n            return x_ * 10**(targetPrecision_ - currentPrecision_);\n\n        return x_ / 10**(currentPrecision_ - targetPrecision_);\n    }\n}\n// Chainlink Aggregator v3 interface\n// https://github.com/smartcontractkit/chainlink/blob/6fea3ccd275466e082a22be690dbaf1609f19dce/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\ninterface IChainlinkAggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\ncontract ChainlinkValueProvider is Oracle, Convert {\n    uint8 public immutable underlierDecimals;\n    address public chainlinkAggregatorAddress;\n\n    /// @notice Constructs the Value provider contracts with the needed Chainlink.\n    /// @param timeUpdateWindow_ Minimum time between updates of the value\n    /// @param chainlinkAggregatorAddress_ Address of the deployed chainlink aggregator contract.\n    constructor(\n        // Oracle parameters\n        uint256 timeUpdateWindow_,\n        // Chainlink specific parameter\n        address chainlinkAggregatorAddress_\n    ) Oracle(timeUpdateWindow_) {\n        chainlinkAggregatorAddress = chainlinkAggregatorAddress_;\n        underlierDecimals = IChainlinkAggregatorV3Interface(\n            chainlinkAggregatorAddress_\n        ).decimals();\n    }\n\n    /// @notice Retrieves the price from the chainlink aggregator\n    /// @return result The result as an signed 59.18-decimal fixed-point number.\n    function getValue() external view override(Oracle) returns (int256) {\n        // Convert the annual rate to 1e18 precision.\n        (, int256 answer, , , ) = IChainlinkAggregatorV3Interface(\n            chainlinkAggregatorAddress\n        ).latestRoundData();\n\n        return convert(answer, underlierDecimals, 18);\n    }\n\n    /// @notice returns the description of the chainlink aggregator the proxy points to.\n    function description() external view returns (string memory) {\n        return\n            IChainlinkAggregatorV3Interface(chainlinkAggregatorAddress)\n                .description();\n    }\n}\ninterface IRelayer {\n    enum RelayerType {\n        DiscountRate,\n        SpotPrice,\n        COUNT\n    }\n\n    function execute() external returns (bool);\n\n    function executeWithRevert() external;\n}// Lightweight interface for Collybus\n// Source: https://github.com/fiatdao/fiat-lux/blob/f49a9457fbcbdac1969c35b4714722f00caa462c/src/interfaces/ICollybus.sol\ninterface ICollybus {\n    function updateDiscountRate(uint256 tokenId_, uint256 rate_) external;\n\n    function updateSpot(address token_, uint256 spot_) external;\n}\n/// @notice The Relayer contract manages the relationship between an oracle and Collybus.\n/// The Relayer manages an Oracle for which it controls the update flow and via execute() calls\n/// pushes data to Collybus when it's needed\n/// @dev The Relayer should be the single entity that updates the oracle so that the Relayer and the Oracle\n/// are value synched. The same is true for the Relayer-Collybus relationship as we do not interrogate the Collybus\n/// for the current value and use a storage cached last updated value.\ncontract Relayer is Guarded, IRelayer {\n    /// @notice Emitter during executeWithRevert() if the oracle is not updated successfully\n    error Relayer__executeWithRevert_noUpdate(RelayerType relayerType);\n\n    /// @notice Emitted when trying to set a parameter that does not exist\n    error Relayer__setParam_unrecognizedParam(bytes32 param);\n\n    event SetParam(bytes32 param, uint256 value);\n    event UpdateOracle(address oracle, int256 value, bool valid);\n    event UpdatedCollybus(bytes32 tokenId, uint256 rate, RelayerType);\n\n    /// ======== Storage ======== ///\n\n    address public immutable collybus;\n    RelayerType public immutable relayerType;\n    address public immutable oracle;\n    bytes32 public immutable encodedTokenId;\n\n    uint256 public minimumPercentageDeltaValue;\n    int256 private _lastUpdateValue;\n\n    /// @param collybusAddress_ Address of the collybus\n    /// @param type_ Relayer type, DiscountRate or SpotPrice\n    /// @param oracleAddress_ The address of the oracle used by the Relayer\n    /// @param encodedTokenId_ Encoded token Id that will be used to push values to Collybus\n    /// uint256 for discount rate, address for spot price\n    /// @param minimumPercentageDeltaValue_ Minimum delta value used to determine when to\n    /// push data to Collybus\n    constructor(\n        address collybusAddress_,\n        RelayerType type_,\n        address oracleAddress_,\n        bytes32 encodedTokenId_,\n        uint256 minimumPercentageDeltaValue_\n    ) {\n        collybus = collybusAddress_;\n        relayerType = type_;\n        oracle = oracleAddress_;\n        encodedTokenId = encodedTokenId_;\n        minimumPercentageDeltaValue = minimumPercentageDeltaValue_;\n        _lastUpdateValue = 0;\n    }\n\n    /// @notice Sets a Relayer parameter\n    /// Supported parameters are:\n    /// - minimumPercentageDeltaValue\n    /// @param param_ The identifier of the parameter that should be updated\n    /// @param value_ The new value\n    /// @dev Reverts if parameter is not found\n    function setParam(bytes32 param_, uint256 value_) public checkCaller {\n        if (param_ == \"minimumPercentageDeltaValue\") {\n            minimumPercentageDeltaValue = value_;\n        } else revert Relayer__setParam_unrecognizedParam(param_);\n\n        emit SetParam(param_, value_);\n    }\n\n    /// @notice Updates the oracle and pushes the updated data to Collybus if the\n    /// delta change in value is larger than the minimum threshold value\n    /// @return Whether the Collybus was or is about to be updated\n    /// @dev Return value is mainly meant to be used by Keepers in order to optimize costs\n    function execute() public override(IRelayer) returns (bool) {\n        // We always update the oracles before retrieving the rates\n        bool oracleUpdated = IOracle(oracle).update();\n        (int256 oracleValue, ) = IOracle(oracle).value();\n\n        // If the oracle was not updated we exit early because no value was updated\n        if (!oracleUpdated) return false;\n\n        // We calculate whether the returned value is over the minimumPercentageDeltaValue\n        // If the deviation is large enough we push the value to Collybus and return true\n        bool currentValueThresholdPassed = checkDeviation(\n            _lastUpdateValue,\n            oracleValue,\n            minimumPercentageDeltaValue\n        );\n        if (currentValueThresholdPassed) {\n            updateCollybus(oracleValue);\n            return true;\n        }\n\n        // If the oracle received a new value (nextValue != oracleValue), but wasn't updated yet,\n        // we return true to indicate that the Collybus is about to be updated\n        bool nextValueThresholdPassed = checkDeviation(\n            _lastUpdateValue,\n            IOracle(oracle).nextValue(),\n            minimumPercentageDeltaValue\n        );\n\n        return nextValueThresholdPassed;\n    }\n\n    /// @notice The function will call execute() and will revert if false\n    /// @dev This method is needed for services that run on each block and only call the method if it doesn't fail\n    /// For extra information on the revert conditions check the execute() function\n    function executeWithRevert() public override(IRelayer) {\n        if (!execute()) {\n            revert Relayer__executeWithRevert_noUpdate(relayerType);\n        }\n    }\n\n    /// @notice Updates Collybus with the new value\n    /// @param oracleValue_ the new value pushed into Collybus\n    function updateCollybus(int256 oracleValue_) internal {\n        // Save the new value to be able to check if the next value is over the threshold\n        _lastUpdateValue = oracleValue_;\n\n        if (relayerType == RelayerType.DiscountRate) {\n            ICollybus(collybus).updateDiscountRate(\n                uint256(encodedTokenId),\n                uint256(oracleValue_)\n            );\n        } else if (relayerType == RelayerType.SpotPrice) {\n            ICollybus(collybus).updateSpot(\n                address(uint160(uint256(encodedTokenId))),\n                uint256(oracleValue_)\n            );\n        }\n\n        emit UpdatedCollybus(\n            encodedTokenId,\n            uint256(oracleValue_),\n            relayerType\n        );\n    }\n\n    /// @notice Returns true if the percentage difference between the two values is larger than the percentage\n    /// @param baseValue_ The value that the percentage is based on\n    /// @param newValue_ The new value\n    /// @param percentage_ The percentage threshold value (100% = 100_00, 50% = 50_00, etc)\n    function checkDeviation(\n        int256 baseValue_,\n        int256 newValue_,\n        uint256 percentage_\n    ) public pure returns (bool) {\n        int256 deviation = (baseValue_ * int256(percentage_)) / 100_00;\n\n        if (\n            baseValue_ + deviation <= newValue_ ||\n            baseValue_ - deviation >= newValue_\n        ) return true;\n\n        return false;\n    }\n}\n\n\ncontract ChainlinkFactory {\n    event ChainlinkDeployed(address relayerAddress, address oracleAddress);\n\n    /// @param collybus_ Address of the collybus\n    /// @param tokenAddress_ Token address that will be used to push values to Collybus\n    /// @param minimumPercentageDeltaValue_ Minimum delta value used to determine when to\n    /// push data to Collybus\n    /// @param timeUpdateWindow_ Minimum time between updates of the value\n    /// @param chainlinkAggregatorAddress_ Address of the deployed chainlink aggregator contract.\n    /// @return The address of the Relayer\n    function create(\n        // Relayer parameters\n        address collybus_,\n        address tokenAddress_,\n        uint256 minimumPercentageDeltaValue_,\n        // Oracle parameters\n        uint256 timeUpdateWindow_,\n        // Chainlink specific parameters, see ChainlinkValueProvider for more info\n        address chainlinkAggregatorAddress_\n    ) public returns (address) {\n        ChainlinkValueProvider chainlinkValueProvider = new ChainlinkValueProvider(\n                timeUpdateWindow_,\n                chainlinkAggregatorAddress_\n            );\n\n        // Create the relayer that manages the oracle and pushes data to Collybus\n        Relayer relayer = new Relayer(\n            collybus_,\n            IRelayer.RelayerType.SpotPrice,\n            address(chainlinkValueProvider),\n            bytes32(uint256(uint160(tokenAddress_))),\n            minimumPercentageDeltaValue_\n        );\n\n        // Whitelist the Relayer in the Oracle so it can trigger updates\n        chainlinkValueProvider.allowCaller(\n            chainlinkValueProvider.ANY_SIG(),\n            address(relayer)\n        );\n\n        // Whitelist the deployer\n        chainlinkValueProvider.allowCaller(\n            chainlinkValueProvider.ANY_SIG(),\n            msg.sender\n        );\n        relayer.allowCaller(relayer.ANY_SIG(), msg.sender);\n\n        // Renounce permissions\n        chainlinkValueProvider.blockCaller(\n            chainlinkValueProvider.ANY_SIG(),\n            address(this)\n        );\n        relayer.blockCaller(relayer.ANY_SIG(), address(this));\n\n        emit ChainlinkDeployed(\n            address(relayer),\n            address(chainlinkValueProvider)\n        );\n        return address(relayer);\n    }\n}\n", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oracleAddress\",\"type\":\"address\"}],\"name\":\"ChainlinkDeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collybus_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumPercentageDeltaValue_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeUpdateWindow_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"chainlinkAggregatorAddress_\",\"type\":\"address\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ChainlinkFactory", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "8000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}