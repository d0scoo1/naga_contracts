{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ribbon/AnteRibbonV2ThetaVaultPlungeTest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\n// \u250f\u2501\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2501\u250f\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u2501\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n// \u2503\u250f\u2501\u2513\u2503\u2501\u2501\u2501\u2501\u250f\u251b\u2517\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2503\u250f\u2501\u2501\u251b\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n// \u2503\u2517\u2501\u251b\u2503\u250f\u2501\u2513\u2501\u2517\u2513\u250f\u251b\u250f\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2503\u2517\u2501\u2501\u2513\u250f\u2513\u250f\u2501\u2513\u2501\u250f\u2501\u2501\u2513\u2501\u250f\u2501\u2513\u2501\u250f\u2501\u2501\u2513\u250f\u2501\u2501\u2513\\n// \u2503\u250f\u2501\u2513\u2503\u2503\u250f\u2513\u2513\u2501\u2503\u2503\u2501\u2503\u250f\u2513\u2503\u2501\u2501\u2501\u2501\u2503\u250f\u2501\u2501\u251b\u2523\u252b\u2503\u250f\u2513\u2513\u2517\u2501\u2513\u2503\u2501\u2503\u250f\u2513\u2513\u2503\u250f\u2501\u251b\u2503\u250f\u2513\u2503\\n// \u2503\u2503 \u2503\u2503\u2503\u2503\u2503\u2503\u2501\u2503\u2517\u2513\u2503\u2503\u2501\u252b\u2501\u250f\u2513\u2501\u2503\u2503\u2501\u2501\u2501\u2503\u2503\u2503\u2503\u2503\u2503\u2503\u2517\u251b\u2517\u2513\u2503\u2503\u2503\u2503\u2503\u2517\u2501\u2513\u2503\u2503\u2501\u252b\\n// \u2517\u251b \u2517\u251b\u2517\u251b\u2517\u251b\u2501\u2517\u2501\u251b\u2517\u2501\u2501\u251b\u2501\u2517\u251b\u2501\u2517\u251b\u2501\u2501\u2501\u2517\u251b\u2517\u251b\u2517\u251b\u2517\u2501\u2501\u2501\u251b\u2517\u251b\u2517\u251b\u2517\u2501\u2501\u251b\u2517\u2501\u2501\u251b\\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n\\npragma solidity ^0.8.0;\\n\\nimport {AnteTest} from \\\"../AnteTest.sol\\\";\\nimport {IRibbonThetaVault} from \\\"./ribbon-v2-contracts/interfaces/IRibbonThetaVault.sol\\\";\\nimport {IController, GammaTypes} from \\\"./ribbon-v2-contracts/interfaces/GammaInterface.sol\\\";\\nimport {Vault} from \\\"./ribbon-v2-contracts/libraries/Vault.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Checks that RibbonV2 Theta vaults do not lose 90% of their assets\\n/// @notice Ante Test to check if a catastrophic failure has occured in RibbonV2\\ncontract AnteRibbonV2ThetaVaultPlungeTest is AnteTest(\\\"RibbonV2 doesn't lose 90% of its TVL\\\") {\\n    // currently deployed RibbonV2 theta vaults\\n    IRibbonThetaVault[2] public thetaVaults = [\\n        IRibbonThetaVault(0x25751853Eab4D0eB3652B5eB6ecB102A2789644B), // eth vault\\n        IRibbonThetaVault(0x65a833afDc250D9d38f8CD9bC2B1E3132dB13B2F) // wbtc vault\\n    ];\\n\\n    // Opyn Controller\\n    IController internal controller = IController(0x4ccc2339F87F6c59c6893E1A678c2266cA58dC72);\\n\\n    // threshold amounts for test to fail\\n    uint256[2] public thresholds;\\n\\n    /// @notice percent drop threshold (set to 10%)\\n    uint8 public constant PERCENT_DROP_THRESHOLD = 10;\\n\\n    constructor() {\\n        protocolName = \\\"Ribbon\\\";\\n        for (uint256 i; i < thetaVaults.length; i++) {\\n            thresholds[i] = (calculateAssetBalance(thetaVaults[i]) * PERCENT_DROP_THRESHOLD) / 100;\\n            testedContracts.push(address(thetaVaults[i]));\\n        }\\n    }\\n\\n    /// @notice computes balance of underlying asset in a given Ribbon Theta Vault\\n    /// @param vault RibbonV2 Theta Vault address\\n    /// @return balance of vault\\n    function calculateAssetBalance(IRibbonThetaVault vault) public view returns (uint256) {\\n        Vault.VaultParams memory vaultParams = vault.vaultParams();\\n        IERC20 underlying = IERC20(vaultParams.underlying);\\n\\n        GammaTypes.Vault memory opynVault = controller.getVault(\\n            address(vault),\\n            controller.getAccountVaultCounter(address(vault))\\n        );\\n\\n        // make assumption that there is only one collateral asset in vault\\n        return underlying.balanceOf(address(vault)) + opynVault.collateralAmounts[0];\\n    }\\n\\n    /// @notice checks balance of Ribbon Theta V2 vaults against threshold\\n    /// (10% of balance when this contract was deployed)\\n    /// @return true if balance of all theta vaults is greater than thresholds\\n    function checkTestPasses() external view override returns (bool) {\\n        for (uint256 i; i < thetaVaults.length; i++) {\\n            if (calculateAssetBalance(thetaVaults[i]) < thresholds[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AnteTest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\n// \u250f\u2501\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2501\u250f\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u2501\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n// \u2503\u250f\u2501\u2513\u2503\u2501\u2501\u2501\u2501\u250f\u251b\u2517\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2503\u250f\u2501\u2501\u251b\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n// \u2503\u2517\u2501\u251b\u2503\u250f\u2501\u2513\u2501\u2517\u2513\u250f\u251b\u250f\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2503\u2517\u2501\u2501\u2513\u250f\u2513\u250f\u2501\u2513\u2501\u250f\u2501\u2501\u2513\u2501\u250f\u2501\u2513\u2501\u250f\u2501\u2501\u2513\u250f\u2501\u2501\u2513\\n// \u2503\u250f\u2501\u2513\u2503\u2503\u250f\u2513\u2513\u2501\u2503\u2503\u2501\u2503\u250f\u2513\u2503\u2501\u2501\u2501\u2501\u2503\u250f\u2501\u2501\u251b\u2523\u252b\u2503\u250f\u2513\u2513\u2517\u2501\u2513\u2503\u2501\u2503\u250f\u2513\u2513\u2503\u250f\u2501\u251b\u2503\u250f\u2513\u2503\\n// \u2503\u2503 \u2503\u2503\u2503\u2503\u2503\u2503\u2501\u2503\u2517\u2513\u2503\u2503\u2501\u252b\u2501\u250f\u2513\u2501\u2503\u2503\u2501\u2501\u2501\u2503\u2503\u2503\u2503\u2503\u2503\u2503\u2517\u251b\u2517\u2513\u2503\u2503\u2503\u2503\u2503\u2517\u2501\u2513\u2503\u2503\u2501\u252b\\n// \u2517\u251b \u2517\u251b\u2517\u251b\u2517\u251b\u2501\u2517\u2501\u251b\u2517\u2501\u2501\u251b\u2501\u2517\u251b\u2501\u2517\u251b\u2501\u2501\u2501\u2517\u251b\u2517\u251b\u2517\u251b\u2517\u2501\u2501\u2501\u251b\u2517\u251b\u2517\u251b\u2517\u2501\u2501\u251b\u2517\u2501\u2501\u251b\\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n\\npragma solidity >=0.7.0;\\n\\nimport \\\"./interfaces/IAnteTest.sol\\\";\\n\\n/// @title Ante V0.5 Ante Test smart contract\\n/// @notice Abstract inheritable contract that supplies syntactic sugar for writing Ante Tests\\n/// @dev Usage: contract YourAnteTest is AnteTest(\\\"String descriptor of test\\\") { ... }\\nabstract contract AnteTest is IAnteTest {\\n    /// @inheritdoc IAnteTest\\n    address public override testAuthor;\\n    /// @inheritdoc IAnteTest\\n    string public override testName;\\n    /// @inheritdoc IAnteTest\\n    string public override protocolName;\\n    /// @inheritdoc IAnteTest\\n    address[] public override testedContracts;\\n\\n    /// @dev testedContracts and protocolName are optional parameters which should\\n    /// be set in the constructor of your AnteTest\\n    /// @param _testName The name of the Ante Test\\n    constructor(string memory _testName) {\\n        testAuthor = msg.sender;\\n        testName = _testName;\\n    }\\n\\n    /// @notice Returns the testedContracts array of addresses\\n    /// @return The list of tested contracts as an array of addresses\\n    function getTestedContracts() external view returns (address[] memory) {\\n        return testedContracts;\\n    }\\n\\n    /// @inheritdoc IAnteTest\\n    function checkTestPasses() external virtual override returns (bool) {}\\n}\\n\"\r\n    },\r\n    \"contracts/ribbon/ribbon-v2-contracts/interfaces/IRibbonThetaVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport {Vault} from \\\"../libraries/Vault.sol\\\";\\n\\ninterface IRibbonThetaVault {\\n    function GAMMA_CONTROLLER() external view returns (address);\\n\\n    function currentOption() external view returns (address);\\n\\n    function nextOption() external view returns (address);\\n\\n    function vaultParams() external view returns (Vault.VaultParams memory);\\n\\n    function vaultState() external view returns (Vault.VaultState memory);\\n\\n    function optionState() external view returns (Vault.OptionState memory);\\n\\n    function optionAuctionID() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/ribbon/ribbon-v2-contracts/interfaces/GammaInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nlibrary GammaTypes {\\n    // vault is a struct of 6 arrays that describe a position a user has, a user can have multiple vaults.\\n    struct Vault {\\n        // addresses of oTokens a user has shorted (i.e. written) against this vault\\n        address[] shortOtokens;\\n        // addresses of oTokens a user has bought and deposited in this vault\\n        // user can be long oTokens without opening a vault (e.g. by buying on a DEX)\\n        // generally, long oTokens will be 'deposited' in vaults to act as collateral\\n        // in order to write oTokens against (i.e. in spreads)\\n        address[] longOtokens;\\n        // addresses of other ERC-20s a user has deposited as collateral in this vault\\n        address[] collateralAssets;\\n        // quantity of oTokens minted/written for each oToken address in shortOtokens\\n        uint256[] shortAmounts;\\n        // quantity of oTokens owned and held in the vault for each oToken address in longOtokens\\n        uint256[] longAmounts;\\n        // quantity of ERC-20 deposited as collateral in the vault for each ERC-20 address in collateralAssets\\n        uint256[] collateralAmounts;\\n    }\\n}\\n\\ninterface IOtoken {\\n    function underlyingAsset() external view returns (address);\\n\\n    function strikeAsset() external view returns (address);\\n\\n    function collateralAsset() external view returns (address);\\n\\n    function strikePrice() external view returns (uint256);\\n\\n    function expiryTimestamp() external view returns (uint256);\\n\\n    function isPut() external view returns (bool);\\n}\\n\\ninterface IOtokenFactory {\\n    function getOtoken(\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        address _collateralAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiry,\\n        bool _isPut\\n    ) external view returns (address);\\n\\n    function createOtoken(\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        address _collateralAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiry,\\n        bool _isPut\\n    ) external returns (address);\\n\\n    function getTargetOtokenAddress(\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        address _collateralAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiry,\\n        bool _isPut\\n    ) external view returns (address);\\n\\n    event OtokenCreated(\\n        address tokenAddress,\\n        address creator,\\n        address indexed underlying,\\n        address indexed strike,\\n        address indexed collateral,\\n        uint256 strikePrice,\\n        uint256 expiry,\\n        bool isPut\\n    );\\n}\\n\\ninterface IController {\\n    // possible actions that can be performed\\n    enum ActionType {\\n        OpenVault,\\n        MintShortOption,\\n        BurnShortOption,\\n        DepositLongOption,\\n        WithdrawLongOption,\\n        DepositCollateral,\\n        WithdrawCollateral,\\n        SettleVault,\\n        Redeem,\\n        Call,\\n        Liquidate\\n    }\\n\\n    struct ActionArgs {\\n        // type of action that is being performed on the system\\n        ActionType actionType;\\n        // address of the account owner\\n        address owner;\\n        // address which we move assets from or to (depending on the action type)\\n        address secondAddress;\\n        // asset that is to be transfered\\n        address asset;\\n        // index of the vault that is to be modified (if any)\\n        uint256 vaultId;\\n        // amount of asset that is to be transfered\\n        uint256 amount;\\n        // each vault can hold multiple short / long / collateral assets\\n        // but we are restricting the scope to only 1 of each in this version\\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\\n        uint256 index;\\n        // any other data that needs to be passed in for arbitrary function calls\\n        bytes data;\\n    }\\n\\n    struct RedeemArgs {\\n        // address to which we pay out the oToken proceeds\\n        address receiver;\\n        // oToken that is to be redeemed\\n        address otoken;\\n        // amount of oTokens that is to be redeemed\\n        uint256 amount;\\n    }\\n\\n    function getPayout(address _otoken, uint256 _amount) external view returns (uint256);\\n\\n    function operate(ActionArgs[] calldata _actions) external;\\n\\n    function getAccountVaultCounter(address owner) external view returns (uint256);\\n\\n    function oracle() external view returns (address);\\n\\n    function getVault(address _owner, uint256 _vaultId) external view returns (GammaTypes.Vault memory);\\n\\n    function getProceed(address _owner, uint256 _vaultId) external view returns (uint256);\\n\\n    function isSettlementAllowed(\\n        address _underlying,\\n        address _strike,\\n        address _collateral,\\n        uint256 _expiry\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/ribbon/ribbon-v2-contracts/libraries/Vault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nlibrary Vault {\\n    /************************************************\\n     *  IMMUTABLES & CONSTANTS\\n     ***********************************************/\\n\\n    // Fees are 6-decimal places. For example: 20 * 10**6 = 20%\\n    uint256 internal constant FEE_MULTIPLIER = 10**6;\\n\\n    // Premium discount has 1-decimal place. For example: 80 * 10**1 = 80%. Which represents a 20% discount.\\n    uint256 internal constant PREMIUM_DISCOUNT_MULTIPLIER = 10;\\n\\n    // Otokens have 8 decimal places.\\n    uint256 internal constant OTOKEN_DECIMALS = 8;\\n\\n    // Percentage of funds allocated to options is 2 decimal places. 10 * 10**2 = 10%\\n    uint256 internal constant OPTION_ALLOCATION_MULTIPLIER = 10**2;\\n\\n    // Placeholder uint value to prevent cold writes\\n    uint256 internal constant PLACEHOLDER_UINT = 1;\\n\\n    struct VaultParams {\\n        // Option type the vault is selling\\n        bool isPut;\\n        // Token decimals for vault shares\\n        uint8 decimals;\\n        // Asset used in Theta / Delta Vault\\n        address asset;\\n        // Underlying asset of the options sold by vault\\n        address underlying;\\n        // Minimum supply of the vault shares issued, for ETH it's 10**10\\n        uint56 minimumSupply;\\n        // Vault cap\\n        uint104 cap;\\n    }\\n\\n    struct OptionState {\\n        // Option that the vault is shorting / longing in the next cycle\\n        address nextOption;\\n        // Option that the vault is currently shorting / longing\\n        address currentOption;\\n        // The timestamp when the `nextOption` can be used by the vault\\n        uint32 nextOptionReadyAt;\\n    }\\n\\n    struct VaultState {\\n        // 32 byte slot 1\\n        //  Current round number. `round` represents the number of `period`s elapsed.\\n        uint16 round;\\n        // Amount that is currently locked for selling options\\n        uint104 lockedAmount;\\n        // Amount that was locked for selling options in the previous round\\n        // used for calculating performance fee deduction\\n        uint104 lastLockedAmount;\\n        // 32 byte slot 2\\n        // Stores the total tally of how much of `asset` there is\\n        // to be used to mint rTHETA tokens\\n        uint128 totalPending;\\n        // Amount locked for scheduled withdrawals;\\n        uint128 queuedWithdrawShares;\\n    }\\n\\n    struct DepositReceipt {\\n        // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\\n        uint16 round;\\n        // Deposit amount, max 20,282,409,603,651 or 20 trillion ETH deposit\\n        uint104 amount;\\n        // Unredeemed shares balance\\n        uint128 unredeemedShares;\\n    }\\n\\n    struct Withdrawal {\\n        // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\\n        uint16 round;\\n        // Number of shares withdrawn\\n        uint128 shares;\\n    }\\n\\n    struct AuctionSellOrder {\\n        // Amount of `asset` token offered in auction\\n        uint96 sellAmount;\\n        // Amount of oToken requested in auction\\n        uint96 buyAmount;\\n        // User Id of delta vault in latest gnosis auction\\n        uint64 userId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAnteTest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\n// \u250f\u2501\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2501\u250f\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u250f\u2501\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n// \u2503\u250f\u2501\u2513\u2503\u2501\u2501\u2501\u2501\u250f\u251b\u2517\u2513\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2503\u250f\u2501\u2501\u251b\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n// \u2503\u2517\u2501\u251b\u2503\u250f\u2501\u2513\u2501\u2517\u2513\u250f\u251b\u250f\u2501\u2501\u2513\u2501\u2501\u2501\u2501\u2503\u2517\u2501\u2501\u2513\u250f\u2513\u250f\u2501\u2513\u2501\u250f\u2501\u2501\u2513\u2501\u250f\u2501\u2513\u2501\u250f\u2501\u2501\u2513\u250f\u2501\u2501\u2513\\n// \u2503\u250f\u2501\u2513\u2503\u2503\u250f\u2513\u2513\u2501\u2503\u2503\u2501\u2503\u250f\u2513\u2503\u2501\u2501\u2501\u2501\u2503\u250f\u2501\u2501\u251b\u2523\u252b\u2503\u250f\u2513\u2513\u2517\u2501\u2513\u2503\u2501\u2503\u250f\u2513\u2513\u2503\u250f\u2501\u251b\u2503\u250f\u2513\u2503\\n// \u2503\u2503 \u2503\u2503\u2503\u2503\u2503\u2503\u2501\u2503\u2517\u2513\u2503\u2503\u2501\u252b\u2501\u250f\u2513\u2501\u2503\u2503\u2501\u2501\u2501\u2503\u2503\u2503\u2503\u2503\u2503\u2503\u2517\u251b\u2517\u2513\u2503\u2503\u2503\u2503\u2503\u2517\u2501\u2513\u2503\u2503\u2501\u252b\\n// \u2517\u251b \u2517\u251b\u2517\u251b\u2517\u251b\u2501\u2517\u2501\u251b\u2517\u2501\u2501\u251b\u2501\u2517\u251b\u2501\u2517\u251b\u2501\u2501\u2501\u2517\u251b\u2517\u251b\u2517\u251b\u2517\u2501\u2501\u2501\u251b\u2517\u251b\u2517\u251b\u2517\u2501\u2501\u251b\u2517\u2501\u2501\u251b\\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n// \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\\n\\npragma solidity >=0.7.0;\\n\\n/// @title The interface for the Ante V0.5 Ante Test\\n/// @notice The Ante V0.5 Ante Test wraps test logic for verifying fundamental invariants of a protocol\\ninterface IAnteTest {\\n    /// @notice Returns the author of the Ante Test\\n    /// @dev This overrides the auto-generated getter for testAuthor as a public var\\n    /// @return The address of the test author\\n    function testAuthor() external view returns (address);\\n\\n    /// @notice Returns the name of the protocol the Ante Test is testing\\n    /// @dev This overrides the auto-generated getter for protocolName as a public var\\n    /// @return The name of the protocol in string format\\n    function protocolName() external view returns (string memory);\\n\\n    /// @notice Returns a single address in the testedContracts array\\n    /// @dev This overrides the auto-generated getter for testedContracts [] as a public var\\n    /// @param i The array index of the address to return\\n    /// @return The address of the i-th element in the list of tested contracts\\n    function testedContracts(uint256 i) external view returns (address);\\n\\n    /// @notice Returns the name of the Ante Test\\n    /// @dev This overrides the auto-generated getter for testName as a public var\\n    /// @return The name of the Ante Test in string format\\n    function testName() external view returns (string memory);\\n\\n    /// @notice Function containing test logic to inspect the protocol invariant\\n    /// @dev This should usually return True\\n    /// @return A single bool indicating if the Ante Test passes/fails\\n    function checkTestPasses() external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"PERCENT_DROP_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IRibbonThetaVault\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"calculateAssetBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkTestPasses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTestedContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testAuthor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"testName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"testedContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"thetaVaults\",\"outputs\":[{\"internalType\":\"contract IRibbonThetaVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"thresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AnteRibbonV2ThetaVaultPlungeTest", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}