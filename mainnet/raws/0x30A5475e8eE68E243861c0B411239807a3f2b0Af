{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/nfts/MetroMiniBlockInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity 0.8.12;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"./interfaces/IMetroBlockInfo.sol\\\";\\n\\ncontract MetroMiniBlockInfo is Ownable, IMetroBlockInfo {\\n\\n    uint256 constant BLOCK_ID_OFFSET = 20_000;\\n\\n    uint256 constant MAX_HOOD_SIZE = 10;\\n\\n    uint256 constant SCORES_DATA_SIZE = 10_000;\\n\\n    uint256 constant BOOSTS_DATA_SIZE = 5_000;\\n\\n    uint256 constant BOOSTS_STEP_SIZE = 10_000;\\n\\n    uint256 constant GEN_MASK    = 0x0001_0001_0001_0001_0001_0001_0001_0001_0001_0001_0001_0001_0001_0001_0001_0001;\\n    uint256 constant BO_MASK     = 0x0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000;\\n\\n    uint256 constant GEN_MASK_LO = 0x0001_0001_0000_0000_0000_0000_0000_0001_0001_0001_0001_0000_0000_0001_0000_0000;\\n    uint256 constant BO_MASK_LO  = 0x0000_0000_0001_0001_0001_0001_0001_0000_0000_0000_0000_0001_0001_0000_0001_0001;\\n\\n    uint256 constant GEN_MASK_HI  = 0x0001_0001_0001_0000_0000_0000_0000_0001_0001_0001_0001_0001_0000_0001_0001_0000;\\n    uint256 constant BO_MASK_HI  = 0x0000_0000_0000_0001_0001_0001_0001_0000_0000_0000_0000_0000_0001_0000_0000_0001;\\n\\n    address[] public scoresAddresses;\\n\\n    address[] public blockDataAddresses;\\n\\n    /**\\n     * We have 2 types of boosts sets - genesis-like and blackout-like. Future miniblocks collection\\n     * will feature either one of these boost sets, so we just store boosts kind in bit array \\n     * (one bit per BOOSTS_STEP_SIZE tokens, starting with least significant bit first, 0 - genesis, 1 - blackout).\\n     * e.g., 10k of genesis, 10k of blackout, then 20k of genesis, then 20k of blackout would be 0x110010\\n     */\\n    uint256 boostsTypes = 0x2;\\n\\n    constructor(address[] memory _scoresAddress, address[] memory _blockDataAddresses) {\\n       /*\\n        * Addresses of the contracts that contains list of special entities for each block.\\n        * They are split into parts because they don't fit into 26kb limit\\n        * for a max contract size.\\n        */\\n        scoresAddresses = _scoresAddress;\\n        blockDataAddresses = _blockDataAddresses;\\n    }\\n\\n    function setScoresAddress(uint256 index, address element) external onlyOwner {\\n        require(index < scoresAddresses.length, 'Invalid index');\\n        require(element != address(0), 'invalid address');\\n        scoresAddresses[index] = element;\\n    }\\n\\n    function pushScoreAddress(address element) external onlyOwner {\\n        require(element != address(0), 'invalid address');\\n        scoresAddresses.push(element);\\n    }\\n\\n    function setBlockDataAddress(uint256 index, address element) external onlyOwner {\\n        require(index < blockDataAddresses.length, 'Invalid index');\\n        require(element != address(0), 'invalid address');\\n        blockDataAddresses[index] = element;\\n    }\\n\\n    function pushBlockDataAddress(address element) external onlyOwner {\\n        require(element != address(0), 'invalid address');\\n        blockDataAddresses.push(element);\\n    }\\n\\n    function setBoostsTypes(uint256 _boostsTypes) external onlyOwner {\\n        boostsTypes = _boostsTypes;\\n    }\\n\\n    /**\\n     * NB: tokenIds are required to be pre-sorted. No duplicates allowed.\\n     */\\n    function getHoodBoost(uint256[] calldata tokenIds) external view override returns (uint256) {\\n        /*\\n        * Collection of User's nft tokens staked into the Metroverse Vault defines Hood.\\n        * Each Block could contain Special Entities. Certain combinations of\\n        * Special Entities incrases rate of MET generation.\\n        * For example, if Hospital, Police Station and Fire Station are seen\\n        * all together in User's blocks then whole collection will give 5% more\\n        * MET.\\n        */\\n        uint256 hoodSize = tokenIds.length;\\n\\n        if (hoodSize == 0) {\\n            return 0;\\n        }\\n\\n        // count the special bits of the tokens\\n        uint256 counterGenHi;\\n        uint256 counterGenLow;\\n        uint256 counterBoHi;\\n        uint256 counterBoLo;\\n        uint256 prevTokenId;\\n\\n        // These should have been constants, but solidity is not there yet\\n        uint256[2] memory GEN_MASKS_LO = [GEN_MASK, GEN_MASK_LO];\\n        uint256[2] memory GEN_MASKS_HI = [GEN_MASK, GEN_MASK_HI];\\n\\n        uint256[2] memory BO_MASKS_LO = [BO_MASK, BO_MASK_LO];\\n        uint256[2] memory BO_MASKS_HI = [BO_MASK, BO_MASK_HI];\\n\\n\\n        for (uint256 i; i < tokenIds.length; i++) {\\n            uint256 tokenId = tokenIds[i];\\n            require(prevTokenId < tokenId, 'no duplicates allowed');\\n            prevTokenId = tokenId;\\n\\n            uint256 boost = getBlockInfo(tokenId);\\n            uint256 boostsTypesBitIndex = (tokenId - 1) / BOOSTS_STEP_SIZE;\\n            uint256 boostsType = (boostsTypes >> boostsTypesBitIndex) & 0x1;\\n\\n            unchecked {\\n                counterGenLow +=  boost       & GEN_MASKS_LO[boostsType];\\n                counterGenHi  += (boost >> 8) & GEN_MASKS_HI[boostsType];\\n                counterBoLo   += boost        & BO_MASKS_LO[boostsType];\\n                counterBoHi   += (boost >> 8) & BO_MASKS_HI[boostsType];\\n            }\\n        }\\n\\n        // There are 10 boost categories. Each category gives specific increase in MET production.\\n        // To get category boost blocks should have 3 special buildings related to the category\\n        // Safety, Education, Entertainment, Transport, Sports, Energy, Cultural, Mansion, Tech, Odds\\n        uint256 totalBoost = 0;\\n        uint256 hoodSizeCorrection = 1000 * MAX_HOOD_SIZE / Math.max(hoodSize, MAX_HOOD_SIZE);\\n\\n        unchecked { // River & River\\n            uint256 min = ((counterGenHi >> 240) & 0xffff) / 3;\\n            if (min > 0) {totalBoost += 800 * _getSpreadedBoost(hoodSizeCorrection, min);}\\n        }\\n\\n        unchecked { // Rail & Rail\\n            uint256 min = ((counterGenLow >> 240) & 0xffff) / 3;\\n            if (min > 0) {totalBoost += 400 * _getSpreadedBoost(hoodSizeCorrection, min);}\\n        }\\n\\n        // for each category get the minimum of the 3 counts and add the stacked boost for that category\\n        unchecked { // Safety\\n            uint256 min = (counterGenHi >> 224) & 0xffff;\\n            uint256 v   = (counterGenLow >> 224) & 0xffff; if (v < min) {min = v;}\\n            v           = (counterGenHi >> 208) & 0xffff; if (v < min) {min = v;}\\n            if (min > 0) {totalBoost += 500 * _getSpreadedBoost(hoodSizeCorrection, min);}\\n        }\\n        unchecked { // Education\\n            uint256 min = (counterGenLow >> 208) & 0xffff;\\n            uint256 v   = (counterGenHi >> 192) & 0xffff; if (v < min) {min = v;}\\n            v           = (counterGenLow >> 192) & 0xffff; if (v < min) {min = v;}\\n            if (min > 0) {totalBoost += 600 * _getSpreadedBoost(hoodSizeCorrection, min);}\\n        }\\n        unchecked { // Entertainment\\n            uint256 min = (counterGenHi >> 176) & 0xffff;\\n            uint256 v   = (counterGenLow >> 176) & 0xffff; if (v < min) {min = v;}\\n            v           = (counterGenHi >> 160) & 0xffff; if (v < min) {min = v;}\\n            if (min > 0) {totalBoost += 600 * _getSpreadedBoost(hoodSizeCorrection, min);}\\n        }\\n        unchecked { // Transport\\n            uint256 min = (counterGenLow >> 160) & 0xffff;\\n            uint256 v   = (counterGenHi >> 144) & 0xffff; if (v < min) {min = v;}\\n            v           = (counterGenLow >> 144) & 0xffff; if (v < min) {min = v;}\\n            if (min > 0) {totalBoost += 500 * _getSpreadedBoost(hoodSizeCorrection, min);}\\n        }\\n        unchecked { // Sports\\n            uint256 min = (counterGenHi >> 128) & 0xffff;\\n            uint256 v   = (counterGenLow >> 128) & 0xffff; if (v < min) {min = v;}\\n            v           = (counterGenHi >> 112) & 0xffff; if (v < min) {min = v;}\\n            if (min > 0) {totalBoost += 1000 * _getSpreadedBoost(hoodSizeCorrection, min);}\\n        }\\n        unchecked { // Energy\\n            uint256 min = (counterGenLow >> 112) & 0xffff;\\n            uint256 v   = (counterGenHi >> 96) & 0xffff; if (v < min) {min = v;}\\n            v           = (counterGenLow >> 96) & 0xffff; if (v < min) {min = v;}\\n            if (min > 0) {totalBoost += 800 * _getSpreadedBoost(hoodSizeCorrection, min);}\\n        }\\n        unchecked { // Cultural\\n            uint256 min = (counterGenHi >> 80) & 0xffff;\\n            uint256 v   = (counterGenLow >> 80) & 0xffff; if (v < min) {min = v;}\\n            v           = (counterGenHi >> 64) & 0xffff; if (v < min) {min = v;}\\n            if (min > 0) {totalBoost += 500 * _getSpreadedBoost(hoodSizeCorrection, min);}\\n        }\\n        unchecked { // Mansion\\n            uint256 min = (counterGenLow >> 64) & 0xffff;\\n            uint256 v   = (counterGenHi >> 48) & 0xffff; if (v < min) {min = v;}\\n            v           = (counterGenLow >> 48) & 0xffff; if (v < min) {min = v;}\\n            if (min > 0) {totalBoost += 600 * _getSpreadedBoost(hoodSizeCorrection, min);}\\n        }\\n        unchecked { // Tech\\n            uint256 min = (counterGenHi >> 32) & 0xffff;\\n            uint256 v   = (counterGenLow >> 32) & 0xffff; if (v < min) {min = v;}\\n            v           = (counterGenHi >> 16) & 0xffff; if (v < min) {min = v;}\\n            if (min > 0) {totalBoost += 800 * _getSpreadedBoost(hoodSizeCorrection, min);}\\n        }\\n        unchecked { // Odds\\n            uint256 min = (counterGenLow >> 16) & 0xffff;\\n            uint256 v   = (counterGenHi) & 0xffff; if (v < min) {min = v;}\\n            v           = (counterGenLow) & 0xffff; if (v < min) {min = v;}\\n            if (min > 0) {totalBoost += 600 * _getSpreadedBoost(hoodSizeCorrection, min);}\\n        }\\n        unchecked { // Partner\\n            uint256 min = (counterBoLo >> 16) & 0xffff;\\n            uint256 v   = (counterBoHi) & 0xffff; if (v < min) {min = v;}\\n            v           = (counterBoLo) & 0xffff; if (v < min) {min = v;}\\n            if (min > 0) {totalBoost += 800 * _getSpreadedBoost(hoodSizeCorrection, min);}\\n        }\\n\\n        // 10000 equals to 1, to be divided by 10000 in vault contract\\n        // return 10100 to give boost of 1%\\n        unchecked {\\n            return 10000 + totalBoost / 1000 ;\\n        }\\n    }\\n\\n    function _getSpreadedBoost(uint256 hoodSizeCorrection, uint256 stackedBoost) internal pure returns (uint256) {\\n        // One boost has a limited scope, it works onlt for MAX_HOOD_SIZE items.\\n        // If hood is bigger there should be proportionally more boosts.\\n        // Add 1000 to keep precision.\\n        uint256 spreadedBoost = stackedBoost * hoodSizeCorrection;\\n\\n        // If there are too many boosts of one category we don't multiply them uncontrollably, \\n        // Instead, we implement diminishing returns\\n        if (spreadedBoost >= 3000) {\\n            spreadedBoost = 1750;\\n        } else if (spreadedBoost >= 2000) {\\n            spreadedBoost = 1500 + (spreadedBoost - 2000) / 4;\\n        } else if (spreadedBoost > 1000) {\\n            spreadedBoost = 1000 + (spreadedBoost - 1000) / 2;\\n        }\\n\\n        return spreadedBoost;\\n    }\\n\\n    function getBlockInfo(uint256 tokenId) public view returns (uint256) {\\n        unchecked {\\n            require(tokenId > BLOCK_ID_OFFSET, \\\"Invalid tokenId\\\");\\n            tokenId -= BLOCK_ID_OFFSET + 1;\\n\\n            uint contractIndex = tokenId / BOOSTS_DATA_SIZE; // index of contract holding token data\\n            if (contractIndex >= blockDataAddresses.length) {\\n                return 0;\\n            }\\n\\n            address contractAddress = blockDataAddresses[contractIndex];\\n            uint indexInContract = tokenId % BOOSTS_DATA_SIZE;  // index of token data inside contract bytecode\\n            uint256 mem;\\n            assembly {\\n                let data := mload(0x40) // load the free memory pointer for temporarily storing the data\\n                // read a 32 byte word at offset from the runtime code at contractAddress  and put it into the memory location at data, \\n                // 32 bytes are added to the offset because that is to skip the 32 STOP opcodes at the start of the runtime code\\n                extcodecopy(contractAddress, data, add(shl(2, and(indexInContract, not(7))), 32), 32)\\n                mem := mload(data) // load the memory into the solidity variable\\n            }\\n\\n            return (mem >> (indexInContract & 7)) & 0x01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01_01;\\n        }\\n    }\\n\\n    function getBlockScore(uint256 tokenId) external view override returns (uint256 score) {\\n        unchecked {\\n            require(tokenId > BLOCK_ID_OFFSET, \\\"Invalid tokenId\\\");\\n            tokenId -= BLOCK_ID_OFFSET + 1;\\n\\n            uint contractIndex = tokenId / SCORES_DATA_SIZE; // index of contract holding token data\\n            if (contractIndex >= scoresAddresses.length) {\\n                return 0;\\n            }\\n\\n            address contractAddress = scoresAddresses[contractIndex];\\n            uint indexInContract = tokenId % SCORES_DATA_SIZE; // index of token data inside contract bytecode\\n            uint256 mem;\\n            assembly {\\n                let data := mload(0x40) // load the free memory pointer for temporarily storing the data\\n                // read a byte at offset from the runtime code at contractAddress  and put it into the memory location at data, \\n                // 32 bytes are added to the offset because that is to skip the 32 STOP opcodes at the start of the runtime code\\n                extcodecopy(contractAddress, data, add(indexInContract, 32), 32)\\n                mem := mload(data) // load the memory into the solidity variable\\n            }\\n\\n            return mem >> 248;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nfts/interfaces/IMetroBlockInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IMetroBlockScores.sol\\\";\\n\\ninterface IMetroBlockInfo is IMetroBlockScores {\\n    function getBlockInfo(uint256 tokenId) external view returns (uint256 info);\\n    function getHoodBoost(uint256[] calldata tokenIds) external view returns (uint256 score);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nfts/interfaces/IMetroBlockScores.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.4;\\n\\ninterface IMetroBlockScores {\\n\\n    function getBlockScore(uint256 tokenId) external view returns (uint256 score);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_scoresAddress\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_blockDataAddresses\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blockDataAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getBlockInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getBlockScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getHoodBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"element\",\"type\":\"address\"}],\"name\":\"pushBlockDataAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"element\",\"type\":\"address\"}],\"name\":\"pushScoreAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"scoresAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"element\",\"type\":\"address\"}],\"name\":\"setBlockDataAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_boostsTypes\",\"type\":\"uint256\"}],\"name\":\"setBoostsTypes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"element\",\"type\":\"address\"}],\"name\":\"setScoresAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MetroMiniBlockInfo", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000050000000000000000000000009a66348f3e216892cfd21d3bde2e79cbb90008420000000000000000000000001455b4f170656460c5d73c1b2725928044347a750000000000000000000000005010d67d3c4aae7d4880d9dd464cf8f2bf9ff9050000000000000000000000001be86947375bfd2165a859e9f8cdccf81b0b3a0e000000000000000000000000088eedec28ad35af40191a60ec8896487a3a5f21000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000abfb85867e0bbc44a9754c2b7fa16e1047565ea6000000000000000000000000b53e492ca6dac8a6740d448c22a27f2afecb1513000000000000000000000000c77537be426918e2132fa7fa9712eca5afd37d83000000000000000000000000eacb0364c279c43d5108db6d3a731e4c04d072d9000000000000000000000000062507968dc5c8725d0f0b7dfffb8daa15b079c9000000000000000000000000d273069632c911ea37505c49340efb5db0f9149d000000000000000000000000a65213fe909dae924dc429dacfe62adf9d67f19d00000000000000000000000010c0322e33e74dd70bdfef39ddd5a7636e2b51700000000000000000000000003283dbbe4daea919892c74a59b43c1fd1e9b75c2000000000000000000000000a85ced91c85ef37810e6a23dfd5bffdd868447d6", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}