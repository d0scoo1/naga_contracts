{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/VestingModuleFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.13;\\n\\nimport {VestingModule} from \\\"./VestingModule.sol\\\";\\nimport {ClonesWithImmutableArgs} from \\\"clones-with-immutable-args/ClonesWithImmutableArgs.sol\\\";\\n\\n///\\n/// @title VestingModuleFactory\\n/// @author 0xSplits <will@0xSplits.xyz>\\n/// @notice  A factory contract for cheaply deploying VestingModules.\\n/// @dev This factory uses our own extension of clones-with-immutable-args to avoid\\n/// `DELEGATECALL` inside `receive()` to accept hard gas-capped `sends` & `transfers`\\n/// for maximum backwards composability.\\n///\\ncontract VestingModuleFactory {\\n    /// -----------------------------------------------------------------------\\n    /// errors\\n    /// -----------------------------------------------------------------------\\n\\n    error InvalidBeneficiary();\\n    error InvalidVestingPeriod();\\n\\n    /// -----------------------------------------------------------------------\\n    /// libraries\\n    /// -----------------------------------------------------------------------\\n\\n    using ClonesWithImmutableArgs for address;\\n\\n    /// -----------------------------------------------------------------------\\n    /// events\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice New vesting integration contract deployed\\n    /// @param vestingModule Address of newly created VestingModule clone\\n    /// @param beneficiary Address to receive funds after vesting\\n    /// @param vestingPeriod Period of time for funds to vest\\n    event CreateVestingModule(\\n        address indexed vestingModule,\\n        address indexed beneficiary,\\n        uint256 vestingPeriod\\n    );\\n\\n    /// -----------------------------------------------------------------------\\n    /// storage\\n    /// -----------------------------------------------------------------------\\n\\n    VestingModule public implementation;\\n\\n    /// -----------------------------------------------------------------------\\n    /// constructor\\n    /// -----------------------------------------------------------------------\\n\\n    constructor() {\\n        implementation = new VestingModule();\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// functions\\n    /// -----------------------------------------------------------------------\\n\\n    /// -----------------------------------------------------------------------\\n    /// functions - public & external\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Creates new vesting module\\n    /// @param beneficiary Address to receive funds after vesting\\n    /// @param vestingPeriod Period of time for funds to vest\\n    /// @return vm Address of new vesting module\\n    function createVestingModule(address beneficiary, uint256 vestingPeriod)\\n        external\\n        returns (VestingModule vm)\\n    {\\n        /// checks\\n        if (beneficiary == address(0)) revert InvalidBeneficiary();\\n        if (vestingPeriod == 0) revert InvalidVestingPeriod();\\n\\n        /// effects\\n        bytes memory data = abi.encodePacked(beneficiary, vestingPeriod);\\n        vm = VestingModule(\\n            address(implementation).cloneDeterministic(\\n                bytes32(bytes20(beneficiary)),\\n                data\\n            )\\n        );\\n        emit CreateVestingModule(address(vm), beneficiary, vestingPeriod);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// functions - views\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Predicts address of vesting module & returns whether it already exists\\n    /// @dev Will return (address(0), false) instead of reverting on invalid inputs\\n    /// @param beneficiary Address to receive funds after vesting\\n    /// @param vestingPeriod Period of time for funds to vest\\n    /// @return predictedAddress Predicted address of new vesting module\\n    /// @return exists Whether a vesting module already exists at {predictedAddress}\\n    function predictVestingModuleAddress(\\n        address beneficiary,\\n        uint256 vestingPeriod\\n    ) external view returns (address predictedAddress, bool exists) {\\n        // TODO: decide if view should revert; leaning toward no\\n        /// checks\\n        /* if (beneficiary == address(0)) revert InvalidBeneficiary(); */\\n        /* if (vestingPeriod == 0) revert InvalidVestingPeriod(); */\\n        if (beneficiary == address(0) || vestingPeriod == 0)\\n            return (address(0), false);\\n\\n        bytes memory data = abi.encodePacked(beneficiary, vestingPeriod);\\n        (predictedAddress, exists) = address(implementation)\\n            .predictDeterministicAddress(bytes32(bytes20(beneficiary)), data);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/VestingModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.13;\\n\\nimport {Clone} from \\\"clones-with-immutable-args/Clone.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {FullMath} from \\\"./lib/FullMath.sol\\\";\\n\\n///\\n/// @title VestingModule\\n/// @author 0xSplits <will@0xSplits.xyz>\\n/// @notice A maximally-composable vesting contract allowing multiple isolated\\n/// streams of different tokens to reach a beneficiary over time. Streams share\\n/// a vesting period but may begin or have funds released independently.\\n/// @dev Funds pile up in the contract via `receive()` & simple ERC20 `transfer`\\n/// until a caller creates a new vesting stream. The funds then vest linearly\\n/// over {vestingPeriod} and may be withdrawn accordingly by anyone on behalf\\n/// of the {beneficiary}. There is no limit on the number of simultaneous\\n/// vesting streams which may be created, ongoing or withdrawn from in a single\\n/// tx.\\n/// This contract uses address(0) in some fns/events/mappings to refer to ETH.\\n///\\ncontract VestingModule is Clone {\\n    /// -----------------------------------------------------------------------\\n    /// errors\\n    /// -----------------------------------------------------------------------\\n\\n    error InvalidVestingStreamId(uint256 id);\\n\\n    /// -----------------------------------------------------------------------\\n    /// libraries\\n    /// -----------------------------------------------------------------------\\n\\n    using SafeTransferLib for address;\\n    using SafeTransferLib for ERC20;\\n\\n    /// -----------------------------------------------------------------------\\n    /// events\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice New vesting stream created\\n    /// @param id Id of vesting stream\\n    /// @param token Address of token to vest (0x0 for ETH)\\n    /// @param amount Amount to vest\\n    event CreateVestingStream(\\n        uint256 indexed id,\\n        address indexed token,\\n        uint256 amount\\n    );\\n\\n    /// @notice Release from vesting stream\\n    /// @param id Id of vesting stream\\n    /// @param amount Amount released from stream\\n    event ReleaseFromVestingStream(uint256 indexed id, uint256 amount);\\n\\n    /// @notice Emitted after each successful ETH transfer to proxy\\n    /// @param amount Amount of ETH received\\n    event ReceiveETH(uint256 amount);\\n\\n    /// -----------------------------------------------------------------------\\n    /// structs\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice holds vesting stream metadata\\n    struct VestingStream {\\n        address token;\\n        uint256 vestingStart;\\n        uint256 total;\\n        uint256 released;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// storage\\n    /// -----------------------------------------------------------------------\\n\\n    /// Address to receive funds after vesting\\n    /// @dev equivalent to address public immutable beneficiary;\\n    function beneficiary() public pure returns (address) {\\n        return _getArgAddress(0);\\n    }\\n\\n    /// Period of time for funds to vest (defaults to 365 days)\\n    /// @dev equivalent to uint256 public immutable vestingPeriod;\\n    function vestingPeriod() public pure returns (uint256) {\\n        return _getArgUint256(20);\\n    }\\n\\n    /// Number of vesting streams\\n    /// @dev Used for sequential ids\\n    uint256 public numVestingStreams;\\n\\n    /// Mapping from Id to vesting stream\\n    mapping(uint256 => VestingStream) internal vestingStreams;\\n    /// Mapping from token to amount vesting (includes current & previous)\\n    mapping(address => uint256) public vesting;\\n    /// Mapping from token to amount released\\n    mapping(address => uint256) public released;\\n\\n    /// -----------------------------------------------------------------------\\n    /// constructor\\n    /// -----------------------------------------------------------------------\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor() {}\\n\\n    /// -----------------------------------------------------------------------\\n    /// functions\\n    /// -----------------------------------------------------------------------\\n\\n    /// -----------------------------------------------------------------------\\n    /// functions - public & external\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice receive ETH\\n    /// @dev receive with emitted event is implemented w/i clone bytecode\\n    /* receive() external payable { */\\n    /*     emit ReceiveETH(msg.value); */\\n    /* } */\\n\\n    /// @notice Creates new vesting streams\\n    /// @param tokens Addresses of ETH (0x0) & ERC20s to begin vesting\\n    /// @return ids Ids of created vesting streams for {tokens}\\n    function createVestingStreams(address[] calldata tokens)\\n        external\\n        payable\\n        returns (uint256[] memory ids)\\n    {\\n        uint256 numTokens = tokens.length;\\n        ids = new uint256[](numTokens);\\n        // use count as first new sequential id\\n        uint256 vestingStreamId = numVestingStreams;\\n\\n        unchecked {\\n            // overflow should be impossible in for-loop index\\n            for (uint256 i = 0; i < numTokens; ++i) {\\n                address token = tokens[i];\\n                // overflow should be impossible\\n                // shouldn't need to worry about re-entrancy from ERC20 view fn\\n                // recognizes 0x0 as ETH\\n                // user chooses tokens array, pernicious ERC20 can't cause DoS\\n                // slither-disable-next-line calls-loop\\n                uint256 pendingAmount = (\\n                    token != address(0)\\n                        ? ERC20(token).balanceOf(address(this))\\n                        : address(this).balance\\n                    // vesting >= released\\n                ) - (vesting[token] - released[token]);\\n                vesting[token] += pendingAmount;\\n                // overflow should be impossible\\n                vestingStreams[vestingStreamId] = VestingStream({\\n                    token: token,\\n                    vestingStart: block.timestamp, // solhint-disable-line not-rely-on-time\\n                    total: pendingAmount,\\n                    released: 0\\n                });\\n                emit CreateVestingStream(vestingStreamId, token, pendingAmount);\\n                ids[i] = vestingStreamId;\\n                ++vestingStreamId;\\n            }\\n            // use last created id as new count\\n            numVestingStreams = vestingStreamId;\\n        }\\n    }\\n\\n    /// @notice Releases vested funds to the beneficiary\\n    /// @param ids Ids of vesting streams to release funds from\\n    /// @return releasedFunds Amounts of funds released from vesting streams {ids}\\n    function releaseFromVesting(uint256[] calldata ids)\\n        external\\n        payable\\n        returns (uint256[] memory releasedFunds)\\n    {\\n        uint256 numIds = ids.length;\\n        releasedFunds = new uint256[](numIds);\\n\\n        unchecked {\\n            // overflow should be impossible in for-loop index\\n            for (uint256 i = 0; i < numIds; ++i) {\\n                uint256 id = ids[i];\\n                if (id >= numVestingStreams) revert InvalidVestingStreamId(id);\\n                VestingStream memory vs = vestingStreams[id];\\n                uint256 transferAmount = _vestedAndUnreleased(vs);\\n                address token = vs.token;\\n                // overflow should be impossible\\n                vestingStreams[id].released += transferAmount;\\n                // overflow should be impossible\\n                released[token] += transferAmount;\\n                // don't need to worry about re-entrancy; funds can't be stolen from beneficiary\\n                // pernicious ERC20s would only mess their own storage, not brick the balance of any ERC20 or ETH\\n                if (token != address(0)) {\\n                    ERC20(token).safeTransfer(beneficiary(), transferAmount);\\n                } else {\\n                    beneficiary().safeTransferETH(transferAmount);\\n                }\\n\\n                emit ReleaseFromVestingStream(id, transferAmount);\\n                releasedFunds[i] = transferAmount;\\n            }\\n        }\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// functions - views\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice View vesting stream {id}\\n    /// @param id Id of vesting stream to view\\n    /// @return vs Vesting stream\\n    function vestingStream(uint256 id)\\n        external\\n        view\\n        returns (VestingStream memory vs)\\n    {\\n        vs = vestingStreams[id];\\n    }\\n\\n    /// @notice View vested amount in vesting stream {id}\\n    /// @param id Id of vesting stream to get vested amount of\\n    /// @return Amount vested in vesting stream {id}\\n    function vested(uint256 id) external view returns (uint256) {\\n        VestingStream memory vs = vestingStreams[id];\\n        return _vested(vs);\\n    }\\n\\n    /// @notice View vested-and-unreleased amount in vesting stream {id}\\n    /// @param id Id of vesting stream to get vested-and-unreleased amount of\\n    /// @return Amount vested-and-unreleased in vesting stream {id}\\n    function vestedAndUnreleased(uint256 id) external view returns (uint256) {\\n        VestingStream memory vs = vestingStreams[id];\\n        return _vestedAndUnreleased(vs);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// functions - private & internal\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice View vested amount in vesting stream {vs}\\n    /// @param vs Vesting stream to get vested amount of\\n    /// @return Amount vested in vesting stream {vs}\\n    function _vested(VestingStream memory vs) internal view returns (uint256) {\\n        uint256 elapsedTime;\\n        unchecked {\\n            // block.timestamp >= vs.vestingStart for any existing stream\\n            // solhint-disable-next-line not-rely-on-time\\n            elapsedTime = block.timestamp - vs.vestingStart;\\n        }\\n        return\\n            elapsedTime >= vestingPeriod()\\n                ? vs.total\\n                : FullMath.mulDiv(vs.total, elapsedTime, vestingPeriod());\\n    }\\n\\n    /// @notice View vested-and-unreleased amount in vesting stream {vs}\\n    /// @param vs Vesting stream to get vested-and-unreleased amount of\\n    /// @return Amount vested-and-unreleased in vesting stream {vs}\\n    function _vestedAndUnreleased(VestingStream memory vs)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        unchecked {\\n            // underflow should be impossible\\n            return _vested(vs) - vs.released;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD\\n\\npragma solidity ^0.8.4;\\n\\n/// @title ClonesWithImmutableArgs\\n/// @author wighawag, zefram.eth\\n/// @notice Enables creating clone contracts with immutable args\\n/// @dev extended by will@0xsplits.xyz to add receive() without DELEGECALL & create2 support\\n/// (h/t WyseNynja https://github.com/wighawag/clones-with-immutable-args/issues/4)\\nlibrary ClonesWithImmutableArgs {\\n    error CreateFail();\\n\\n    /// @notice Creates a clone proxy of the implementation contract with immutable args\\n    /// @dev data cannot exceed 65535 bytes, since 2 bytes are used to store the data length\\n    /// @param implementation The implementation contract to clone\\n    /// @param data Encoded immutable args\\n    /// @return ptr The ptr to the clone's bytecode\\n    /// @return creationSize The size of the clone to be created\\n    function cloneCreationCode(address implementation, bytes memory data)\\n        internal\\n        pure\\n        returns (uint256 ptr, uint256 creationSize)\\n    {\\n        // unrealistic for memory ptr or data length to exceed 256 bits\\n        unchecked {\\n            uint256 extraLength = data.length + 2; // +2 bytes for telling how much data there is appended to the call\\n            creationSize = 0x71 + extraLength;\\n            uint256 runSize = creationSize - 10;\\n            uint256 dataPtr;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                ptr := mload(0x40)\\n\\n                // -------------------------------------------------------------------------------------------------------------\\n                // CREATION (10 bytes)\\n                // -------------------------------------------------------------------------------------------------------------\\n\\n                // 61 runtime  | PUSH2 runtime (r)     | r                       | \u2013\\n                mstore(\\n                    ptr,\\n                    0x6100000000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x01), shl(240, runSize)) // size of the contract running bytecode (16 bits)\\n\\n                // creation size = 0a\\n                // 3d          | RETURNDATASIZE        | 0 r                     | \u2013\\n                // 81          | DUP2                  | r 0 r                   | \u2013\\n                // 60 creation | PUSH1 creation (c)    | c r 0 r                 | \u2013\\n                // 3d          | RETURNDATASIZE        | 0 c r 0 r               | \u2013\\n                // 39          | CODECOPY              | 0 r                     | [0-runSize): runtime code\\n                // f3          | RETURN                |                         | [0-runSize): runtime code\\n\\n                // -------------------------------------------------------------------------------------------------------------\\n                // RUNTIME (103 bytes + extraLength)\\n                // -------------------------------------------------------------------------------------------------------------\\n\\n                //     0x000     36       calldatasize      cds                  | -\\n                //     0x001     602f     push1 0x2f        0x2f cds             | -\\n                // ,=< 0x003     57       jumpi                                  | -\\n                // |   0x004     34       callvalue         cv                   | -\\n                // |   0x005     3d       returndatasize    0 cv                 | -\\n                // |   0x006     52       mstore                                 | [0, 0x20) = cv\\n                // |   0x007     7f245c.. push32 0x245c..   id                   | [0, 0x20) = cv\\n                // |   0x028     6020     push1 0x20        0x20 id              | [0, 0x20) = cv\\n                // |   0x02a     3d       returndatasize    0 0x20 id            | [0, 0x20) = cv\\n                // |   0x02b     a1       log1                                   | [0, 0x20) = cv\\n                // |   0x02c     3d       returndatasize    0                    | [0, 0x20) = cv\\n                // |   0x02d     3d       returndatasize    0 0                  | [0, 0x20) = cv\\n                // |   0x02e     f3       return\\n                // `-> 0x02f     5b       jumpdest\\n\\n                // 3d          | RETURNDATASIZE        | 0                       | \u2013\\n                // 3d          | RETURNDATASIZE        | 0 0                     | \u2013\\n                // 3d          | RETURNDATASIZE        | 0 0 0                   | \u2013\\n                // 3d          | RETURNDATASIZE        | 0 0 0 0                 | \u2013\\n                // 36          | CALLDATASIZE          | cds 0 0 0 0             | \u2013\\n                // 3d          | RETURNDATASIZE        | 0 cds 0 0 0 0           | \u2013\\n                // 3d          | RETURNDATASIZE        | 0 0 cds 0 0 0 0         | \u2013\\n                // 37          | CALLDATACOPY          | 0 0 0 0                 | [0, cds) = calldata\\n                // 61          | PUSH2 extra           | extra 0 0 0 0           | [0, cds) = calldata\\n                mstore(\\n                    add(ptr, 0x03),\\n                    0x3d81600a3d39f336602f57343d527f0000000000000000000000000000000000\\n                )\\n                mstore(\\n                    add(ptr, 0x12),\\n                    // = keccak256(\\\"ReceiveETH(uint256)\\\")\\n                    0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n                )\\n                mstore(\\n                    add(ptr, 0x32),\\n                    0x60203da13d3df35b3d3d3d3d363d3d3761000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x43), shl(240, extraLength))\\n\\n                // 60 0x67     | PUSH1 0x67            | 0x67 extra 0 0 0 0      | [0, cds) = calldata // 0x67 (103) is runtime size - data\\n                // 36          | CALLDATASIZE          | cds 0x67 extra 0 0 0 0  | [0, cds) = calldata\\n                // 39          | CODECOPY              | 0 0 0 0                 | [0, cds) = calldata, [cds, cds+0x37) = extraData\\n                // 36          | CALLDATASIZE          | cds 0 0 0 0             | [0, cds) = calldata, [cds, cds+0x37) = extraData\\n                // 61 extra    | PUSH2 extra           | extra cds 0 0 0 0       | [0, cds) = calldata, [cds, cds+0x37) = extraData\\n                mstore(\\n                    add(ptr, 0x45),\\n                    0x6067363936610000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x4b), shl(240, extraLength))\\n\\n                // 01          | ADD                   | cds+extra 0 0 0 0       | [0, cds) = calldata, [cds, cds+0x37) = extraData\\n                // 3d          | RETURNDATASIZE        | 0 cds 0 0 0 0           | [0, cds) = calldata, [cds, cds+0x37) = extraData\\n                // 73 addr     | PUSH20 0x123\u2026         | addr 0 cds 0 0 0 0      | [0, cds) = calldata, [cds, cds+0x37) = extraData\\n                mstore(\\n                    add(ptr, 0x4d),\\n                    0x013d730000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x50), shl(0x60, implementation))\\n\\n                // 5a          | GAS                   | gas addr 0 cds 0 0 0 0  | [0, cds) = calldata, [cds, cds+0x37) = extraData\\n                // f4          | DELEGATECALL          | success 0 0             | [0, cds) = calldata, [cds, cds+0x37) = extraData\\n                // 3d          | RETURNDATASIZE        | rds success 0 0         | [0, cds) = calldata, [cds, cds+0x37) = extraData\\n                // 3d          | RETURNDATASIZE        | rds rds success 0 0     | [0, cds) = calldata, [cds, cds+0x37) = extraData\\n                // 93          | SWAP4                 | 0 rds success 0 rds     | [0, cds) = calldata, [cds, cds+0x37) = extraData\\n                // 80          | DUP1                  | 0 0 rds success 0 rds   | [0, cds) = calldata, [cds, cds+0x37) = extraData\\n                // 3e          | RETURNDATACOPY        | success 0 rds           | [0, rds) = return data (there might be some irrelevant leftovers in memory [rds, cds+0x37) when rds < cds+0x37)\\n                // 60 0x65     | PUSH1 0x65            | 0x65 sucess 0 rds       | [0, rds) = return data\\n                // 57          | JUMPI                 | 0 rds                   | [0, rds) = return data\\n                // fd          | REVERT                | \u2013                       | [0, rds) = return data\\n                // 5b          | JUMPDEST              | 0 rds                   | [0, rds) = return data\\n                // f3          | RETURN                | \u2013                       | [0, rds) = return data\\n                mstore(\\n                    add(ptr, 0x64),\\n                    0x5af43d3d93803e606557fd5bf300000000000000000000000000000000000000\\n                )\\n            }\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // APPENDED DATA (Accessible from extcodecopy)\\n            // (but also send as appended data to the delegatecall)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            extraLength -= 2;\\n            uint256 counter = extraLength;\\n            uint256 copyPtr = ptr + 0x71;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                dataPtr := add(data, 32)\\n            }\\n            for (; counter >= 32; counter -= 32) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    mstore(copyPtr, mload(dataPtr))\\n                }\\n\\n                copyPtr += 32;\\n                dataPtr += 32;\\n            }\\n            uint256 mask = ~(256**(32 - counter) - 1);\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                mstore(copyPtr, and(mload(dataPtr), mask))\\n            }\\n            copyPtr += counter;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                mstore(copyPtr, shl(240, extraLength))\\n            }\\n        }\\n    }\\n\\n    /// @notice Creates a clone proxy of the implementation contract with immutable args\\n    /// @dev data cannot exceed 65535 bytes, since 2 bytes are used to store the data length\\n    /// @param implementation The implementation contract to clone\\n    /// @param data Encoded immutable args\\n    /// @return instance The address of the created clone\\n    function clone(address implementation, bytes memory data)\\n        internal\\n        returns (address payable instance)\\n    {\\n        (uint256 creationPtr, uint256 creationSize) = cloneCreationCode(\\n            implementation,\\n            data\\n        );\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            instance := create(0, creationPtr, creationSize)\\n        }\\n\\n        // if the create failed, the instance address won't be set\\n        if (instance == address(0)) {\\n            revert CreateFail();\\n        }\\n    }\\n\\n    /// @notice Creates a clone proxy of the implementation contract with immutable args\\n    /// @dev data cannot exceed 65535 bytes, since 2 bytes are used to store the data length\\n    /// @param implementation The implementation contract to clone\\n    /// @param salt The salt for create2\\n    /// @param data Encoded immutable args\\n    /// @return instance The address of the created clone\\n    function cloneDeterministic(\\n        address implementation,\\n        bytes32 salt,\\n        bytes memory data\\n    ) internal returns (address payable instance) {\\n        (uint256 creationPtr, uint256 creationSize) = cloneCreationCode(\\n            implementation,\\n            data\\n        );\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            instance := create2(0, creationPtr, creationSize, salt)\\n        }\\n\\n        // if the create failed, the instance address won't be set\\n        if (instance == address(0)) {\\n            revert CreateFail();\\n        }\\n    }\\n\\n    /// @notice Predicts the address where a deterministic clone of implementation will be deployed\\n    /// @dev data cannot exceed 65535 bytes, since 2 bytes are used to store the data length\\n    /// @param implementation The implementation contract to clone\\n    /// @param salt The salt for create2\\n    /// @param data Encoded immutable args\\n    /// @return predicted The predicted address of the created clone\\n    /// @return exists Whether the clone already exists\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        bytes memory data\\n    ) internal view returns (address predicted, bool exists) {\\n        (uint256 creationPtr, uint256 creationSize) = cloneCreationCode(\\n            implementation,\\n            data\\n        );\\n\\n        bytes32 creationHash;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            creationHash := keccak256(creationPtr, creationSize)\\n        }\\n\\n        predicted = computeAddress(salt, creationHash, address(this));\\n        exists = predicted.code.length > 0;\\n    }\\n\\n    /// @dev Returns the address where a contract will be stored if deployed via CREATE2 from a contract located at `deployer`.\\n    function computeAddress(\\n        bytes32 salt,\\n        bytes32 bytecodeHash,\\n        address deployer\\n    ) internal pure returns (address) {\\n        bytes32 _data = keccak256(\\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\\n        );\\n        return address(uint160(uint256(_data)));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/clones-with-immutable-args/src/Clone.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD\\npragma solidity ^0.8.4;\\n\\n/// @title Clone\\n/// @author zefram.eth\\n/// @notice Provides helper functions for reading immutable args from calldata\\ncontract Clone {\\n    /// @notice Reads an immutable arg with type address\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgAddress(uint256 argOffset)\\n        internal\\n        pure\\n        returns (address arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := shr(0x60, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint256\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint256(uint256 argOffset)\\n        internal\\n        pure\\n        returns (uint256 arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := calldataload(add(offset, argOffset))\\n        }\\n    }\\n\\n    /// @notice Reads a uint256 array stored in the immutable args.\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @param arrLen Number of elements in the array\\n    /// @return arr The array\\n    function _getArgUint256Array(uint256 argOffset, uint64 arrLen)\\n        internal\\n        pure\\n        returns (uint256[] memory arr)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        uint256 el;\\n        arr = new uint256[](arrLen);\\n        for (uint64 i = 0; i < arrLen; i++) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                el := calldataload(add(add(offset, argOffset), mul(i, 32)))\\n            }\\n            arr[i] = el;\\n        }\\n        return arr;\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint64\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint64(uint256 argOffset)\\n        internal\\n        pure\\n        returns (uint64 arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := shr(0xc0, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint8\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := shr(0xf8, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @return offset The offset of the packed immutable args in calldata\\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            offset := sub(\\n                calldatasize(),\\n                add(shr(240, calldataload(sub(calldatasize(), 2))), 2)\\n            )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    event Debug(bool one, bool two, uint256 retsize);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\n/// from https://github.com/ZeframLou/vested-erc20/blob/main/src/lib/FullMath.sol\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (type(uint256).max - denominator + 1) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        unchecked {\\n            if (mulmod(a, b, denominator) > 0) {\\n                require(result < type(uint256).max);\\n                result++;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"clones-with-immutable-args/=lib/clones-with-immutable-args/src/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"splits-contracts/=lib/splits-contracts/contracts/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\"\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CreateFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBeneficiary\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidVestingPeriod\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vestingModule\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestingPeriod\",\"type\":\"uint256\"}],\"name\":\"CreateVestingModule\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vestingPeriod\",\"type\":\"uint256\"}],\"name\":\"createVestingModule\",\"outputs\":[{\"internalType\":\"contract VestingModule\",\"name\":\"vm\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"contract VestingModule\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vestingPeriod\",\"type\":\"uint256\"}],\"name\":\"predictVestingModuleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"predictedAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VestingModuleFactory", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x652a2a2876b855d9c30d9265f882f0a486608976", "SwarmSource": ""}]}