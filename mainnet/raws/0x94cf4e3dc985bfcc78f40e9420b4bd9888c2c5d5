{"status": "1", "message": "OK", "result": [{"SourceCode": "//SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ninterface IUniswapFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapRouter01 {\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getamountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getamountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getamountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getamountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapRouter02 is IUniswapRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\ninterface IUniswapV2Pair {\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n  function name() external pure returns (string memory);\r\n  function symbol() external pure returns (string memory);\r\n  function decimals() external pure returns (uint8);\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address owner) external view returns (uint);\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n\r\n  function approve(address spender, uint value) external returns (bool);\r\n  function transfer(address to, uint value) external returns (bool);\r\n  function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n  function nonces(address owner) external view returns (uint);\r\n\r\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n  event Mint(address indexed sender, uint amount0, uint amount1);\r\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n  event Swap(\r\n      address indexed sender,\r\n      uint amount0In,\r\n      uint amount1In,\r\n      uint amount0Out,\r\n      uint amount1Out,\r\n      address indexed to\r\n  );\r\n  event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n  function factory() external view returns (address);\r\n  function token0() external view returns (address);\r\n  function token1() external view returns (address);\r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n  function price0CumulativeLast() external view returns (uint);\r\n  function price1CumulativeLast() external view returns (uint);\r\n  function kLast() external view returns (uint);\r\n\r\n  function mint(address to) external returns (uint liquidity);\r\n  function burn(address to) external returns (uint amount0, uint amount1);\r\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n  function skim(address to) external;\r\n  function sync() external;\r\n}\r\n\r\ncontract smart {\r\n    address router_address = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    IUniswapRouter02 router = IUniswapRouter02(router_address);\r\n\r\n    function create_weth_pair(address token) private returns (address, IUniswapV2Pair) {\r\n       address pair_address = IUniswapFactory(router.factory()).createPair(token, router.WETH());\r\n       return (pair_address, IUniswapV2Pair(pair_address));\r\n    }\r\n\r\n    function get_weth_reserve(address pair_address) private  view returns(uint, uint) {\r\n        IUniswapV2Pair pair = IUniswapV2Pair(pair_address);\r\n        uint112 token_reserve;\r\n        uint112 native_reserve;\r\n        uint32 last_timestamp;\r\n        (token_reserve, native_reserve, last_timestamp) = pair.getReserves();\r\n        return (token_reserve, native_reserve);\r\n    }\r\n\r\n    function get_weth_price_impact(address token, uint amount, bool sell) private view returns(uint) {\r\n        address pair_address = IUniswapFactory(router.factory()).getPair(token, router.WETH());\r\n        (uint res_token, uint res_weth) = get_weth_reserve(pair_address);\r\n        uint impact;\r\n        if(sell) {\r\n            impact = (amount * 100) / res_token;\r\n        } else {\r\n            impact = (amount * 100) / res_weth;\r\n        }\r\n        return impact;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract protected {\r\n\r\n    mapping (address => bool) is_auth;\r\n\r\n    function authorized(address addy) public view returns(bool) {\r\n        return is_auth[addy];\r\n    }\r\n\r\n    function set_authorized(address addy, bool booly) public onlyAuth {\r\n        is_auth[addy] = booly;\r\n    }\r\n\r\n    modifier onlyAuth() {\r\n        require( is_auth[msg.sender] || msg.sender==owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    address owner;\r\n    modifier onlyOwner() {\r\n        require(msg.sender==owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    bool locked;\r\n    modifier safe() {\r\n        require(!locked, \"reentrant\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    receive() external payable {}\r\n    fallback() external payable {}\r\n}\r\n\r\ncontract squiggles is protected, smart {\r\n\r\n    struct PROPOSAL {\r\n        address proposer;\r\n        mapping(address => bool) voted;\r\n        bytes32 short_name;\r\n        uint side_1_votes;\r\n        bytes32 side_1_name;\r\n        bytes32 side_1_url;\r\n        uint side_2_votes;\r\n        bytes32 side_2_name;\r\n        bytes32 side_2_url;\r\n        bool is_active;\r\n        uint start_time;\r\n        uint end_time;\r\n        string description_url;\r\n    }\r\n\r\n    mapping(bytes32 => PROPOSAL) proposal;\r\n    bytes32[] proposals;\r\n    bytes32[] proposals_inactive;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        is_auth[owner] = true;\r\n    }\r\n\r\n    function propose(bytes32 name, bytes32 side_1, bytes32 side_2,\r\n                     bytes32 url_1, bytes32 url_2, string memory url_description) public safe {\r\n                         \r\n        proposal[name].proposer = msg.sender;\r\n        proposal[name].side_1_name = side_1;\r\n        proposal[name].side_2_name = side_2;\r\n        proposal[name].side_1_url = url_1;\r\n        proposal[name].side_2_url = url_2;\r\n        proposal[name].description_url = url_description;\r\n        proposals.push(name);\r\n    }\r\n\r\n    function start_propose(bytes32 name) public safe {\r\n        require(msg.sender == proposal[name].proposer || is_auth[msg.sender], \"403\");\r\n        proposal[name].is_active = true;        \r\n    }\r\n\r\n    function get_description(bytes32 name) public view returns(string memory description) {\r\n        return proposal[name].description_url;\r\n    }\r\n\r\n    function get_proposal(bytes32 name) public view returns (bytes32, uint256, bytes32,\r\n                                                        bytes32, uint, bytes32,\r\n                                                        address) {\r\n\r\n        return (\r\n            proposal[name].side_1_name,\r\n            proposal[name].side_1_votes,\r\n            proposal[name].side_1_url,\r\n            proposal[name].side_2_name,\r\n            proposal[name].side_2_votes,\r\n            proposal[name].side_2_url,\r\n            proposal[name].proposer\r\n        );\r\n\r\n    }\r\n\r\n    function end_proposal(bytes32 name) public onlyAuth {\r\n        proposal[name].is_active = false;\r\n        proposals_inactive.push(name);\r\n    }\r\n\r\n    function vote(bytes32 name, uint8 side) public {\r\n        require(!proposal[name].voted[msg.sender], \"Already voted\");\r\n        require(side==1 || side==2, \"Wrong side\");\r\n        proposal[name].voted[msg.sender] = true;\r\n        if(side==1) {\r\n            proposal[name].side_1_votes += 1;\r\n        } else {\r\n            proposal[name].side_2_votes += 1;\r\n        }\r\n    }\r\n\r\n    /******************** Views ********************/\r\n\r\n    function get_all_proposals() public view returns(bytes32[] memory, bytes32[] memory) {\r\n        return(proposals, proposals_inactive);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"end_proposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_all_proposals\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"get_description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"get_proposal\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"side_1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"side_2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"url_1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"url_2\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"url_description\",\"type\":\"string\"}],\"name\":\"propose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"set_authorized\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"start_propose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "squiggles", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://608bbd9b91e354f486dcdf392c9b3951033e3c9744f43e9df9968efed6baf2d5"}]}