{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.0;\r\n\r\ninterface ERC721 {\r\n  function safeTransferFrom(address from,address to,uint256 tokenId) external;\r\n}\r\n\r\ninterface ERC20 {\r\n  function transferFrom(address src, address dst, uint wad)\r\n        external\r\n        returns (bool);\r\n}\r\n\r\n\r\ncontract GolomTrader {\r\n  mapping(bytes32 => bool) public orderhashes; // keep tracks of orderhashes that are filled or cancelled so they cant be filled again \r\n  mapping(bytes32 => bool) public offerhashes; // keep tracks of offerhashes that are filled or cancelled so they cant be filled again \r\n  address payable owner;\r\n  ERC20 wethcontract;\r\n\r\n  mapping(address => uint256) public data; // keep tracks of orderhashes that are filled or cancelled so they cant be filled again \r\n  event Orderfilled(address indexed from,address indexed to, bytes32 indexed id, uint amt,address referrer,uint feeAmt,uint royaltyAmt,address royaltyAddress,address buyerAddress);\r\n  event Offerfilled(address indexed from,address indexed to, bytes32 indexed id, uint amt,uint feeAmt,uint royaltyAmt,address royaltyAddress,uint isany);\r\n  event Ordercancelled(bytes32 indexed id);\r\n  event Offercancelled(bytes32 indexed id);\r\n\r\n  constructor ()\r\n  {\r\n    owner = payable(msg.sender);\r\n    address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    wethcontract = ERC20(WETH);\r\n  }\r\n\r\n/// @notice returns eip712domainhash\r\n    function _eip712DomainHash() internal view returns(bytes32 eip712DomainHash) {\r\n        eip712DomainHash = keccak256(\r\n        abi.encode(\r\n            keccak256(\r\n                \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n            ),\r\n            keccak256(bytes(\"GOLOM.IO\")),\r\n            keccak256(bytes(\"1\")),\r\n            1,\r\n            address(this)\r\n        )\r\n    );  \r\n    }\r\n\r\n/// @notice order is a swap(erc721 -->eth) where maker is nft seller and taker is nft buyer\r\n/// @param v,r,s EIP712 type signature of signer/nft seller\r\n/// @param _addressArgs[5] address arguments array \r\n/// @param _uintArgs[6] uint arguments array\r\n/// @dev addressargs->//0 - tokenAddress,//1 - signer,//2 - royaltyaddress,//3 - reffereraddress // 4-buyerAddress\r\n/// @dev uintArgs->//0-tokenId ,//1-totalAmt,//2-deadline,//3-feeamt,//4-salt,//5-royaltyamt\r\n/// @dev totalAmt, totalAmt of ether in wei that the trade is done for , seller gets totalAmt-fees - royalty\r\n/// @dev deadline, deadline till order is valid\r\n/// @dev feeamt fee to be paid to owner of contract\r\n/// @dev signer seller of nft and signer of signature\r\n/// @dev salt salt for uniqueness of the order\r\n/// @dev refferer address that reffered the trade\r\n/// @dev buyerAddress address allowed to fill the order if (0) anyone can fill\r\n\r\n  function matchOrder(\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    address[5] calldata _addressArgs,\r\n    uint[6] calldata _uintArgs\r\n  ) external payable {\r\n    require(block.timestamp < _uintArgs[2], \"Signed transaction expired\");\r\n\r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchorder(uint tokenId,address tokenAddress,uint totalAmt,uint feeAmt,uint royaltyAmt,address royaltyAddress,address signer,address buyerAddress,uint deadline,uint salt)\"),\r\n          _uintArgs[0],\r\n          _addressArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[3],\r\n          _uintArgs[5],\r\n          _addressArgs[2],\r\n          _addressArgs[1],\r\n          _addressArgs[4],\r\n          _uintArgs[2],\r\n          _uintArgs[4]\r\n        )\r\n    );\r\n\r\n    bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", _eip712DomainHash(), hashStruct));\r\n    address signaturesigner = ecrecover(hash, v, r, s);\r\n    require(signaturesigner == _addressArgs[1], \"invalid signature\");\r\n    if (_addressArgs[4]!=address(0)){\r\n        require(msg.sender==_addressArgs[4],\"not fillable by this address\");\r\n    }\r\n    require(msg.value == _uintArgs[1], \"wrong eth amt\");\r\n    require(orderhashes[hashStruct]==false,\"order filled or cancelled\");\r\n    orderhashes[hashStruct]=true; // prevent reentrency and also doesnt allow any order to be filled more then once\r\n    ERC721 nftcontract = ERC721(_addressArgs[0]);\r\n    nftcontract.safeTransferFrom(_addressArgs[1],msg.sender ,_uintArgs[0]); // transfer \r\n\r\n    if (_uintArgs[3]>0){\r\n      owner.transfer(_uintArgs[3]); // fee transfer to owner\r\n    }\r\n\r\n    if (_uintArgs[5]>0){ // if royalty has to be paid\r\n     payable(_addressArgs[2]).transfer(_uintArgs[5]); // royalty transfer to royaltyaddress\r\n    }\r\n    payable(_addressArgs[1]).transfer(msg.value-_uintArgs[3]-_uintArgs[5]); // transfer of eth to seller of nft\r\n    emit Orderfilled(_addressArgs[1], msg.sender, hashStruct , _uintArgs[1] , _addressArgs[3] ,_uintArgs[3],_uintArgs[5],_addressArgs[2],_addressArgs[4]);\r\n  }\r\n\r\n/// @notice cancels order and make it unfillable\r\n  function cancelOrder(    \r\n    address[5] calldata _addressArgs,\r\n    uint[6] calldata _uintArgs\r\n) external{\r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchorder(uint tokenId,address tokenAddress,uint totalAmt,uint feeAmt,uint royaltyAmt,address royaltyAddress,address signer,address buyerAddress,uint deadline,uint salt)\"),\r\n          _uintArgs[0],\r\n          _addressArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[3],\r\n          _uintArgs[5],\r\n          _addressArgs[2],\r\n          _addressArgs[1],\r\n          _addressArgs[4],\r\n          _uintArgs[2],\r\n          _uintArgs[4]\r\n        )\r\n    );        \r\n      orderhashes[hashStruct]=true;  // no need to check for signature validation since sender can only invalidate his own order\r\n      emit Offercancelled(hashStruct);\r\n  }\r\n\r\n/// @notice offer is a swap(erc721 -->eth) where maker is nft buyer and taker is nft seller , called by seller of ERc721NFT when he sees a signed buy offer of ethamt ETH\r\n/// @param v,r,s EIP712 type signature of signer/nft buyer\r\n/// @param _addressArgs[3] address arguments array \r\n/// @param _uintArgs[7] uint arguments array\r\n/// @dev addressargs->//0 - tokenAddress,//1 - signer,//2 - royaltyaddress\r\n/// @dev uintArgs->//0-tokenId ,//1-ethamt,//2-deadline,//3-feeamt,//4-salt,//5-royaltyamt,//6-Isanytoken\r\n/// @dev Isanytoken , if this is 1 then any token of the tokenAddress collection can be used to fill this offer\r\n\r\n  function matchOffer(\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    address[3] calldata _addressArgs,\r\n    uint[7] calldata _uintArgs\r\n  ) external {\r\n    require(block.timestamp < _uintArgs[2], \"Signed transaction expired\");\r\n\r\n    bytes32 hashStruct;\r\n    if (_uintArgs[6]==1){\r\n        hashStruct = keccak256(\r\n        abi.encode(\r\n            keccak256(\"matchoffer(uint anyToken,address tokenAddress,uint totalAmt,uint feeAmt,address signer,uint deadline,uint salt)\"),\r\n            _uintArgs[6],\r\n            _addressArgs[0],\r\n            _uintArgs[1],\r\n            _uintArgs[3],\r\n            _addressArgs[1],\r\n            _uintArgs[2],\r\n            _uintArgs[4]\r\n            )\r\n        );\r\n    }else{\r\n        hashStruct = keccak256(\r\n        abi.encode(\r\n            keccak256(\"matchoffer(uint tokenId,address tokenAddress,uint totalAmt,uint feeAmt,address signer,uint deadline,uint salt)\"),\r\n            _uintArgs[0],\r\n            _addressArgs[0],\r\n            _uintArgs[1],\r\n            _uintArgs[3],\r\n            _addressArgs[1],\r\n            _uintArgs[2],\r\n            _uintArgs[4]\r\n            )\r\n        );\r\n\r\n    }\r\n\r\n    bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", _eip712DomainHash(), hashStruct));\r\n    address signaturesigner = ecrecover(hash, v, r, s);\r\n    require(signaturesigner == _addressArgs[1], \"invalid signature\");\r\n    require(offerhashes[hashStruct]==false,\"order filled or cancelled\");\r\n    offerhashes[hashStruct]=true;\r\n    if (_uintArgs[3]>0){\r\n      require(wethcontract.transferFrom(_addressArgs[1], owner , _uintArgs[3]),\"error in weth transfer\");\r\n    }\r\n    if (_uintArgs[5]>0){\r\n      require(wethcontract.transferFrom(_addressArgs[1], _addressArgs[2] , _uintArgs[5]),\"error in weth transfer\");\r\n    }\r\n\r\n    require(wethcontract.transferFrom(_addressArgs[1], msg.sender, _uintArgs[1]-_uintArgs[5]-_uintArgs[3]),\"error in weth transfer\");\r\n\r\n    ERC721 nftcontract = ERC721(_addressArgs[0]);\r\n    nftcontract.safeTransferFrom(msg.sender,_addressArgs[1] ,_uintArgs[0]);\r\n    emit Offerfilled(_addressArgs[1], msg.sender, hashStruct , _uintArgs[1] ,_uintArgs[3],_uintArgs[5],_addressArgs[2],0);\r\n  }\r\n\r\n\r\n/// @notice cancels order and make it unfillable\r\n  function cancelOffer(    \r\n    address[3] calldata _addressArgs,\r\n    uint[7] calldata _uintArgs\r\n) external{\r\n    bytes32 hashStruct;\r\n    if (_uintArgs[6]==1){\r\n        hashStruct = keccak256(\r\n        abi.encode(\r\n            keccak256(\"matchoffer(uint anyToken,address tokenAddress,uint totalAmt,uint feeAmt,address signer,uint deadline,uint salt)\"),\r\n            _uintArgs[6],\r\n            _addressArgs[0],\r\n            _uintArgs[1],\r\n            _uintArgs[3],\r\n            _addressArgs[1],\r\n            _uintArgs[2],\r\n            _uintArgs[4]\r\n            )\r\n        );\r\n    }else{\r\n        hashStruct = keccak256(\r\n        abi.encode(\r\n            keccak256(\"matchoffer(uint tokenId,address tokenAddress,uint totalAmt,uint feeAmt,address signer,uint deadline,uint salt)\"),\r\n            _uintArgs[0],\r\n            _addressArgs[0],\r\n            _uintArgs[1],\r\n            _uintArgs[3],\r\n            _addressArgs[1],\r\n            _uintArgs[2],\r\n            _uintArgs[4]\r\n            )\r\n        );\r\n    }\r\n      offerhashes[hashStruct]=true;  \r\n      emit Offercancelled(hashStruct);\r\n  }\r\n\r\n\r\n///@notice returns Keccak256 hash of an order\r\n  function orderHash(   \r\n    address[5] calldata _addressArgs,\r\n    uint[6] calldata _uintArgs\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchorder(uint tokenId,address tokenAddress,uint totalAmt,uint feeAmt,uint royaltyAmt,address royaltyAddress,address signer,address buyerAddress,uint deadline,uint salt)\"),\r\n          _uintArgs[0],\r\n          _addressArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[3],\r\n          _uintArgs[5],\r\n          _addressArgs[2],\r\n          _addressArgs[1],\r\n          _addressArgs[4],\r\n          _uintArgs[2],\r\n          _uintArgs[4]\r\n        )\r\n    );\r\n    }\r\n\r\n  function offerHash(   \r\n    address[3] memory _addressArgs,\r\n    uint[7] memory _uintArgs\r\n    ) public pure returns (bytes32) {\r\n\r\n    if (_uintArgs[6]==1){\r\n        return keccak256(\r\n        abi.encode(\r\n            keccak256(\"matchoffer(uint anyToken,address tokenAddress,uint totalAmt,uint feeAmt,address signer,uint deadline,uint salt)\"),\r\n            _uintArgs[6],\r\n            _addressArgs[0],\r\n            _uintArgs[1],\r\n            _uintArgs[3],\r\n            _addressArgs[1],\r\n            _uintArgs[2],\r\n            _uintArgs[4]\r\n            )\r\n        );\r\n    }else{\r\n        return keccak256(\r\n        abi.encode(\r\n            keccak256(\"matchoffer(uint tokenId,address tokenAddress,uint totalAmt,uint feeAmt,address signer,uint deadline,uint salt)\"),\r\n            _uintArgs[0],\r\n            _addressArgs[0],\r\n            _uintArgs[1],\r\n            _uintArgs[3],\r\n            _addressArgs[1],\r\n            _uintArgs[2],\r\n            _uintArgs[4]\r\n            )\r\n        );\r\n    }\r\n    }\r\n\r\n// ALREADY FILLED OR CANCELLED - 1\r\n// deadline PASSED- 2  EXPIRED\r\n// sign INVALID - 0\r\n// VALID - 3\r\n/// @notice returns status of an offer\r\n\r\n\r\n  function orderStatus(\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    address[5] calldata _addressArgs,\r\n    uint[6] calldata _uintArgs\r\n  ) public view returns (uint256) {\r\n    if (block.timestamp > _uintArgs[2]){\r\n      return 2;\r\n    }\r\n\r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchorder(uint tokenId,address tokenAddress,uint totalAmt,uint feeAmt,uint royaltyAmt,address royaltyAddress,address signer,address buyerAddress,uint deadline,uint salt)\"),\r\n          _uintArgs[0],\r\n          _addressArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[3],\r\n          _uintArgs[5],\r\n          _addressArgs[2],\r\n          _addressArgs[1],\r\n          _addressArgs[4],\r\n          _uintArgs[2],\r\n          _uintArgs[4]\r\n        )\r\n    );\r\n    bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", _eip712DomainHash(), hashStruct));\r\n    address signaturesigner = ecrecover(hash, v, r, s);\r\n\r\n    if (signaturesigner != _addressArgs[1]){\r\n      return 0;\r\n    }\r\n    if (orderhashes[hashStruct]==true){\r\n      return 1;\r\n    }\r\n\r\n    return 3;\r\n\r\n  }\r\n\r\n\r\n\r\n// ALREADY FILLED OR CANCELLED - 1\r\n// deadline PASSED- 2  EXPIRED\r\n// sign INVALID - 0\r\n// VALID - 3\r\n/// @notice returns status of an order\r\n\r\n  function offerStatus(\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    address[3] memory _addressArgs,\r\n    uint[7] memory _uintArgs\r\n  ) public view returns (uint256) {\r\n    if (block.timestamp > _uintArgs[2]){\r\n      return 2;\r\n    }\r\n\r\n    bytes32 hashStruct;\r\n    if (_uintArgs[6]==1){\r\n        hashStruct = keccak256(\r\n        abi.encode(\r\n            keccak256(\"matchoffer(uint anyToken,address tokenAddress,uint totalAmt,uint feeAmt,address signer,uint deadline,uint salt)\"),\r\n            _uintArgs[6],\r\n            _addressArgs[0],\r\n            _uintArgs[1],\r\n            _uintArgs[3],\r\n            _addressArgs[1],\r\n            _uintArgs[2],\r\n            _uintArgs[4]\r\n            )\r\n        );\r\n    }else{\r\n        \r\n        hashStruct = keccak256(\r\n        abi.encode(\r\n            keccak256(\"matchoffer(uint tokenId,address tokenAddress,uint totalAmt,uint feeAmt,address signer,uint deadline,uint salt)\"),\r\n            _uintArgs[0],\r\n            _addressArgs[0],\r\n            _uintArgs[1],\r\n            _uintArgs[3],\r\n            _addressArgs[1],\r\n            _uintArgs[2],\r\n            _uintArgs[4]\r\n            )\r\n        );\r\n    }\r\n\r\n    bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", _eip712DomainHash(), hashStruct));\r\n    address signaturesigner = ecrecover(hash, v, r, s);\r\n\r\n    if (signaturesigner != _addressArgs[1]){\r\n      return 0;\r\n    }\r\n    if (offerhashes[hashStruct]==true){\r\n      return 1;\r\n    }\r\n    return 3;\r\n\r\n  }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"Offercancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royaltyAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"royaltyAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"isany\",\"type\":\"uint256\"}],\"name\":\"Offerfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"Ordercancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royaltyAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"royaltyAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyerAddress\",\"type\":\"address\"}],\"name\":\"Orderfilled\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[3]\",\"name\":\"_addressArgs\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[7]\",\"name\":\"_uintArgs\",\"type\":\"uint256[7]\"}],\"name\":\"cancelOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[5]\",\"name\":\"_addressArgs\",\"type\":\"address[5]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"data\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"address[3]\",\"name\":\"_addressArgs\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[7]\",\"name\":\"_uintArgs\",\"type\":\"uint256[7]\"}],\"name\":\"matchOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"address[5]\",\"name\":\"_addressArgs\",\"type\":\"address[5]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"matchOrder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[3]\",\"name\":\"_addressArgs\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[7]\",\"name\":\"_uintArgs\",\"type\":\"uint256[7]\"}],\"name\":\"offerHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"address[3]\",\"name\":\"_addressArgs\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[7]\",\"name\":\"_uintArgs\",\"type\":\"uint256[7]\"}],\"name\":\"offerStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"offerhashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[5]\",\"name\":\"_addressArgs\",\"type\":\"address[5]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"orderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"address[5]\",\"name\":\"_addressArgs\",\"type\":\"address[5]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"orderStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderhashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GolomTrader", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://04b3bae034e7cf83a192333d9ac026b1cce747ed1fbf512d9bcbe46309e3e062"}]}