{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.10;\n\n\n\n\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint256 digits);\n    function totalSupply() external view returns (uint256 supply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\n\n\ninterface IFundProxy {\n\n    function getRawFundBalancesAndPrices()\n        external\n        returns (\n            string[] memory,\n            uint256[] memory,\n            uint8[][] memory,\n            uint256[][] memory,\n            uint256[] memory\n        );\n}\n\n\n\n\n\ninterface IFundController {\n    function fuseAssets(uint8,string memory) external view returns (address);\n}\n\n\n\n\n\ninterface IFuseAsset {\n    function getCash() external returns (uint256);\n}\n\n\n\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x + y;\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x - y;\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * y;\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\n\ncontract RariView is DSMath {\n\n    /// @dev Not set as view because it calls some non view methods\n    /// @param _tokenAddr Address od the underlying token\n    /// @param _fundProxyAddr FundProxy addr\n    /// @param _controllerAddr RariFundController addr\n    function getPoolLiquidity(\n        address _tokenAddr,\n        address _fundProxyAddr,\n        address _controllerAddr\n    ) public returns (uint256) {\n\n        string memory currencyCode = IERC20(_tokenAddr).symbol();\n\n        // Step 1: Get raw data of fund\n        (\n            string[] memory currencyArr,\n            ,\n            uint8[][] memory pools,\n            uint256[][] memory amountsMap,\n        ) = IFundProxy(_fundProxyAddr).getRawFundBalancesAndPrices();\n\n        // Step 2: Get index of currency code we are searching for\n        uint256 currencyIndex = findCurrencyIndex(currencyArr, currencyCode);\n\n        uint8[] memory currencyPoolIds = pools[currencyIndex];\n        uint256[] memory amounts = amountsMap[currencyIndex];\n\n        // Step 3: Go over each pool and calculate pool asset liquidity (skip over legacy)\n        uint256 totalFuseAssetBalance = 0;\n        for (uint256 i = 0; i < currencyPoolIds.length; ++i) {\n            // under 100 ids are legacy\n            if (uint8(currencyPoolIds[i]) < 100 && amounts[i] == 0) continue;\n\n            address fuseAssetsAddr = IFundController(_controllerAddr).fuseAssets(\n                uint8(currencyPoolIds[i]),\n                currencyCode\n            );\n\n            uint256 cash = IFuseAsset(fuseAssetsAddr).getCash();\n\n            if (cash >= amounts[i]){\n                totalFuseAssetBalance += amounts[i];\n            } else {\n                totalFuseAssetBalance += cash;\n                break;\n            }\n\n        }\n\n        // STEP 4: Add contract balance to final sum\n        uint256 contractBalance = IERC20(_tokenAddr).balanceOf(_controllerAddr);\n\n        return contractBalance + totalFuseAssetBalance;\n    }\n\n    function findCurrencyIndex(string[] memory _currencyArr, string memory _targetCode)\n        public        \n        pure\n        returns (uint256)\n    {\n        for (uint256 i = 0; i < _currencyArr.length; ++i) {\n            if (keccak256(abi.encode(_currencyArr[i])) == keccak256(abi.encode(_targetCode))) {\n                return i;\n            }\n        }\n\n        // so we revert down the line if we don't find the index\n        return type(uint256).max;\n    }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_currencyArr\",\"type\":\"string[]\"},{\"internalType\":\"string\",\"name\":\"_targetCode\",\"type\":\"string\"}],\"name\":\"findCurrencyIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fundProxyAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_controllerAddr\",\"type\":\"address\"}],\"name\":\"getPoolLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RariView", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}