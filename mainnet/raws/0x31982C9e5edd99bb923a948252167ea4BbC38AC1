{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/v0.8/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OwnableInterface {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/SimpleWriteAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwner.sol\\\";\\nimport \\\"./interfaces/AccessControllerInterface.sol\\\";\\n\\n/**\\n * @title SimpleWriteAccessController\\n * @notice Gives access to accounts explicitly added to an access list by the\\n * controller's owner.\\n * @dev does not make any special permissions for externally, see\\n * SimpleReadAccessController for that.\\n */\\ncontract SimpleWriteAccessController is AccessControllerInterface, ConfirmedOwner {\\n  bool public checkEnabled;\\n  mapping(address => bool) internal accessList;\\n\\n  event AddedAccess(address user);\\n  event RemovedAccess(address user);\\n  event CheckAccessEnabled();\\n  event CheckAccessDisabled();\\n\\n  constructor() ConfirmedOwner(msg.sender) {\\n    checkEnabled = true;\\n  }\\n\\n  /**\\n   * @notice Returns the access of an address\\n   * @param _user The address to query\\n   */\\n  function hasAccess(address _user, bytes memory) public view virtual override returns (bool) {\\n    return accessList[_user] || !checkEnabled;\\n  }\\n\\n  /**\\n   * @notice Adds an address to the access list\\n   * @param _user The address to add\\n   */\\n  function addAccess(address _user) external onlyOwner {\\n    if (!accessList[_user]) {\\n      accessList[_user] = true;\\n\\n      emit AddedAccess(_user);\\n    }\\n  }\\n\\n  /**\\n   * @notice Removes an address from the access list\\n   * @param _user The address to remove\\n   */\\n  function removeAccess(address _user) external onlyOwner {\\n    if (accessList[_user]) {\\n      accessList[_user] = false;\\n\\n      emit RemovedAccess(_user);\\n    }\\n  }\\n\\n  /**\\n   * @notice makes the access check enforced\\n   */\\n  function enableAccessCheck() external onlyOwner {\\n    if (!checkEnabled) {\\n      checkEnabled = true;\\n\\n      emit CheckAccessEnabled();\\n    }\\n  }\\n\\n  /**\\n   * @notice makes the access check unenforced\\n   */\\n  function disableAccessCheck() external onlyOwner {\\n    if (checkEnabled) {\\n      checkEnabled = false;\\n\\n      emit CheckAccessDisabled();\\n    }\\n  }\\n\\n  /**\\n   * @dev reverts if the caller does not have access\\n   */\\n  modifier checkAccess() {\\n    require(hasAccess(msg.sender, msg.data), \\\"No access\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AccessControllerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AccessControllerInterface {\\n  function hasAccess(address user, bytes calldata data) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/ArbitrumValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/AggregatorValidatorInterface.sol\\\";\\nimport \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\nimport \\\"../interfaces/AccessControllerInterface.sol\\\";\\nimport \\\"../interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../SimpleWriteAccessController.sol\\\";\\n\\n/* ./dev dependencies - to be moved from ./dev after audit */\\nimport \\\"./interfaces/ArbitrumSequencerUptimeFeedInterface.sol\\\";\\nimport \\\"./interfaces/FlagsInterface.sol\\\";\\nimport \\\"./vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IInbox.sol\\\";\\nimport \\\"./vendor/arb-bridge-eth/v0.8.0-custom/contracts/libraries/AddressAliasHelper.sol\\\";\\nimport \\\"./vendor/arb-os/e8d9696f21/contracts/arbos/builtin/ArbSys.sol\\\";\\nimport \\\"./vendor/openzeppelin-solidity/v4.3.1/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title ArbitrumValidator - makes xDomain L2 Flags contract call (using L2 xDomain Forwarder contract)\\n * @notice Allows to raise and lower Flags on the Arbitrum L2 network through L1 bridge\\n *  - The internal AccessController controls the access of the validate method\\n *  - Gas configuration is controlled by a configurable external SimpleWriteAccessController\\n *  - Funds on the contract are managed by the owner\\n */\\ncontract ArbitrumValidator is TypeAndVersionInterface, AggregatorValidatorInterface, SimpleWriteAccessController {\\n  enum PaymentStrategy {\\n    L1,\\n    L2\\n  }\\n  // Config for L1 -> L2 Arbitrum retryable ticket message\\n  struct GasConfig {\\n    uint256 maxGas;\\n    uint256 gasPriceBid;\\n    address gasPriceL1FeedAddr;\\n  }\\n\\n  /// @dev Precompiled contract that exists in every Arbitrum chain at address(100). Exposes a variety of system-level functionality.\\n  address constant ARBSYS_ADDR = address(0x0000000000000000000000000000000000000064);\\n\\n  int256 private constant ANSWER_SEQ_OFFLINE = 1;\\n\\n  address public immutable CROSS_DOMAIN_MESSENGER;\\n  address public immutable L2_SEQ_STATUS_RECORDER;\\n  // L2 xDomain alias address of this contract\\n  address public immutable L2_ALIAS = AddressAliasHelper.applyL1ToL2Alias(address(this));\\n\\n  PaymentStrategy private s_paymentStrategy;\\n  GasConfig private s_gasConfig;\\n  AccessControllerInterface private s_configAC;\\n\\n  /**\\n   * @notice emitted when a new payment strategy is set\\n   * @param paymentStrategy strategy describing how the contract pays for xDomain calls\\n   */\\n  event PaymentStrategySet(PaymentStrategy indexed paymentStrategy);\\n\\n  /**\\n   * @notice emitted when a new gas configuration is set\\n   * @param maxGas gas limit for immediate L2 execution attempt.\\n   * @param gasPriceBid maximum L2 gas price to pay\\n   * @param gasPriceL1FeedAddr address of the L1 gas price feed (used to approximate Arbitrum retryable ticket submission cost)\\n   */\\n  event GasConfigSet(uint256 maxGas, uint256 gasPriceBid, address indexed gasPriceL1FeedAddr);\\n\\n  /**\\n   * @notice emitted when a new gas access-control contract is set\\n   * @param previous the address prior to the current setting\\n   * @param current the address of the new access-control contract\\n   */\\n  event ConfigACSet(address indexed previous, address indexed current);\\n\\n  /**\\n   * @notice emitted when a new ETH withdrawal from L2 was requested\\n   * @param id unique id of the published retryable transaction (keccak256(requestID, uint(0))\\n   * @param amount of funds to withdraw\\n   */\\n  event L2WithdrawalRequested(uint256 indexed id, uint256 amount, address indexed refundAddr);\\n\\n  /**\\n   * @param crossDomainMessengerAddr address the xDomain bridge messenger (Arbitrum Inbox L1) contract address\\n   * @param l2ArbitrumSequencerUptimeFeedAddr the L2 Flags contract address\\n   * @param configACAddr address of the access controller for managing gas price on Arbitrum\\n   * @param maxGas gas limit for immediate L2 execution attempt. A value around 1M should be sufficient\\n   * @param gasPriceBid maximum L2 gas price to pay\\n   * @param gasPriceL1FeedAddr address of the L1 gas price feed (used to approximate Arbitrum retryable ticket submission cost)\\n   * @param paymentStrategy strategy describing how the contract pays for xDomain calls\\n   */\\n  constructor(\\n    address crossDomainMessengerAddr,\\n    address l2ArbitrumSequencerUptimeFeedAddr,\\n    address configACAddr,\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address gasPriceL1FeedAddr,\\n    PaymentStrategy paymentStrategy\\n  ) {\\n    require(crossDomainMessengerAddr != address(0), \\\"Invalid xDomain Messenger address\\\");\\n    require(l2ArbitrumSequencerUptimeFeedAddr != address(0), \\\"Invalid ArbitrumSequencerUptimeFeed contract address\\\");\\n    CROSS_DOMAIN_MESSENGER = crossDomainMessengerAddr;\\n    L2_SEQ_STATUS_RECORDER = l2ArbitrumSequencerUptimeFeedAddr;\\n    // Additional L2 payment configuration\\n    _setConfigAC(configACAddr);\\n    _setGasConfig(maxGas, gasPriceBid, gasPriceL1FeedAddr);\\n    _setPaymentStrategy(paymentStrategy);\\n  }\\n\\n  /**\\n   * @notice versions:\\n   *\\n   * - ArbitrumValidator 0.1.0: initial release\\n   * - ArbitrumValidator 0.2.0: critical Arbitrum network update\\n   *   - xDomain `msg.sender` backwards incompatible change (now an alias address)\\n   *   - new `withdrawFundsFromL2` fn that withdraws from L2 xDomain alias address\\n   *   - approximation of `maxSubmissionCost` using a L1 gas price feed\\n   * - ArbitrumValidator 1.0.0: change target of L2 sequencer status update\\n   *   - now calls `updateStatus` on an L2 ArbitrumSequencerUptimeFeed contract instead of\\n   *     directly calling the Flags contract\\n   *\\n   * @inheritdoc TypeAndVersionInterface\\n   */\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"ArbitrumValidator 1.0.0\\\";\\n  }\\n\\n  /// @return stored PaymentStrategy\\n  function paymentStrategy() external view virtual returns (PaymentStrategy) {\\n    return s_paymentStrategy;\\n  }\\n\\n  /// @return stored GasConfig\\n  function gasConfig() external view virtual returns (GasConfig memory) {\\n    return s_gasConfig;\\n  }\\n\\n  /// @return config AccessControllerInterface contract address\\n  function configAC() external view virtual returns (address) {\\n    return address(s_configAC);\\n  }\\n\\n  /**\\n   * @notice makes this contract payable\\n   * @dev receives funds:\\n   *  - to use them (if configured) to pay for L2 execution on L1\\n   *  - when withdrawing funds from L2 xDomain alias address (pay for L2 execution on L2)\\n   */\\n  receive() external payable {}\\n\\n  /**\\n   * @notice withdraws all funds available in this contract to the msg.sender\\n   * @dev only owner can call this\\n   */\\n  function withdrawFunds() external onlyOwner {\\n    address payable recipient = payable(msg.sender);\\n    uint256 amount = address(this).balance;\\n    Address.sendValue(recipient, amount);\\n  }\\n\\n  /**\\n   * @notice withdraws all funds available in this contract to the address specified\\n   * @dev only owner can call this\\n   * @param recipient address where to send the funds\\n   */\\n  function withdrawFundsTo(address payable recipient) external onlyOwner {\\n    uint256 amount = address(this).balance;\\n    Address.sendValue(recipient, amount);\\n  }\\n\\n  /**\\n   * @notice withdraws funds from L2 xDomain alias address (representing this L1 contract)\\n   * @dev only owner can call this\\n   * @param amount of funds to withdraws\\n   * @param refundAddr address where gas excess on L2 will be sent\\n   *   WARNING: `refundAddr` is not aliased! Make sure you can recover the refunded funds on L2.\\n   * @return id unique id of the published retryable transaction (keccak256(requestID, uint(0))\\n   */\\n  function withdrawFundsFromL2(uint256 amount, address refundAddr) external onlyOwner returns (uint256 id) {\\n    // Build an xDomain message to trigger the ArbSys precompile, which will create a L2 -> L1 tx transferring `amount`\\n    bytes memory message = abi.encodeWithSelector(ArbSys.withdrawEth.selector, address(this));\\n    // Make the xDomain call\\n    // NOTICE: We approximate the max submission cost of sending a retryable tx with specific calldata length.\\n    uint256 maxSubmissionCost = _approximateMaxSubmissionCost(message.length);\\n    uint256 maxGas = 120_000; // static `maxGas` for L2 -> L1 transfer\\n    uint256 gasPriceBid = s_gasConfig.gasPriceBid;\\n    uint256 l1PaymentValue = s_paymentStrategy == PaymentStrategy.L1\\n      ? _maxRetryableTicketCost(maxSubmissionCost, maxGas, gasPriceBid)\\n      : 0;\\n    // NOTICE: In the case of PaymentStrategy.L2 the L2 xDomain alias address needs to be funded, as it will be paying the fee.\\n    id = IInbox(CROSS_DOMAIN_MESSENGER).createRetryableTicketNoRefundAliasRewrite{value: l1PaymentValue}(\\n      ARBSYS_ADDR, // target\\n      amount, // L2 call value (requested)\\n      maxSubmissionCost,\\n      refundAddr, // excessFeeRefundAddress\\n      refundAddr, // callValueRefundAddress\\n      maxGas,\\n      gasPriceBid,\\n      message\\n    );\\n    emit L2WithdrawalRequested(id, amount, refundAddr);\\n  }\\n\\n  /**\\n   * @notice sets config AccessControllerInterface contract\\n   * @dev only owner can call this\\n   * @param accessController new AccessControllerInterface contract address\\n   */\\n  function setConfigAC(address accessController) external onlyOwner {\\n    _setConfigAC(accessController);\\n  }\\n\\n  /**\\n   * @notice sets Arbitrum gas configuration\\n   * @dev access control provided by `configAC`\\n   * @param maxGas gas limit for immediate L2 execution attempt. A value around 1M should be sufficient\\n   * @param gasPriceBid maximum L2 gas price to pay\\n   * @param gasPriceL1FeedAddr address of the L1 gas price feed (used to approximate Arbitrum retryable ticket submission cost)\\n   */\\n  function setGasConfig(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address gasPriceL1FeedAddr\\n  ) external onlyOwnerOrConfigAccess {\\n    _setGasConfig(maxGas, gasPriceBid, gasPriceL1FeedAddr);\\n  }\\n\\n  /**\\n   * @notice sets the payment strategy\\n   * @dev access control provided by `configAC`\\n   * @param paymentStrategy strategy describing how the contract pays for xDomain calls\\n   */\\n  function setPaymentStrategy(PaymentStrategy paymentStrategy) external onlyOwnerOrConfigAccess {\\n    _setPaymentStrategy(paymentStrategy);\\n  }\\n\\n  /**\\n   * @notice validate method sends an xDomain L2 tx to update Flags contract, in case of change from `previousAnswer`.\\n   * @dev A retryable ticket is created on the Arbitrum L1 Inbox contract. The tx gas fee can be paid from this\\n   *   contract providing a value, or if no L1 value is sent with the xDomain message the gas will be paid by\\n   *   the L2 xDomain alias account (generated from `address(this)`). This method is accessed controlled.\\n   * @param previousAnswer previous aggregator answer\\n   * @param currentAnswer new aggregator answer - value of 1 considers the service offline.\\n   */\\n  function validate(\\n    uint256, /* previousRoundId */\\n    int256 previousAnswer,\\n    uint256, /* currentRoundId */\\n    int256 currentAnswer\\n  ) external override checkAccess returns (bool) {\\n    // Avoids resending to L2 the same tx on every call\\n    if (previousAnswer == currentAnswer) {\\n      return true;\\n    }\\n\\n    // Excess gas on L2 will be sent to the L2 xDomain alias address of this contract\\n    address refundAddr = L2_ALIAS;\\n    // Encode the ArbitrumSequencerUptimeFeed call\\n    bytes4 selector = ArbitrumSequencerUptimeFeedInterface.updateStatus.selector;\\n    bool status = currentAnswer == ANSWER_SEQ_OFFLINE;\\n    uint64 timestamp = uint64(block.timestamp);\\n    // Encode `status` and `timestamp`\\n    bytes memory message = abi.encodeWithSelector(selector, status, timestamp);\\n    // Make the xDomain call\\n    // NOTICE: We approximate the max submission cost of sending a retryable tx with specific calldata length.\\n    uint256 maxSubmissionCost = _approximateMaxSubmissionCost(message.length);\\n    uint256 maxGas = s_gasConfig.maxGas;\\n    uint256 gasPriceBid = s_gasConfig.gasPriceBid;\\n    uint256 l1PaymentValue = s_paymentStrategy == PaymentStrategy.L1\\n      ? _maxRetryableTicketCost(maxSubmissionCost, maxGas, gasPriceBid)\\n      : 0;\\n    // NOTICE: In the case of PaymentStrategy.L2 the L2 xDomain alias address needs to be funded, as it will be paying the fee.\\n    // We also ignore the returned msg number, that can be queried via the `InboxMessageDelivered` event.\\n    IInbox(CROSS_DOMAIN_MESSENGER).createRetryableTicketNoRefundAliasRewrite{value: l1PaymentValue}(\\n      L2_SEQ_STATUS_RECORDER, // target\\n      0, // L2 call value\\n      maxSubmissionCost,\\n      refundAddr, // excessFeeRefundAddress\\n      refundAddr, // callValueRefundAddress\\n      maxGas,\\n      gasPriceBid,\\n      message\\n    );\\n    // return success\\n    return true;\\n  }\\n\\n  /// @notice internal method that stores the payment strategy\\n  function _setPaymentStrategy(PaymentStrategy paymentStrategy) internal {\\n    s_paymentStrategy = paymentStrategy;\\n    emit PaymentStrategySet(paymentStrategy);\\n  }\\n\\n  /// @notice internal method that stores the gas configuration\\n  function _setGasConfig(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address gasPriceL1FeedAddr\\n  ) internal {\\n    require(maxGas > 0, \\\"Max gas is zero\\\");\\n    require(gasPriceBid > 0, \\\"Gas price bid is zero\\\");\\n    require(gasPriceL1FeedAddr != address(0), \\\"Gas price Aggregator is zero address\\\");\\n    s_gasConfig = GasConfig(maxGas, gasPriceBid, gasPriceL1FeedAddr);\\n    emit GasConfigSet(maxGas, gasPriceBid, gasPriceL1FeedAddr);\\n  }\\n\\n  /// @notice Internal method that stores the configuration access controller\\n  function _setConfigAC(address accessController) internal {\\n    address previousAccessController = address(s_configAC);\\n    if (accessController != previousAccessController) {\\n      s_configAC = AccessControllerInterface(accessController);\\n      emit ConfigACSet(previousAccessController, accessController);\\n    }\\n  }\\n\\n  /**\\n   * @notice Internal method that approximates the `maxSubmissionCost` (using the L1 gas price feed)\\n   * @dev On L2 this info is available via `ArbRetryableTx.getSubmissionPrice`.\\n   * @param calldataSizeInBytes xDomain message size in bytes\\n   */\\n  function _approximateMaxSubmissionCost(uint256 calldataSizeInBytes) internal view returns (uint256) {\\n    (, int256 l1GasPriceInWei, , , ) = AggregatorV3Interface(s_gasConfig.gasPriceL1FeedAddr).latestRoundData();\\n    uint256 l1GasPriceEstimate = uint256(l1GasPriceInWei) * 3; // add 200% buffer (price volatility error margin)\\n    return (l1GasPriceEstimate * calldataSizeInBytes) / 256 + l1GasPriceEstimate;\\n  }\\n\\n  /// @notice Internal helper method that calculates the total cost of the xDomain retryable ticket call\\n  function _maxRetryableTicketCost(\\n    uint256 maxSubmissionCost,\\n    uint256 maxGas,\\n    uint256 gasPriceBid\\n  ) internal pure returns (uint256) {\\n    return maxSubmissionCost + maxGas * gasPriceBid;\\n  }\\n\\n  /// @dev reverts if the caller does not have access to change the configuration\\n  modifier onlyOwnerOrConfigAccess() {\\n    require(\\n      msg.sender == owner() || (address(s_configAC) != address(0) && s_configAC.hasAccess(msg.sender, msg.data)),\\n      \\\"No access\\\"\\n    );\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AggregatorValidatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorValidatorInterface {\\n  function validate(\\n    uint256 previousRoundId,\\n    int256 previousAnswer,\\n    uint256 currentRoundId,\\n    int256 currentAnswer\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/TypeAndVersionInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract TypeAndVersionInterface {\\n  function typeAndVersion() external pure virtual returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/interfaces/ArbitrumSequencerUptimeFeedInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ArbitrumSequencerUptimeFeedInterface {\\n  function updateStatus(bool status, uint64 timestamp) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/interfaces/FlagsInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\ninterface FlagsInterface {\\n  function getFlag(address) external view returns (bool);\\n\\n  function getFlags(address[] calldata) external view returns (bool[] memory);\\n\\n  function raiseFlag(address) external;\\n\\n  function raiseFlags(address[] calldata) external;\\n\\n  function lowerFlag(address) external;\\n\\n  function lowerFlags(address[] calldata) external;\\n\\n  function setRaisingAccessController(address) external;\\n\\n  function setLoweringAccessController(address) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IInbox.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// NOTICE: pragma change from original (^0.6.11)\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IMessageProvider.sol\\\";\\n\\ninterface IInbox is IMessageProvider {\\n  function sendL2Message(bytes calldata messageData) external returns (uint256);\\n\\n  function sendUnsignedTransaction(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    uint256 nonce,\\n    address destAddr,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external returns (uint256);\\n\\n  function sendContractTransaction(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address destAddr,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external returns (uint256);\\n\\n  function sendL1FundedUnsignedTransaction(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    uint256 nonce,\\n    address destAddr,\\n    bytes calldata data\\n  ) external payable returns (uint256);\\n\\n  function sendL1FundedContractTransaction(\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    address destAddr,\\n    bytes calldata data\\n  ) external payable returns (uint256);\\n\\n  function createRetryableTicketNoRefundAliasRewrite(\\n    address destAddr,\\n    uint256 arbTxCallValue,\\n    uint256 maxSubmissionCost,\\n    address submissionRefundAddress,\\n    address valueRefundAddress,\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    bytes calldata data\\n  ) external payable returns (uint256);\\n\\n  function createRetryableTicket(\\n    address destAddr,\\n    uint256 arbTxCallValue,\\n    uint256 maxSubmissionCost,\\n    address submissionRefundAddress,\\n    address valueRefundAddress,\\n    uint256 maxGas,\\n    uint256 gasPriceBid,\\n    bytes calldata data\\n  ) external payable returns (uint256);\\n\\n  function depositEth(address destAddr) external payable returns (uint256);\\n\\n  function depositEthRetryable(\\n    address destAddr,\\n    uint256 maxSubmissionCost,\\n    uint256 maxGas,\\n    uint256 maxGasPrice\\n  ) external payable returns (uint256);\\n\\n  function bridge() external view returns (IBridge);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/libraries/AddressAliasHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// NOTICE: pragma change from original (^0.6.11)\\npragma solidity ^0.8.0;\\n\\nlibrary AddressAliasHelper {\\n  uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\\n\\n  /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n  /// address in the L1 that submitted a tx to the inbox\\n  /// @param l1Address L2 address as viewed in msg.sender\\n  /// @return l2Address the address in the L1 that triggered the tx to L2\\n  function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\\n    unchecked {\\n      l2Address = address(uint160(l1Address) + offset);\\n    }\\n  }\\n\\n  /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n  /// address in the L1 that submitted a tx to the inbox\\n  /// @param l2Address L2 address as viewed in msg.sender\\n  /// @return l1Address the address in the L1 that triggered the tx to L2\\n  function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\\n    unchecked {\\n      l1Address = address(uint160(l2Address) - offset);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-os/e8d9696f21/contracts/arbos/builtin/ArbSys.sol\": {\r\n      \"content\": \"// NOTICE: pragma change from original (>=0.4.21 <0.7.0)\\npragma solidity >=0.4.21 <0.9.0;\\n\\n/**\\n * @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\\n */\\ninterface ArbSys {\\n  /**\\n   * @notice Get internal version number identifying an ArbOS build\\n   * @return version number as int\\n   */\\n  function arbOSVersion() external pure returns (uint256);\\n\\n  function arbChainID() external view returns (uint256);\\n\\n  /**\\n   * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\\n   * @return block number as int\\n   */\\n  function arbBlockNumber() external view returns (uint256);\\n\\n  /**\\n   * @notice Send given amount of Eth to dest from sender.\\n   * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\\n   * @param destination recipient address on L1\\n   * @return unique identifier for this L2-to-L1 transaction.\\n   */\\n  function withdrawEth(address destination) external payable returns (uint256);\\n\\n  /**\\n   * @notice Send a transaction to L1\\n   * @param destination recipient address on L1\\n   * @param calldataForL1 (optional) calldata for L1 contract call\\n   * @return a unique identifier for this L2-to-L1 transaction.\\n   */\\n  function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns (uint256);\\n\\n  /**\\n   * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\\n   * @param account target account\\n   * @return the number of transactions issued by the given external account or the account sequence number of the given contract\\n   */\\n  function getTransactionCount(address account) external view returns (uint256);\\n\\n  /**\\n   * @notice get the value of target L2 storage slot\\n   * This function is only callable from address 0 to prevent contracts from being able to call it\\n   * @param account target account\\n   * @param index target index of storage slot\\n   * @return stotage value for the given account at the given index\\n   */\\n  function getStorageAt(address account, uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @notice check if current call is coming from l1\\n   * @return true if the caller of this was called directly from L1\\n   */\\n  function isTopLevelCall() external view returns (bool);\\n\\n  event L2ToL1Transaction(\\n    address caller,\\n    address indexed destination,\\n    uint256 indexed uniqueId,\\n    uint256 indexed batchNumber,\\n    uint256 indexInBatch,\\n    uint256 arbBlockNum,\\n    uint256 ethBlockNum,\\n    uint256 timestamp,\\n    uint256 callvalue,\\n    bytes data\\n  );\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/openzeppelin-solidity/v4.3.1/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n\\n    uint256 size;\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain `call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n   * revert reason using the provided one.\\n   *\\n   * _Available since v4.3._\\n   */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// NOTICE: pragma change from original (^0.6.11)\\npragma solidity ^0.8.0;\\n\\ninterface IBridge {\\n  event MessageDelivered(\\n    uint256 indexed messageIndex,\\n    bytes32 indexed beforeInboxAcc,\\n    address inbox,\\n    uint8 kind,\\n    address sender,\\n    bytes32 messageDataHash\\n  );\\n\\n  function deliverMessageToInbox(\\n    uint8 kind,\\n    address sender,\\n    bytes32 messageDataHash\\n  ) external payable returns (uint256);\\n\\n  function executeCall(\\n    address destAddr,\\n    uint256 amount,\\n    bytes calldata data\\n  ) external returns (bool success, bytes memory returnData);\\n\\n  // These are only callable by the admin\\n  function setInbox(address inbox, bool enabled) external;\\n\\n  function setOutbox(address inbox, bool enabled) external;\\n\\n  // View functions\\n\\n  function activeOutbox() external view returns (address);\\n\\n  function allowedInboxes(address inbox) external view returns (bool);\\n\\n  function allowedOutboxes(address outbox) external view returns (bool);\\n\\n  function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n  function messageCount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IMessageProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\n// NOTICE: pragma change from original (^0.6.11)\\npragma solidity ^0.8.0;\\n\\ninterface IMessageProvider {\\n  event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\\n\\n  event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/dev/interfaces/ForwarderInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title ForwarderInterface - forwards a call to a target, under some conditions\\ninterface ForwarderInterface {\\n  /**\\n   * @notice forward calls the `target` with `data`\\n   * @param target contract address to be called\\n   * @param data to send to target contract\\n   */\\n  function forward(address target, bytes memory data) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\\n\"\r\n    },\r\n    \"src/v0.8/SimpleReadAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./SimpleWriteAccessController.sol\\\";\\n\\n/**\\n * @title SimpleReadAccessController\\n * @notice Gives access to:\\n * - any externally owned account (note that off-chain actors can always read\\n * any contract storage regardless of on-chain access control measures, so this\\n * does not weaken the access control while improving usability)\\n * - accounts explicitly added to an access list\\n * @dev SimpleReadAccessController is not suitable for access controlling writes\\n * since it grants any externally owned account access! See\\n * SimpleWriteAccessController for that.\\n */\\ncontract SimpleReadAccessController is SimpleWriteAccessController {\\n  /**\\n   * @notice Returns the access of an address\\n   * @param _user The address to query\\n   */\\n  function hasAccess(address _user, bytes memory _calldata) public view virtual override returns (bool) {\\n    return super.hasAccess(_user, _calldata) || _user == tx.origin;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/Flags.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./SimpleReadAccessController.sol\\\";\\nimport \\\"./interfaces/AccessControllerInterface.sol\\\";\\nimport \\\"./interfaces/FlagsInterface.sol\\\";\\n\\n/**\\n * @title The Flags contract\\n * @notice Allows flags to signal to any reader on the access control list.\\n * The owner can set flags, or designate other addresses to set flags. The\\n * owner must turn the flags off, other setters cannot. An expected pattern is\\n * to allow addresses to raise flags on themselves, so if you are subscribing to\\n * FlagOn events you should filter for addresses you care about.\\n */\\ncontract Flags is FlagsInterface, SimpleReadAccessController {\\n  AccessControllerInterface public raisingAccessController;\\n\\n  mapping(address => bool) private flags;\\n\\n  event FlagRaised(address indexed subject);\\n  event FlagLowered(address indexed subject);\\n  event RaisingAccessControllerUpdated(address indexed previous, address indexed current);\\n\\n  /**\\n   * @param racAddress address for the raising access controller.\\n   */\\n  constructor(address racAddress) {\\n    setRaisingAccessController(racAddress);\\n  }\\n\\n  /**\\n   * @notice read the warning flag status of a contract address.\\n   * @param subject The contract address being checked for a flag.\\n   * @return A true value indicates that a flag was raised and a\\n   * false value indicates that no flag was raised.\\n   */\\n  function getFlag(address subject) external view override checkAccess returns (bool) {\\n    return flags[subject];\\n  }\\n\\n  /**\\n   * @notice read the warning flag status of a contract address.\\n   * @param subjects An array of addresses being checked for a flag.\\n   * @return An array of bools where a true value for any flag indicates that\\n   * a flag was raised and a false value indicates that no flag was raised.\\n   */\\n  function getFlags(address[] calldata subjects) external view override checkAccess returns (bool[] memory) {\\n    bool[] memory responses = new bool[](subjects.length);\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      responses[i] = flags[subjects[i]];\\n    }\\n    return responses;\\n  }\\n\\n  /**\\n   * @notice enable the warning flag for an address.\\n   * Access is controlled by raisingAccessController, except for owner\\n   * who always has access.\\n   * @param subject The contract address whose flag is being raised\\n   */\\n  function raiseFlag(address subject) external override {\\n    require(allowedToRaiseFlags(), \\\"Not allowed to raise flags\\\");\\n\\n    tryToRaiseFlag(subject);\\n  }\\n\\n  /**\\n   * @notice enable the warning flags for multiple addresses.\\n   * Access is controlled by raisingAccessController, except for owner\\n   * who always has access.\\n   * @param subjects List of the contract addresses whose flag is being raised\\n   */\\n  function raiseFlags(address[] calldata subjects) external override {\\n    require(allowedToRaiseFlags(), \\\"Not allowed to raise flags\\\");\\n\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      tryToRaiseFlag(subjects[i]);\\n    }\\n  }\\n\\n  /**\\n   * @notice allows owner to disable the warning flags for multiple addresses.\\n   * @param subjects List of the contract addresses whose flag is being lowered\\n   */\\n  function lowerFlags(address[] calldata subjects) external override onlyOwner {\\n    for (uint256 i = 0; i < subjects.length; i++) {\\n      address subject = subjects[i];\\n\\n      if (flags[subject]) {\\n        flags[subject] = false;\\n        emit FlagLowered(subject);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice allows owner to change the access controller for raising flags.\\n   * @param racAddress new address for the raising access controller.\\n   */\\n  function setRaisingAccessController(address racAddress) public override onlyOwner {\\n    address previous = address(raisingAccessController);\\n\\n    if (previous != racAddress) {\\n      raisingAccessController = AccessControllerInterface(racAddress);\\n\\n      emit RaisingAccessControllerUpdated(previous, racAddress);\\n    }\\n  }\\n\\n  // PRIVATE\\n\\n  function allowedToRaiseFlags() private view returns (bool) {\\n    return msg.sender == owner() || raisingAccessController.hasAccess(msg.sender, msg.data);\\n  }\\n\\n  function tryToRaiseFlag(address subject) private {\\n    if (!flags[subject]) {\\n      flags[subject] = true;\\n      emit FlagRaised(subject);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/FlagsInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface FlagsInterface {\\n  function getFlag(address) external view returns (bool);\\n\\n  function getFlags(address[] calldata) external view returns (bool[] memory);\\n\\n  function raiseFlag(address) external;\\n\\n  function raiseFlags(address[] calldata) external;\\n\\n  function lowerFlags(address[] calldata) external;\\n\\n  function setRaisingAccessController(address) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"crossDomainMessengerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l2ArbitrumSequencerUptimeFeedAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"configACAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPriceBid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gasPriceL1FeedAddr\",\"type\":\"address\"},{\"internalType\":\"enum ArbitrumValidator.PaymentStrategy\",\"name\":\"paymentStrategy\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"AddedAccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CheckAccessDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CheckAccessEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"ConfigACSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxGas\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasPriceBid\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gasPriceL1FeedAddr\",\"type\":\"address\"}],\"name\":\"GasConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"refundAddr\",\"type\":\"address\"}],\"name\":\"L2WithdrawalRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum ArbitrumValidator.PaymentStrategy\",\"name\":\"paymentStrategy\",\"type\":\"uint8\"}],\"name\":\"PaymentStrategySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RemovedAccess\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CROSS_DOMAIN_MESSENGER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"L2_ALIAS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"L2_SEQ_STATUS_RECORDER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"addAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configAC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableAccessCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableAccessCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"maxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPriceBid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gasPriceL1FeedAddr\",\"type\":\"address\"}],\"internalType\":\"struct ArbitrumValidator.GasConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"hasAccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentStrategy\",\"outputs\":[{\"internalType\":\"enum ArbitrumValidator.PaymentStrategy\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"removeAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"accessController\",\"type\":\"address\"}],\"name\":\"setConfigAC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPriceBid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"gasPriceL1FeedAddr\",\"type\":\"address\"}],\"name\":\"setGasConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ArbitrumValidator.PaymentStrategy\",\"name\":\"paymentStrategy\",\"type\":\"uint8\"}],\"name\":\"setPaymentStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"previousAnswer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"currentAnswer\",\"type\":\"int256\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"refundAddr\",\"type\":\"address\"}],\"name\":\"withdrawFundsFromL2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawFundsTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ArbitrumValidator", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000004dbd4fc535ac27206064b68ffcf827b0a60bab3f000000000000000000000000c1303bbbaf172c55848d3cb91606d8e27ff384280000000000000000000000002be843e2a5907fff0b7c9337b5058617bfec2bfe0000000000000000000000000000000000000000000000000000000001312d0000000000000000000000000000000000000000000000000000000000b2d05e00000000000000000000000000169e633a2d1e6c10dd91238ba11c4a708dfef37c0000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}