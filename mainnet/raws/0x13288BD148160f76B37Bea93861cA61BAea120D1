{"status": "1", "message": "OK", "result": [{"SourceCode": "// Verified using https://dapp.tools\n\n// hevm: flattened sources of /nix/store/9nsv73hmqz0jn01dv39h9cw3r2xydxb0-h2o-deploy/dapp/h2o-deploy/src/AdvancedTokenAdapters.sol\npragma solidity =0.6.7 >=0.6.0 <0.8.0;\n\n////// /nix/store/9nsv73hmqz0jn01dv39h9cw3r2xydxb0-h2o-deploy/dapp/h2o-deploy/src/utils/ReentrancyGuard.sol\n// SPDX-License-Identifier: MIT\n\n/* pragma solidity >=0.6.0 <0.8.0; */\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n////// /nix/store/9nsv73hmqz0jn01dv39h9cw3r2xydxb0-h2o-deploy/dapp/h2o-deploy/src/AdvancedTokenAdapters.sol\n/// AdvancedTokenAdapters.sol\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// (at your option) any later version.\n// the Free Software Foundation, either version 3 of the License, or\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n/* pragma solidity 0.6.7; */\n/* import \"./utils/ReentrancyGuard.sol\"; */\n\nabstract contract SAFEEngineLike_1 {\n    function modifyCollateralBalance(bytes32,address,int) virtual public;\n}\n\n// CollateralJoin1\nabstract contract CollateralLike_1 {\n    function decimals() virtual public view returns (uint);\n    function transfer(address,uint) virtual public returns (bool);\n    function transferFrom(address,address,uint) virtual public returns (bool);\n}\n\ncontract CollateralJoin1 {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"CollateralJoin1/account-not-authorized\");\n        _;\n    }\n\n    // Safe engine contract\n    SAFEEngineLike_1 public safeEngine;\n    // The name of the collateral type handled by this join contract\n    bytes32        public collateralType;\n    // The collateral token contract\n    CollateralLike_1 public collateral;\n    // The number of decimals the collateral has\n    uint           public decimals;\n    // Whether this contract is disabled or not\n    uint           public contractEnabled;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event DisableContract();\n    event Join(address sender, address usr, uint wad);\n    event Exit(address sender, address usr, uint wad);\n\n    constructor(address safeEngine_, bytes32 collateralType_, address collateral_) public {\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n\n        safeEngine = SAFEEngineLike_1(safeEngine_);\n        collateralType = collateralType_;\n        collateral = CollateralLike_1(collateral_);\n        decimals = collateral.decimals();\n\n        require(decimals == 18, \"CollateralJoin1/not-18-decimals\");\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addition(uint x, int y) internal pure returns (uint z) {\n        z = x + uint(y);\n        require(y >= 0 || z <= x);\n        require(y <= 0 || z >= x);\n    }\n\n    // --- Administration ---\n    /*\n    * @notify Disable this join contract\n    */\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n\n    // --- Collateral Gateway ---\n    /*\n    * @notify Join collateral tokens in the system\n    * @dev It reverts in case the contract is disabled\n    * @param usr The address that will receive tokens inside the system\n    * @param wad The amount of tokens to join\n    */\n    function join(address usr, uint wad) external {\n        require(contractEnabled == 1, \"CollateralJoin1/not-contractEnabled\");\n        require(int(wad) >= 0, \"CollateralJoin1/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, usr, int(wad));\n        require(collateral.transferFrom(msg.sender, address(this), wad), \"CollateralJoin1/failed-transfer\");\n        emit Join(msg.sender, usr, wad);\n    }\n    /*\n    * @notify Exit collateral tokens from the system and send them to a custom address\n    * @param usr The address that will receive collateral tokens after they are exited\n    * @param wad The amount of tokens to exit\n    */\n    function exit(address usr, uint wad) external {\n        require(wad <= 2 ** 255, \"CollateralJoin1/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, msg.sender, -int(wad));\n        require(collateral.transfer(usr, wad), \"CollateralJoin1/failed-transfer\");\n        emit Exit(msg.sender, usr, wad);\n    }\n}\n\n// CollateralJoin2\n\n// For a token that does not return a bool on transfer or transferFrom (like OMG)\n// This is one way of doing it. Check the balances before and after calling a transfer\n\nabstract contract CollateralLike2 {\n    function decimals() virtual public view returns (uint);\n    function transfer(address,uint) virtual public;\n    function transferFrom(address,address,uint) virtual public;\n    function balanceOf(address) virtual public view returns (uint);\n    function allowance(address,address) virtual public view returns (uint);\n}\n\ncontract CollateralJoin2 {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"CollateralJoin2/account-not-authorized\");\n        _;\n    }\n\n    // Safe engine contract\n    SAFEEngineLike_1  public safeEngine;\n    // The name of the collateral type handled by this join contract\n    bytes32         public collateralType;\n    // The collateral token contract\n    CollateralLike2 public collateral;\n    // The number of decimals the collateral has\n    uint            public decimals;\n    // Whether this contract is disabled or not\n    uint            public contractEnabled;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event DisableContract();\n    event Join(address sender, address usr, uint wad);\n    event Exit(address sender, address usr, uint wad);\n\n    constructor(address safeEngine_, bytes32 collateralType_, address collateral_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine = SAFEEngineLike_1(safeEngine_);\n        collateralType = collateralType_;\n        collateral = CollateralLike2(collateral_);\n        decimals = collateral.decimals();\n        contractEnabled = 1;\n        require(decimals == 18, \"CollateralJoin2/not-18-decimals\");\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addition(uint x, int y) internal pure returns (uint z) {\n        z = x + uint(y);\n        require(y >= 0 || z <= x);\n        require(y <= 0 || z >= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"CollateralJoin2/overflow\");\n    }\n\n    // --- Administration ---\n    /*\n    * @notify Disable this join contract\n    */\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n\n    // --- Collateral Gateway ---\n    function transfer(int wad, address guy) internal {\n        int256 prevBalance = int(collateral.balanceOf(address(this)));\n        require(prevBalance >= wad, \"CollateralJoin2/no-funds\");\n        (bool ok,) = address(collateral).call(\n            abi.encodeWithSignature(\"transfer(address,uint256)\", guy, wad)\n        );\n        require(ok, \"CollateralJoin2/failed-transfer\");\n        require(uint(prevBalance + wad) == collateral.balanceOf(address(this)), \"CollateralJoin2/failed-transfer\");\n    }\n    function transferFrom(int wad) internal {\n        int256 prevBalance = int(collateral.balanceOf(msg.sender));\n        require(prevBalance >= wad, \"CollateralJoin2/no-funds\");\n        require(int(collateral.allowance(msg.sender, address(this))) >= wad, \"CollateralJoin2/no-allowance\");\n        (bool ok,) = address(collateral).call(\n            abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), wad)\n        );\n        require(ok, \"CollateralJoin2/failed-transfer\");\n        require(uint(prevBalance - wad) == collateral.balanceOf(msg.sender), \"CollateralJoin2/failed-transfer\");\n    }\n    /*\n    * @notify Join collateral tokens in the system\n    * @dev It reverts in case the contract is disabled\n    * @param usr The address that will receive tokens inside the system\n    * @param wad The amount of tokens to join\n    */\n    function join(address usr, uint wad) public {\n        require(contractEnabled == 1, \"CollateralJoin2/contract-not-enabled\");\n        require(wad <= 2 ** 255, \"CollateralJoin2/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, usr, int(wad));\n        transferFrom(int256(wad));\n        emit Join(msg.sender, usr, wad);\n    }\n    /*\n    * @notify Exit collateral tokens from the system and send them to a custom address\n    * @param usr The address that will receive collateral tokens after they are exited\n    * @param wad The amount of tokens to exit\n    */\n    function exit(address usr, uint wad) public {\n        require(wad <= 2 ** 255, \"CollateralJoin2/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, msg.sender, -int(wad));\n        transfer(int(wad), usr);\n        emit Exit(msg.sender, usr, wad);\n    }\n}\n\n// CollateralJoin3\n// For a token that has a lower precision than 18 and doesn't have decimals field in place\n\nabstract contract CollateralLike3 {\n    function transfer(address,uint) virtual public returns (bool);\n    function transferFrom(address,address,uint) virtual public returns (bool);\n}\n\ncontract CollateralJoin3 {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"CollateralJoin3/account-not-authorized\");\n        _;\n    }\n\n    // Safe engine contract\n    SAFEEngineLike_1  public safeEngine;\n    // The name of the collateral type handled by this join contract\n    bytes32         public collateralType;\n    // The collateral token contract\n    CollateralLike3 public collateral;\n    // The number of decimals the collateral has\n    uint            public decimals;\n    // Whether this contract is disabled or not\n    uint            public contractEnabled;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event DisableContract();\n    event Join(address sender, address usr, uint wad);\n    event Exit(address sender, address usr, uint wad);\n\n    constructor(address safeEngine_, bytes32 collateralType_, address collateral_, uint decimals_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine = SAFEEngineLike_1(safeEngine_);\n        collateralType = collateralType_;\n        collateral = CollateralLike3(collateral_);\n        require(decimals_ < 18, \"CollateralJoin3/decimals-higher-18\");\n        decimals = decimals_;\n        contractEnabled = 1;\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addition(uint x, int y) internal pure returns (uint z) {\n        z = x + uint(y);\n        require(y >= 0 || z <= x);\n        require(y <= 0 || z >= x);\n    }\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"CollateralJoin3/overflow\");\n    }\n    function multiply(int x, uint y) internal pure returns (int z) {\n        require(y == 0 || (z = x * int256(y)) / int256(y) == x, \"CollateralJoin3/overflow\");\n    }\n\n    // --- Administration ---\n    /*\n    * @notify Disable this join contract\n    */\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n\n    // --- Collateral Gateway ---\n    /*\n    * @notify Join collateral tokens in the system\n    * @dev It reverts in case the contract is disabled\n    * @param usr The address that will receive tokens inside the system\n    * @param wad The amount of tokens to join\n    */\n    function join(address usr, uint wad) public {\n        require(contractEnabled == 1, \"CollateralJoin3/contract-not-enabled\");\n        uint wad18 = multiply(wad, 10 ** (18 - decimals));\n        require(wad18 <= 2 ** 255, \"CollateralJoin3/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, usr, int(wad18));\n        require(collateral.transferFrom(msg.sender, address(this), wad), \"CollateralJoin3/failed-transfer\");\n        emit Join(msg.sender, usr, wad);\n    }\n    /*\n    * @notify Exit collateral tokens from the system and send them to a custom address\n    * @param usr The address that will receive collateral tokens after they are exited\n    * @param wad The amount of tokens to exit\n    */\n    function exit(address usr, uint wad) public {\n        uint wad18 = multiply(wad, 10 ** (18 - decimals));\n        require(wad18 <= 2 ** 255, \"CollateralJoin3/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, msg.sender, -int(wad18));\n        require(collateral.transfer(usr, wad), \"CollateralJoin3/failed-transfer\");\n        emit Exit(msg.sender, usr, wad);\n    }\n}\n\n/// CollateralJoin4\n\n// Copyright (C) 2019 Lorenzo Manacorda <lorenzo@mailbox.org>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n// For tokens that do not implement transferFrom (like GNT), meaning the usual adapter\n// approach won't work: the adapter cannot call transferFrom and therefore\n// has no way of knowing when users deposit gems into it.\n\n// To work around this, we introduce the concept of a bag, which is a trusted\n// (it's created by the adapter), personalized component (one for each user).\n\n// Users first have to create their bag with `CollateralJoin4.make`, then transfer\n// tokens to it, and then call `CollateralJoin4.join`, which transfer the collateral from the\n// bag to the adapter.\n\nabstract contract CollateralLike4 {\n    function decimals() virtual public view returns (uint);\n    function balanceOf(address) virtual public returns (uint256);\n    function transfer(address, uint256) virtual public returns (bool);\n}\n\ncontract GemBag {\n    address         public ada;\n    address         public lad;\n    CollateralLike4 public collateral;\n\n    constructor(address lad_, address collateral_) public {\n        ada = msg.sender;\n        lad = lad_;\n        collateral = CollateralLike4(collateral_);\n    }\n\n    /*\n    * @notify Transfer tokens out of this bag\n    * @param usr The address that will receive tokens\n    * @param wad The amount of tokens to transfer out of the bag\n    */\n    function exit(address usr, uint256 wad) external {\n        require(msg.sender == ada || msg.sender == lad, \"GemBag/invalid-caller\");\n        require(collateral.transfer(usr, wad), \"GemBag/failed-transfer\");\n    }\n}\n\ncontract CollateralJoin4 {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"CollateralJoin4/account-not-authorized\");\n        _;\n    }\n\n    // Safe engine contract\n    SAFEEngineLike_1  public safeEngine;\n    // The name of the collateral type handled by this join contract\n    bytes32         public collateralType;\n    // The collateral token contract\n    CollateralLike4 public collateral;\n    // The number of decimals the collateral has\n    uint            public decimals;\n    // Whether this contract is disabled or not\n    uint            public contractEnabled;\n\n    // Bags that store tokens joined in the system\n    mapping(address => address) public bags;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event DisableContract();\n    event Join(address sender, address bag, address usr, uint wad);\n    event Exit(address sender, address usr, uint wad);\n\n    constructor(address safeEngine_, bytes32 collateralType_, address collateral_) public {\n        authorizedAccounts[msg.sender] = 1;\n        safeEngine = SAFEEngineLike_1(safeEngine_);\n        collateralType = collateralType_;\n        collateral = CollateralLike4(collateral_);\n        decimals = collateral.decimals();\n        contractEnabled = 1;\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addition(uint x, int y) internal pure returns (uint z) {\n        z = x + uint(y);\n        require(y >= 0 || z <= x);\n        require(y <= 0 || z >= x);\n    }\n\n    // --- Administration ---\n    /*\n    * @notify Disable this contract\n    */\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n\n    // -- Bags --\n    /*\n    * @notify Create a new bag for msg.sender\n    */\n    function make() external returns (address bag) {\n        bag = make(msg.sender);\n    }\n    /*\n    * @notify Create a new bag for a custom address\n    * @param usr The address to create a bag for\n    */\n    function make(address usr) public returns (address bag) {\n        require(bags[usr] == address(0), \"CollateralJoin4/bag-already-exists\");\n        bag = address(new GemBag(address(usr), address(collateral)));\n        bags[usr] = bag;\n    }\n\n    // -- Collateral Gateway ---\n    /*\n    * @notify Join collateral tokens in the system\n    * @dev It reverts in case the contract is disabled\n    * @param usr The address that will receive tokens inside the system\n    * @param wad The amount of tokens to join\n    */\n    function join(address usr, uint256 wad) external {\n        require(contractEnabled == 1, \"CollateralJoin4/contract-not-enabled\");\n        require(int256(wad) >= 0, \"CollateralJoin4/negative-amount\");\n        GemBag(bags[msg.sender]).exit(address(this), wad);\n        safeEngine.modifyCollateralBalance(collateralType, usr, int256(wad));\n        emit Join(msg.sender, bags[msg.sender], usr, wad);\n    }\n    /*\n    * @notify Exit collateral tokens from the system and send them to a custom address\n    * @param usr The address that will receive collateral tokens after they are exited\n    * @param wad The amount of tokens to exit\n    */\n    function exit(address usr, uint256 wad) external {\n        require(int256(wad) >= 0, \"CollateralJoin4/negative-amount\");\n\n        safeEngine.modifyCollateralBalance(collateralType, msg.sender, -int256(wad));\n        require(collateral.transfer(usr, wad), \"CollateralJoin4/failed-transfer\");\n\n        emit Exit(msg.sender, usr, wad);\n    }\n}\n\n// CollateralLike5\n// For a token that has a lower precision than 18 and it has decimals (like USDC)\nabstract contract CollateralLike5 {\n    function decimals() virtual public view returns (uint8);\n    function transfer(address,uint) virtual public returns (bool);\n    function transferFrom(address,address,uint) virtual public returns (bool);\n}\n\ncontract CollateralJoin5 {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"CollateralJoin5/account-not-authorized\");\n        _;\n    }\n\n    // Safe engine contract\n    SAFEEngineLike_1  public safeEngine;\n    // The name of the collateral type handled by this join contract\n    bytes32         public collateralType;\n    // The collateral token contract\n    CollateralLike5 public collateral;\n    // The number of decimals the collateral has\n    uint            public decimals;\n    // Whether this contract is disabled or not\n    uint            public contractEnabled;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event DisableContract();\n    event Join(address sender, address usr, uint wad);\n    event Exit(address sender, address usr, uint wad);\n\n    constructor(address safeEngine_, bytes32 collateralType_, address collateral_) public {\n        collateral = CollateralLike5(collateral_);\n        decimals = collateral.decimals();\n        require(decimals < 18, \"CollateralJoin5/decimals-18-or-higher\");\n\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n\n        safeEngine = SAFEEngineLike_1(safeEngine_);\n        collateralType = collateralType_;\n\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function multiply(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"CollateralJoin5/overflow\");\n    }\n\n    // --- Administration ---\n    /*\n    * @notify Disable this contract\n    */\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n\n    // --- Collateral Gateway ---\n    /*\n    * @notify Join collateral tokens in the system\n    * @dev It reverts in case the contract is disabled\n    * @param usr The address that will receive tokens inside the system\n    * @param wad The amount of tokens to join\n    */\n    function join(address usr, uint wad) public {\n        require(contractEnabled == 1, \"CollateralJoin5/not-contractEnabled\");\n        uint wad18 = multiply(wad, 10 ** (18 - decimals));\n        require(int(wad18) >= 0, \"CollateralJoin5/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, usr, int(wad18));\n        require(collateral.transferFrom(msg.sender, address(this), wad), \"CollateralJoin5/failed-transfer\");\n        emit Join(msg.sender, usr, wad);\n    }\n    /*\n    * @notify Exit collateral tokens from the system and send them to a custom address\n    * @param usr The address that will receive collateral tokens after they are exited\n    * @param wad The amount of tokens to exit\n    */\n    function exit(address usr, uint wad) public {\n        uint wad18 = multiply(wad, 10 ** (18 - decimals));\n        require(int(wad18) >= 0, \"CollateralJoin5/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, msg.sender, -int(wad18));\n        require(collateral.transfer(usr, wad), \"CollateralJoin5/failed-transfer\");\n        emit Exit(msg.sender, usr, wad);\n    }\n}\n\n// For whitelisting addresses that are allowed to join collateral (the collateral type has 18 decimals and implements transferFrom)\ncontract CollateralJoin6 {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"CollateralJoin6/account-not-authorized\");\n        _;\n    }\n\n    // -- Whitelisting ---\n    // Allowances to join collateral into the system\n    mapping(address => uint256) public allowance;\n    // Amount of collateral already joined\n    mapping(address => uint256) public collateralJoined;\n    /**\n     * @notice Change an address' allowance\n     * @param account Account to change the allowance for\n     * @param amount New allowance\n     */\n    function setAllowance(address account, uint256 amount) external isAuthorized {\n        if (both(amount == 0, allowance[account] > 0)) {\n          allowed = addition(allowed, -1);\n        } else if (both(allowance[account] == 0, amount > 0)) {\n          allowed = addition(allowed, uint(1));\n        }\n        allowance[account] = amount;\n        emit SetAllowance(account, amount, allowed);\n    }\n    /**\n    * @notice Checks whether msg.sender can join collateral\n    * @param amount of collateral to join\n    **/\n    function canJoin(uint256 amount) public view returns (bool) {\n        return both(allowance[msg.sender] > 0, addition(amount, collateralJoined[msg.sender]) <= allowance[msg.sender]);\n    }\n\n    // Safe engine contract\n    SAFEEngineLike_1  public safeEngine;\n    // The name of the collateral type handled by this join contract\n    bytes32         public collateralType;\n    // The collateral token contract\n    CollateralLike_1  public collateral;\n    // The number of decimals the collateral has\n    uint            public decimals;\n    // The number of allowed addresses that can add collateral in the system\n    uint            public allowed;\n    // Whether this contract is disabled or not\n    uint            public contractEnabled;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event SetAllowance(address account, uint amount, uint allowed);\n    event DisableContract();\n    event Join(address sender, address usr, uint wad);\n    event Exit(address sender, address usr, uint wad);\n\n    constructor(address safeEngine_, bytes32 collateralType_, address collateral_) public {\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n        safeEngine = SAFEEngineLike_1(safeEngine_);\n        collateralType = collateralType_;\n        collateral = CollateralLike_1(collateral_);\n        decimals = collateral.decimals();\n        require(decimals == 18, \"CollateralJoin6/not-18-decimals\");\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addition(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function addition(uint x, int y) internal pure returns (uint z) {\n        z = x + uint(y);\n        require(y >= 0 || z <= x);\n        require(y <= 0 || z >= x);\n    }\n    function subtract(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n\n    // --- Administration ---\n    /*\n    * @notify Disable this contract\n    */\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n\n    // --- Utils ---\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    // --- Collateral Gateway ---\n    /*\n    * @notify Join collateral tokens in the system\n    * @dev It reverts in case the contract is disabled\n    * @param usr The address that will receive tokens inside the system\n    * @param wad The amount of tokens to join\n    */\n    function join(address usr, uint wad) external {\n        require(contractEnabled == 1, \"CollateralJoin6/not-contractEnabled\");\n        require(canJoin(wad), \"CollateralJoin6/cannot-join-above-allowance\");\n        require(int(wad) >= 0, \"CollateralJoin6/overflow\");\n        collateralJoined[msg.sender] = addition(collateralJoined[msg.sender], wad);\n        safeEngine.modifyCollateralBalance(collateralType, usr, int(wad));\n        require(collateral.transferFrom(msg.sender, address(this), wad), \"CollateralJoin6/failed-transfer\");\n        emit Join(msg.sender, usr, wad);\n    }\n    /*\n    * @notify Exit collateral tokens from the system and send them to a custom address\n    * @param usr The address that will receive collateral tokens after they are exited\n    * @param wad The amount of tokens to exit\n    */\n    function exit(address usr, uint wad) external {\n        require(wad <= 2 ** 255, \"CollateralJoin6/overflow\");\n        if (collateralJoined[msg.sender] >= wad) {\n          collateralJoined[msg.sender] = subtract(collateralJoined[msg.sender], wad);\n        } else {\n          collateralJoined[msg.sender] = 0;\n        }\n        safeEngine.modifyCollateralBalance(collateralType, msg.sender, -int(wad));\n        require(collateral.transfer(usr, wad), \"CollateralJoin6/failed-transfer\");\n        emit Exit(msg.sender, usr, wad);\n    }\n}\n\n// AuthCollateralJoin\ncontract AuthCollateralJoin {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"AuthCollateralJoin/account-not-authorized\");\n        _;\n    }\n\n    // Safe engine contract\n    SAFEEngineLike_1  public safeEngine;\n    // The name of the collateral type handled by this join contract\n    bytes32         public collateralType;\n    // The collateral token contract\n    CollateralLike_1  public collateral;\n    // The number of decimals the collateral has\n    uint            public decimals;\n    // Whether this contract is disabled or not\n    uint            public contractEnabled;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event DisableContract();\n    event Join(address sender, address usr, uint wad);\n    event Exit(address sender, address usr, uint wad);\n\n    constructor(address safeEngine_, bytes32 collateralType_, address collateral_) public {\n        safeEngine = SAFEEngineLike_1(safeEngine_);\n        collateralType = collateralType_;\n        collateral = CollateralLike_1(collateral_);\n        decimals = collateral.decimals();\n\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addition(uint x, int y) internal pure returns (uint z) {\n        z = x + uint(y);\n        require(y >= 0 || z <= x);\n        require(y <= 0 || z >= x);\n    }\n\n    // --- Administration ---\n    /*\n    * @notify Disable this contract\n    */\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n\n    // --- Collateral Gateway ---\n    /*\n    * @notify Join collateral tokens in the system\n    * @dev It reverts in case the contract is disabled\n    * @param usr The address that will receive tokens inside the system\n    * @param wad The amount of tokens to join\n    */\n    function join(address usr, uint wad) public isAuthorized {\n        require(contractEnabled == 1, \"AuthCollateralJoin/contract-not-enabled\");\n        require(int(wad) >= 0, \"AuthCollateralJoin/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, usr, int(wad));\n        require(collateral.transferFrom(msg.sender, address(this), wad), \"AuthCollateralJoin/failed-transfer\");\n        emit Join(msg.sender, usr, wad);\n    }\n    /*\n    * @notify Exit collateral tokens from the system and send them to a custom address\n    * @param usr The address that will receive collateral tokens after they are exited\n    * @param wad The amount of tokens to exit\n    */\n    function exit(address usr, uint wad) public isAuthorized {\n        require(wad <= 2 ** 255, \"AuthCollateralJoin/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, msg.sender, -int(wad));\n        require(collateral.transfer(usr, wad), \"AuthCollateralJoin/failed-transfer\");\n        emit Exit(msg.sender, usr, wad);\n    }\n}\n\nabstract contract IERC3156FlashBorrowerLike {\n\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external payable virtual returns (bytes32);\n}\n\n// CollateralJoin2\n\n// For standard tokens (CollateralJoin1) that allows for flashloans\n\nabstract contract CollateralLike7 {\n    function decimals() virtual public view returns (uint);\n    function transfer(address,uint) virtual public returns (bool);\n    function transferFrom(address,address,uint) virtual public returns (bool);\n    function balanceOf(address) virtual public view returns (uint);\n}\n\ncontract CollateralJoin7 is ReentrancyGuard {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"CollateralJoin7/account-not-authorized\");\n        _;\n    }\n\n    // Safe engine contract\n    SAFEEngineLike_1   public safeEngine;\n    // The name of the collateral type handled by this join contract\n    bytes32          public collateralType;\n    // The collateral token contract\n    CollateralLike7  public collateral;\n    // The number of decimals the collateral has\n    uint             public decimals;\n    // Whether this contract is disabled or not\n    uint             public contractEnabled;\n    // flashloan fee receiver\n    address          public feeReceiver;\n    // fee charged for flashloans (WAD, 100% == 1 WAD)\n    uint256          public flashLoanFee;\n    // callback success hash\n    bytes32 constant public  CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    uint256 constant        WAD = 10 ** 18;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event DisableContract();\n    event Join(address sender, address usr, uint wad);\n    event Exit(address sender, address usr, uint wad);\n    event ModifyParameters(bytes32 indexed parameter, uint256 data);\n    event ModifyParameters(bytes32 indexed parameter, address data);\n\n    constructor(\n        address safeEngine_,\n        bytes32 collateralType_,\n        address collateral_,\n        uint256 flashLoanFee_,\n        address payable feeReceiver_\n    ) public {\n        require(feeReceiver_ != address(0), \"CollateralJoin7/null-fee-receiver\");\n        authorizedAccounts[msg.sender] = 1;\n        contractEnabled = 1;\n\n        safeEngine = SAFEEngineLike_1(safeEngine_);\n        collateralType = collateralType_;\n        collateral = CollateralLike7(collateral_);\n        decimals = collateral.decimals();\n        flashLoanFee = flashLoanFee_;\n        feeReceiver  = feeReceiver_;\n\n        require(decimals == 18, \"CollateralJoin7/not-18-decimals\");\n\n        emit ModifyParameters(\"flashLoanFee\", flashLoanFee_);\n        emit ModifyParameters(\"feeReceiver\", feeReceiver_);\n        emit AddAuthorization(msg.sender);\n    }\n\n    // --- Math ---\n    function addition(uint x, int y) internal pure returns (uint z) {\n        z = x + uint(y);\n        require(y >= 0 || z <= x, \"CollateralJoin7/add-overflow\");\n        require(y <= 0 || z >= x, \"CollateralJoin7/add-overflow\");\n    }\n    function addition(uint x, uint y) internal pure returns (uint z) {\n        z = x + y;\n        require(z >= x, \"CollateralJoin7/add-overflow\");\n    }\n    function multiply(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"CollateralJoin7/mul-overflow\");\n    }\n\n    // --- Administration ---\n    /*\n    * @notify Disable this join contract\n    */\n    function disableContract() external isAuthorized {\n        contractEnabled = 0;\n        emit DisableContract();\n    }\n    /**\n     * @notice Modify an uint256 param\n     * @param parameter The name of the parameter modified\n     * @param data New value for the parameter\n     */\n    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n        if (parameter == \"flashLoanFee\") flashLoanFee = data;\n        else revert(\"CollateralJoin7/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n    /**\n     * @notice Modify an uint256 param\n     * @param parameter The name of the parameter modified\n     * @param data New value for the parameter\n     */\n    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n        require(data != address(0), \"CollateralJoin7/null-data\");\n        if (parameter == \"feeReceiver\") feeReceiver = payable(data);\n        else revert(\"CollateralJoin7/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, data);\n    }\n\n    // --- Collateral Gateway ---\n    /*\n    * @notify Join collateral tokens in the system\n    * @dev It reverts in case the contract is disabled\n    * @param usr The address that will receive tokens inside the system\n    * @param wad The amount of tokens to join\n    */\n    function join(address usr, uint wad) external nonReentrant {\n        require(contractEnabled == 1, \"CollateralJoin7/not-contractEnabled\");\n        require(int(wad) >= 0, \"CollateralJoin7/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, usr, int(wad));\n        require(collateral.transferFrom(msg.sender, address(this), wad), \"CollateralJoin7/failed-transfer\");\n        emit Join(msg.sender, usr, wad);\n    }\n    /*\n    * @notify Exit collateral tokens from the system and send them to a custom address\n    * @param usr The address that will receive collateral tokens after they are exited\n    * @param wad The amount of tokens to exit\n    */\n    function exit(address usr, uint wad) external nonReentrant {\n        require(wad <= 2 ** 255, \"CollateralJoin7/overflow\");\n        safeEngine.modifyCollateralBalance(collateralType, msg.sender, -int(wad));\n        require(collateral.transfer(usr, wad), \"CollateralJoin7/failed-transfer\");\n        emit Exit(msg.sender, usr, wad);\n    }\n\n    // --- Flash Loan ---\n    /**\n     * @dev Initiate a flash loan.\n     * @notice Token variable is unused, maintained to maintain compatibility with EIP-3156\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrowerLike receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external nonReentrant returns (bool) {\n        require(contractEnabled == 1, \"CollateralJoin7/not-contractEnabled\");\n        require(amount > 0, \"CollateralJoin7/null-amount\");\n        uint256 initialBalance = collateral.balanceOf(address(this));\n        uint256 fee            = flashFee(token, amount);\n\n        // transfer eth to borrower\n        require(collateral.transfer(address(receiver), amount), \"CollateralJoin7/transfer-failed\");\n\n        // calls borrower, payment should be sent to this contract within the callback\n        require(\n            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == CALLBACK_SUCCESS,\n            \"CollateralJoin7/callback-failed\"\n        );\n\n        // check repayment\n        require (collateral.balanceOf(address(this)) == addition(initialBalance, fee), \"CollateralJoin7/loan-not-fully-paid\");\n\n        // send fees to feeReceiver\n        require(collateral.transfer(feeReceiver, fee), \"CollateralJoin7/transfer-failed\");\n        return true;\n    }\n\n\n    // --- Getters ---\n    /**\n     * @dev The amount of currency available to be lent.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(\n        address token\n    ) external view returns (uint256) {\n        require (token == address(collateral), \"CollateralJoin7/invalid-token\");\n        return collateral.balanceOf(address(this));\n    }\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @notice Token variable is unused, maintained to maintain compatibility with EIP-3156\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(\n        address token,\n        uint256 amount\n    ) public view returns (uint256) {\n        require (token == address(collateral), \"CollateralJoin7/invalid-token\");\n        return multiply(amount, flashLoanFee) / WAD;\n    }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"safeEngine_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"collateralType_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"collateral_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DisableContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Exit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Join\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemoveAuthorization\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateral\",\"outputs\":[{\"internalType\":\"contract CollateralLike_1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralType\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractEnabled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"join\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeEngine\",\"outputs\":[{\"internalType\":\"contract SAFEEngineLike_1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CollateralJoin1", "CompilerVersion": "v0.6.7+commit.b8d736ae", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001e6afa340851d60e75be38494813c09b3356a0094f4345414e2d4100000000000000000000000000000000000000000000000000000000000000000000000000967da4048cd07ab37855c090aaf366e4ce1b9f48", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}