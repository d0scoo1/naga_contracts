{"status": "1", "message": "OK", "result": [{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n//////////////////////////////////////////////////////////////////\r\n//     __  ___         __  _                                    //\r\n//    /  |/  /__ _____/ /_(_)__ ____  ___                       //\r\n//   / /|_/ / _ `/ __/ __/ / _ `/ _ \\(_-<                       //\r\n//  /_/  /_/\\_,_/_/  \\__/_/\\_,_/_//_/___/                       //\r\n//                                                              //\r\n//    _____                 _ __    ___                  __     //\r\n//   / ___/__  __ _  __ _  (_) /_  / _ )___ ____ ___ ___/ /     //\r\n//  / /__/ _ \\/  ' \\/  ' \\/ / __/ / _  / _ `(_-</ -_) _  /      //\r\n//  \\___/\\___/_/_/_/_/_/_/_/\\__/ /____/\\_,_/___/\\__/\\_,_/       //\r\n//                                                              //\r\n//     ___       ________                                       //\r\n//    / _ \\___ _/ _/ _/ /__                                     //\r\n//   / , _/ _ `/ _/ _/ / -_)                                    //\r\n//  /_/|_|\\_,_/_//_//_/\\__/                                     //\r\n//                                                              //\r\n//  by: 0xInuarashi.eth                                         //\r\n////////////////////////////////////////////////////////////////// \r\n\r\nabstract contract Ownable {\r\n    address public owner; \r\n    constructor() { owner = msg.sender; }\r\n    modifier onlyOwner { require(owner == msg.sender, \"Not Owner!\"); _; }\r\n    function transferOwnership(address new_) external onlyOwner { owner = new_; }\r\n}\r\n\r\ninterface iCS {\r\n\r\n    struct Character {\r\n        // general info\r\n        uint8 race_;\r\n        uint8 renderType_;\r\n\r\n        // equipment\r\n        uint16 transponderId_;\r\n        uint16 spaceCapsuleId_;\r\n\r\n        // stats\r\n        uint8 augments_;\r\n        uint16 basePoints_;\r\n        uint16 totalEquipmentBonus_;\r\n    }\r\n\r\n    function characters(uint256 tokenId_) external view returns (Character memory);\r\n}\r\n\r\ninterface iMES {\r\n    function transferFrom(address from_, address to_, uint256 amount_) external;\r\n    function burn(address from_, uint256 amount_) external;\r\n}\r\n\r\ninterface IERC721 {\r\n    function balanceOf(address owner_) external view returns (uint256); \r\n}\r\n\r\ncontract MESCommitBasedRaffle is Ownable {\r\n\r\n    // M a r t i a n  E s s e n c e \r\n    iMES public MES = iMES(0x3C2Eb40D25a4b2B5A068a959a40d57D63Dc98B95);\r\n\r\n    // M a r t i a n s \r\n    IERC721 public Martians = IERC721(0x075854b315F2cd7eC490853Bc5589B09E546449f);\r\n\r\n    // M a r t i a n s  C h a r a c t e r  S t o r a g e \r\n    iCS public CS = iCS(0xC7C40032E952F52F1ce7472913CDd8EeC89521c4);\r\n\r\n    // For a commit-based raffle, we need to store somewhere the index of users as well\r\n    // as user-data.\r\n\r\n    // Then, we can pull a seed with provably-fair randomness and then use\r\n    // that randomness as inertia for a compute-intensive on-chain result.\r\n\r\n    // Gas cost is conscious in this contract.\r\n\r\n    // First, we define an interia.\r\n    bytes32 public raffleInertia;\r\n    \r\n    // We then have a inertia pull method.\r\n    function pullRaffleInertia() external onlyOwner {\r\n        // Pulling is a 1-time function.\r\n        require(raffleInertia == 0,\r\n            \"Inertia already set\");\r\n\r\n        // A pseudo-random generated bytes32. For provably-fair, change this.\r\n        raffleInertia = keccak256(abi.encodePacked(\r\n            block.timestamp, block.difficulty, blockhash(block.number)));\r\n    }\r\n\r\n    // Now, we need to set some commit-based raffle logics.\r\n    struct CommitData {\r\n        address entrant; // 20 | 12\r\n        uint64 entries; // 8 | 4\r\n    }\r\n\r\n    // 2 SSTORE are necessary to do this on-chain with flexibility.\r\n    CommitData[] public commitData;\r\n    function viewCommitData() external view returns (CommitData[] memory) {\r\n        return commitData;\r\n    }\r\n\r\n    // Then, we set some raffle logics\r\n    // uint256 public weiPerEntry = 1 ether;\r\n\r\n    // Benchmark: 58,304 GAS Units\r\n    // commitBasedRaffleOffChainERC20.sol: 43,431 GAS Units \r\n\r\n    // Numbers without any require statements and reading additional SSTORES...\r\n    // 67,424 GAS Units per TX using ERC20I with full approval (no approve SSTORE update)\r\n    // 70,677 GAS Units per TX using ERC20I with partial approval (approve SSTORE update)\r\n\r\n    // Numbers with require statement... (2120 additional GAS)\r\n    // 69,544 GAS Units per TX using ERC20I with full approval (no approve SSTORE update)\r\n    // 72,797 GAS Units per TX using ERC20I with partial approval (approve SSTORE update)\r\n\r\n    function raffleCommit(uint256 amount_, uint256 tokenId_) external {\r\n        require(raffleInertia == 0, \r\n            \"Raffle Inertia set! Raffles closed!\");\r\n\r\n        // We hardcode weiPerEntry for gas savings\r\n        uint256 _entries = amount_ / 5 ether;\r\n\r\n        // Instantiate the multipler into local memory\r\n        uint256 _multiplier = 1;\r\n\r\n        // Here, we check for tokenId for augmentation\r\n        // If the tokenId is not 0, means there is an input.\r\n        if (tokenId_ != 0) {\r\n            iCS.Character memory _Character = CS.characters(tokenId_);\r\n            \r\n            // If the token is fully augmented\r\n            if (_Character.augments_ == 10) {\r\n                // Multiply their entries by 3\r\n                _multiplier = 3;\r\n            }\r\n        } \r\n\r\n        // If the tokenId_ is 0, there is no target character. See if they are a holder.\r\n        else {\r\n            // If they have a balance\r\n            if (Martians.balanceOf(msg.sender) > 0) {\r\n                // Multiply their entries by 2\r\n                _multiplier = 2;\r\n            }\r\n        }\r\n\r\n        // Recalculate the entries with the multipler\r\n        _entries = _entries * _multiplier;\r\n\r\n        require(_entries > 0,\r\n            \"Invalid amount of entries!\");\r\n\r\n        // MES.transferFrom(msg.sender, address(this), amount_);\r\n\r\n        // We replace a standard ERC20 transferFrom to a custom burn to save gas\r\n        MES.burn(msg.sender, amount_);\r\n\r\n        commitData.push( \r\n            CommitData(\r\n                msg.sender, \r\n                uint64(_entries)\r\n        ));\r\n    }\r\n\r\n    // Now, we need to create some pulling logic. Gas intensive view-function.\r\n    function _getTotalEntries() public view returns (uint256) {\r\n        // Find the total entries\r\n        uint256 _totalEntries;\r\n        for (uint256 i = 0; i < commitData.length; i++) {\r\n            _totalEntries += commitData[i].entries;\r\n        }\r\n        return _totalEntries;\r\n    }\r\n\r\n    function _getInertiaOfIndex(uint256 index_, uint256 modulo_) public \r\n    view returns (uint256) {\r\n        require(raffleInertia != 0, \r\n            \"raffleInertia not set yet!\");\r\n        \r\n        return uint256(keccak256(abi.encodePacked(\r\n            raffleInertia, index_\r\n        ))) % modulo_;\r\n    }\r\n\r\n    function _getRaffleWinner(uint256 index_, uint256 modulo_) public \r\n    view returns (address) {\r\n        // Find the total entries\r\n        uint256 _modulo = modulo_ == 0 ? (_getTotalEntries() + 1) : modulo_;\r\n\r\n        // Now, pull an inertia with the amount of entries\r\n        uint256 _winningEntry = _getInertiaOfIndex(index_, _modulo); \r\n\r\n        // Now, we find the winner of the index.\r\n        uint256 _currentEntry;\r\n        address _winner;\r\n        uint256 i;\r\n        while (_winner == address(0)) {\r\n            uint256 _previousEntries = _currentEntry;\r\n            _currentEntry += commitData[i].entries;\r\n            if (_previousEntries < _winningEntry \r\n                && _currentEntry >= _winningEntry) { \r\n                _winner = commitData[i].entrant;\r\n            }\r\n            i++;\r\n        }\r\n        return _winner;\r\n    }\r\n\r\n    // Pagination for Read Limit Safety\r\n    function getRaffleWinnerFromInertia(uint256 inertia_) public\r\n    view returns (address) {\r\n        // Now, we find the winner of the index.\r\n        uint256 _currentEntry;\r\n        address _winner;\r\n        uint256 i;\r\n        while (_winner == address(0)) {\r\n            uint256 _previousEntries = _currentEntry;\r\n            _currentEntry += commitData[i].entries;\r\n            if (_previousEntries < inertia_ \r\n                && _currentEntry >= inertia_) { \r\n                _winner = commitData[i].entrant;\r\n            }\r\n            i++;\r\n        }\r\n        return _winner;   \r\n    }\r\n\r\n    function viewRaffleResultsPaginated(uint256 start_, uint256 end_) external\r\n    view returns (address[] memory) {\r\n        uint256 _iterations = end_ - start_ + 1;\r\n        uint256 _totalEntries = _getTotalEntries() + 1;\r\n        address[] memory _winners = new address[](_iterations);\r\n        uint256 _index;\r\n\r\n        for (uint256 i = start_; i <= end_; i++) {\r\n            _winners[_index++] = _getRaffleWinner(i, _totalEntries);\r\n        }\r\n\r\n        return _winners;\r\n    }\r\n    function viewInertiaResultsPaginated(uint256 start_, uint256 end_) external\r\n    view returns (uint256[] memory) {\r\n        uint256 _iterations = end_ - start_ + 1;\r\n        uint256 _totalEntries = _getTotalEntries() + 1;\r\n        uint256[] memory _winners = new uint256[](_iterations);\r\n        uint256 _index;\r\n\r\n        for (uint256 i = start_; i <= end_; i++) {\r\n            _winners[_index++] = _getInertiaOfIndex(i, _totalEntries);\r\n        }\r\n\r\n        return _winners;\r\n    }\r\n\r\n    // Tested on Etherscan @ 2022-05-10 => \r\n    //  10000 Items in Array - 150 Results [/]\r\n    //  20000 Items in Array - 75 Results [/]\r\n    function viewRaffleResults(uint256 amountOfWinners_) external \r\n    view returns (address[] memory) {\r\n        uint256 _totalEntries = _getTotalEntries() + 1;\r\n        address[] memory _winners = new address[](amountOfWinners_);\r\n        for (uint256 i = 0; i < amountOfWinners_; i++) {\r\n            _winners[i] = _getRaffleWinner(i, _totalEntries);\r\n        }\r\n        return _winners;\r\n    }\r\n    function viewInertiaResults(uint256 amountOfWinners_) external \r\n    view returns (uint256[] memory) {\r\n        uint256 _totalEntries = _getTotalEntries() + 1;\r\n        uint256[] memory _winners = new uint256[](amountOfWinners_);\r\n        for (uint256 i = 0; i < amountOfWinners_; i++) {\r\n            _winners[i] = _getInertiaOfIndex(i, _totalEntries);\r\n        }\r\n        return _winners;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"CS\",\"outputs\":[{\"internalType\":\"contract iCS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MES\",\"outputs\":[{\"internalType\":\"contract iMES\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Martians\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"modulo_\",\"type\":\"uint256\"}],\"name\":\"_getInertiaOfIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"modulo_\",\"type\":\"uint256\"}],\"name\":\"_getRaffleWinner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getTotalEntries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"commitData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"entrant\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"entries\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inertia_\",\"type\":\"uint256\"}],\"name\":\"getRaffleWinnerFromInertia\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pullRaffleInertia\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"raffleCommit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raffleInertia\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewCommitData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"entrant\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"entries\",\"type\":\"uint64\"}],\"internalType\":\"struct MESCommitBasedRaffle.CommitData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOfWinners_\",\"type\":\"uint256\"}],\"name\":\"viewInertiaResults\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end_\",\"type\":\"uint256\"}],\"name\":\"viewInertiaResultsPaginated\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOfWinners_\",\"type\":\"uint256\"}],\"name\":\"viewRaffleResults\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end_\",\"type\":\"uint256\"}],\"name\":\"viewRaffleResultsPaginated\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MESCommitBasedRaffle", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b14d7e18feb76afbaafcafc24ffa66d4b6eb7a5e1bcd5b1aff2791df77ea026d"}]}