{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.8.10;\r\n \r\n// SPDX-License-Identifier: MIT\r\n \r\ncontract LifeStake {\r\n    //constant\r\n    uint256 public constant percentDivider = 1_000;\r\n    uint256 public maxStake = 2_500_000_000;\r\n    uint256 public minStake = 10_000;\r\n    uint256 public totalStaked;\r\n    uint256 public currentStaked;\r\n    uint256 public TimeStep = 1 days;\r\n    //address\r\n    IERC20 public TOKEN;\r\n    address payable public Admin;\r\n    address payable public RewardAddress;\r\n \r\n    // structures\r\n    struct Stake {\r\n        uint256 StakePercent;\r\n        uint256 StakePeriod;\r\n    }\r\n    struct Staker {\r\n        uint256 Amount;\r\n        uint256 Claimed;\r\n        uint256 Claimable;\r\n        uint256 MaxClaimable;\r\n        uint256 TokenPerDay;\r\n        uint256 LastClaimTime;\r\n        uint256 UnStakeTime;\r\n        uint256 StakeTime;\r\n    }\r\n \r\n    Stake public StakeI;\r\n    Stake public StakeII;\r\n    Stake public StakeIII;\r\n    // mapping & array\r\n    mapping(address => Staker) private PlanI;\r\n    mapping(address => Staker) private PlanII;\r\n    mapping(address => Staker) private PlanIII;\r\n \r\n    modifier onlyAdmin() {\r\n        require(msg.sender == Admin, \"Stake: Not an Admin\");\r\n        _;\r\n    }\r\n    modifier validDepositId(uint256 _depositId) {\r\n        require(_depositId >= 1 && _depositId <= 3, \"Invalid depositId\");\r\n        _;\r\n    }\r\n \r\n    constructor(address _TOKEN) {\r\n        Admin = payable(msg.sender);\r\n        RewardAddress = payable(msg.sender);\r\n        TOKEN = IERC20(_TOKEN);\r\n        StakeI.StakePercent = 25;\r\n        StakeI.StakePeriod = 30 days;\r\n \r\n        StakeII.StakePercent = 175;\r\n        StakeII.StakePeriod = 180 days;\r\n \r\n        StakeIII.StakePercent = 390;\r\n        StakeIII.StakePeriod = 360 days;\r\n \r\n        maxStake = maxStake * (10**TOKEN.decimals());\r\n        minStake = minStake * (10**TOKEN.decimals());\r\n    }\r\n \r\n    receive() external payable {}\r\n \r\n    // to buy  token during Stake time => for web3 use\r\n    function deposit(uint256 _depositId, uint256 _amount)\r\n        public\r\n        validDepositId(_depositId)\r\n    {\r\n        require(currentStaked <= maxStake, \"MaxStake limit reached\");\r\n        require(_amount >= minStake, \"Deposit more than 10_000\");\r\n        TOKEN.transferFrom(msg.sender, address(this), _amount);\r\n        totalStaked = totalStaked + (_amount);\r\n        currentStaked = currentStaked + (_amount);\r\n \r\n        if (_depositId == 1) {\r\n            PlanI[msg.sender].Claimable = calcRewards(msg.sender, _depositId);\r\n            PlanI[msg.sender].Amount = PlanI[msg.sender].Amount + (_amount);\r\n            PlanI[msg.sender].TokenPerDay = (\r\n                CalculatePerDay(\r\n                    (((PlanI[msg.sender].Amount * (StakeI.StakePercent)) /\r\n                        (percentDivider)) ) + calcRewards(msg.sender, _depositId),\r\n                    StakeI.StakePeriod\r\n                )\r\n            );\r\n            PlanI[msg.sender].MaxClaimable =\r\n                ((PlanI[msg.sender].Amount * (StakeI.StakePercent)) /\r\n                    (percentDivider)) +\r\n                PlanI[msg.sender].Claimable;\r\n \r\n            PlanI[msg.sender].LastClaimTime = block.timestamp;\r\n \r\n            PlanI[msg.sender].StakeTime = block.timestamp;\r\n            PlanI[msg.sender].UnStakeTime =\r\n                block.timestamp +\r\n                (StakeI.StakePeriod);\r\n            PlanI[msg.sender].Claimed = 0; \r\n        } else if (_depositId == 2) {\r\n            PlanII[msg.sender].Claimable = calcRewards(msg.sender, _depositId);\r\n \r\n            PlanII[msg.sender].Amount = PlanII[msg.sender].Amount + (_amount);\r\n            PlanII[msg.sender].TokenPerDay = (\r\n                CalculatePerDay(\r\n                    (((PlanII[msg.sender].Amount * (StakeII.StakePercent)) /\r\n                        (percentDivider)) + calcRewards(msg.sender, _depositId)),\r\n                    StakeII.StakePeriod\r\n                )\r\n            );\r\n            PlanII[msg.sender].MaxClaimable =\r\n                ((PlanII[msg.sender].Amount * (StakeII.StakePercent)) /\r\n                    (percentDivider)) +\r\n                PlanII[msg.sender].Claimable;\r\n \r\n            PlanII[msg.sender].LastClaimTime = block.timestamp;\r\n \r\n            PlanII[msg.sender].StakeTime = block.timestamp;\r\n            PlanII[msg.sender].UnStakeTime =\r\n                block.timestamp +\r\n                (StakeII.StakePeriod);\r\n            PlanII[msg.sender].Claimed = 0;\r\n        } else if (_depositId == 3) {\r\n            PlanIII[msg.sender].Claimable = calcRewards(msg.sender, _depositId);\r\n            PlanIII[msg.sender].Amount = PlanIII[msg.sender].Amount + (_amount);\r\n            PlanIII[msg.sender].TokenPerDay = (\r\n                CalculatePerDay(\r\n                    (((PlanIII[msg.sender].Amount * (StakeIII.StakePercent)) /\r\n                        (percentDivider)) ) + calcRewards(msg.sender, _depositId),\r\n                    StakeIII.StakePeriod\r\n                )\r\n            );\r\n            PlanIII[msg.sender].MaxClaimable =\r\n                ((PlanIII[msg.sender].Amount * (StakeIII.StakePercent)) /\r\n                    (percentDivider)) +\r\n                PlanIII[msg.sender].Claimable;\r\n \r\n            PlanIII[msg.sender].LastClaimTime = block.timestamp;\r\n \r\n            PlanIII[msg.sender].StakeTime = block.timestamp;\r\n            PlanIII[msg.sender].UnStakeTime =\r\n                block.timestamp +\r\n                (StakeIII.StakePeriod);\r\n            PlanIII[msg.sender].Claimed = 0;\r\n        }\r\n    }\r\n    function extendLockup(uint256 _depositId)\r\n        public\r\n        validDepositId(_depositId)\r\n    {\r\n        require(currentStaked <= maxStake, \"MaxStake limit reached\");\r\n        totalStaked = totalStaked + (calcRewards(msg.sender, _depositId));\r\n \r\n        currentStaked = currentStaked + (calcRewards(msg.sender, _depositId));\r\n        if(calcRewards(msg.sender, _depositId) > 0)\r\n        {\r\n            TOKEN.transferFrom(RewardAddress, address(this),calcRewards(msg.sender, _depositId) );\r\n        }\r\n        if (_depositId == 1) {\r\n            require(PlanI[msg.sender].Amount > 0, \"not staked1\");\r\n \r\n            PlanI[msg.sender].Amount = PlanI[msg.sender].Amount + (calcRewards(msg.sender, _depositId));\r\n            PlanI[msg.sender].TokenPerDay = (\r\n                CalculatePerDay(\r\n                    ((PlanI[msg.sender].Amount * (StakeI.StakePercent)) /\r\n                        (percentDivider)),\r\n                    StakeI.StakePeriod\r\n                )\r\n            );\r\n            PlanI[msg.sender].MaxClaimable =\r\n                ((PlanI[msg.sender].Amount * (StakeI.StakePercent)) /\r\n                    (percentDivider)) ;\r\n \r\n            PlanI[msg.sender].LastClaimTime = block.timestamp;\r\n \r\n            PlanI[msg.sender].StakeTime = block.timestamp;\r\n            PlanI[msg.sender].UnStakeTime =\r\n                block.timestamp +\r\n                (StakeI.StakePeriod);\r\n            PlanI[msg.sender].Claimable = 0;\r\n            PlanI[msg.sender].Claimed = 0;\r\n        } else if (_depositId == 2) {\r\n            require(PlanII[msg.sender].Amount > 0, \"not staked2\");\r\n \r\n            PlanII[msg.sender].Amount = PlanII[msg.sender].Amount + (calcRewards(msg.sender, _depositId));\r\n            PlanII[msg.sender].TokenPerDay = (\r\n                CalculatePerDay(\r\n                    ((PlanII[msg.sender].Amount * (StakeII.StakePercent)) /\r\n                        (percentDivider)),\r\n                    StakeII.StakePeriod\r\n                )\r\n            );\r\n            PlanII[msg.sender].MaxClaimable =\r\n                ((PlanII[msg.sender].Amount * (StakeII.StakePercent)) /\r\n                    (percentDivider)) ;\r\n \r\n            PlanII[msg.sender].LastClaimTime = block.timestamp;\r\n \r\n            PlanII[msg.sender].StakeTime = block.timestamp;\r\n            PlanII[msg.sender].UnStakeTime =\r\n                block.timestamp +\r\n                (StakeII.StakePeriod);\r\n            PlanII[msg.sender].Claimable = 0;\r\n            PlanII[msg.sender].Claimed = 0;\r\n        } else if (_depositId == 3) {\r\n            require(PlanIII[msg.sender].Amount > 0, \"not staked3\");\r\n            PlanIII[msg.sender].Claimable = 0;\r\n            PlanIII[msg.sender].Amount = PlanIII[msg.sender].Amount + (calcRewards(msg.sender, _depositId));\r\n            PlanIII[msg.sender].TokenPerDay = (\r\n                CalculatePerDay(\r\n                    ((PlanIII[msg.sender].Amount * (StakeIII.StakePercent)) /\r\n                        (percentDivider)),\r\n                    StakeIII.StakePeriod\r\n                )\r\n            );\r\n            PlanIII[msg.sender].MaxClaimable =\r\n                ((PlanIII[msg.sender].Amount * (StakeIII.StakePercent)) /\r\n                    (percentDivider)) ;\r\n \r\n            PlanIII[msg.sender].LastClaimTime = block.timestamp;\r\n \r\n            PlanIII[msg.sender].StakeTime = block.timestamp;\r\n            PlanIII[msg.sender].UnStakeTime =\r\n                block.timestamp +\r\n                (StakeIII.StakePeriod);\r\n            PlanIII[msg.sender].Claimable = 0;\r\n            PlanIII[msg.sender].Claimed = 0;\r\n        }\r\n    }\r\n    function withdrawAll(uint256 _depositId)\r\n        external\r\n        validDepositId(_depositId)\r\n    {\r\n        require(calcRewards(msg.sender,_depositId) > 0,\"no claimable amount available yet\");\r\n        _withdraw(msg.sender, _depositId);\r\n    }\r\n \r\n    function _withdraw(address _user, uint256 _depositId)\r\n        internal\r\n        validDepositId(_depositId)\r\n    {\r\n        if (_depositId == 1) {\r\n            require(PlanI[_user].Claimed <= PlanI[_user].MaxClaimable,\"no claimable amount available3\");\r\n            require(block.timestamp > PlanI[_user].LastClaimTime,\"time not reached3\");\r\n \r\n \r\n            if (calcRewards(_user, _depositId) > 0) {\r\n                TOKEN.transferFrom(RewardAddress, _user, calcRewards(_user, _depositId));\r\n            }\r\n            PlanI[_user].Claimed = PlanI[_user].Claimed + (calcRewards(_user, _depositId));\r\n            PlanI[_user].LastClaimTime = block.timestamp;\r\n            PlanI[_user].Claimable = 0;\r\n        }\r\n        if (_depositId == 2) {\r\n            require(PlanII[_user].Claimed <= PlanII[_user].MaxClaimable,\"no claimable amount available3\");\r\n            require(block.timestamp > PlanII[_user].LastClaimTime,\"time not reached3\");\r\n \r\n \r\n            if (calcRewards(_user, _depositId) > 0) {\r\n                TOKEN.transferFrom(RewardAddress, _user, calcRewards(_user, _depositId));\r\n            }\r\n            PlanII[_user].Claimed = PlanII[_user].Claimed + (calcRewards(_user, _depositId));\r\n            PlanII[_user].LastClaimTime = block.timestamp;\r\n            PlanII[_user].Claimable = 0;\r\n        }\r\n \r\n        if (_depositId == 3) {\r\n            require(PlanIII[_user].Claimed <= PlanIII[_user].MaxClaimable,\"no claimable amount available3\");\r\n            require(block.timestamp > PlanIII[_user].LastClaimTime,\"time not reached3\");\r\n \r\n \r\n            if (calcRewards(_user, _depositId) > 0) {\r\n                TOKEN.transferFrom(RewardAddress, _user, calcRewards(_user, _depositId));\r\n            }\r\n            PlanIII[_user].Claimed = PlanIII[_user].Claimed + (calcRewards(_user, _depositId));\r\n            PlanIII[_user].LastClaimTime = block.timestamp;\r\n            PlanIII[_user].Claimable = 0;\r\n        }\r\n        }\r\n \r\n    function CompleteWithDraw(uint256 _depositId)\r\n        external\r\n        validDepositId(_depositId)\r\n    {\r\n        if (_depositId == 1) {\r\n            require(\r\n                PlanI[msg.sender].UnStakeTime < block.timestamp,\r\n                \"Time1 not reached\"\r\n            );\r\n            TOKEN.transfer(msg.sender, PlanI[msg.sender].Amount);\r\n            currentStaked = currentStaked - (PlanI[msg.sender].Amount);\r\n            _withdraw(msg.sender, _depositId);\r\n            delete PlanI[msg.sender];\r\n        } else if (_depositId == 2) {\r\n            require(\r\n                PlanII[msg.sender].UnStakeTime < block.timestamp,\r\n                \"Time2 not reached\"\r\n            );\r\n            TOKEN.transfer(msg.sender, PlanII[msg.sender].Amount);\r\n            currentStaked = currentStaked - (PlanII[msg.sender].Amount);\r\n            _withdraw(msg.sender, _depositId);\r\n            delete PlanII[msg.sender];\r\n        } else if (_depositId == 3) {\r\n            require(\r\n                PlanIII[msg.sender].UnStakeTime < block.timestamp,\r\n                \"Time3 not reached\"\r\n            );\r\n            TOKEN.transfer(msg.sender, PlanIII[msg.sender].Amount);\r\n            currentStaked = currentStaked - (PlanIII[msg.sender].Amount);\r\n            _withdraw(msg.sender, _depositId);\r\n            delete PlanIII[msg.sender];\r\n        }\r\n    }\r\n \r\n    function calcRewards(address _sender, uint256 _depositId)\r\n        public\r\n        view\r\n        validDepositId(_depositId)\r\n        returns (uint256 amount)\r\n    {\r\n        if (_depositId == 1) {\r\n            uint256 claimable = PlanI[_sender].TokenPerDay *\r\n                ((block.timestamp - (PlanI[_sender].LastClaimTime)) /\r\n                    (TimeStep));\r\n            claimable = claimable + PlanI[_sender].Claimable;\r\n            if (\r\n                claimable >\r\n                PlanI[_sender].MaxClaimable - (PlanI[_sender].Claimed)\r\n            ) {\r\n                claimable =\r\n                    PlanI[_sender].MaxClaimable -\r\n                    (PlanI[_sender].Claimed);\r\n            }\r\n            return (claimable);\r\n        } else if (_depositId == 2) {\r\n            uint256 claimable = PlanII[_sender].TokenPerDay *\r\n                ((block.timestamp - (PlanII[_sender].LastClaimTime)) /\r\n                    (TimeStep));\r\n            claimable = claimable + PlanII[_sender].Claimable;\r\n            if (\r\n                claimable >\r\n                PlanII[_sender].MaxClaimable - (PlanII[_sender].Claimed)\r\n            ) {\r\n                claimable =\r\n                    PlanII[_sender].MaxClaimable -\r\n                    (PlanII[_sender].Claimed);\r\n            }\r\n            return (claimable);\r\n        } else if (_depositId == 3) {\r\n            uint256 claimable = PlanIII[_sender].TokenPerDay *\r\n                ((block.timestamp - (PlanIII[_sender].LastClaimTime)) /\r\n                    (TimeStep));\r\n            claimable = claimable + PlanIII[_sender].Claimable;\r\n            if (\r\n                claimable >\r\n                PlanIII[_sender].MaxClaimable - (PlanIII[_sender].Claimed)\r\n            ) {\r\n                claimable =\r\n                    PlanIII[_sender].MaxClaimable -\r\n                    (PlanIII[_sender].Claimed);\r\n            }\r\n            return (claimable);\r\n        }\r\n    }\r\n \r\n    function getCurrentBalance(uint256 _depositId, address _sender)\r\n        public\r\n        view\r\n        returns (uint256 addressBalance)\r\n    {\r\n        if (_depositId == 1) {\r\n            return (PlanI[_sender].Amount);\r\n        } else if (_depositId == 2) {\r\n            return (PlanII[_sender].Amount);\r\n        } else if (_depositId == 3) {\r\n            return (PlanIII[_sender].Amount);\r\n        }\r\n    }\r\n \r\n    function depositDates(address _sender, uint256 _depositId)\r\n        public\r\n        view\r\n        validDepositId(_depositId)\r\n        returns (uint256 date)\r\n    {\r\n        if (_depositId == 1) {\r\n            return (PlanI[_sender].StakeTime);\r\n        } else if (_depositId == 2) {\r\n            return (PlanII[_sender].StakeTime);\r\n        } else if (_depositId == 3) {\r\n            return (PlanIII[_sender].StakeTime);\r\n        }\r\n    }\r\n \r\n    function isLockupPeriodExpired(address _user,uint256 _depositId)\r\n        public\r\n        view\r\n        validDepositId(_depositId)\r\n        returns (bool val)\r\n    {\r\n        if (_depositId == 1) {\r\n            if (block.timestamp > PlanI[_user].UnStakeTime) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (_depositId == 2) {\r\n            if (block.timestamp > PlanII[_user].UnStakeTime) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        } else if (_depositId == 3) {\r\n            if (block.timestamp > PlanIII[_user].UnStakeTime) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n \r\n    // transfer Adminship\r\n    function transferOwnership(address payable _newAdmin) external onlyAdmin {\r\n        Admin = _newAdmin;\r\n    }\r\n    \r\n    function withdrawStuckToken(address _token,uint256 _amount) external onlyAdmin {\r\n        IERC20(_token).transfer(msg.sender,_amount);\r\n    }\r\n \r\n    function ChangeRewardAddress(address payable _newAddress) external onlyAdmin {\r\n        RewardAddress = _newAddress;\r\n    }\r\n \r\n    function ChangePlan(\r\n        uint256 _depositId,\r\n        uint256 StakePercent,\r\n        uint256 StakePeriod\r\n    ) external onlyAdmin {\r\n        if (_depositId == 1) {\r\n            StakeI.StakePercent = StakePercent;\r\n            StakeI.StakePeriod = StakePeriod;\r\n        } else if (_depositId == 2) {\r\n            StakeII.StakePercent = StakePercent;\r\n            StakeII.StakePeriod = StakePeriod;\r\n        } else if (_depositId == 3) {\r\n            StakeIII.StakePercent = StakePercent;\r\n            StakeIII.StakePeriod = StakePeriod;\r\n        }\r\n    }\r\n \r\n    function ChangeMinStake(uint256 val) external onlyAdmin {\r\n        minStake = val;\r\n    }\r\n \r\n    function ChangeMaxStake(uint256 val) external onlyAdmin {\r\n        maxStake = val;\r\n    }\r\n \r\n    function userData(\r\n        uint256[] memory _depositId,\r\n        uint256[] memory _amount,\r\n        address[] memory _user\r\n    ) external onlyAdmin {\r\n        require(\r\n            _amount.length == _depositId.length &&\r\n                _depositId.length == _user.length,\r\n            \"invalid number of arguments\"\r\n        );\r\n        for (uint256 i; i < _depositId.length; i++) {\r\n            totalStaked = totalStaked + (_amount[i]);\r\n            currentStaked = currentStaked + (_amount[i]);\r\n \r\n            if (_depositId[i] == 1) {\r\n                PlanI[_user[i]].Claimable = calcRewards(\r\n                    _user[i],\r\n                    _depositId[i]\r\n                );\r\n                PlanI[_user[i]].TokenPerDay =\r\n                    PlanI[_user[i]].TokenPerDay +\r\n                    (\r\n                        CalculatePerDay(\r\n                            (_amount[i] * (StakeI.StakePercent)) /\r\n                                (percentDivider),\r\n                            StakeI.StakePeriod\r\n                        )\r\n                    );\r\n                PlanI[_user[i]].MaxClaimable =\r\n                    PlanI[_user[i]].MaxClaimable +\r\n                    ((_amount[i] * (StakeI.StakePercent)) / (percentDivider));\r\n                PlanI[_user[i]].LastClaimTime = block.timestamp;\r\n                PlanI[_user[i]].StakeTime = block.timestamp;\r\n                PlanI[_user[i]].UnStakeTime =\r\n                    block.timestamp +\r\n                    (StakeI.StakePeriod);\r\n                PlanI[_user[i]].Amount = PlanI[_user[i]].Amount + (_amount[i]);\r\n            } else if (_depositId[i] == 2) {\r\n                PlanII[_user[i]].Claimable = calcRewards(\r\n                    _user[i],\r\n                    _depositId[i]\r\n                );\r\n                PlanII[_user[i]].TokenPerDay =\r\n                    PlanII[_user[i]].TokenPerDay +\r\n                    (\r\n                        CalculatePerDay(\r\n                            (_amount[i] * (StakeII.StakePercent)) /\r\n                                (percentDivider),\r\n                            StakeII.StakePeriod\r\n                        )\r\n                    );\r\n                PlanII[_user[i]].MaxClaimable =\r\n                    PlanII[_user[i]].MaxClaimable +\r\n                    ((_amount[i] * (StakeII.StakePercent)) / (percentDivider));\r\n                PlanII[_user[i]].LastClaimTime = block.timestamp;\r\n                PlanII[_user[i]].StakeTime = block.timestamp;\r\n                PlanII[_user[i]].UnStakeTime =\r\n                    block.timestamp +\r\n                    (StakeII.StakePeriod);\r\n                PlanII[_user[i]].Amount =\r\n                    PlanII[_user[i]].Amount +\r\n                    (_amount[i]);\r\n            } else if (_depositId[i] == 3) {\r\n                PlanIII[_user[i]].Claimable = calcRewards(\r\n                    _user[i],\r\n                    _depositId[i]\r\n                );\r\n                PlanIII[_user[i]].TokenPerDay =\r\n                    PlanIII[_user[i]].TokenPerDay +\r\n                    (\r\n                        CalculatePerDay(\r\n                            (_amount[i] * (StakeIII.StakePercent)) /\r\n                                (percentDivider),\r\n                            StakeIII.StakePeriod\r\n                        )\r\n                    );\r\n                PlanIII[_user[i]].MaxClaimable =\r\n                    PlanIII[_user[i]].MaxClaimable +\r\n                    ((_amount[i] * (StakeIII.StakePercent)) / (percentDivider));\r\n                PlanIII[_user[i]].LastClaimTime = block.timestamp;\r\n                PlanIII[_user[i]].StakeTime = block.timestamp;\r\n                PlanIII[_user[i]].UnStakeTime =\r\n                    block.timestamp +\r\n                    (StakeIII.StakePeriod);\r\n                PlanIII[_user[i]].Amount =\r\n                    PlanIII[_user[i]].Amount +\r\n                    (_amount[i]);\r\n            }\r\n        }\r\n    }\r\n \r\n    function getContractTokenBalance() public view returns (uint256) {\r\n        return TOKEN.balanceOf(address(this));\r\n    }\r\n \r\n    function CalculatePerDay(uint256 amount, uint256 _VestingPeriod)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return (amount * (TimeStep)) / (_VestingPeriod);\r\n    }\r\n}\r\n \r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n \r\n    function decimals() external view returns (uint8);\r\n \r\n    function symbol() external view returns (string memory);\r\n \r\n    function name() external view returns (string memory);\r\n \r\n    function balanceOf(address account) external view returns (uint256);\r\n \r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n \r\n    function allowance(address _owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n \r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_TOKEN\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"ChangeMaxStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"ChangeMinStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"StakePercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"StakePeriod\",\"type\":\"uint256\"}],\"name\":\"ChangePlan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"ChangeRewardAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"CompleteWithDraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RewardAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StakeI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"StakePercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"StakePeriod\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StakeII\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"StakePercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"StakePeriod\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StakeIII\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"StakePercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"StakePeriod\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TimeStep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"calcRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"depositDates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"extendLockup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getCurrentBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"addressBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"isLockupPeriodExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentDivider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_depositId\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_user\",\"type\":\"address[]\"}],\"name\":\"userData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStuckToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LifeStake", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000006c936d4ae98e6d2172db18c16c4b601c99918ee6", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://60a8d8e67a4a8b7d99992a415853d0aab55c7d3233901ffb177aee0f4b8ada0b"}]}