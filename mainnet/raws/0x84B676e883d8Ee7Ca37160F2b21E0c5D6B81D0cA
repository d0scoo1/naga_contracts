{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/OscilloExchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interface/IDistributor.sol\\\";\\nimport \\\"./interface/IGovernance.sol\\\";\\nimport \\\"./interface/IERC20Meta.sol\\\";\\nimport \\\"./interface/IWrapped.sol\\\";\\nimport \\\"./library/LibTrade.sol\\\";\\nimport \\\"./library/LibTransfer.sol\\\";\\n\\n\\ncontract OscilloExchange is Ownable {\\n    using LibTrade for LibTrade.MatchExecution;\\n    using LibTransfer for IERC20Meta;\\n\\n    bytes32 private constant _DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n    bytes32 private constant _DOMAIN_VERSION = 0x0984d5efd47d99151ae1be065a709e56c602102f24c1abc4008eb3f815a8d217;\\n    bytes32 private constant _DOMAIN_NAME = 0xd8847acffb1e80c967781c9cefc950c79c285c67014ab8ca7bfb053adcb94e20;\\n\\n    uint private constant GAS_EXPECTATION_BUFFERED = 270000;\\n    uint private constant RESERVE_MAX = 2500;\\n    uint private constant RESERVE_DENOM = 1000000;\\n    uint private constant PRICE_DENOM = 1000000;\\n\\n    bytes32 private immutable _domainSeparator;\\n    mapping(uint => uint) private _fills;\\n    mapping(address => bool) private _executors;\\n\\n    IGovernance public governance;\\n    IDistributor public distributor;\\n    IWrapped public immutable nativeToken;\\n\\n    event Executed(uint indexed matchId, uint[3] askTransfers, uint[3] bidTransfers);\\n    event Cancelled(uint indexed matchId, uint code);\\n\\n    modifier onlyExecutor {\\n        require(msg.sender != address(0) && _executors[msg.sender], \\\"!executor\\\");\\n        _;\\n    }\\n\\n    receive() external payable {}\\n\\n    constructor(address _governance, address _nativeToken) {\\n        _domainSeparator = keccak256(abi.encode(_DOMAIN_TYPEHASH, _DOMAIN_NAME, _DOMAIN_VERSION, block.chainid, address(this)));\\n        governance = IGovernance(_governance);\\n        nativeToken = IWrapped(_nativeToken);\\n    }\\n\\n    /** Views **/\\n\\n    function toAmountQuote(address base, address quote, uint amount, uint price) public view returns (uint) {\\n        return amount * price * (10 ** IERC20Meta(quote).decimals()) / PRICE_DENOM / (10 ** IERC20Meta(base).decimals());\\n    }\\n\\n    function toAmountsInOut(LibTrade.MatchExecution memory exec) public view returns (uint[2] memory askTransfers, uint[2] memory bidTransfers) {\\n        uint baseUnit = 10 ** IERC20Meta(exec.base).decimals();\\n        uint quoteUnit = 10 ** IERC20Meta(exec.quote).decimals();\\n\\n        uint bidReserve = exec.amount * exec.reserve / RESERVE_DENOM;\\n        uint askReserve = bidReserve * exec.price * quoteUnit / PRICE_DENOM / baseUnit;\\n        uint amountQ = exec.amount * exec.price * quoteUnit / PRICE_DENOM / baseUnit;\\n        askTransfers = [exec.amount, amountQ - askReserve];\\n        bidTransfers = [amountQ, exec.amount - bidReserve];\\n    }\\n\\n    function reserves(address base, address quote, uint amount, uint price, uint reserve) public view returns (uint askReserve, uint bidReserve) {\\n        bidReserve = amount * (reserve > RESERVE_MAX ? RESERVE_MAX : reserve) / RESERVE_DENOM;\\n        askReserve = toAmountQuote(base, quote, bidReserve, price);\\n    }\\n\\n    function txCosts(LibTrade.MatchExecution memory exec, uint gasprice, uint gasUsed) private view returns (uint askTx, uint bidTx) {\\n        uint baseDecimals = IERC20Meta(exec.base).decimals();\\n        uint txCost = gasprice * gasUsed * exec.priceN / exec.price / (10 ** (18 - baseDecimals));\\n        askTx = _fills[exec.ask.id] == 0 ? txCost * exec.price * (10 ** IERC20Meta(exec.quote).decimals()) / PRICE_DENOM / (10 ** baseDecimals) : 0;\\n        bidTx = _fills[exec.bid.id] == 0 ? txCost : 0;\\n    }\\n\\n    function acceptance(LibTrade.MatchExecution[] memory chunk, uint gasprice) public view returns (LibTrade.Acceptance[] memory) {\\n        LibTrade.Acceptance[] memory accepts = new LibTrade.Acceptance[](chunk.length);\\n        for (uint i = 0; i < chunk.length; i++) {\\n            LibTrade.MatchExecution memory e = chunk[i];\\n            accepts[i].mid = e.mid;\\n\\n            if (!e.recover(_domainSeparator) || e.reserve > RESERVE_MAX) accepts[i].code = accepts[i].code | (1 << LibTrade.CodeIdxSignature);\\n            if (e.price < e.ask.lprice || e.price > e.bid.lprice) accepts[i].code = accepts[i].code | (1 << LibTrade.CodeIdxPrice);\\n            if (e.ask.amount < _fills[e.ask.id] + e.amount) accepts[i].code = accepts[i].code | (1 << LibTrade.CodeIdxAskFilled);\\n            if (e.bid.amount < _fills[e.bid.id] + e.amount) accepts[i].code = accepts[i].code | (1 << LibTrade.CodeIdxBidFilled);\\n\\n            uint amountQ = toAmountQuote(e.base, e.quote, e.amount, e.price);\\n            (uint askReserve, uint bidReserve) = reserves(e.base, e.quote, e.amount, e.price, e.reserve);\\n            (uint askTx, uint bidTx) = txCosts(e, gasprice, GAS_EXPECTATION_BUFFERED);\\n            if (askReserve + askTx > amountQ) accepts[i].code = accepts[i].code | (1 << LibTrade.CodeIdxAskCost);\\n            if (bidReserve + bidTx > e.amount) accepts[i].code = accepts[i].code | (1 << LibTrade.CodeIdxBidCost);\\n\\n            (uint[2] memory askTransfers, uint[2] memory bidTransfers) = toAmountsInOut(e);\\n            if (IERC20Meta(e.base).available(e.ask.account, address(this)) < askTransfers[0]) accepts[i].code = accepts[i].code | (1 << LibTrade.CodeIdxAskBalance);\\n            if (IERC20Meta(e.quote).available(e.bid.account, address(this)) < bidTransfers[0]) accepts[i].code = accepts[i].code | (1 << LibTrade.CodeIdxBidBalance);\\n\\n            accepts[i].askTransfers = [askTransfers[0], askTransfers[1], askTx];\\n            accepts[i].bidTransfers = [bidTransfers[0], bidTransfers[1], bidTx];\\n        }\\n        return accepts;\\n    }\\n\\n    /** Interactions **/\\n\\n    function execute(LibTrade.MatchExecution[] calldata chunk, uint gasUsed) external onlyExecutor {\\n        gasUsed = gasUsed == 0 ? GAS_EXPECTATION_BUFFERED : gasUsed;\\n        for (uint i = 0; i < chunk.length; i++) {\\n            uint code;\\n            LibTrade.MatchExecution memory e = chunk[i];\\n\\n            uint amountQ = e.amount * e.price * (10 ** IERC20Meta(e.quote).decimals()) / PRICE_DENOM / (10 ** IERC20Meta(e.base).decimals());\\n            if (IERC20Meta(e.base).available(e.ask.account, address(this)) < e.amount) code = code | (1 << LibTrade.CodeIdxAskBalance);\\n            if (IERC20Meta(e.quote).available(e.bid.account, address(this)) < amountQ) code = code | (1 << LibTrade.CodeIdxBidBalance);\\n            if (code != 0) {\\n                emit Cancelled(e.mid, code);\\n                continue;\\n            }\\n\\n            if (!e.recover(_domainSeparator) || e.reserve > RESERVE_MAX) code = code | (1 << LibTrade.CodeIdxSignature);\\n            if (e.price < e.ask.lprice || e.price > e.bid.lprice) code = code | (1 << LibTrade.CodeIdxPrice);\\n            if (code != 0) {\\n                emit Cancelled(e.mid, code);\\n                continue;\\n            }\\n\\n            (uint askFilled, uint bidFilled) = (_fills[e.ask.id], _fills[e.bid.id]);\\n            if (e.ask.amount < askFilled + e.amount) code = code | (1 << LibTrade.CodeIdxAskFilled);\\n            if (e.bid.amount < bidFilled + e.amount) code = code | (1 << LibTrade.CodeIdxBidFilled);\\n            if (code != 0) {\\n                emit Cancelled(e.mid, code);\\n                continue;\\n            }\\n\\n            uint bidReserve = e.amount * e.reserve / RESERVE_DENOM;\\n            uint askReserve = bidReserve * e.price * (10 ** IERC20Meta(e.quote).decimals()) / PRICE_DENOM / (10 ** IERC20Meta(e.base).decimals());\\n            (uint askTx, uint bidTx) = _txCosts(e, askFilled, bidFilled, tx.gasprice, gasUsed);\\n            if (askReserve + askTx > amountQ) code = code | (1 << LibTrade.CodeIdxAskCost);\\n            if (bidReserve + bidTx > e.amount) code = code | (1 << LibTrade.CodeIdxBidCost);\\n            if (code != 0) {\\n                emit Cancelled(e.mid, code);\\n                continue;\\n            }\\n\\n            _fills[e.ask.id] = askFilled + e.amount;\\n            _fills[e.bid.id] = bidFilled + e.amount;\\n\\n            IERC20Meta(e.base).safeTransferFrom(e.ask.account, address(this), e.amount);\\n            IERC20Meta(e.quote).safeTransferFrom(e.bid.account, address(this), amountQ);\\n\\n            IERC20Meta(e.quote).safeTransfer(e.ask.account, amountQ - askReserve - askTx);\\n            if (e.unwrap && e.base == address(nativeToken)) {\\n                uint balance = address(this).balance;\\n                nativeToken.withdraw(e.amount - bidReserve - bidTx);\\n                LibTransfer.safeTransferETH(e.bid.account, address(this).balance - balance);\\n            } else {\\n                IERC20Meta(e.base).safeTransfer(e.bid.account, e.amount - bidReserve - bidTx);\\n            }\\n\\n            if (askTx > 0) IERC20Meta(e.quote).safeTransfer(msg.sender, askTx);\\n            if (bidTx > 0) IERC20Meta(e.base).safeTransfer(msg.sender, bidTx);\\n            emit Executed(e.mid, [e.amount, amountQ - askReserve, askTx], [amountQ, e.amount - bidReserve, bidTx]);\\n        }\\n    }\\n\\n    /** Restricted **/\\n\\n    function setExecutor(address target, bool on) external onlyOwner {\\n        require(target != address(0), \\\"!target\\\");\\n        _executors[target] = on;\\n    }\\n\\n    function setDistributor(address newDistributor) external onlyOwner {\\n        require(newDistributor != address(0) && newDistributor != address(distributor), \\\"!distributor\\\");\\n        if (address(distributor) != address(0)) {\\n            IERC20Meta(distributor.rewardToken()).safeApprove(address(distributor), 0);\\n        }\\n\\n        distributor = IDistributor(newDistributor);\\n        IERC20Meta rewardToken = IERC20Meta(distributor.rewardToken());\\n        rewardToken.safeApprove(address(distributor), 0);\\n        rewardToken.safeApprove(address(distributor), type(uint).max);\\n    }\\n\\n    function distribute(uint checkpoint, uint accVolume, uint rewardAmount) external onlyOwner {\\n        require(address(distributor) != address(0), \\\"!distributor\\\");\\n        governance.notifyAccVolumeUpdated(checkpoint, accVolume);\\n        distributor.notifyRewardDistributed(rewardAmount);\\n    }\\n\\n    function sweep(address[] calldata tokens) external onlyOwner {\\n        address rewardToken = distributor.rewardToken();\\n        for (uint i = 0; i < tokens.length; i++) {\\n            if (tokens[i] == rewardToken) continue;\\n\\n            IERC20Meta token = IERC20Meta(tokens[i]);\\n            uint leftover = token.balanceOf(address(this));\\n            if (leftover > 0) token.safeTransfer(owner(), leftover);\\n        }\\n    }\\n\\n    /** Privates **/\\n\\n    function _txCosts(LibTrade.MatchExecution memory exec, uint askFilled, uint bidFilled, uint gasprice, uint gasUsed) private view returns (uint askTx, uint bidTx) {\\n        uint baseDecimals = IERC20Meta(exec.base).decimals();\\n        uint txCost = gasprice * gasUsed * exec.priceN / exec.price / (10 ** (18 - baseDecimals));\\n        askTx = askFilled == 0 ? txCost * exec.price * (10 ** IERC20Meta(exec.quote).decimals()) / PRICE_DENOM / (10 ** baseDecimals) : 0;\\n        bidTx = bidFilled == 0 ? txCost : 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n\\ninterface IDistributor {\\n    function rewardToken() external view returns (address);\\n    function reserves() external view returns (uint);\\n\\n    function stake(uint amount) external;\\n    function unstake(uint amount) external;\\n    function claim() external;\\n    function exit() external;\\n\\n    function notifyRewardDistributed(uint rewardAmount) external;\\n    function stakeBehalf(address account, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n\\ninterface IGovernance {\\n    function notifyAccVolumeUpdated(uint checkpoint, uint accVolumeX2) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IERC20Meta.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n\\ninterface IERC20Meta {\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address account) external view returns (uint);\\n    function transfer(address to, uint amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function approve(address spender, uint amount) external returns (bool);\\n    function transferFrom(address from, address to, uint amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IWrapped.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface IWrapped {\\n    function deposit() external payable;\\n    function withdraw(uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/library/LibTrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n\\nlibrary LibTrade {\\n    bytes32 constant _ORDER_TYPEHASH = 0x287d88810c333c982eb76bb0816bf9f46aed64f1f5378d80081fbfdc7928ab5e;\\n\\n    uint constant CodeIdxSignature = 7;\\n    uint constant CodeIdxPrice = 6;\\n    uint constant CodeIdxAskFilled = 5;\\n    uint constant CodeIdxBidFilled = 4;\\n    uint constant CodeIdxAskCost = 3;\\n    uint constant CodeIdxBidCost = 2;\\n    uint constant CodeIdxAskBalance = 1;\\n    uint constant CodeIdxBidBalance = 0;\\n\\n    /// @dev code [signature|price|ask.fill|bid.fill|ask.cost|bid.cost|ask.available|bid.available]\\n    struct Acceptance {\\n        uint mid;\\n        uint code;\\n        uint[3] askTransfers;\\n        uint[3] bidTransfers;\\n    }\\n\\n    struct Order {\\n        address account;\\n        address tokenIn;\\n        address tokenOut;\\n        uint amount;\\n        uint lprice;\\n    }\\n\\n    struct OrderPacked {\\n        uint id;\\n        address account;\\n        uint amount;\\n        uint lprice;\\n        bytes sig;\\n    }\\n\\n    struct MatchExecution {\\n        uint mid;\\n        address base;\\n        address quote;\\n        OrderPacked ask;\\n        OrderPacked bid;\\n        uint amount;\\n        uint price;\\n        uint priceN;\\n        uint reserve;\\n        bool unwrap;\\n    }\\n\\n    function recover(MatchExecution memory exec, bytes32 domainSeparator) internal pure returns (bool) {\\n        Order memory ask = Order(exec.ask.account, exec.base, exec.quote, exec.ask.amount, exec.ask.lprice);\\n        Order memory bid = Order(exec.bid.account, exec.quote, exec.base, exec.bid.amount, exec.bid.lprice);\\n        return recoverOrder(ask, domainSeparator, exec.ask.sig) && recoverOrder(bid, domainSeparator, exec.bid.sig);\\n    }\\n\\n    function recoverOrder(Order memory order, bytes32 domainSeparator, bytes memory signature) private pure returns (bool) {\\n        require(signature.length == 65, \\\"invalid signature length\\\");\\n\\n        bytes32 structHash;\\n        bytes32 orderDigest;\\n\\n        // Order struct (5 fields) and type hash (5 + 1) * 32 = 192\\n        assembly {\\n            let dataStart := sub(order, 32)\\n            let temp := mload(dataStart)\\n            mstore(dataStart, _ORDER_TYPEHASH)\\n            structHash := keccak256(dataStart, 192)\\n            mstore(dataStart, temp)\\n        }\\n\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            mstore(freeMemoryPointer, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(freeMemoryPointer, 2), domainSeparator)\\n            mstore(add(freeMemoryPointer, 34), structHash)\\n            orderDigest := keccak256(freeMemoryPointer, 66)\\n        }\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"invalid signature 's' value\\\");\\n\\n        address signer;\\n\\n        if (v > 30) {\\n            require(v - 4 == 27 || v - 4 == 28, \\\"invalid signature 'v' value\\\");\\n            signer = ecrecover(keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", orderDigest)), v - 4, r, s);\\n        } else {\\n            require(v == 27 || v == 28, \\\"invalid signature 'v' value\\\");\\n            signer = ecrecover(orderDigest, v, r, s);\\n        }\\n        return signer != address(0) && signer == order.account;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/library/LibTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n\\nimport \\\"../interface/IERC20Meta.sol\\\";\\n\\nlibrary LibTransfer {\\n    function available(IERC20Meta token, address owner, address spender) internal view returns (uint) {\\n        uint _allowance = token.allowance(owner, spender);\\n        uint _balance = token.balanceOf(owner);\\n        return _allowance < _balance ? _allowance : _balance;\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success, ) = to.call{ value: value }(new bytes(0));\\n        require(success, \\\"!safeTransferETH\\\");\\n    }\\n\\n    function safeApprove(IERC20Meta token, address to, uint value) internal {\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"!safeApprove\\\");\\n    }\\n\\n    function safeTransfer(IERC20Meta token, address to, uint value) internal {\\n        bytes4 selector_ = token.transfer.selector;\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            mstore(freeMemoryPointer, selector_)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\\n            mstore(add(freeMemoryPointer, 36), value)\\n\\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n        require(_getLastTransferResult(token), \\\"!safeTransfer\\\");\\n    }\\n\\n    function safeTransferFrom(IERC20Meta token, address from, address to, uint value) internal {\\n        bytes4 selector_ = token.transferFrom.selector;\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            mstore(freeMemoryPointer, selector_)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\\n            mstore(add(freeMemoryPointer, 68), value)\\n\\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n        require(_getLastTransferResult(token), \\\"!safeTransferFrom\\\");\\n    }\\n\\n    function _getLastTransferResult(IERC20Meta token) private view returns (bool success) {\\n        assembly {\\n            function revertWithMessage(length, message) {\\n                mstore(0x00, \\\"\\\\x08\\\\xc3\\\\x79\\\\xa0\\\")\\n                mstore(0x04, 0x20)\\n                mstore(0x24, length)\\n                mstore(0x44, message)\\n                revert(0x00, 0x64)\\n            }\\n\\n            switch returndatasize()\\n            case 0 {\\n                if iszero(extcodesize(token)) {\\n                    revertWithMessage(20, \\\"!contract\\\")\\n                }\\n                success := 1\\n            }\\n            case 32 {\\n                returndatacopy(0, 0, returndatasize())\\n                success := iszero(iszero(mload(0)))\\n            }\\n            default {\\n                revertWithMessage(31, \\\"!transferResult\\\")\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nativeToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"matchId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"code\",\"type\":\"uint256\"}],\"name\":\"Cancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"matchId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[3]\",\"name\":\"askTransfers\",\"type\":\"uint256[3]\"},{\"indexed\":false,\"internalType\":\"uint256[3]\",\"name\":\"bidTransfers\",\"type\":\"uint256[3]\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quote\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lprice\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct LibTrade.OrderPacked\",\"name\":\"ask\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lprice\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct LibTrade.OrderPacked\",\"name\":\"bid\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceN\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"}],\"internalType\":\"struct LibTrade.MatchExecution[]\",\"name\":\"chunk\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"gasprice\",\"type\":\"uint256\"}],\"name\":\"acceptance\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"code\",\"type\":\"uint256\"},{\"internalType\":\"uint256[3]\",\"name\":\"askTransfers\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[3]\",\"name\":\"bidTransfers\",\"type\":\"uint256[3]\"}],\"internalType\":\"struct LibTrade.Acceptance[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accVolume\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributor\",\"outputs\":[{\"internalType\":\"contract IDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quote\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lprice\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct LibTrade.OrderPacked\",\"name\":\"ask\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lprice\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct LibTrade.OrderPacked\",\"name\":\"bid\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceN\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"}],\"internalType\":\"struct LibTrade.MatchExecution[]\",\"name\":\"chunk\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"contract IGovernance\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeToken\",\"outputs\":[{\"internalType\":\"contract IWrapped\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quote\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"}],\"name\":\"reserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"askReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidReserve\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDistributor\",\"type\":\"address\"}],\"name\":\"setDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"on\",\"type\":\"bool\"}],\"name\":\"setExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quote\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"toAmountQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quote\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lprice\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct LibTrade.OrderPacked\",\"name\":\"ask\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lprice\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct LibTrade.OrderPacked\",\"name\":\"bid\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceN\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"}],\"internalType\":\"struct LibTrade.MatchExecution\",\"name\":\"exec\",\"type\":\"tuple\"}],\"name\":\"toAmountsInOut\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"askTransfers\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"bidTransfers\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "OscilloExchange", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007e00aecaba5df64e9fefab55ac6b3f58100e79e2000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}