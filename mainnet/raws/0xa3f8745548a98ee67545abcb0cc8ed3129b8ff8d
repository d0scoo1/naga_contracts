{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn\\u0027t rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn\\u0027t, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"},\"ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"},\"IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it\\u0027s common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"},\"IveSPA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\ninterface IveSPA {\\n    function getLastUserSlope(address addr) external view returns (int128);\\n\\n    function getUserPointHistoryTS(address addr, uint256 idx)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function userPointEpoch(address addr) external view returns (uint256);\\n\\n    function checkpoint() external;\\n\\n    function lockedEnd(address addr) external view returns (uint256);\\n\\n    function depositFor(address addr, uint128 value) external;\\n\\n    function createLock(\\n        uint128 value,\\n        uint256 unlockTime,\\n        bool autoCooldown\\n    ) external;\\n\\n    function increaseAmount(uint128 value) external;\\n\\n    function increaseUnlockTime(uint256 unlockTime) external;\\n\\n    function initiateCooldown() external;\\n\\n    function withdraw() external;\\n\\n    function balanceOf(address addr, uint256 ts)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(address addr) external view returns (uint256);\\n\\n    function balanceOfAt(address, uint256 blockNumber)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function totalSupply(uint256 ts) external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function totalSupplyAt(uint256 blockNumber) external view returns (uint256);\\n}\\n\"},\"OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ContextUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"},\"ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"},\"SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance \\u003e= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n        // we\\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length \\u003e 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"},\"veSPA_v1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@//\\n//@@@@@@@@\\u0026....(@@@@@@@@@@@@@..../@@@@@@@@@//\\n//@@@@@@........../@@@@@@@........../@@@@@@//\\n//@@@@@............(@@@@@............(@@@@@//\\n//@@@@@(............@@@@@(...........\\u0026@@@@@//\\n//@@@@@@@...........\\u0026@@@@@@.........@@@@@@@//\\n//@@@@@@@@@@@@@@%..../@@@@@@@@@@@@@@@@@@@@@//\\n//@@@@@@@@@@@@@@@@@@@...@@@@@@@@@@@@@@@@@@@//\\n//@@@@@@@@@@@@@@@@@@@@@......(\\u0026@@@@@@@@@@@@//\\n//@@@@@@#.........@@@@@@#...........@@@@@@@//\\n//@@@@@/...........%@@@@@............%@@@@@//\\n//@@@@@............#@@@@@............%@@@@@//\\n//@@@@@@..........#@@@@@@@/.........#@@@@@@//\\n//@@@@@@@@@\\u0026/.(@@@@@@@@@@@@@@\\u0026/.(\\u0026@@@@@@@@@//\\n//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@//\\n\\nimport \\\"./ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"./OwnableUpgradeable.sol\\\";\\nimport \\\"./SafeERC20Upgradeable.sol\\\";\\nimport \\\"./IveSPA.sol\\\";\\n\\n// @title Voting Escrow\\n// @notice Cooldown logic is added in the contract\\n// @notice Make contract upgradeable\\n// @notice This is a Solidity implementation of the CURVE\\u0027s voting escrow.\\n// @notice Votes have a weight depending on time, so that users are\\n//         committed to the future of (whatever they are voting for)\\n// @dev Vote weight decays linearly over time. Lock time cannot be\\n//  more than `MAX_TIME` (4 years).\\n\\n/**\\n# Voting escrow to have time-weighted votes\\n# w ^\\n# 1 +        /\\n#   |      /\\n#   |    /\\n#   |  /\\n#   |/\\n# 0 +--------+------\\u003e time\\n#       maxtime (4 years?)\\n*/\\n\\ncontract veSPA_v1 is IveSPA, OwnableUpgradeable, ReentrancyGuardUpgradeable {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    enum ActionType {\\n        DEPOSIT_FOR,\\n        CREATE_LOCK,\\n        INCREASE_AMOUNT,\\n        INCREASE_LOCK_TIME,\\n        INITIATE_COOLDOWN\\n    }\\n\\n    event UserCheckpoint(\\n        ActionType indexed actionType,\\n        bool autoCooldown,\\n        address indexed provider,\\n        uint256 value,\\n        uint256 indexed locktime\\n    );\\n    event GlobalCheckpoint(address caller, uint256 epoch);\\n    event Withdraw(address indexed provider, uint256 value, uint256 ts);\\n    event Supply(uint256 prevSupply, uint256 supply);\\n\\n    struct Point {\\n        int128 bias; // veSPA value at this point\\n        int128 slope; // slope at this point\\n        int128 residue; // residue calculated at this point\\n        uint256 ts; // timestamp of this point\\n        uint256 blk; // block number of this point\\n    }\\n    /* We cannot really do block numbers per se b/c slope is per time, not per block\\n     * and per block could be fairly bad b/c Ethereum changes blocktimes.\\n     * What we can do is to extrapolate ***At functions */\\n\\n    struct LockedBalance {\\n        bool autoCooldown; // if true, the user\\u0027s deposit will have a default cooldown.\\n        bool cooldownInitiated; // Determines if the cooldown has been initiated.\\n        uint128 amount; // amount of SPA locked for a user.\\n        uint256 end; // the expiry time of the deposit.\\n    }\\n\\n    string public version;\\n    string public constant name = \\\"Vote-escrow SPA\\\";\\n    string public constant symbol = \\\"veSPA\\\";\\n    uint8 public constant decimals = 18;\\n    uint256 public totalSPALocked;\\n    uint256 public constant WEEK = 1 weeks;\\n    uint256 public constant MAX_TIME = 4 * 365 days;\\n    uint256 public constant MIN_TIME = 1 * WEEK;\\n    uint256 public constant MULTIPLIER = 10**18;\\n    int128 public constant I_YEAR = int128(uint128(365 days));\\n    int128 public constant I_MIN_TIME = int128(uint128(WEEK));\\n    address public SPA;\\n\\n    // @dev Mappings to store global point information\\n    uint256 public epoch;\\n    mapping(uint256 =\\u003e Point) public pointHistory; // epoch -\\u003e unsigned point\\n    mapping(uint256 =\\u003e int128) public slopeChanges; // time -\\u003e signed slope change\\n\\n    // @dev Mappings to store user deposit information\\n    mapping(address =\\u003e LockedBalance) public lockedBalances; // user Deposits\\n    mapping(address =\\u003e mapping(uint256 =\\u003e Point)) public userPointHistory; // user -\\u003e point[userEpoch]\\n    mapping(address =\\u003e uint256) public override userPointEpoch;\\n\\n    // @dev Constructor\\n    function initialize(address _SPA, string memory _version)\\n        public\\n        initializer\\n    {\\n        require(_SPA != address(0), \\\"_SPA is zero address\\\");\\n        OwnableUpgradeable.__Ownable_init();\\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\\n        SPA = _SPA;\\n        version = _version;\\n        pointHistory[0].blk = block.number;\\n        pointHistory[0].ts = block.timestamp;\\n    }\\n\\n    // @notice Get the most recently recorded rate of voting power decrease for `addr`\\n    // @param addr The address to get the rate for\\n    // @return value of the slope\\n    function getLastUserSlope(address addr)\\n        external\\n        view\\n        override\\n        returns (int128)\\n    {\\n        uint256 uEpoch = userPointEpoch[addr];\\n        if (uEpoch == 0) {\\n            return 0;\\n        }\\n        return userPointHistory[addr][uEpoch].slope;\\n    }\\n\\n    // @notice Get the timestamp for checkpoint `idx` for `addr`\\n    // @param addr User wallet address\\n    // @param idx User epoch number\\n    // @return Epoch time of the checkpoint\\n    function getUserPointHistoryTS(address addr, uint256 idx)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return userPointHistory[addr][idx].ts;\\n    }\\n\\n    // @notice Get timestamp when `addr`\\u0027s lock finishes\\n    // @param addr User wallet address\\n    // @return Timestamp when lock finishes\\n    function lockedEnd(address addr) external view override returns (uint256) {\\n        return lockedBalances[addr].end;\\n    }\\n\\n    // @notice add checkpoints to pointHistory for every week from last added checkpoint until now\\n    // @dev block number for each added checkpoint is estimated by their respective timestamp and the blockslope\\n    //         where the blockslope is estimated by the last added time/block point and the current time/block point\\n    // @dev pointHistory include all weekly global checkpoints and some additional in-week global checkpoints\\n    // @return lastPoint by calling this function\\n    function _updateGlobalPoint() private returns (Point memory lastPoint) {\\n        uint256 _epoch = epoch;\\n        lastPoint = Point({\\n            bias: 0,\\n            slope: 0,\\n            residue: 0,\\n            ts: block.timestamp,\\n            blk: block.number //TODO: arbi-main-fork cannot test it\\n        });\\n        Point memory initialLastPoint = Point({\\n            bias: 0,\\n            slope: 0,\\n            residue: 0,\\n            ts: block.timestamp,\\n            blk: block.number\\n        });\\n        if (_epoch \\u003e 0) {\\n            lastPoint = pointHistory[_epoch];\\n            initialLastPoint = pointHistory[_epoch];\\n        }\\n        uint256 lastCheckpoint = lastPoint.ts;\\n        uint256 blockSlope = 0; // dblock/dt\\n        if (block.timestamp \\u003e lastPoint.ts) {\\n            blockSlope =\\n                (MULTIPLIER * (block.number - lastPoint.blk)) /\\n                (block.timestamp - lastPoint.ts);\\n        }\\n        {\\n            uint256 ti = (lastCheckpoint / WEEK) * WEEK;\\n            for (uint256 i = 0; i \\u003c 255; i++) {\\n                ti += WEEK;\\n                int128 dslope = 0;\\n                if (ti \\u003e block.timestamp) {\\n                    ti = block.timestamp;\\n                } else {\\n                    dslope = slopeChanges[ti];\\n                }\\n                // calculate the slope and bia of the new last point\\n                lastPoint.bias -=\\n                    lastPoint.slope *\\n                    int128(int256(ti) - int256(lastCheckpoint));\\n                lastPoint.slope += dslope;\\n                if (lastPoint.bias \\u003c 0) {\\n                    lastPoint.bias = 0;\\n                }\\n                if (lastPoint.slope \\u003c 0) {\\n                    lastPoint.slope = 0;\\n                }\\n\\n                lastCheckpoint = ti;\\n                lastPoint.ts = ti;\\n                lastPoint.blk =\\n                    initialLastPoint.blk +\\n                    (blockSlope * (ti - initialLastPoint.ts)) /\\n                    MULTIPLIER;\\n                _epoch += 1;\\n                if (ti == block.timestamp) {\\n                    lastPoint.blk = block.number;\\n                    pointHistory[_epoch] = lastPoint;\\n                    break;\\n                }\\n                pointHistory[_epoch] = lastPoint;\\n            }\\n        }\\n\\n        epoch = _epoch;\\n        return lastPoint;\\n    }\\n\\n    // @notice Record global and per-user data to checkpoint\\n    // @param addr User wallet address. No user checkpoint if 0x0\\n    // @param oldDeposit Previous locked balance / end lock time for the user\\n    // @param newDeposit New locked balance / end lock time for the user\\n    function _checkpoint(\\n        address addr,\\n        LockedBalance memory oldDeposit,\\n        LockedBalance memory newDeposit\\n    ) internal {\\n        Point memory uOld = Point(0, 0, 0, 0, 0);\\n        Point memory uNew = Point(0, 0, 0, 0, 0);\\n        int128 dSlopeOld = 0;\\n        int128 dSlopeNew = 0;\\n\\n        if (oldDeposit.amount \\u003e 0) {\\n            int128 amt = int128(oldDeposit.amount);\\n            if (!oldDeposit.cooldownInitiated) {\\n                uOld.residue = (amt * I_MIN_TIME) / I_YEAR;\\n                oldDeposit.end -= WEEK;\\n            }\\n            if (oldDeposit.end \\u003e block.timestamp) {\\n                uOld.slope = amt / I_YEAR;\\n\\n                uOld.bias =\\n                    uOld.slope *\\n                    int128(int256(oldDeposit.end) - int256(block.timestamp));\\n            }\\n        }\\n        if ((newDeposit.end \\u003e block.timestamp) \\u0026\\u0026 (newDeposit.amount \\u003e 0)) {\\n            int128 amt = int128(newDeposit.amount);\\n            if (!newDeposit.cooldownInitiated) {\\n                uNew.residue = (amt * I_MIN_TIME) / I_YEAR;\\n                newDeposit.end -= WEEK;\\n            }\\n            if (newDeposit.end \\u003e block.timestamp) {\\n                uNew.slope = amt / I_YEAR;\\n                uNew.bias =\\n                    uNew.slope *\\n                    int128(int256(newDeposit.end) - int256(block.timestamp));\\n            }\\n        }\\n\\n        dSlopeOld = slopeChanges[oldDeposit.end];\\n        if (newDeposit.end != 0) {\\n            dSlopeNew = slopeChanges[newDeposit.end];\\n        }\\n        // add all global checkpoints from last added global check point until now\\n        Point memory lastPoint = _updateGlobalPoint();\\n        // update the last global checkpoint (now) with user action\\u0027s consequences\\n        lastPoint.slope += (uNew.slope - uOld.slope);\\n        lastPoint.bias += (uNew.bias - uOld.bias);\\n        lastPoint.residue += (uNew.residue - uOld.residue);\\n        if (lastPoint.slope \\u003c 0) {\\n            lastPoint.slope = 0;\\n        }\\n        if (lastPoint.bias \\u003c 0) {\\n            lastPoint.bias = 0;\\n        }\\n        pointHistory[epoch] = lastPoint;\\n        if (oldDeposit.end \\u003e block.timestamp) {\\n            // old_dslope was \\u003csomething\\u003e - u_old.slope, so we cancel that\\n            dSlopeOld += uOld.slope;\\n            if (newDeposit.end == oldDeposit.end) {\\n                dSlopeOld -= uNew.slope;\\n            }\\n            slopeChanges[oldDeposit.end] = dSlopeOld;\\n        }\\n\\n        if (newDeposit.end \\u003e block.timestamp) {\\n            if (newDeposit.end \\u003e oldDeposit.end) {\\n                dSlopeNew -= uNew.slope;\\n                // old slope disappeared at this point\\n                slopeChanges[newDeposit.end] = dSlopeNew;\\n            }\\n            // else: we recorded it already in old_dslopes\u0304\\n        }\\n        uint256 userEpc = userPointEpoch[addr] + 1;\\n        userPointEpoch[addr] = userEpc;\\n        uNew.ts = block.timestamp;\\n        uNew.blk = block.number;\\n        userPointHistory[addr][userEpc] = uNew;\\n    }\\n\\n    // @notice Deposit and lock tokens for a user\\n    // @param addr Address of the user\\n    // @param value Amount of tokens to deposit\\n    // @param unlockTime Time when the tokens will be unlocked\\n    // @param oldDeposit Previous locked balance of the user / timestamp\\n\\n    function _depositFor(\\n        address addr,\\n        bool autoCooldown,\\n        bool enableCooldown,\\n        uint128 value,\\n        uint256 unlockTime,\\n        LockedBalance memory oldDeposit,\\n        ActionType _type\\n    ) internal {\\n        LockedBalance memory newDeposit = lockedBalances[addr];\\n        uint256 prevSupply = totalSPALocked;\\n\\n        totalSPALocked += value;\\n        newDeposit.amount += value;\\n        newDeposit.autoCooldown = autoCooldown;\\n        newDeposit.cooldownInitiated = enableCooldown;\\n        if (unlockTime != 0) {\\n            newDeposit.end = unlockTime;\\n        }\\n        lockedBalances[addr] = newDeposit;\\n        _checkpoint(addr, oldDeposit, newDeposit);\\n\\n        if (value != 0) {\\n            IERC20Upgradeable(SPA).safeTransferFrom(\\n                _msgSender(),\\n                address(this),\\n                value\\n            );\\n        }\\n\\n        emit UserCheckpoint(_type, autoCooldown, addr, value, newDeposit.end);\\n        emit Supply(prevSupply, totalSPALocked);\\n    }\\n\\n    // @notice Record global data to checkpoint\\n    function checkpoint() external override {\\n        _updateGlobalPoint();\\n        emit GlobalCheckpoint(_msgSender(), epoch);\\n    }\\n\\n    // @notice Deposit and lock tokens for a user\\n    // @dev Anyone (even a smart contract) can deposit tokens for someone else, but\\n    //      cannot extend their locktime and deposit for a user that is not locked\\n    // @param addr Address of the user\\n    // @param value Amount of tokens to deposit\\n    function depositFor(address addr, uint128 value)\\n        external\\n        override\\n        nonReentrant\\n    {\\n        LockedBalance memory existingDeposit = lockedBalances[addr];\\n        require(value \\u003e 0, \\\"Cannot deposit 0 tokens\\\");\\n        require(existingDeposit.amount \\u003e 0, \\\"No existing lock\\\");\\n\\n        if (!existingDeposit.autoCooldown) {\\n            require(\\n                !existingDeposit.cooldownInitiated,\\n                \\\"Cannot deposit during cooldown\\\"\\n            );\\n        }\\n        // else: auto-cooldown is on, so user can deposit anytime prior to expiry\\n        require(\\n            existingDeposit.end \\u003e block.timestamp,\\n            \\\"Lock expired. Withdraw\\\"\\n        );\\n        _depositFor(\\n            addr,\\n            existingDeposit.autoCooldown,\\n            existingDeposit.cooldownInitiated,\\n            value,\\n            0,\\n            existingDeposit,\\n            ActionType.DEPOSIT_FOR\\n        );\\n    }\\n\\n    // @notice Deposit `value` for `msg.sender` and lock untill `unlockTime`\\n    // @param value Amount of tokens to deposit\\n    // @param unlockTime Time when the tokens will be unlocked\\n    // @param autoCooldown Choose to opt in to auto-cooldown\\n    // @dev if autoCooldown is true, the user\\u0027s veSPA balance will\\n    //      decay to 0 after `unlockTime` else the user\\u0027s veSPA balance\\n    //      will remain = residual balance till user initiates cooldown\\n    // @dev unlockTime is rownded down to whole weeks\\n    function createLock(\\n        uint128 value,\\n        uint256 unlockTime,\\n        bool autoCooldown\\n    ) external override nonReentrant {\\n        address account = _msgSender();\\n        uint256 roundedUnlockTime = (unlockTime / WEEK) * WEEK;\\n        LockedBalance memory existingDeposit = lockedBalances[account];\\n\\n        require(value \\u003e 0, \\\"Cannot lock 0 tokens\\\");\\n        require(existingDeposit.amount == 0, \\\"Withdraw old tokens first\\\");\\n        require(roundedUnlockTime \\u003e block.timestamp, \\\"Cannot lock in the past\\\");\\n        require(\\n            roundedUnlockTime \\u003c= block.timestamp + MAX_TIME,\\n            \\\"Voting lock can be 4 years max\\\"\\n        );\\n        _depositFor(\\n            account,\\n            autoCooldown,\\n            autoCooldown,\\n            value,\\n            roundedUnlockTime,\\n            existingDeposit,\\n            ActionType.CREATE_LOCK\\n        );\\n    }\\n\\n    // @notice Deposit `value` additional tokens for `msg.sender` without\\n    //         modifying the locktime\\n    // @param value Amount of tokens to deposit\\n    function increaseAmount(uint128 value) external override nonReentrant {\\n        address account = _msgSender();\\n        LockedBalance memory existingDeposit = lockedBalances[account];\\n\\n        require(value \\u003e 0, \\\"Cannot deposit 0 tokens\\\");\\n        require(existingDeposit.amount \\u003e 0, \\\"No existing lock found\\\");\\n\\n        if (!existingDeposit.autoCooldown) {\\n            require(\\n                !existingDeposit.cooldownInitiated,\\n                \\\"Cannot deposit during cooldown\\\"\\n            );\\n        }\\n        // else: auto-cooldown is on, so user can deposit anytime prior to expiry\\n\\n        require(\\n            existingDeposit.end \\u003e block.timestamp,\\n            \\\"Lock expired. Withdraw\\\"\\n        );\\n        _depositFor(\\n            account,\\n            existingDeposit.autoCooldown,\\n            existingDeposit.cooldownInitiated,\\n            value,\\n            0,\\n            existingDeposit,\\n            ActionType.INCREASE_AMOUNT\\n        );\\n    }\\n\\n    // @notice Extend the locktime of `msg.sender`\\u0027s tokens to `unlockTime`\\n    // @param unlockTime New locktime\\n    function increaseUnlockTime(uint256 unlockTime) external override {\\n        address account = _msgSender();\\n        LockedBalance memory existingDeposit = lockedBalances[account];\\n        uint256 roundedUnlockTime = (unlockTime / WEEK) * WEEK; // Locktime is rounded down to weeks\\n\\n        require(existingDeposit.amount \\u003e 0, \\\"No existing lock found\\\");\\n        if (!existingDeposit.autoCooldown) {\\n            require(\\n                !existingDeposit.cooldownInitiated,\\n                \\\"Deposit is in cooldown\\\"\\n            );\\n        }\\n        // else: auto-cooldown is on, so user can increase unlocktime anytime prior to expiry\\n        require(\\n            existingDeposit.end \\u003e block.timestamp,\\n            \\\"Lock expired. Withdraw\\\"\\n        );\\n        require(\\n            roundedUnlockTime \\u003e existingDeposit.end,\\n            \\\"Can only increase lock duration\\\"\\n        );\\n        require(\\n            roundedUnlockTime \\u003c= block.timestamp + MAX_TIME,\\n            \\\"Voting lock can be 4 years max\\\"\\n        );\\n\\n        _depositFor(\\n            account,\\n            existingDeposit.autoCooldown,\\n            existingDeposit.cooldownInitiated,\\n            0,\\n            roundedUnlockTime,\\n            existingDeposit,\\n            ActionType.INCREASE_LOCK_TIME\\n        );\\n    }\\n\\n    // @notice Initiate the cooldown period for `msg.sender`\\u0027s deposit\\n    function initiateCooldown() external override {\\n        address account = _msgSender();\\n        LockedBalance memory existingDeposit = lockedBalances[account];\\n        require(existingDeposit.amount \\u003e 0, \\\"No existing lock found\\\");\\n        require(\\n            !existingDeposit.cooldownInitiated,\\n            \\\"Cooldown already initiated\\\"\\n        );\\n        require(\\n            block.timestamp \\u003e= existingDeposit.end - MIN_TIME,\\n            \\\"Can not initiate cool down\\\"\\n        );\\n\\n        uint256 roundedUnlockTime = ((block.timestamp + MIN_TIME) / WEEK) *\\n            WEEK;\\n\\n        _depositFor(\\n            account,\\n            existingDeposit.autoCooldown,\\n            true,\\n            0,\\n            roundedUnlockTime,\\n            existingDeposit,\\n            ActionType.INITIATE_COOLDOWN\\n        );\\n    }\\n\\n    // @notice Withdraw tokens for `msg.sender`\\n    // @dev Only possible if the locktime has expired\\n    function withdraw() external override nonReentrant {\\n        address account = _msgSender();\\n        LockedBalance memory existingDeposit = lockedBalances[account];\\n        require(existingDeposit.amount \\u003e 0, \\\"No existing lock found\\\");\\n        require(existingDeposit.cooldownInitiated, \\\"No cooldown initiated\\\");\\n        require(block.timestamp \\u003e= existingDeposit.end, \\\"Lock not expired.\\\");\\n        uint128 value = existingDeposit.amount;\\n\\n        LockedBalance memory oldDeposit = lockedBalances[account];\\n        lockedBalances[account] = LockedBalance(false, false, 0, 0);\\n        uint256 prevSupply = totalSPALocked;\\n        totalSPALocked -= value;\\n\\n        // oldDeposit can have either expired \\u003c= timestamp or 0 end\\n        // existingDeposit has 0 end\\n        // Both can have \\u003e= 0 amount\\n        _checkpoint(account, oldDeposit, LockedBalance(false, false, 0, 0));\\n\\n        IERC20Upgradeable(SPA).safeTransfer(account, value);\\n        emit Withdraw(account, value, block.timestamp);\\n        emit Supply(prevSupply, totalSPALocked);\\n    }\\n\\n    // ----------------------VIEW functions----------------------\\n    // NOTE:The following ERC20/minime-compatible methods are not real balanceOf and supply!!\\n    // They measure the weights for the purpose of voting, so they don\\u0027t represent real coins.\\n\\n    // @notice Binary search to estimate timestamp for block number\\n    // @param blockNumber Block number to estimate timestamp for\\n    // @param maxEpoch Don\\u0027t go beyond this epoch\\n    // @return Estimated timestamp for block number\\n    function _findBlockEpoch(uint256 blockNumber, uint256 maxEpoch)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 min = 0;\\n        uint256 max = maxEpoch;\\n\\n        for (uint256 i = 0; i \\u003c 128; i++) {\\n            if (min \\u003e= max) {\\n                break;\\n            }\\n            uint256 mid = (min + max + 1) / 2;\\n            if (pointHistory[mid].blk \\u003c= blockNumber) {\\n                min = mid;\\n            } else {\\n                max = mid - 1;\\n            }\\n        }\\n        return min;\\n    }\\n\\n    function _findUserTimestampEpoch(address addr, uint256 ts)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 min = 0;\\n        uint256 max = userPointEpoch[addr];\\n\\n        for (uint256 i = 0; i \\u003c 128; i++) {\\n            if (min \\u003e= max) {\\n                break;\\n            }\\n            uint256 mid = (min + max + 1) / 2;\\n            if (userPointHistory[addr][mid].ts \\u003c= ts) {\\n                min = mid;\\n            } else {\\n                max = mid - 1;\\n            }\\n        }\\n        return min;\\n    }\\n\\n    function _findGlobalTimestampEpoch(uint256 ts)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 min = 0;\\n        uint256 max = epoch;\\n\\n        for (uint256 i = 0; i \\u003c 128; i++) {\\n            if (min \\u003e= max) {\\n                break;\\n            }\\n            uint256 mid = (min + max + 1) / 2;\\n            if (pointHistory[mid].ts \\u003c= ts) {\\n                min = mid;\\n            } else {\\n                max = mid - 1;\\n            }\\n        }\\n        return min;\\n    }\\n\\n    // @notice Function to estimate the user deposit\\n    // @param autoCooldown Choose to opt in to auto-cooldown\\n    // @param value Amount of SPA to deposit\\n    // @param expectedUnlockTime The expected unlock time\\n    // @dev if autoCooldown is true, the user\\u0027s veSPA balance will\\n    //      decay to 0 after `unlockTime` else the user\\u0027s veSPA balance\\n    //      will remain = residual balance till user initiates cooldown\\n    // @return Estimated deposit\\n    function estimateDeposit(\\n        bool autoCooldown,\\n        uint128 value,\\n        uint256 expectedUnlockTime\\n    )\\n        public\\n        view\\n        returns (\\n            bool,\\n            int128 initialVespaBalance, // initial veSPA balance\\n            int128 slope, // slope of the user\\u0027s graph\\n            int128 bias, // bias of the user\\u0027s graph\\n            int128 residue, // residual balance\\n            uint256 actualUnlockTime, // actual rounded unlock time\\n            uint256 providedUnlockTime, // expected unlock time\\n            uint256 residuePeriodStart\\n        )\\n    {\\n        actualUnlockTime = (expectedUnlockTime / WEEK) * WEEK;\\n\\n        require(actualUnlockTime \\u003e block.timestamp, \\\"Cannot lock in the past\\\");\\n        require(\\n            actualUnlockTime \\u003c= block.timestamp + MAX_TIME,\\n            \\\"Voting lock can be 4 years max\\\"\\n        );\\n\\n        int128 amt = int128(value);\\n        slope = amt / I_YEAR;\\n\\n        if (!autoCooldown) {\\n            residue = (amt * I_MIN_TIME) / I_YEAR;\\n            residuePeriodStart = actualUnlockTime - WEEK;\\n            bias =\\n                slope *\\n                int128(\\n                    int256(actualUnlockTime - WEEK) - int256(block.timestamp)\\n                );\\n        } else {\\n            bias =\\n                slope *\\n                int128(int256(actualUnlockTime) - int256(block.timestamp));\\n        }\\n        if (bias \\u003c= 0) {\\n            bias = 0;\\n        }\\n        initialVespaBalance = bias + residue;\\n\\n        return (\\n            autoCooldown,\\n            initialVespaBalance,\\n            slope,\\n            bias,\\n            residue,\\n            actualUnlockTime,\\n            expectedUnlockTime,\\n            residuePeriodStart\\n        );\\n    }\\n\\n    // @notice Get the voting power for a user at the specified timestamp\\n    // @dev Adheres to ERC20 `balanceOf` interface for Aragon compatibility\\n    // @param addr User wallet address\\n    // @param ts Timestamp to get voting power at\\n    // @return Voting power of user at timestamp\\n    function balanceOf(address addr, uint256 ts)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        uint256 _epoch = _findUserTimestampEpoch(addr, ts);\\n        if (_epoch == 0) {\\n            return 0;\\n        } else {\\n            Point memory lastPoint = userPointHistory[addr][_epoch];\\n            lastPoint.bias -=\\n                lastPoint.slope *\\n                int128(int256(ts) - int256(lastPoint.ts));\\n            if (lastPoint.bias \\u003c 0) {\\n                lastPoint.bias = 0;\\n            }\\n            lastPoint.bias += lastPoint.residue;\\n            return uint256(int256(lastPoint.bias));\\n        }\\n    }\\n\\n    // @notice Get the current voting power for a user\\n    // @param addr User wallet address\\n    // @return Voting power of user at current timestamp\\n    function balanceOf(address addr) public view override returns (uint256) {\\n        return balanceOf(addr, block.timestamp);\\n    }\\n\\n    // @notice Get the voting power of `addr` at block `blockNumber`\\n    // @param addr User wallet address\\n    // @param blockNumber Block number to get voting power at\\n    // @return Voting power of user at block number\\n    function balanceOfAt(address addr, uint256 blockNumber)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        uint256 min = 0;\\n        uint256 max = userPointEpoch[addr];\\n\\n        // Find the approximate timestamp for the block number\\n        for (uint256 i = 0; i \\u003c 128; i++) {\\n            if (min \\u003e= max) {\\n                break;\\n            }\\n            uint256 mid = (min + max + 1) / 2;\\n            if (userPointHistory[addr][mid].blk \\u003c= blockNumber) {\\n                min = mid;\\n            } else {\\n                max = mid - 1;\\n            }\\n        }\\n\\n        // min is the userEpoch nearest to the block number\\n        Point memory uPoint = userPointHistory[addr][min];\\n        uint256 maxEpoch = epoch;\\n\\n        // blocktime using the global point history\\n        uint256 _epoch = _findBlockEpoch(blockNumber, maxEpoch);\\n        Point memory point0 = pointHistory[_epoch];\\n        uint256 dBlock = 0;\\n        uint256 dt = 0;\\n\\n        if (_epoch \\u003c maxEpoch) {\\n            Point memory point1 = pointHistory[_epoch + 1];\\n            dBlock = point1.blk - point0.blk;\\n            dt = point1.ts - point0.ts;\\n        } else {\\n            dBlock = blockNumber - point0.blk;\\n            dt = block.timestamp - point0.ts;\\n        }\\n\\n        uint256 blockTime = point0.ts;\\n        if (dBlock != 0) {\\n            blockTime += (dt * (blockNumber - point0.blk)) / dBlock;\\n        }\\n\\n        uPoint.bias -=\\n            uPoint.slope *\\n            int128(int256(blockTime) - int256(uPoint.ts));\\n        if (uPoint.bias \\u003c 0) {\\n            uPoint.bias = 0;\\n        }\\n        uPoint.bias += uPoint.residue;\\n        return uint256(int256(uPoint.bias));\\n    }\\n\\n    // @notice Calculate total voting power at some point in the past\\n    // @param point The point (bias/slope) to start search from\\n    // @param ts Timestamp to calculate total voting power at\\n    // @return Total voting power at timestamp\\n    function supplyAt(Point memory point, uint256 ts)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        Point memory lastPoint = point;\\n        uint256 ti = (lastPoint.ts / WEEK) * WEEK;\\n\\n        // Calculate the missing checkpoints\\n        for (uint256 i = 0; i \\u003c 255; i++) {\\n            ti += WEEK;\\n            int128 dSlope = 0;\\n            if (ti \\u003e ts) {\\n                ti = ts;\\n            } else {\\n                dSlope = slopeChanges[ti];\\n            }\\n            lastPoint.bias -=\\n                lastPoint.slope *\\n                int128(int256(ti) - int256(lastPoint.ts));\\n            if (ti == ts) {\\n                break;\\n            }\\n            lastPoint.slope += dSlope;\\n            lastPoint.ts = ti;\\n        }\\n\\n        if (lastPoint.bias \\u003c 0) {\\n            lastPoint.bias = 0;\\n        }\\n        lastPoint.bias += lastPoint.residue;\\n        return uint256(int256(lastPoint.bias));\\n    }\\n\\n    // @notice Calculate total voting power at a given timestamp\\n    // @return Total voting power at timestamp\\n    function totalSupply(uint256 ts) public view override returns (uint256) {\\n        uint256 _epoch = _findGlobalTimestampEpoch(ts);\\n        Point memory lastPoint = pointHistory[_epoch];\\n        return supplyAt(lastPoint, ts);\\n    }\\n\\n    // @notice Calculate total voting power at current timestamp\\n    // @return Total voting power at current timestamp\\n    function totalSupply() public view override returns (uint256) {\\n        return totalSupply(block.timestamp);\\n    }\\n\\n    // @notice Calculate total voting power at a given block number in past\\n    // @param blockNumber Block number to calculate total voting power at\\n    // @return Total voting power at block number\\n    function totalSupplyAt(uint256 blockNumber)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        require(blockNumber \\u003c= block.number);\\n        uint256 _epoch = epoch;\\n        uint256 targetEpoch = _findBlockEpoch(blockNumber, _epoch);\\n\\n        Point memory point0 = pointHistory[targetEpoch];\\n        uint256 dt = 0;\\n\\n        if (targetEpoch \\u003c _epoch) {\\n            Point memory point1 = pointHistory[targetEpoch + 1];\\n            dt =\\n                ((blockNumber - point0.blk) * (point1.ts - point0.ts)) /\\n                (point1.blk - point0.blk);\\n        } else {\\n            if (point0.blk != block.number) {\\n                dt =\\n                    ((blockNumber - point0.blk) *\\n                        (block.timestamp - point0.ts)) /\\n                    (block.number - point0.blk);\\n            }\\n        }\\n        // Now dt contains info on how far we are beyond point0\\n        return supplyAt(point0, point0.ts + dt);\\n    }\\n}\\n\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"GlobalCheckpoint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"Supply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum veSPA_v1.ActionType\",\"name\":\"actionType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"autoCooldown\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"locktime\",\"type\":\"uint256\"}],\"name\":\"UserCheckpoint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"I_MIN_TIME\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"\",\"type\":\"int128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"I_YEAR\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"\",\"type\":\"int128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SPA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WEEK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"autoCooldown\",\"type\":\"bool\"}],\"name\":\"createLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"}],\"name\":\"depositFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"autoCooldown\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"expectedUnlockTime\",\"type\":\"uint256\"}],\"name\":\"estimateDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"int128\",\"name\":\"initialVespaBalance\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"slope\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"bias\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"residue\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"actualUnlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"providedUnlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"residuePeriodStart\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getLastUserSlope\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"\",\"type\":\"int128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getUserPointHistoryTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"}],\"name\":\"increaseAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"name\":\"increaseUnlockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_SPA\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_version\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initiateCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedBalances\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"autoCooldown\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"cooldownInitiated\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"lockedEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pointHistory\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"bias\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"slope\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"residue\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blk\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"slopeChanges\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"\",\"type\":\"int128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSPALocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"totalSupplyAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userPointEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userPointHistory\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"bias\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"slope\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"residue\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blk\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "veSPA_v1", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://19385ccc1ebef63e604e938ce163d9255f448afbd305a1894f320bb246a0e050"}]}