{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.16;\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    function owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }\r\n}\r\ncontract Voter {\r\n    \r\n    struct Proposal{\r\n        bytes32 name;\r\n    }\r\n    \r\n    struct Ballot{\r\n        bytes32 name;\r\n        address chainperson;\r\n        bool blind;\r\n        bool finished;\r\n    }\r\n    \r\n    struct votedData{\r\n        uint256 proposal;\r\n        bool isVal;\r\n    }\r\n    \r\n    event Vote(\r\n        address votedPerson,\r\n        uint256 proposalIndex\r\n        );\r\n        \r\n    event Finish(\r\n        bool finished\r\n        );\r\n\r\n    mapping (address => mapping(uint256 => mapping(address => votedData))) votedDatas;\r\n    mapping (address => mapping(uint256 => address[])) voted;\r\n    mapping (address => mapping(uint256 => mapping(uint256 => uint256))) voteCount;\r\n    mapping (address => Ballot[]) public ballots;   \r\n    mapping (address => mapping(uint256 => Proposal[])) public proposals;\r\n    \r\n    function getBallotsNum(address chainperson) public constant returns (uint count) {\r\n        return ballots[chainperson].length; \r\n    }\r\n    function getProposalsNum(address chainperson, uint ballot) public constant returns (uint count) {\r\n        return proposals[chainperson][ballot].length;\r\n    }\r\n    \r\n    function getBallotIndex(address chainperson, bytes32 ballotName) public constant returns (uint index){\r\n        for (uint i=0;i<ballots[chainperson].length;i++){\r\n            if (ballots[chainperson][i].name == ballotName){\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    function isVoted(address chainperson, uint ballot) public constant returns (bool result){\r\n        for (uint8 i=0;i<voted[chainperson][ballot].length;i++){\r\n            if (voted[chainperson][ballot][i] == msg.sender){\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    function startNewBallot(bytes32 ballotName, bool blindParam, bytes32[] proposalNames) external returns (bool success){\r\n        for (uint8 y=0;y<ballots[msg.sender].length;y++){\r\n            if (ballots[msg.sender][i].name == ballotName){\r\n                revert();\r\n            }\r\n        }\r\n        ballots[msg.sender].push(Ballot({\r\n            name: ballotName, \r\n            chainperson: msg.sender, \r\n            blind: blindParam,\r\n            finished: false\r\n        }));\r\n        \r\n        uint ballotsNum = ballots[msg.sender].length;\r\n        for (uint8 i=0;i<proposalNames.length;i++){\r\n            proposals[msg.sender][ballotsNum-1].push(Proposal({name:proposalNames[i]}));\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function getVoted(address chainperson, uint256 ballot) public constant returns (address[]){\r\n        if (ballots[chainperson][ballot].blind == true){\r\n            revert();\r\n        }\r\n        return voted[chainperson][ballot];\r\n    }\r\n    \r\n    function getVotesCount(address chainperson, uint256 ballot, bytes32 proposalName) public constant returns (uint256 count){\r\n        if (ballots[chainperson][ballot].blind == true){\r\n            revert();\r\n        }\r\n        \r\n        for (uint8 i=0;i<proposals[chainperson][ballot].length;i++){\r\n            if (proposals[chainperson][ballot][i].name == proposalName){\r\n                return voteCount[chainperson][ballot][i];\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getVotedData(address chainperson, uint256 ballot, address voter) public constant returns (uint256 proposalNum){\r\n        if (ballots[chainperson][ballot].blind == true){\r\n            revert();\r\n        }\r\n        \r\n        if (votedDatas[chainperson][ballot][voter].isVal == true){\r\n            return votedDatas[chainperson][ballot][voter].proposal;\r\n        }\r\n    }\r\n    \r\n    function vote(address chainperson, uint256 ballot, uint256 proposalNum) external returns (bool success){\r\n        \r\n        if (ballots[chainperson][ballot].finished == true){\r\n            revert();\r\n        }\r\n        for (uint8 i = 0;i<voted[chainperson][ballot].length;i++){\r\n            if (votedDatas[chainperson][ballot][msg.sender].isVal == true){\r\n                revert();\r\n            }\r\n        }\r\n        voted[chainperson][ballot].push(msg.sender);\r\n        voteCount[chainperson][ballot][proposalNum]++;\r\n        votedDatas[chainperson][ballot][msg.sender] = votedData({proposal: proposalNum, isVal: true});\r\n        Vote(msg.sender, proposalNum);\r\n        return true;\r\n    }\r\n    \r\n    function getProposalIndex(address chainperson, uint256 ballot, bytes32 proposalName) public constant returns (uint index){\r\n        for (uint8 i=0;i<proposals[chainperson][ballot].length;i++){\r\n            if (proposals[chainperson][ballot][i].name == proposalName){\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    function finishBallot(bytes32 ballot) external returns (bool success){\r\n        for (uint8 i=0;i<ballots[msg.sender].length;i++){\r\n            if (ballots[msg.sender][i].name == ballot) {\r\n                if (ballots[msg.sender][i].chainperson == msg.sender){\r\n                    ballots[msg.sender][i].finished = true;\r\n                    Finish(true);\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getWinner(address chainperson, uint ballotIndex) public constant returns (bytes32 winnerName){\r\n            if (ballots[chainperson][ballotIndex].finished == false){\r\n                revert();\r\n            }\r\n            uint256 maxVotes;\r\n            bytes32 winner;\r\n            for (uint8 i=0;i<proposals[chainperson][ballotIndex].length;i++){\r\n                if (voteCount[chainperson][ballotIndex][i]>maxVotes){\r\n                    maxVotes = voteCount[chainperson][ballotIndex][i];\r\n                    winner = proposals[chainperson][ballotIndex][i].name;\r\n                }\r\n            }\r\n            return winner;\r\n    }\r\n}\r\ncontract Multisig {\r\n\r\n    /*\r\n    * Types\r\n    */\r\n    struct Transaction {\r\n        uint id;\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        TxnStatus status;\r\n        address[] confirmed;\r\n        address creator;\r\n    }\r\n\r\n    struct Wallet {\r\n        bytes32 name;\r\n        address creator;\r\n        uint id;\r\n        uint allowance;\r\n        address[] owners;\r\n        Log[] logs;\r\n        Transaction[] transactions;\r\n        uint appovalsreq;\r\n    }\r\n    \r\n    struct Log {\r\n        uint amount;\r\n        address sender;\r\n    }\r\n    \r\n    enum TxnStatus { Unconfirmed, Pending, Executed }\r\n    \r\n    /*\r\n    * Modifiers\r\n    */\r\n    modifier onlyOwner ( address creator, uint walletId ) {\r\n        bool found;\r\n        for (uint i = 0;i<wallets[creator][walletId].owners.length;i++){\r\n            if (wallets[creator][walletId].owners[i] == msg.sender){\r\n                found = true;\r\n            }\r\n        }\r\n        if (found){\r\n            _;\r\n        }\r\n    }\r\n    \r\n    /*\r\n    * Events\r\n    */\r\n    event WalletCreated(uint id);\r\n    event TxnSumbitted(uint id);\r\n    event TxnConfirmed(uint id);\r\n    event topUpBalance(uint value);\r\n\r\n    /*\r\n    * Storage\r\n    */\r\n    mapping (address => Wallet[]) public wallets;\r\n    \r\n    /*\r\n    * Constructor\r\n    */\r\n    function ibaMultisig() public{\r\n\r\n    }\r\n\r\n    /*\r\n    * Getters\r\n    */\r\n    function getWalletId(address creator, bytes32 name) external view returns (uint, bool){\r\n        for (uint i = 0;i<wallets[creator].length;i++){\r\n            if (wallets[creator][i].name == name){\r\n                return (i, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getOwners(address creator, uint id) external view returns (address[]){\r\n        return wallets[creator][id].owners;\r\n    }\r\n    \r\n    function getTxnNum(address creator, uint id) external view returns (uint){\r\n        require(wallets[creator][id].owners.length > 0);\r\n        return wallets[creator][id].transactions.length;\r\n    }\r\n    \r\n    function getTxn(address creator, uint walletId, uint id) external view returns (uint, address, uint, bytes, TxnStatus, address[], address){\r\n        Transaction storage txn = wallets[creator][walletId].transactions[id];\r\n        return (txn.id, txn.destination, txn.value, txn.data, txn.status, txn.confirmed, txn.creator);\r\n    }\r\n    \r\n    function getLogsNum(address creator, uint id) external view returns (uint){\r\n        return wallets[creator][id].logs.length;\r\n    }\r\n    \r\n    function getLog(address creator, uint id, uint logId) external view returns (address, uint){\r\n        return(wallets[creator][id].logs[logId].sender, wallets[creator][id].logs[logId].amount);\r\n    }\r\n    \r\n    /*\r\n    * Methods\r\n    */\r\n    \r\n    function createWallet(uint approvals, address[] owners, bytes32 name) external payable{\r\n\r\n        /* check if name was actually given */\r\n        require(name.length != 0);\r\n        \r\n        /*check if approvals num equals or greater than given owners num*/\r\n        require(approvals <= owners.length);\r\n        \r\n        /* check if wallets with given name already exists */\r\n        bool found;\r\n        for (uint i = 0; i<wallets[msg.sender].length;i++){\r\n            if (wallets[msg.sender][i].name == name){\r\n                found = true;\r\n            }\r\n        }\r\n        require (found == false);\r\n        \r\n        /*instantiate new wallet*/\r\n        uint currentLen = wallets[msg.sender].length++;\r\n        wallets[msg.sender][currentLen].name = name;\r\n        wallets[msg.sender][currentLen].creator = msg.sender;\r\n        wallets[msg.sender][currentLen].id = currentLen;\r\n        wallets[msg.sender][currentLen].allowance = msg.value;\r\n        wallets[msg.sender][currentLen].owners = owners;\r\n        wallets[msg.sender][currentLen].appovalsreq = approvals;\r\n        emit WalletCreated(currentLen);\r\n    }\r\n\r\n    function topBalance(address creator, uint id) external payable {\r\n        require (msg.value > 0 wei);\r\n        wallets[creator][id].allowance += msg.value;\r\n        \r\n        /* create new log entry */\r\n        uint loglen = wallets[creator][id].logs.length++;\r\n        wallets[creator][id].logs[loglen].amount = msg.value;\r\n        wallets[creator][id].logs[loglen].sender = msg.sender;\r\n        emit topUpBalance(msg.value);\r\n    }\r\n    \r\n    function submitTransaction(address creator, address destination, uint walletId, uint value, bytes data) onlyOwner (creator,walletId) external returns (bool) {\r\n        uint newTxId = wallets[creator][walletId].transactions.length++;\r\n        wallets[creator][walletId].transactions[newTxId].id = newTxId;\r\n        wallets[creator][walletId].transactions[newTxId].destination = destination;\r\n        wallets[creator][walletId].transactions[newTxId].value = value;\r\n        wallets[creator][walletId].transactions[newTxId].data = data;\r\n        wallets[creator][walletId].transactions[newTxId].creator = msg.sender;\r\n        emit TxnSumbitted(newTxId);\r\n        return true;\r\n    }\r\n\r\n    function confirmTransaction(address creator, uint walletId, uint txId) onlyOwner(creator, walletId) external returns (bool){\r\n        Wallet storage wallet = wallets[creator][walletId];\r\n        Transaction storage txn = wallet.transactions[txId];\r\n\r\n        //check whether this owner has already confirmed this txn\r\n                \r\n        bool f;\r\n        for (uint8 i = 0; i<txn.confirmed.length;i++){\r\n            if (txn.confirmed[i] == msg.sender){\r\n                f = true;\r\n            }\r\n        }\r\n        //push sender address into confirmed array if havent found\r\n                                                       \r\n        require(!f);\r\n        txn.confirmed.push(msg.sender);\r\n        \r\n        if (txn.confirmed.length == wallet.appovalsreq){\r\n            txn.status = TxnStatus.Pending;\r\n        }\r\n        \r\n        //fire event\r\n                                                       \r\n        emit TxnConfirmed(txId);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function executeTxn(address creator, uint walletId, uint txId) onlyOwner(creator, walletId) external returns (bool){\r\n        Wallet storage wallet = wallets[creator][walletId];\r\n        \r\n        Transaction storage txn = wallet.transactions[txId];\r\n        \r\n        /* check txn status */\r\n        require(txn.status == TxnStatus.Pending);\r\n        \r\n        /* check whether wallet has sufficient balance to send this transaction */\r\n        require(wallet.allowance >= txn.value);\r\n        \r\n        /* send transaction */\r\n        address dest = txn.destination;\r\n        uint val = txn.value;\r\n        bytes memory dat = txn.data;\r\n        assert(dest.call.value(val)(dat));\r\n            \r\n        /* change transaction's status to executed */\r\n        txn.status = TxnStatus.Executed;\r\n\r\n        /* change wallet's balance */\r\n        wallet.allowance = wallet.allowance - txn.value;\r\n\r\n        return true;\r\n        \r\n    }\r\n}\r\ncontract Escrow{\r\n    \r\n    struct Bid{\r\n        bytes32 name;\r\n        address oracle;\r\n        address seller;\r\n        address buyer;\r\n        uint price;\r\n        uint timeout;\r\n        dealStatus status;\r\n        uint fee;\r\n        bool isLimited;\r\n    }\r\n    \r\n    enum dealStatus{ unPaid, Pending, Closed, Rejected, Refund }\r\n    \r\n    mapping (address => Bid[]) public bids;\r\n    mapping (address => uint) public pendingWithdrawals;\r\n    \r\n    event amountRecieved(\r\n        address seller,\r\n        uint bidId\r\n    );\r\n    \r\n    event bidClosed(\r\n        address seller,\r\n        uint bidId\r\n        );\r\n        \r\n    event bidCreated(\r\n        address seller,\r\n        bytes32 name,\r\n        uint bidId\r\n        );\r\n        \r\n    event refundDone(\r\n        address seller,\r\n        uint bidId\r\n        );\r\n        \r\n    event withdrawDone(\r\n        address person,\r\n        uint amount\r\n        );\r\n    \r\n    event bidRejected(\r\n        address seller,\r\n        uint bidId\r\n        );\r\n        \r\n    function getBidIndex(address seller, bytes32 name) public constant returns (uint){\r\n        for (uint8 i=0;i<bids[seller].length;i++){\r\n            if (bids[seller][i].name == name){\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getBidsNum (address seller) public constant returns (uint bidsNum) {\r\n        return bids[seller].length;\r\n    }\r\n    \r\n    function sendAmount (address seller, uint bidId) external payable{\r\n        Bid storage a = bids[seller][bidId];\r\n        require(msg.value == a.price && a.status == dealStatus.unPaid);\r\n        if (a.isLimited == true){\r\n            require(a.timeout > block.number);\r\n        }\r\n        a.status = dealStatus.Pending;\r\n        amountRecieved(seller, bidId);\r\n    }\r\n    \r\n    function createBid (bytes32 name, address seller, address oracle, address buyer, uint price, uint timeout, uint fee) external{\r\n        require(name.length != 0 && price !=0);\r\n        bool limited = true;\r\n        if (timeout == 0){\r\n            limited = false;\r\n        }\r\n        bids[seller].push(Bid({\r\n            name: name, \r\n            oracle: oracle, \r\n            seller: seller, \r\n            buyer: buyer,\r\n            price: price,\r\n            timeout: block.number+timeout,\r\n            status: dealStatus.unPaid,\r\n            fee: fee,\r\n            isLimited: limited\r\n        }));\r\n        uint bidId = bids[seller].length-1;\r\n        bidCreated(seller, name, bidId);\r\n    }\r\n    \r\n    function closeBid(address seller, uint bidId) external returns (bool){\r\n        Bid storage bid = bids[seller][bidId];\r\n        if (bid.isLimited == true){\r\n            require(bid.timeout > block.number);\r\n        }\r\n        require(msg.sender == bid.oracle && bid.status == dealStatus.Pending);\r\n        bid.status = dealStatus.Closed;\r\n        pendingWithdrawals[bid.seller]+=bid.price-bid.fee;\r\n        pendingWithdrawals[bid.oracle]+=bid.fee;\r\n        withdraw(bid.seller);\r\n        withdraw(bid.oracle);\r\n        bidClosed(seller, bidId);\r\n        return true;\r\n    }\r\n    \r\n    function refund(address seller, uint bidId) external returns (bool){\r\n        require(bids[seller][bidId].buyer == msg.sender && bids[seller][bidId].isLimited == true && bids[seller][bidId].timeout < block.number && bids[seller][bidId].status == dealStatus.Pending);\r\n        Bid storage a = bids[seller][bidId];\r\n        a.status = dealStatus.Refund;\r\n        pendingWithdrawals[a.buyer] = a.price;\r\n        withdraw(a.buyer);\r\n        refundDone(seller,bidId);\r\n        return true;\r\n    }\r\n    function rejectBid(address seller, uint bidId) external returns (bool){\r\n        if (bids[seller][bidId].isLimited == true){\r\n            require(bids[seller][bidId].timeout > block.number);\r\n        }\r\n        require(msg.sender == bids[seller][bidId].oracle && bids[seller][bidId].status == dealStatus.Pending);\r\n        Bid storage bid = bids[seller][bidId];\r\n        bid.status = dealStatus.Rejected;\r\n        pendingWithdrawals[bid.oracle] = bid.fee;\r\n        pendingWithdrawals[bid.buyer] = bid.price-bid.fee;\r\n        withdraw(bid.buyer);\r\n        withdraw(bid.oracle);\r\n        bidRejected(seller, bidId);\r\n        return true;\r\n    }\r\n    \r\n    function withdraw(address person) private{\r\n        uint amount = pendingWithdrawals[person];\r\n        pendingWithdrawals[person] = 0;\r\n        person.transfer(amount);\r\n        withdrawDone(person, amount);\r\n    }\r\n    \r\n}\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\r\n\r\ncontract HideraNetwork {\r\n                \r\n    // Public variables of the token\r\n                \r\n    string public name;\r\n                \r\n    string public symbol;\r\n                \r\n    uint8 public decimals = 8;\r\n                \r\n    // 8 decimals is the strongly suggested default, avoid changing it\r\n                \r\n    uint256 public totalSupply;\r\n\r\n    // This creates an array with all balances\r\n                \r\n    mapping (address => uint256) public balanceOf;\r\n                \r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n                \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    // This generates a public event on the blockchain that will notify clients\r\n                \r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    // This notifies clients about the amount burnt\r\n                \r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    /**\r\n     * Constrctor function\r\n     *\r\n     * Initializes contract with initial supply tokens to the creator of the contract\r\n     */\r\n    function HideraNetwork(\r\n        uint256 initialSupply,\r\n        string tokenName,\r\n        string tokenSymbol\r\n    ) public {\r\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\r\n                \r\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\r\n                \r\n        name = tokenName;                                   // Set the name for display purposes\r\n                \r\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\r\n                \r\n    }\r\n\r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n                \r\n        // Prevent transfer to 0x0 address. Use burn() instead\r\n                \r\n        require(_to != 0x0);\r\n                \r\n        // Check if the sender has enough\r\n                \r\n        require(balanceOf[_from] >= _value);\r\n                \r\n        // Check for overflows\r\n                \r\n        require(balanceOf[_to] + _value > balanceOf[_to]);\r\n                \r\n        // Save this for an assertion in the future\r\n                \r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n                \r\n        // Subtract from the sender\r\n                \r\n        balanceOf[_from] -= _value;\r\n                \r\n        // Add the same to the recipient\r\n                \r\n        balanceOf[_to] += _value;\r\n                \r\n        emit Transfer(_from, _to, _value);\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n                \r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens from other address\r\n     *\r\n     * Send `_value` tokens to `_to` in behalf of `_from`\r\n     *\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     * @param _extraData some extra information to send to the approved contract\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other account\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the senders allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        emit Burn(_from, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\n/******************************************/\r\n/*       ADVANCED TOKEN STARTS HERE       */\r\n/******************************************/\r\n\r\ncontract HIDERA is owned, HideraNetwork {\r\n\r\n    uint256 public sellPrice;\r\n    uint256 public buyPrice;\r\n\r\n    mapping (address => bool) public frozenAccount;\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event FrozenFunds(address target, bool frozen);\r\n\r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function HIDERA(\r\n        uint256 initialSupply,\r\n        string tokenName,\r\n        string tokenSymbol,\r\n        uint256 tokenDecimals\r\n        \r\n    ) HideraNetwork(initialSupply, tokenName, tokenSymbol) public {}\r\n\r\n    /* Internal transfer, only can be called by this contract */\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\r\n        require (balanceOf[_from] >= _value);               // Check if the sender has enough\r\n        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\r\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\r\n        require(!frozenAccount[_to]);                       // Check if recipient is frozen\r\n        balanceOf[_from] -= _value;                         // Subtract from the sender\r\n        balanceOf[_to] += _value;                           // Add the same to the recipient\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n\r\n    /// @notice Create `mintedAmount` tokens and send it to `target`\r\n                \r\n    /// @param target Address to receive the tokens\r\n                \r\n    /// @param mintedAmount the amount of tokens it will receive\r\n                \r\n    function mintToken(address target, uint256 mintedAmount) onlyOwner public {\r\n        balanceOf[target] += mintedAmount;\r\n        totalSupply += mintedAmount;\r\n        emit Transfer(0, this, mintedAmount);\r\n        emit Transfer(this, target, mintedAmount);\r\n    }\r\n\r\n    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\r\n                \r\n    /// @param target Address to be frozen\r\n                \r\n    /// @param freeze either to freeze it or not\r\n                \r\n    function freezeAccount(address target, bool freeze) onlyOwner public {\r\n        frozenAccount[target] = freeze;\r\n        emit FrozenFunds(target, freeze);\r\n    }\r\n\r\n    /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth\r\n                \r\n    /// @param newSellPrice Price the users can sell to the contract\r\n                \r\n    /// @param newBuyPrice Price users can buy from the contract\r\n                \r\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {\r\n        sellPrice = newSellPrice;\r\n        buyPrice = newBuyPrice;\r\n    }\r\n\r\n    /// @notice Buy tokens from contract by sending ether\r\n                \r\n    function buy() payable public {\r\n        uint amount = msg.value / buyPrice;               // calculates the amount\r\n        _transfer(this, msg.sender, amount);              // makes the transfers\r\n    }\r\n\r\n    /// @notice Sell `amount` tokens to contract\r\n                \r\n    /// @param amount amount of tokens to be sold\r\n                \r\n    function sell(uint256 amount) public {\r\n        address myAddress = this;\r\n        require(myAddress.balance >= amount * sellPrice);      // checks if the contract has enough ether to buy\r\n        _transfer(msg.sender, this, amount);              // makes the transfers\r\n        msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. Its important to do this last to avoid recursion attacks\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"newSellPrice\",\"type\":\"uint256\"},{\"name\":\"newBuyPrice\",\"type\":\"uint256\"}],\"name\":\"setPrices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"mintedAmount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"name\":\"tokenName\",\"type\":\"string\"},{\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"name\":\"tokenDecimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"}]", "ContractName": "HIDERA", "CompilerVersion": "v0.4.25-nightly.2018.5.28+commit.c223b03", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000bebc200000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000006484944455241000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034844520000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://42268fd6f6c8c3d44c3393276fb710b40fa58b5a7f7a3787360f78866e9db8cd"}]}