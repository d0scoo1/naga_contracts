{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/core/proxy/infiniteProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../infiniteProxy/proxy.sol\\\";\\n\\ncontract InstaVault is Proxy {\\n    constructor(address admin_, address dummyImplementation_)\\n        Proxy(admin_, dummyImplementation_)\\n    {}\\n}\"\r\n    },\r\n    \"contracts/infiniteProxy/proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./events.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`.\\n */\\ncontract Internals is Events {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct SigsSlot {\\n        bytes4[] value;\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT =\\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Storage slot with the address of the current dummy-implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _DUMMY_IMPLEMENTATION_SLOT =\\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    function _getSlotImplSigsSlot(address implementation_)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\\"eip1967.proxy.implementation\\\", implementation_)\\n            );\\n    }\\n\\n    function _getSlotSigsImplSlot(bytes4 sig_) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\\"eip1967.proxy.implementation\\\", sig_));\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot_)\\n        internal\\n        pure\\n        returns (AddressSlot storage _r)\\n    {\\n        assembly {\\n            _r.slot := slot_\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `SigsSlot` with member `value` located at `slot`.\\n     */\\n    function getSigsSlot(bytes32 slot_)\\n        internal\\n        pure\\n        returns (SigsSlot storage _r)\\n    {\\n        assembly {\\n            _r.slot := slot_\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets new implementation and adds mapping from implementation to sigs and sig to implementation.\\n     */\\n    function _setImplementationSigs(\\n        address implementation_,\\n        bytes4[] memory sigs_\\n    ) internal {\\n        require(sigs_.length != 0, \\\"no-sigs\\\");\\n        bytes32 slot_ = _getSlotImplSigsSlot(implementation_);\\n        bytes4[] memory sigsCheck_ = getSigsSlot(slot_).value;\\n        require(sigsCheck_.length == 0, \\\"implementation-already-exist\\\");\\n        for (uint256 i = 0; i < sigs_.length; i++) {\\n            bytes32 sigSlot_ = _getSlotSigsImplSlot(sigs_[i]);\\n            require(\\n                getAddressSlot(sigSlot_).value == address(0),\\n                \\\"sig-already-exist\\\"\\n            );\\n            getAddressSlot(sigSlot_).value = implementation_;\\n        }\\n        getSigsSlot(slot_).value = sigs_;\\n        emit setImplementationLog(implementation_, sigs_);\\n    }\\n\\n    /**\\n     * @dev removes implementation and the mappings corresponding to it.\\n     */\\n    function _removeImplementationSigs(address implementation_) internal {\\n        bytes32 slot_ = _getSlotImplSigsSlot(implementation_);\\n        bytes4[] memory sigs_ = getSigsSlot(slot_).value;\\n        require(sigs_.length != 0, \\\"implementation-not-exist\\\");\\n        for (uint256 i = 0; i < sigs_.length; i++) {\\n            bytes32 sigSlot_ = _getSlotSigsImplSlot(sigs_[i]);\\n            delete getAddressSlot(sigSlot_).value;\\n        }\\n        delete getSigsSlot(slot_).value;\\n        emit removeImplementationLog(implementation_);\\n    }\\n\\n    function _getImplementationSigs(address implementation_)\\n        internal\\n        view\\n        returns (bytes4[] memory)\\n    {\\n        bytes32 slot_ = _getSlotImplSigsSlot(implementation_);\\n        return getSigsSlot(slot_).value;\\n    }\\n\\n    function _getSigImplementation(bytes4 sig_)\\n        internal\\n        view\\n        returns (address implementation_)\\n    {\\n        bytes32 slot_ = _getSlotSigsImplSlot(sig_);\\n        return getAddressSlot(slot_).value;\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Returns the current dummy-implementation.\\n     */\\n    function _getDummyImplementation() internal view returns (address) {\\n        return getAddressSlot(_DUMMY_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin_) internal {\\n        address oldAdmin_ = _getAdmin();\\n        require(\\n            newAdmin_ != address(0),\\n            \\\"ERC1967: new admin is the zero address\\\"\\n        );\\n        getAddressSlot(_ADMIN_SLOT).value = newAdmin_;\\n        emit setAdminLog(oldAdmin_, newAdmin_);\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setDummyImplementation(address newDummyImplementation_) internal {\\n        address oldDummyImplementation_ = _getDummyImplementation();\\n        getAddressSlot(_DUMMY_IMPLEMENTATION_SLOT)\\n            .value = newDummyImplementation_;\\n        emit setDummyImplementationLog(\\n            oldDummyImplementation_,\\n            newDummyImplementation_\\n        );\\n    }\\n\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation_) internal {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(\\n                gas(),\\n                implementation_,\\n                0,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by Implementations registry.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback(bytes4 sig_) internal {\\n        address implementation_ = _getSigImplementation(sig_);\\n        require(\\n            implementation_ != address(0),\\n            \\\"Liquidity: Not able to find implementation_\\\"\\n        );\\n        _delegate(implementation_);\\n    }\\n}\\n\\ncontract AdminStuff is Internals {\\n    modifier onlyAdmin() {\\n        require(msg.sender == _getAdmin(), \\\"not-the-admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev sets new admin.\\n     */\\n    function setAdmin(address newAdmin_) external onlyAdmin {\\n        _setAdmin(newAdmin_);\\n    }\\n\\n    /**\\n     * @dev sets new dummy-implementation.\\n     */\\n    function setDummyImplementation(address newDummyImplementation_)\\n        external\\n        onlyAdmin\\n    {\\n        _setDummyImplementation(newDummyImplementation_);\\n    }\\n\\n    /**\\n     * @dev adds new implementation address.\\n     */\\n    function addImplementation(address implementation_, bytes4[] calldata sigs_)\\n        external\\n        onlyAdmin\\n    {\\n        _setImplementationSigs(implementation_, sigs_);\\n    }\\n\\n    /**\\n     * @dev removes an existing implementation address.\\n     */\\n    function removeImplementation(address implementation_) external onlyAdmin {\\n        _removeImplementationSigs(implementation_);\\n    }\\n\\n    constructor(address admin_, address dummyImplementation_) {\\n        _setAdmin(admin_);\\n        _setDummyImplementation(dummyImplementation_);\\n    }\\n}\\n\\nabstract contract Proxy is AdminStuff {\\n    constructor(address admin_, address dummyImplementation_)\\n        AdminStuff(admin_, dummyImplementation_)\\n    {}\\n\\n    /**\\n     * @dev returns admin's address.\\n     */\\n    function getAdmin() external view returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    /**\\n     * @dev returns dummy-implementations's address.\\n     */\\n    function getDummyImplementation() external view returns (address) {\\n        return _getDummyImplementation();\\n    }\\n\\n    /**\\n     * @dev returns bytes4[] sigs from implementation address If not registered then returns empty array.\\n     */\\n    function getImplementationSigs(address impl_)\\n        external\\n        view\\n        returns (bytes4[] memory)\\n    {\\n        return _getImplementationSigs(impl_);\\n    }\\n\\n    /**\\n     * @dev returns implementation address from bytes4 sig. If sig is not registered then returns address(0).\\n     */\\n    function getSigsImplementation(bytes4 sig_)\\n        external\\n        view\\n        returns (address)\\n    {\\n        return _getSigImplementation(sig_);\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by Implementations registry.\\n     */\\n    fallback() external payable {\\n        _fallback(msg.sig);\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by Implementations registry.\\n     */\\n    receive() external payable {\\n        if (msg.sig != 0x00000000) {\\n            _fallback(msg.sig);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/infiniteProxy/events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract Events {\\n    event setAdminLog(address oldAdmin_, address newAdmin_);\\n\\n    event setDummyImplementationLog(\\n        address oldDummyImplementation_,\\n        address newDummyImplementation_\\n    );\\n\\n    event setImplementationLog(address implementation_, bytes4[] sigs_);\\n\\n    event removeImplementationLog(address implementation_);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dummyImplementation_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"name\":\"removeImplementationLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin_\",\"type\":\"address\"}],\"name\":\"setAdminLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDummyImplementation_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDummyImplementation_\",\"type\":\"address\"}],\"name\":\"setDummyImplementationLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4[]\",\"name\":\"sigs_\",\"type\":\"bytes4[]\"}],\"name\":\"setImplementationLog\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"sigs_\",\"type\":\"bytes4[]\"}],\"name\":\"addImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDummyImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"impl_\",\"type\":\"address\"}],\"name\":\"getImplementationSigs\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"sig_\",\"type\":\"bytes4\"}],\"name\":\"getSigsImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"name\":\"removeImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin_\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDummyImplementation_\",\"type\":\"address\"}],\"name\":\"setDummyImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "InstaVault", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000085b40eb65e49eb61de78a3a989752249f8837fc500000000000000000000000076b2d8a03ada1b767974aa6af20c86737eb3e103", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x2766dc21ac3c0b15a2445e5e8033a47304f91fdf", "SwarmSource": ""}]}