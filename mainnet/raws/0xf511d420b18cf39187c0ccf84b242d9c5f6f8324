{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"dao.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\npragma solidity ^0.8.7;\\n\\ncontract DAO {\\n    address public dao;\\n\\n    event DAOChanged(address from, address to);\\n\\n    constructor() {\\n        dao = msg.sender;\\n        emit DAOChanged(address(0), msg.sender);\\n    }\\n\\n    modifier onlyDAO() {\\n        require(msg.sender == dao, \\\"Only DAO\\\");\\n        _;\\n    }\\n\\n    function changeDAO(address _dao) external onlyDAO {\\n        require(_dao != address(0), \\\"DAO to ZERO\\\");\\n        address olddao = dao;\\n        dao = _dao;\\n        emit DAOChanged(olddao, dao);\\n    }\\n\\n}\\n\"},\"interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\npragma solidity ^0.8.7;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\n// Interfaces for contract interaction\\ninterface INterfaces {\\n    function balanceOf(address) external returns (uint256);\\n\\n    function transfer(address, uint256) external returns (bool);\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n}\\n\\n// For tokens that do not return true on transfers eg. USDT\\ninterface INterfacesNoR {\\n    function transfer(address, uint256) external;\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\"},\"owned.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\npragma solidity ^0.8.7;\\n\\ncontract Owned {\\n    address public owner;\\n    address public newOwner;\\n\\n    event OwnershipChanged(address from, address to);\\n\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnershipChanged(address(0), msg.sender);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        _;\\n    }\\n\\n    // owner can give super-rights to someone\\n    function giveOwnership(address user) external onlyOwner {\\n        require(user != address(0), \\\"User renounceOwnership\\\");\\n        newOwner = user;\\n    }\\n\\n    // new owner need to accept\\n    function acceptOwnership() external {\\n        require(msg.sender == newOwner, \\\"Only NewOwner\\\");\\n        emit OwnershipChanged(owner, newOwner);\\n        owner = msg.sender;\\n        delete newOwner;\\n    }\\n}\\n\"},\"TattooMoneyLaunchpadBuy.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.7;\\n\\n// TattooMoney.io Public Sale Contract - via StableCoins, ETH and wBTC\\n//\\n// USE ONLY OWN WALLET (Metamask, TrustWallet, Trezor, Ledger...)\\n// DO NOT SEND FROM EXCHANGES OR ANY SERVICES\\n//\\n// Use ONLY ETH network, ERC20 tokens (Not Binance/Tron/whatever!)\\n//\\n// Set approval to contract address or use USDC authorization first\\n//\\n// DO NOT SEND STABLE TOKENS DIRECTLY - IT WILL NOT COUNT THAT!\\n//\\n// Need 150k gas limit.\\n// Use proper pay* function\\n\\ncontract TattooMoneyLaunchpadBuy {\\n\\n    uint256 private constant DECIMALS_TAT2 = 18;\\n    uint256 private constant DECIMALS_DAI = 18;\\n    uint256 private constant DECIMALS_USD = 6;\\n    uint256 private constant DECIMALS_WBTC = 8;\\n\\n    /// max tokens per user is 75000 as $15000 is AML limit\\n    uint256 public constant maxTokens = 75_000*(10**DECIMALS_TAT2);\\n\\n    /// contract starts accepting transfers\\n    uint256 public  dateStart;\\n\\n    /// hard time limit\\n    uint256 public  dateEnd;\\n\\n    /// total collected USD\\n    uint256 public usdCollected;\\n\\n    /// sale is limited by tokens count\\n    uint256 public tokensLimit;\\n\\n    /// tokens sold in this sale\\n    uint256 public tokensSold;\\n\\n    uint256 public tokensforadolar = 5*(10**DECIMALS_TAT2);\\n\\n    // addresses of tokens\\n    address public tat2 = 0xb487d0328b109e302b9d817b6f46Cbd738eA08C2;\\n    address public usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n    address public dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n    address public wbtc = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\\n    address public usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n    address public wbtcoracle = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c;\\n    address public ethoracle = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\\n\\n    address public owner;\\n    address public newOwner;\\n\\n    bool public saleEnded;\\n\\n    // deposited USD tokens per token address\\n    mapping(address =\\u003e uint256) private _deposited;\\n\\n    /// Tokens bought by user\\n    mapping(address =\\u003e uint256) public tokensBoughtOf;\\n\\n    mapping(address =\\u003e bool) public KYCpassed;\\n\\n    event AcceptedUSD(address indexed user, uint256 amount);\\n    event AcceptedWBTC(address indexed user, uint256 amount);\\n    event AcceptedETH(address indexed user, uint256 amount);\\n\\n    string constant ERR_TRANSFER = \\\"Token transfer failed\\\";\\n    string constant ERR_SALE_LIMIT = \\\"Token sale limit reached\\\";\\n    string constant ERR_AML = \\\"AML sale limit reached\\\";\\n    string constant ERR_SOON = \\\"TOO SOON\\\";\\n\\n    /**\\n    Contract constructor\\n    @param _owner adddress of contract owner\\n    @param _startDate sale start timestamp\\n    @param _endDate sale end timestamp\\n     */\\n\\n    constructor(\\n        address _owner,\\n        uint256 _tokensLimit, // 10000000\\n        uint256 _startDate, // 14-2-2022  22:22:22 GMT (1644796800)\\n        uint256 _endDate //  22-12-2021  22:22:22 GMT (1645568542)\\n    ) {\\n        owner = _owner;\\n        tokensLimit = _tokensLimit * (10**DECIMALS_TAT2);\\n        dateStart = _startDate;\\n        dateEnd = _endDate;\\n    }\\n\\n    /**\\n        Add address that passed KYC\\n        @param user address to mark as fee-free\\n     */\\n    function addKYCpassed(address user) external onlyOwner {\\n        KYCpassed[user] = true;\\n    }\\n\\n    /**\\n        Remove address form KYC list\\n        @param user user to remove\\n     */\\n    function removeKYCpassed(address user) external onlyOwner {\\n        KYCpassed[user] = false;\\n    }\\n\\n    /**\\n    Pay in using USDC, use approve/transferFrom\\n    @param amount number of USDC (with decimals)\\n    */\\n    function payUSDC(uint256 amount) external {\\n        require(\\n            INterfaces(usdc).transferFrom(msg.sender, address(this), amount),\\n            ERR_TRANSFER\\n        );\\n        _pay(msg.sender, amount );\\n        _deposited[usdc] += amount;\\n    }\\n\\n    /**\\n    Pay in using USDT, need set approval first\\n    @param amount USDT amount (with decimals)\\n    */\\n    function payUSDT(uint256 amount) external {\\n        INterfacesNoR(usdt).transferFrom(msg.sender, address(this), amount);\\n        _pay(msg.sender, amount );\\n        _deposited[usdt] += amount;\\n    }\\n\\n    /**\\n    Pay in using DAI, need set approval first\\n    @param amount number of DAI (with 6 decimals)\\n    */\\n    function payDAI(uint256 amount) external {\\n        require(\\n            INterfaces(dai).transferFrom(msg.sender, address(this), amount),\\n            ERR_TRANSFER\\n        );\\n        _pay(msg.sender, amount / (10**12));\\n        _deposited[dai] += amount;\\n    }\\n\\n    /**\\n    Pay in using wBTC, need set approval first\\n    @param amount number of wBTC (with decimals)\\n    */\\n    function paywBTC(uint256 amount) external {\\n        require(\\n            INterfaces(wbtc).transferFrom(msg.sender, address(this), amount),\\n            ERR_TRANSFER\\n        );\\n        _paywBTC(msg.sender, amount );\\n        _deposited[wbtc] += amount;\\n    }\\n\\n    //\\n    // accept ETH\\n    //\\n\\n    receive() external payable {\\n        _payEth(msg.sender, msg.value);\\n    }\\n\\n    function payETH() external payable {\\n        _payEth(msg.sender, msg.value);\\n    }\\n\\n    /**\\n    Get ETH price from Chainlink.\\n    @return price for 1 ETH with 18 decimals\\n    */\\n    function tokensPerEth() public view returns (uint256) {\\n        int256 answer;\\n        (, answer, , , ) = INterfaces(ethoracle).latestRoundData();\\n        // geting price with 18 decimals\\n        return uint256((uint256(answer) * tokensforadolar)/10**8);\\n    }\\n\\n    /**\\n    Get BTC price from Chainlink.\\n    @return price for 1 BTC with 18 decimals\\n    */\\n    function tokensPerwBTC() public view returns (uint256) {\\n        int256 answer;\\n        (, answer, , , ) = INterfaces(wbtcoracle).latestRoundData();\\n        // geting price with 18 decimals\\n        return uint256((uint256(answer) * tokensforadolar)/10**8);\\n    }\\n\\n    /**\\n    How much tokens left to sale\\n    */\\n    function tokensLeft() external view returns (uint256) {\\n        return tokensLimit - tokensSold;\\n    }\\n\\n    function _payEth(address user, uint256 amount) internal notEnded {\\n        uint256 sold = (amount * tokensPerEth()) / (10**18);\\n        tokensSold += sold;\\n        require(tokensSold \\u003c= tokensLimit, ERR_SALE_LIMIT);\\n        tokensBoughtOf[user] += sold;\\n        if(!KYCpassed[user]){\\n          require(tokensBoughtOf[user] \\u003c= maxTokens, ERR_AML);\\n        }\\n        _sendTokens(user, sold);\\n        emit AcceptedETH(user, amount);\\n    }\\n\\n    function _paywBTC(address user, uint256 amount) internal notEnded {\\n        uint256 sold = (amount * tokensPerwBTC()) / (10**8);\\n        tokensSold += sold;\\n        require(tokensSold \\u003c= tokensLimit, ERR_SALE_LIMIT);\\n        tokensBoughtOf[user] += sold;\\n        if(!KYCpassed[user]){\\n          require(tokensBoughtOf[user] \\u003c= maxTokens, ERR_AML);\\n        }\\n        _sendTokens(user, sold);\\n        emit AcceptedWBTC(user, amount);\\n    }\\n\\n    function _pay(address user, uint256 usd) internal notEnded {\\n        uint256 sold = (usd * tokensforadolar) / (10**6);\\n        tokensSold += sold;\\n        require(tokensSold \\u003c= tokensLimit, ERR_SALE_LIMIT);\\n        tokensBoughtOf[user] += sold;\\n        if(!KYCpassed[user]){\\n          require(tokensBoughtOf[user] \\u003c= maxTokens, ERR_AML);\\n        }\\n        _sendTokens(user, sold);\\n        emit AcceptedUSD(user, usd);\\n    }\\n\\n    function _sendTokens(address user, uint256 amount) internal notEnded {\\n      require(\\n          INterfaces(tat2).transfer(user, amount),\\n          ERR_TRANSFER\\n      );\\n    }\\n\\n    //\\n    // modifiers\\n    //\\n\\n    modifier notEnded() {\\n        require(!saleEnded, \\\"Sale ended\\\");\\n        require(\\n            block.timestamp \\u003e dateStart \\u0026\\u0026 block.timestamp \\u003c dateEnd,\\n            \\\"Too soon or too late\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only for contract Owner\\\");\\n        _;\\n    }\\n\\n    /// Take out stables, wBTC  and ETH\\n    function takeAll() external onlyOwner {\\n        uint256 amt = INterfaces(usdt).balanceOf(address(this));\\n        if (amt \\u003e 0) {\\n            INterfacesNoR(usdt).transfer(owner, amt);\\n        }\\n        amt = INterfaces(usdc).balanceOf(address(this));\\n        if (amt \\u003e 0) {\\n            require(INterfaces(usdc).transfer(owner, amt), ERR_TRANSFER);\\n        }\\n        amt = INterfaces(dai).balanceOf(address(this));\\n        if (amt \\u003e 0) {\\n            require(INterfaces(dai).transfer(owner, amt), ERR_TRANSFER);\\n        }\\n        amt = INterfaces(wbtc).balanceOf(address(this));\\n        if (amt \\u003e 0) {\\n            require(INterfaces(wbtc).transfer(owner, amt), ERR_TRANSFER);\\n        }\\n        amt = address(this).balance;\\n        if (amt \\u003e 0) {\\n            payable(owner).transfer(amt);\\n        }\\n    }\\n\\n    /// we take unsold TAT2\\n    function TakeUnsoldTAT2() external onlyOwner {\\n        uint256 amt = INterfaces(tat2).balanceOf(address(this));\\n        if (amt \\u003e 0) {\\n            require(INterfaces(tat2).transfer(owner, amt), ERR_TRANSFER);\\n        }\\n    }\\n\\n    /// we can recover any ERC20!\\n    function recoverErc20(address token) external onlyOwner {\\n        uint256 amt = INterfaces(token).balanceOf(address(this));\\n        if (amt \\u003e 0) {\\n            INterfacesNoR(token).transfer(owner, amt); // use broken ERC20 to ignore return value\\n        }\\n    }\\n\\n    /// just in case\\n    function recoverEth() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n\\n    function EndSale() external onlyOwner {\\n        saleEnded = true;\\n    }\\n\\n    function changeOwner(address _newOwner) external onlyOwner {\\n        newOwner = _newOwner;\\n    }\\n\\n    function acceptOwnership() external {\\n        require(\\n            msg.sender != address(0) \\u0026\\u0026 msg.sender == newOwner,\\n            \\\"Only NewOwner\\\"\\n        );\\n        newOwner = address(0);\\n        owner = msg.sender;\\n    }\\n}\\n\\n// Interfaces for contract interaction\\ninterface INterfaces {\\n    function balanceOf(address) external returns (uint256);\\n\\n    function transfer(address, uint256) external returns (bool);\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    // chainlink ETH/USD, ethoracle\\n    // answer|int256 :  304706968812 - 8 decimals\\n\\n    // chainlink BTC/USD wbtcoracle\\n    // answer|int256 : 4419282000000 - 8 decimals\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\\n// For tokens that do not return true on transfers eg. USDT\\ninterface INterfacesNoR {\\n    function transfer(address, uint256) external;\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\\n// by Patrick\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokensLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endDate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AcceptedETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AcceptedUSD\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AcceptedWBTC\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EndSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"KYCpassed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TakeUnsoldTAT2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"addKYCpassed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dateEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dateStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethoracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"payDAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"payUSDC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"payUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"paywBTC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"recoverErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"removeKYCpassed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tat2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensBoughtOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensPerEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensPerwBTC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensforadolar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wbtc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wbtcoracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TattooMoneyLaunchpadBuy", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000009f8e0bdada7ba929509ce92cbbbed0fb129c883200000000000000000000000000000000000000000000000000000000009896800000000000000000000000000000000000000000000000000000000062099b80000000000000000000000000000000000000000000000000000000006215621e", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://07110add2b64330fe305853f2ac45e16f57acc4722640c3c7ea5f2c4ffc12880"}]}