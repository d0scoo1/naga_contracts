{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/council/simpleProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.3;\\n\\ncontract SimpleProxy {\\n    // This contract splits the storage of a contract from its logic, it will\\n    // call an implementation contract via delegatecall. That implementation\\n    // changes what is stored in this contract, by changing the implementation\\n    // address this contract effectively has different logic.\\n\\n    // NOTE - Functions 'upgradeProxy', 'resetProxyOwner', 'proxyImplementation' and 'proxyGovernance'\\n    // are occupied namespace and cannot be used in implementation contracts. In a very unlikely\\n    // edge case a 4 bit hash collision between function selectors could block other function names.\\n\\n    // The implementation contains the logic for this proxy, it for security reasons\\n    // should not assume only this contract can call it.\\n    // NOTE - It's insecure in implementation proxies to use the default storage layout since\\n    //        it is possible to overwrite this address. Use Storage.sol for storage.\\n    address public proxyImplementation;\\n    // The address which can upgrade this contract\\n    address public proxyGovernance;\\n\\n    /// @notice Sets up the authorizable library for the proxy\\n    /// @param _governance An address which will be authorized to change the implementation\\n    ///                    it will also be set at the owner of this contract.\\n    /// @param _firstImplementation The first implementation address\\n    constructor(address _governance, address _firstImplementation) {\\n        // Set governance\\n        proxyGovernance = _governance;\\n        // Set the first implementation\\n        proxyImplementation = _firstImplementation;\\n    }\\n\\n    /// @notice Allows authorized addresses to change the implementation\\n    /// @param _newImplementation The new implementation address\\n    function upgradeProxy(address _newImplementation) external {\\n        require(msg.sender == proxyGovernance, \\\"unauthorized\\\");\\n        proxyImplementation = _newImplementation;\\n    }\\n\\n    /// @notice Sets the address which can upgrade this proxy, only callable\\n    ///         by the current address which can upgrade this proxy.\\n    /// @param _newGovernance The new governance address\\n    function resetProxyOwner(address _newGovernance) external {\\n        require(msg.sender == proxyGovernance, \\\"unauthorized\\\");\\n        proxyGovernance = _newGovernance;\\n    }\\n\\n    /// @notice The fallback is the routing function for the proxy and uses delegatecall\\n    ///         to forward any calls which are made to this address to be executed by the\\n    ///         logic contract.\\n    /// @dev WARNING - We don't do extcode size checks like high level solidity if the\\n    ///                implementation has 0 bytecode this will succeed but do nothing.\\n    fallback() external payable {\\n        assembly {\\n            let calldataLength := calldatasize()\\n\\n            // equivalent to receive() external payable {}\\n            if iszero(calldataLength) {\\n                return(0, 0)\\n            }\\n\\n            // We load the free memory pointer\\n            // Note - We technically don't need to do this because the whole call is\\n            // in assembly but it's good practice to match solidity's memory management\\n            let ptr := mload(0x40)\\n            // Copy the calldata into memory\\n            calldatacopy(\\n                // The position in memory this copies to\\n                ptr,\\n                // The calldata index this copies from\\n                0,\\n                // The number of bytes to copy\\n                calldataLength\\n            )\\n            // Move the free memory pointer\\n            mstore(0x40, add(ptr, calldataLength))\\n            // Load the implementation address\\n            let implementation := sload(proxyImplementation.slot)\\n            // It's very unlikely any extra data got loaded but we clean anyway\\n            implementation := and(\\n                implementation,\\n                0x000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n            )\\n            // Now we make the delegatecall\\n            let success := delegatecall(\\n                // The gas param\\n                gas(),\\n                // The address\\n                implementation,\\n                // The memory location of the input data\\n                ptr,\\n                // The input size\\n                calldataLength,\\n                // The output memory pointer and size, we use the return data instead\\n                0,\\n                0\\n            )\\n            // Load our new free memory pointer\\n            ptr := mload(0x40)\\n            // Load the return data size\\n            let returndataLength := returndatasize()\\n            // Copy the return data\\n            returndatacopy(\\n                // Memory location of the output\\n                ptr,\\n                // Memory location of the input\\n                0,\\n                // Length of the input\\n                returndataLength\\n            )\\n            // If the call was not successful we revert\\n            if iszero(success) {\\n                revert(ptr, returndataLength)\\n            }\\n\\n            // If the call was successful we return\\n            return(ptr, returndataLength)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_firstImplementation\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"proxyGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernance\",\"type\":\"address\"}],\"name\":\"resetProxyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SimpleProxy", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000422494292e7a9dda8778bb4ea05c2779a3d60f5d0000000000000000000000006f51da68446e568fe24be166917a99d4da7ee1d0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x6f51da68446e568fe24be166917a99d4da7ee1d0", "SwarmSource": ""}]}