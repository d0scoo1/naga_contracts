{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0\r\n\r\npragma solidity ^0.8.11;\r\n\r\n/// @notice 1-of-1 NFT.\r\n/// adapted from https://gist.github.com/z0r0z/ea0b752aa9537070b0d61f8a74d5c10c\r\ncontract SingleNFT {\r\n    address private owner;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\r\n\r\n    function balanceOf(address) external pure returns (uint256) {\r\n        return 1;\r\n    }\r\n\r\n    function ownerOf(uint256) external view returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    /// @notice Returns a string from a null terminated bytes array in memory\r\n    /// @dev Works backwards from the end of the byte array so that it only needs one for loop\r\n    function _nullTerminatedString(bytes memory input) public pure returns (string memory) {\r\n        bytes memory output;\r\n        for (uint256 i = input.length; i > 0; i--) {\r\n            // Find the first non null byte\r\n            if (uint8(input[i - 1]) != 0) {\r\n                // Initialize the output byte array\r\n                if (output.length == 0) {\r\n                    output = new bytes(i);\r\n                }\r\n\r\n                output[i - 1] = input[i - 1];\r\n            }\r\n        }\r\n\r\n        return string(output);\r\n    }\r\n\r\n    function name() external pure returns (string memory) {\r\n        uint256 offset = _getImmutableArgsOffset();\r\n        bytes32 nameBytes;\r\n        assembly {\r\n            nameBytes := calldataload(offset)\r\n        }\r\n        return _nullTerminatedString(abi.encodePacked(nameBytes));\r\n    }\r\n\r\n    function symbol() external pure returns (string memory) {\r\n        uint256 offset = _getImmutableArgsOffset();\r\n        bytes16 symbolBytes;\r\n        assembly {\r\n            symbolBytes := calldataload(add(offset, 0x20))\r\n        }\r\n        return _nullTerminatedString(abi.encodePacked(symbolBytes));\r\n    }\r\n\r\n    function tokenURI(uint256) external pure returns (string memory) {\r\n        uint256 offset = _getImmutableArgsOffset();\r\n        bytes32 uriBytes1;\r\n        bytes16 uriBytes2;\r\n        assembly {\r\n            uriBytes1 := calldataload(add(offset, 0x30))\r\n            uriBytes2 := calldataload(add(offset, 0x50))\r\n        }\r\n        return _nullTerminatedString(abi.encodePacked(\"ipfs://\", uriBytes1, uriBytes2));\r\n    }\r\n\r\n    /// @return offset The offset of the packed immutable args in calldata\r\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            offset := sub(calldatasize(), add(shr(240, calldataload(sub(calldatasize(), 2))), 2))\r\n        }\r\n    }\r\n\r\n    /// @notice Random function name to save gas. Thanks to @_apedev for early access.\r\n    /// https://twitter.com/_apedev/status/1483827473930407936\r\n    /// Also payable to save even more gas\r\n    function mint_d22vi9okr4w(address to) external payable {\r\n        require(owner == address(0), \"Already minted\");\r\n        owner = to;\r\n\r\n        emit Transfer(address(0), to, 0);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\r\n        return interfaceId == 0x01ffc9a7 || interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;\r\n    }\r\n}\r\nlibrary ClonesWithCallData {\r\n    function cloneWithCallDataProvision(\r\n        address implementation,\r\n        bytes memory data\r\n    ) internal returns (address instance) {\r\n        // unrealistic for memory ptr or data length to exceed 256 bits\r\n        unchecked {\r\n            uint256 extraLength = data.length + 2; // +2 bytes for telling how much data there is appended to the call\r\n            uint256 creationSize = 0x43 + extraLength;\r\n            uint256 runSize = creationSize - 11;\r\n            uint256 dataPtr;\r\n            uint256 ptr;\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                ptr := mload(0x40)\r\n\r\n                // -------------------------------------------------------------------------------------------------------------\r\n                // CREATION (11 bytes)\r\n                // -------------------------------------------------------------------------------------------------------------\r\n\r\n                // 3d          | RETURNDATASIZE        | 0                       | \u2013\r\n                // 61 runtime  | PUSH2 runtime (r)     | r 0                     | \u2013\r\n                mstore(\r\n                    ptr,\r\n                    0x3d61000000000000000000000000000000000000000000000000000000000000\r\n                )\r\n                mstore(add(ptr, 0x02), shl(240, runSize)) // size of the contract running bytecode (16 bits)\r\n\r\n                // creation size = 0b\r\n                // 80          | DUP1                  | r r 0                   | \u2013\r\n                // 60 creation | PUSH1 creation (c)    | c r r 0                 | \u2013\r\n                // 3d          | RETURNDATASIZE        | 0 c r r 0               | \u2013\r\n                // 39          | CODECOPY              | r 0                     | [0-2d]: runtime code\r\n                // 81          | DUP2                  | 0 c  0                  | [0-2d]: runtime code\r\n                // f3          | RETURN                | 0                       | [0-2d]: runtime code\r\n                mstore(\r\n                    add(ptr, 0x04),\r\n                    0x80600b3d3981f300000000000000000000000000000000000000000000000000\r\n                )\r\n\r\n                // -------------------------------------------------------------------------------------------------------------\r\n                // RUNTIME\r\n                // -------------------------------------------------------------------------------------------------------------\r\n\r\n                // 36          | CALLDATASIZE          | cds                     | \u2013\r\n                // 3d          | RETURNDATASIZE        | 0 cds                   | \u2013\r\n                // 3d          | RETURNDATASIZE        | 0 0 cds                 | \u2013\r\n                // 37          | CALLDATACOPY          | \u2013                       | [0, cds] = calldata\r\n                // 61          | PUSH2 extra           | extra                   | [0, cds] = calldata\r\n                mstore(\r\n                    add(ptr, 0x0b),\r\n                    0x363d3d3761000000000000000000000000000000000000000000000000000000\r\n                )\r\n                mstore(add(ptr, 0x10), shl(240, extraLength))\r\n\r\n                // 60 0x38     | PUSH1 0x38            | 0x38 extra              | [0, cds] = calldata // 0x38 (56) is runtime size - data\r\n                // 36          | CALLDATASIZE          | cds 0x38 extra          | [0, cds] = calldata\r\n                // 39          | CODECOPY              | _                       | [0, cds] = calldata\r\n                // 3d          | RETURNDATASIZE        | 0                       | [0, cds] = calldata\r\n                // 3d          | RETURNDATASIZE        | 0 0                     | [0, cds] = calldata\r\n                // 3d          | RETURNDATASIZE        | 0 0 0                   | [0, cds] = calldata\r\n                // 36          | CALLDATASIZE          | cds 0 0 0               | [0, cds] = calldata\r\n                // 61 extra    | PUSH2 extra           | extra cds 0 0 0         | [0, cds] = calldata\r\n                mstore(\r\n                    add(ptr, 0x12),\r\n                    0x603836393d3d3d36610000000000000000000000000000000000000000000000\r\n                )\r\n                mstore(add(ptr, 0x1b), shl(240, extraLength))\r\n\r\n                // 01          | ADD                   | cds+extra 0 0 0         | [0, cds] = calldata\r\n                // 3d          | RETURNDATASIZE        | 0 cds 0 0 0             | [0, cds] = calldata\r\n                // 73 addr     | PUSH20 0x123\u2026         | addr 0 cds 0 0 0        | [0, cds] = calldata\r\n                mstore(\r\n                    add(ptr, 0x1d),\r\n                    0x013d730000000000000000000000000000000000000000000000000000000000\r\n                )\r\n                mstore(add(ptr, 0x20), shl(0x60, implementation))\r\n\r\n                // 5a          | GAS                   | gas addr 0 cds 0 0 0    | [0, cds] = calldata\r\n                // f4          | DELEGATECALL          | success 0               | [0, cds] = calldata\r\n                // 3d          | RETURNDATASIZE        | rds success 0           | [0, cds] = calldata\r\n                // 82          | DUP3                  | 0 rds success 0         | [0, cds] = calldata\r\n                // 80          | DUP1                  | 0 0 rds success 0       | [0, cds] = calldata\r\n                // 3e          | RETURNDATACOPY        | success 0               | [0, rds] = return data (there might be some irrelevant leftovers in memory [rds, cds] when rds < cds)\r\n                // 90          | SWAP1                 | 0 success               | [0, rds] = return data\r\n                // 3d          | RETURNDATASIZE        | rds 0 success           | [0, rds] = return data\r\n                // 91          | SWAP2                 | success 0 rds           | [0, rds] = return data\r\n                // 60 0x36     | PUSH1 0x36            | 0x36 sucess 0 rds       | [0, rds] = return data\r\n                // 57          | JUMPI                 | 0 rds                   | [0, rds] = return data\r\n                // fd          | REVERT                | \u2013                       | [0, rds] = return data\r\n                // 5b          | JUMPDEST              | 0 rds                   | [0, rds] = return data\r\n                // f3          | RETURN                | \u2013                       | [0, rds] = return data\r\n\r\n                mstore(\r\n                    add(ptr, 0x34),\r\n                    0x5af43d82803e903d91603657fd5bf30000000000000000000000000000000000\r\n                )\r\n            }\r\n\r\n            // -------------------------------------------------------------------------------------------------------------\r\n            // APPENDED DATA (Accessible from extcodecopy)\r\n            // (but also send as appended data to the delegatecall)\r\n            // -------------------------------------------------------------------------------------------------------------\r\n\r\n            extraLength -= 2;\r\n            uint256 counter = extraLength;\r\n            uint256 copyPtr = ptr + 0x43;\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                dataPtr := add(data, 32)\r\n            }\r\n            for (; counter >= 32; counter -= 32) {\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    mstore(copyPtr, mload(dataPtr))\r\n                }\r\n\r\n                copyPtr += 32;\r\n                dataPtr += 32;\r\n            }\r\n            uint256 mask = ~(256**(32 - counter) - 1);\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                mstore(copyPtr, and(mload(dataPtr), mask))\r\n            }\r\n            copyPtr += counter;\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                mstore(copyPtr, shl(240, extraLength))\r\n            }\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                instance := create(0, ptr, creationSize)\r\n            }\r\n            require(instance != address(0), \"create failed\");\r\n        }\r\n    }\r\n}\r\n\r\n/// @title SingleNFTFactory\r\n/// @author https://twitter.com/devan_non https://github.com/devanonon\r\n/// @notice Factory for deploying ERC721 contracts cheaply\r\n/// @dev Based on https://github.com/ZeframLou/vested-erc20\r\n/// and inspiried by this thread: https://twitter.com/alcuadrado/status/1484333520071708672\r\ncontract SingleNFTFactory {\r\n    /// -----------------------------------------------------------------------\r\n    /// Library usage\r\n    /// -----------------------------------------------------------------------\r\n\r\n    using ClonesWithCallData for address;\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Immutable parameters\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice The ERC721 used as the template for all clones created\r\n    SingleNFT public immutable implementation;\r\n\r\n    constructor(SingleNFT implementation_) {\r\n        implementation = implementation_;\r\n    }\r\n\r\n    /// @notice Creates a SingleNFT contract\r\n    /// @dev Uses a modified minimal proxy contract that stores immutable parameters in code and\r\n    /// passes them in through calldata. See ClonesWithCallData. Make 96 byte token URI\r\n    /// @param _name The name of the ERC721 token (restricted to 32 bytes)\r\n    /// @param _symbol The symbol of the ERC721 token (restricted to 16 bytes)\r\n    /// @param _URI1 First part of the IPFS hash, requires client to split up URI for gas savings\r\n    /// @param _URI2 Second part of the IPFS hash, requires client to split up URI for gas savings\r\n    /// @return erc721 The created SingleNFT contract\r\n    function createERC721(\r\n        bytes32 _name,\r\n        bytes16 _symbol,\r\n        bytes32 _URI1,\r\n        bytes16 _URI2\r\n    ) external returns (SingleNFT erc721) {\r\n        bytes memory ptr = new bytes(96);\r\n        assembly {\r\n            mstore(add(ptr, 0x20), _name)\r\n            mstore(add(ptr, 0x40), _symbol)\r\n            mstore(add(ptr, 0x50), _URI1)\r\n            mstore(add(ptr, 0x70), _URI2)\r\n        }\r\n\r\n        erc721 = SingleNFT(\r\n            address(implementation).cloneWithCallDataProvision(ptr)\r\n        );\r\n        // Random function name to save gas, see comments in function for explanation\r\n        erc721.mint_d22vi9okr4w(msg.sender);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract SingleNFT\",\"name\":\"implementation_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes16\",\"name\":\"_symbol\",\"type\":\"bytes16\"},{\"internalType\":\"bytes32\",\"name\":\"_URI1\",\"type\":\"bytes32\"},{\"internalType\":\"bytes16\",\"name\":\"_URI2\",\"type\":\"bytes16\"}],\"name\":\"createERC721\",\"outputs\":[{\"internalType\":\"contract SingleNFT\",\"name\":\"erc721\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"contract SingleNFT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SingleNFTFactory", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000006ab91b6c77ab3782d91c85cb7066b2b82bfe7873", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://423a4676f4a520527db286899152389eab7946ce8159a409331943f3430761b7"}]}