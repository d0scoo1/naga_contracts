{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n// Copyright (C) 2018 Lev Livnev <lev@liv.nev.org.uk>\n// Copyright (C) 2020-2021 Maker Ecosystem Growth Holdings, INC.\npragma solidity ^0.8.4;\n\ninterface ICodex {\n    function init(address vault) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address,\n        bytes32,\n        uint256\n    ) external;\n\n    function credit(address) external view returns (uint256);\n\n    function unbackedDebt(address) external view returns (uint256);\n\n    function balances(\n        address,\n        uint256,\n        address\n    ) external view returns (uint256);\n\n    function vaults(address vault)\n        external\n        view\n        returns (\n            uint256 totalNormalDebt,\n            uint256 rate,\n            uint256 debtCeiling,\n            uint256 debtFloor\n        );\n\n    function positions(\n        address vault,\n        uint256 tokenId,\n        address position\n    ) external view returns (uint256 collateral, uint256 normalDebt);\n\n    function globalDebt() external view returns (uint256);\n\n    function globalUnbackedDebt() external view returns (uint256);\n\n    function globalDebtCeiling() external view returns (uint256);\n\n    function delegates(address, address) external view returns (uint256);\n\n    function grantDelegate(address) external;\n\n    function revokeDelegate(address) external;\n\n    function modifyBalance(\n        address,\n        uint256,\n        address,\n        int256\n    ) external;\n\n    function transferBalance(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function transferCredit(\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function modifyCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function transferCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function confiscateCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function settleUnbackedDebt(uint256 debt) external;\n\n    function createUnbackedDebt(\n        address debtor,\n        address creditor,\n        uint256 debt\n    ) external;\n\n    function modifyRate(\n        address vault,\n        address creditor,\n        int256 rate\n    ) external;\n\n    function lock() external;\n}interface IPriceCalculator {\n    // 1st arg: initial price [wad]\n    // 2nd arg: seconds since auction start [seconds]\n    // returns: current auction price [wad]\n    function price(uint256, uint256) external view returns (uint256);\n}\n\ninterface IPriceFeed {\n    function peek() external returns (bytes32, bool);\n\n    function read() external view returns (bytes32);\n}\n\ninterface ICollybus {\n    function vaults(address) external view returns (uint128, uint128);\n\n    function spots(address) external view returns (uint256);\n\n    function rates(uint256) external view returns (uint256);\n\n    function rateIds(address, uint256) external view returns (uint256);\n\n    function redemptionPrice() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint128 data\n    ) external;\n\n    function setParam(\n        address vault,\n        uint256 tokenId,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function updateDiscountRate(uint256 rateId, uint256 rate) external;\n\n    function updateSpot(address token, uint256 spot) external;\n\n    function read(\n        address vault,\n        address underlier,\n        uint256 tokenId,\n        uint256 maturity,\n        bool net\n    ) external view returns (uint256 price);\n\n    function lock() external;\n}\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n\ninterface IDebtAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function tokenToSellBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function aer() external view returns (address);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(\n        address recipient,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock() external;\n\n    function cancelAuction(uint256 id) external;\n}\ninterface ISurplusAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(uint256 creditToSell, uint256 bid) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 creditToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock(uint256 credit) external;\n\n    function cancelAuction(uint256 id) external;\n}\n\ninterface IAer {\n    function codex() external view returns (ICodex);\n\n    function surplusAuction() external view returns (ISurplusAuction);\n\n    function debtAuction() external view returns (IDebtAuction);\n\n    function debtQueue(uint256) external view returns (uint256);\n\n    function queuedDebt() external view returns (uint256);\n\n    function debtOnAuction() external view returns (uint256);\n\n    function auctionDelay() external view returns (uint256);\n\n    function debtAuctionSellSize() external view returns (uint256);\n\n    function debtAuctionBidSize() external view returns (uint256);\n\n    function surplusAuctionSellSize() external view returns (uint256);\n\n    function surplusBuffer() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function queueDebt(uint256 debt) external;\n\n    function unqueueDebt(uint256 queuedAt) external;\n\n    function settleDebtWithSurplus(uint256 debt) external;\n\n    function settleAuctionedDebt(uint256 debt) external;\n\n    function startDebtAuction() external returns (uint256 auctionId);\n\n    function startSurplusAuction() external returns (uint256 auctionId);\n\n    function transferCredit(address to, uint256 credit) external;\n\n    function lock() external;\n}\ninterface ILimes {\n    function codex() external view returns (ICodex);\n\n    function aer() external view returns (IAer);\n\n    function vaults(address)\n        external\n        view\n        returns (\n            address,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function live() external view returns (uint256);\n\n    function globalMaxDebtOnAuction() external view returns (uint256);\n\n    function globalDebtOnAuction() external view returns (uint256);\n\n    function setParam(bytes32 param, address data) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        address collateralAuction\n    ) external;\n\n    function liquidationPenalty(address vault) external view returns (uint256);\n\n    function liquidate(\n        address vault,\n        uint256 tokenId,\n        address position,\n        address keeper\n    ) external returns (uint256 auctionId);\n\n    function liquidated(\n        address vault,\n        uint256 tokenId,\n        uint256 debt\n    ) external;\n\n    function lock() external;\n}\n\ninterface CollateralAuctionCallee {\n    function collateralAuctionCall(\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external;\n}\n\ninterface ICollateralAuction {\n    function vaults(address)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            ICollybus,\n            IPriceCalculator\n        );\n\n    function codex() external view returns (ICodex);\n\n    function limes() external view returns (ILimes);\n\n    function aer() external view returns (IAer);\n\n    function feeTip() external view returns (uint64);\n\n    function flatTip() external view returns (uint192);\n\n    function auctionCounter() external view returns (uint256);\n\n    function activeAuctions(uint256) external view returns (uint256);\n\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            address,\n            uint256,\n            address,\n            uint96,\n            uint256\n        );\n\n    function stopped() external view returns (uint256);\n\n    function init(address vault, address collybus) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        address data\n    ) external;\n\n    function startAuction(\n        uint256 debt,\n        uint256 collateralToSell,\n        address vault,\n        uint256 tokenId,\n        address user,\n        address keeper\n    ) external returns (uint256 auctionId);\n\n    function redoAuction(uint256 auctionId, address keeper) external;\n\n    function takeCollateral(\n        uint256 auctionId,\n        uint256 collateralAmount,\n        uint256 maxPrice,\n        address recipient,\n        bytes calldata data\n    ) external;\n\n    function count() external view returns (uint256);\n\n    function list() external view returns (uint256[] memory);\n\n    function getStatus(uint256 auctionId)\n        external\n        view\n        returns (\n            bool needsRedo,\n            uint256 price,\n            uint256 collateralToSell,\n            uint256 debt\n        );\n\n    function updateAuctionDebtFloor(address vault) external;\n\n    function cancelAuction(uint256 auctionId) external;\n}interface ITenebrae {\n    function codex() external view returns (ICodex);\n\n    function limes() external view returns (ILimes);\n\n    function aer() external view returns (IAer);\n\n    function collybus() external view returns (ICollybus);\n\n    function live() external view returns (uint256);\n\n    function lockedAt() external view returns (uint256);\n\n    function cooldownDuration() external view returns (uint256);\n\n    function debt() external view returns (uint256);\n\n    function lostCollateral(address, uint256) external view returns (uint256);\n\n    function normalDebtByTokenId(address, uint256) external view returns (uint256);\n\n    function claimed(\n        address,\n        uint256,\n        address\n    ) external view returns (uint256);\n\n    function setParam(bytes32 param, address data) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function lockPrice(address vault, uint256 tokenId) external view returns (uint256);\n\n    function redemptionPrice(address vault, uint256 tokenId) external view returns (uint256);\n\n    function lock() external;\n\n    function skipAuction(address vault, uint256 auctionId) external;\n\n    function offsetPosition(\n        address vault,\n        uint256 tokenId,\n        address user\n    ) external;\n\n    function closePosition(address vault, uint256 tokenId) external;\n\n    function fixGlobalDebt() external;\n\n    function redeem(\n        address vault,\n        uint256 tokenId,\n        uint256 credit\n    ) external;\n}interface IVault {\n    function codex() external view returns (ICodex);\n\n    function collybus() external view returns (ICollybus);\n\n    function token() external view returns (address);\n\n    function tokenScale() external view returns (uint256);\n\n    function underlierToken() external view returns (address);\n\n    function underlierScale() external view returns (uint256);\n\n    function vaultType() external view returns (bytes32);\n\n    function live() external view returns (uint256);\n\n    function lock() external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function maturity(uint256 tokenId) external returns (uint256);\n\n    function fairPrice(\n        uint256 tokenId,\n        bool net,\n        bool face\n    ) external view returns (uint256);\n\n    function enter(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external;\n\n    function exit(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external;\n}\ninterface IGuarded {\n    function ANY_SIG() external view returns (bytes32);\n\n    function ANY_CALLER() external view returns (address);\n\n    function allowCaller(bytes32 sig, address who) external;\n\n    function blockCaller(bytes32 sig, address who) external;\n\n    function canCall(bytes32 sig, address who) external view returns (bool);\n}\n/// @title Guarded\n/// @notice Mixin implementing an authentication scheme on a method level\nabstract contract Guarded is IGuarded {\n    /// ======== Custom Errors ======== ///\n\n    error Guarded__notRoot();\n    error Guarded__notGranted();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Wildcard for granting a caller to call every guarded method\n    bytes32 public constant override ANY_SIG = keccak256(\"ANY_SIG\");\n    /// @notice Wildcard for granting a caller to call every guarded method\n    address public constant override ANY_CALLER = address(uint160(uint256(bytes32(keccak256(\"ANY_CALLER\")))));\n\n    /// @notice Mapping storing who is granted to which method\n    /// @dev Method Signature => Caller => Bool\n    mapping(bytes32 => mapping(address => bool)) private _canCall;\n\n    /// ======== Events ======== ///\n\n    event AllowCaller(bytes32 sig, address who);\n    event BlockCaller(bytes32 sig, address who);\n\n    constructor() {\n        // set root\n        _setRoot(msg.sender);\n    }\n\n    /// ======== Auth ======== ///\n\n    modifier callerIsRoot() {\n        if (_canCall[ANY_SIG][msg.sender]) {\n            _;\n        } else revert Guarded__notRoot();\n    }\n\n    modifier checkCaller() {\n        if (canCall(msg.sig, msg.sender)) {\n            _;\n        } else revert Guarded__notGranted();\n    }\n\n    /// @notice Grant the right to call method `sig` to `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should be able to call `sig`\n    function allowCaller(bytes32 sig, address who) public override callerIsRoot {\n        _canCall[sig][who] = true;\n        emit AllowCaller(sig, who);\n    }\n\n    /// @notice Revoke the right to call method `sig` from `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should not be able to call `sig` anymore\n    function blockCaller(bytes32 sig, address who) public override callerIsRoot {\n        _canCall[sig][who] = false;\n        emit BlockCaller(sig, who);\n    }\n\n    /// @notice Returns if `who` can call `sig`\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should be able to call `sig`\n    function canCall(bytes32 sig, address who) public view override returns (bool) {\n        return (_canCall[sig][who] || _canCall[ANY_SIG][who] || _canCall[sig][ANY_CALLER]);\n    }\n\n    /// @notice Sets the root user (granted `ANY_SIG`)\n    /// @param root Address of who should be set as root\n    function _setRoot(address root) internal {\n        _canCall[ANY_SIG][root] = true;\n        emit AllowCaller(ANY_SIG, root);\n    }\n\n    /// @notice Unsets the root user (granted `ANY_SIG`)\n    /// @param root Address of who should be unset as root\n    function _unsetRoot(address root) internal {\n        _canCall[ANY_SIG][root] = false;\n        emit AllowCaller(ANY_SIG, root);\n    }\n}// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n\nuint256 constant MLN = 10**6;\nuint256 constant BLN = 10**9;\nuint256 constant WAD = 10**18;\nuint256 constant RAY = 10**18;\nuint256 constant RAD = 10**18;\n\n/* solhint-disable func-visibility, no-inline-assembly */\n\nerror Math__toInt256_overflow(uint256 x);\n\nfunction toInt256(uint256 x) pure returns (int256) {\n    if (x > uint256(type(int256).max)) revert Math__toInt256_overflow(x);\n    return int256(x);\n}\n\nfunction min(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x <= y ? x : y;\n    }\n}\n\nfunction max(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x >= y ? x : y;\n    }\n}\n\nerror Math__diff_overflow(uint256 x, uint256 y);\n\nfunction diff(uint256 x, uint256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) - int256(y);\n        if (!(int256(x) >= 0 && int256(y) >= 0)) revert Math__diff_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow(uint256 x, uint256 y);\n\nfunction add(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add_overflow(x, y);\n    }\n}\n\nerror Math__add48_overflow(uint256 x, uint256 y);\n\nfunction add48(uint48 x, uint48 y) pure returns (uint48 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add48_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow_signed(uint256 x, int256 y);\n\nfunction add(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x + uint256(y);\n        if (!(y >= 0 || z <= x)) revert Math__add_overflow_signed(x, y);\n        if (!(y <= 0 || z >= x)) revert Math__add_overflow_signed(x, y);\n    }\n}\n\nerror Math__sub_overflow(uint256 x, uint256 y);\n\nfunction sub(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x - y) > x) revert Math__sub_overflow(x, y);\n    }\n}\n\nerror Math__sub_overflow_signed(uint256 x, int256 y);\n\nfunction sub(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x - uint256(y);\n        if (!(y <= 0 || z <= x)) revert Math__sub_overflow_signed(x, y);\n        if (!(y >= 0 || z >= x)) revert Math__sub_overflow_signed(x, y);\n    }\n}\n\nerror Math__mul_overflow(uint256 x, uint256 y);\n\nfunction mul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (!(y == 0 || (z = x * y) / y == x)) revert Math__mul_overflow(x, y);\n    }\n}\n\nerror Math__mul_overflow_signed(uint256 x, int256 y);\n\nfunction mul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) * y;\n        if (int256(x) < 0) revert Math__mul_overflow_signed(x, y);\n        if (!(y == 0 || z / y == int256(x))) revert Math__mul_overflow_signed(x, y);\n    }\n}\n\nfunction wmul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, y) / WAD;\n    }\n}\n\nfunction wmul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = mul(x, y) / int256(WAD);\n    }\n}\n\nerror Math__div_overflow(uint256 x, uint256 y);\n\nfunction div(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (y == 0) revert Math__div_overflow(x, y);\n        return x / y;\n    }\n}\n\nfunction wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, WAD) / y;\n    }\n}\n\n// optimized version from dss PR #78\nfunction wpow(\n    uint256 x,\n    uint256 n,\n    uint256 b\n) pure returns (uint256 z) {\n    unchecked {\n        assembly {\n            switch n\n            case 0 {\n                z := b\n            }\n            default {\n                switch x\n                case 0 {\n                    z := 0\n                }\n                default {\n                    switch mod(n, 2)\n                    case 0 {\n                        z := b\n                    }\n                    default {\n                        z := x\n                    }\n                    let half := div(b, 2) // for rounding.\n                    for {\n                        n := div(n, 2)\n                    } n {\n                        n := div(n, 2)\n                    } {\n                        let xx := mul(x, x)\n                        if shr(128, x) {\n                            revert(0, 0)\n                        }\n                        let xxRound := add(xx, half)\n                        if lt(xxRound, xx) {\n                            revert(0, 0)\n                        }\n                        x := div(xxRound, b)\n                        if mod(n, 2) {\n                            let zx := mul(z, x)\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                                revert(0, 0)\n                            }\n                            let zxRound := add(zx, half)\n                            if lt(zxRound, zx) {\n                                revert(0, 0)\n                            }\n                            z := div(zxRound, b)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/* solhint-disable func-visibility, no-inline-assembly */\n/// @title Tenebrae\n/// @notice `Tenebrae` coordinates Global Settlement. This is an involved, stateful process that takes\n/// place over nine steps.\n///\n/// Uses End.sol from DSS (MakerDAO) / GlobalSettlement SafeEngine.sol from GEB (Reflexer Labs) as a blueprint\n/// Changes from End.sol / GlobalSettlement.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\n///\n/// @dev\n/// First we freeze the system and lock the prices for each vault and TokenId.\n///\n/// 1. `lock()`:\n///     - freezes user entrypoints\n///     - cancels debtAuction/surplusAuction auctions\n///     - starts cooldown period\n///\n/// We must process some system state before it is possible to calculate\n/// the final credit / collateral price. In particular, we need to determine\n///\n///     a. `debt`, the outstanding credit supply after including system surplus / deficit\n///\n///     b. `lostCollateral`, the collateral shortfall per collateral type by\n///     considering under-collateralised Positions.\n///\n/// We determine (a) by processing ongoing credit generating processes,\n/// i.e. auctions. We need to ensure that auctions will not generate any\n/// further credit income.\n///\n/// In the case of the Dutch Auctions model (CollateralAuction) they keep recovering\n/// debt during the whole lifetime and there isn't a max duration time\n/// guaranteed for the auction to end.\n/// So the way to ensure the protocol will not receive extra credit income is:\n///\n///     2a. i) `skipAuctions`: cancel all ongoing auctions and seize the collateral.\n///\n///         `skipAuctions(vault, id)`:\n///          - cancel individual running collateralAuction auctions\n///          - retrieves remaining collateral and debt (including penalty) to owner's Position\n///\n/// We determine (b) by processing all under-collateralised Positions with `offsetPosition`:\n///\n/// 3. `offsetPosition(vault, tokenId, position)`:\n///     - cancels the Position's debt with an equal amount of collateral\n///\n/// When a Position has been processed and has no debt remaining, the\n/// remaining collateral can be removed.\n///\n/// 4. `closePosition(vault)`:\n///     - remove collateral from the caller's Position\n///     - owner can call as needed\n///\n/// After the processing period has elapsed, we enable calculation of\n/// the final price for each collateral type.\n///\n/// 5. `fixGlobalDebt()`:\n///     - only callable after processing time period elapsed\n///     - assumption that all under-collateralised Positions are processed\n///     - fixes the total outstanding supply of credit\n///     - may also require extra Position processing to cover aer surplus\n///\n/// At this point we have computed the final price for each collateral\n/// type and credit holders can now turn their credit into collateral. Each\n/// unit credit can claim a fixed basket of collateral.\n///\n/// Finally, collateral can be obtained with `redeem`.\n///\n/// 6. `redeem(vault, tokenId wad)`:\n///     - exchange some credit for collateral tokens from a specific vault and tokenId\ncontract Tenebrae is Guarded, ITenebrae {\n    /// ======== Custom Errors ======== ///\n\n    error Tenebrae__setParam_notLive();\n    error Tenebrae__setParam_unknownParam();\n    error Tenebrae__lock_notLive();\n    error Tenebrae__skipAuction_debtNotZero();\n    error Tenebrae__skipAuction_overflow();\n    error Tenebrae__offsetPosition_debtNotZero();\n    error Tenebrae__offsetPosition_overflow();\n    error Tenebrae__closePosition_stillLive();\n    error Tenebrae__closePosition_debtNotZero();\n    error Tenebrae__closePosition_normalDebtNotZero();\n    error Tenebrae__closePosition_overflow();\n    error Tenebrae__fixGlobalDebt_stillLive();\n    error Tenebrae__fixGlobalDebt_debtNotZero();\n    error Tenebrae__fixGlobalDebt_surplusNotZero();\n    error Tenebrae__fixGlobalDebt_cooldownNotFinished();\n    error Tenebrae__redeem_redemptionPriceZero();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Codex\n    ICodex public override codex;\n    /// @notice Limes\n    ILimes public override limes;\n    /// @notice Aer\n    IAer public override aer;\n    /// @notice Collybus\n    ICollybus public override collybus;\n\n    /// @notice Time of lock [unix epoch time]\n    uint256 public override lockedAt;\n    /// @notice  // Processing Cooldown Length [seconds]\n    uint256 public override cooldownDuration;\n    /// @notice Total outstanding credit after processing all positions and auctions [wad]\n    uint256 public override debt;\n\n    /// @notice Boolean indicating if this contract is live (0 - not live, 1 - live)\n    uint256 public override live;\n\n    /// @notice Total collateral shortfall for each asset\n    /// @dev Vault => TokenId => Collateral shortfall [wad]\n    mapping(address => mapping(uint256 => uint256)) public override lostCollateral;\n    /// @notice Total normalized debt for each asset\n    /// @dev Vault => TokenId => Total debt per vault [wad]\n    mapping(address => mapping(uint256 => uint256)) public override normalDebtByTokenId;\n    /// @notice Amount of collateral claimed by users\n    /// @dev Vault => TokenId => Account => Collateral claimed [wad]\n    mapping(address => mapping(uint256 => mapping(address => uint256))) public override claimed;\n\n    /// ======== Events ======== ///\n\n    event SetParam(bytes32 indexed param, uint256 data);\n    event SetParam(bytes32 indexed param, address data);\n\n    event Lock();\n    event SkipAuction(\n        uint256 indexed auctionId,\n        address vault,\n        uint256 tokenId,\n        address indexed user,\n        uint256 debt,\n        uint256 collateralToSell,\n        uint256 normalDebt\n    );\n    event SettlePosition(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed user,\n        uint256 settledCollateral,\n        uint256 normalDebt\n    );\n    event ClosePosition(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed user,\n        uint256 collateral,\n        uint256 normalDebt\n    );\n    event FixGlobalDebt();\n    event Redeem(address indexed vault, uint256 indexed tokenId, address indexed user, uint256 credit);\n\n    constructor() Guarded() {\n        live = 1;\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [address]\n    function setParam(bytes32 param, address data) external override checkCaller {\n        if (live == 0) revert Tenebrae__setParam_notLive();\n        if (param == \"codex\") codex = ICodex(data);\n        else if (param == \"limes\") limes = ILimes(data);\n        else if (param == \"aer\") aer = IAer(data);\n        else if (param == \"collybus\") collybus = ICollybus(data);\n        else revert Tenebrae__setParam_unknownParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (live == 0) revert Tenebrae__setParam_notLive();\n        if (param == \"cooldownDuration\") cooldownDuration = data;\n        else revert Tenebrae__setParam_unknownParam();\n        emit SetParam(param, data);\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Returns the price fixed when the system got locked\n    /// @dev Fair price remains fixed since no new rates or spot prices are submitted to Collybus\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @return lockPrice [wad]\n    function lockPrice(address vault, uint256 tokenId) public view override returns (uint256) {\n        return wdiv(collybus.redemptionPrice(), IVault(vault).fairPrice(tokenId, false, true));\n    }\n\n    /// @notice Returns the price at which credit can be redeemed for collateral\n    /// @notice vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @return redemptionPrice [wad]\n    function redemptionPrice(address vault, uint256 tokenId) public view override returns (uint256) {\n        if (debt == 0) return 0;\n        (, uint256 rate, , ) = codex.vaults(vault);\n        uint256 collateral = wmul(wmul(normalDebtByTokenId[vault][tokenId], rate), lockPrice(vault, tokenId));\n        return wdiv(sub(collateral, lostCollateral[vault][tokenId]), wmul(debt, WAD));\n    }\n\n    /// @notice Locks the system. See 1.\n    /// @dev Sender has to be allowed to call this method\n    function lock() external override checkCaller {\n        if (live == 0) revert Tenebrae__lock_notLive();\n        live = 0;\n        lockedAt = block.timestamp;\n        codex.lock();\n        limes.lock();\n        aer.lock();\n        collybus.lock();\n        emit Lock();\n    }\n\n    /// @notice Skips on-going collateral auction. See 2.\n    /// @dev Has to be performed before global debt is fixed\n    /// @param vault Address of the Vault\n    /// @param auctionId Id of the collateral auction the skip\n    function skipAuction(address vault, uint256 auctionId) external override {\n        if (debt != 0) revert Tenebrae__skipAuction_debtNotZero();\n        (address _collateralAuction, , , ) = limes.vaults(vault);\n        ICollateralAuction collateralAuction = ICollateralAuction(_collateralAuction);\n        (, uint256 rate, , ) = codex.vaults(vault);\n        (, uint256 debt_, uint256 collateralToSell, , uint256 tokenId, address user, , ) = collateralAuction.auctions(\n            auctionId\n        );\n        codex.createUnbackedDebt(address(aer), address(aer), debt_);\n        collateralAuction.cancelAuction(auctionId);\n        uint256 normalDebt = wdiv(debt_, rate);\n        if (!(int256(collateralToSell) >= 0 && int256(normalDebt) >= 0)) revert Tenebrae__skipAuction_overflow();\n        codex.confiscateCollateralAndDebt(\n            vault,\n            tokenId,\n            user,\n            address(this),\n            address(aer),\n            int256(collateralToSell),\n            int256(normalDebt)\n        );\n        emit SkipAuction(auctionId, vault, tokenId, user, debt_, collateralToSell, normalDebt);\n    }\n\n    /// @notice Offsets the debt of a Position with its collateral. See 3.\n    /// @dev Has to be performed before global debt is fixed\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param user Address of the Position's owner\n    function offsetPosition(\n        address vault,\n        uint256 tokenId,\n        address user\n    ) external override {\n        if (debt != 0) revert Tenebrae__offsetPosition_debtNotZero();\n        (, uint256 rate, , ) = codex.vaults(vault);\n        (uint256 collateral, uint256 normalDebt) = codex.positions(vault, tokenId, user);\n        // get price at maturity\n        uint256 owedCollateral = wdiv(wmul(normalDebt, rate), IVault(vault).fairPrice(tokenId, false, true));\n        uint256 offsetCollateral;\n        if (owedCollateral > collateral) {\n            // owing more collateral than the Position has\n            lostCollateral[vault][tokenId] = add(lostCollateral[vault][tokenId], sub(owedCollateral, collateral));\n            offsetCollateral = collateral;\n        } else {\n            offsetCollateral = owedCollateral;\n        }\n        normalDebtByTokenId[vault][tokenId] = add(normalDebtByTokenId[vault][tokenId], normalDebt);\n        if (!(offsetCollateral <= 2**255 && normalDebt <= 2**255)) revert Tenebrae__offsetPosition_overflow();\n        codex.confiscateCollateralAndDebt(\n            vault,\n            tokenId,\n            user,\n            address(this),\n            address(aer),\n            -int256(offsetCollateral),\n            -int256(normalDebt)\n        );\n        emit SettlePosition(vault, tokenId, user, offsetCollateral, normalDebt);\n    }\n\n    /// @notice Closes a user's position, such that the user can exit part of their collateral. See 4.\n    /// @dev Has to be performed before global debt is fixed\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    function closePosition(address vault, uint256 tokenId) external override {\n        if (live != 0) revert Tenebrae__closePosition_stillLive();\n        if (debt != 0) revert Tenebrae__closePosition_debtNotZero();\n        (uint256 collateral, uint256 normalDebt) = codex.positions(vault, tokenId, msg.sender);\n        if (normalDebt != 0) revert Tenebrae__closePosition_normalDebtNotZero();\n        normalDebtByTokenId[vault][tokenId] = add(normalDebtByTokenId[vault][tokenId], normalDebt);\n        if (collateral > 2**255) revert Tenebrae__closePosition_overflow();\n        codex.confiscateCollateralAndDebt(vault, tokenId, msg.sender, msg.sender, address(aer), -int256(collateral), 0);\n        emit ClosePosition(vault, tokenId, msg.sender, collateral, normalDebt);\n    }\n\n    /// @notice Fixes the global debt of the system. See 5.\n    /// @dev Can only be called once.\n    function fixGlobalDebt() external override {\n        if (live != 0) revert Tenebrae__fixGlobalDebt_stillLive();\n        if (debt != 0) revert Tenebrae__fixGlobalDebt_debtNotZero();\n        if (codex.credit(address(aer)) != 0) revert Tenebrae__fixGlobalDebt_surplusNotZero();\n        if (block.timestamp < add(lockedAt, cooldownDuration)) revert Tenebrae__fixGlobalDebt_cooldownNotFinished();\n        debt = codex.globalDebt();\n        emit FixGlobalDebt();\n    }\n\n    /// @notice Gives users the ability to redeem their remaining collateral with credit. See 6.\n    /// @dev Has to be performed after global debt is fixed otherwise redemptionPrice is 0\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param credit Amount of credit to redeem for collateral [wad]\n    function redeem(\n        address vault,\n        uint256 tokenId,\n        uint256 credit // credit amount\n    ) external override {\n        uint256 price = redemptionPrice(vault, tokenId);\n        if (price == 0) revert Tenebrae__redeem_redemptionPriceZero();\n        codex.transferCredit(msg.sender, address(aer), credit);\n        aer.settleDebtWithSurplus(credit);\n        codex.transferBalance(vault, tokenId, address(this), msg.sender, wmul(credit, price));\n        claimed[vault][tokenId][msg.sender] = add(claimed[vault][tokenId][msg.sender], credit);\n        emit Redeem(vault, tokenId, msg.sender, credit);\n    }\n}\n", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Guarded__notGranted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Guarded__notRoot\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"Math__add_overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"Math__mul_overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"Math__sub_overflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Tenebrae__closePosition_debtNotZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Tenebrae__closePosition_normalDebtNotZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Tenebrae__closePosition_overflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Tenebrae__closePosition_stillLive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Tenebrae__fixGlobalDebt_cooldownNotFinished\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Tenebrae__fixGlobalDebt_debtNotZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Tenebrae__fixGlobalDebt_stillLive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Tenebrae__fixGlobalDebt_surplusNotZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Tenebrae__lock_notLive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Tenebrae__offsetPosition_debtNotZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Tenebrae__offsetPosition_overflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Tenebrae__redeem_redemptionPriceZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Tenebrae__setParam_notLive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Tenebrae__setParam_unknownParam\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Tenebrae__skipAuction_debtNotZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Tenebrae__skipAuction_overflow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sig\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"AllowCaller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sig\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"BlockCaller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"normalDebt\",\"type\":\"uint256\"}],\"name\":\"ClosePosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"FixGlobalDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"credit\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"param\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"SetParam\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"param\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"SetParam\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"settledCollateral\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"normalDebt\",\"type\":\"uint256\"}],\"name\":\"SettlePosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralToSell\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"normalDebt\",\"type\":\"uint256\"}],\"name\":\"SkipAuction\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ANY_CALLER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ANY_SIG\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aer\",\"outputs\":[{\"internalType\":\"contract IAer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sig\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"allowCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sig\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"blockCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sig\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"canCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"closePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"codex\",\"outputs\":[{\"internalType\":\"contract ICodex\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collybus\",\"outputs\":[{\"internalType\":\"contract ICollybus\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldownDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixGlobalDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limes\",\"outputs\":[{\"internalType\":\"contract ILimes\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"live\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"lockPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lostCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"normalDebtByTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"offsetPosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"credit\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"redemptionPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"param\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"setParam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"param\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"setParam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"skipAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Tenebrae", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "8000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}