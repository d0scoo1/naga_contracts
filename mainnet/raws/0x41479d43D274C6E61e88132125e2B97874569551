{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/artistv2.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.5.16;\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\npragma solidity ^0.5.16;\\n\\ncontract IERC721 is IERC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function balanceOf(address owner) public view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) public view returns (address owner);\\n    function approve(address to, uint256 tokenId) public;\\n    function getApproved(uint256 tokenId) public view returns (address operator);\\n    function setApprovalForAll(address operator, bool _approved) public;\\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\\n    function transferFrom(address from, address to, uint256 tokenId) public;\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\\n}\\n\\npragma solidity ^0.5.16;\\n\\ncontract IERC721Receiver {\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\\n    public returns (bytes4);\\n}\\n\\npragma solidity ^0.5.16;\\n\\nlibrary SafeMath {\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        require(c / a == b);\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n    \\n    function sub0(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if(b > a){\\n            return 0;\\n        }\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a);\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n    \\n    \\n}\\n\\npragma solidity ^0.5.16;\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n}\\n\\npragma solidity ^0.5.16;\\n\\ncontract ERC165 is IERC165 {\\n    bytes4 internal constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    constructor () internal {\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    function _registerInterface(bytes4 interfaceId) internal {\\n        require(interfaceId != 0xffffffff);\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\\npragma solidity ^0.5.16;\\n\\ncontract ERC721 is ERC165, IERC721 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\\n    mapping (uint256 => address) private _tokenOwner;\\n    mapping (uint256 => address) private _tokenApprovals;\\n    mapping (address => uint256) private _ownedTokensCount;\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n    bytes4 internal constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    constructor () public {\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n    }\\n\\n    function balanceOf(address owner) public view returns (uint256) {\\n        require(owner != address(0));\\n        return _ownedTokensCount[owner];\\n    }\\n\\n    function ownerOf(uint256 tokenId) public view returns (address) {\\n        address owner = _tokenOwner[tokenId];\\n        require(owner != address(0));\\n        return owner;\\n    }\\n\\n    function approve(address to, uint256 tokenId) public {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner);\\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\\n\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    function getApproved(uint256 tokenId) public view returns (address) {\\n        require(_exists(tokenId));\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    function setApprovalForAll(address to, bool approved) public {\\n        require(to != msg.sender);\\n        _operatorApprovals[msg.sender][to] = approved;\\n        emit ApprovalForAll(msg.sender, to, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public {\\n        require(_isApprovedOrOwner(msg.sender, tokenId));\\n        _transferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\\n        transferFrom(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data));\\n    }\\n\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        address owner = _tokenOwner[tokenId];\\n        return owner != address(0);\\n    }\\n\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal {\\n        require(to != address(0));\\n        require(!_exists(tokenId));\\n\\n        _tokenOwner[tokenId] = to;\\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\\n        require(ownerOf(tokenId) == from);\\n        require(to != address(0));\\n\\n        _clearApproval(tokenId);\\n\\n        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\\n        _tokenOwner[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        internal returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n\\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    function _clearApproval(uint256 tokenId) private {\\n        if (_tokenApprovals[tokenId] != address(0)) {\\n            _tokenApprovals[tokenId] = address(0);\\n        }\\n    }\\n\\n}\\n\\npragma solidity ^0.5.16;\\n\\ncontract IERC721Enumerable is IERC721 {\\n    function totalSupply() public view returns (uint256);\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\\n    function tokenByIndex(uint256 index) public view returns (uint256);\\n}\\n\\npragma solidity ^0.5.16;\\n\\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\\n\\n    mapping(address => uint256[]) private _ownedTokens;\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\n    uint256[] private _allTokens;\\n    mapping(uint256 => uint256) private _allTokensIndex;\\n    bytes4 internal constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    constructor () public {\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\\n        require(index < balanceOf(owner));\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    function totalSupply() public view returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    function tokenByIndex(uint256 index) public view returns (uint256) {\\n        require(index < totalSupply());\\n        return _allTokens[index];\\n    }\\n\\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\\n        super._transferFrom(from, to, tokenId);\\n        _removeTokenFromOwnerEnumeration(from, tokenId);\\n        _addTokenToOwnerEnumeration(to, tokenId);\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal {\\n        super._mint(to, tokenId);\\n        _addTokenToOwnerEnumeration(to, tokenId);\\n        _addTokenToAllTokensEnumeration(tokenId);\\n    }\\n\\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\\n        return _ownedTokens[owner];\\n    }\\n\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\\n        _ownedTokens[to].push(tokenId);\\n    }\\n\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n            _ownedTokens[from][tokenIndex] = lastTokenId;\\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\\n        }\\n\\n        _ownedTokens[from].length--;\\n    }\\n\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n\\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId;\\n        _allTokensIndex[lastTokenId] = tokenIndex;\\n\\n        _allTokens.length--;\\n        _allTokensIndex[tokenId] = 0;\\n    }\\n}\\n\\npragma solidity ^0.5.16;\\n\\ncontract IERC721Metadata is IERC721 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\n\\npragma solidity ^0.5.16;\\n\\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\\n\\n    string internal _name;\\n    string internal _symbol;\\n\\n    bytes4 internal constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n    }\\n\\n    function name() external view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() external view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n}\\n\\npragma solidity ^0.5.16;\\n\\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\\n    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\\n   }\\n}\\npragma solidity ^0.5.16;\\n\\ncontract IRadicalNFT is IERC165 {\\n    function round(uint256 _tokenid) external view returns (uint256 _round);\\n    function price(uint256 _round) public returns (uint256 _price);\\n    function getBidStartTime(uint256 tokenid)external view returns(uint64);\\n    function bid(address inviterAddress, uint256 tokenid) external payable;\\n}\\ncontract RadicalNFT is ERC165,IRadicalNFT {\\n\\n    bytes4 internal constant _INTERFACE_ID_RADICALNFT = 0x9203c74e;\\n //       bytes4(keccak256('round(uint256)')) ^\\n //       bytes4(keccak256('price(uint256)')) ^\\n //       bytes4(keccak256('getBidStartTime(uint256)')) ^\\n //   \\n\\n    constructor () public {\\n       _registerInterface(_INTERFACE_ID_RADICALNFT);\\n    }\\n}\\n\\ncontract Ownable {\\n  address  owner;\\n\\n    constructor() public {\\n    owner = msg.sender;\\n  }\\n\\n\\n  modifier onlyOwner() {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n  function transferOwnership(address newOwner) onlyOwner public {\\n    if (newOwner != address(0)) {\\n      owner = newOwner;\\n    }\\n  }\\n\\n}\\n\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 internal constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 internal _status;\\n\\n    constructor ()public {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\ncontract ArtistBase is Ownable,ERC721Full,RadicalNFT,ReentrancyGuard {\\n    \\n    using SafeMath for uint256;\\n    \\n    bool public paused = false;\\n    address public cfoAddress;\\n    address cooAddress;\\n    \\n    address public  VBID_ADDRESS;\\n    address public  bonusPoolAddress;\\n    address public  devPoolAddress;  \\n    uint256[] private priceList;\\n\\n    /// @dev The main art struct. \\n    struct Art {\\n\\n        uint256 id;\\n\\n        // The timestamp from the block when aution startTime\\n        uint64 bidStartTime;\\n        uint64 bidEndTime;\\n        uint64 lastTime;\\n        uint64 round;\\n        //bid issue privileges\\n        bool bid;\\n        string ipfs;\\n    }\\n\\n\\n    uint256 public lastBidTime=0;\\n    Art[] public arts;\\n\\n    //current id \\n    uint256 curid;\\n    \\n    uint256 public bidInterval;\\n    uint256 private defaultBidTokenId;\\n    //this is defined by vbid. \\n    //min\uff0818% \u2716\ufe0f\uff081000000 - \u8be5\u827a\u672f\u5bb6\u5408\u7ea6\u63a5\u6536\u7684\u603bveBID\u6570\uff09\uff0c0\uff09\\n    //can only updated by contract of vbid \\n    uint256 public tbdivident;\\n    //bid token address\\n    IERC20  bidtoken;\\n\\n    //do NOT change memory map\\n    \\n    modifier onlyCLevel() {\\n        require(\\n            msg.sender == cooAddress \\n        );\\n        _;\\n    }\\n    modifier whenNotPaused() {\\n        require(!paused);\\n        _;\\n    }\\n\\n    /// @dev Modifier to allow actions only when the contract IS paused\\n    modifier whenPaused {\\n        require(paused);\\n        _;\\n    }\\n\\n\\n    function pause() external onlyCLevel whenNotPaused {\\n        paused = true;\\n    }\\n\\n    function unpause() public onlyCLevel whenPaused {\\n        paused = false;\\n    }\\n    \\n\\n    function creatArt2(\\n        bool bidflag,\\n        string memory ipfsaddr,\\n        uint64 startTime,\\n        uint64 _bidEndTime\\n\\n    )\\n        public\\n        whenNotPaused\\n        returns (uint256)\\n    {\\n         require(msg.sender == owner, \\\"ERR_NOT_OWNER\\\");\\n\\n\\n        if(lastBidTime==0){\\n            bidflag=false;\\n        }else if((now-lastBidTime)<bidInterval){\\n            bidflag=false;\\n        }else{\\n            if(bidflag){\\n                lastBidTime=now;\\n            }\\n        }\\n\\n\\n        if(_bidEndTime==0){\\n            _bidEndTime=uint64(-1);\\n        }\\n        Art memory _art = Art({\\n            id: curid,\\n            bidStartTime: startTime,\\n            bidEndTime:_bidEndTime,\\n            lastTime:uint64(now),\\n            round: 0,\\n            bid: bidflag,\\n            ipfs: ipfsaddr\\n\\n        });\\n        curid = arts.push(_art) ;\\n\\n        _mint(owner, curid-1);\\n\\n        return curid;\\n    }\\n\\n    \\n    function updateTopbidderDivident(uint256 _tb) \\n        external\\n    {\\n        require(VBID_ADDRESS==msg.sender, \\\"ERR_INVALID_VBID\\\"); \\n        if(_tb>=1000000 ether){\\n            tbdivident=0;\\n        }else{\\n            tbdivident=(1000000 ether-_tb).mul(1800).div(1000000 ether);\\n        }       \\n    }\\n\\n    function setVBIDContract(address _vbid) \\n        external\\n    {\\n         require(msg.sender == cfoAddress, \\\"ERR_NOT_CFO\\\");\\n        tbdivident=1800;\\n        VBID_ADDRESS=_vbid;    \\n    }\\n    \\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\\n        require(_exists(tokenId));\\n        return arts[tokenId].ipfs;\\n    }\\n\\n    function checkArtBidable(uint256 tokenId) external view returns (bool) {\\n        require(_exists(tokenId));\\n        return arts[tokenId].bid;\\n    }\\n\\n    function openBidTokenAuthority() \\n        external\\n        onlyCLevel\\n        {\\n            lastBidTime=now - bidInterval;\\n        }\\n\\n    function closeBidTokenAuthority() \\n        external\\n        onlyCLevel\\n        {\\n            lastBidTime=0;\\n        }\\n\\n    function setBidInterval(uint256 interval) \\n        external\\n        onlyCLevel\\n        {\\n            bidInterval=interval;\\n        }\\n        \\n    function changeArtData(uint256 tokenid,string calldata ipfs) \\n        external\\n        onlyCLevel\\n        {\\n            require(tokenid<curid, \\\"ERR_ARTID_TOOBIG\\\");\\n            arts[tokenid].ipfs=ipfs;\\n        }\\n    function editArtData(uint256 tokenid,string calldata ipfs) \\n        external\\n        onlyOwner\\n        {\\n            require(tokenid<curid, \\\"ERR_ARTID_TOOBIG\\\");\\n            require(arts[tokenid].bidStartTime>now,\\\"ERR_ALREADY_START\\\");\\n            arts[tokenid].ipfs=ipfs;\\n        }\\n\\n\\n    function checkBidable() view\\n        external\\n        returns (bool){\\n        \\n            if(lastBidTime==0){\\n                return false;\\n            }else if((now-lastBidTime)<bidInterval){\\n                return false;\\n            }else{\\n                return true;\\n            }\\n        \\n        }\\n    function getLatestTokenID() view\\n        external\\n        returns (uint256){\\n            return curid;\\n        }\\n        \\n    function setBidStartTime(uint256 tokenid,uint64 startTime) \\n        external\\n        onlyOwner\\n        {\\n            require(tokenid<curid, \\\"ERR_TOKEN_ID_ERROR\\\");\\n            require(arts[tokenid].bidStartTime>now,\\\"ERR_ALREADY_START\\\");\\n            arts[tokenid].bidStartTime=startTime;\\n        }\\n\\n    function getBidStartTime(uint256 tokenid) view\\n        external\\n        returns(uint64)\\n        {\\n            require(tokenid<curid, \\\"ERR_TOKEN_ID_ERROR\\\");\\n            return arts[tokenid].bidStartTime;\\n        }\\n        \\n    function setDefaultBidId(uint256 tokenid) \\n        external\\n        onlyOwner\\n        {\\n            require(tokenid<curid, \\\"ERR_TOKEN_ID_ERROR\\\");\\n\\n            defaultBidTokenId=tokenid;\\n        }\\n        \\n    function round(uint256 tokenid) view \\n        external\\n        returns (uint256){\\n            return arts[tokenid].round;\\n        }\\n        \\n\\n    event LOG_AUCTION_V2(\\n        uint256  artid,\\n        uint256  lastPrice,\\n        uint256  curPrice,\\n        uint256  bid,\\n        address  lastOwner,\\n        address  buyer,\\n        address  inviterAddress,\\n        uint256  artistdivident,\\n        uint256  tax\\n    );\\n\\n    function () external\\n    whenNotPaused\\n     payable {\\n        _bid(devPoolAddress,defaultBidTokenId);\\n         \\n    }\\n   \\n      function bid(address inviterAddress, uint256 artid) payable\\n    whenNotPaused\\n     public {\\n        _bid(inviterAddress,artid); \\n     }\\n\\n     function price(uint256 _round) public\\n     returns (uint256)\\n     {\\n         //this round start from 1\\n         if(_round<10){\\n             return _round.mul(0.05 ether);\\n         }else if(_round==10){\\n             return 0.50 ether;\\n         }else{\\n             \\n             uint256 lastValue=priceList[priceList.length-1];\\n             for(uint256 i=priceList.length;i<(_round-9);i++){\\n                 lastValue=lastValue.mul(11).div(10);\\n                 priceList.push(lastValue);\\n             }\\n             \\n             return priceList[_round-10];\\n         }\\n     }     \\n     //you can NOT change init fuction as it has ready been executed\\n     function initRoundPrice() internal\\n     returns (uint256)\\n     {\\n         priceList.push(0.50 ether);\\n     }\\n     function dealBid(uint256 tokenid) internal\\n     returns (uint256)\\n     {\\n             \\n        uint256 x=0;\\n        if(arts[tokenid].bid){\\n            uint256 r=arts[tokenid].round;\\n            x=r<10?50 ether:((r+1).mul(5 ether));\\n            if(bidtoken.balanceOf(cfoAddress)>=x){\\n                bidtoken.transferFrom(cfoAddress,msg.sender,x);\\n            }else{\\n                x=0;\\n            }\\n        }\\n        return x;\\n     }\\n    uint256 constant baseprice=0.05 ether;\\n    //event DebugString(address indexed from, address indexed to, uint256 value, string  str);\\n    function _bid(address inviterAddress, uint256 artid) nonReentrant internal\\n     {\\n         require(artid<curid, \\\"ERR_ARTID_TOOBIG\\\");  \\n         address lastOwner=ownerOf(artid);\\n         require(lastOwner!=msg.sender, \\\"ERR_CAN_NOT_PURCHASE_OWN_ART\\\");       \\n         require(arts[artid].bidStartTime<now,\\\"ERR_BID_NOT_START_YET\\\");\\n         require(arts[artid].bidEndTime>now,\\\"ERR_BID_END_ALREADY\\\");\\n         uint256 r=arts[artid].round;\\n         \\n         if(r==0){\\n             \\n             {\\n                 require(msg.value>=baseprice, \\\"ERR_NOT_ENOUGH_MONEY\\\");\\n                  //return extra\\n                  \\n                  (bool success, ) =address(uint160(msg.sender)).call.value(msg.value.sub(baseprice))(\\\"\\\");\\n                  require(success,\\\"ERR refund to payer,maybe gas fail\\\");\\n                  //pay artist\\n                  (bool success1, ) =address(uint160(owner)).call.value(baseprice)(\\\"\\\");\\n                  require(success1,\\\"ERR contract transfer eth to owner,maybe gas fail\\\");\\n              }\\n\\n             arts[artid].round++;\\n            _transferFrom(lastOwner, msg.sender, artid);\\n\\n            if(arts[artid].bidEndTime<now+300){\\n                arts[artid].bidEndTime+=300;\\n            }\\n            arts[artid].lastTime=uint64(now);\\n            emit LOG_AUCTION_V2(artid,baseprice,baseprice,dealBid(artid),lastOwner,msg.sender,inviterAddress,0,0 );\\n            return;\\n         }\\n\\n         \\n        uint256 curprice=price(r);\\n        uint256 payprice=price(r+1);\\n        require(msg.value>=payprice, \\\"ERR_NOT_ENOUGH_MONEY\\\");\\n        \\n         uint256 artistdivident=5000+1800-tbdivident;\\n         uint256 tax=0;\\n         {//only for stack deep issue\\n            //refund extra money\\n            (bool success2, ) =address(uint160(msg.sender)).call.value(msg.value.sub(payprice))(\\\"\\\");\\n            require(success2,\\\"ERR refund to payer,maybe gas fail\\\");\\n         \\n             uint256 smoney=payprice-curprice;\\n             address(uint160(inviterAddress)).send(smoney.mul(2).div(100));\\n             smoney=smoney.mul(98).div(100);\\n             tax=tbdivident;\\n\\n            address(uint160(bonusPoolAddress)).transfer(smoney.mul(tax).div(9800));\\n             \\n            (bool success, ) =address(uint160(owner)).call.value(smoney.mul(artistdivident).div(9800))(\\\"\\\");\\n            require(success,\\\"ERR contract transfer eth to owner,maybe gas fail\\\");\\n    \\n            (bool success1, ) =address(uint160(lastOwner)).call.value(smoney.mul(9800 - artistdivident - tax ).div(9800).add(curprice))(\\\"\\\");\\n            require(success1,\\\"ERR pay to lastOwner,maybe gas fail\\\");\\n         }\\n\\n         arts[artid].round++;\\n    \\n          _transferFrom(lastOwner, msg.sender, artid);\\n\\n        if(arts[artid].bidEndTime<now+300){\\n            arts[artid].bidEndTime+=300;\\n        }\\n        arts[artid].lastTime=uint64(now);\\n        emit LOG_AUCTION_V2(artid, curprice,payprice,dealBid(artid),lastOwner,msg.sender,inviterAddress,artistdivident,tax);\\n         \\n    }\\n\\n}\\n\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address account) external view returns (uint);\\n    function transfer(address recipient, uint amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function approve(address spender, uint amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\n}\\n\\ninterface IArtistSetup {\\n    function setup_constructor(string calldata name,string calldata symbol,address artistaddr,\\n    address auditor,address _bid,address _bonusPool,address _devPool,address _vbid) external ;\\n}\\ncontract ArtistV2 is ArtistBase,IArtistSetup{\\n    \\n    constructor() ERC721Full(\\\"MasterCopy\\\",\\\"\\\")\\n    public {\\n       owner=address(1);\\n    }\\n\\n    function setup_constructor(string calldata name,string calldata symbol,address artistaddr,\\n    address auditor,address _bid,address _bonusPool,address _devPool,address _vbid)  external {\\n        require(address(0)==owner,\\\"owner not zero error\\\");\\n        _name=name;\\n        _symbol=symbol;\\n        bonusPoolAddress=_bonusPool;\\n        devPoolAddress=_devPool;\\n        bidtoken=IERC20(_bid);\\n        owner=artistaddr;\\n        cfoAddress=msg.sender;\\n        cooAddress=auditor;\\n        bidInterval=30 days;\\n        tbdivident=1800;\\n        VBID_ADDRESS=_vbid;\\n        \\n        _status = _NOT_ENTERED;\\n        initRoundPrice();\\n    }\\n    function setCOO(address _newCOO) external onlyCLevel {\\n        require(_newCOO != address(0));\\n\\n        cooAddress = _newCOO;\\n    }\\n    function rescueETH(address _address) external onlyCLevel {\\n        address(uint160(_address)).transfer(address(this).balance);\\n    }\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\\n        return (interfaceId==_INTERFACE_ID_ERC165)\\n        ||(interfaceId==_ERC721_RECEIVED)\\n        ||(interfaceId==_INTERFACE_ID_ERC721)\\n        ||(interfaceId==_INTERFACE_ID_ERC721_ENUMERABLE)\\n        ||(interfaceId==_INTERFACE_ID_ERC721_METADATA)\\n        ||(interfaceId==_INTERFACE_ID_RADICALNFT)\\n;\\n    }\\n\\n\\n    function getOwner()\\n        external view\\n        returns (address)\\n    {\\n        return owner;\\n    }\\n\\n    function getBuildNumber() external view returns (uint256) {\\n        return 1168;\\n    }\\n \\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"artid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"curPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lastOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inviterAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"artistdivident\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tax\",\"type\":\"uint256\"}],\"name\":\"LOG_AUCTION_V2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"VBID_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"arts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"bidStartTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"bidEndTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lastTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"round\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"bid\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"ipfs\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"inviterAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"artid\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bidInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"ipfs\",\"type\":\"string\"}],\"name\":\"changeArtData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"checkArtBidable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkBidable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeBidTokenAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"bidflag\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"ipfsaddr\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_bidEndTime\",\"type\":\"uint64\"}],\"name\":\"creatArt2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"ipfs\",\"type\":\"string\"}],\"name\":\"editArtData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"}],\"name\":\"getBidStartTime\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBuildNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLatestTokenID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBidTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"openBidTokenAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"rescueETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"}],\"name\":\"round\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"}],\"name\":\"setBidInterval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"}],\"name\":\"setBidStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"}],\"name\":\"setDefaultBidId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vbid\",\"type\":\"address\"}],\"name\":\"setVBIDContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"artistaddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"auditor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bid\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bonusPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vbid\",\"type\":\"address\"}],\"name\":\"setup_constructor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tbdivident\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tb\",\"type\":\"uint256\"}],\"name\":\"updateTopbidderDivident\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ArtistV2", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}