{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Logic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./IUniswapV2Router.sol\\\";\\nimport \\\"./Authority.sol\\\";\\nimport \\\"./IStaking.sol\\\";\\n\\n\\ncontract Logic is Authority {\\n\\tevent CreatedNode(address indexed from, uint count, uint price);\\n\\tevent ClaimedNode(address indexed from, uint count, uint claimed, bool staked);\\n\\n\\taddress public immutable yeti;\\n\\taddress public immutable bigFoot;\\n\\taddress public splitter;\\n\\taddress public treasury;\\n\\taddress public staking;\\n\\n\\taddress public immutable router;\\n\\taddress public immutable stable;\\n\\n\\tmapping(uint => uint) public lastClaimTime; // token id to last claim time\\n\\n\\tuint public price = 100 * 10**6; // usdc 6 decimals\\n\\tuint public constant PRICE_INCR = 100 * 10**6; // usdc 6 decimals\\n\\tuint public constant REF_PRICE_INCR = 100;\\n\\n\\tuint public dailyRewards;\\n\\tuint public constant DAY = 1 days;\\n\\n\\tuint public constant REF_RATIO = 10000;\\n\\n\\tuint private constant MAX_UINT256 = type(uint256).max;\\n\\n\\tbool public presale = true;\\n\\tmapping(address => bool) public whitelisted;\\n\\n\\tbool public applyLp = true;\\n\\tuint public lpRate;\\n\\t\\n\\tbool public applyTreasury = true;\\n\\tuint public treasuryRate;\\n\\t\\n\\tconstructor(\\n\\t\\taddress[] memory addresses,\\n\\t\\tuint[] memory rates,\\n\\t\\tuint _dailyRewards\\n\\t) {\\n\\t\\tbigFoot = addresses[0];\\n\\t\\tyeti = addresses[1];\\n\\t\\tsplitter = addresses[2];\\n\\t\\ttreasury = addresses[3];\\n\\t\\tstaking = addresses[4];\\n\\t\\trouter = addresses[5];\\n\\t\\tstable = addresses[6];\\n\\n\\t\\tlpRate = rates[0];\\n\\t\\ttreasuryRate = rates[1];\\n\\n\\t\\tdailyRewards = _dailyRewards;\\n\\t}\\n\\n\\t// Modifiers\\n\\tmodifier onlyYeti() {\\n\\t\\trequire(msg.sender == yeti, \\\"Logic: onlyYeti\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\t// Init\\n\\tfunction init() external onlyAuthority {\\n\\t\\tIERC20(stable).approve(router, MAX_UINT256);\\n\\t\\tIERC20(bigFoot).approve(router, MAX_UINT256);\\n\\t}\\n\\n\\t// Core\\n\\tfunction safeMint(address sender, uint tokenId) external onlyYeti {\\n\\t\\tuint priceStack = price; // gas\\n\\n\\t\\tif ((tokenId + 1) % REF_PRICE_INCR == 0) {\\n\\t\\t\\tunchecked { price += PRICE_INCR; }\\n\\t\\t}\\n\\n\\t\\tIERC20(stable).transferFrom(sender, address(this), priceStack);\\n\\n\\t\\tuint balance = IERC20(stable).balanceOf(address(this));\\n\\n\\t\\tif (!presale) {\\n\\t\\t\\tlastClaimTime[tokenId] = block.timestamp;\\n\\n\\t\\t\\tif (applyLp) {\\n\\t\\t\\t\\tuint lpAmount = balance * lpRate / REF_RATIO;\\n\\t\\t\\t\\tswapAndAdd(lpAmount);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (applyTreasury) {\\n\\t\\t\\t\\tuint treasuryAmount = balance * treasuryRate / REF_RATIO;\\n\\t\\t\\t\\tIERC20(stable).transfer(treasury, treasuryAmount);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\trequire(whitelisted[sender], \\\"Logic: Address not whitelisted\\\");\\n\\n\\t\\t\\tuint treasuryAmount = balance * (lpRate + treasuryRate) / REF_RATIO;\\n\\t\\t\\tIERC20(stable).transfer(treasury, treasuryAmount);\\n\\t\\t}\\n\\t\\t\\n\\t\\tsafeTransferSplitter(stable);\\n\\t\\tsafeTransferSplitter(bigFoot);\\n\\n\\t\\temit CreatedNode(sender, 1, priceStack);\\n\\t}\\n\\n\\tfunction safeClaim(address sender, uint tokenId, bool stake) external onlyYeti {\\n\\t\\tif (lastClaimTime[tokenId] == 0) { // presale\\n\\t\\t\\trequire(!presale, \\\"Logic: Presale ongoing\\\");\\n\\t\\t\\tlastClaimTime[tokenId] = block.timestamp;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\n\\t\\tuint amount = pendingOf(tokenId);\\n\\n\\t\\tlastClaimTime[tokenId] = block.timestamp;\\n\\n\\t\\tif (amount == 0)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (stake)\\n\\t\\t\\tIStaking(staking).stake(amount, sender);\\n\\t\\telse\\n\\t\\t\\tIERC20(bigFoot).transferFrom(treasury, sender, amount);\\n\\t\\t\\n\\t\\temit ClaimedNode(sender, 1, amount, stake);\\n\\t}\\n\\t\\n\\tfunction safeMintBatch(\\n\\t\\taddress sender, \\n\\t\\tuint[] calldata tokenIds\\n\\t) \\n\\t\\texternal \\n\\t\\tonlyYeti \\n\\t{\\n\\t\\tuint finalPrice;\\n\\t\\tuint priceStack = price; // gas\\n\\t\\tbool _presale = presale; // gas\\n\\n\\t\\tfor (uint i = 0; i < tokenIds.length; i++) {\\n\\t\\t\\tunchecked { finalPrice += priceStack; }\\n\\n\\t\\t\\tif ((tokenIds[i] + 1) % REF_PRICE_INCR == 0) {\\n\\t\\t\\t\\tunchecked { \\n\\t\\t\\t\\t\\tprice += PRICE_INCR;\\n\\t\\t\\t\\t\\tpriceStack += PRICE_INCR;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!_presale)\\n\\t\\t\\t\\tlastClaimTime[tokenIds[i]] = block.timestamp;\\n\\t\\t}\\n\\n\\t\\tIERC20(stable).transferFrom(sender, address(this), finalPrice);\\n\\t\\t\\t\\n\\t\\tuint balance = IERC20(stable).balanceOf(address(this));\\n\\n\\t\\tif (!_presale) {\\n\\t\\t\\tif (applyLp) {\\n\\t\\t\\t\\tuint lpAmount = balance * lpRate / REF_RATIO;\\n\\t\\t\\t\\tswapAndAdd(lpAmount);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (applyTreasury) {\\n\\t\\t\\t\\tuint treasuryAmount = balance * treasuryRate / REF_RATIO;\\n\\t\\t\\t\\tIERC20(stable).transfer(treasury, treasuryAmount);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\trequire(whitelisted[sender], \\\"Logic: Address not whitelisted\\\");\\n\\n\\t\\t\\tuint treasuryAmount = balance * (lpRate + treasuryRate) / REF_RATIO;\\n\\t\\t\\tIERC20(stable).transfer(treasury, treasuryAmount);\\n\\t\\t}\\n\\t\\t\\n\\t\\tsafeTransferSplitter(stable);\\n\\t\\tsafeTransferSplitter(bigFoot);\\n\\n\\t\\temit CreatedNode(sender, tokenIds.length, finalPrice);\\n\\t}\\n\\t\\n\\tfunction safeClaimBatch(\\n\\t\\taddress sender, \\n\\t\\tuint[] calldata tokenIds, \\n\\t\\tbool stake\\n\\t) \\n\\t\\texternal \\n\\t\\tonlyYeti \\n\\t{\\n\\t\\tuint amount;\\n\\n\\t\\tfor (uint i = 0; i < tokenIds.length; i++) {\\n\\t\\t\\tuint tokenId = tokenIds[i]; // gas\\n\\n\\t\\t\\tif (lastClaimTime[tokenId] == 0) { // presale\\n\\t\\t\\t\\trequire(!presale, \\\"Logic: Presale ongoing\\\");\\n\\t\\t\\t\\tlastClaimTime[tokenId] = block.timestamp;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tunchecked { amount += pendingOf(tokenId); }\\n\\t\\t\\t\\tlastClaimTime[tokenId] = block.timestamp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (amount == 0)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (stake)\\n\\t\\t\\tIStaking(staking).stake(amount, sender);\\n\\t\\telse\\n\\t\\t\\tIERC20(bigFoot).transferFrom(treasury, sender, amount);\\n\\t\\t\\n\\t\\temit ClaimedNode(sender, tokenIds.length, amount, stake);\\n\\t}\\n\\n\\t// Setters\\n\\tfunction setApplyLp(bool _new) external onlyAuthority {\\n\\t\\tapplyLp = _new;\\n\\t}\\n\\t\\n\\tfunction setLpRate(uint _new) external onlyAuthority {\\n\\t\\tlpRate = _new;\\n\\t}\\n\\n\\tfunction setApplyTreasury(bool _new) external onlyAuthority {\\n\\t\\tapplyTreasury = _new;\\n\\t}\\n\\t\\n\\tfunction setTreasuryRate(uint _new) external onlyAuthority {\\n\\t\\ttreasuryRate = _new;\\n\\t}\\n\\t\\n\\tfunction setDailyRewards(uint _new) external onlyAuthority {\\n\\t\\tdailyRewards = _new;\\n\\t}\\n\\t\\n\\tfunction setPresale(bool _new) external onlyAuthority {\\n\\t\\tpresale = _new;\\n\\t}\\n\\t\\n\\tfunction setWhitelisted(address[] calldata _addr, bool _new) external onlyAuthority {\\n\\t\\tfor (uint i = 0; i < _addr.length; i++) {\\n\\t\\t\\twhitelisted[_addr[i]] = _new;\\n\\t\\t}\\n\\t}\\n\\n\\t// Web3\\n\\tfunction pendingOf(uint tokenId) public view returns (uint) {\\n\\t\\treturn dailyRewards * (block.timestamp - lastClaimTime[tokenId]) / DAY;\\n\\t}\\n\\n\\t// Internal\\n\\tfunction safeTransferSplitter(address token) internal {\\n\\t\\tIERC20 erc20 = IERC20(token); // gas\\n\\t\\tuint balance = erc20.balanceOf(address(this));\\n\\t\\tif (balance > 0)\\n\\t\\t\\terc20.transfer(splitter, balance);\\n\\t}\\n\\n\\tfunction swapAndAdd(uint amount) internal {\\n\\t\\tuint swappedHalf = amount / 2;\\n\\t\\tuint otherHalf = amount - swappedHalf;\\n\\t\\tuint amountOut = swapExactTokensForTokens(swappedHalf);\\n\\t\\taddLiquidity(otherHalf, amountOut);\\n\\t}\\n\\n\\tfunction swapExactTokensForTokens(uint amount) internal returns (uint){\\n\\t\\taddress[] memory path = new address[](2);\\n\\t\\tpath[0] = stable;\\n\\t\\tpath[1] = bigFoot;\\n\\t\\treturn IUniswapV2Router(router).swapExactTokensForTokens(\\n\\t\\t\\tamount,\\n\\t\\t\\t0,\\n\\t\\t\\tpath,\\n\\t\\t\\taddress(this),\\n\\t\\t\\tblock.timestamp\\n\\t\\t)[1];\\n\\t}\\n\\n\\tfunction addLiquidity(uint _stableAmount, uint _bigFootAmount) internal {\\n\\t\\tIUniswapV2Router(router).addLiquidity(\\n\\t\\t\\tstable,\\n\\t\\t\\tbigFoot,\\n\\t\\t\\t_stableAmount,\\n\\t\\t\\t_bigFootAmount,\\n\\t\\t\\t0,\\n\\t\\t\\t0,\\n\\t\\t\\ttreasury,\\n\\t\\t\\tblock.timestamp\\n\\t\\t);\\n\\t}\\n}\\n\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/IUniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n\\ninterface IUniswapV2Router {\\n\\tfunction addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n\\tfunction swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint256[] memory amounts);\\n}\\n\\n\"\r\n    },\r\n    \"contracts/Authority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\n\\ncontract Authority {\\n\\t\\n\\taddress[] public authorities;\\n\\tmapping(address => bool) public isAuthority;\\n\\n\\tconstructor() {\\n\\t\\tauthorities.push(msg.sender);\\n\\t\\tisAuthority[msg.sender] = true;\\n\\t}\\n\\n\\tmodifier onlySuperAuthority() {\\n\\t\\trequire(authorities[0] == msg.sender, \\\"Authority: Only Super Authority\\\");\\n\\t\\t_;\\n\\t}\\n\\t\\n\\tmodifier onlyAuthority() {\\n\\t\\trequire(isAuthority[msg.sender], \\\"Authority: Only Authority\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tfunction addAuthority(address _new, bool _change) external onlySuperAuthority {\\n\\t\\trequire(!isAuthority[_new], \\\"Authoritys: Already authority\\\");\\n\\t\\tisAuthority[_new] = true;\\n\\t\\tif (_change) {\\n\\t\\t\\tauthorities.push(authorities[0]);\\n\\t\\t\\tauthorities[0] = _new;\\n\\t\\t} else {\\n\\t\\t\\tauthorities.push(_new);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction removeAuthority(address _new) external onlySuperAuthority {\\n\\t\\trequire(isAuthority[_new], \\\"Authority: Not authority\\\");\\n\\t\\trequire(_new != authorities[0], \\\"Authority: Cannot remove super authority\\\");\\n\\t\\tfor (uint i = 1; i < authorities.length; i++) {\\n\\t\\t\\tif (authorities[i] == _new) {\\n\\t\\t\\t\\tauthorities[i] = authorities[authorities.length - 1];\\n\\t\\t\\t\\tauthorities.pop();\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tisAuthority[_new] = false;\\n\\t}\\n\\n\\tfunction getAuthoritiesSize() external view returns(uint) {\\n\\t\\treturn authorities.length;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n\\ninterface IStaking {\\n\\tfunction stake(uint256 _amount, address _recipient) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rates\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_dailyRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"staked\",\"type\":\"bool\"}],\"name\":\"ClaimedNode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"CreatedNode\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE_INCR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REF_PRICE_INCR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REF_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_change\",\"type\":\"bool\"}],\"name\":\"addAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"applyLp\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"applyTreasury\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"authorities\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bigFoot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dailyRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuthoritiesSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAuthority\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastClaimTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"pendingOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"removeAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stake\",\"type\":\"bool\"}],\"name\":\"safeClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"stake\",\"type\":\"bool\"}],\"name\":\"safeClaimBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"safeMintBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_new\",\"type\":\"bool\"}],\"name\":\"setApplyLp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_new\",\"type\":\"bool\"}],\"name\":\"setApplyTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"setDailyRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"setLpRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_new\",\"type\":\"bool\"}],\"name\":\"setPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"setTreasuryRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_new\",\"type\":\"bool\"}],\"name\":\"setWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"splitter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stable\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yeti\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Logic", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000006f05b59d3b200000000000000000000000000000000000000000000000000000000000000000007000000000000000000000000c4ea977c6c3519a8527f3ff0728caab40c1071520000000000000000000000009e57b50b077a6b477e74bb62901823b2e9620f47000000000000000000000000d4c72bffe7399d7e116850dc391b3b95a43d0a8d000000000000000000000000c29766348744f9d9df715f465f7ebfd7f729ec820000000000000000000000007959c178a639109d863675b855f5b4bc11247f0c000000000000000000000000d9e1ce17f2641f24ae83637ab66a2cca9c378b9f000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000001b5800000000000000000000000000000000000000000000000000000000000007d0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}