{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.23;\r\n\r\n\r\n// thanks to https://github.com/willitscale/solidity-util and https://github.com/Arachnid/solidity-stringutils\r\nlibrary StringUtils {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string self) internal pure returns (slice) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\n     * @param self The slice to copy.\r\n     * @return A new slice containing the same data as `self`.\r\n     */\r\n    function copy(slice self) internal pure returns (slice) {\r\n        return slice(self._len, self._ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice's text.\r\n     */\r\n    function toString(slice self) internal pure returns (string) {\r\n        string memory ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n    * Lower\r\n    *\r\n    * Converts all the values of a string to their corresponding lower case\r\n    * value.\r\n    *\r\n    * @param _base When being used for a data type this is the extended object\r\n    *              otherwise this is the string base to convert to lower case\r\n    * @return string\r\n    */\r\n    function lower(string _base) internal pure returns (string) {\r\n        bytes memory _baseBytes = bytes(_base);\r\n        for (uint i = 0; i < _baseBytes.length; i++) {\r\n            _baseBytes[i] = _lower(_baseBytes[i]);\r\n        }\r\n        return string(_baseBytes);\r\n    }\r\n\r\n    /**\r\n    * Lower\r\n    *\r\n    * Convert an alphabetic character to lower case and return the original\r\n    * value when not alphabetic\r\n    *\r\n    * @param _b1 The byte to be converted to lower case\r\n    * @return bytes1 The converted value if the passed value was alphabetic\r\n    *                and in a upper case otherwise returns the original value\r\n    */\r\n    function _lower(bytes1 _b1) internal pure returns (bytes1) {\r\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\r\n            return bytes1(uint8(_b1) + 32);\r\n        }\r\n        return _b1;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}", "ABI": "[]", "ContractName": "StringUtils", "CompilerVersion": "v0.4.23+commit.124ca40d", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://4ab8701268aa87ad9549f1038b7e2d1834e1b2aa3328e266140a65b7b46e9169"}]}