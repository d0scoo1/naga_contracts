{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": false\r\n      },\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n                    decodedLen := sub(decodedLen, 1)\\n                }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               // read 4 characters\\n               dataPtr := add(dataPtr, 4)\\n               let input := mload(dataPtr)\\n\\n               // write 3 bytes\\n               let output := add(\\n                   add(\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\n                   add(\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\n                    )\\n                )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/FashionHatPunksData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0 <0.9.0;\\npragma abicoder v2;\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./StringUtilsLib.sol\\\";\\n\\ninterface PunkDataInterface {\\n    function punkImage(uint16 index) external view returns (bytes memory);\\n    function punkAttributes(uint16 index) external view returns (string memory);\\n}\\n\\ncontract FashionHatPunksData is Ownable {\\n    using StringUtils for string;\\n    using Strings for uint16;\\n    using Strings for uint8;\\n    using Strings for uint256;\\n    \\n    PunkDataInterface immutable punkDataContract;\\n    \\n    enum HatType { BASEBALL, BUCKET, COWBOY, VISOR }\\n    enum HatSize { REGULAR, SMALL }\\n    enum HatColor { BLACK, GREY, RED, WHITE, TAN, BROWN }\\n    enum HatPosition { REGULAR, FLIPPED }\\n    \\n    enum PunkAttributeType {SEX, HAIR, EYES, BEARD, EARS, LIPS, MOUTH,\\n                                FACE, EMOTION, NECK, NOSE, CHEEKS, TEETH}\\n    \\n    enum PunkAttributeValue {NONE, ALIEN, APE, BANDANA, BEANIE, BIG_BEARD, BIG_SHADES, BLACK_LIPSTICK, BLONDE_BOB, BLONDE_SHORT, BLUE_EYE_SHADOW, BUCK_TEETH, CAP, CAP_FORWARD, CHINSTRAP, CHOKER, CIGARETTE, CLASSIC_SHADES, CLOWN_EYES_BLUE, CLOWN_EYES_GREEN, CLOWN_HAIR_GREEN, CLOWN_NOSE, COWBOY_HAT, CRAZY_HAIR, DARK_HAIR, DO_RAG, EARRING, EYE_MASK, EYE_PATCH, FEDORA, FEMALE, FRONT_BEARD, FRONT_BEARD_DARK, FROWN, FRUMPY_HAIR, GOAT, GOLD_CHAIN, GREEN_EYE_SHADOW, HALF_SHAVED, HANDLEBARS, HEADBAND, HOODIE, HORNED_RIM_GLASSES, HOT_LIPSTICK, KNITTED_CAP, LUXURIOUS_BEARD, MALE, MEDICAL_MASK, MESSY_HAIR, MOHAWK, MOHAWK_DARK, MOHAWK_THIN, MOLE, MUSTACHE, MUTTONCHOPS, NERD_GLASSES, NORMAL_BEARD, NORMAL_BEARD_BLACK, ORANGE_SIDE, PEAK_SPIKE, PIGTAILS, PILOT_HELMET, PINK_WITH_HAT, PIPE, POLICE_CAP, PURPLE_EYE_SHADOW, PURPLE_HAIR, PURPLE_LIPSTICK, RED_MOHAWK, REGULAR_SHADES, ROSY_CHEEKS, SHADOW_BEARD, SHAVED_HEAD, SILVER_CHAIN, SMALL_SHADES, SMILE, SPOTS, STRAIGHT_HAIR, STRAIGHT_HAIR_BLONDE, STRAIGHT_HAIR_DARK, STRINGY_HAIR, TASSLE_HAT, THREE_D_GLASSES, TIARA, TOP_HAT, VAMPIRE_HAIR, VAPE, VR, WELDING_GOGGLES, WILD_BLONDE, WILD_HAIR, WILD_WHITE_HAIR, ZOMBIE}\\n    \\n    constructor(address punkDataContractAddress) {\\n        punkDataContract = PunkDataInterface(punkDataContractAddress);\\n    }\\n    \\n    function punkHatType(Punk memory punk) public view returns (HatType result) {\\n        uint[] memory choiceWeights = new uint[](4);\\n        \\n        for (uint i; i < 4; i++) {\\n            choiceWeights[i] = 25e8;\\n        }\\n        \\n        if (!visorLooksGood[punk.hair][punk.sex]) { \\n            choiceWeights[uint(HatType.VISOR)] = 5e8;\\n        }\\n        \\n        if (punk.hair == PunkAttributeValue.COWBOY_HAT) {\\n            return HatType.COWBOY;\\n        }\\n        if (punk.hair == PunkAttributeValue.CAP ||\\n            punk.hair == PunkAttributeValue.BEANIE ||\\n            (punk.sex != PunkAttributeValue.FEMALE && originalEyePixelGap(punk) == 2)\\n        ) {\\n            return HatType.BASEBALL;\\n        }\\n        \\n        if ((punk.sex == PunkAttributeValue.FEMALE || originalEyePixelGap(punk) == 1) &&\\n            punk.mouth == PunkAttributeValue.CIGARETTE &&\\n            (canWearHat(punk, HatType.BUCKET) ||\\n            (canWearHat(punk, HatType.BASEBALL) && canFlipHat(punk)))\\n        ) {\\n            choiceWeights[uint(HatType.COWBOY)] /= 5;\\n            choiceWeights[uint(HatType.VISOR)] /= 5;\\n            \\n            if (!canFlipHat(punk)) {\\n                choiceWeights[uint(HatType.BASEBALL)] /= 5;\\n            }\\n        }\\n        \\n        if (punk.seed < 55 && canWearHat(punk, HatType.BASEBALL) &&\\n            punk.sex != PunkAttributeValue.FEMALE &&\\n            (punk.eyes == PunkAttributeValue.VR || punk.eyes == PunkAttributeValue.BIG_SHADES) &&\\n            originalEyePixelGap(punk) != 1\\n        ) {\\n            return HatType.BASEBALL;\\n        }\\n        \\n        if (punk.seed < 75 &&\\n           punk.sex != PunkAttributeValue.FEMALE &&\\n           (punk.eyes == PunkAttributeValue.VR || punk.eyes == PunkAttributeValue.BIG_SHADES) &&\\n           (canWearHat(punk, HatType.COWBOY) || canWearHat(punk, HatType.BUCKET))\\n        ) {\\n            choiceWeights[uint(HatType.BASEBALL)] = 0;\\n            choiceWeights[uint(HatType.VISOR)] = 0;\\n        }\\n        \\n        if (!visibleHairAttribute(punk) && \\n            (canWearHat(punk, HatType.COWBOY) ||\\n             canWearHat(punk, HatType.BASEBALL) ||\\n             canWearHat(punk, HatType.BUCKET))\\n        ) {\\n            choiceWeights[uint(HatType.VISOR)] = 0;\\n        }\\n        \\n        if (punk.sex != PunkAttributeValue.FEMALE &&\\n            punk.hair == PunkAttributeValue.CLOWN_HAIR_GREEN &&\\n            (punk.eyes == PunkAttributeValue.VR || punk.eyes == PunkAttributeValue.BIG_SHADES)\\n        ) {\\n            choiceWeights[uint(HatType.VISOR)] = 0;\\n        }\\n        \\n        if (punk.eyes == PunkAttributeValue.WELDING_GOGGLES && \\n            (canWearHat(punk, HatType.COWBOY) ||\\n             canWearHat(punk, HatType.BASEBALL) ||\\n             canWearHat(punk, HatType.BUCKET))\\n        ) {\\n            choiceWeights[uint(HatType.VISOR)] = 0;\\n        }\\n        \\n        for (uint i; i < 4; i++) {\\n            if (!canWearHat(punk, HatType(i))) {\\n                choiceWeights[i] = 0;\\n            }\\n        }\\n        \\n        uint8 choiceIndex = weightedChoice(punk, choiceWeights, \\\"hat_type\\\");\\n        return HatType(choiceIndex);\\n    }\\n    \\n    function punkHatColor(Punk memory punk) public view returns (HatColor result) {\\n        HatType hatType = punkHatType(punk);\\n        \\n        uint[] memory choiceWeights = new uint[](6);\\n        \\n        if (hatType == HatType.BASEBALL) {\\n            choiceWeights[uint(HatColor.BLACK)] = 22.5e8;\\n            choiceWeights[uint(HatColor.GREY)] = 25e8;\\n            choiceWeights[uint(HatColor.RED)] = 20e8;\\n            choiceWeights[uint(HatColor.WHITE)] = 25e8;\\n            choiceWeights[uint(HatColor.TAN)] = 20e8;\\n            choiceWeights[uint(HatColor.BROWN)] = 0;\\n        } else if (hatType == HatType.BUCKET) {\\n            choiceWeights[uint(HatColor.BLACK)] = 50e8;\\n            choiceWeights[uint(HatColor.GREY)] = 0;\\n            choiceWeights[uint(HatColor.RED)] = 0;\\n            choiceWeights[uint(HatColor.WHITE)] = 0;\\n            choiceWeights[uint(HatColor.TAN)] = 50e8;\\n            choiceWeights[uint(HatColor.BROWN)] = 50e8;\\n        } else if (hatType == HatType.COWBOY) {\\n            choiceWeights[uint(HatColor.BLACK)] = 60e8;\\n            choiceWeights[uint(HatColor.GREY)] = 20e8;\\n            choiceWeights[uint(HatColor.RED)] = 0;\\n            choiceWeights[uint(HatColor.WHITE)] = 0;\\n            choiceWeights[uint(HatColor.TAN)] = 40e8;\\n            choiceWeights[uint(HatColor.BROWN)] = 0;\\n        } else if (hatType == HatType.VISOR) {\\n            choiceWeights[uint(HatColor.BLACK)] = 22.5e8;\\n            choiceWeights[uint(HatColor.GREY)] = 25e8;\\n            choiceWeights[uint(HatColor.RED)] = 20e8;\\n            choiceWeights[uint(HatColor.WHITE)] = 25e8;\\n            choiceWeights[uint(HatColor.TAN)] = 20e8;\\n            choiceWeights[uint(HatColor.BROWN)] = 0;\\n        }\\n        \\n        if (punk.hair == PunkAttributeValue.HOODIE) {\\n            choiceWeights[uint(HatColor.BLACK)] = 0;\\n            choiceWeights[uint(HatColor.GREY)] = 0;\\n            choiceWeights[uint(HatColor.RED)] = 10e8;\\n            choiceWeights[uint(HatColor.WHITE)] = 30e8;\\n            choiceWeights[uint(HatColor.TAN)] = 30e8;\\n        }\\n        \\n        if (punk.eyes == PunkAttributeValue.THREE_D_GLASSES || punk.hair == PunkAttributeValue.WILD_WHITE_HAIR) {\\n            choiceWeights[uint(HatColor.WHITE)] = 0;\\n        }\\n        \\n        if (punk.hair == PunkAttributeValue.DARK_HAIR && hatType == HatType.BUCKET) {\\n            choiceWeights[uint(HatColor.BLACK)] /= 10;\\n        }\\n        \\n        if (hatType == HatType.VISOR) {\\n            if (punk.hair == PunkAttributeValue.WILD_HAIR || punk.hair == PunkAttributeValue.HALF_SHAVED ||\\n               ((punk.hair == PunkAttributeValue.HEADBAND && punk.sex == PunkAttributeValue.FEMALE))) {\\n                choiceWeights[uint(HatColor.BLACK)] = 0;\\n            }\\n            \\n            if (punk.hair == PunkAttributeValue.WILD_BLONDE) {\\n                choiceWeights[uint(HatColor.TAN)] = 0;\\n            }\\n        }\\n        \\n        if (hatType == HatType.COWBOY || hatType == HatType.BUCKET) {\\n            if (\\n                eyesWithBlackTop(punk) ||\\n                punk.hair == PunkAttributeValue.FRUMPY_HAIR ||\\n                punk.hair == PunkAttributeValue.WILD_HAIR ||\\n                punk.hair == PunkAttributeValue.HALF_SHAVED\\n            ) {\\n                choiceWeights[uint(HatColor.BLACK)] = 0;\\n            }\\n        }\\n        \\n        if (punk.sex != PunkAttributeValue.FEMALE && (punk.eyes == PunkAttributeValue.VR || punk.eyes == PunkAttributeValue.BIG_SHADES)) {\\n            choiceWeights[uint(HatColor.BLACK)] = 0;\\n        }\\n        \\n        if (punk.hair == PunkAttributeValue.CRAZY_HAIR && (punk.sex == PunkAttributeValue.FEMALE || hatType == HatType.VISOR)) {\\n            choiceWeights[uint(HatColor.RED)] = 0;\\n        }\\n        \\n        uint8 choiceIndex = weightedChoice(punk, choiceWeights, \\\"hat_color\\\");\\n        return HatColor(choiceIndex);\\n    }\\n    \\n    function punkHatPosition(Punk memory punk) public view returns (HatPosition result) {\\n        HatType hatType = punkHatType(punk);\\n        \\n        if (hatType != HatType.BASEBALL) {\\n            return HatPosition.REGULAR;\\n        }\\n        \\n        uint[] memory choiceWeights = new uint[](2);\\n        \\n        choiceWeights[uint(HatPosition.REGULAR)] = 50e8;\\n        choiceWeights[uint(HatPosition.FLIPPED)] = 50e8;\\n        \\n        if (punk.hair == PunkAttributeValue.HALF_SHAVED) {\\n            return HatPosition.FLIPPED;\\n        }\\n        \\n        if (!canFlipHat(punk)) {\\n            return HatPosition.REGULAR;\\n        }\\n        \\n        if (\\n            punk.sex != PunkAttributeValue.FEMALE &&\\n            (punk.eyes == PunkAttributeValue.VR || punk.eyes == PunkAttributeValue.BIG_SHADES) &&\\n            hatEyePixelGap(punk) == 1\\n        ) {\\n            return (punk.eyes == PunkAttributeValue.BIG_SHADES ? HatPosition.REGULAR : HatPosition.FLIPPED);\\n        }\\n        \\n        if ((punk.sex == PunkAttributeValue.FEMALE || originalEyePixelGap(punk) == 1) &&\\n            punk.mouth == PunkAttributeValue.CIGARETTE\\n        ) {\\n            choiceWeights[uint(HatPosition.REGULAR)] /= 10;\\n        }\\n        \\n        if (\\n            punk.hair == PunkAttributeValue.HOODIE ||\\n            punk.hair == PunkAttributeValue.BEANIE ||\\n            originalEyePixelGap(punk) == 2\\n        ) {\\n            return HatPosition.REGULAR;\\n        }\\n        \\n        uint8 choiceIndex = weightedChoice(punk, choiceWeights, \\\"hat_position\\\");\\n        return HatPosition(choiceIndex);\\n    }\\n    \\n    function hatEyePixelGap(Punk memory punk) public view returns (uint8 gap) {\\n        HatType currentHat = punkHatType(punk);\\n        \\n        if (\\n            currentHat == HatType.VISOR ||\\n            currentHat == HatType.BUCKET ||\\n            currentHat == HatType.COWBOY\\n        ) {\\n            return 1;\\n        }\\n        \\n        if (punk.hair == PunkAttributeValue.BANDANA) {\\n            if (punk.sex == PunkAttributeValue.FEMALE) {\\n                return 1;\\n            } else {\\n                if (punk.eyes == PunkAttributeValue.BIG_SHADES || punk.eyes == PunkAttributeValue.VR) {\\n                    return 2;\\n                } else {\\n                    return 1;\\n                }\\n            }\\n        }\\n        \\n        uint8 originalGap = originalEyePixelGap(punk);\\n        \\n        if (punk.sex != PunkAttributeValue.FEMALE) {\\n            if (\\n                punk.hair == PunkAttributeValue.CLOWN_HAIR_GREEN ||\\n                punk.hair == PunkAttributeValue.HOODIE\\n            ) {\\n                return 1;\\n            } else {\\n                return (originalGap > 0 ? originalGap : 2);\\n            }\\n        }\\n        \\n        if (\\n            (currentHat == HatType.BASEBALL &&\\n            (punk.hair == PunkAttributeValue.DARK_HAIR || punk.hair == PunkAttributeValue.ORANGE_SIDE)) ||\\n            (punk.hair == PunkAttributeValue.PINK_WITH_HAT || punk.hair == PunkAttributeValue.STRAIGHT_HAIR ||\\n             punk.hair == PunkAttributeValue.STRAIGHT_HAIR_BLONDE || punk.hair == PunkAttributeValue.STRAIGHT_HAIR_DARK)\\n        ) {\\n            return 1;\\n        }\\n        \\n        return (originalGap > 0 ? originalGap : 2);\\n    }\\n    \\n    function punkHatSize(Punk memory punk) public view returns (HatSize result) {\\n        HatType currentHat = punkHatType(punk);\\n\\n        if (punk.sex != PunkAttributeValue.FEMALE) {\\n            return HatSize.REGULAR;\\n        }\\n        \\n        if (currentHat == HatType.BASEBALL && punk.hair == PunkAttributeValue.CRAZY_HAIR) {\\n            return HatSize.REGULAR;\\n        }\\n        \\n        if (currentHat == HatType.BUCKET && punk.hair == PunkAttributeValue.WILD_HAIR) {\\n            return HatSize.REGULAR;\\n        }\\n        \\n        if (\\n            currentHat == HatType.BUCKET ||\\n            currentHat == HatType.BASEBALL\\n        ) {\\n            if (\\n                punk.hair == PunkAttributeValue.BLONDE_BOB ||\\n                punk.hair == PunkAttributeValue.BLONDE_SHORT\\n            ) {\\n                return HatSize.REGULAR;\\n            }\\n        }\\n        \\n        if (\\n            currentHat == HatType.COWBOY ||\\n            currentHat == HatType.BUCKET ||\\n            currentHat == HatType.BASEBALL\\n        ) {\\n            if (\\n                punk.hair == PunkAttributeValue.FRUMPY_HAIR\\n            ) {\\n                return HatSize.REGULAR;\\n            }\\n        }\\n        \\n        if (\\n            currentHat == HatType.COWBOY ||\\n            currentHat == HatType.BUCKET\\n        ) {\\n            if (\\n                punk.hair == PunkAttributeValue.HALF_SHAVED ||\\n                punk.hair == PunkAttributeValue.WILD_BLONDE\\n            ) {\\n                return HatSize.REGULAR;\\n            }\\n        }\\n        \\n        if (\\n            punk.hair == PunkAttributeValue.STRAIGHT_HAIR_BLONDE ||\\n            punk.hair == PunkAttributeValue.STRAIGHT_HAIR ||\\n            punk.hair == PunkAttributeValue.STRAIGHT_HAIR_DARK\\n        ) {\\n            return HatSize.REGULAR;\\n        }\\n        \\n        return HatSize.SMALL;\\n    }\\n    \\n    mapping(PunkAttributeValue => mapping(PunkAttributeValue => bool)) public canFlipHatMapping;\\n    \\n    function setcanFlipHatMapping(PunkAttributeValue[] memory hairs, PunkAttributeValue[] memory sexes) external onlyOwner {\\n        for (uint i; i < hairs.length; i++) {\\n            PunkAttributeValue hair = hairs[i];\\n            PunkAttributeValue sex = sexes[i];\\n            \\n            canFlipHatMapping[hair][sex] = true;\\n        }\\n    }\\n    \\n    function canFlipHat(Punk memory punk) public view returns (bool) {\\n        if (!canWearHat(punk, HatType.BASEBALL)) {\\n            return false;\\n        }\\n        \\n        return canFlipHatMapping[punk.hair][punk.sex];\\n    }\\n    \\n    function randomNumber(Punk memory punk, uint lessThanNumb, string memory seedAddition) public pure returns (uint) {\\n        uint16 seed = punk.seed;\\n        uint256 randomNum = uint256(\\n            keccak256(abi.encodePacked(punk.id.toString(), \\\":\\\", seed.toString(), seedAddition))\\n        );\\n        \\n        return uint(randomNum % lessThanNumb);\\n    }\\n    \\n    function weightedChoice(Punk memory punk, uint[] memory choiceWeights, string memory seedAddition) public pure returns (uint8) {\\n        uint sumOfWeights;\\n        uint numChoices = choiceWeights.length;\\n\\n        for (uint i; i < numChoices; i++) {\\n            sumOfWeights += choiceWeights[i];\\n        }\\n        \\n        uint randomNumberInstance = randomNumber(punk, sumOfWeights, seedAddition);\\n        \\n        for (uint8 i; i < numChoices; i++) {\\n            if (randomNumberInstance < choiceWeights[i]) {\\n                return i;\\n            } else {\\n                randomNumberInstance -= choiceWeights[i];\\n            }\\n        }\\n    }\\n    \\n    mapping(PunkAttributeValue => mapping(PunkAttributeValue => bool)) public visorLooksGood;\\n    \\n    function setVisorLooksGood(PunkAttributeValue[] memory hairs, PunkAttributeValue[] memory sexes) external onlyOwner {\\n        for (uint i = 0; i < hairs.length; i++) {\\n            PunkAttributeValue hair = hairs[i];\\n            PunkAttributeValue sex = sexes[i];\\n            \\n            visorLooksGood[hair][sex] = true;\\n        }\\n    }\\n    \\n    mapping(PunkAttributeValue => mapping(PunkAttributeValue => bool)) public lacksVisibleHairAttribute;\\n    \\n    function setLacksVisibleHairAttribute(PunkAttributeValue[] memory hairs, PunkAttributeValue[] memory sexes) external onlyOwner {\\n        for (uint i = 0; i < hairs.length; i++) {\\n            PunkAttributeValue hair = hairs[i];\\n            PunkAttributeValue sex = sexes[i];\\n            \\n            lacksVisibleHairAttribute[hair][sex] = true;\\n        }\\n    }\\n    \\n    function visibleHairAttribute(Punk memory punk) public view returns (bool) {\\n        return !lacksVisibleHairAttribute[punk.hair][punk.sex];\\n    }\\n    \\n    mapping(PunkAttributeValue => mapping(PunkAttributeValue => uint8)) public originalEyePixelGapMapping;\\n    \\n    function setOriginalEyePixelGap(PunkAttributeValue[] memory hairs, PunkAttributeValue[] memory sexes, uint8[] memory gaps) external onlyOwner {\\n        for (uint i = 0; i < hairs.length; i++) {\\n            PunkAttributeValue hair = hairs[i];\\n            PunkAttributeValue sex = sexes[i];\\n            \\n            originalEyePixelGapMapping[hair][sex] = gaps[i];\\n        }\\n    }\\n    \\n    function originalEyePixelGap(Punk memory punk) public view returns (uint8 gap) {\\n        return originalEyePixelGapMapping[punk.hair][punk.sex];\\n    }\\n    \\n    function eyesWithBlackTop(Punk memory punk) public pure returns (bool) {\\n        if (punk.sex == PunkAttributeValue.FEMALE && punk.eyes == PunkAttributeValue.REGULAR_SHADES) {\\n            return true;\\n        }\\n        \\n        return (\\n            punk.eyes == PunkAttributeValue.NERD_GLASSES ||\\n            punk.eyes == PunkAttributeValue.HORNED_RIM_GLASSES ||\\n            punk.eyes == PunkAttributeValue.EYE_PATCH ||\\n            punk.eyes == PunkAttributeValue.EYE_MASK ||\\n            punk.eyes == PunkAttributeValue.CLASSIC_SHADES ||\\n            punk.eyes == PunkAttributeValue.BIG_SHADES ||\\n            punk.eyes == PunkAttributeValue.VR\\n        );\\n    }\\n    \\n    struct Punk {\\n        uint16 id;\\n        uint16 seed;\\n        PunkAttributeValue sex;\\n        PunkAttributeValue hair;\\n        PunkAttributeValue eyes;\\n        PunkAttributeValue beard;\\n        PunkAttributeValue ears;\\n        PunkAttributeValue lips;\\n        PunkAttributeValue mouth;\\n        PunkAttributeValue face;\\n        PunkAttributeValue emotion;\\n        PunkAttributeValue neck;\\n        PunkAttributeValue nose;\\n        PunkAttributeValue cheeks;\\n        PunkAttributeValue teeth;\\n    }\\n    \\n    function initializePunk(uint16 punkId, uint16 punkSeed) public view returns (Punk memory) {\\n        Punk memory punk = Punk({\\n            id: punkId,\\n            seed: punkSeed,\\n            sex: PunkAttributeValue.NONE,\\n            hair: PunkAttributeValue.NONE,\\n            eyes: PunkAttributeValue.NONE,\\n            beard: PunkAttributeValue.NONE,\\n            ears: PunkAttributeValue.NONE,\\n            lips: PunkAttributeValue.NONE,\\n            mouth: PunkAttributeValue.NONE,\\n            face: PunkAttributeValue.NONE,\\n            emotion: PunkAttributeValue.NONE,\\n            neck: PunkAttributeValue.NONE,\\n            nose: PunkAttributeValue.NONE,\\n            cheeks: PunkAttributeValue.NONE,\\n            teeth: PunkAttributeValue.NONE\\n        });\\n        \\n        string memory attributes = punkDataContract.punkAttributes(punk.id);\\n\\n        string[] memory attributeArray = attributes.split(\\\",\\\");\\n        \\n        for (uint i = 0; i < attributeArray.length; i++) {\\n            string memory untrimmedAttribute = attributeArray[i];\\n            string memory trimmedAttribute;\\n            \\n            if (i < 1) {\\n                trimmedAttribute = untrimmedAttribute.split(' ')[0];\\n            } else {\\n                trimmedAttribute = untrimmedAttribute._substring(int(bytes(untrimmedAttribute).length - 1), 1);\\n            }\\n            \\n            PunkAttributeValue attrValue = attrStringToEnumMapping[trimmedAttribute];\\n            PunkAttributeType attrType = attrValueToTypeEnumMapping[attrValue];\\n            \\n            if (attrType == PunkAttributeType.SEX) {\\n                punk.sex = attrValue;\\n            } else if (attrType == PunkAttributeType.HAIR) {\\n                punk.hair = attrValue;\\n            } else if (attrType == PunkAttributeType.EYES) {\\n                punk.eyes = attrValue;\\n            } else if (attrType == PunkAttributeType.BEARD) {\\n                punk.beard = attrValue;\\n            } else if (attrType == PunkAttributeType.EARS) {\\n                punk.ears = attrValue;\\n            } else if (attrType == PunkAttributeType.LIPS) {\\n                punk.lips = attrValue;\\n            } else if (attrType == PunkAttributeType.MOUTH) {\\n                punk.mouth = attrValue;\\n            } else if (attrType == PunkAttributeType.FACE) {\\n                punk.face = attrValue;\\n            } else if (attrType == PunkAttributeType.EMOTION) {\\n                punk.emotion = attrValue;\\n            } else if (attrType == PunkAttributeType.NECK) {\\n                punk.neck = attrValue;\\n            } else if (attrType == PunkAttributeType.NOSE) {\\n                punk.nose = attrValue;\\n            } else if (attrType == PunkAttributeType.CHEEKS) {\\n                punk.cheeks = attrValue;\\n            } else if (attrType == PunkAttributeType.TEETH) {\\n                punk.teeth = attrValue;\\n            }\\n        }\\n        \\n        return punk;\\n    }\\n    \\n    function punkAttributesAsJSON(uint16 punkId, uint16 punkSeed) public view returns (string memory json) {\\n        Punk memory punk = initializePunk(punkId, punkSeed);\\n        \\n        PunkAttributeValue none = PunkAttributeValue.NONE;\\n        bytes memory output = \\\"[\\\";\\n        \\n        HatType hat = punkHatType(punk);\\n        HatColor hatColor = punkHatColor(punk);\\n        HatPosition hatPosition = punkHatPosition(punk);\\n        \\n        PunkAttributeValue[13] memory attrArray = [\\n            punk.sex,\\n            (visibleHair(punk) ? punk.hair : none),\\n            punk.eyes,\\n            punk.beard,\\n            punk.ears,\\n            punk.lips,\\n            punk.mouth,\\n            punk.face,\\n            punk.emotion,\\n            punk.neck,\\n            punk.nose,\\n            punk.cheeks,\\n            punk.teeth\\n        ];\\n        \\n        bytes memory hatColorBytes;\\n        \\n        if (hatColor == HatColor.BLACK) {\\n            hatColorBytes = \\\"Black\\\";\\n        } else if (hatColor == HatColor.GREY) {\\n            hatColorBytes = \\\"Grey\\\";\\n        } else if (hatColor == HatColor.RED) {\\n            hatColorBytes = \\\"Red\\\";\\n        } else if (hatColor == HatColor.WHITE) {\\n            hatColorBytes = \\\"White\\\";\\n        } else if (hatColor == HatColor.TAN) {\\n            hatColorBytes = \\\"Tan\\\";\\n        } else if (hatColor == HatColor.BROWN) {\\n            hatColorBytes = \\\"Brown\\\";\\n        }\\n        \\n        bytes memory hatTypeBytes;\\n        \\n        if (hat == HatType.BASEBALL) {\\n            hatTypeBytes = \\\"Baseball Cap\\\";\\n        } else if (hat == HatType.BUCKET) {\\n            hatTypeBytes = \\\"Bucket Hat\\\";\\n        } else if (hat == HatType.COWBOY) {\\n            hatTypeBytes = \\\"Cowboy Hat\\\";\\n        } else if (hat == HatType.VISOR) {\\n            hatTypeBytes = \\\"Visor\\\";\\n        }\\n        \\n        for (uint i = 0; i < 13; ++i) {\\n            PunkAttributeValue attrVal = attrArray[i];\\n            \\n            if (attrVal != none) {\\n                output = abi.encodePacked(output, punkAttributeAsJSON(attrVal), \\\",\\\");\\n            }\\n        }\\n        \\n        bytes memory hatName = abi.encodePacked(hatColorBytes, \\\" \\\", hatTypeBytes);\\n        \\n        if (hatPosition == HatPosition.FLIPPED) {\\n            hatName = abi.encodePacked(\\\"Backwards \\\", hatName);\\n        }\\n        \\n        bytes memory hatTrait = abi.encodePacked(\\n            '{\\\"trait_type\\\":\\\"Fashion Hat\\\", \\\"value\\\":\\\"', hatName, '\\\"}'\\n        );\\n        \\n        return string(abi.encodePacked(output, hatTrait, \\\"]\\\"));\\n    }\\n    \\n    function punkAttributeAsJSON(PunkAttributeValue attribute) internal view returns (string memory json) {\\n        require(attribute != PunkAttributeValue.NONE);\\n        \\n        string memory attributeAsString = attrEnumToStringMapping[attribute];\\n        string memory attributeTypeAsString;\\n        \\n        PunkAttributeType attrType = attrValueToTypeEnumMapping[attribute];\\n        \\n        if (attrType == PunkAttributeType.SEX) {\\n            attributeTypeAsString = \\\"Sex\\\";\\n        } else if (attrType == PunkAttributeType.HAIR) {\\n            attributeTypeAsString = \\\"Hair\\\";\\n        } else if (attrType == PunkAttributeType.EYES) {\\n            attributeTypeAsString = \\\"Eyes\\\";\\n        } else if (attrType == PunkAttributeType.BEARD) {\\n            attributeTypeAsString = \\\"Beard\\\";\\n        } else if (attrType == PunkAttributeType.EARS) {\\n            attributeTypeAsString = \\\"Ears\\\";\\n        } else if (attrType == PunkAttributeType.LIPS) {\\n            attributeTypeAsString = \\\"Lips\\\";\\n        } else if (attrType == PunkAttributeType.MOUTH) {\\n            attributeTypeAsString = \\\"Mouth\\\";\\n        } else if (attrType == PunkAttributeType.FACE) {\\n            attributeTypeAsString = \\\"Face\\\";\\n        } else if (attrType == PunkAttributeType.EMOTION) {\\n            attributeTypeAsString = \\\"Emotion\\\";\\n        } else if (attrType == PunkAttributeType.NECK) {\\n            attributeTypeAsString = \\\"Neck\\\";\\n        } else if (attrType == PunkAttributeType.NOSE) {\\n            attributeTypeAsString = \\\"Nose\\\";\\n        } else if (attrType == PunkAttributeType.CHEEKS) {\\n            attributeTypeAsString = \\\"Cheeks\\\";\\n        } else if (attrType == PunkAttributeType.TEETH) {\\n            attributeTypeAsString = \\\"Teeth\\\";\\n        }\\n        \\n        return string(abi.encodePacked('{\\\"trait_type\\\":\\\"', attributeTypeAsString, '\\\", \\\"value\\\":\\\"', attributeAsString, '\\\"}'));\\n    }\\n    \\n    function visibleHair(Punk memory punk) public view returns (bool) {\\n        HatType hat = punkHatType(punk);\\n\\n        if (visibleHairAttribute(punk)) { return true; }\\n        \\n        if (punk.hair == PunkAttributeValue.BEANIE && hat == HatType.BASEBALL) {\\n            return true;\\n        }\\n        \\n        bool tiaraBlocked = punk.eyes == PunkAttributeValue.REGULAR_SHADES ||\\n                            punk.eyes == PunkAttributeValue.CLASSIC_SHADES ||\\n                            punk.eyes == PunkAttributeValue.HORNED_RIM_GLASSES ||\\n                            punk.eyes == PunkAttributeValue.THREE_D_GLASSES ||\\n                            punk.eyes == PunkAttributeValue.EYE_PATCH ||\\n                            punk.eyes == PunkAttributeValue.EYE_MASK;\\n                             \\n        if (punk.hair == PunkAttributeValue.TIARA && (!tiaraBlocked || hatEyePixelGap(punk) == 2)) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    mapping(PunkAttributeValue => PunkAttributeType) public attrValueToTypeEnumMapping;\\n    \\n    function setAttrValueToTypeEnumMapping(uint8[][] memory attrValuesAndTypes) external onlyOwner {\\n        for (uint i; i < attrValuesAndTypes.length; i++) {\\n            PunkAttributeValue attrVal = PunkAttributeValue(attrValuesAndTypes[i][0]);\\n            PunkAttributeType attrType = PunkAttributeType(attrValuesAndTypes[i][1]);\\n            \\n            attrValueToTypeEnumMapping[attrVal] = attrType;\\n        }\\n    }\\n    \\n    mapping(string => PunkAttributeValue) public attrStringToEnumMapping;\\n    mapping(PunkAttributeValue => string) public attrEnumToStringMapping;\\n    \\n    function setAttrStringToEnumMapping(string[] memory attrStrs, PunkAttributeValue[] memory attrEnums) external onlyOwner {\\n        for (uint i; i < attrStrs.length; i++) {\\n            string memory attrString = attrStrs[i];\\n            PunkAttributeValue attrEnum = attrEnums[i];\\n            \\n            attrStringToEnumMapping[attrString] = attrEnum;\\n            attrEnumToStringMapping[attrEnum] = attrString;\\n        }\\n    }\\n    \\n    mapping(PunkAttributeValue => mapping(PunkAttributeValue => mapping(HatType => bool))) public hatAvailableBySexAndHair;\\n    \\n    function canWearHat(Punk memory punk, HatType hat) public view returns (bool) {\\n        return hatAvailableBySexAndHair[punk.hair][punk.sex][hat];\\n    }\\n    \\n    function setAvailableHats(PunkAttributeValue[] memory hairs, PunkAttributeValue[] memory sexes, HatType[] memory hats) external onlyOwner {\\n        for (uint i; i < hairs.length; i++) {\\n            PunkAttributeValue hair = hairs[i];\\n            PunkAttributeValue sex = sexes[i];\\n            HatType hat = hats[i];\\n            \\n            hatAvailableBySexAndHair[hair][sex][hat] = true;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/FashionHatPunksRenderer.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0 <0.9.0;\\npragma abicoder v2;\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"base64-sol/base64.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\nimport \\\"./FashionHatPunksData.sol\\\";\\n\\ninterface HatPunkData {\\n    struct Punk {\\n        uint16 id;\\n        uint16 seed;\\n        PunkAttributeValue sex;\\n        PunkAttributeValue hair;\\n        PunkAttributeValue eyes;\\n        PunkAttributeValue beard;\\n        PunkAttributeValue ears;\\n        PunkAttributeValue lips;\\n        PunkAttributeValue mouth;\\n        PunkAttributeValue face;\\n        PunkAttributeValue emotion;\\n        PunkAttributeValue neck;\\n        PunkAttributeValue nose;\\n        PunkAttributeValue cheeks;\\n        PunkAttributeValue teeth;\\n    }\\n    \\n    enum HatType { BASEBALL, BUCKET, COWBOY, VISOR }\\n    enum HatSize { REGULAR, SMALL }\\n    enum HatColor { BLACK, GREY, RED, WHITE, TAN, BROWN }\\n    enum HatPosition { REGULAR, FLIPPED }\\n    \\n    enum PunkAttributeType {SEX, HAIR, EYES, BEARD, EARS, LIPS, MOUTH,\\n                                FACE, EMOTION, NECK, NOSE, CHEEKS, TEETH}\\n                                \\n    enum PunkAttributeValue {NONE, ALIEN, APE, BANDANA, BEANIE, BIG_BEARD, BIG_SHADES, BLACK_LIPSTICK, BLONDE_BOB, BLONDE_SHORT, BLUE_EYE_SHADOW, BUCK_TEETH, CAP, CAP_FORWARD, CHINSTRAP, CHOKER, CIGARETTE, CLASSIC_SHADES, CLOWN_EYES_BLUE, CLOWN_EYES_GREEN, CLOWN_HAIR_GREEN, CLOWN_NOSE, COWBOY_HAT, CRAZY_HAIR, DARK_HAIR, DO_RAG, EARRING, EYE_MASK, EYE_PATCH, FEDORA, FEMALE, FRONT_BEARD, FRONT_BEARD_DARK, FROWN, FRUMPY_HAIR, GOAT, GOLD_CHAIN, GREEN_EYE_SHADOW, HALF_SHAVED, HANDLEBARS, HEADBAND, HOODIE, HORNED_RIM_GLASSES, HOT_LIPSTICK, KNITTED_CAP, LUXURIOUS_BEARD, MALE, MEDICAL_MASK, MESSY_HAIR, MOHAWK, MOHAWK_DARK, MOHAWK_THIN, MOLE, MUSTACHE, MUTTONCHOPS, NERD_GLASSES, NORMAL_BEARD, NORMAL_BEARD_BLACK, ORANGE_SIDE, PEAK_SPIKE, PIGTAILS, PILOT_HELMET, PINK_WITH_HAT, PIPE, POLICE_CAP, PURPLE_EYE_SHADOW, PURPLE_HAIR, PURPLE_LIPSTICK, RED_MOHAWK, REGULAR_SHADES, ROSY_CHEEKS, SHADOW_BEARD, SHAVED_HEAD, SILVER_CHAIN, SMALL_SHADES, SMILE, SPOTS, STRAIGHT_HAIR, STRAIGHT_HAIR_BLONDE, STRAIGHT_HAIR_DARK, STRINGY_HAIR, TASSLE_HAT, THREE_D_GLASSES, TIARA, TOP_HAT, VAMPIRE_HAIR, VAPE, VR, WELDING_GOGGLES, WILD_BLONDE, WILD_HAIR, WILD_WHITE_HAIR, ZOMBIE}\\n    \\n    function punkHatType(Punk memory punk) external view returns (HatType);\\n    function punkHatSize(Punk memory punk) external view returns (HatSize);\\n    function punkHatColor(Punk memory punk) external view returns (HatColor);\\n    function punkHatPosition(Punk memory punk) external view returns (HatPosition);\\n    \\n    function hatEyePixelGap(Punk memory punk) external view returns (uint8);\\n    \\n    function initializePunk(uint16 punkId, uint16 punkSeed) external view returns (Punk memory);\\n    \\n    function punkAttributesAsJSON(uint16 punkId, uint16 punkSeed) external view returns (string memory);\\n}\\n\\ncontract FashionHatPunksRenderer is Ownable {\\n    using Strings for uint32;\\n    using Strings for uint16;\\n    using Strings for uint8;\\n    using Strings for uint256;\\n    \\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    \\n    PunkDataInterface immutable punkDataContract;\\n    HatPunkData immutable hatDataContract;\\n    \\n    mapping(HatPunkData.HatType =>\\n            mapping(HatPunkData.HatSize =>\\n            mapping(HatPunkData.HatColor => bytes))) public hatImages;\\n            \\n    function setHatImages(HatPunkData.HatType[] memory hatTypes,\\n                           HatPunkData.HatSize[] memory hatSizes,\\n                           HatPunkData.HatColor[] memory hatColors,\\n                           bytes[] memory hatImagesAry) external onlyOwner {\\n\\n        for (uint i; i < hatTypes.length; i++) {\\n            HatPunkData.HatType hat = hatTypes[i];\\n            HatPunkData.HatSize size = hatSizes[i];\\n            HatPunkData.HatColor color = hatColors[i];\\n            \\n            hatImages[hat][size][color] = hatImagesAry[i];\\n        }\\n    }\\n    \\n    mapping(HatPunkData.PunkAttributeValue => bytes) public nonhatImages;\\n    \\n    function setNonhatImages(HatPunkData.PunkAttributeValue[] memory attributeValues, bytes[] memory imageData) external onlyOwner {\\n        for (uint8 i = 0; i < attributeValues.length; i++) {\\n            nonhatImages[attributeValues[i]] = imageData[i];\\n        }\\n    }\\n    \\n    constructor(address fashionHatPunkDataAddress, address punkDataContractAddress) {\\n      punkDataContract = PunkDataInterface(punkDataContractAddress);\\n      hatDataContract = HatPunkData(fashionHatPunkDataAddress);\\n    }\\n    \\n    function bytesToSvgRects(bytes memory pixelBytes) public pure returns (string memory rects) {\\n        uint len = pixelBytes.length;\\n        \\n        for (uint i; i < len; ++i) {\\n            uint8 colorClassInt = uint8(pixelBytes[i]);\\n            \\n            if (colorClassInt > 0) {\\n                uint x = i % 24;\\n                uint y = i / 24;\\n                \\n                rects = string(abi.encodePacked(rects, '<rect x=\\\"', x.toString(), '\\\" y=\\\"', y.toString(),'\\\" class=\\\"c', colorClassInt.toString(), '\\\"/>'));\\n            }\\n        }\\n    }\\n \\n    function hatOverlayPosition(HatPunkData.Punk memory punk) public view returns (int8 x, int8 y) {\\n        HatPunkData.HatType hat = hatDataContract.punkHatType(punk);\\n        HatPunkData.HatPosition position = hatDataContract.punkHatPosition(punk);\\n        int8 gap = int8(hatDataContract.hatEyePixelGap(punk));\\n        \\n        if (punk.sex != HatPunkData.PunkAttributeValue.FEMALE) {\\n            if (position == HatPunkData.HatPosition.FLIPPED) {\\n                x = -23;    \\n            }\\n            \\n            return (x, -(gap - 1));\\n        }\\n        \\n        if (hat == HatPunkData.HatType.BASEBALL) {\\n            if (position == HatPunkData.HatPosition.FLIPPED) {\\n                x = -23;\\n            } else if (\\n                punk.hair == HatPunkData.PunkAttributeValue.BLONDE_BOB ||\\n                punk.hair == HatPunkData.PunkAttributeValue.BLONDE_SHORT ||\\n                punk.hair == HatPunkData.PunkAttributeValue.STRAIGHT_HAIR_DARK ||\\n                punk.hair == HatPunkData.PunkAttributeValue.STRAIGHT_HAIR_BLONDE ||\\n                punk.hair == HatPunkData.PunkAttributeValue.STRAIGHT_HAIR ||\\n                punk.hair == HatPunkData.PunkAttributeValue.CRAZY_HAIR ||\\n                punk.hair == HatPunkData.PunkAttributeValue.TASSLE_HAT ||\\n                punk.hair == HatPunkData.PunkAttributeValue.FRUMPY_HAIR\\n            ) {\\n                x = 0;               \\n            } else {\\n                x = 1;\\n            }\\n        } else {\\n            if (hat == HatPunkData.HatType.VISOR) {\\n                punk.hair == HatPunkData.PunkAttributeValue.STRAIGHT_HAIR_BLONDE ? x = 0 : x = 1;\\n            } else {\\n                x = 0;\\n            }\\n        }\\n        \\n        return (x, -(gap - 2));\\n    }\\n    \\n    function intToString(int256 value) internal pure returns (string memory) {\\n        if (value >= 0) {\\n            return uint(value).toString();\\n        } else {\\n            return string(abi.encodePacked(\\\"-\\\", uint(-value).toString()));\\n        }\\n    }\\n    \\n    function nonHatSvgs(HatPunkData.Punk memory punk) public view returns (bytes memory svg) {\\n        HatPunkData.PunkAttributeValue female = HatPunkData.PunkAttributeValue.FEMALE;\\n        HatPunkData.PunkAttributeValue big_shades = HatPunkData.PunkAttributeValue.BIG_SHADES;\\n        HatPunkData.PunkAttributeValue vr = HatPunkData.PunkAttributeValue.VR;\\n        HatPunkData.PunkAttributeValue clown_nose = HatPunkData.PunkAttributeValue.CLOWN_NOSE;\\n        HatPunkData.PunkAttributeValue bandana = HatPunkData.PunkAttributeValue.BANDANA;\\n        HatPunkData.HatType hat = hatDataContract.punkHatType(punk);\\n        HatPunkData.HatType visor = HatPunkData.HatType.VISOR;\\n        HatPunkData.HatType baseball = HatPunkData.HatType.BASEBALL;\\n        HatPunkData.HatPosition position = hatDataContract.punkHatPosition(punk);\\n        \\n        uint y;\\n        \\n        if (punk.sex == female && punk.hair == bandana) {\\n            svg = abi.encodePacked(\\n                svg,\\n                '<g>',\\n                    bytesToSvgRects(nonhatImages[bandana]),\\n                '</g>'\\n            );\\n        }\\n        \\n        if (punk.eyes == big_shades) {\\n            y = punk.sex == female ? 2 : 0;\\n            \\n            svg = abi.encodePacked(\\n                svg,\\n                '<g transform=\\\"translate(0,', y.toString(), ')\\\">',\\n                    bytesToSvgRects(nonhatImages[big_shades]),\\n                '</g>'\\n            );\\n        } else if (punk.eyes == vr) {\\n            y = punk.sex == female ? 2 : 0;\\n            \\n            if (hat != visor && !(hat == baseball && position == HatPunkData.HatPosition.REGULAR)) {\\n                svg = abi.encodePacked(\\n                    svg,\\n                    '<g transform=\\\"translate(0,', y.toString(), ')\\\">',\\n                        bytesToSvgRects(nonhatImages[vr]),\\n                    '</g>'\\n                );\\n            }\\n\\n            if (punk.nose == clown_nose) {\\n                y = punk.sex == female ? 1 : 0;\\n                \\n                svg = abi.encodePacked(\\n                    svg,\\n                    '<g transform=\\\"translate(0,', y.toString(), ')\\\">',\\n                        bytesToSvgRects(nonhatImages[clown_nose]),\\n                    '</g>'\\n                );\\n            }\\n        }\\n    }\\n    \\n    function getHatSvg(HatPunkData.Punk memory punk) public view returns (bytes memory) {\\n        HatPunkData.HatType hat = hatDataContract.punkHatType(punk);\\n        HatPunkData.HatSize size = hatDataContract.punkHatSize(punk);\\n        HatPunkData.HatColor color = hatDataContract.punkHatColor(punk);\\n        HatPunkData.HatPosition position = hatDataContract.punkHatPosition(punk);\\n        \\n        (int8 x, int8 y) = hatOverlayPosition(punk);\\n        \\n        bytes memory transform = 'transform=\\\"';\\n        \\n        if (position == HatPunkData.HatPosition.FLIPPED) {\\n            transform = abi.encodePacked(transform, 'scale(-1, 1) ');\\n        }\\n        \\n        transform = abi.encodePacked(\\n            transform,\\n            'translate(', intToString(x), ',', intToString(y), ')\\\"'\\n        );\\n        \\n        return abi.encodePacked(\\n            '<g ', transform, ' >',\\n                bytesToSvgRects(hatImages[hat][size][color]),\\n            '</g>'\\n        );\\n    }\\n    \\n    function getSpecialMaskCoords(HatPunkData.Punk memory punk) public view returns (uint8 x, uint8 y) {\\n        HatPunkData.HatType hat = hatDataContract.punkHatType(punk);\\n        \\n        if (punk.sex == HatPunkData.PunkAttributeValue.FEMALE &&\\n            punk.hair == HatPunkData.PunkAttributeValue.HEADBAND\\n        ) {\\n            return (5, 11);\\n        }\\n        \\n        if (punk.sex != HatPunkData.PunkAttributeValue.FEMALE &&\\n            punk.hair == HatPunkData.PunkAttributeValue.WILD_HAIR &&\\n            hat == HatPunkData.HatType.BASEBALL\\n        ) {\\n            return (2, 9);\\n        }\\n    }\\n    \\n    function getRegularMaskCoords(HatPunkData.Punk memory punk) public view returns (uint8 x, uint8 y) {\\n        HatPunkData.HatType hat = hatDataContract.punkHatType(punk);\\n        uint8 gap = hatDataContract.hatEyePixelGap(punk);\\n        \\n        if (hat == HatPunkData.HatType.VISOR) {\\n            return (0, 0);\\n        }\\n        \\n        if (punk.hair == HatPunkData.PunkAttributeValue.BANDANA &&\\n            punk.sex != HatPunkData.PunkAttributeValue.FEMALE\\n        ) {\\n            return (0, 7);\\n        }\\n        \\n        if (punk.sex != HatPunkData.PunkAttributeValue.FEMALE) {\\n            y++;\\n            \\n            if (hat == HatPunkData.HatType.BASEBALL) {\\n                if (\\n                    punk.hair == HatPunkData.PunkAttributeValue.CLOWN_HAIR_GREEN ||\\n                    punk.hair == HatPunkData.PunkAttributeValue.BEANIE ||\\n                    punk.hair == HatPunkData.PunkAttributeValue.HOODIE\\n                ) {\\n                    return (0, 0);\\n                }\\n            }\\n        }\\n        \\n        y += gap + 12;\\n        \\n        return (x, (23 - y));\\n    }\\n    \\n    function toHexStringNoPrefix(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length);\\n        for (uint256 i = buffer.length; i > 0; i--) {\\n            buffer[i - 1] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        return string(buffer);\\n    }\\n    \\n    function punkImageSvg(uint16 punkId, uint16 punkSeed, uint32 backgroundColor, bool phunkify) external view returns (string memory) {\\n        HatPunkData.Punk memory punk = hatDataContract.initializePunk(punkId, punkSeed);\\n        \\n        bytes memory pixels = punkDataContract.punkImage(punk.id);\\n        \\n        string memory punkRects;\\n    \\n        string memory containerOpener = phunkify ? '<g transform=\\\"scale(-1,1) translate(-24,0)\\\">' : '<g>';\\n        \\n        (uint maskX, uint maskY) = getRegularMaskCoords(punk);\\n        (uint spMaskX, uint spMaskY) = getSpecialMaskCoords(punk);\\n        \\n        bytes memory buffer = new bytes(8);\\n        for (uint256 y = 0; y < 24; y++) {\\n            for (uint256 x = 0; x < 24; x++) {\\n                uint256 p = (y * 24 + x) * 4;\\n                \\n                bool pointIsMasked = y <= maskY || x <= maskX;\\n                \\n                if (x == spMaskX && y == spMaskY) {\\n                    pointIsMasked = true;\\n                }\\n                \\n                if (punk.sex == HatPunkData.PunkAttributeValue.FEMALE &&\\n                    punk.mouth == HatPunkData.PunkAttributeValue.CIGARETTE &&\\n                    x == 19 && y == 10\\n                ) {\\n                    pointIsMasked = false;\\n                }\\n                \\n                if (uint8(pixels[p + 3]) > 0 && !pointIsMasked) {\\n                    for (uint256 i = 0; i < 4; i++) {\\n                        uint8 value = uint8(pixels[p + i]);\\n                        buffer[i * 2 + 1] = _HEX_SYMBOLS[value & 0xf];\\n                        value >>= 4;\\n                        buffer[i * 2] = _HEX_SYMBOLS[value & 0xf];\\n                    }\\n                    punkRects = string(\\n                        abi.encodePacked(\\n                            punkRects,\\n    '<rect x=\\\"', x.toString(),'\\\" y=\\\"', y.toString(), '\\\" fill=\\\"#', string(buffer), '\\\"/>'\\n                        )\\n                    );\\n                }\\n            }\\n        }\\n        \\n        bytes memory almostFinalSVG = abi.encodePacked(\\n            '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" shape-rendering=\\\"crispEdges\\\" version=\\\"1.2\\\" viewBox=\\\"0 0 24 24\\\">',\\n                '<style>rect{width:1px;height:1px}.c1{fill:#000000}.c2{fill:#074b3e}.c3{fill:#085949}.c4{fill:#09614f}.c5{fill:#0a6a56}.c6{fill:#142c7c}.c7{fill:#1637a4}.c8{fill:#181818}.c9{fill:#1a43c8}.c10{fill:#222222}.c11{fill:#282828}.c12{fill:#333333}.c13{fill:#3c3c3c}.c14{fill:#44585c}.c15{fill:#4f3623}.c16{fill:#4f666b}.c17{fill:#505050}.c18{fill:#593d28}.c19{fill:#5e402a}.c20{fill:#67462e}.c21{fill:#690c45}.c22{fill:#697984}.c23{fill:#6b7c87}.c24{fill:#7c909c}.c25{fill:#8c0d5b}.c26{fill:#8d8d8d}.c27{fill:#8e240e}.c28{fill:#8f0000}.c29{fill:#908274}.c30{fill:#9a2710}.c31{fill:#9d0000}.c32{fill:#a82b11}.c33{fill:#aa0000}.c34{fill:#aa9a8a}.c35{fill:#ab9b8b}.c36{fill:#ad2160}.c37{fill:#b1a59a}.c38{fill:#b1b1b1}.c39{fill:#b4b4b4}.c40{fill:#b5a99f}.c41{fill:#ba0000}.c42{fill:#bfb2a6}.c43{fill:#cacaca}.c44{fill:#d2d2d2}.c45{fill:#d60000}.c46{fill:#d6c8bb}.c47{fill:#d7c9bc}.c48{fill:#f0f0f0}.c49{fill:#fafafa}</style>',\\n                containerOpener,\\n                    '<rect x=\\\"0\\\" y=\\\"0\\\" style=\\\"width:100%;height:100%\\\" fill=\\\"#', toHexStringNoPrefix(backgroundColor, 4), '\\\"/>',\\n                    punkRects,\\n                    getHatSvg(punk),\\n                    nonHatSvgs(punk),\\n                '</g>',\\n            \\\"</svg>\\\"\\n        );\\n        \\n        // So it will look okay in Safari!\\n        return string(abi.encodePacked(\\n            '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" shape-rendering=\\\"crispEdges\\\" version=\\\"1.2\\\" viewBox=\\\"0 0 3072 3072\\\"><image x=\\\"0\\\" y=\\\"0\\\" width=\\\"100%\\\" height=\\\"100%\\\" image-rendering=\\\"pixelated\\\" href=\\\"data:image/svg+xml;base64,',\\n            Base64.encode(almostFinalSVG),\\n            '\\\" /></svg>'\\n        ));\\n    }\\n}\"\r\n    },\r\n    \"contracts/StringUtilsLib.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n/**\\n * Strings Library\\n * \\n * In summary this is a simple library of string functions which make simple \\n * string operations less tedious in solidity.\\n * \\n * Please be aware these functions can be quite gas heavy so use them only when\\n * necessary not to clog the blockchain with expensive transactions.\\n * \\n * @author James Lockhart <james@n3tw0rk.co.uk>\\n */\\nlibrary StringUtils {\\n\\n    /**\\n     * Concat (High gas cost)\\n     * \\n     * Appends two strings together and returns a new value\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string which will be the concatenated\\n     *              prefix\\n     * @param _value The value to be the concatenated suffix\\n     * @return string The resulting string from combinging the base and value\\n     */\\n    function concat(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (string memory) {\\n        bytes memory _baseBytes = bytes(_base);\\n        bytes memory _valueBytes = bytes(_value);\\n\\n        assert(_valueBytes.length > 0);\\n\\n        string memory _tmpValue = new string(_baseBytes.length +\\n            _valueBytes.length);\\n        bytes memory _newValue = bytes(_tmpValue);\\n\\n        uint i;\\n        uint j;\\n\\n        for (i = 0; i < _baseBytes.length; i++) {\\n            _newValue[j++] = _baseBytes[i];\\n        }\\n\\n        for (i = 0; i < _valueBytes.length; i++) {\\n            _newValue[j++] = _valueBytes[i];\\n        }\\n\\n        return string(_newValue);\\n    }\\n\\n    /**\\n     * Index Of\\n     *\\n     * Locates and returns the position of a character within a string\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string acting as the haystack to be\\n     *              searched\\n     * @param _value The needle to search for, at present this is currently\\n     *               limited to one character\\n     * @return int The position of the needle starting from 0 and returning -1\\n     *             in the case of no matches found\\n     */\\n    function indexOf(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (int) {\\n        return _indexOf(_base, _value, 0);\\n    }\\n\\n    /**\\n     * Index Of\\n     *\\n     * Locates and returns the position of a character within a string starting\\n     * from a defined offset\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string acting as the haystack to be\\n     *              searched\\n     * @param _value The needle to search for, at present this is currently\\n     *               limited to one character\\n     * @param _offset The starting point to start searching from which can start\\n     *                from 0, but must not exceed the length of the string\\n     * @return int The position of the needle starting from 0 and returning -1\\n     *             in the case of no matches found\\n     */\\n    function _indexOf(string memory _base, string memory _value, uint _offset)\\n        internal\\n        pure\\n        returns (int) {\\n        bytes memory _baseBytes = bytes(_base);\\n        bytes memory _valueBytes = bytes(_value);\\n\\n        assert(_valueBytes.length == 1);\\n\\n        for (uint i = _offset; i < _baseBytes.length; i++) {\\n            if (_baseBytes[i] == _valueBytes[0]) {\\n                return int(i);\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    /**\\n     * Length\\n     * \\n     * Returns the length of the specified string\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string to be measured\\n     * @return uint The length of the passed string\\n     */\\n    function length(string memory _base)\\n        internal\\n        pure\\n        returns (uint) {\\n        bytes memory _baseBytes = bytes(_base);\\n        return _baseBytes.length;\\n    }\\n\\n    /**\\n     * Sub String\\n     * \\n     * Extracts the beginning part of a string based on the desired length\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string that will be used for \\n     *              extracting the sub string from\\n     * @param _length The length of the sub string to be extracted from the base\\n     * @return string The extracted sub string\\n     */\\n    function substring(string memory _base, int _length)\\n        internal\\n        pure\\n        returns (string memory) {\\n        return _substring(_base, _length, 0);\\n    }\\n\\n    /**\\n     * Sub String\\n     * \\n     * Extracts the part of a string based on the desired length and offset. The\\n     * offset and length must not exceed the lenth of the base string.\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string that will be used for \\n     *              extracting the sub string from\\n     * @param _length The length of the sub string to be extracted from the base\\n     * @param _offset The starting point to extract the sub string from\\n     * @return string The extracted sub string\\n     */\\n    function _substring(string memory _base, int _length, int _offset)\\n        internal\\n        pure\\n        returns (string memory) {\\n        bytes memory _baseBytes = bytes(_base);\\n\\n        assert(uint(_offset + _length) <= _baseBytes.length);\\n\\n        string memory _tmp = new string(uint(_length));\\n        bytes memory _tmpBytes = bytes(_tmp);\\n\\n        uint j = 0;\\n        for (uint i = uint(_offset); i < uint(_offset + _length); i++) {\\n            _tmpBytes[j++] = _baseBytes[i];\\n        }\\n\\n        return string(_tmpBytes);\\n    }\\n\\n\\n    function split(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (string[] memory splitArr) {\\n        bytes memory _baseBytes = bytes(_base);\\n\\n        uint _offset = 0;\\n        uint _splitsCount = 1;\\n        while (_offset < _baseBytes.length - 1) {\\n            int _limit = _indexOf(_base, _value, _offset);\\n            if (_limit == -1)\\n                break;\\n            else {\\n                _splitsCount++;\\n                _offset = uint(_limit) + 1;\\n            }\\n        }\\n\\n        splitArr = new string[](_splitsCount);\\n\\n        _offset = 0;\\n        _splitsCount = 0;\\n        while (_offset < _baseBytes.length - 1) {\\n\\n            int _limit = _indexOf(_base, _value, _offset);\\n            if (_limit == - 1) {\\n                _limit = int(_baseBytes.length);\\n            }\\n\\n            string memory _tmp = new string(uint(_limit) - _offset);\\n            bytes memory _tmpBytes = bytes(_tmp);\\n\\n            uint j = 0;\\n            for (uint i = _offset; i < uint(_limit); i++) {\\n                _tmpBytes[j++] = _baseBytes[i];\\n            }\\n            _offset = uint(_limit) + 1;\\n            splitArr[_splitsCount++] = string(_tmpBytes);\\n        }\\n        return splitArr;\\n    }\\n\\n    /**\\n     * Compare To\\n     * \\n     * Compares the characters of two strings, to ensure that they have an \\n     * identical footprint\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *               otherwise this is the string base to compare against\\n     * @param _value The string the base is being compared to\\n     * @return bool Simply notates if the two string have an equivalent\\n     */\\n    function compareTo(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (bool) {\\n        bytes memory _baseBytes = bytes(_base);\\n        bytes memory _valueBytes = bytes(_value);\\n\\n        if (_baseBytes.length != _valueBytes.length) {\\n            return false;\\n        }\\n\\n        for (uint i = 0; i < _baseBytes.length; i++) {\\n            if (_baseBytes[i] != _valueBytes[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * Compare To Ignore Case (High gas cost)\\n     * \\n     * Compares the characters of two strings, converting them to the same case\\n     * where applicable to alphabetic characters to distinguish if the values\\n     * match.\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *               otherwise this is the string base to compare against\\n     * @param _value The string the base is being compared to\\n     * @return bool Simply notates if the two string have an equivalent value\\n     *              discarding case\\n     */\\n    function compareToIgnoreCase(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (bool) {\\n        bytes memory _baseBytes = bytes(_base);\\n        bytes memory _valueBytes = bytes(_value);\\n\\n        if (_baseBytes.length != _valueBytes.length) {\\n            return false;\\n        }\\n\\n        for (uint i = 0; i < _baseBytes.length; i++) {\\n            if (_baseBytes[i] != _valueBytes[i] &&\\n            _upper(_baseBytes[i]) != _upper(_valueBytes[i])) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * Upper\\n     * \\n     * Converts all the values of a string to their corresponding upper case\\n     * value.\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string base to convert to upper case\\n     * @return string \\n     */\\n    function upper(string memory _base)\\n        internal\\n        pure\\n        returns (string memory) {\\n        bytes memory _baseBytes = bytes(_base);\\n        for (uint i = 0; i < _baseBytes.length; i++) {\\n            _baseBytes[i] = _upper(_baseBytes[i]);\\n        }\\n        return string(_baseBytes);\\n    }\\n\\n    /**\\n     * Lower\\n     * \\n     * Converts all the values of a string to their corresponding lower case\\n     * value.\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string base to convert to lower case\\n     * @return string \\n     */\\n    function lower(string memory _base)\\n        internal\\n        pure\\n        returns (string memory) {\\n        bytes memory _baseBytes = bytes(_base);\\n        for (uint i = 0; i < _baseBytes.length; i++) {\\n            _baseBytes[i] = _lower(_baseBytes[i]);\\n        }\\n        return string(_baseBytes);\\n    }\\n\\n    /**\\n     * Upper\\n     * \\n     * Convert an alphabetic character to upper case and return the original\\n     * value when not alphabetic\\n     * \\n     * @param _b1 The byte to be converted to upper case\\n     * @return bytes1 The converted value if the passed value was alphabetic\\n     *                and in a lower case otherwise returns the original value\\n     */\\n    function _upper(bytes1 _b1)\\n        private\\n        pure\\n        returns (bytes1) {\\n\\n        if (_b1 >= 0x61 && _b1 <= 0x7A) {\\n            return bytes1(uint8(_b1) - 32);\\n        }\\n\\n        return _b1;\\n    }\\n\\n    /**\\n     * Lower\\n     * \\n     * Convert an alphabetic character to lower case and return the original\\n     * value when not alphabetic\\n     * \\n     * @param _b1 The byte to be converted to lower case\\n     * @return bytes1 The converted value if the passed value was alphabetic\\n     *                and in a upper case otherwise returns the original value\\n     */\\n    function _lower(bytes1 _b1)\\n        private\\n        pure\\n        returns (bytes1) {\\n\\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\\n            return bytes1(uint8(_b1) + 32);\\n        }\\n\\n        return _b1;\\n    }\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fashionHatPunkDataAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"punkDataContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"pixelBytes\",\"type\":\"bytes\"}],\"name\":\"bytesToSvgRects\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"rects\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct HatPunkData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"}],\"name\":\"getHatSvg\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct HatPunkData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"}],\"name\":\"getRegularMaskCoords\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"x\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"y\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct HatPunkData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"}],\"name\":\"getSpecialMaskCoords\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"x\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"y\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum HatPunkData.HatType\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.HatSize\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.HatColor\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"hatImages\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct HatPunkData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"}],\"name\":\"hatOverlayPosition\",\"outputs\":[{\"internalType\":\"int8\",\"name\":\"x\",\"type\":\"int8\"},{\"internalType\":\"int8\",\"name\":\"y\",\"type\":\"int8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct HatPunkData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"}],\"name\":\"nonHatSvgs\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum HatPunkData.PunkAttributeValue\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"nonhatImages\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"punkSeed\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"backgroundColor\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"phunkify\",\"type\":\"bool\"}],\"name\":\"punkImageSvg\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum HatPunkData.HatType[]\",\"name\":\"hatTypes\",\"type\":\"uint8[]\"},{\"internalType\":\"enum HatPunkData.HatSize[]\",\"name\":\"hatSizes\",\"type\":\"uint8[]\"},{\"internalType\":\"enum HatPunkData.HatColor[]\",\"name\":\"hatColors\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes[]\",\"name\":\"hatImagesAry\",\"type\":\"bytes[]\"}],\"name\":\"setHatImages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum HatPunkData.PunkAttributeValue[]\",\"name\":\"attributeValues\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes[]\",\"name\":\"imageData\",\"type\":\"bytes[]\"}],\"name\":\"setNonhatImages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FashionHatPunksRenderer", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000f03e345bb89dc9cfaf8fda381a9e4417bfb46e7a00000000000000000000000016f5a35647d6f03d5d3da7b35409d65ba03af3b2", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}