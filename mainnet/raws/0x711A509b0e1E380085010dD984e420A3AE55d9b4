{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.8.7;\r\n\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IUtilityERC20 is IERC20 {\r\n    function adminMint(address owner, uint amountWei) external;\r\n\r\n    function adminSetTokenTimestamp(uint tokenId, uint timestamp) external;\r\n\r\n    function burn(address owner, uint amountWei) external;\r\n\r\n    function claimRewards() external;\r\n\r\n    function stake(uint[] calldata tokenId) external;\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\r\n/**\r\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\r\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155MetadataURI is IERC1155 {\r\n    /**\r\n     * @dev Returns the URI for token type `id`.\r\n     *\r\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\r\n     * clients with the actual token type ID.\r\n     */\r\n    function uri(uint256 id) external view returns (string memory);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/ERC1155.sol)\r\n/**\r\n * @dev Implementation of the basic standard multi-token.\r\n * See https://eips.ethereum.org/EIPS/eip-1155\r\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\r\n *\r\n * _Available since v3.1._\r\n */\r\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\r\n    using Address for address;\r\n\r\n    // Mapping from token ID to account balances\r\n    mapping(uint256 => mapping(address => uint256)) private _balances;\r\n\r\n    // Mapping from account to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\r\n    string private _uri;\r\n\r\n    /**\r\n     * @dev See {_setURI}.\r\n     */\r\n    constructor(string memory uri_) {\r\n        _setURI(uri_);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC1155).interfaceId ||\r\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155MetadataURI-uri}.\r\n     *\r\n     * This implementation returns the same URI for *all* token types. It relies\r\n     * on the token type ID substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * Clients calling this function must replace the `\\{id\\}` substring with the\r\n     * actual token type ID.\r\n     */\r\n    function uri(uint256) public view virtual override returns (string memory) {\r\n        return _uri;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\r\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\r\n        return _balances[id][account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOfBatch}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _setApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n        _safeTransferFrom(from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeBatchTransferFrom}.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: transfer caller is not owner nor approved\"\r\n        );\r\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n        _balances[id][to] += amount;\r\n\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n            _balances[id][to] += amount;\r\n        }\r\n\r\n        emit TransferBatch(operator, from, to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new URI for all token types, by relying on the token type ID\r\n     * substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\r\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\r\n     * clients with the token type ID.\r\n     *\r\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\r\n     * interpreted by clients as\r\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\r\n     * for token type ID 0x4cce0.\r\n     *\r\n     * See {uri}.\r\n     *\r\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\r\n     * this function emits no events.\r\n     */\r\n    function _setURI(string memory newuri) internal virtual {\r\n        _uri = newuri;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n\r\n        _balances[id][to] += amount;\r\n        emit TransferSingle(operator, address(0), to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _mintBatch(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            _balances[ids[i]][to] += amounts[i];\r\n        }\r\n\r\n        emit TransferBatch(operator, address(0), to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens of token type `id` from `from`\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `from` must have at least `amount` tokens of token type `id`.\r\n     */\r\n    function _burn(\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC1155: burn from the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n\r\n        emit TransferSingle(operator, from, address(0), id, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     */\r\n    function _burnBatch(\r\n        address from,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC1155: burn from the zero address\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(operator, from, address(0), ids, amounts);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `operator` to operate on all of `owner` tokens\r\n     *\r\n     * Emits a {ApprovalForAll} event.\r\n     */\r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) internal virtual {\r\n        require(owner != operator, \"ERC1155: setting approval status for self\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning, as well as batched variants.\r\n     *\r\n     * The same hook is called on both single and batched variants. For single\r\n     * transfers, the length of the `id` and `amount` arrays will be 1.\r\n     *\r\n     * Calling conditions (for each `id` and `amount` pair):\r\n     *\r\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * of token type `id` will be  transferred to `to`.\r\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\r\n     * for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\r\n     * will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     * - `ids` and `amounts` have the same, non-zero length.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\r\n                bytes4 response\r\n            ) {\r\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\r\n        uint256[] memory array = new uint256[](1);\r\n        array[0] = element;\r\n\r\n        return array;\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Supply.sol)\r\n/**\r\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\r\n *\r\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\r\n * clearly identified. Note: While a totalSupply of 1 might mean the\r\n * corresponding is an NFT, there is no guarantees that no other token with the\r\n * same id are not going to be minted.\r\n */\r\nabstract contract ERC1155Supply is ERC1155 {\r\n    mapping(uint256 => uint256) private _totalSupply;\r\n\r\n    /**\r\n     * @dev Total amount of tokens in with a given id.\r\n     */\r\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\r\n        return _totalSupply[id];\r\n    }\r\n\r\n    /**\r\n     * @dev Indicates whether any token exist with a given id, or not.\r\n     */\r\n    function exists(uint256 id) public view virtual returns (bool) {\r\n        return ERC1155Supply.totalSupply(id) > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC1155-_beforeTokenTransfer}.\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        if (from == address(0)) {\r\n            for (uint256 i = 0; i < ids.length; ++i) {\r\n                _totalSupply[ids[i]] += amounts[i];\r\n            }\r\n        }\r\n\r\n        if (to == address(0)) {\r\n            for (uint256 i = 0; i < ids.length; ++i) {\r\n                _totalSupply[ids[i]] -= amounts[i];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Enumerable is IERC721 {\r\n    /**\r\n     * @dev Returns the total amount of tokens stored by the contract.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n     * Use along with {totalSupply} to enumerate all tokens.\r\n     */\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n\r\ninterface IExtensibleERC721Enumerable is IERC721Enumerable {\r\n    function isAdmin(address addr) external view returns (bool);\r\n\r\n    function addAdmin(address addr) external;\r\n\r\n    function removeAdmin(address addr) external;\r\n\r\n    function canAccessToken(address addr, uint tokenId) external view returns (bool);\r\n\r\n    function adminBurn(uint tokenId) external;\r\n\r\n    function adminTransfer(address from, address to, uint tokenId) external;\r\n}\r\n\r\n\r\nenum Accessory {\r\n    GOLD_EARRINGS,\r\n    SCARS,\r\n    GOLDEN_CHAIN,\r\n    AMULET,\r\n    CUBAN_LINK_GOLD_CHAIN,\r\n    FANNY_PACK,\r\n    NONE\r\n}\r\n\r\nenum BackAccessory {\r\n    NETRUNNER,\r\n    MERCENARY,\r\n    RONIN,\r\n    ENCHANTER,\r\n    VANGUARD,\r\n    MINER,\r\n    PATHFINDER,\r\n    SCOUT\r\n}\r\n\r\nenum Background {\r\n    STARRY_PINK,\r\n    STARRY_YELLOW,\r\n    STARRY_PURPLE,\r\n    STARRY_GREEN,\r\n    NEBULA,\r\n    STARRY_RED,\r\n    STARRY_BLUE,\r\n    SUNSET,\r\n    MORNING,\r\n    INDIGO,\r\n    CITY__PURPLE,\r\n    CONTROL_ROOM,\r\n    LAB,\r\n    GREEN,\r\n    ORANGE,\r\n    PURPLE,\r\n    CITY__GREEN,\r\n    CITY__RED,\r\n    STATION,\r\n    BOUNTY,\r\n    BLUE_SKY,\r\n    RED_SKY,\r\n    GREEN_SKY\r\n}\r\n\r\nenum Clothing {\r\n    MARTIAL_SUIT,\r\n    AMETHYST_ARMOR,\r\n    SHIRT_AND_TIE,\r\n    THUNDERDOME_ARMOR,\r\n    FLEET_UNIFORM__BLUE,\r\n    BANANITE_SHIRT,\r\n    EXPLORER,\r\n    COSMIC_GHILLIE_SUIT__BLUE,\r\n    COSMIC_GHILLIE_SUIT__GOLD,\r\n    CYBER_JUMPSUIT,\r\n    ENCHANTER_ROBES,\r\n    HOODIE,\r\n    SPACESUIT,\r\n    MECHA_ARMOR,\r\n    LAB_COAT,\r\n    FLEET_UNIFORM__RED,\r\n    GOLD_ARMOR,\r\n    ENERGY_ARMOR__BLUE,\r\n    ENERGY_ARMOR__RED,\r\n    MISSION_SUIT__BLACK,\r\n    MISSION_SUIT__PURPLE,\r\n    COWBOY,\r\n    GLITCH_ARMOR,\r\n    NONE\r\n}\r\n\r\nenum Eyes {\r\n    SPACE_VISOR,\r\n    ADORABLE,\r\n    VETERAN,\r\n    SUNGLASSES,\r\n    WHITE_SUNGLASSES,\r\n    RED_EYES,\r\n    WINK,\r\n    CASUAL,\r\n    CLOSED,\r\n    DOWNCAST,\r\n    HAPPY,\r\n    BLUE_EYES,\r\n    HUD_GLASSES,\r\n    DARK_SUNGLASSES,\r\n    NIGHT_VISION_GOGGLES,\r\n    BIONIC,\r\n    HIVE_GOGGLES,\r\n    MATRIX_GLASSES,\r\n    GREEN_GLOW,\r\n    ORANGE_GLOW,\r\n    RED_GLOW,\r\n    PURPLE_GLOW,\r\n    BLUE_GLOW,\r\n    SKY_GLOW,\r\n    RED_LASER,\r\n    BLUE_LASER,\r\n    GOLDEN_SHADES,\r\n    HIPSTER_GLASSES,\r\n    PINCENEZ,\r\n    BLUE_SHADES,\r\n    BLIT_GLASSES,\r\n    NOUNS_GLASSES\r\n}\r\n\r\nenum Fur {\r\n    MAGENTA,\r\n    BLUE,\r\n    GREEN,\r\n    RED,\r\n    BLACK,\r\n    BROWN,\r\n    SILVER,\r\n    PURPLE,\r\n    PINK,\r\n    SEANCE,\r\n    TURQUOISE,\r\n    CRIMSON,\r\n    GREENYELLOW,\r\n    GOLD,\r\n    DIAMOND,\r\n    METALLIC\r\n}\r\n\r\nenum Head {\r\n    HALO,\r\n    ENERGY_FIELD,\r\n    BLUE_TOP_HAT,\r\n    RED_TOP_HAT,\r\n    ENERGY_CRYSTAL,\r\n    CROWN,\r\n    BANDANA,\r\n    BUCKET_HAT,\r\n    HOMBURG_HAT,\r\n    PROPELLER_HAT,\r\n    HEADBAND,\r\n    DORAG,\r\n    PURPLE_COWBOY_HAT,\r\n    SPACESUIT_HELMET,\r\n    PARTY_HAT,\r\n    CAP,\r\n    LEATHER_COWBOY_HAT,\r\n    CYBER_HELMET__BLUE,\r\n    CYBER_HELMET__RED,\r\n    SAMURAI_HAT,\r\n    NONE\r\n}\r\n\r\nenum Mouth {\r\n    SMIRK,\r\n    SURPRISED,\r\n    SMILE,\r\n    PIPE,\r\n    OPEN_SMILE,\r\n    NEUTRAL,\r\n    MASK,\r\n    TONGUE_OUT,\r\n    GOLD_GRILL,\r\n    DIAMOND_GRILL,\r\n    NAVY_RESPIRATOR,\r\n    RED_RESPIRATOR,\r\n    MAGENTA_RESPIRATOR,\r\n    GREEN_RESPIRATOR,\r\n    MEMPO,\r\n    VAPE,\r\n    PILOT_OXYGEN_MASK,\r\n    CIGAR,\r\n    BANANA,\r\n    CHROME_RESPIRATOR,\r\n    STOIC\r\n}\r\n\r\nlibrary Enums {\r\n    function toString(Accessory v) external pure returns (string memory) {\r\n        if (v == Accessory.GOLD_EARRINGS) {\r\n            return \"Gold Earrings\";\r\n        }\r\n\r\n        if (v == Accessory.SCARS) {\r\n            return \"Scars\";\r\n        }\r\n\r\n        if (v == Accessory.GOLDEN_CHAIN) {\r\n            return \"Golden Chain\";\r\n        }\r\n\r\n        if (v == Accessory.AMULET) {\r\n            return \"Amulet\";\r\n        }\r\n\r\n        if (v == Accessory.CUBAN_LINK_GOLD_CHAIN) {\r\n            return \"Cuban Link Gold Chain\";\r\n        }\r\n\r\n        if (v == Accessory.FANNY_PACK) {\r\n            return \"Fanny Pack\";\r\n        }\r\n\r\n        if (v == Accessory.NONE) {\r\n            return \"None\";\r\n        }\r\n        revert(\"invalid accessory\");\r\n    }\r\n\r\n    function toString(BackAccessory v) external pure returns (string memory) {\r\n        if (v == BackAccessory.NETRUNNER) {\r\n            return \"Netrunner\";\r\n        }\r\n\r\n        if (v == BackAccessory.MERCENARY) {\r\n            return \"Mercenary\";\r\n        }\r\n\r\n        if (v == BackAccessory.RONIN) {\r\n            return \"Ronin\";\r\n        }\r\n\r\n        if (v == BackAccessory.ENCHANTER) {\r\n            return \"Enchanter\";\r\n        }\r\n\r\n        if (v == BackAccessory.VANGUARD) {\r\n            return \"Vanguard\";\r\n        }\r\n\r\n        if (v == BackAccessory.MINER) {\r\n            return \"Miner\";\r\n        }\r\n\r\n        if (v == BackAccessory.PATHFINDER) {\r\n            return \"Pathfinder\";\r\n        }\r\n\r\n        if (v == BackAccessory.SCOUT) {\r\n            return \"Scout\";\r\n        }\r\n        revert(\"invalid back accessory\");\r\n    }\r\n\r\n    function toString(Background v) external pure returns (string memory) {\r\n        if (v == Background.STARRY_PINK) {\r\n            return \"Starry Pink\";\r\n        }\r\n\r\n        if (v == Background.STARRY_YELLOW) {\r\n            return \"Starry Yellow\";\r\n        }\r\n\r\n        if (v == Background.STARRY_PURPLE) {\r\n            return \"Starry Purple\";\r\n        }\r\n\r\n        if (v == Background.STARRY_GREEN) {\r\n            return \"Starry Green\";\r\n        }\r\n\r\n        if (v == Background.NEBULA) {\r\n            return \"Nebula\";\r\n        }\r\n\r\n        if (v == Background.STARRY_RED) {\r\n            return \"Starry Red\";\r\n        }\r\n\r\n        if (v == Background.STARRY_BLUE) {\r\n            return \"Starry Blue\";\r\n        }\r\n\r\n        if (v == Background.SUNSET) {\r\n            return \"Sunset\";\r\n        }\r\n\r\n        if (v == Background.MORNING) {\r\n            return \"Morning\";\r\n        }\r\n\r\n        if (v == Background.INDIGO) {\r\n            return \"Indigo\";\r\n        }\r\n\r\n        if (v == Background.CITY__PURPLE) {\r\n            return \"City - Purple\";\r\n        }\r\n\r\n        if (v == Background.CONTROL_ROOM) {\r\n            return \"Control Room\";\r\n        }\r\n\r\n        if (v == Background.LAB) {\r\n            return \"Lab\";\r\n        }\r\n\r\n        if (v == Background.GREEN) {\r\n            return \"Green\";\r\n        }\r\n\r\n        if (v == Background.ORANGE) {\r\n            return \"Orange\";\r\n        }\r\n\r\n        if (v == Background.PURPLE) {\r\n            return \"Purple\";\r\n        }\r\n\r\n        if (v == Background.CITY__GREEN) {\r\n            return \"City - Green\";\r\n        }\r\n\r\n        if (v == Background.CITY__RED) {\r\n            return \"City - Red\";\r\n        }\r\n\r\n        if (v == Background.STATION) {\r\n            return \"Station\";\r\n        }\r\n\r\n        if (v == Background.BOUNTY) {\r\n            return \"Bounty\";\r\n        }\r\n\r\n        if (v == Background.BLUE_SKY) {\r\n            return \"Blue Sky\";\r\n        }\r\n\r\n        if (v == Background.RED_SKY) {\r\n            return \"Red Sky\";\r\n        }\r\n\r\n        if (v == Background.GREEN_SKY) {\r\n            return \"Green Sky\";\r\n        }\r\n        revert(\"invalid background\");\r\n    }\r\n\r\n    function toString(Clothing v) external pure returns (string memory) {\r\n        if (v == Clothing.MARTIAL_SUIT) {\r\n            return \"Martial Suit\";\r\n        }\r\n\r\n        if (v == Clothing.AMETHYST_ARMOR) {\r\n            return \"Amethyst Armor\";\r\n        }\r\n\r\n        if (v == Clothing.SHIRT_AND_TIE) {\r\n            return \"Shirt and Tie\";\r\n        }\r\n\r\n        if (v == Clothing.THUNDERDOME_ARMOR) {\r\n            return \"Thunderdome Armor\";\r\n        }\r\n\r\n        if (v == Clothing.FLEET_UNIFORM__BLUE) {\r\n            return \"Fleet Uniform - Blue\";\r\n        }\r\n\r\n        if (v == Clothing.BANANITE_SHIRT) {\r\n            return \"Bananite Shirt\";\r\n        }\r\n\r\n        if (v == Clothing.EXPLORER) {\r\n            return \"Explorer\";\r\n        }\r\n\r\n        if (v == Clothing.COSMIC_GHILLIE_SUIT__BLUE) {\r\n            return \"Cosmic Ghillie Suit - Blue\";\r\n        }\r\n\r\n        if (v == Clothing.COSMIC_GHILLIE_SUIT__GOLD) {\r\n            return \"Cosmic Ghillie Suit - Gold\";\r\n        }\r\n\r\n        if (v == Clothing.CYBER_JUMPSUIT) {\r\n            return \"Cyber Jumpsuit\";\r\n        }\r\n\r\n        if (v == Clothing.ENCHANTER_ROBES) {\r\n            return \"Enchanter Robes\";\r\n        }\r\n\r\n        if (v == Clothing.HOODIE) {\r\n            return \"Hoodie\";\r\n        }\r\n\r\n        if (v == Clothing.SPACESUIT) {\r\n            return \"Spacesuit\";\r\n        }\r\n\r\n        if (v == Clothing.MECHA_ARMOR) {\r\n            return \"Mecha Armor\";\r\n        }\r\n\r\n        if (v == Clothing.LAB_COAT) {\r\n            return \"Lab Coat\";\r\n        }\r\n\r\n        if (v == Clothing.FLEET_UNIFORM__RED) {\r\n            return \"Fleet Uniform - Red\";\r\n        }\r\n\r\n        if (v == Clothing.GOLD_ARMOR) {\r\n            return \"Gold Armor\";\r\n        }\r\n\r\n        if (v == Clothing.ENERGY_ARMOR__BLUE) {\r\n            return \"Energy Armor - Blue\";\r\n        }\r\n\r\n        if (v == Clothing.ENERGY_ARMOR__RED) {\r\n            return \"Energy Armor - Red\";\r\n        }\r\n\r\n        if (v == Clothing.MISSION_SUIT__BLACK) {\r\n            return \"Mission Suit - Black\";\r\n        }\r\n\r\n        if (v == Clothing.MISSION_SUIT__PURPLE) {\r\n            return \"Mission Suit - Purple\";\r\n        }\r\n\r\n        if (v == Clothing.COWBOY) {\r\n            return \"Cowboy\";\r\n        }\r\n\r\n        if (v == Clothing.GLITCH_ARMOR) {\r\n            return \"Glitch Armor\";\r\n        }\r\n\r\n        if (v == Clothing.NONE) {\r\n            return \"None\";\r\n        }\r\n        revert(\"invalid clothing\");\r\n    }\r\n\r\n    function toString(Eyes v) external pure returns (string memory) {\r\n        if (v == Eyes.SPACE_VISOR) {\r\n            return \"Space Visor\";\r\n        }\r\n\r\n        if (v == Eyes.ADORABLE) {\r\n            return \"Adorable\";\r\n        }\r\n\r\n        if (v == Eyes.VETERAN) {\r\n            return \"Veteran\";\r\n        }\r\n\r\n        if (v == Eyes.SUNGLASSES) {\r\n            return \"Sunglasses\";\r\n        }\r\n\r\n        if (v == Eyes.WHITE_SUNGLASSES) {\r\n            return \"White Sunglasses\";\r\n        }\r\n\r\n        if (v == Eyes.RED_EYES) {\r\n            return \"Red Eyes\";\r\n        }\r\n\r\n        if (v == Eyes.WINK) {\r\n            return \"Wink\";\r\n        }\r\n\r\n        if (v == Eyes.CASUAL) {\r\n            return \"Casual\";\r\n        }\r\n\r\n        if (v == Eyes.CLOSED) {\r\n            return \"Closed\";\r\n        }\r\n\r\n        if (v == Eyes.DOWNCAST) {\r\n            return \"Downcast\";\r\n        }\r\n\r\n        if (v == Eyes.HAPPY) {\r\n            return \"Happy\";\r\n        }\r\n\r\n        if (v == Eyes.BLUE_EYES) {\r\n            return \"Blue Eyes\";\r\n        }\r\n\r\n        if (v == Eyes.HUD_GLASSES) {\r\n            return \"HUD Glasses\";\r\n        }\r\n\r\n        if (v == Eyes.DARK_SUNGLASSES) {\r\n            return \"Dark Sunglasses\";\r\n        }\r\n\r\n        if (v == Eyes.NIGHT_VISION_GOGGLES) {\r\n            return \"Night Vision Goggles\";\r\n        }\r\n\r\n        if (v == Eyes.BIONIC) {\r\n            return \"Bionic\";\r\n        }\r\n\r\n        if (v == Eyes.HIVE_GOGGLES) {\r\n            return \"Hive Goggles\";\r\n        }\r\n\r\n        if (v == Eyes.MATRIX_GLASSES) {\r\n            return \"Matrix Glasses\";\r\n        }\r\n\r\n        if (v == Eyes.GREEN_GLOW) {\r\n            return \"Green Glow\";\r\n        }\r\n\r\n        if (v == Eyes.ORANGE_GLOW) {\r\n            return \"Orange Glow\";\r\n        }\r\n\r\n        if (v == Eyes.RED_GLOW) {\r\n            return \"Red Glow\";\r\n        }\r\n\r\n        if (v == Eyes.PURPLE_GLOW) {\r\n            return \"Purple Glow\";\r\n        }\r\n\r\n        if (v == Eyes.BLUE_GLOW) {\r\n            return \"Blue Glow\";\r\n        }\r\n\r\n        if (v == Eyes.SKY_GLOW) {\r\n            return \"Sky Glow\";\r\n        }\r\n\r\n        if (v == Eyes.RED_LASER) {\r\n            return \"Red Laser\";\r\n        }\r\n\r\n        if (v == Eyes.BLUE_LASER) {\r\n            return \"Blue Laser\";\r\n        }\r\n\r\n        if (v == Eyes.GOLDEN_SHADES) {\r\n            return \"Golden Shades\";\r\n        }\r\n\r\n        if (v == Eyes.HIPSTER_GLASSES) {\r\n            return \"Hipster Glasses\";\r\n        }\r\n\r\n        if (v == Eyes.PINCENEZ) {\r\n            return \"Pince-nez\";\r\n        }\r\n\r\n        if (v == Eyes.BLUE_SHADES) {\r\n            return \"Blue Shades\";\r\n        }\r\n\r\n        if (v == Eyes.BLIT_GLASSES) {\r\n            return \"Blit GLasses\";\r\n        }\r\n\r\n        if (v == Eyes.NOUNS_GLASSES) {\r\n            return \"Nouns Glasses\";\r\n        }\r\n        revert(\"invalid eyes\");\r\n    }\r\n\r\n    function toString(Fur v) external pure returns (string memory) {\r\n        if (v == Fur.MAGENTA) {\r\n            return \"Magenta\";\r\n        }\r\n\r\n        if (v == Fur.BLUE) {\r\n            return \"Blue\";\r\n        }\r\n\r\n        if (v == Fur.GREEN) {\r\n            return \"Green\";\r\n        }\r\n\r\n        if (v == Fur.RED) {\r\n            return \"Red\";\r\n        }\r\n\r\n        if (v == Fur.BLACK) {\r\n            return \"Black\";\r\n        }\r\n\r\n        if (v == Fur.BROWN) {\r\n            return \"Brown\";\r\n        }\r\n\r\n        if (v == Fur.SILVER) {\r\n            return \"Silver\";\r\n        }\r\n\r\n        if (v == Fur.PURPLE) {\r\n            return \"Purple\";\r\n        }\r\n\r\n        if (v == Fur.PINK) {\r\n            return \"Pink\";\r\n        }\r\n\r\n        if (v == Fur.SEANCE) {\r\n            return \"Seance\";\r\n        }\r\n\r\n        if (v == Fur.TURQUOISE) {\r\n            return \"Turquoise\";\r\n        }\r\n\r\n        if (v == Fur.CRIMSON) {\r\n            return \"Crimson\";\r\n        }\r\n\r\n        if (v == Fur.GREENYELLOW) {\r\n            return \"Green-Yellow\";\r\n        }\r\n\r\n        if (v == Fur.GOLD) {\r\n            return \"Gold\";\r\n        }\r\n\r\n        if (v == Fur.DIAMOND) {\r\n            return \"Diamond\";\r\n        }\r\n\r\n        if (v == Fur.METALLIC) {\r\n            return \"Metallic\";\r\n        }\r\n        revert(\"invalid fur\");\r\n    }\r\n\r\n    function toString(Head v) external pure returns (string memory) {\r\n        if (v == Head.HALO) {\r\n            return \"Halo\";\r\n        }\r\n\r\n        if (v == Head.ENERGY_FIELD) {\r\n            return \"Energy Field\";\r\n        }\r\n\r\n        if (v == Head.BLUE_TOP_HAT) {\r\n            return \"Blue Top Hat\";\r\n        }\r\n\r\n        if (v == Head.RED_TOP_HAT) {\r\n            return \"Red Top Hat\";\r\n        }\r\n\r\n        if (v == Head.ENERGY_CRYSTAL) {\r\n            return \"Energy Crystal\";\r\n        }\r\n\r\n        if (v == Head.CROWN) {\r\n            return \"Crown\";\r\n        }\r\n\r\n        if (v == Head.BANDANA) {\r\n            return \"Bandana\";\r\n        }\r\n\r\n        if (v == Head.BUCKET_HAT) {\r\n            return \"Bucket Hat\";\r\n        }\r\n\r\n        if (v == Head.HOMBURG_HAT) {\r\n            return \"Homburg Hat\";\r\n        }\r\n\r\n        if (v == Head.PROPELLER_HAT) {\r\n            return \"Propeller Hat\";\r\n        }\r\n\r\n        if (v == Head.HEADBAND) {\r\n            return \"Headband\";\r\n        }\r\n\r\n        if (v == Head.DORAG) {\r\n            return \"Do-rag\";\r\n        }\r\n\r\n        if (v == Head.PURPLE_COWBOY_HAT) {\r\n            return \"Purple Cowboy Hat\";\r\n        }\r\n\r\n        if (v == Head.SPACESUIT_HELMET) {\r\n            return \"Spacesuit Helmet\";\r\n        }\r\n\r\n        if (v == Head.PARTY_HAT) {\r\n            return \"Party Hat\";\r\n        }\r\n\r\n        if (v == Head.CAP) {\r\n            return \"Cap\";\r\n        }\r\n\r\n        if (v == Head.LEATHER_COWBOY_HAT) {\r\n            return \"Leather Cowboy Hat\";\r\n        }\r\n\r\n        if (v == Head.CYBER_HELMET__BLUE) {\r\n            return \"Cyber Helmet - Blue\";\r\n        }\r\n\r\n        if (v == Head.CYBER_HELMET__RED) {\r\n            return \"Cyber Helmet - Red\";\r\n        }\r\n\r\n        if (v == Head.SAMURAI_HAT) {\r\n            return \"Samurai Hat\";\r\n        }\r\n\r\n        if (v == Head.NONE) {\r\n            return \"None\";\r\n        }\r\n        revert(\"invalid head\");\r\n    }\r\n\r\n    function toString(Mouth v) external pure returns (string memory) {\r\n        if (v == Mouth.SMIRK) {\r\n            return \"Smirk\";\r\n        }\r\n\r\n        if (v == Mouth.SURPRISED) {\r\n            return \"Surprised\";\r\n        }\r\n\r\n        if (v == Mouth.SMILE) {\r\n            return \"Smile\";\r\n        }\r\n\r\n        if (v == Mouth.PIPE) {\r\n            return \"Pipe\";\r\n        }\r\n\r\n        if (v == Mouth.OPEN_SMILE) {\r\n            return \"Open Smile\";\r\n        }\r\n\r\n        if (v == Mouth.NEUTRAL) {\r\n            return \"Neutral\";\r\n        }\r\n\r\n        if (v == Mouth.MASK) {\r\n            return \"Mask\";\r\n        }\r\n\r\n        if (v == Mouth.TONGUE_OUT) {\r\n            return \"Tongue Out\";\r\n        }\r\n\r\n        if (v == Mouth.GOLD_GRILL) {\r\n            return \"Gold Grill\";\r\n        }\r\n\r\n        if (v == Mouth.DIAMOND_GRILL) {\r\n            return \"Diamond Grill\";\r\n        }\r\n\r\n        if (v == Mouth.NAVY_RESPIRATOR) {\r\n            return \"Navy Respirator\";\r\n        }\r\n\r\n        if (v == Mouth.RED_RESPIRATOR) {\r\n            return \"Red Respirator\";\r\n        }\r\n\r\n        if (v == Mouth.MAGENTA_RESPIRATOR) {\r\n            return \"Magenta Respirator\";\r\n        }\r\n\r\n        if (v == Mouth.GREEN_RESPIRATOR) {\r\n            return \"Green Respirator\";\r\n        }\r\n\r\n        if (v == Mouth.MEMPO) {\r\n            return \"Mempo\";\r\n        }\r\n\r\n        if (v == Mouth.VAPE) {\r\n            return \"Vape\";\r\n        }\r\n\r\n        if (v == Mouth.PILOT_OXYGEN_MASK) {\r\n            return \"Pilot Oxygen Mask\";\r\n        }\r\n\r\n        if (v == Mouth.CIGAR) {\r\n            return \"Cigar\";\r\n        }\r\n\r\n        if (v == Mouth.BANANA) {\r\n            return \"Banana\";\r\n        }\r\n\r\n        if (v == Mouth.CHROME_RESPIRATOR) {\r\n            return \"Chrome Respirator\";\r\n        }\r\n\r\n        if (v == Mouth.STOIC) {\r\n            return \"Stoic\";\r\n        }\r\n        revert(\"invalid mouth\");\r\n    }\r\n}\r\n\r\n\r\nstruct KeyValuePair {\r\n    string key;\r\n    string value;\r\n}\r\n\r\nstruct ChainScoutMetadata {\r\n    Accessory accessory;\r\n    BackAccessory backaccessory;\r\n    Background background;\r\n    Clothing clothing;\r\n    Eyes eyes;\r\n    Fur fur;\r\n    Head head;\r\n    Mouth mouth;\r\n    uint24 attack;\r\n    uint24 defense;\r\n    uint24 luck;\r\n    uint24 speed;\r\n    uint24 strength;\r\n    uint24 intelligence;\r\n    uint16 level;\r\n}\r\n\r\n\r\ninterface IChainScouts is IExtensibleERC721Enumerable {\r\n    function adminCreateChainScout(\r\n        ChainScoutMetadata calldata tbd,\r\n        address owner\r\n    ) external;\r\n\r\n    function adminRemoveExtension(string calldata key) external;\r\n\r\n    function adminSetExtension(\r\n        string calldata key,\r\n        ChainScoutsExtension extension\r\n    ) external;\r\n\r\n    function adminSetChainScoutMetadata(\r\n        uint256 tokenId,\r\n        ChainScoutMetadata calldata tbd\r\n    ) external;\r\n\r\n    function getChainScoutMetadata(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (ChainScoutMetadata memory);\r\n}\r\n\r\n\r\nabstract contract ChainScoutsExtension {\r\n    IChainScouts internal chainScouts;\r\n    bool public enabled;\r\n\r\n    modifier canAccessToken(uint tokenId) {\r\n        require(chainScouts.canAccessToken(msg.sender, tokenId), \"ChainScoutsExtension: you don't own the token\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(chainScouts.isAdmin(msg.sender), \"ChainScoutsExtension: admins only\");\r\n        _;\r\n    }\r\n\r\n    modifier whenEnabled() {\r\n        require(enabled, \"ChainScoutsExtension: currently disabled\");\r\n        _;\r\n    }\r\n\r\n    function adminSetEnabled(bool e) external onlyAdmin {\r\n        enabled = e;\r\n    }\r\n\r\n    function extensionKey() public virtual view returns (string memory);\r\n\r\n    function setChainScouts(IChainScouts _contract) external {\r\n        require(address(0) == address(chainScouts) || chainScouts.isAdmin(msg.sender), \"ChainScoutsExtension: The Chain Scouts contract must not be set or you must be an admin\");\r\n        chainScouts = _contract;\r\n        chainScouts.adminSetExtension(extensionKey(), this);\r\n    }\r\n}\r\n\r\n\r\n// shamelessly stolen from the anonymice contract\r\nlibrary Base64 {\r\n    string internal constant TABLE =\r\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n    /**\r\n     * @dev Converts the input data into a base64 string.\r\n     */\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        if (data.length == 0) return \"\";\r\n\r\n        // load the table into memory\r\n        string memory table = TABLE;\r\n\r\n        // multiply by 4/3 rounded up\r\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\r\n\r\n        // add some extra buffer at the end required for the writing\r\n        string memory result = new string(encodedLen + 32);\r\n\r\n        assembly {\r\n            // set the actual output length\r\n            mstore(result, encodedLen)\r\n\r\n            // prepare the lookup table\r\n            let tablePtr := add(table, 1)\r\n\r\n            // input ptr\r\n            let dataPtr := data\r\n            let endPtr := add(dataPtr, mload(data))\r\n\r\n            // result ptr, jump over length\r\n            let resultPtr := add(result, 32)\r\n\r\n            // run over the input, 3 bytes at a time\r\n            for {\r\n\r\n            } lt(dataPtr, endPtr) {\r\n\r\n            } {\r\n                dataPtr := add(dataPtr, 3)\r\n\r\n                // read 3 bytes\r\n                let input := mload(dataPtr)\r\n\r\n                // write 4 characters\r\n                mstore(\r\n                    resultPtr,\r\n                    shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F))))\r\n                )\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore(\r\n                    resultPtr,\r\n                    shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F))))\r\n                )\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore(\r\n                    resultPtr,\r\n                    shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F))))\r\n                )\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore(\r\n                    resultPtr,\r\n                    shl(248, mload(add(tablePtr, and(input, 0x3F))))\r\n                )\r\n                resultPtr := add(resultPtr, 1)\r\n            }\r\n\r\n            // padding with '='\r\n            switch mod(mload(data), 3)\r\n            case 1 {\r\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\r\n            }\r\n            case 2 {\r\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\nlibrary Integer {\r\n    /**\r\n     * @dev Gets the bit at the given position in the given integer.\r\n     *      255 is the leftmost bit, 0 is the rightmost bit.\r\n     *\r\n     *      For example: bitAt(2, 0) == 0, because the rightmost bit of 10 is 0\r\n     *                   bitAt(2, 1) == 1, because the second to last bit of 10 is 1\r\n     */\r\n    function bitAt(uint integer, uint pos) internal pure returns (uint) {\r\n        require(pos <= 255, \"pos > 255\");\r\n\r\n        return (integer & (1 << pos)) >> pos;\r\n    }\r\n\r\n    function setBitAt(uint integer, uint pos) internal pure returns (uint) {\r\n        return integer | (1 << pos);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the value of the bits between left and right, both inclusive, in the given integer.\r\n     *      255 is the leftmost bit, 0 is the rightmost bit.\r\n     *      \r\n     *      For example: bitsFrom(10, 3, 1) == 7 (101 in binary), because 10 is *101*0 in binary\r\n     *                   bitsFrom(10, 2, 0) == 2 (010 in binary), because 10 is 1*010* in binary\r\n     */\r\n    function bitsFrom(uint integer, uint left, uint right) internal pure returns (uint) {\r\n        require(left >= right, \"left > right\");\r\n        require(left <= 255, \"left > 255\");\r\n\r\n        uint delta = left - right + 1;\r\n\r\n        return (integer & (((1 << delta) - 1) << right)) >> right;\r\n    }\r\n}\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\nenum NumericAttributeType {\r\n    NUMBER,\r\n    BOOST_PERCENTAGE,\r\n    BOOST_NUMBER,\r\n    DATE\r\n}\r\n\r\nstruct Attribute {\r\n    string displayType;\r\n    string key;\r\n    string serializedValue;\r\n    string maxValue;\r\n}\r\n\r\nstruct OpenSeaMetadata {\r\n    string svg;\r\n    string description;\r\n    string name;\r\n    uint24 backgroundColor;\r\n    Attribute[] attributes;\r\n}\r\n\r\nlibrary OpenSeaMetadataLibrary {\r\n    using Strings for uint;\r\n\r\n    struct ObjectKeyValuePair {\r\n        string key;\r\n        string serializedValue;\r\n    }\r\n\r\n    function uintToColorString(uint value, uint nBytes) internal pure returns (string memory) {\r\n        bytes memory symbols = \"0123456789ABCDEF\";\r\n        bytes memory buf = new bytes(nBytes * 2);\r\n\r\n        for (uint i = 0; i < nBytes * 2; ++i) {\r\n            buf[nBytes * 2 - 1 - i] = symbols[Integer.bitsFrom(value, (i * 4) + 3, i * 4)];\r\n        }\r\n\r\n        return string(buf);\r\n    }\r\n\r\n    function quote(string memory str) internal pure returns (string memory output) {\r\n        return bytes(str).length > 0 ? string(abi.encodePacked(\r\n            '\"',\r\n            str,\r\n            '\"'\r\n        )) : \"\";\r\n    }\r\n\r\n    function makeStringAttribute(string memory key, string memory value) internal pure returns (Attribute memory) {\r\n        return Attribute(\"\", key, quote(value), \"\");\r\n    }\r\n\r\n    function makeNumericAttribute(NumericAttributeType nat, string memory key, string memory value, string memory maxValue) private pure returns (Attribute memory) {\r\n        string memory s = \"number\";\r\n        if (nat == NumericAttributeType.BOOST_PERCENTAGE) {\r\n            s = \"boost_percentage\";\r\n        }\r\n        else if (nat == NumericAttributeType.BOOST_NUMBER) {\r\n            s = \"boost_number\";\r\n        }\r\n        else if (nat == NumericAttributeType.DATE) {\r\n            s = \"date\";\r\n        }\r\n\r\n        return Attribute(s, key, value, maxValue);\r\n    }\r\n\r\n    function makeFixedPoint(uint value, uint decimals) internal pure returns (string memory) {\r\n        bytes memory st = bytes(value.toString());\r\n\r\n        while (st.length < decimals) {\r\n            st = abi.encodePacked(\r\n                \"0\",\r\n                st\r\n            );\r\n        }\r\n\r\n        bytes memory ret = new bytes(st.length + 1);\r\n\r\n        if (decimals >= st.length) {\r\n            return string(abi.encodePacked(\"0.\", st));\r\n        }\r\n\r\n        uint dl = st.length - decimals;\r\n\r\n        uint i = 0;\r\n        uint j = 0;\r\n\r\n        while (i < ret.length) {\r\n            if (i == dl) {\r\n                ret[i] = '.';\r\n                i++;\r\n                continue;\r\n            }\r\n\r\n            ret[i] = st[j];\r\n\r\n            i++;\r\n            j++;\r\n        }\r\n\r\n        return string(ret);\r\n    }\r\n\r\n    function makeFixedPointAttribute(NumericAttributeType nat, string memory key, uint value, uint maxValue, uint decimals) internal pure returns (Attribute memory) {\r\n        return makeNumericAttribute(nat, key, makeFixedPoint(value, decimals), maxValue == 0 ? \"\" : makeFixedPoint(maxValue, decimals));\r\n    }\r\n\r\n    function makeUintAttribute(NumericAttributeType nat, string memory key, uint value, uint maxValue) internal pure returns (Attribute memory) {\r\n        return makeNumericAttribute(nat, key, value.toString(), maxValue == 0 ? \"\" : maxValue.toString());\r\n    }\r\n\r\n    function makeBooleanAttribute(string memory key, bool value) internal pure returns (Attribute memory) {\r\n        return Attribute(\"\", key, value ? \"true\" : \"false\", \"\");\r\n    }\r\n\r\n    function makeAttributesArray(Attribute[] memory attributes) internal pure returns (string memory output) {\r\n        output = \"[\";\r\n        bool empty = true;\r\n\r\n        for (uint i = 0; i < attributes.length; ++i) {\r\n            if (bytes(attributes[i].serializedValue).length > 0) {\r\n                ObjectKeyValuePair[] memory kvps = new ObjectKeyValuePair[](4);\r\n                kvps[0] = ObjectKeyValuePair(\"trait_type\", quote(attributes[i].key));\r\n                kvps[1] = ObjectKeyValuePair(\"display_type\", quote(attributes[i].displayType));\r\n                kvps[2] = ObjectKeyValuePair(\"value\", attributes[i].serializedValue);\r\n                kvps[3] = ObjectKeyValuePair(\"max_value\", attributes[i].maxValue);\r\n\r\n                output = string(abi.encodePacked(\r\n                    output,\r\n                    empty ? \"\" : \",\",\r\n                    makeObject(kvps)\r\n                ));\r\n                empty = false;\r\n            }\r\n        }\r\n\r\n        output = string(abi.encodePacked(output, \"]\"));\r\n    }\r\n\r\n    function notEmpty(string memory s) internal pure returns (bool) {\r\n        return bytes(s).length > 0;\r\n    }\r\n\r\n    function makeObject(ObjectKeyValuePair[] memory kvps) internal pure returns (string memory output) {\r\n        output = \"{\";\r\n        bool empty = true;\r\n\r\n        for (uint i = 0; i < kvps.length; ++i) {\r\n            if (bytes(kvps[i].serializedValue).length > 0) {\r\n                output = string(abi.encodePacked(\r\n                    output,\r\n                    empty ? \"\" : \",\",\r\n                    '\"',\r\n                    kvps[i].key,\r\n                    '\":',\r\n                    kvps[i].serializedValue\r\n                ));\r\n                empty = false;\r\n            }\r\n        }\r\n\r\n        output = string(abi.encodePacked(output, \"}\"));\r\n    }\r\n\r\n    function makeMetadataWithExtraKvps(OpenSeaMetadata memory metadata, ObjectKeyValuePair[] memory extra) internal pure returns (string memory output) {\r\n        /*\r\n        string memory svgUrl = string(abi.encodePacked(\r\n            \"data:image/svg+xml;base64,\",\r\n            string(Base64.encode(bytes(metadata.svg)))\r\n        ));\r\n        */\r\n\r\n        string memory svgUrl = string(abi.encodePacked(\r\n            \"data:image/svg+xml;utf8,\",\r\n            metadata.svg\r\n        ));\r\n\r\n        ObjectKeyValuePair[] memory kvps = new ObjectKeyValuePair[](5 + extra.length);\r\n        kvps[0] = ObjectKeyValuePair(\"name\", quote(metadata.name));\r\n        kvps[1] = ObjectKeyValuePair(\"description\", quote(metadata.description));\r\n        kvps[2] = ObjectKeyValuePair(\"image\", quote(svgUrl));\r\n        kvps[3] = ObjectKeyValuePair(\"background_color\", quote(uintToColorString(metadata.backgroundColor, 3)));\r\n        kvps[4] = ObjectKeyValuePair(\"attributes\", makeAttributesArray(metadata.attributes));\r\n        for (uint i = 0; i < extra.length; ++i) {\r\n            kvps[i + 5] = extra[i];\r\n        }\r\n\r\n        return string(abi.encodePacked(\r\n            \"data:application/json;base64,\",\r\n            Base64.encode(bytes(makeObject(kvps)))\r\n        ));\r\n    }\r\n\r\n    function makeMetadata(OpenSeaMetadata memory metadata) internal pure returns (string memory output) {\r\n        return makeMetadataWithExtraKvps(metadata, new ObjectKeyValuePair[](0));\r\n    }\r\n\r\n    function makeERC1155Metadata(OpenSeaMetadata memory metadata, string memory symbol) internal pure returns (string memory output) {\r\n        ObjectKeyValuePair[] memory kvps = new ObjectKeyValuePair[](1);\r\n        kvps[0] = ObjectKeyValuePair(\"symbol\", quote(symbol));\r\n        return makeMetadataWithExtraKvps(metadata, kvps);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Base class for creating \"passes\" e.g. Scout Pass purchaseable with a Utility ERC20 token.\r\n */\r\nabstract contract BasePass is ChainScoutsExtension, ERC1155Supply {\r\n    IUtilityERC20 public token;\r\n    uint256 public price;\r\n    string public name;\r\n    uint256 public MAX_SUPPLY;\r\n\r\n    IERC1155 public oldPass; // old scout pass address\r\n    uint256 public oldSupply; // migration purpose only\r\n\r\n    constructor() ERC1155(\"\") {}\r\n\r\n    function init(\r\n        address _oldPass,\r\n        uint256 _oldSupply,\r\n        address _token,\r\n        uint256 _price,\r\n        string memory _name\r\n    ) internal {\r\n        _setURI(\"\");\r\n        enabled = true;\r\n        MAX_SUPPLY = 3_444;\r\n        oldPass = IERC1155(_oldPass);\r\n        oldSupply = _oldSupply;\r\n        token = IUtilityERC20(_token);\r\n        price = _price;\r\n        name = _name;\r\n    }\r\n\r\n    /**\r\n     * Sets the name of the pass. OpenSea uses this to determine the collection name.\r\n     */\r\n    function adminSetName(string memory _name) external onlyAdmin {\r\n        name = _name;\r\n    }\r\n\r\n    /**\r\n     * Sets the token used to purchase the pass.\r\n     */\r\n    function adminSetToken(IUtilityERC20 _token) external onlyAdmin {\r\n        token = _token;\r\n    }\r\n\r\n    /**\r\n     * Sets the amount of token() needed to purchase a pass. Remember that this is wei (10^-18 eth) for most tokens.\r\n     */\r\n    function adminSetPrice(uint256 _price) external onlyAdmin {\r\n        price = _price;\r\n    }\r\n\r\n    /**\r\n     * Sets old supply for migration\r\n     */\r\n    function adminSetOldSupply(uint oldSupply_) external onlyAdmin {\r\n        oldSupply = oldSupply_;\r\n    }\r\n\r\n    /**\r\n     * Sets old pass for migration\r\n     */\r\n    function adminSetOldPass(address oldPass_) external onlyAdmin {\r\n        oldPass = IERC1155(oldPass_);\r\n    }\r\n\r\n    /**\r\n     * @dev Burns one or more passes. This is used by contracts that require passes in exchange for services.\r\n     * You must be the owner of the pass(es) being burnt or an admin.\r\n     */\r\n    function burn(address owner, uint256 count) external virtual whenEnabled {\r\n        require(\r\n            chainScouts.isAdmin(msg.sender) || msg.sender == owner,\r\n            \"must be admin or owner\"\r\n        );\r\n        _burn(msg.sender, 0, count);\r\n    }\r\n\r\n    /**\r\n     * @dev Purchases one or more passes. Requires price() token() per pass.\r\n     */\r\n    function migrate(uint256 count) public virtual whenEnabled {\r\n        require(count > 0, \"Must be at least one\");\r\n        oldPass.safeTransferFrom(msg.sender, address(this), 0, count, hex\"\");\r\n        _mint(msg.sender, 0, count, hex\"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Admin purpose only\r\n     */\r\n    function mintReserve(uint256 count, address to_) external onlyAdmin {\r\n        require(count > 0, \"Must be at least one\");\r\n        _mint(to_, 0, count, hex\"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Purchases one or more passes. Requires price() token() per pass.\r\n     */\r\n    function purchase(uint256 count) public virtual whenEnabled {\r\n        require(count > 0, \"Must mint at least one\");\r\n        require(totalSupply(0)+count <= MAX_SUPPLY-oldSupply, \"Exceed max supply\");\r\n        token.burn(msg.sender, count * price);\r\n        _mint(msg.sender, 0, count, hex\"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the metadata of the pass. Used by OpenSea to render the image.\r\n     */\r\n    function metadata() public virtual view returns (OpenSeaMetadata memory);\r\n\r\n    /**\r\n     * @dev Returns the \"symbol\" of the pass. For example, Ethereum's symbol is \"ETH\".\r\n     */\r\n    function symbol() public virtual view returns (string memory);\r\n\r\n    function uri(uint) public override view returns (string memory) {\r\n        return OpenSeaMetadataLibrary.makeERC1155Metadata(metadata(), symbol());\r\n    }\r\n\r\n    // onReceive functions signatures\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) public pure returns (bytes4) {\r\n        return 0xf23a6e61; \r\n    }\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) public pure returns (bytes4) { return 0xbc197c81; }\r\n}\r\n\r\n\r\ninterface IRenderer {\r\n    function render(bytes[] memory sprites) external view returns (string memory);\r\n}\r\n\r\n/// @dev Proxy for NFT Factory\r\ncontract ProxyTarget {\r\n\r\n    // Storage for this proxy\r\n    bytes32 internal constant IMPLEMENTATION_SLOT = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\r\n    bytes32 internal constant ADMIN_SLOT          = bytes32(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103);\r\n\r\n    function _getAddress(bytes32 key) internal view returns (address add) {\r\n        add = address(uint160(uint256(_getSlotValue(key))));\r\n    }\r\n\r\n    function _getSlotValue(bytes32 slot_) internal view returns (bytes32 value_) {\r\n        assembly {\r\n            value_ := sload(slot_)\r\n        }\r\n    }\r\n\r\n    function _setSlotValue(bytes32 slot_, bytes32 value_) internal {\r\n        assembly {\r\n            sstore(slot_, value_)\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// import \"./Sprites.sol\";\r\ncontract ScoutPass is BasePass, ProxyTarget {\r\n    bool public initialized;\r\n    IRenderer public renderer;\r\n    string private _symbol;\r\n\r\n    function initialize(address _oldPass, uint256 _oldSupply, address _token, IRenderer _renderer) external\r\n    {\r\n        require(msg.sender == _getAddress(ADMIN_SLOT), \"not admin\");\r\n\t\trequire(!initialized);\r\n\t\tinitialized = true;\r\n        // BasePass(\r\n        //     _token,\r\n        //     200 ether,\r\n        //     \"Scout Pass\"\r\n        // )\r\n        init(_oldPass, _oldSupply, _token, 200 ether, \"Scout Pass\");\r\n        _symbol = \"SCOUTPASS\";\r\n        renderer = _renderer;\r\n    }\r\n\r\n    function extensionKey() public override pure returns (string memory) {\r\n        return \"metaversePass\";\r\n    }\r\n    \r\n    function adminSetRenderer(IRenderer _renderer) external onlyAdmin {\r\n        renderer = _renderer;\r\n    }\r\n\r\n    function adminSetSymbol(string memory sym) external onlyAdmin {\r\n        _symbol = sym;\r\n    }\r\n\r\n    function metadata() public virtual view override returns (OpenSeaMetadata memory) {\r\n        bytes[] memory passSprite = new bytes[](1);\r\n        passSprite[0] = getPassSprite();\r\n        string memory sprite = renderer.render(passSprite);\r\n\r\n        return OpenSeaMetadata({\r\n            svg: sprite,\r\n            name: \"Scout Pass\",\r\n            description: \"The Scout Pass is the key to unlock perks in the Chain Scouts ecosystem\",\r\n            backgroundColor: 0,\r\n            attributes: new Attribute[](0)\r\n        });\r\n    }\r\n\r\n    function symbol() public virtual view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function getPassSprite() internal pure returns (bytes memory) {\r\n        return\r\n            hex\"41F022E501C28B9A020905370826B808241CFC28B98040D8426122E67102428101114DC4221E04044E4409075F122E501868B99C609AA066AAA46044A866AAAC6ADE58D1BF6EE19B057C46FDBC866BECC6FDBD06FC8D46ADED866BEDC6044E066AAE4609A75E1A2E7F1836101888B99C809AA09126A48044A880EB576203CF720113823F6F920269D7C88B94062A2E672826A829AAA9283CEA2AC195D8AADEDCA0F3E0A6AAE4A09A75F2A2E500CC8B990C0D84A6322E673026A8308869303CD538CADE5F0300118D8CADEDCC0F3E0C221E4C09A75F322E5018E8B99CE09AA0F126A4E0F3A8EAC156D3AB7AE38012F3B86B0380118D8EADEDCE0F3E0F126E4E09AE8E8B9ECE1A179F3A2E501908B99D009AA10221A500F354C42B7AD40012E45E1AF400118590ADEDD00F3E10221E5009A75F422E501928B99D209AA126CDA520F354B4AB7AC48012D4DE1AE4C182F480118592ADEDD20F3E126AAE5209A75F4A2E500D48B99148BA4A6522E675026A850A129503CEA52B7AB50012C55E1AD560FEE54182F55E1B0500118CD4ADE69550013652B7B7503CF85088B95026BA522EFB52327C522E9EFD48B98168B98562AD8968C94665A2E675826A85834E958112A5AB7AB58012C5DE1AD5E0FEE5C182F5DE1B05C1818CD6004D1783FD56004D96ADEDD6044E160E4E5609A75C5A2E7D5A2EFE5A2EBF58AB60622BA1622ED11988B99D809AA180D3A58044A98ADEAD8004B19786B5983FB99060BD9786C197CE63464183560013662B7B76011386034F960269D7D88B981A8BF4266A2E676826A869AFA968112A6AB7AB68012C6DE1AD6DF3AE6E0FEF6C18306DE1B16DF3B26DE199D1B83FD5A02BD9AADEDDA044E1A6BEE5A09AE9A8D4EDA8B9F1A8C87BF6A2E5011C8B995C8D499C8E79DC09AA1CFDBA5C04454B72B7AC70012D75E1AE75F3AF760FD851D060D5C004D9CADEDDC044E1CFDBE5C044E9C8E777C72321EFDC8B94037A2E647A35257A3CA67A40E77811287BF6E978111531EADEB5E0045D07DE198CDF83FD1E0046B67AB7B77811387BF6F978113A7A645DF1E8F2F5E8E77DF7A32100608B98A08D48E08E79209039602C99A099E9E009AA20FDBA6004454D82B7974E000469682B7B780113883F6F98026BA826E3B82647C82427D80AD3E82353F8232208A35218A39E28A43A38A42648A69658A77268A7E678826A889AFA98811155A2ADEDE2044E226BEE6209AEA2A0EEE29D4F229B8F62909FA28F2FE28E78248F18648F28A49868E499E9249D4964A0E9A4A289E409AA246BEA6404455696213790113891AFB99026BA92A9FB92943C9287FD92797E926E3F9264609A40E19A64629A6B639A79649A87E59A9E669AB8A79826A899AFA99811155A6ADEDE6044E266BEE6609AEA6B15EE6AE2F26A6EF66A28FA6A05FE69AD82899E8689C38A89E58E8A39928AA7968B169A8B789E809AA29126A68044AA8ADE56CA0886DA2B797468221CA8ADE675A08876A2B7B7A01138A449B9A026BAA2EF7BA2DA7CA2BB7DA2A2FEA2977FA27E60A8BA61AA83A2AA9423AAAF64AAC565AAF4A6AB16E7A826A8AC49A9A8112AAAB7ABA8886CAAB796BAA221BEAADEC2A221C6AADE653A88874AAB7B5A88876AAB7B7A81138AC49B9A826BAAB2CBBAB0B3CAADCBDAAC2FEAAACBFA8C5E0B28361B29B62B2B123B2D7E4B2F365B31E66B34F67B026A8B449A9B011155ACADEDEC044E2D126E6C09AEACDF9EECCDFF2CC47F6CBD2FACB50FECABD82EA5086EAED8AEB698EEC1492EC9A96ED719AEE859EE09AA2E221A6E0F3AAEADE56EB8886FBAB79846E221CAEADECEE221D2EADED6E221DAEADEDEE044E2E221E6E09AEAEF09EEEE60F2ED36F6EC88FAEBE9FEEB43830AC4870B508B0C1D8F0CB2930D8A970E589B0F8D9F009AA306BEA700F354BC2B7ACC0886DC2B7973F0221C30ADE632C08873C2B79A570221DB0ADEDF0044E306BEE7009AEB104BEF0F61F30E79F70D67FB0C79FF0BE9832B16872BFA8B2C888F2D80932EA4972FB79B31089F209AA326BEA720F3556CAB7B7C83CF8C9AFB9C826BACC743BCC18FCCBE0BDCB9ABECB4F7FCB18A0D2E4E1D31AE2D34F63D3A164D3E0A5D447E6D48A27D026A8D449A9D03CD55B5884DF40F3E34FDBE7409AEB52DAEF51E8F35063F74F6BFB4E53FF4CDF836C14876CDF8B6E2A8F6F6B9370FD9772099B732C9F609AA37126A76044AB60EB576D83CF7D81138DBF6F9D826BADCFC7BDCAFFCDC743DDC12FEDBCEFFDB7E60E31E61E36662E3BD63E40864E473E5E4BBA6E4FC67E026A8E1AAA9E0112AE1AAABE2B796378FDBBB86C15F1E3F6F2E1AFB3E3F6F4E3F235E2B7B6E1AFB7E01138E1AAB9E026BAE51CBBE4EB3CE4A97DE466FEE3F0FFE3B760EB3A61EB7962EBE6E3EC56521BA0049FA090A3A044537E88878E81139E8241D73A004F7B25CFBB11FFFAF8283CD9987CEF58BD0308FC004487F60FE8F61014AFD846B3D8425B6F6119BE3D84273CF60FFDF0013EF4743FF3FDA0FB86E1FBD862FC4BA3FC9E64F801129FF786509FC181533F786B7F0605D2FDE1B3FC181A5BF7866F8FC181CEFF786F3E004F7F39BFBF25CFFF0F0\";\r\n    }\r\n\r\n    // function setChainScoutsTest(IChainScouts _contract) external onlyAdmin {\r\n    //     // require(address(0) == address(chainScouts) || chainScouts.isAdmin(msg.sender), \"ChainScoutsExtension: The Chain Scouts contract must not be set or you must be an admin\");\r\n    //     chainScouts = _contract;\r\n    //     // chainScouts.adminSetExtension(extensionKey(), this);\r\n    // }\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"e\",\"type\":\"bool\"}],\"name\":\"adminSetEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"adminSetName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldPass_\",\"type\":\"address\"}],\"name\":\"adminSetOldPass\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"oldSupply_\",\"type\":\"uint256\"}],\"name\":\"adminSetOldSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"adminSetPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IRenderer\",\"name\":\"_renderer\",\"type\":\"address\"}],\"name\":\"adminSetRenderer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"sym\",\"type\":\"string\"}],\"name\":\"adminSetSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUtilityERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"adminSetToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extensionKey\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oldPass\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_oldSupply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract IRenderer\",\"name\":\"_renderer\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadata\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"svg\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint24\",\"name\":\"backgroundColor\",\"type\":\"uint24\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"displayType\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"serializedValue\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"maxValue\",\"type\":\"string\"}],\"internalType\":\"struct Attribute[]\",\"name\":\"attributes\",\"type\":\"tuple[]\"}],\"internalType\":\"struct OpenSeaMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"}],\"name\":\"mintReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldPass\",\"outputs\":[{\"internalType\":\"contract IERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renderer\",\"outputs\":[{\"internalType\":\"contract IRenderer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IChainScouts\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"setChainScouts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IUtilityERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ScoutPass", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4c4c4248214444c6d891ba2e2a970a03cbb09cc97544e5170e57948464bac849"}]}