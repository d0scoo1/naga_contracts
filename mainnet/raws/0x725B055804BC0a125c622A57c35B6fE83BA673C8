{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/type2/CheapSwapFactory2.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.12;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/ICheapSwapFactory2.sol\\\";\\nimport \\\"./CheapSwapAddress.sol\\\";\\n\\ncontract CheapSwapFactory2 is ICheapSwapFactory2, Ownable {\\n    mapping(address => address) public addressMap;\\n    uint256 public fee = 0.001 ether;\\n    address public feeAddress;\\n\\n    constructor() {\\n        feeAddress = msg.sender;\\n    }\\n\\n    /* ================ TRANSACTION FUNCTIONS ================ */\\n\\n    function createAddress() external {\\n        addressMap[msg.sender] = address(new CheapSwapAddress(msg.sender));\\n        emit CreateAddress(msg.sender, addressMap[msg.sender]);\\n    }\\n\\n    /* =================== ADMIN FUNCTIONS =================== */\\n\\n    function setFeeAddress(address _feeAddress) external onlyOwner {\\n        feeAddress = _feeAddress;\\n    }\\n\\n    function setFee(uint256 _fee) external onlyOwner {\\n        fee = _fee;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/type2/interfaces/ICheapSwapFactory2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\ninterface ICheapSwapFactory2 {\\n    /* ==================== EVENTS =================== */\\n\\n    event CreateAddress(address owner, address chatSwapAddress);\\n\\n    /* ==================== VIEW FUNCTIONS =================== */\\n\\n    function fee() external view returns (uint256);\\n\\n    function feeAddress() external view returns (address);\\n\\n    /* ================ TRANSACTION FUNCTIONS ================ */\\n\\n    function createAddress() external;\\n\\n    /* ==================== ADMIN FUNCTIONS =================== */\\n\\n    function setFeeAddress(address _feeAddress) external;\\n\\n    function setFee(uint256 _fee) external;\\n}\\n\"\r\n    },\r\n    \"contracts/type2/CheapSwapAddress.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.12;\\n\\nimport \\\"../lib/BytesLib.sol\\\";\\nimport \\\"./interfaces/ICheapSwapAddress.sol\\\";\\nimport \\\"./interfaces/ICheapSwapFactory2.sol\\\";\\n\\ncontract CheapSwapAddress is ICheapSwapAddress {\\n    using BytesLib for bytes;\\n\\n    bool public callPause;\\n    address public owner;\\n    ICheapSwapFactory2 public cheapSwapFactory;\\n    mapping(uint256 => bytes) public targetDataMap;\\n    mapping(address => bool) public callApprove;\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n        cheapSwapFactory = ICheapSwapFactory2(msg.sender);\\n    }\\n\\n    /* ==================== UTIL FUNCTIONS =================== */\\n\\n    modifier _onlyOwner() {\\n        require(owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /* ================ TRANSACTION FUNCTIONS ================ */\\n\\n    receive() external payable {\\n        doReceive();\\n    }\\n\\n    function doReceive() public payable {\\n        require(targetDataMap[msg.value].length != 0, \\\"CheapSwapAddress: empty targetData\\\");\\n        uint256 fee = cheapSwapFactory.fee();\\n        require(msg.value >= fee, \\\"CheapSwapAddress: insufficient value\\\");\\n        payable(cheapSwapFactory.feeAddress()).transfer(fee);\\n        uint256 value = msg.value - fee;\\n        if (value > 0) {\\n            payable(owner).transfer(value);\\n        }\\n        bytes memory targetData = targetDataMap[msg.value];\\n        (bool success, ) = targetData.toAddress(0).call(targetData.slice(20, targetData.length - 20));\\n        require(success, \\\"CheapSwapAddress: call error\\\");\\n    }\\n\\n    function call(address target, bytes calldata data) external payable {\\n        require(callApprove[msg.sender] && !callPause, \\\"CheapSwapAddress: not allow call\\\");\\n        bool success;\\n        if (msg.value > 0) {\\n            (success, ) = target.call{value: msg.value}(data);\\n        } else {\\n            (success, ) = target.call(data);\\n        }\\n        require(success, \\\"CheapSwapAddress: call error\\\");\\n    }\\n\\n    /* ==================== ADMIN FUNCTIONS ================== */\\n\\n    function approveCall(address sender) external _onlyOwner {\\n        callApprove[sender] = !callApprove[sender];\\n        emit ApproveCall(sender, callApprove[sender]);\\n    }\\n\\n    function pauseCall() external _onlyOwner {\\n        callPause = !callPause;\\n        emit PauseCall(callPause);\\n    }\\n\\n    function setTargetData(uint256 value, bytes calldata targetData) external _onlyOwner {\\n        targetDataMap[value] = targetData;\\n        emit SetTargetData(value, targetData);\\n    }\\n\\n    function setTargetDataList(uint256[] calldata valueList, bytes[] calldata targetDataList) external _onlyOwner {\\n        require(valueList.length == targetDataList.length, \\\"CheapSwapAddress: not equal length\\\");\\n        uint256 length = valueList.length;\\n        for (uint256 i = 0; i < length; ++i) {\\n            targetDataMap[valueList[i]] = targetDataList[i];\\n            emit SetTargetData(valueList[i], targetDataList[i]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/BytesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\u00e7alo S\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.5.0;\\n\\nlibrary BytesLib {\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_start + _length >= _start, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_start + 20 >= _start, \\\"toAddress_overflow\\\");\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\\n        require(_start + 3 >= _start, \\\"toUint24_overflow\\\");\\n        require(_bytes.length >= _start + 3, \\\"toUint24_outOfBounds\\\");\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/type2/interfaces/ICheapSwapAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\ninterface ICheapSwapAddress {\\n    /* ==================== EVENTS =================== */\\n\\n    event ApproveCall(address sender, bool callApprove);\\n\\n    event SetTargetData(uint256 value, bytes targetData);\\n\\n    event PauseCall(bool cancelCall);\\n\\n    /* ==================== VIEW FUNCTIONS =================== */\\n\\n    function owner() external view returns (address);\\n\\n    /* ================ TRANSACTION FUNCTIONS ================ */\\n\\n    function doReceive() external payable;\\n\\n    function call(address target, bytes calldata data) external payable;\\n\\n    /* ===================== ADMIN FUNCTIONS ==================== */\\n\\n    function approveCall(address sender) external;\\n\\n    function pauseCall() external;\\n\\n    function setTargetData(uint256 value, bytes calldata targetData) external;\\n\\n    function setTargetDataList(uint256[] calldata valueList, bytes[] calldata targetDataList) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"chatSwapAddress\",\"type\":\"address\"}],\"name\":\"CreateAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeAddress\",\"type\":\"address\"}],\"name\":\"setFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CheapSwapFactory2", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}