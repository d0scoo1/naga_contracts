{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TokenRangeVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libraries/BytesUtils.sol\\\";\\n\\ncontract TokenRangeVerifier {\\n    using BytesUtils for bytes;\\n\\n    function verify(uint256 startTokenId, uint256 endTokenId) public pure {\\n        uint256 tokenId = abi.decode(msg.data.slice(136, 32), (uint256));\\n        require(\\n            startTokenId <= tokenId && tokenId <= endTokenId,\\n            \\\"Invalid token id\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BytesUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// Inspired from the Wyvern V3 source code:\\n// https://github.com/wyvernprotocol/wyvern-v3/blob/1d89d6a91faddf3c3494e6ebdcb07b46fe111fb4/contracts/lib/ArrayUtils.sol\\n\\nlibrary BytesUtils {\\n    function drop(bytes memory array, uint256 start)\\n        public\\n        pure\\n        returns (bytes memory result)\\n    {\\n        result = slice(array, start, array.length - start);\\n    }\\n\\n    function slice(\\n        bytes memory array,\\n        uint256 start,\\n        uint256 length\\n    ) public pure returns (bytes memory result) {\\n        assembly {\\n            switch iszero(length)\\n            case 0 {\\n                // Get a location of some free memory and store it in `result`\\n                result := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthMod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthMod := and(length, 31)\\n\\n                // The multiplication in the next line is necessary because when\\n                // slicing multiples of 32 bytes (`lengthMod == 0`) the following\\n                // copy loop was copying the origin's length and then ending in a\\n                // premature way not copying everything it should.\\n                let mc := add(\\n                    add(result, lengthMod),\\n                    mul(0x20, iszero(lengthMod))\\n                )\\n                let end := add(mc, length)\\n\\n                for {\\n                    // The multiplication below has the same exact purpose as the one above\\n                    let cc := add(\\n                        add(\\n                            add(array, lengthMod),\\n                            mul(0x20, iszero(lengthMod))\\n                        ),\\n                        start\\n                    )\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(result, length)\\n\\n                // Update free-memory pointer, allocating the array padded to 32 bytes\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            // If we want a zero-length slice then simply return a zero-length array\\n            default {\\n                result := mload(0x40)\\n\\n                mstore(0x40, add(result, 0x20))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/BytesUtils.sol\": {\r\n        \"BytesUtils\": \"0x5595ddec926bfb297814c33a90e44f97c6074fe5\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTokenId\",\"type\":\"uint256\"}],\"name\":\"verify\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "TokenRangeVerifier", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}