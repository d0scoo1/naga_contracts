{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/farming/FarmMainGen1V2.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"../amm-aggregator/common/IAMM.sol\\\";\\nimport \\\"./IFarmMainGen1.sol\\\";\\nimport \\\"./IFarmExtensionGen1.sol\\\";\\nimport \\\"./util/IERC20.sol\\\";\\nimport \\\"./util/IEthItemOrchestrator.sol\\\";\\nimport \\\"./util/INativeV1.sol\\\";\\n\\ncontract FarmMainGen1V2 is IFarmMainGen1 {\\n\\n    // percentage\\n    uint256 public override constant ONE_HUNDRED = 1e18;\\n    // event that tracks contracts deployed for the given reward token\\n    event RewardToken(address indexed rewardTokenAddress);\\n    // new or transferred farming position event\\n    event Transfer(uint256 indexed positionId, address indexed from, address indexed to);\\n    // event that tracks involved tokens for this contract\\n    event SetupToken(address indexed mainToken, address indexed involvedToken);\\n    // event that tracks farm tokens\\n    event FarmToken(uint256 indexed objectId, address indexed liquidityPoolToken, uint256 setupIndex, uint256 endBlock);\\n    // factory address that will create clones of this contract\\n    address public initializer;\\n    // address of the extension of this contract\\n    address public host;\\n    // address of the reward token\\n    address public override _rewardTokenAddress;\\n    // mapping containing all the currently available farming setups info\\n    mapping(uint256 => FarmingSetupInfo) private _setupsInfo;\\n    // counter for the farming setup info\\n    uint256 public _farmingSetupsInfoCount;\\n    // mapping containing all the currently available farming setups\\n    mapping(uint256 => FarmingSetup) private _setups;\\n    // counter for the farming setups\\n    uint256 public _farmingSetupsCount;\\n    // mapping containing all the positions\\n    mapping(uint256 => FarmingPosition) private _positions;\\n    // mapping containing the reward per token per setup per block\\n    mapping(uint256 => uint256) private _rewardPerTokenPerSetup;\\n    // mapping containing the reward per token paid per position\\n    mapping(uint256 => uint256) private _rewardPerTokenPaid;\\n    // mapping containing whether a farming position has been partially reedemed or not\\n    mapping(uint256 => uint256) public _partiallyRedeemed;\\n    // mapping containing all the number of opened positions for each setups\\n    mapping(uint256 => uint256) private _setupPositionsCount;\\n    // mapping containing all the reward received/paid per setup\\n    mapping(uint256 => uint256) public _rewardReceived;\\n    mapping(uint256 => uint256) public _rewardPaid;\\n\\n    /** Modifiers. */\\n\\n    /** @dev byExtension modifier used to check for unauthorized changes. */\\n    modifier byExtension() {\\n        require(msg.sender == host, \\\"Unauthorized\\\");\\n        _;\\n    }\\n\\n    /** @dev byPositionOwner modifier used to check for unauthorized accesses. */\\n    modifier byPositionOwner(uint256 positionId) {\\n        require(_positions[positionId].uniqueOwner == msg.sender && _positions[positionId].creationBlock != 0, \\\"Not owned\\\");\\n        _;\\n    }\\n\\n    /** @dev activeSetupOnly modifier used to check for function calls only if the setup is active. */\\n    modifier activeSetupOnly(uint256 setupIndex) {\\n        require(_setups[setupIndex].active, \\\"Setup not active\\\");\\n        require(_setups[setupIndex].startBlock <= block.number && _setups[setupIndex].endBlock > block.number, \\\"Invalid setup\\\");\\n        _;\\n    }\\n\\n    receive() external payable {}\\n\\n    /** Extension methods */\\n\\n    function lazyInit(bytes memory initPayload) public returns(bytes memory extensionReturnCall) {\\n        require(initializer == address(0), \\\"Already initialized\\\");\\n        initializer = msg.sender;\\n        (host, initPayload) = abi.decode(initPayload, (address, bytes));\\n        require(host != address(0), \\\"extension\\\");\\n        (bytes memory extensionInitData, address rewardTokenAddress, bytes memory farmingSetupInfosBytes) = abi.decode(initPayload, (bytes, address, bytes));\\n        emit RewardToken(_rewardTokenAddress = rewardTokenAddress);\\n        if (keccak256(extensionInitData) != keccak256(\\\"\\\")) {\\n            extensionReturnCall = _call(host, extensionInitData);\\n        }\\n        if(farmingSetupInfosBytes.length > 0) {\\n            FarmingSetupInfo[] memory farmingSetupInfos = abi.decode(farmingSetupInfosBytes, (FarmingSetupInfo[]));\\n            for(uint256 i = 0; i < farmingSetupInfos.length; i++) {\\n                _setOrAddFarmingSetupInfo(farmingSetupInfos[i], true, false, 0);\\n            }\\n        }\\n    }\\n\\n    function setFarmingSetups(FarmingSetupConfiguration[] memory farmingSetups) public override byExtension {\\n        for (uint256 i = 0; i < farmingSetups.length; i++) {\\n            _setOrAddFarmingSetupInfo(farmingSetups[i].info, farmingSetups[i].add, farmingSetups[i].disable, farmingSetups[i].index);\\n        }\\n    }\\n\\n    function finalFlush(address[] calldata tokens, uint256[] calldata amounts) public  {\\n        for(uint256 i = 0; i < _farmingSetupsCount; i++) {\\n            require(_setupPositionsCount[i] == 0 && !_setups[i].active && _setups[i].totalSupply == 0, \\\"Not Empty\\\");\\n        }\\n        (,,, address receiver,) = IFarmExtensionGen1(host).data();\\n        require(tokens.length == amounts.length, \\\"length\\\");\\n        for(uint256 i = 0; i < tokens.length; i++) {\\n            address token = tokens[i];\\n            uint256 amount = amounts[i];\\n            require(receiver != address(0));\\n            if(token == address(0)) {\\n                (bool result,) = receiver.call{value : amount}(\\\"\\\");\\n                require(result, \\\"ETH\\\");\\n            } else {\\n                _safeTransfer(token, receiver, amount);\\n            }\\n        }\\n    }\\n\\n    /** Public methods */\\n\\n    /** @dev returns the position with the given id.\\n      * @param positionId id of the position.\\n      * @return farming position with the given id.\\n     */\\n    function position(uint256 positionId) public override view returns (FarmingPosition memory) {\\n        return _positions[positionId];\\n    }\\n\\n    function setup(uint256 setupIndex) public override view returns (FarmingSetup memory, FarmingSetupInfo memory) {\\n        return (_setups[setupIndex], _setupsInfo[_setups[setupIndex].infoIndex]);\\n    }\\n\\n    function setups() public override view returns (FarmingSetup[] memory) {\\n        FarmingSetup[] memory farmingSetups = new FarmingSetup[](_farmingSetupsCount);\\n        for (uint256 i = 0; i < _farmingSetupsCount; i++) {\\n            farmingSetups[i] = _setups[i];\\n        }\\n        return farmingSetups;\\n    }\\n\\n    function activateSetup(uint256 setupInfoIndex) public {\\n        require(_setupsInfo[setupInfoIndex].renewTimes > 0 && !_setups[_setupsInfo[setupInfoIndex].lastSetupIndex].active, \\\"Invalid toggle.\\\");\\n        _toggleSetup(_setupsInfo[setupInfoIndex].lastSetupIndex);\\n    }\\n\\n    function toggleSetup(uint256 setupInfoIndex) public {\\n        require(_setups[_setupsInfo[setupInfoIndex].lastSetupIndex].active && block.number > _setups[_setupsInfo[setupInfoIndex].lastSetupIndex].endBlock, \\\"Invalid toggle.\\\");\\n        _toggleSetup(_setupsInfo[setupInfoIndex].lastSetupIndex);\\n    }\\n\\n    function openPosition(FarmingPositionRequest memory request) public override payable returns(uint256 positionId) {\\n        if(!_setups[request.setupIndex].active) {\\n            activateSetup(_setups[request.setupIndex].infoIndex);\\n        }\\n\\n        // retrieve the setup\\n        FarmingSetup storage chosenSetup = _setups[request.setupIndex];\\n        // retrieve the unique owner\\n        address uniqueOwner = (request.positionOwner != address(0)) ? request.positionOwner : msg.sender;\\n        // create the position id\\n        positionId = uint256(keccak256(abi.encode(uniqueOwner, _setupsInfo[chosenSetup.infoIndex].free ? 0 : block.number, request.setupIndex)));\\n        require(_positions[positionId].creationBlock == 0, \\\"Invalid open\\\");\\n        // create the lp data for the amm\\n        (LiquidityPoolData memory liquidityPoolData, uint256 mainTokenAmount) = _addLiquidity(request.setupIndex, request);\\n        // calculate the reward\\n        uint256 reward;\\n        uint256 lockedRewardPerBlock;\\n        require(_setupsInfo[chosenSetup.infoIndex].free, \\\"free\\\");\\n        _updateFreeSetup(request.setupIndex, liquidityPoolData.amount, positionId, false);\\n        _positions[positionId] = FarmingPosition({\\n            uniqueOwner: uniqueOwner,\\n            setupIndex : request.setupIndex,\\n            liquidityPoolTokenAmount: liquidityPoolData.amount,\\n            mainTokenAmount: mainTokenAmount,\\n            reward: reward,\\n            lockedRewardPerBlock: lockedRewardPerBlock,\\n            creationBlock: block.number\\n        });\\n        _setupPositionsCount[request.setupIndex] += (1 + (_setupsInfo[chosenSetup.infoIndex].free ? 0 : liquidityPoolData.amount));\\n        emit Transfer(positionId, address(0), uniqueOwner);\\n    }\\n\\n    function addLiquidity(uint256 positionId, FarmingPositionRequest memory request) public override payable activeSetupOnly(request.setupIndex) byPositionOwner(positionId) {\\n        // retrieve farming position\\n        FarmingPosition storage farmingPosition = _positions[positionId];\\n        FarmingSetup storage chosenSetup = _setups[farmingPosition.setupIndex];\\n        // check if farmoing position is valid\\n        require(_setupsInfo[chosenSetup.infoIndex].free, \\\"Invalid add liquidity\\\");\\n        // create the lp data for the amm\\n        (LiquidityPoolData memory liquidityPoolData,) = _addLiquidity(farmingPosition.setupIndex, request);\\n        // rebalance the reward per token\\n        _rewardPerTokenPerSetup[farmingPosition.setupIndex] += (((block.number - chosenSetup.lastUpdateBlock) * chosenSetup.rewardPerBlock) * 1e18) / chosenSetup.totalSupply;\\n        farmingPosition.reward = calculateFreeFarmingReward(positionId, false);\\n        _rewardPerTokenPaid[positionId] = _rewardPerTokenPerSetup[farmingPosition.setupIndex];\\n        farmingPosition.liquidityPoolTokenAmount += liquidityPoolData.amount;\\n        // update the last block update variablex\\n        chosenSetup.lastUpdateBlock = block.number;\\n        chosenSetup.totalSupply += liquidityPoolData.amount;\\n    }\\n\\n\\n    /** @dev this function allows a user to withdraw the reward.\\n      * @param positionId farming position id.\\n     */\\n    function withdrawReward(uint256 positionId) public byPositionOwner(positionId) {\\n        // retrieve farming position\\n        FarmingPosition storage farmingPosition = _positions[positionId];\\n        uint256 reward = farmingPosition.reward;\\n        uint256 currentBlock = block.number;\\n        if (!_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free) {\\n            // check if reward is available\\n            require(farmingPosition.reward > 0, \\\"No reward\\\");\\n            // check if it's a partial reward or not\\n            // if (_setups[farmingPosition.setupIndex].endBlock > block.number) {\\n            // calculate the reward from the farming position creation block to the current block multiplied by the reward per block\\n            (reward,) = calculateLockedFarmingReward(0, 0, true, positionId);\\n            //}\\n            require(reward <= farmingPosition.reward, \\\"Reward is bigger than expected\\\");\\n            // remove the partial reward from the liquidity mining position total reward\\n            farmingPosition.reward = currentBlock >= _setups[farmingPosition.setupIndex].endBlock ? 0 : farmingPosition.reward - reward;\\n            farmingPosition.creationBlock = block.number;\\n        } else {\\n            // rebalance setup\\n            currentBlock = currentBlock > _setups[farmingPosition.setupIndex].endBlock ? _setups[farmingPosition.setupIndex].endBlock : currentBlock;\\n            _rewardPerTokenPerSetup[farmingPosition.setupIndex] += (((currentBlock - _setups[farmingPosition.setupIndex].lastUpdateBlock) * _setups[farmingPosition.setupIndex].rewardPerBlock) * 1e18) / _setups[farmingPosition.setupIndex].totalSupply;\\n            reward = calculateFreeFarmingReward(positionId, false);\\n            _rewardPerTokenPaid[positionId] = _rewardPerTokenPerSetup[farmingPosition.setupIndex];\\n            farmingPosition.reward = 0;\\n            // update the last block update variable\\n            _setups[farmingPosition.setupIndex].lastUpdateBlock = currentBlock;\\n        }\\n        if (reward > 0) {\\n            // transfer the reward\\n            if (_rewardTokenAddress != address(0)) {\\n                _safeTransfer(_rewardTokenAddress, farmingPosition.uniqueOwner, reward);\\n            } else {\\n                (bool result,) = farmingPosition.uniqueOwner.call{value:reward}(\\\"\\\");\\n                require(result, \\\"Invalid ETH transfer.\\\");\\n            }\\n            _rewardPaid[farmingPosition.setupIndex] += reward;\\n        }\\n        if (_setups[farmingPosition.setupIndex].endBlock <= block.number) {\\n            if (_setups[farmingPosition.setupIndex].active) {\\n                _toggleSetup(farmingPosition.setupIndex);\\n            }\\n            // close the locked position after withdrawing all the reward\\n            if (!_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free) {\\n                _setupPositionsCount[farmingPosition.setupIndex] -= 1;\\n                if (_setupPositionsCount[farmingPosition.setupIndex] == 0 && !_setups[farmingPosition.setupIndex].active) {\\n                    delete _setups[farmingPosition.setupIndex];\\n                }\\n                delete _positions[positionId];\\n            }\\n        } else if (!_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free) {\\n            // set the partially redeemed amount\\n            _partiallyRedeemed[positionId] += reward;\\n        }\\n    }\\n\\n    function withdrawLiquidity(uint256 positionId, uint256 objectId, uint256 removedLiquidity, uint256 amount0Min, uint256 amount1Min, bytes memory burnData) public {\\n        // retrieve farming position\\n        FarmingPosition memory farmingPosition = _positions[positionId];\\n        uint256 setupIndex = farmingPosition.setupIndex;\\n        require((positionId != 0 && objectId == 0) || (objectId != 0 && positionId == 0 && _setups[setupIndex].objectId == objectId), \\\"Invalid position\\\");\\n        // current owned liquidity\\n        require(\\n            (\\n                _setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free &&\\n                farmingPosition.creationBlock != 0 &&\\n                removedLiquidity <= farmingPosition.liquidityPoolTokenAmount &&\\n                farmingPosition.uniqueOwner == msg.sender &&\\n                positionId != 0\\n            ), \\\"Invalid withdraw\\\");\\n        // burn the liquidity in the locked setup\\n        withdrawReward(positionId);\\n        _setups[farmingPosition.setupIndex].totalSupply -= removedLiquidity;\\n        _removeLiquidity(positionId, setupIndex, removedLiquidity, false, amount0Min, amount1Min, burnData);\\n        if (positionId == 0) {\\n            _setupPositionsCount[setupIndex] -= removedLiquidity;\\n            if (_setupPositionsCount[setupIndex] == 0 && !_setups[setupIndex].active) {\\n                delete _setups[setupIndex];\\n            }\\n        }\\n    }\\n\\n    function calculateLockedFarmingReward(uint256 setupIndex, uint256 mainTokenAmount, bool isPartial, uint256 positionId) public view returns(uint256 reward, uint256 relativeRewardPerBlock) {\\n        if (isPartial) {\\n            // retrieve the position\\n            FarmingPosition memory farmingPosition = _positions[positionId];\\n            // calculate the reward\\n            uint256 currentBlock = block.number >= _setups[farmingPosition.setupIndex].endBlock ? _setups[farmingPosition.setupIndex].endBlock : block.number;\\n            reward = ((currentBlock - farmingPosition.creationBlock) * farmingPosition.lockedRewardPerBlock);\\n        } else {\\n            FarmingSetup memory setup = _setups[setupIndex];\\n            // check if main token amount is less than the stakeable liquidity\\n            require(mainTokenAmount <= _setupsInfo[_setups[setupIndex].infoIndex].maxStakeable - setup.totalSupply, \\\"Invalid liquidity\\\");\\n            uint256 remainingBlocks = block.number >= setup.endBlock ? 0 : setup.endBlock - block.number;\\n            // get amount of remaining blocks\\n            require(remainingBlocks > 0, \\\"FarmingSetup ended\\\");\\n            // get total reward still available (= 0 if rewardPerBlock = 0)\\n            require(setup.rewardPerBlock * remainingBlocks > 0, \\\"No rewards\\\");\\n            // calculate relativeRewardPerBlock\\n            relativeRewardPerBlock = (setup.rewardPerBlock * ((mainTokenAmount * 1e18) / _setupsInfo[_setups[setupIndex].infoIndex].maxStakeable)) / 1e18;\\n            // check if rewardPerBlock is greater than 0\\n            require(relativeRewardPerBlock > 0, \\\"Invalid rpb\\\");\\n            // calculate reward by multiplying relative reward per block and the remaining blocks\\n            reward = relativeRewardPerBlock * remainingBlocks;\\n        }\\n    }\\n\\n    function calculateFreeFarmingReward(uint256 positionId, bool isExt) public view returns(uint256 reward) {\\n        FarmingPosition memory farmingPosition = _positions[positionId];\\n        reward = ((_rewardPerTokenPerSetup[farmingPosition.setupIndex] - _rewardPerTokenPaid[positionId]) * farmingPosition.liquidityPoolTokenAmount) / 1e18;\\n        if (isExt) {\\n            uint256 currentBlock = block.number < _setups[farmingPosition.setupIndex].endBlock ? block.number : _setups[farmingPosition.setupIndex].endBlock;\\n            uint256 lastUpdateBlock = _setups[farmingPosition.setupIndex].lastUpdateBlock < _setups[farmingPosition.setupIndex].startBlock ? _setups[farmingPosition.setupIndex].startBlock : _setups[farmingPosition.setupIndex].lastUpdateBlock;\\n            uint256 rpt = (((currentBlock - lastUpdateBlock) * _setups[farmingPosition.setupIndex].rewardPerBlock) * 1e18) / _setups[farmingPosition.setupIndex].totalSupply;\\n            reward += (rpt * farmingPosition.liquidityPoolTokenAmount) / 1e18;\\n        }\\n        reward += farmingPosition.reward;\\n    }\\n\\n    /** Private methods */\\n\\n    function _setOrAddFarmingSetupInfo(FarmingSetupInfo memory info, bool add, bool disable, uint256 setupIndex) private {\\n        require(info.free, \\\"free\\\");\\n        FarmingSetupInfo memory farmingSetupInfo = info;\\n\\n        if(add || !disable) {\\n            farmingSetupInfo.renewTimes = farmingSetupInfo.renewTimes + 1;\\n            if(farmingSetupInfo.renewTimes == 0) {\\n                farmingSetupInfo.renewTimes = farmingSetupInfo.renewTimes - 1;\\n            }\\n        }\\n\\n        if (add) {\\n            require(\\n                farmingSetupInfo.ammPlugin != address(0) &&\\n                farmingSetupInfo.liquidityPoolTokenAddress != address(0) &&\\n                farmingSetupInfo.originalRewardPerBlock > 0 &&\\n                (farmingSetupInfo.free || farmingSetupInfo.maxStakeable > 0),\\n                \\\"Invalid setup configuration\\\"\\n            );\\n\\n            (,,address[] memory tokenAddresses) = IAMM(farmingSetupInfo.ammPlugin).byLiquidityPool(farmingSetupInfo.liquidityPoolTokenAddress);\\n            farmingSetupInfo.ethereumAddress = address(0);\\n            if (farmingSetupInfo.involvingETH) {\\n                (farmingSetupInfo.ethereumAddress,,) = IAMM(farmingSetupInfo.ammPlugin).data();\\n            }\\n            bool mainTokenFound = false;\\n            bool ethTokenFound = false;\\n            for(uint256 z = 0; z < tokenAddresses.length; z++) {\\n                if(tokenAddresses[z] == farmingSetupInfo.mainTokenAddress) {\\n                    mainTokenFound = true;\\n                    if(tokenAddresses[z] == farmingSetupInfo.ethereumAddress) {\\n                        ethTokenFound = true;\\n                    }\\n                } else {\\n                    emit SetupToken(farmingSetupInfo.mainTokenAddress, tokenAddresses[z]);\\n                    if(tokenAddresses[z] == farmingSetupInfo.ethereumAddress) {\\n                        ethTokenFound = true;\\n                    }\\n                }\\n            }\\n            require(mainTokenFound, \\\"No main token\\\");\\n            require(!farmingSetupInfo.involvingETH || ethTokenFound, \\\"No ETH token\\\");\\n            farmingSetupInfo.setupsCount = 0;\\n            _setupsInfo[_farmingSetupsInfoCount] = farmingSetupInfo;\\n            _setups[_farmingSetupsCount] = FarmingSetup(_farmingSetupsInfoCount, false, 0, 0, 0, 0, farmingSetupInfo.originalRewardPerBlock, 0);\\n            _setupsInfo[_farmingSetupsInfoCount].lastSetupIndex = _farmingSetupsCount;\\n            _farmingSetupsInfoCount += 1;\\n            _farmingSetupsCount += 1;\\n            return;\\n        }\\n\\n        FarmingSetup storage setup = _setups[setupIndex];\\n        farmingSetupInfo = _setupsInfo[_setups[setupIndex].infoIndex];\\n\\n        if(disable) {\\n            require(setup.active, \\\"Not possible\\\");\\n            _toggleSetup(setupIndex);\\n            return;\\n        }\\n\\n        info.renewTimes -= 1;\\n\\n        if (setup.active && _setupsInfo[_setups[setupIndex].infoIndex].free) {\\n            setup = _setups[setupIndex];\\n            if(block.number < setup.endBlock) {\\n                uint256 difference = info.originalRewardPerBlock < farmingSetupInfo.originalRewardPerBlock ? farmingSetupInfo.originalRewardPerBlock - info.originalRewardPerBlock : info.originalRewardPerBlock - farmingSetupInfo.originalRewardPerBlock;\\n                uint256 duration = setup.endBlock - block.number;\\n                uint256 amount = difference * duration;\\n                if (amount > 0) {\\n                    if (info.originalRewardPerBlock > farmingSetupInfo.originalRewardPerBlock) {\\n                        require(_ensureTransfer(amount), \\\"Insufficient reward in extension.\\\");\\n                        _rewardReceived[setupIndex] += amount;\\n                    }\\n                    _updateFreeSetup(setupIndex, 0, 0, false);\\n                    setup.rewardPerBlock = info.originalRewardPerBlock;\\n                }\\n            }\\n            _setupsInfo[_setups[setupIndex].infoIndex].originalRewardPerBlock = info.originalRewardPerBlock;\\n        }\\n        if(_setupsInfo[_setups[setupIndex].infoIndex].renewTimes > 0) {\\n            _setupsInfo[_setups[setupIndex].infoIndex].renewTimes = info.renewTimes;\\n        }\\n    }\\n\\n    function _transferToMeAndCheckAllowance(FarmingSetup memory setup, FarmingPositionRequest memory request) private returns(IAMM amm, uint256 liquidityPoolAmount, uint256 mainTokenAmount) {\\n        require(request.amount > 0, \\\"No amount\\\");\\n        require(!request.amountIsLiquidityPool, \\\"LP\\\");\\n        // retrieve the values\\n        amm = IAMM(_setupsInfo[setup.infoIndex].ammPlugin);\\n        liquidityPoolAmount = request.amountIsLiquidityPool ? request.amount : 0;\\n        mainTokenAmount = request.amountIsLiquidityPool ? 0 : request.amount;\\n        address[] memory tokens;\\n        uint256[] memory tokenAmounts;\\n        // if liquidity pool token amount is provided, the position is opened by liquidity pool token amount\\n        if(request.amountIsLiquidityPool) {\\n            _safeTransferFrom(_setupsInfo[setup.infoIndex].liquidityPoolTokenAddress, msg.sender, address(this), liquidityPoolAmount);\\n            (tokenAmounts, tokens) = amm.byLiquidityPoolAmount(_setupsInfo[setup.infoIndex].liquidityPoolTokenAddress, liquidityPoolAmount);\\n        } else {\\n            // else it is opened by the tokens amounts\\n            (liquidityPoolAmount, tokenAmounts, tokens) = amm.byTokenAmount(_setupsInfo[setup.infoIndex].liquidityPoolTokenAddress, _setupsInfo[setup.infoIndex].mainTokenAddress, mainTokenAmount);\\n        }\\n\\n        // iterate the tokens and perform the transferFrom and the approve\\n        for(uint256 i = 0; i < tokens.length; i++) {\\n            if(tokens[i] == _setupsInfo[setup.infoIndex].mainTokenAddress) {\\n                mainTokenAmount = tokenAmounts[i];\\n                require(mainTokenAmount >= _setupsInfo[setup.infoIndex].minStakeable, \\\"Invalid liquidity.\\\");\\n                if(request.amountIsLiquidityPool) {\\n                    break;\\n                }\\n            }\\n            if(request.amountIsLiquidityPool) {\\n                continue;\\n            }\\n            if(_setupsInfo[setup.infoIndex].involvingETH && _setupsInfo[setup.infoIndex].ethereumAddress == tokens[i]) {\\n                require(msg.value == tokenAmounts[i], \\\"Incorrect eth value\\\");\\n            } else {\\n                _safeTransferFrom(tokens[i], msg.sender, address(this), tokenAmounts[i]);\\n                _safeApprove(tokens[i], _setupsInfo[setup.infoIndex].ammPlugin, tokenAmounts[i]);\\n            }\\n        }\\n    }\\n\\n    function _addLiquidity(uint256 setupIndex, FarmingPositionRequest memory request) private returns(LiquidityPoolData memory liquidityPoolData, uint256 tokenAmount) {\\n        (IAMM amm, uint256 liquidityPoolAmount, uint256 mainTokenAmount) = _transferToMeAndCheckAllowance(_setups[setupIndex], request);\\n        // liquidity pool data struct for the AMM\\n        liquidityPoolData = LiquidityPoolData(\\n            _setupsInfo[_setups[setupIndex].infoIndex].liquidityPoolTokenAddress,\\n            request.amountIsLiquidityPool ? liquidityPoolAmount : mainTokenAmount,\\n            _setupsInfo[_setups[setupIndex].infoIndex].mainTokenAddress,\\n            request.amountIsLiquidityPool,\\n            _setupsInfo[_setups[setupIndex].infoIndex].involvingETH,\\n            address(this)\\n        );\\n        tokenAmount = mainTokenAmount;\\n        // amount is lp check\\n        if (liquidityPoolData.amountIsLiquidityPool || !_setupsInfo[_setups[setupIndex].infoIndex].involvingETH) {\\n            require(msg.value == 0, \\\"ETH not involved\\\");\\n        }\\n        if (liquidityPoolData.amountIsLiquidityPool) {\\n            return(liquidityPoolData, tokenAmount);\\n        }\\n        // retrieve the poolTokenAmount from the amm\\n        uint256[] memory addedLiquidityAmounts;\\n        if(liquidityPoolData.involvingETH) {\\n            (liquidityPoolData.amount, addedLiquidityAmounts,) = amm.addLiquidity{value : msg.value}(liquidityPoolData);\\n        } else {\\n            (liquidityPoolData.amount, addedLiquidityAmounts,) = amm.addLiquidity(liquidityPoolData);\\n        }\\n        require(addedLiquidityAmounts[0] >= request.amount0Min, \\\"too little added\\\");\\n        require(addedLiquidityAmounts[1] >= request.amount1Min, \\\"too little added\\\");\\n    }\\n\\n    /** @dev helper function used to remove liquidity from a free position or to burn item farm tokens and retrieve their content.\\n      * @param positionId id of the position.\\n      * @param setupIndex index of the setup related to the item farm tokens.\\n      * @param isUnlock if we're removing liquidity from an unlock method or not.\\n     */\\n    function _removeLiquidity(uint256 positionId, uint256 setupIndex, uint256 removedLiquidity, bool isUnlock, uint256 amount0Min, uint256 amount1Min, bytes memory burnData) private {\\n        FarmingSetupInfo memory setupInfo = _setupsInfo[_setups[setupIndex].infoIndex];\\n        // retrieve the position\\n        FarmingPosition storage farmingPosition = _positions[positionId];\\n        // remaining liquidity\\n        uint256 remainingLiquidity;\\n        // we are removing liquidity using the setup items\\n        if (setupInfo.free && farmingPosition.creationBlock != 0 && positionId != 0) {\\n            // update the remaining liquidity\\n            remainingLiquidity = farmingPosition.liquidityPoolTokenAmount - removedLiquidity;\\n        }\\n        if (!setupInfo.free && _setups[setupIndex].active && !isUnlock) {\\n            _toggleSetup(setupIndex);\\n        } else if (setupInfo.free && positionId != 0) {\\n            if (_setups[farmingPosition.setupIndex].active && _setups[farmingPosition.setupIndex].endBlock <= block.number) {\\n                _toggleSetup(farmingPosition.setupIndex);\\n            }\\n            // delete the farming position after the withdraw\\n            if (remainingLiquidity == 0) {\\n                _setupPositionsCount[farmingPosition.setupIndex] -= 1;\\n                if (_setupPositionsCount[farmingPosition.setupIndex] == 0 && !_setups[farmingPosition.setupIndex].active) {\\n                    delete _setups[farmingPosition.setupIndex];\\n                }\\n                delete _positions[positionId];\\n            } else {\\n                // update the creation block and amount\\n                require(setupInfo.minStakeable == 0, \\\"Min stake: cannot remove partial liquidity\\\");\\n                farmingPosition.liquidityPoolTokenAmount = remainingLiquidity;\\n            }\\n        }\\n        // create liquidity pool data struct for the AMM\\n        LiquidityPoolData memory lpData = LiquidityPoolData(\\n            setupInfo.liquidityPoolTokenAddress,\\n            removedLiquidity,\\n            setupInfo.mainTokenAddress,\\n            true,\\n            setupInfo.involvingETH,\\n            burnData.length > 0 ? msg.sender : address(this)\\n        );\\n        _safeApprove(lpData.liquidityPoolAddress, setupInfo.ammPlugin, lpData.amount);\\n        (, uint256[] memory removedLiquidityAmounts, address[] memory tokens) = IAMM(setupInfo.ammPlugin).removeLiquidity(lpData);\\n        require(removedLiquidityAmounts[0] >= amount0Min, \\\"too little received\\\");\\n        require(removedLiquidityAmounts[1] >= amount1Min, \\\"too little received\\\");\\n\\n        if(burnData.length > 0 ) {\\n            _burnFee(burnData);\\n        } else {\\n            if(lpData.involvingETH) {\\n                (address eth,,) = IAMM(setupInfo.ammPlugin).data();\\n                tokens[0] = tokens[0] == eth ? address(0) : tokens[0];\\n                tokens[1] = tokens[1] == eth ? address(0) : tokens[1];\\n            }\\n            uint256 feeAmount0 = _payFee(tokens[0], removedLiquidityAmounts[0]);\\n            uint256 feeAmount1 = _payFee(tokens[1], removedLiquidityAmounts[1]);\\n            _safeTransfer(tokens[0], msg.sender, removedLiquidityAmounts[0] - feeAmount0);\\n            _safeTransfer(tokens[1], msg.sender, removedLiquidityAmounts[1] - feeAmount1);\\n        }\\n    }\\n\\n    function _payFee(address tokenAddress, uint256 feeAmount) private returns (uint256) {\\n        if(tokenAddress != address(0)) {\\n            _safeApprove(tokenAddress, IFarmFactory(initializer).initializer(), feeAmount);\\n        }\\n        return IFarmFactory(initializer).payFee{value : tokenAddress != address(0) ? 0 : feeAmount}(address(this), tokenAddress, feeAmount, \\\"\\\");\\n    }\\n\\n    function _burnFee(bytes memory burnData) private returns (uint256) {\\n        (, burnData) = abi.decode(burnData, (bool, bytes));\\n        return IFarmFactory(initializer).burnOrTransferToken(msg.sender, burnData);\\n    }\\n\\n    /** @dev updates the free setup with the given index.\\n      * @param setupIndex index of the setup that we're updating.\\n      * @param amount amount of liquidity that we're adding/removeing.\\n      * @param positionId position id.\\n      * @param fromExit if it's from an exit or not.\\n     */\\n    function _updateFreeSetup(uint256 setupIndex, uint256 amount, uint256 positionId, bool fromExit) private {\\n        uint256 currentBlock = block.number < _setups[setupIndex].endBlock ? block.number : _setups[setupIndex].endBlock;\\n        if (_setups[setupIndex].totalSupply != 0) {\\n            uint256 lastUpdateBlock = _setups[setupIndex].lastUpdateBlock < _setups[setupIndex].startBlock ? _setups[setupIndex].startBlock : _setups[setupIndex].lastUpdateBlock;\\n            _rewardPerTokenPerSetup[setupIndex] += (((currentBlock - lastUpdateBlock) * _setups[setupIndex].rewardPerBlock) * 1e18) / _setups[setupIndex].totalSupply;\\n        }\\n        // update the last block update variable\\n        _setups[setupIndex].lastUpdateBlock = currentBlock;\\n        if (positionId != 0) {\\n            _rewardPerTokenPaid[positionId] = _rewardPerTokenPerSetup[setupIndex];\\n        }\\n        if (amount > 0) {\\n            fromExit ? _setups[setupIndex].totalSupply -= amount : _setups[setupIndex].totalSupply += amount;\\n        }\\n    }\\n\\n    function _toggleSetup(uint256 setupIndex) private {\\n        FarmingSetup storage setup = _setups[setupIndex];\\n        // require(!setup.active || block.number >= setup.endBlock, \\\"Not valid activation\\\");\\n\\n        require(block.number > _setupsInfo[setup.infoIndex].startBlock, \\\"Too early for this setup\\\");\\n\\n        if (setup.active && block.number >= setup.endBlock && _setupsInfo[setup.infoIndex].renewTimes == 0) {\\n            setup.active = false;\\n            return;\\n        } else if (block.number >= setup.startBlock && block.number < setup.endBlock && setup.active) {\\n            setup.active = false;\\n            _setupsInfo[setup.infoIndex].renewTimes = 0;\\n            uint256 amount = (setup.endBlock - block.number) * setup.rewardPerBlock;\\n            setup.endBlock = block.number;\\n            if (_setupsInfo[setup.infoIndex].free) {\\n                _updateFreeSetup(setupIndex, 0, 0, false);\\n            }\\n            _rewardReceived[setupIndex] -= amount;\\n            _giveBack(amount);\\n            return;\\n        }\\n\\n        bool wasActive = setup.active;\\n        setup.active = _ensureTransfer(setup.rewardPerBlock * _setupsInfo[setup.infoIndex].blockDuration);\\n\\n        if (setup.active && wasActive) {\\n            _rewardReceived[_farmingSetupsCount] = setup.rewardPerBlock * _setupsInfo[setup.infoIndex].blockDuration;\\n            // set new setup\\n            _setups[_farmingSetupsCount] = abi.decode(abi.encode(setup), (FarmingSetup));\\n            // update old setup\\n            _setups[setupIndex].active = false;\\n            // update new setup\\n            _setupsInfo[setup.infoIndex].renewTimes -= 1;\\n            _setupsInfo[setup.infoIndex].setupsCount += 1;\\n            _setupsInfo[setup.infoIndex].lastSetupIndex = _farmingSetupsCount;\\n            _setups[_farmingSetupsCount].startBlock = block.number;\\n            _setups[_farmingSetupsCount].endBlock = block.number + _setupsInfo[_setups[_farmingSetupsCount].infoIndex].blockDuration;\\n            _setups[_farmingSetupsCount].objectId = 0;\\n            _setups[_farmingSetupsCount].totalSupply = 0;\\n            _farmingSetupsCount += 1;\\n        } else if (setup.active && !wasActive) {\\n            _rewardReceived[setupIndex] = setup.rewardPerBlock * _setupsInfo[_setups[setupIndex].infoIndex].blockDuration;\\n            // update new setup\\n            _setups[setupIndex].startBlock = block.number;\\n            _setups[setupIndex].endBlock = block.number + _setupsInfo[_setups[setupIndex].infoIndex].blockDuration;\\n            _setups[setupIndex].totalSupply = 0;\\n            _setupsInfo[_setups[setupIndex].infoIndex].renewTimes -= 1;\\n        } else {\\n            _setupsInfo[_setups[setupIndex].infoIndex].renewTimes = 0;\\n        }\\n    }\\n\\n\\n    /** @dev function used to safely approve ERC20 transfers.\\n      * @param erc20TokenAddress address of the token to approve.\\n      * @param to receiver of the approval.\\n      * @param value amount to approve for.\\n     */\\n    function _safeApprove(address erc20TokenAddress, address to, uint256 value) internal virtual {\\n        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).approve.selector, to, value));\\n        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'APPROVE_FAILED');\\n    }\\n\\n    /** @dev function used to safe transfer ERC20 tokens.\\n      * @param erc20TokenAddress address of the token to transfer.\\n      * @param to receiver of the tokens.\\n      * @param value amount of tokens to transfer.\\n     */\\n    function _safeTransfer(address erc20TokenAddress, address to, uint256 value) internal virtual {\\n        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\\n        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\\n    }\\n\\n    /** @dev this function safely transfers the given ERC20 value from an address to another.\\n      * @param erc20TokenAddress erc20 token address.\\n      * @param from address from.\\n      * @param to address to.\\n      * @param value amount to transfer.\\n     */\\n    function _safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) private {\\n        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\\n        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\\n    }\\n\\n    /** @dev calls the contract at the given location using the given payload and returns the returnData.\\n      * @param location location to call.\\n      * @param payload call payload.\\n      * @return returnData call return data.\\n     */\\n    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\\n        assembly {\\n            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\\n            let size := returndatasize()\\n            returnData := mload(0x40)\\n            mstore(returnData, size)\\n            let returnDataPayloadStart := add(returnData, 0x20)\\n            returndatacopy(returnDataPayloadStart, 0, size)\\n            mstore(0x40, add(returnDataPayloadStart, size))\\n            switch result case 0 {revert(returnDataPayloadStart, size)}\\n        }\\n    }\\n\\n    /** @dev returns the input address to string.\\n      * @param _addr address to convert as string.\\n      * @return address as string.\\n     */\\n    function _toString(address _addr) internal pure returns(string memory) {\\n        bytes32 value = bytes32(uint256(_addr));\\n        bytes memory alphabet = \\\"0123456789abcdef\\\";\\n\\n        bytes memory str = new bytes(42);\\n        str[0] = '0';\\n        str[1] = 'x';\\n        for (uint i = 0; i < 20; i++) {\\n            str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];\\n            str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\\n        }\\n        return string(str);\\n    }\\n\\n    /** @dev gives back the reward to the extension.\\n      * @param amount to give back.\\n     */\\n    function _giveBack(uint256 amount) private {\\n        if(amount == 0) {\\n            return;\\n        }\\n        if (_rewardTokenAddress == address(0)) {\\n            IFarmExtensionGen1(host).backToYou{value : amount}(amount);\\n        } else {\\n            _safeApprove(_rewardTokenAddress, host, amount);\\n            IFarmExtensionGen1(host).backToYou(amount);\\n        }\\n    }\\n\\n    /** @dev ensures the transfer from the contract to the extension.\\n      * @param amount amount to transfer.\\n     */\\n    function _ensureTransfer(uint256 amount) private returns(bool) {\\n        uint256 initialBalance = _rewardTokenAddress == address(0) ? address(this).balance : IERC20(_rewardTokenAddress).balanceOf(address(this));\\n        uint256 expectedBalance = initialBalance + amount;\\n        try IFarmExtensionGen1(host).transferTo(amount) {} catch {}\\n        uint256 actualBalance = _rewardTokenAddress == address(0) ? address(this).balance : IERC20(_rewardTokenAddress).balanceOf(address(this));\\n        if(actualBalance == expectedBalance) {\\n            return true;\\n        }\\n        _giveBack(actualBalance - initialBalance);\\n        return false;\\n    }\\n}\\n\\ninterface IFarmFactory {\\n    function initializer() external view returns (address);\\n    function payFee(address sender, address tokenAddress, uint256 value, bytes calldata permitSignature) external payable returns (uint256 feePaid);\\n    function burnOrTransferToken(address sender, bytes calldata permitSignature) external payable returns(uint256 amountTransferedOrBurnt);\\n}\"\r\n    },\r\n    \"contracts/farming/util/INativeV1.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0;\\n\\nimport \\\"./IEthItem.sol\\\";\\n\\ninterface INativeV1 is IEthItem {\\n\\n    function init(string calldata name, string calldata symbol, bool hasDecimals, string calldata collectionUri, address extensionAddress, bytes calldata extensionInitPayload) external returns(bytes memory extensionInitCallResponse);\\n    function extension() external view returns (address extensionAddress);\\n    function canMint(address operator) external view returns (bool result);\\n    function isEditable(uint256 objectId) external view returns (bool result);\\n    function releaseExtension() external;\\n    function uri() external view returns (string memory);\\n    function decimals() external view returns (uint256);\\n    function mint(uint256 amount, string calldata tokenName, string calldata tokenSymbol, string calldata objectUri, bool editable) external returns (uint256 objectId, address tokenAddress);\\n    function mint(uint256 amount, string calldata tokenName, string calldata tokenSymbol, string calldata objectUri) external returns (uint256 objectId, address tokenAddress);\\n    function mint(uint256 objectId, uint256 amount) external;\\n    function makeReadOnly(uint256 objectId) external;\\n    function setUri(string calldata newUri) external;\\n    function setUri(uint256 objectId, string calldata newUri) external;\\n}\"\r\n    },\r\n    \"contracts/farming/util/IEthItemOrchestrator.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0;\\n\\ninterface IEthItemOrchestrator {\\n    function createNative(bytes calldata modelInitPayload, string calldata ens)\\n        external\\n        returns (address newNativeAddress, bytes memory modelInitCallResponse);\\n}\"\r\n    },\r\n    \"contracts/farming/util/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0;\\n\\ninterface IERC20 {\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function safeApprove(address spender, uint256 amount) external;\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/farming/IFarmExtensionGen1.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"./FarmDataGen1.sol\\\";\\n\\ninterface IFarmExtensionGen1 {\\n\\n    function init(bool byMint, address host, address treasury) external;\\n\\n    function setHost(address host) external;\\n    function setTreasury(address treasury) external;\\n\\n    function data() external view returns(address farmMainContract, bool byMint, address host, address treasury, address rewardTokenAddress);\\n\\n    function transferTo(uint256 amount) external;\\n    function backToYou(uint256 amount) external payable;\\n\\n    function setFarmingSetups(FarmingSetupConfiguration[] memory farmingSetups) external;\\n\\n}\"\r\n    },\r\n    \"contracts/farming/IFarmMainGen1.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"./FarmDataGen1.sol\\\";\\n\\ninterface IFarmMainGen1 {\\n\\n    function ONE_HUNDRED() external view returns(uint256);\\n    function _rewardTokenAddress() external view returns(address);\\n    function position(uint256 positionId) external view returns (FarmingPosition memory);\\n    function setups() external view returns (FarmingSetup[] memory);\\n    function setup(uint256 setupIndex) external view returns (FarmingSetup memory, FarmingSetupInfo memory);\\n    function setFarmingSetups(FarmingSetupConfiguration[] memory farmingSetups) external;\\n    function openPosition(FarmingPositionRequest calldata request) external payable returns(uint256 positionId);\\n    function addLiquidity(uint256 positionId, FarmingPositionRequest calldata request) external payable;\\n}\"\r\n    },\r\n    \"contracts/amm-aggregator/common/IAMM.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\npragma abicoder v2;\\n\\nimport \\\"./AMMData.sol\\\";\\n\\ninterface IAMM {\\n\\n    event NewLiquidityPoolAddress(address indexed);\\n\\n    function info() external view returns(string memory name, uint256 version);\\n\\n    function data() external view returns(address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools);\\n\\n    function balanceOf(address liquidityPoolAddress, address owner) external view returns(uint256, uint256[] memory, address[] memory);\\n\\n    function byLiquidityPool(address liquidityPoolAddress) external view returns(uint256, uint256[] memory, address[] memory);\\n\\n    function byTokens(address[] calldata liquidityPoolTokens) external view returns(uint256, uint256[] memory, address, address[] memory);\\n\\n    function byPercentage(address liquidityPoolAddress, uint256 numerator, uint256 denominator) external view returns (uint256, uint256[] memory, address[] memory);\\n\\n    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) external view returns(uint256[] memory, address[] memory);\\n\\n    function byTokenAmount(address liquidityPoolAddress, address tokenAddress, uint256 tokenAmount) external view returns(uint256, uint256[] memory, address[] memory);\\n\\n    function createLiquidityPoolAndAddLiquidity(address[] calldata tokenAddresses, uint256[] calldata amounts, bool involvingETH, address receiver) external payable returns(uint256, uint256[] memory, address, address[] memory);\\n\\n    function addLiquidity(LiquidityPoolData calldata data) external payable returns(uint256, uint256[] memory, address[] memory);\\n    function addLiquidityBatch(LiquidityPoolData[] calldata data) external payable returns(uint256[] memory, uint256[][] memory, address[][] memory);\\n\\n    function removeLiquidity(LiquidityPoolData calldata data) external returns(uint256, uint256[] memory, address[] memory);\\n    function removeLiquidityBatch(LiquidityPoolData[] calldata data) external returns(uint256[] memory, uint256[][] memory, address[][] memory);\\n\\n    function getSwapOutput(address tokenAddress, uint256 tokenAmount, address[] calldata, address[] calldata path) view external returns(uint256[] memory);\\n\\n    function swapLiquidity(SwapData calldata data) external payable returns(uint256);\\n    function swapLiquidityBatch(SwapData[] calldata data) external payable returns(uint256[] memory);\\n}\"\r\n    },\r\n    \"contracts/farming/util/IEthItem.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IEthItemInteroperableInterface.sol\\\";\\n\\ninterface IEthItem is IERC1155 {\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function totalSupply(uint256 objectId) external view returns (uint256);\\n\\n    function name(uint256 objectId) external view returns (string memory);\\n\\n    function symbol(uint256 objectId) external view returns (string memory);\\n\\n    function decimals(uint256 objectId) external view returns (uint256);\\n\\n    function uri(uint256 objectId) external view returns (string memory);\\n\\n    function mainInterfaceVersion() external pure returns(uint256 ethItemInteroperableVersion);\\n\\n    function toInteroperableInterfaceAmount(uint256 objectId, uint256 ethItemAmount) external view returns (uint256 interoperableInterfaceAmount);\\n\\n    function toMainInterfaceAmount(uint256 objectId, uint256 erc20WrapperAmount) external view returns (uint256 mainInterfaceAmount);\\n\\n    function interoperableInterfaceModel() external view returns (address, uint256);\\n\\n    function asInteroperable(uint256 objectId) external view returns (IEthItemInteroperableInterface);\\n\\n    function emitTransferSingleEvent(address sender, address from, address to, uint256 objectId, uint256 amount) external;\\n\\n    function mint(uint256 amount, string calldata partialUri)\\n        external\\n        returns (uint256, address);\\n\\n    function burn(\\n        uint256 objectId,\\n        uint256 amount\\n    ) external;\\n\\n    function burnBatch(\\n        uint256[] calldata objectIds,\\n        uint256[] calldata amounts\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/farming/FarmDataGen1.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\n\\nstruct FarmingPositionRequest {\\n    uint256 setupIndex; // index of the chosen setup.\\n    uint256 amount; // amount of main token or liquidity pool token.\\n    bool amountIsLiquidityPool; //true if user wants to directly share the liquidity pool token amount, false to add liquidity to AMM\\n    address positionOwner; // position extension or address(0) [msg.sender].\\n    uint256 amount0Min;\\n    uint256 amount1Min;\\n}\\n\\nstruct FarmingSetupConfiguration {\\n    bool add; // true if we're adding a new setup, false we're updating it.\\n    bool disable;\\n    uint256 index; // index of the setup we're updating.\\n    FarmingSetupInfo info; // data of the new or updated setup\\n}\\n\\nstruct FarmingSetupInfo {\\n    bool free; // if the setup is a free farming setup or a locked one.\\n    uint256 blockDuration; // duration of setup\\n    uint256 startBlock; // optional start block used for the delayed activation of the first setup\\n    uint256 originalRewardPerBlock;\\n    uint256 minStakeable; // minimum amount of staking tokens.\\n    uint256 maxStakeable; // maximum amount stakeable in the setup (used only if free is false).\\n    uint256 renewTimes; // if the setup is renewable or if it's one time.\\n    address ammPlugin; // amm plugin address used for this setup (eg. uniswap amm plugin address).\\n    address liquidityPoolTokenAddress; // address of the liquidity pool token\\n    address mainTokenAddress; // eg. buidl address.\\n    address ethereumAddress;\\n    bool involvingETH; // if the setup involves ETH or not.\\n    uint256 penaltyFee; // fee paid when the user exits a still active locked farming setup (used only if free is false).\\n    uint256 setupsCount; // number of setups created by this info.\\n    uint256 lastSetupIndex; // index of last setup;\\n}\\n\\nstruct FarmingSetup {\\n    uint256 infoIndex; // setup info\\n    bool active; // if the setup is active or not.\\n    uint256 startBlock; // farming setup start block.\\n    uint256 endBlock; // farming setup end block.\\n    uint256 lastUpdateBlock; // number of the block where an update was triggered.\\n    uint256 objectId; // items object id for the liquidity pool token (used only if free is false).\\n    uint256 rewardPerBlock; // farming setup reward per single block.\\n    uint256 totalSupply; // If free it's the LP amount, if locked is currentlyStaked.\\n}\\n\\nstruct FarmingPosition {\\n    address uniqueOwner; // address representing the owner of the position.\\n    uint256 setupIndex; // the setup index related to this position.\\n    uint256 creationBlock; // block when this position was created.\\n    uint256 liquidityPoolTokenAmount; // amount of liquidity pool token in the position.\\n    uint256 mainTokenAmount; // amount of main token in the position (used only if free is false).\\n    uint256 reward; // position reward (used only if free is false).\\n    uint256 lockedRewardPerBlock; // position locked reward per block (used only if free is false).\\n}\"\r\n    },\r\n    \"contracts/amm-aggregator/common/AMMData.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0;\\n\\nstruct LiquidityPoolData {\\n    address liquidityPoolAddress;\\n    uint256 amount;\\n    address tokenAddress;\\n    bool amountIsLiquidityPool;\\n    bool involvingETH;\\n    address receiver;\\n}\\n\\nstruct SwapData {\\n    bool enterInETH;\\n    bool exitInETH;\\n    address[] liquidityPoolAddresses;\\n    address[] path;\\n    address inputToken;\\n    uint256 amount;\\n    address receiver;\\n}\"\r\n    },\r\n    \"contracts/farming/util/IEthItemInteroperableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IEthItemInteroperableInterface is IERC20 {\\n\\n    function mainInterface() external view returns (address);\\n\\n    function objectId() external view returns (uint256);\\n\\n    function mint(address owner, uint256 amount) external;\\n\\n    function burn(address owner, uint256 amount) external;\\n\\n    function permitNonce(address sender) external view returns(uint256);\\n\\n    function permit(address owner, address spender, uint value, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    function interoperableInterfaceVersion() external pure returns(uint256 ethItemInteroperableInterfaceVersion);\\n}\"\r\n    },\r\n    \"contracts/farming/util/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0;\\n\\ninterface IERC1155 {\\n\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"objectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityPoolToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"}],\"name\":\"FarmToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"}],\"name\":\"RewardToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mainToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"involvedToken\",\"type\":\"address\"}],\"name\":\"SetupToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ONE_HUNDRED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_farmingSetupsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_farmingSetupsInfoCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_partiallyRedeemed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_rewardPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_rewardReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rewardTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"setupInfoIndex\",\"type\":\"uint256\"}],\"name\":\"activateSetup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"amountIsLiquidityPool\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"positionOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmingPositionRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isExt\",\"type\":\"bool\"}],\"name\":\"calculateFreeFarmingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mainTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPartial\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"calculateLockedFarmingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"relativeRewardPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"finalFlush\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"host\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initPayload\",\"type\":\"bytes\"}],\"name\":\"lazyInit\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"extensionReturnCall\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"amountIsLiquidityPool\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"positionOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmingPositionRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"name\":\"openPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"position\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"uniqueOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityPoolTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mainTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedRewardPerBlock\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmingPosition\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"free\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"blockDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originalRewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minStakeable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakeable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"renewTimes\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ammPlugin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityPoolTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mainTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ethereumAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"involvingETH\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"penaltyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setupsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastSetupIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmingSetupInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"internalType\":\"struct FarmingSetupConfiguration[]\",\"name\":\"farmingSetups\",\"type\":\"tuple[]\"}],\"name\":\"setFarmingSetups\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"setupIndex\",\"type\":\"uint256\"}],\"name\":\"setup\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"infoIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"objectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmingSetup\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"free\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"blockDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originalRewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minStakeable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakeable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"renewTimes\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ammPlugin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityPoolTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mainTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ethereumAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"involvingETH\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"penaltyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setupsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastSetupIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmingSetupInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setups\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"infoIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"objectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmingSetup[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"setupInfoIndex\",\"type\":\"uint256\"}],\"name\":\"toggleSetup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"objectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"removedLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"burnData\",\"type\":\"bytes\"}],\"name\":\"withdrawLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"withdrawReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FarmMainGen1V2", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}