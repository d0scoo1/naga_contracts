{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/aps/APContractV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.13;\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport \\\"../interfaces/IPriceModule.sol\\\";\\r\\nimport \\\"../interfaces/IHexUtils.sol\\\";\\r\\n\\r\\ncontract APContractV2 is Initializable {\\r\\n    address public yieldsterDAO;\\r\\n\\r\\n    address public yieldsterTreasury;\\r\\n\\r\\n    address public yieldsterGOD;\\r\\n\\r\\n    address public emergencyVault;\\r\\n\\r\\n    address public yieldsterExchange;\\r\\n\\r\\n    address public stringUtils;\\r\\n\\r\\n    address public whitelistModule;\\r\\n\\r\\n    address public proxyFactory;\\r\\n\\r\\n    address public priceModule;\\r\\n\\r\\n    address public safeMinter;\\r\\n\\r\\n    address public safeUtils;\\r\\n\\r\\n    address public exchangeRegistry;\\r\\n\\r\\n    address public stockDeposit;\\r\\n\\r\\n    address public stockWithdraw;\\r\\n\\r\\n    address public platFormManagementFee;\\r\\n\\r\\n    address public profitManagementFee;\\r\\n\\r\\n    address public wEth;\\r\\n\\r\\n    address public sdkContract;\\r\\n\\r\\n    address public mStorage;\\r\\n\\r\\n    struct Vault {\\r\\n        mapping(address => bool) vaultAssets;\\r\\n        mapping(address => bool) vaultDepositAssets;\\r\\n        mapping(address => bool) vaultWithdrawalAssets;\\r\\n        address depositStrategy;\\r\\n        address withdrawStrategy;\\r\\n        uint256[] whitelistGroup;\\r\\n        address vaultAdmin;\\r\\n        bool created;\\r\\n        uint256 slippage;\\r\\n    }\\r\\n\\r\\n    mapping(address => bool) assets;\\r\\n\\r\\n    mapping(address => Vault) vaults;\\r\\n\\r\\n    mapping(address => bool) vaultCreated;\\r\\n\\r\\n    mapping(address => bool) APSManagers;\\r\\n\\r\\n    mapping(address => uint256) vaultsOwnedByAdmin;\\r\\n\\r\\n    struct SmartStrategy {\\r\\n        address minter;\\r\\n        address executor;\\r\\n        bool created;\\r\\n    }\\r\\n\\r\\n    mapping(address => SmartStrategy) smartStrategies;\\r\\n\\r\\n    mapping(address => address) minterStrategyMap;\\r\\n\\r\\n    struct vaultActiveManagemetFee {\\r\\n        mapping(address => bool) isActiveManagementFee;\\r\\n        mapping(address => uint256) activeManagementFeeIndex;\\r\\n        address[] activeManagementFeeList;\\r\\n    }\\r\\n\\r\\n    mapping(address => vaultActiveManagemetFee) managementFeeStrategies;\\r\\n\\r\\n    mapping(address => bool) permittedWalletAddresses;\\r\\n\\r\\n    /// @dev Function to initialize addresses.\\r\\n    /// @param _yieldsterDAO Address of yieldsterDAO.\\r\\n    /// @param _yieldsterTreasury Address of yieldsterTreasury.\\r\\n    /// @param _yieldsterGOD Address of yieldsterGOD.\\r\\n    /// @param _emergencyVault Address of emergencyVault.\\r\\n    /// @param _apsAdmin Address of apsAdmin.\\r\\n    function initialize(\\r\\n        address _yieldsterDAO,\\r\\n        address _yieldsterTreasury,\\r\\n        address _yieldsterGOD,\\r\\n        address _emergencyVault,\\r\\n        address _apsAdmin\\r\\n    ) public initializer {\\r\\n        yieldsterDAO = _yieldsterDAO;\\r\\n        yieldsterTreasury = _yieldsterTreasury;\\r\\n        yieldsterGOD = _yieldsterGOD;\\r\\n        emergencyVault = _emergencyVault;\\r\\n        APSManagers[_apsAdmin] = true;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set initial values.\\r\\n    /// @param _whitelistModule Address of whitelistModule.\\r\\n    /// @param _platformManagementFee Address of platformManagementFee.\\r\\n    /// @param _profitManagementFee Address of profitManagementFee.\\r\\n    /// @param _stringUtils Address of stringUtils.\\r\\n    /// @param _yieldsterExchange Address of yieldsterExchange.\\r\\n    /// @param _exchangeRegistry Address of exchangeRegistry.\\r\\n    /// @param _priceModule Address of priceModule.\\r\\n    /// @param _safeUtils Address of safeUtils.\\r\\n    function setInitialValues(\\r\\n        address _whitelistModule,\\r\\n        address _platformManagementFee,\\r\\n        address _profitManagementFee,\\r\\n        address _stringUtils,\\r\\n        address _yieldsterExchange,\\r\\n        address _exchangeRegistry,\\r\\n        address _priceModule,\\r\\n        address _safeUtils,\\r\\n        address _mStorage\\r\\n    ) public onlyYieldsterDAO {\\r\\n        whitelistModule = _whitelistModule;\\r\\n        platFormManagementFee = _platformManagementFee;\\r\\n        stringUtils = _stringUtils;\\r\\n        yieldsterExchange = _yieldsterExchange;\\r\\n        exchangeRegistry = _exchangeRegistry;\\r\\n        priceModule = _priceModule;\\r\\n        safeUtils = _safeUtils;\\r\\n        profitManagementFee = _profitManagementFee;\\r\\n        mStorage = _mStorage;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to add proxy Factory address to Yieldster.\\r\\n    /// @param _proxyFactory Address of proxy factory.\\r\\n    function addProxyFactory(address _proxyFactory) public onlyManager {\\r\\n        proxyFactory = _proxyFactory;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to add vault Admin to Yieldster.\\r\\n    /// @param _manager Address of the manager.\\r\\n    function addManager(address _manager) public onlyYieldsterDAO {\\r\\n        APSManagers[_manager] = true;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to remove vault Admin from Yieldster.\\r\\n    /// @param _manager Address of the manager.\\r\\n    function removeManager(address _manager) public onlyYieldsterDAO {\\r\\n        APSManagers[_manager] = false;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set Yieldster GOD.\\r\\n    /// @param _yieldsterGOD Address of the Yieldster GOD.\\r\\n    function setYieldsterGOD(address _yieldsterGOD) public {\\r\\n        require(\\r\\n            msg.sender == yieldsterGOD,\\r\\n            \\\"Only Yieldster GOD can perform this operation\\\"\\r\\n        );\\r\\n        yieldsterGOD = _yieldsterGOD;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set Yieldster DAO.\\r\\n    /// @param _yieldsterDAO Address of the Yieldster DAO.\\r\\n    function setYieldsterDAO(address _yieldsterDAO) public {\\r\\n        require(\\r\\n            msg.sender == yieldsterDAO,\\r\\n            \\\"Only Yieldster DAO can perform this operation\\\"\\r\\n        );\\r\\n        yieldsterDAO = _yieldsterDAO;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set Yieldster Treasury.\\r\\n    /// @param _yieldsterTreasury Address of the Yieldster Treasury.\\r\\n    function setYieldsterTreasury(address _yieldsterTreasury) public {\\r\\n        require(\\r\\n            msg.sender == yieldsterDAO,\\r\\n            \\\"Only Yieldster DAO can perform this operation\\\"\\r\\n        );\\r\\n        yieldsterTreasury = _yieldsterTreasury;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to disable Yieldster GOD.\\r\\n    function disableYieldsterGOD() public {\\r\\n        require(\\r\\n            msg.sender == yieldsterGOD,\\r\\n            \\\"Only Yieldster GOD can perform this operation\\\"\\r\\n        );\\r\\n        yieldsterGOD = address(0);\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set Emergency vault.\\r\\n    /// @param _emergencyVault Address of the Yieldster Emergency vault.\\r\\n    function setEmergencyVault(address _emergencyVault)\\r\\n        public\\r\\n        onlyYieldsterDAO\\r\\n    {\\r\\n        emergencyVault = _emergencyVault;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set Safe Minter.\\r\\n    /// @param _safeMinter Address of the Safe Minter.\\r\\n    function setSafeMinter(address _safeMinter) public onlyYieldsterDAO {\\r\\n        safeMinter = _safeMinter;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set safeUtils contract.\\r\\n    /// @param _safeUtils Address of the safeUtils contract.\\r\\n    function setSafeUtils(address _safeUtils) public onlyYieldsterDAO {\\r\\n        safeUtils = _safeUtils;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set stringUtils contract.\\r\\n    /// @param _stringUtils Address of the stringUtils contract.\\r\\n    function setStringUtils(address _stringUtils) public onlyYieldsterDAO {\\r\\n        stringUtils = _stringUtils;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set whitelistModule contract.\\r\\n    /// @param _whitelistModule Address of the whitelistModule contract.\\r\\n    function setWhitelistModule(address _whitelistModule)\\r\\n        public\\r\\n        onlyYieldsterDAO\\r\\n    {\\r\\n        whitelistModule = _whitelistModule;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set exchangeRegistry address.\\r\\n    /// @param _exchangeRegistry Address of the exchangeRegistry.\\r\\n    function setExchangeRegistry(address _exchangeRegistry)\\r\\n        public\\r\\n        onlyYieldsterDAO\\r\\n    {\\r\\n        exchangeRegistry = _exchangeRegistry;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set Yieldster Exchange.\\r\\n    /// @param _yieldsterExchange Address of the Yieldster exchange.\\r\\n    function setYieldsterExchange(address _yieldsterExchange)\\r\\n        public\\r\\n        onlyYieldsterDAO\\r\\n    {\\r\\n        yieldsterExchange = _yieldsterExchange;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to change the vault Admin for a vault.\\r\\n    /// @param _vaultAdmin Address of the new APS Manager.\\r\\n    function changeVaultAdmin(address _vaultAdmin) external {\\r\\n        require(vaults[msg.sender].created, \\\"Vault is not present\\\");\\r\\n        vaultsOwnedByAdmin[vaults[msg.sender].vaultAdmin] =\\r\\n            vaultsOwnedByAdmin[vaults[msg.sender].vaultAdmin] -\\r\\n            1;\\r\\n        vaultsOwnedByAdmin[_vaultAdmin] = vaultsOwnedByAdmin[_vaultAdmin] + 1;\\r\\n        vaults[msg.sender].vaultAdmin = _vaultAdmin;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to change the Slippage Settings for a vault.\\r\\n    /// @param _slippage value of slippage.\\r\\n    function setVaultSlippage(uint256 _slippage) external {\\r\\n        require(vaults[msg.sender].created, \\\"Vault is not present\\\");\\r\\n        vaults[msg.sender].slippage = _slippage;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to get the Slippage Settings for a vault.\\r\\n    function getVaultSlippage() external view returns (uint256) {\\r\\n        require(vaults[msg.sender].created, \\\"Vault is not present\\\");\\r\\n        return vaults[msg.sender].slippage;\\r\\n    }\\r\\n\\r\\n    //Price Module\\r\\n    /// @dev Function to set Yieldster price module.\\r\\n    /// @param _priceModule Address of the price module.\\r\\n    function setPriceModule(address _priceModule) public onlyManager {\\r\\n        priceModule = _priceModule;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to get the USD price for a token.\\r\\n    /// @param _tokenAddress Address of the token.\\r\\n    function getUSDPrice(address _tokenAddress) public view returns (uint256) {\\r\\n        return IPriceModule(priceModule).getUSDPrice(_tokenAddress);\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set Management Fee Strategies.\\r\\n    /// @param _platformManagement Address of the Platform Management Fee Strategy\\r\\n    /// @param _profitManagement Address of the Profit Management Fee Strategy\\r\\n    function setProfitAndPlatformManagementFeeStrategies(\\r\\n        address _platformManagement,\\r\\n        address _profitManagement\\r\\n    ) public onlyYieldsterDAO {\\r\\n        if (_profitManagement != address(0))\\r\\n            profitManagementFee = _profitManagement;\\r\\n        if (_platformManagement != address(0))\\r\\n            platFormManagementFee = _platformManagement;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to get the list of management fee strategies applied to the vault.\\r\\n    function getVaultManagementFee() public view returns (address[] memory) {\\r\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\r\\n        return managementFeeStrategies[msg.sender].activeManagementFeeList;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to add the management fee strategies applied to a vault.\\r\\n    /// @param _vaultAddress Address of the vault.\\r\\n    /// @param _managementFeeAddress Address of the management fee strategy.\\r\\n    function addManagementFeeStrategies(\\r\\n        address _vaultAddress,\\r\\n        address _managementFeeAddress\\r\\n    ) public {\\r\\n        require(vaults[_vaultAddress].created, \\\"Vault not present\\\");\\r\\n        require(\\r\\n            vaults[_vaultAddress].vaultAdmin == msg.sender,\\r\\n            \\\"Sender not Authorized\\\"\\r\\n        );\\r\\n        managementFeeStrategies[_vaultAddress].isActiveManagementFee[\\r\\n            _managementFeeAddress\\r\\n        ] = true;\\r\\n        managementFeeStrategies[_vaultAddress].activeManagementFeeIndex[\\r\\n                _managementFeeAddress\\r\\n            ] = managementFeeStrategies[_vaultAddress]\\r\\n            .activeManagementFeeList\\r\\n            .length;\\r\\n        managementFeeStrategies[_vaultAddress].activeManagementFeeList.push(\\r\\n            _managementFeeAddress\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Function to deactivate a vault strategy.\\r\\n    /// @param _vaultAddress Address of the Vault.\\r\\n    /// @param _managementFeeAddress Address of the Management Fee Strategy.\\r\\n    function removeManagementFeeStrategies(\\r\\n        address _vaultAddress,\\r\\n        address _managementFeeAddress\\r\\n    ) public {\\r\\n        require(vaults[_vaultAddress].created, \\\"Vault not present\\\");\\r\\n        require(\\r\\n            managementFeeStrategies[_vaultAddress].isActiveManagementFee[\\r\\n                _managementFeeAddress\\r\\n            ],\\r\\n            \\\"Provided ManagementFee is not active\\\"\\r\\n        );\\r\\n        require(\\r\\n            vaults[_vaultAddress].vaultAdmin == msg.sender ||\\r\\n                yieldsterDAO == msg.sender,\\r\\n            \\\"Sender not Authorized\\\"\\r\\n        );\\r\\n        require(\\r\\n            platFormManagementFee != _managementFeeAddress ||\\r\\n                yieldsterDAO == msg.sender,\\r\\n            \\\"Platfrom Management only changable by dao!\\\"\\r\\n        );\\r\\n        managementFeeStrategies[_vaultAddress].isActiveManagementFee[\\r\\n            _managementFeeAddress\\r\\n        ] = false;\\r\\n\\r\\n        if (\\r\\n            managementFeeStrategies[_vaultAddress]\\r\\n                .activeManagementFeeList\\r\\n                .length == 1\\r\\n        ) {\\r\\n            managementFeeStrategies[_vaultAddress].activeManagementFeeList.pop();\\r\\n        } else {\\r\\n            uint256 index = managementFeeStrategies[_vaultAddress]\\r\\n                .activeManagementFeeIndex[_managementFeeAddress];\\r\\n            uint256 lastIndex = managementFeeStrategies[_vaultAddress]\\r\\n                .activeManagementFeeList\\r\\n                .length - 1;\\r\\n            delete managementFeeStrategies[_vaultAddress]\\r\\n                .activeManagementFeeList[index];\\r\\n            managementFeeStrategies[_vaultAddress].activeManagementFeeIndex[\\r\\n                    managementFeeStrategies[_vaultAddress]\\r\\n                        .activeManagementFeeList[lastIndex]\\r\\n                ] = index;\\r\\n            managementFeeStrategies[_vaultAddress].activeManagementFeeList[\\r\\n                    index\\r\\n                ] = managementFeeStrategies[_vaultAddress]\\r\\n                .activeManagementFeeList[lastIndex];\\r\\n            managementFeeStrategies[_vaultAddress].activeManagementFeeList.pop();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Function to create a vault.\\r\\n    /// @param _vaultAddress Address of the new vault.\\r\\n    function setVaultStatus(address _vaultAddress) public {\\r\\n        require(\\r\\n            msg.sender == proxyFactory,\\r\\n            \\\"Only Proxy Factory can perform this operation\\\"\\r\\n        );\\r\\n        vaultCreated[_vaultAddress] = true;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to add a vault in the APS.\\r\\n    /// @param _vaultAdmin Address of the vaults APS Manager.\\r\\n    /// @param _whitelistGroup List of whitelist groups applied to the vault.\\r\\n    function addVault(address _vaultAdmin, uint256[] memory _whitelistGroup)\\r\\n        public\\r\\n    {\\r\\n        require(vaultCreated[msg.sender], \\\"Vault not created\\\");\\r\\n        Vault storage newVault = vaults[msg.sender];\\r\\n        newVault.vaultAdmin = _vaultAdmin;\\r\\n        newVault.depositStrategy = stockDeposit;\\r\\n        newVault.withdrawStrategy = stockWithdraw;\\r\\n        newVault.whitelistGroup = _whitelistGroup;\\r\\n        newVault.created = true;\\r\\n        newVault.slippage = 50;\\r\\n        vaultsOwnedByAdmin[_vaultAdmin] = vaultsOwnedByAdmin[_vaultAdmin] + 1;\\r\\n\\r\\n        // applying Platform management fee\\r\\n        managementFeeStrategies[msg.sender].isActiveManagementFee[\\r\\n            platFormManagementFee\\r\\n        ] = true;\\r\\n        managementFeeStrategies[msg.sender].activeManagementFeeIndex[\\r\\n                platFormManagementFee\\r\\n            ] = managementFeeStrategies[msg.sender]\\r\\n            .activeManagementFeeList\\r\\n            .length;\\r\\n        managementFeeStrategies[msg.sender].activeManagementFeeList.push(\\r\\n            platFormManagementFee\\r\\n        );\\r\\n\\r\\n        //applying Profit management fee\\r\\n        managementFeeStrategies[msg.sender].isActiveManagementFee[\\r\\n            profitManagementFee\\r\\n        ] = true;\\r\\n        managementFeeStrategies[msg.sender].activeManagementFeeIndex[\\r\\n                profitManagementFee\\r\\n            ] = managementFeeStrategies[msg.sender]\\r\\n            .activeManagementFeeList\\r\\n            .length;\\r\\n        managementFeeStrategies[msg.sender].activeManagementFeeList.push(\\r\\n            profitManagementFee\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Function to Manage the vault assets.\\r\\n    /// @param _enabledDepositAsset List of deposit assets to be enabled in the vault.\\r\\n    /// @param _enabledWithdrawalAsset List of withdrawal assets to be enabled in the vault.\\r\\n    /// @param _disabledDepositAsset List of deposit assets to be disabled in the vault.\\r\\n    /// @param _disabledWithdrawalAsset List of withdrawal assets to be disabled in the vault.\\r\\n    function setVaultAssets(\\r\\n        address[] memory _enabledDepositAsset,\\r\\n        address[] memory _enabledWithdrawalAsset,\\r\\n        address[] memory _disabledDepositAsset,\\r\\n        address[] memory _disabledWithdrawalAsset\\r\\n    ) public {\\r\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\r\\n\\r\\n        for (uint256 i = 0; i < _enabledDepositAsset.length; i++) {\\r\\n            address asset = _enabledDepositAsset[i];\\r\\n            require(_isAssetPresent(asset), \\\"Asset not supported by Yieldster\\\");\\r\\n            vaults[msg.sender].vaultAssets[asset] = true;\\r\\n            vaults[msg.sender].vaultDepositAssets[asset] = true;\\r\\n        }\\r\\n\\r\\n        for (uint256 i = 0; i < _enabledWithdrawalAsset.length; i++) {\\r\\n            address asset = _enabledWithdrawalAsset[i];\\r\\n            require(_isAssetPresent(asset), \\\"Asset not supported by Yieldster\\\");\\r\\n            vaults[msg.sender].vaultAssets[asset] = true;\\r\\n            vaults[msg.sender].vaultWithdrawalAssets[asset] = true;\\r\\n        }\\r\\n\\r\\n        for (uint256 i = 0; i < _disabledDepositAsset.length; i++) {\\r\\n            address asset = _disabledDepositAsset[i];\\r\\n            require(_isAssetPresent(asset), \\\"Asset not supported by Yieldster\\\");\\r\\n            vaults[msg.sender].vaultAssets[asset] = false;\\r\\n            vaults[msg.sender].vaultDepositAssets[asset] = false;\\r\\n        }\\r\\n\\r\\n        for (uint256 i = 0; i < _disabledWithdrawalAsset.length; i++) {\\r\\n            address asset = _disabledWithdrawalAsset[i];\\r\\n            require(_isAssetPresent(asset), \\\"Asset not supported by Yieldster\\\");\\r\\n            vaults[msg.sender].vaultAssets[asset] = false;\\r\\n            vaults[msg.sender].vaultWithdrawalAssets[asset] = false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Function to check if the asset is supported by the vault.\\r\\n    /// @param cleanUpAsset Address of the asset.\\r\\n    function _isVaultAsset(address cleanUpAsset) public view returns (bool) {\\r\\n        require(vaults[msg.sender].created, \\\"Vault is not present\\\");\\r\\n        return vaults[msg.sender].vaultAssets[cleanUpAsset];\\r\\n    }\\r\\n\\r\\n    /// @dev Function to check if an asset is supported by Yieldster.\\r\\n    /// @param _address Address of the asset.\\r\\n    function _isAssetPresent(address _address) private view returns (bool) {\\r\\n        return assets[_address];\\r\\n    }\\r\\n\\r\\n    /// @dev Function to add an asset to the Yieldster.\\r\\n    /// @param _tokenAddress Address of the asset.\\r\\n    function addAsset(address _tokenAddress) public onlyManager {\\r\\n        require(!_isAssetPresent(_tokenAddress), \\\"Asset already present!\\\");\\r\\n        assets[_tokenAddress] = true;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to remove an asset from the Yieldster.\\r\\n    /// @param _tokenAddress Address of the asset.\\r\\n    function removeAsset(address _tokenAddress) public onlyManager {\\r\\n        require(_isAssetPresent(_tokenAddress), \\\"Asset not present!\\\");\\r\\n        delete assets[_tokenAddress];\\r\\n    }\\r\\n\\r\\n    /// @dev Function to check if an asset is supported deposit asset in the vault.\\r\\n    /// @param _assetAddress Address of the asset.\\r\\n    function isDepositAsset(address _assetAddress) public view returns (bool) {\\r\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\r\\n        return vaults[msg.sender].vaultDepositAssets[_assetAddress];\\r\\n    }\\r\\n\\r\\n    /// @dev Function to check if an asset is supported withdrawal asset in the vault.\\r\\n    /// @param _assetAddress Address of the asset.\\r\\n    function isWithdrawalAsset(address _assetAddress)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\r\\n        return vaults[msg.sender].vaultWithdrawalAssets[_assetAddress];\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set stock Deposit and Withdraw.\\r\\n    /// @param _stockDeposit Address of the stock deposit contract.\\r\\n    /// @param _stockWithdraw Address of the stock withdraw contract.\\r\\n    function setStockDepositWithdraw(\\r\\n        address _stockDeposit,\\r\\n        address _stockWithdraw\\r\\n    ) public onlyYieldsterDAO {\\r\\n        stockDeposit = _stockDeposit;\\r\\n        stockWithdraw = _stockWithdraw;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set smart strategy applied to the vault.\\r\\n    /// @param _smartStrategyAddress Address of the smart strategy.\\r\\n    /// @param _type type of smart strategy(deposit or withdraw).\\r\\n    function setVaultSmartStrategy(address _smartStrategyAddress, uint256 _type)\\r\\n        external\\r\\n    {\\r\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\r\\n        require(\\r\\n            _isSmartStrategyPresent(_smartStrategyAddress),\\r\\n            \\\"Smart Strategy not Supported by Yieldster\\\"\\r\\n        );\\r\\n        if (_type == 1) {\\r\\n            vaults[msg.sender].depositStrategy = _smartStrategyAddress;\\r\\n        } else if (_type == 2) {\\r\\n            vaults[msg.sender].withdrawStrategy = _smartStrategyAddress;\\r\\n        } else {\\r\\n            revert(\\\"Invalid type provided\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Function to check if a smart strategy is supported by Yieldster.\\r\\n    /// @param _address Address of the smart strategy.\\r\\n    function _isSmartStrategyPresent(address _address)\\r\\n        private\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return smartStrategies[_address].created;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to add a smart strategy to Yieldster.\\r\\n    /// @param _smartStrategyAddress Address of the smart strategy.\\r\\n    /// @param _minter Address of the strategy minter.\\r\\n    /// @param _executor Address of the strategy executor.\\r\\n    function addSmartStrategy(\\r\\n        address _smartStrategyAddress,\\r\\n        address _minter,\\r\\n        address _executor\\r\\n    ) public onlyManager {\\r\\n        require(\\r\\n            !_isSmartStrategyPresent(_smartStrategyAddress),\\r\\n            \\\"Smart Strategy already present!\\\"\\r\\n        );\\r\\n        // SmartStrategy memory newSmartStrategy = SmartStrategy({\\r\\n        //     minter: _minter,\\r\\n        //     executor: _executor,\\r\\n        //     created: true\\r\\n        // });\\r\\n        SmartStrategy storage newSmartStrategy = smartStrategies[\\r\\n            _smartStrategyAddress\\r\\n        ];\\r\\n        newSmartStrategy.minter = _minter;\\r\\n        newSmartStrategy.executor = _executor;\\r\\n        newSmartStrategy.created = true;\\r\\n\\r\\n        minterStrategyMap[_minter] = _smartStrategyAddress;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to remove a smart strategy from Yieldster.\\r\\n    /// @param _smartStrategyAddress Address of the smart strategy.\\r\\n    function removeSmartStrategy(address _smartStrategyAddress)\\r\\n        public\\r\\n        onlyManager\\r\\n    {\\r\\n        require(\\r\\n            !_isSmartStrategyPresent(_smartStrategyAddress),\\r\\n            \\\"Smart Strategy not present\\\"\\r\\n        );\\r\\n        delete smartStrategies[_smartStrategyAddress];\\r\\n    }\\r\\n\\r\\n    /// @dev Function to get ssmart strategy executor address.\\r\\n    /// @param _smartStrategy Address of the strategy.\\r\\n    function smartStrategyExecutor(address _smartStrategy)\\r\\n        external\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        return smartStrategies[_smartStrategy].executor;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to change executor of smart strategy.\\r\\n    /// @param _smartStrategy Address of the smart strategy.\\r\\n    /// @param _executor Address of the executor.\\r\\n    function changeSmartStrategyExecutor(\\r\\n        address _smartStrategy,\\r\\n        address _executor\\r\\n    ) public onlyManager {\\r\\n        require(\\r\\n            _isSmartStrategyPresent(_smartStrategy),\\r\\n            \\\"Smart Strategy not present!\\\"\\r\\n        );\\r\\n        smartStrategies[_smartStrategy].executor = _executor;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to get the deposit strategy applied to the vault.\\r\\n    function getDepositStrategy() public view returns (address) {\\r\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\r\\n        return vaults[msg.sender].depositStrategy;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to get the withdrawal strategy applied to the vault.\\r\\n    function getWithdrawStrategy() public view returns (address) {\\r\\n        require(vaults[msg.sender].created, \\\"Vault not present\\\");\\r\\n        return vaults[msg.sender].withdrawStrategy;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to get strategy address from minter.\\r\\n    /// @param _minter Address of the minter.\\r\\n    function getStrategyFromMinter(address _minter)\\r\\n        external\\r\\n        view\\r\\n        returns (address)\\r\\n    {\\r\\n        return minterStrategyMap[_minter];\\r\\n    }\\r\\n\\r\\n    modifier onlyYieldsterDAO() {\\r\\n        require(\\r\\n            yieldsterDAO == msg.sender,\\r\\n            \\\"Only Yieldster DAO is allowed to perform this operation\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyManager() {\\r\\n        require(\\r\\n            APSManagers[msg.sender],\\r\\n            \\\"Only APS managers allowed to perform this operation!\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to check if an address is an Yieldster Vault.\\r\\n    /// @param _address Address to check.\\r\\n    function isVault(address _address) public view returns (bool) {\\r\\n        return vaults[_address].created;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to get wEth Address.\\r\\n    function getWETH() external view returns (address) {\\r\\n        return wEth;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set wEth Address.\\r\\n    /// @param _wEth Address of wEth.\\r\\n    function setWETH(address _wEth) external onlyYieldsterDAO {\\r\\n        wEth = _wEth;\\r\\n    }\\r\\n\\r\\n    /// @dev function to calculate the slippage value accounted min return for an exchange operation.\\r\\n    /// @param fromToken Address of From token\\r\\n    /// @param toToken Address of To token\\r\\n    /// @param amount amount of From token\\r\\n    /// @param slippagePercent slippage Percentage\\r\\n    function calculateSlippage(\\r\\n        address fromToken,\\r\\n        address toToken,\\r\\n        uint256 amount,\\r\\n        uint256 slippagePercent\\r\\n    ) public view returns (uint256) {\\r\\n        uint256 fromTokenUSD = getUSDPrice(fromToken);\\r\\n        uint256 toTokenUSD = getUSDPrice(toToken);\\r\\n        uint256 fromTokenAmountDecimals = IHexUtils(stringUtils).toDecimals(\\r\\n            fromToken,\\r\\n            amount\\r\\n        );\\r\\n\\r\\n        uint256 expectedToTokenDecimal = (fromTokenAmountDecimals *\\r\\n            fromTokenUSD) / toTokenUSD;\\r\\n\\r\\n        uint256 expectedToToken = IHexUtils(stringUtils).fromDecimals(\\r\\n            toToken,\\r\\n            expectedToTokenDecimal\\r\\n        );\\r\\n\\r\\n        uint256 minReturn = expectedToToken -\\r\\n            ((expectedToToken * slippagePercent) / (10000));\\r\\n        return minReturn;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to check number of vaults owned by an admin\\r\\n    /// @param _vaultAdmin address of vaultAdmin\\r\\n    function vaultsCount(address _vaultAdmin) public view returns (uint256) {\\r\\n        return vaultsOwnedByAdmin[_vaultAdmin];\\r\\n    }\\r\\n\\r\\n    /// @dev Function to retrieve the storage of managementFee\\r\\n    function getPlatformFeeStorage() public view returns (address) {\\r\\n        return mStorage;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set the storage of managementFee\\r\\n    /// @param _mStorage address of platform storage\\r\\n    function setManagementFeeStorage(address _mStorage)\\r\\n        external\\r\\n        onlyYieldsterDAO\\r\\n    {\\r\\n        mStorage = _mStorage;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set the address of setSDKContract\\r\\n    /// @param _sdkContract address of sdkContract\\r\\n    function setSDKContract(address _sdkContract) external onlyYieldsterDAO {\\r\\n        sdkContract = _sdkContract;\\r\\n    }\\r\\n\\r\\n    /// @dev Function to set the approved wallets\\r\\n    /// @param _walletAddresses address of wallet\\r\\n    /// @param _permission status of permission\\r\\n    function setWalletAddress(\\r\\n        address[] memory _walletAddresses,\\r\\n        bool[] memory _permission\\r\\n    ) external onlyYieldsterDAO {\\r\\n        for (uint256 i = 0; i < _walletAddresses.length; i++) {\\r\\n            if (_walletAddresses[i] != address(0))\\r\\n                if (\\r\\n                    permittedWalletAddresses[_walletAddresses[i]] !=\\r\\n                    _permission[i]\\r\\n                )\\r\\n                    permittedWalletAddresses[_walletAddresses[i]] = _permission[\\r\\n                        i\\r\\n                    ];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Function to check if  approved wallet\\r\\n    /// @param _walletAddress address of wallet\\r\\n\\r\\n    function checkWalletAddress(address _walletAddress)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return permittedWalletAddresses[_walletAddress];\\r\\n    }\\r\\n\\r\\n    /// @dev Function to add assets to  Yieldster.\\r\\n    /// @param _tokenAddresses Address of the assets.\\r\\n    function addAssets(address[] calldata _tokenAddresses) public onlyManager {\\r\\n        for (uint256 index = 0; index < _tokenAddresses.length; index++) {\\r\\n            address _tokenAddress = _tokenAddresses[index];\\r\\n            assets[_tokenAddress] = true;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IPriceModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.13;\\r\\n\\r\\ninterface IPriceModule\\r\\n{\\r\\n    function getUSDPrice(address ) external view returns(uint256);\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IHexUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.13;\\r\\n\\r\\ninterface IHexUtils {\\r\\n    function fromHex(bytes calldata) external pure returns (bytes memory);\\r\\n\\r\\n    function toDecimals(address, uint256) external view returns (uint256);\\r\\n\\r\\n    function fromDecimals(address, uint256) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"petersburg\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cleanUpAsset\",\"type\":\"address\"}],\"name\":\"_isVaultAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"addAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"addAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_managementFeeAddress\",\"type\":\"address\"}],\"name\":\"addManagementFeeStrategies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxyFactory\",\"type\":\"address\"}],\"name\":\"addProxyFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_smartStrategyAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"name\":\"addSmartStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAdmin\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_whitelistGroup\",\"type\":\"uint256[]\"}],\"name\":\"addVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippagePercent\",\"type\":\"uint256\"}],\"name\":\"calculateSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_smartStrategy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"name\":\"changeSmartStrategyExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAdmin\",\"type\":\"address\"}],\"name\":\"changeVaultAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_walletAddress\",\"type\":\"address\"}],\"name\":\"checkWalletAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableYieldsterGOD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlatformFeeStorage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"getStrategyFromMinter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"getUSDPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultManagementFee\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_yieldsterDAO\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yieldsterTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yieldsterGOD\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_emergencyVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_apsAdmin\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetAddress\",\"type\":\"address\"}],\"name\":\"isDepositAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetAddress\",\"type\":\"address\"}],\"name\":\"isWithdrawalAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mStorage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platFormManagementFee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitManagementFee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"removeAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_managementFeeAddress\",\"type\":\"address\"}],\"name\":\"removeManagementFeeStrategies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_smartStrategyAddress\",\"type\":\"address\"}],\"name\":\"removeSmartStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeMinter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeUtils\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sdkContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_emergencyVault\",\"type\":\"address\"}],\"name\":\"setEmergencyVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exchangeRegistry\",\"type\":\"address\"}],\"name\":\"setExchangeRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whitelistModule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_platformManagementFee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_profitManagementFee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stringUtils\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yieldsterExchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exchangeRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceModule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_safeUtils\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mStorage\",\"type\":\"address\"}],\"name\":\"setInitialValues\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mStorage\",\"type\":\"address\"}],\"name\":\"setManagementFeeStorage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_priceModule\",\"type\":\"address\"}],\"name\":\"setPriceModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_platformManagement\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_profitManagement\",\"type\":\"address\"}],\"name\":\"setProfitAndPlatformManagementFeeStrategies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sdkContract\",\"type\":\"address\"}],\"name\":\"setSDKContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_safeMinter\",\"type\":\"address\"}],\"name\":\"setSafeMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_safeUtils\",\"type\":\"address\"}],\"name\":\"setSafeUtils\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stockDeposit\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stockWithdraw\",\"type\":\"address\"}],\"name\":\"setStockDepositWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stringUtils\",\"type\":\"address\"}],\"name\":\"setStringUtils\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_enabledDepositAsset\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_enabledWithdrawalAsset\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_disabledDepositAsset\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_disabledWithdrawalAsset\",\"type\":\"address[]\"}],\"name\":\"setVaultAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"setVaultSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_smartStrategyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"setVaultSmartStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"}],\"name\":\"setVaultStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wEth\",\"type\":\"address\"}],\"name\":\"setWETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_walletAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_permission\",\"type\":\"bool[]\"}],\"name\":\"setWalletAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whitelistModule\",\"type\":\"address\"}],\"name\":\"setWhitelistModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_yieldsterDAO\",\"type\":\"address\"}],\"name\":\"setYieldsterDAO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_yieldsterExchange\",\"type\":\"address\"}],\"name\":\"setYieldsterExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_yieldsterGOD\",\"type\":\"address\"}],\"name\":\"setYieldsterGOD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_yieldsterTreasury\",\"type\":\"address\"}],\"name\":\"setYieldsterTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_smartStrategy\",\"type\":\"address\"}],\"name\":\"smartStrategyExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stockDeposit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stockWithdraw\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stringUtils\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultAdmin\",\"type\":\"address\"}],\"name\":\"vaultsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldsterDAO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldsterExchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldsterGOD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldsterTreasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "APContractV2", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "petersburg", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}