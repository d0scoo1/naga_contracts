{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/YVaultAssetProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IYearnVault.sol\\\";\\nimport \\\"./WrappedPosition.sol\\\";\\nimport \\\"./libraries/Authorizable.sol\\\";\\n\\n/// SECURITY - This contract has an owner address which can migrate funds to a new yearn vault [or other contract\\n///            with compatible interface] as well as pause deposits and withdraws. This means that any deposited funds\\n///            have the same security as that address.\\n\\n/// @author Element Finance\\n/// @title Yearn Vault v1 Asset Proxy\\ncontract YVaultAssetProxy is WrappedPosition, Authorizable {\\n    // The addresses of the current yearn vault\\n    IYearnVault public vault;\\n    // 18 decimal fractional form of the multiplier which is applied after\\n    // a vault upgrade. 0 when no upgrade has happened\\n    uint88 public conversionRate;\\n    // Bool packed into the same storage slot as vault and conversion rate\\n    bool public paused;\\n    uint8 public immutable vaultDecimals;\\n\\n    /// @notice Constructs this contract and stores needed data\\n    /// @param vault_ The yearn v2 vault\\n    /// @param _token The underlying token.\\n    ///               This token should revert in the event of a transfer failure.\\n    /// @param _name The name of the token created\\n    /// @param _symbol The symbol of the token created\\n    /// @param _governance The address which can upgrade the yearn vault\\n    /// @param _pauser address which can pause this contract\\n    constructor(\\n        address vault_,\\n        IERC20 _token,\\n        string memory _name,\\n        string memory _symbol,\\n        address _governance,\\n        address _pauser\\n    ) WrappedPosition(_token, _name, _symbol) Authorizable() {\\n        // Authorize the pauser\\n        _authorize(_pauser);\\n        // set the owner\\n        setOwner(_governance);\\n        // Set the vault\\n        vault = IYearnVault(vault_);\\n        // Approve the vault so it can pull tokens from this address\\n        _token.approve(vault_, type(uint256).max);\\n        // Load the decimals and set them as an immutable\\n        uint8 localVaultDecimals = IERC20(vault_).decimals();\\n        vaultDecimals = localVaultDecimals;\\n        require(\\n            uint8(_token.decimals()) == localVaultDecimals,\\n            \\\"Inconsistent decimals\\\"\\n        );\\n    }\\n\\n    /// @notice Checks that the contract has not been paused\\n    modifier notPaused() {\\n        require(!paused, \\\"Paused\\\");\\n        _;\\n    }\\n\\n    /// @notice Makes the actual deposit into the yearn vault\\n    /// @return Tuple (the shares minted, amount underlying used)\\n    function _deposit() internal override notPaused returns (uint256, uint256) {\\n        // Get the amount deposited\\n        uint256 amount = token.balanceOf(address(this));\\n\\n        // Deposit and get the shares that were minted to this\\n        uint256 shares = vault.deposit(amount, address(this));\\n\\n        // If we have migrated our shares are no longer 1 - 1 with the vault shares\\n        if (conversionRate != 0) {\\n            // conversionRate is the fraction of yearnSharePrice1/yearnSharePrices2 at time of migration\\n            // and so this multiplication will convert between yearn shares in the new vault and\\n            // those in the old vault\\n            shares = (shares * conversionRate) / 1e18;\\n        }\\n\\n        // Return the amount of shares the user has produced, and the amount used for it.\\n        return (shares, amount);\\n    }\\n\\n    /// @notice Withdraw the number of shares\\n    /// @param _shares The number of wrapped position shares to withdraw\\n    /// @param _destination The address to send the output funds\\n    // @param _underlyingPerShare The possibly precomputed underlying per share\\n    /// @return returns the amount of funds freed by doing a yearn withdraw\\n    function _withdraw(\\n        uint256 _shares,\\n        address _destination,\\n        uint256\\n    ) internal override notPaused returns (uint256) {\\n        // If the conversion rate is non-zero we have upgraded and so our wrapped shares are\\n        // not one to one with the original shares.\\n        if (conversionRate != 0) {\\n            // Then since conversion rate is yearnSharePrice1/yearnSharePrices2 we divide the\\n            // wrapped position shares by it because they are equivalent to the first yearn vault shares\\n            _shares = (_shares * 1e18) / conversionRate;\\n        }\\n        // Withdraws shares from the vault. Max loss is set at 100% as\\n        // the minimum output value is enforced by the calling\\n        // function in the WrappedPosition contract.\\n        uint256 amountReceived = vault.withdraw(_shares, _destination, 10000);\\n\\n        // Return the amount of underlying\\n        return amountReceived;\\n    }\\n\\n    /// @notice Get the underlying amount of tokens per shares given\\n    /// @param _amount The amount of shares you want to know the value of\\n    /// @return Value of shares in underlying token\\n    function _underlying(uint256 _amount)\\n        internal\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        // We may have to convert before using the vault price per share\\n        if (conversionRate != 0) {\\n            // Imitate the _withdraw logic and convert this amount to yearn vault2 shares\\n            _amount = (_amount * 1e18) / conversionRate;\\n        }\\n        return (_amount * _pricePerShare()) / (10**vaultDecimals);\\n    }\\n\\n    /// @notice Get the price per share in the vault\\n    /// @return The price per share in units of underlying;\\n    function _pricePerShare() internal view returns (uint256) {\\n        return vault.pricePerShare();\\n    }\\n\\n    /// @notice Function to reset approvals for the proxy\\n    function approve() external {\\n        token.approve(address(vault), 0);\\n        token.approve(address(vault), type(uint256).max);\\n    }\\n\\n    /// @notice Allows an authorized address or the owner to pause this contract\\n    /// @param pauseStatus true for paused, false for not paused\\n    /// @dev the caller must be authorized\\n    function pause(bool pauseStatus) external onlyAuthorized {\\n        paused = pauseStatus;\\n    }\\n\\n    /// @notice Function to transition between two yearn vaults\\n    /// @param newVault The address of the new vault\\n    /// @param minOutputShares The min of the new yearn vault's shares the wp will receive\\n    /// @dev WARNING - This function has the capacity to steal all user funds from this\\n    ///                contract and so it should be ensured that the owner is a high quorum\\n    ///                governance vote through the time lock.\\n    function transition(IYearnVault newVault, uint256 minOutputShares)\\n        external\\n        onlyOwner\\n    {\\n        // Load the current vault's price per share\\n        uint256 currentPricePerShare = _pricePerShare();\\n        // Load the new vault's price per share\\n        uint256 newPricePerShare = newVault.pricePerShare();\\n        // Load the current conversion rate or set it to 1\\n        uint256 newConversionRate = conversionRate == 0 ? 1e18 : conversionRate;\\n        // Calculate the new conversion rate, note by multiplying by the old\\n        // conversion rate here we implicitly support more than 1 upgrade\\n        newConversionRate =\\n            (newConversionRate * newPricePerShare) /\\n            currentPricePerShare;\\n        // We now withdraw from the old yearn vault using max shares\\n        // Note - Vaults should be checked in the future that they still have this behavior\\n        vault.withdraw(type(uint256).max, address(this), 10000);\\n        // Approve the new vault\\n        token.approve(address(newVault), type(uint256).max);\\n        // Then we deposit into the new vault\\n        uint256 currentBalance = token.balanceOf(address(this));\\n        uint256 outputShares = newVault.deposit(currentBalance, address(this));\\n        // We enforce a min output\\n        require(outputShares >= minOutputShares, \\\"Not enough output\\\");\\n        // Change the stored variables\\n        vault = newVault;\\n        // because of the truncation yearn vaults can't have a larger diff than ~ billion\\n        // times larger\\n        conversionRate = uint88(newConversionRate);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    function symbol() external view returns (string memory);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    // Note this is non standard but nearly all ERC20 have exposed decimal functions\\n    function decimals() external view returns (uint8);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IYearnVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IYearnVault is IERC20 {\\n    function deposit(uint256, address) external returns (uint256);\\n\\n    function withdraw(\\n        uint256,\\n        address,\\n        uint256\\n    ) external returns (uint256);\\n\\n    // Returns the amount of underlying per each unit [1e18] of yearn shares\\n    function pricePerShare() external view returns (uint256);\\n\\n    function governance() external view returns (address);\\n\\n    function setDepositLimit(uint256) external;\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function totalAssets() external view returns (uint256);\\n\\n    function apiVersion() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/WrappedPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IWETH.sol\\\";\\nimport \\\"./interfaces/IWrappedPosition.sol\\\";\\n\\nimport \\\"./libraries/ERC20Permit.sol\\\";\\n\\n/// @author Element Finance\\n/// @title Wrapped Position Core\\nabstract contract WrappedPosition is ERC20Permit, IWrappedPosition {\\n    IERC20 public immutable override token;\\n\\n    /// @notice Constructs this contract\\n    /// @param _token The underlying token.\\n    ///               This token should revert in the event of a transfer failure.\\n    /// @param _name the name of this contract\\n    /// @param _symbol the symbol for this contract\\n    constructor(\\n        IERC20 _token,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20Permit(_name, _symbol) {\\n        token = _token;\\n        // We set our decimals to be the same as the underlying\\n        _setupDecimals(_token.decimals());\\n    }\\n\\n    /// We expect that the following logic will be present in an integration implementation\\n    /// which inherits from this contract\\n\\n    /// @dev Makes the actual deposit into the 'vault'\\n    /// @return Tuple (shares minted, amount underlying used)\\n    function _deposit() internal virtual returns (uint256, uint256);\\n\\n    /// @dev Makes the actual withdraw from the 'vault'\\n    /// @return returns the amount produced\\n    function _withdraw(\\n        uint256,\\n        address,\\n        uint256\\n    ) internal virtual returns (uint256);\\n\\n    /// @dev Converts between an internal balance representation\\n    ///      and underlying tokens.\\n    /// @return The amount of underlying the input is worth\\n    function _underlying(uint256) internal view virtual returns (uint256);\\n\\n    /// @notice Get the underlying balance of an address\\n    /// @param _who The address to query\\n    /// @return The underlying token balance of the address\\n    function balanceOfUnderlying(address _who)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _underlying(balanceOf[_who]);\\n    }\\n\\n    /// @notice Returns the amount of the underlying asset a certain amount of shares is worth\\n    /// @param _shares Shares to calculate underlying value for\\n    /// @return The value of underlying assets for the given shares\\n    function getSharesToUnderlying(uint256 _shares)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _underlying(_shares);\\n    }\\n\\n    /// @notice Entry point to deposit tokens into the Wrapped Position contract\\n    ///         Transfers tokens on behalf of caller so the caller must set\\n    ///         allowance on the contract prior to call.\\n    /// @param _amount The amount of underlying tokens to deposit\\n    /// @param _destination The address to mint to\\n    /// @return Returns the number of Wrapped Position tokens minted\\n    function deposit(address _destination, uint256 _amount)\\n        external\\n        override\\n        returns (uint256)\\n    {\\n        // Send tokens to the proxy\\n        token.transferFrom(msg.sender, address(this), _amount);\\n        // Calls our internal deposit function\\n        (uint256 shares, ) = _deposit();\\n        // Mint them internal ERC20 tokens corresponding to the deposit\\n        _mint(_destination, shares);\\n        return shares;\\n    }\\n\\n    /// @notice Entry point to deposit tokens into the Wrapped Position contract\\n    ///         Assumes the tokens were transferred before this was called\\n    /// @param _destination the destination of this deposit\\n    /// @return Returns (WP tokens minted, used underlying,\\n    ///                  senders WP balance before mint)\\n    /// @dev WARNING - The call which funds this method MUST be in the same transaction\\n    //                 as the call to this method or you risk loss of funds\\n    function prefundedDeposit(address _destination)\\n        external\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        // Calls our internal deposit function\\n        (uint256 shares, uint256 usedUnderlying) = _deposit();\\n\\n        uint256 balanceBefore = balanceOf[_destination];\\n\\n        // Mint them internal ERC20 tokens corresponding to the deposit\\n        _mint(_destination, shares);\\n        return (shares, usedUnderlying, balanceBefore);\\n    }\\n\\n    /// @notice Exit point to withdraw tokens from the Wrapped Position contract\\n    /// @param _destination The address which is credited with tokens\\n    /// @param _shares The amount of shares the user is burning to withdraw underlying\\n    /// @param _minUnderlying The min output the caller expects\\n    /// @return The amount of underlying transferred to the destination\\n    function withdraw(\\n        address _destination,\\n        uint256 _shares,\\n        uint256 _minUnderlying\\n    ) public override returns (uint256) {\\n        return _positionWithdraw(_destination, _shares, _minUnderlying, 0);\\n    }\\n\\n    /// @notice This function burns enough tokens from the sender to send _amount\\n    ///          of underlying to the _destination.\\n    /// @param _destination The address to send the output to\\n    /// @param _amount The amount of underlying to try to redeem for\\n    /// @param _minUnderlying The minium underlying to receive\\n    /// @return The amount of underlying released, and shares used\\n    function withdrawUnderlying(\\n        address _destination,\\n        uint256 _amount,\\n        uint256 _minUnderlying\\n    ) external override returns (uint256, uint256) {\\n        // First we load the number of underlying per unit of Wrapped Position token\\n        uint256 oneUnit = 10**decimals;\\n        uint256 underlyingPerShare = _underlying(oneUnit);\\n        // Then we calculate the number of shares we need\\n        uint256 shares = (_amount * oneUnit) / underlyingPerShare;\\n        // Using this we call the normal withdraw function\\n        uint256 underlyingReceived = _positionWithdraw(\\n            _destination,\\n            shares,\\n            _minUnderlying,\\n            underlyingPerShare\\n        );\\n        return (underlyingReceived, shares);\\n    }\\n\\n    /// @notice This internal function allows the caller to provide a precomputed 'underlyingPerShare'\\n    ///         so that we can avoid calling it again in the internal function\\n    /// @param _destination The destination to send the output to\\n    /// @param _shares The number of shares to withdraw\\n    /// @param _minUnderlying The min amount of output to produce\\n    /// @param _underlyingPerShare The precomputed shares per underlying\\n    /// @return The amount of underlying released\\n    function _positionWithdraw(\\n        address _destination,\\n        uint256 _shares,\\n        uint256 _minUnderlying,\\n        uint256 _underlyingPerShare\\n    ) internal returns (uint256) {\\n        // Burn users shares\\n        _burn(msg.sender, _shares);\\n\\n        // Withdraw that many shares from the vault\\n        uint256 withdrawAmount = _withdraw(\\n            _shares,\\n            _destination,\\n            _underlyingPerShare\\n        );\\n\\n        // We revert if this call doesn't produce enough underlying\\n        // This security feature is useful in some edge cases\\n        require(withdrawAmount >= _minUnderlying, \\\"Not enough underlying\\\");\\n        return withdrawAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Authorizable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.7.0;\\n\\ncontract Authorizable {\\n    // This contract allows a flexible authorization scheme\\n\\n    // The owner who can change authorization status\\n    address public owner;\\n    // A mapping from an address to its authorization status\\n    mapping(address => bool) public authorized;\\n\\n    /// @dev We set the deployer to the owner\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    /// @dev This modifier checks if the msg.sender is the owner\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Sender not owner\\\");\\n        _;\\n    }\\n\\n    /// @dev This modifier checks if an address is authorized\\n    modifier onlyAuthorized() {\\n        require(isAuthorized(msg.sender), \\\"Sender not Authorized\\\");\\n        _;\\n    }\\n\\n    /// @dev Returns true if an address is authorized\\n    /// @param who the address to check\\n    /// @return true if authorized false if not\\n    function isAuthorized(address who) public view returns (bool) {\\n        return authorized[who];\\n    }\\n\\n    /// @dev Privileged function authorize an address\\n    /// @param who the address to authorize\\n    function authorize(address who) external onlyOwner {\\n        _authorize(who);\\n    }\\n\\n    /// @dev Privileged function to de authorize an address\\n    /// @param who The address to remove authorization from\\n    function deauthorize(address who) external onlyOwner {\\n        authorized[who] = false;\\n    }\\n\\n    /// @dev Function to change owner\\n    /// @param who The new owner address\\n    function setOwner(address who) public onlyOwner {\\n        owner = who;\\n    }\\n\\n    /// @dev Inheritable function which authorizes someone\\n    /// @param who the address to authorize\\n    function _authorize(address who) internal {\\n        authorized[who] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n\\n    event Deposit(address indexed dst, uint256 wad);\\n    event Withdrawal(address indexed src, uint256 wad);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWrappedPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Permit.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IWrappedPosition is IERC20Permit {\\n    function token() external view returns (IERC20);\\n\\n    function balanceOfUnderlying(address who) external view returns (uint256);\\n\\n    function getSharesToUnderlying(uint256 shares)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function deposit(address sender, uint256 amount) external returns (uint256);\\n\\n    function withdraw(\\n        address sender,\\n        uint256 _shares,\\n        uint256 _minUnderlying\\n    ) external returns (uint256);\\n\\n    function withdrawUnderlying(\\n        address _destination,\\n        uint256 _amount,\\n        uint256 _minUnderlying\\n    ) external returns (uint256, uint256);\\n\\n    function prefundedDeposit(address _destination)\\n        external\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC20Permit.sol\\\";\\n\\n// This default erc20 library is designed for max efficiency and security.\\n// WARNING: By default it does not include totalSupply which breaks the ERC20 standard\\n//          to use a fully standard compliant ERC20 use 'ERC20PermitWithSupply\\\"\\nabstract contract ERC20Permit is IERC20Permit {\\n    // --- ERC20 Data ---\\n    // The name of the erc20 token\\n    string public name;\\n    // The symbol of the erc20 token\\n    string public override symbol;\\n    // The decimals of the erc20 token, should default to 18 for new tokens\\n    uint8 public override decimals;\\n\\n    // A mapping which tracks user token balances\\n    mapping(address => uint256) public override balanceOf;\\n    // A mapping which tracks which addresses a user allows to move their tokens\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n    // A mapping which tracks the permit signature nonces for users\\n    mapping(address => uint256) public override nonces;\\n\\n    // --- EIP712 niceties ---\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 public override DOMAIN_SEPARATOR;\\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    /// @notice Initializes the erc20 contract\\n    /// @param name_ the value 'name' will be set to\\n    /// @param symbol_ the value 'symbol' will be set to\\n    /// @dev decimals default to 18 and must be reset by an inheriting contract for\\n    ///      non standard decimal values\\n    constructor(string memory name_, string memory symbol_) {\\n        // Set the state variables\\n        name = name_;\\n        symbol = symbol_;\\n        decimals = 18;\\n\\n        // By setting these addresses to 0 attempting to execute a transfer to\\n        // either of them will revert. This is a gas efficient way to prevent\\n        // a common user mistake where they transfer to the token address.\\n        // These values are not considered 'real' tokens and so are not included\\n        // in 'total supply' which only contains minted tokens.\\n        balanceOf[address(0)] = type(uint256).max;\\n        balanceOf[address(this)] = type(uint256).max;\\n\\n        // Optional extra state manipulation\\n        _extraConstruction();\\n\\n        // Computes the EIP 712 domain separator which prevents user signed messages for\\n        // this contract to be replayed in other contracts.\\n        // https://eips.ethereum.org/EIPS/eip-712\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /// @notice An optional override function to execute and change state before immutable assignment\\n    function _extraConstruction() internal virtual {}\\n\\n    // --- Token ---\\n    /// @notice Allows a token owner to send tokens to another address\\n    /// @param recipient The address which will be credited with the tokens\\n    /// @param amount The amount user token to send\\n    /// @return returns true on success, reverts on failure so cannot return false.\\n    /// @dev transfers to this contract address or 0 will fail\\n    function transfer(address recipient, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        // We forward this call to 'transferFrom'\\n        return transferFrom(msg.sender, recipient, amount);\\n    }\\n\\n    /// @notice Transfers an amount of erc20 from a spender to a receipt\\n    /// @param spender The source of the ERC20 tokens\\n    /// @param recipient The destination of the ERC20 tokens\\n    /// @param amount the number of tokens to send\\n    /// @return returns true on success and reverts on failure\\n    /// @dev will fail transfers which send funds to this contract or 0\\n    function transferFrom(\\n        address spender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        // Load balance and allowance\\n        uint256 balance = balanceOf[spender];\\n        require(balance >= amount, \\\"ERC20: insufficient-balance\\\");\\n        // We potentially have to change allowances\\n        if (spender != msg.sender) {\\n            // Loading the allowance in the if block prevents vanilla transfers\\n            // from paying for the sload.\\n            uint256 allowed = allowance[spender][msg.sender];\\n            // If the allowance is max we do not reduce it\\n            // Note - This means that max allowances will be more gas efficient\\n            // by not requiring a sstore on 'transferFrom'\\n            if (allowed != type(uint256).max) {\\n                require(allowed >= amount, \\\"ERC20: insufficient-allowance\\\");\\n                allowance[spender][msg.sender] = allowed - amount;\\n            }\\n        }\\n        // Update the balances\\n        balanceOf[spender] = balance - amount;\\n        // Note - In the constructor we initialize the 'balanceOf' of address 0 and\\n        //        the token address to uint256.max and so in 8.0 transfers to those\\n        //        addresses revert on this step.\\n        balanceOf[recipient] = balanceOf[recipient] + amount;\\n        // Emit the needed event\\n        emit Transfer(spender, recipient, amount);\\n        // Return that this call succeeded\\n        return true;\\n    }\\n\\n    /// @notice This internal minting function allows inheriting contracts\\n    ///         to mint tokens in the way they wish.\\n    /// @param account the address which will receive the token.\\n    /// @param amount the amount of token which they will receive\\n    /// @dev This function is virtual so that it can be overridden, if you\\n    ///      are reviewing this contract for security you should ensure to\\n    ///      check for overrides\\n    function _mint(address account, uint256 amount) internal virtual {\\n        // Add tokens to the account\\n        balanceOf[account] = balanceOf[account] + amount;\\n        // Emit an event to track the minting\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /// @notice This internal burning function allows inheriting contracts to\\n    ///         burn tokens in the way they see fit.\\n    /// @param account the account to remove tokens from\\n    /// @param amount  the amount of tokens to remove\\n    /// @dev This function is virtual so that it can be overridden, if you\\n    ///      are reviewing this contract for security you should ensure to\\n    ///      check for overrides\\n    function _burn(address account, uint256 amount) internal virtual {\\n        // Reduce the balance of the account\\n        balanceOf[account] = balanceOf[account] - amount;\\n        // Emit an event tracking transfers\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /// @notice This function allows a user to approve an account which can transfer\\n    ///         tokens on their behalf.\\n    /// @param account The account which will be approve to transfer tokens\\n    /// @param amount The approval amount, if set to uint256.max the allowance does not go down on transfers.\\n    /// @return returns true for compatibility with the ERC20 standard\\n    function approve(address account, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        // Set the senders allowance for account to amount\\n        allowance[msg.sender][account] = amount;\\n        // Emit an event to track approvals\\n        emit Approval(msg.sender, account, amount);\\n        return true;\\n    }\\n\\n    /// @notice This function allows a caller who is not the owner of an account to execute the functionality of 'approve' with the owners signature.\\n    /// @param owner the owner of the account which is having the new approval set\\n    /// @param spender the address which will be allowed to spend owner's tokens\\n    /// @param value the new allowance value\\n    /// @param deadline the timestamp which the signature must be submitted by to be valid\\n    /// @param v Extra ECDSA data which allows public key recovery from signature assumed to be 27 or 28\\n    /// @param r The r component of the ECDSA signature\\n    /// @param s The s component of the ECDSA signature\\n    /// @dev The signature for this function follows EIP 712 standard and should be generated with the\\n    ///      eth_signTypedData JSON RPC call instead of the eth_sign JSON RPC call. If using out of date\\n    ///      parity signing libraries the v component may need to be adjusted. Also it is very rare but possible\\n    ///      for v to be other values, those values are not supported.\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        // The EIP 712 digest for this function\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        owner,\\n                        spender,\\n                        value,\\n                        nonces[owner],\\n                        deadline\\n                    )\\n                )\\n            )\\n        );\\n        // Require that the owner is not zero\\n        require(owner != address(0), \\\"ERC20: invalid-address-0\\\");\\n        // Require that we have a valid signature from the owner\\n        require(owner == ecrecover(digest, v, r, s), \\\"ERC20: invalid-permit\\\");\\n        // Require that the signature is not expired\\n        require(\\n            deadline == 0 || block.timestamp <= deadline,\\n            \\\"ERC20: permit-expired\\\"\\n        );\\n        // Format the signature to the default format\\n        require(\\n            uint256(s) <=\\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n            \\\"ERC20: invalid signature 's' value\\\"\\n        );\\n        // Increment the signature nonce to prevent replay\\n        nonces[owner]++;\\n        // Set the allowance to the new value\\n        allowance[owner][spender] = value;\\n        // Emit an approval event to be able to track this happening\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /// @notice Internal function which allows inheriting contract to set custom decimals\\n    /// @param decimals_ the new decimal value\\n    function _setupDecimals(uint8 decimals_) internal {\\n        // Set the decimals\\n        decimals = decimals_;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Permit.sol\": {\r\n      \"content\": \"// Forked from openzepplin\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit is IERC20 {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for `permit`, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 7500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pauser\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"balanceOfUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"conversionRate\",\"outputs\":[{\"internalType\":\"uint88\",\"name\":\"\",\"type\":\"uint88\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"deauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"getSharesToUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"pauseStatus\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"}],\"name\":\"prefundedDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IYearnVault\",\"name\":\"newVault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minOutputShares\",\"type\":\"uint256\"}],\"name\":\"transition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IYearnVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minUnderlying\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minUnderlying\",\"type\":\"uint256\"}],\"name\":\"withdrawUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "YVaultAssetProxy", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "7500", "ConstructorArguments": "000000000000000000000000a354f35829ae975e850e23e9615b11da1b3dc4de000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000081758f3361a769016eae4844072fa6d7f828a65100000000000000000000000040309f197e7f94b555904df0f788a3f48cf326ab000000000000000000000000000000000000000000000000000000000000000e656c656d656e742079765553444300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000067976555344430000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}