{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ArtPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport './libraries/TimeConverter.sol';\\nimport './logic/StakingPoolLogic.sol';\\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ncontract ArtPool {\\n\\n    using StakingPoolLogic for PoolData;\\n\\n    constructor(address rewardAsset_) public {\\n        rewardAsset = IERC20(rewardAsset_);\\n        _admin = msg.sender;\\n    }\\n\\n    address public _admin;\\n\\n    struct PoolData {\\n        string poolName;\\n        uint256 rewardPerSecond;\\n        uint256 rewardIndex;\\n        uint256 startTimestamp;\\n        uint256 endTimestamp;\\n        uint256 totalPrincipal;\\n        uint256 lastUpdateTimestamp;\\n        uint256 totalNFT;\\n        uint256 voteMax;\\n        bool isFullLockup;\\n        uint256 lockupTimestamp;\\n        uint256 totalVoted;\\n        uint256 voteStartTimestamp;\\n        uint256 voteEndTimestamp;\\n        bool hasTaxCollected;\\n        mapping(address => WhitelistNFT) whitelistNFT;\\n        mapping(address => uint256) userIndex;\\n        mapping(address => uint256) userReward;\\n        mapping(address => uint256) userPrincipal;\\n        mapping(address => uint256) userVoted;\\n        mapping(address => UserNFT) userNFT;\\n        NFT[] votedNFT;\\n    }\\n\\n    struct UserNFT {\\n        mapping(address => uint256[]) stakedTokens;\\n        // mapping(address => mapping(uint256 => uint256)) indexOfToken;\\n        mapping(address => mapping(uint256 => uint256)) startStakeTimestamp;\\n        uint256 amountStaked;\\n    }\\n\\n    struct WhitelistNFT {\\n        bool isWhitelisted;\\n        bool isAllWhitelisted;\\n        uint256 multiplier;\\n        mapping(uint256 => bool) tokenIsWhitelisted;\\n        mapping(uint256 => VoteInfo) voteInfo;\\n    }\\n\\n    struct VoteInfo {\\n        address[] voters;\\n        mapping(address => uint256) votingCount;\\n        uint256 voted;\\n    }\\n\\n    struct NFT {\\n        address nftAddress;\\n        uint256 tokenId;\\n    }\\n\\n    mapping(uint8 => PoolData) internal _rounds;\\n\\n    mapping(address => mapping(uint256 => address)) public tokenOwners;\\n\\n    uint8 public lastRound;\\n\\n    IERC20 public rewardAsset;\\n\\n    event InitRound(\\n        uint256 rewardPerSecond,\\n        uint256 startTimestamp,\\n        uint256 endTimestamp,\\n        uint8 roundNumber\\n    );\\n\\n    event Stake(\\n        address indexed user,\\n        address nftAddress,\\n        uint256 tokenId,\\n        uint8 round\\n    );\\n\\n    event Unstake(\\n        address indexed user,\\n        address nftAddress,\\n        uint256 tokenId,\\n        uint8 round\\n    );\\n\\n    event Claim(\\n        address indexed user,\\n        uint256 reward,\\n        uint8 round\\n    );\\n\\n    event Vote(\\n        address indexed user,\\n        address nftAddress,\\n        uint256 tokenId,\\n        uint256 amount,\\n        uint8 round\\n    );\\n\\n    function setVoteTime(uint8 round, uint256 startTimestamp, uint256 endTimestamp) external onlyAdmin {\\n        PoolData storage poolData = _rounds[round];\\n\\n        poolData.voteStartTimestamp = startTimestamp;\\n        poolData.voteEndTimestamp = endTimestamp;\\n    }\\n\\n    function initNewRound(\\n        string calldata poolName,\\n        bool isFullLockup,\\n        uint256 lockupTimestamp,\\n        uint256 rewardPerSecond,\\n        uint16 year,\\n        uint8 month,\\n        uint8 day,\\n        uint8 hour,\\n        uint8 duration,\\n        uint256 voteMax\\n    ) external onlyAdmin {\\n        uint256 roundstartTimestamp = TimeConverter.toTimestamp(year, month, day, hour);\\n\\n        uint8 newRound = lastRound + 1;\\n        (uint256 startTimestamp, uint256 endTimestamp) = _rounds[newRound].initRound(\\n            poolName,\\n            isFullLockup,\\n            lockupTimestamp,\\n            rewardPerSecond,\\n            roundstartTimestamp,\\n            duration,\\n            voteMax\\n        );\\n\\n        lastRound = newRound;\\n\\n        emit InitRound(\\n            rewardPerSecond,\\n            startTimestamp,\\n            endTimestamp,\\n            newRound\\n        );\\n    }\\n\\n    modifier onlyAdmin() {\\n        if (msg.sender != _admin) revert(\\\"OnlyAdmin\\\");\\n        _;\\n    }\\n\\n    function getVoteData(uint8 round, address nftAddress, uint256 tokenId)\\n    external\\n    view\\n    returns(\\n        uint256 totalVoters,\\n        uint256 totalVoted\\n    )\\n    {\\n        PoolData storage poolData = _rounds[round];\\n        WhitelistNFT storage whitelistNFT = poolData.whitelistNFT[nftAddress];\\n        VoteInfo storage voteInfo = whitelistNFT.voteInfo[tokenId];\\n\\n        return(\\n        voteInfo.voters.length,\\n        voteInfo.voted\\n        );\\n    }\\n\\n    function getUserVoteData(uint8 round, address nftAddress, uint256 tokenId, address user)\\n    external\\n    view\\n    returns(\\n        uint256 totalVoted,\\n        uint256 totalVoter,\\n        uint256 userVoted\\n    )\\n    {\\n        PoolData storage poolData = _rounds[round];\\n        WhitelistNFT storage whitelistNFT = poolData.whitelistNFT[nftAddress];\\n        VoteInfo storage voteInfo = whitelistNFT.voteInfo[tokenId];\\n\\n        return (\\n        voteInfo.voters.length,\\n        voteInfo.voted,\\n        voteInfo.votingCount[user]\\n        );\\n    }\\n\\n    function getPoolData(uint8 round)\\n    external\\n    view\\n    returns (\\n        string memory poolName,\\n        bool isFullLockup,\\n        uint256 lockupTimestamp,\\n        uint256 rewardPerSecond,\\n        uint256 startTimestamp,\\n        uint256 endTimestamp,\\n        uint256 totalNFT,\\n        uint256 voteMax,\\n        uint256 voteStartTimestamp,\\n        uint256 voteEndTimestamp\\n    )\\n    {\\n        PoolData storage poolData = _rounds[round];\\n\\n        return (\\n        poolData.poolName,\\n        poolData.isFullLockup,\\n        poolData.lockupTimestamp,\\n        poolData.rewardPerSecond,\\n        poolData.startTimestamp,\\n        poolData.endTimestamp,\\n        poolData.totalNFT,\\n        poolData.voteMax,\\n        poolData.voteStartTimestamp,\\n        poolData.voteEndTimestamp\\n        );\\n    }\\n\\n    function getPoolDataETC(uint8 round)\\n    external\\n    view\\n    returns(\\n        uint256 totalVoted,\\n        uint256 totalPrincipal,\\n        bool hasTaxCollected,\\n        uint256 votedNFTs\\n    )\\n    {\\n        PoolData storage poolData = _rounds[round];\\n\\n        return (\\n        poolData.totalVoted,\\n        poolData.totalPrincipal,\\n        poolData.hasTaxCollected,\\n        poolData.votedNFT.length\\n        );\\n    }\\n\\n    function getUserData(uint8 round, address user)\\n    external\\n    view\\n    returns (\\n        uint256 userIndex,\\n        uint256 userReward,\\n        uint256 userPrincipal,\\n        uint256 amountStaked,\\n        uint256 amountVoted\\n    )\\n    {\\n        PoolData storage poolData = _rounds[round];\\n        UserNFT storage userNFT = poolData.userNFT[user];\\n\\n        return (\\n        poolData.userIndex[user],\\n        poolData.userReward[user],\\n        poolData.userPrincipal[user],\\n        userNFT.amountStaked,\\n        poolData.userVoted[user]\\n        );\\n    }\\n\\n    function getUserReward(address user, uint8 round) external view returns (uint256) {\\n        PoolData storage poolData = _rounds[round];\\n        return poolData.getUserReward(user);\\n    }\\n\\n    function getUserDataNFT(uint8 round, address user, address nftAddress)\\n    external\\n    view\\n    returns (\\n        uint256[] memory tokenId\\n    )\\n    {\\n        PoolData storage poolData = _rounds[round];\\n        UserNFT storage userNFT = poolData.userNFT[user];\\n\\n        return (userNFT.stakedTokens[nftAddress]);\\n    }\\n\\n    function getWhitelistNFTData(uint8 round, address nftAddress)\\n    external\\n    view\\n    returns (\\n        bool isWhitelisted,\\n        bool isAllWhitelisted,\\n        uint256 multiplier\\n    )\\n    {\\n        PoolData storage poolData = _rounds[round];\\n        WhitelistNFT storage whitelistNFT = poolData.whitelistNFT[nftAddress];\\n\\n        return (\\n        whitelistNFT.isWhitelisted,\\n        whitelistNFT.isAllWhitelisted,\\n        whitelistNFT.multiplier\\n        );\\n    }\\n\\n    function checkWhiteListed(uint8 round, address nftAddress, uint256 tokenId)\\n    external\\n    view\\n    returns(\\n        bool isWhitelisted\\n    )\\n    {\\n        PoolData storage poolData = _rounds[round];\\n        WhitelistNFT storage whitelistNFT = poolData.whitelistNFT[nftAddress];\\n\\n        if(whitelistNFT.isWhitelisted){\\n            if(whitelistNFT.isAllWhitelisted) {\\n                return true;\\n            }else {\\n                return whitelistNFT.tokenIsWhitelisted[tokenId];\\n            }\\n        }else {\\n            return false;\\n        }\\n    }\\n\\n    function addWhitelist(uint8 round, address nftAddress, bool isAllWhitelisted, uint256[] calldata whitelistedToken, uint256 multiplier) external onlyAdmin {\\n        PoolData storage poolData = _rounds[round];\\n        WhitelistNFT storage whitelistNFT = poolData.whitelistNFT[nftAddress];\\n\\n        if(poolData.whitelistNFT[nftAddress].isWhitelisted) revert(\\\"Already whitelisted\\\");\\n\\n        whitelistNFT.isWhitelisted = true;\\n        whitelistNFT.isAllWhitelisted = isAllWhitelisted;\\n        whitelistNFT.multiplier = multiplier;\\n        for(uint256 i = 0; i < whitelistedToken.length; i ++ ){\\n            whitelistNFT.tokenIsWhitelisted[whitelistedToken[i]] = true;\\n        }\\n    }\\n\\n    function claim(uint8 round) external {\\n        _claim(msg.sender, round);\\n    }\\n\\n    function stake(uint8 round, address nftAddress, uint256 tokenId) external {\\n        _stake(msg.sender, round, nftAddress, tokenId);\\n    }\\n\\n    function batchStake(uint8 round, address nftAddress, uint256[] calldata tokenIds) external {\\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\\n            _stake(msg.sender, round, nftAddress, tokenIds[i]);\\n        }\\n    }\\n\\n    function unstake(uint8 round, address nftAddress, uint256 tokenId) external {\\n        _unstake(msg.sender, round, nftAddress, tokenId);\\n    }\\n\\n    function batchUnstake(uint8 round, address nftAddress, uint256[] calldata tokenIds) external {\\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\\n            _unstake(msg.sender, round, nftAddress, tokenIds[i]);\\n        }\\n    }\\n\\n    function _stake(address userAddress, uint8 round, address nftAddress, uint256 tokenId) internal {\\n        PoolData storage poolData = _rounds[round];\\n        UserNFT storage user = poolData.userNFT[userAddress];\\n        WhitelistNFT storage whitelistNFT = poolData.whitelistNFT[nftAddress];\\n\\n        if (round == 0) revert(\\\"StakingNotInitiated\\\");\\n\\n        if (poolData.endTimestamp < block.timestamp || poolData.startTimestamp > block.timestamp)\\n            revert(\\\"NotInRound\\\");\\n\\n        if(!whitelistNFT.isWhitelisted)\\n            revert(\\\"NotWhitelistedNFT\\\");\\n\\n        if(!whitelistNFT.isAllWhitelisted){\\n            if(!whitelistNFT.tokenIsWhitelisted[tokenId])\\n                revert(\\\"NotWhiteListedToken\\\");\\n        }\\n\\n        uint256 amount = whitelistNFT.multiplier > 0 ? whitelistNFT.multiplier : 1;\\n\\n        poolData.updateStakingPool(round, userAddress);\\n\\n        // nft \uc804\uc1a1\\n        IERC721(nftAddress).transferFrom(userAddress, address(this), tokenId);\\n\\n        poolData.userPrincipal[userAddress] = add(poolData.userPrincipal[userAddress], amount);\\n        poolData.totalPrincipal = add(poolData.totalPrincipal, amount);\\n        poolData.totalNFT = add(poolData.totalNFT, 1);\\n\\n\\n        user.stakedTokens[nftAddress].push(tokenId);\\n        // user.indexOfToken[nftAddress][tokenId] = user.stakedTokens[nftAddress].length;\\n        user.amountStaked += 1;\\n\\n\\n        user.startStakeTimestamp[nftAddress][tokenId] = block.timestamp;\\n        tokenOwners[nftAddress][tokenId] = msg.sender;\\n\\n        emit Stake(\\n            msg.sender,\\n            nftAddress,\\n            tokenId,\\n            round\\n        );\\n    }\\n\\n    function _unstake(address userAddress, uint8 round, address nftAddress, uint256 tokenId) internal {\\n        require(tokenOwners[nftAddress][tokenId] == userAddress, \\\"NotOwnerOfThisToken\\\");\\n\\n        PoolData storage poolData = _rounds[round];\\n        UserNFT storage user = poolData.userNFT[userAddress];\\n        WhitelistNFT storage whitelistNFT = poolData.whitelistNFT[nftAddress];\\n\\n        if(poolData.isFullLockup){\\n            if(poolData.endTimestamp > block.timestamp) {\\n                revert (\\\"LockupNotFinished\\\");\\n            }\\n        }\\n\\n        if(poolData.lockupTimestamp > 0 && block.timestamp < poolData.endTimestamp) {\\n            if(block.timestamp - user.startStakeTimestamp[nftAddress][tokenId] < poolData.lockupTimestamp){\\n                revert (\\\"LockupNotFinished\\\");\\n            }\\n        }\\n\\n        poolData.updateStakingPool(round, msg.sender);\\n\\n        for (uint256 i; i<user.stakedTokens[nftAddress].length; i++) {\\n            if (user.stakedTokens[nftAddress][i] == tokenId) {\\n                user.stakedTokens[nftAddress][i] = user.stakedTokens[nftAddress][user.stakedTokens[nftAddress].length - 1];\\n                user.stakedTokens[nftAddress].pop();\\n                break;\\n            }\\n        }\\n\\n        delete tokenOwners[nftAddress][tokenId];\\n\\n        user.amountStaked -= 1;\\n        poolData.totalNFT = sub(poolData.totalNFT, 1);\\n\\n        uint256 amount = whitelistNFT.multiplier > 0 ? whitelistNFT.multiplier : 1;\\n\\n        poolData.userPrincipal[userAddress] = sub(poolData.userPrincipal[userAddress], amount);\\n        poolData.totalPrincipal = sub(poolData.totalPrincipal, amount);\\n\\n        IERC721(nftAddress).transferFrom(\\n            address(this),\\n            userAddress,\\n            tokenId\\n        );\\n\\n        emit Stake(\\n            msg.sender,\\n            nftAddress,\\n            tokenId,\\n            round\\n        );\\n    }\\n\\n    function _claim(address user, uint8 round) internal {\\n        PoolData storage poolData = _rounds[round];\\n\\n        uint256 reward = poolData.getUserReward(user);\\n\\n        if (reward == 0) revert(\\\"ZeroReward\\\");\\n\\n        poolData.userReward[user] = 0;\\n        poolData.userIndex[user] = poolData.getRewardIndex();\\n\\n        rewardAsset.transfer(user, reward);\\n\\n        emit Claim(user, reward, round);\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n    function vote(uint8 round, address nftAddress, uint256 tokenId, uint256 amount) external {\\n        PoolData storage poolData = _rounds[round];\\n        WhitelistNFT storage whitelistNFT = poolData.whitelistNFT[nftAddress];\\n        VoteInfo storage voteInfo = whitelistNFT.voteInfo[tokenId];\\n\\n        if(tokenOwners[nftAddress][tokenId] == address(0)) revert(\\\"NotStakedNFT\\\");\\n\\n        if (poolData.voteEndTimestamp < block.timestamp || poolData.voteStartTimestamp > block.timestamp)\\n            revert(\\\"NotInVoteTime\\\");\\n\\n        if(amount > poolData.voteMax) revert(\\\"GreaterThanMaximum\\\");\\n\\n        uint userTotalVotingCount = poolData.userVoted[msg.sender];\\n\\n        uint256 userVotingCount = voteInfo.votingCount[msg.sender];\\n\\n        if(add(amount, userTotalVotingCount) > poolData.voteMax) revert(\\\"ExceedsMaximum\\\");\\n\\n        if(userVotingCount > 0) {\\n            // if(add(amount, userVotingCount) > poolData.voteMax) revert(\\\"ExceedsMaximum\\\");\\n        }else {\\n            voteInfo.voters.push(msg.sender);\\n        }\\n\\n        if(voteInfo.voted <= 0) {\\n            poolData.votedNFT.push(NFT({\\n            nftAddress: nftAddress,\\n            tokenId: tokenId\\n            }));\\n        }\\n\\n        voteInfo.votingCount[msg.sender] = add(userVotingCount, amount);\\n        voteInfo.voted = add(voteInfo.voted, amount);\\n        poolData.totalVoted = add(poolData.totalVoted, amount);\\n        poolData.userVoted[msg.sender] = add(userTotalVotingCount, amount);\\n\\n        rewardAsset.transferFrom(msg.sender, address(this), amount);\\n\\n        emit Vote(\\n            msg.sender,\\n            nftAddress,\\n            tokenId,\\n            amount,\\n            round\\n        );\\n    }\\n\\n    function forcedTransferFrom(address to, address nftAddress, uint256 tokenId) external onlyAdmin {\\n        IERC721(nftAddress).transferFrom(address(this), to, tokenId);\\n    }\\n\\n    function withdraw() external onlyAdmin {\\n        payable(msg.sender).transfer(address(this).balance);\\n    }\\n\\n    function withdrawToken() external onlyAdmin {\\n        uint256 balance = rewardAsset.balanceOf(address(this));\\n        rewardAsset.transfer(msg.sender, balance);\\n    }\\n\\n    function finishVote(uint8 round, address taxCollector, uint256 taxRate) external onlyAdmin {\\n        PoolData storage poolData = _rounds[round];\\n\\n        if(poolData.hasTaxCollected) revert(\\\"AlreadyCollectedTax\\\");\\n        if(taxRate > 100 ) revert(\\\"RateCannotOver100\\\");\\n        if(poolData.endTimestamp > block.timestamp) revert(\\\"NotFinishedRound\\\");\\n\\n        uint256 totalVoted = poolData.totalVoted;\\n        uint256 tax = totalVoted * taxRate / 100;\\n        uint256 totalPrize = totalVoted - tax;\\n\\n        uint256 winningVoteCount = 0;\\n        uint256 winningIndex = 0;\\n\\n        for (uint256 i = 0; i < poolData.votedNFT.length; i++) {\\n            address nftAddress = poolData.votedNFT[i].nftAddress;\\n            uint256 tokenId = poolData.votedNFT[i].tokenId;\\n\\n            WhitelistNFT storage whitelistNFT = poolData.whitelistNFT[nftAddress];\\n            VoteInfo storage voteInfo = whitelistNFT.voteInfo[tokenId];\\n\\n            if (voteInfo.voted > winningVoteCount) {\\n                winningVoteCount = voteInfo.voted;\\n                winningIndex = i;\\n\\n                if(voteInfo.voted * 2 >= totalVoted){\\n                    break;\\n                }\\n            }\\n        }\\n\\n        address winnerNFT = poolData.votedNFT[winningIndex].nftAddress;\\n        uint256 winnerTokenId = poolData.votedNFT[winningIndex].tokenId;\\n\\n        WhitelistNFT storage winnerNFTInfo = poolData.whitelistNFT[winnerNFT];\\n        VoteInfo storage winnerVoteInfo = winnerNFTInfo.voteInfo[winnerTokenId];\\n\\n        for (uint256 v = 0 ; v < winnerVoteInfo.voters.length; v ++){\\n            address voter = winnerVoteInfo.voters[v];\\n            uint256 userVotingCount = winnerVoteInfo.votingCount[voter];\\n\\n            uint256 prize = ((userVotingCount * 10000) / winnerVoteInfo.voted) * totalPrize / 10000;\\n            rewardAsset.transfer(voter, prize);\\n        }\\n\\n        rewardAsset.transfer(taxCollector, tax);\\n\\n        poolData.hasTaxCollected = true;\\n    }\\n\\n    function getWinners(uint8 round)\\n    external\\n    view\\n    returns(\\n        uint256 votedNFTs,\\n        uint256 voted,\\n        uint256 winningVoteCount,\\n        address winnerNFT,\\n        uint256 winnerTokenId,\\n        address[] memory winners\\n    )\\n    {\\n        PoolData storage poolData = _rounds[round];\\n\\n        uint256 totalVoted = poolData.totalVoted;\\n\\n        winningVoteCount = 0;\\n        uint256 winningIndex = 0;\\n\\n\\n        votedNFTs = poolData.votedNFT.length;\\n\\n        for (uint256 i = 0; i < poolData.votedNFT.length; i++) {\\n            address nftAddress = poolData.votedNFT[i].nftAddress;\\n            uint256 tokenId = poolData.votedNFT[i].tokenId;\\n\\n            VoteInfo storage voteInfo = poolData.whitelistNFT[nftAddress].voteInfo[tokenId];\\n\\n            voted = voteInfo.voted;\\n\\n            if (voteInfo.voted > winningVoteCount) {\\n                winningVoteCount = voteInfo.voted;\\n                winningIndex = i;\\n\\n                if(voteInfo.voted * 2 >= totalVoted){\\n                    break;\\n                }\\n            }\\n        }\\n\\n\\n        winnerNFT = poolData.votedNFT[winningIndex].nftAddress;\\n        winnerTokenId = poolData.votedNFT[winningIndex].tokenId;\\n\\n        WhitelistNFT storage winnerNFTInfo = poolData.whitelistNFT[winnerNFT];\\n        VoteInfo storage winnerVoteInfo = winnerNFTInfo.voteInfo[winnerTokenId];\\n\\n        return (\\n            votedNFTs,\\n            voted,\\n            winningVoteCount,\\n            winnerNFT,\\n            winnerTokenId,\\n            winnerVoteInfo.voters\\n        );\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/logic/StakingPoolLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8;\\nimport '../ArtPool.sol';\\nimport '../libraries/TimeConverter.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nlibrary StakingPoolLogic {\\n  using StakingPoolLogic for ArtPool.PoolData;\\n\\n  event UpdateStakingPool(\\n    address indexed user,\\n    uint256 newRewardIndex,\\n    uint256 totalPrincipal,\\n    uint8 currentRound\\n  );\\n\\n  function getRewardIndex(ArtPool.PoolData storage poolData) internal view returns (uint256) {\\n    uint256 currentTimestamp = block.timestamp < poolData.endTimestamp\\n      ? block.timestamp\\n      : poolData.endTimestamp;\\n    uint256 timeDiff = currentTimestamp - poolData.lastUpdateTimestamp;\\n    uint256 totalPrincipal = poolData.totalPrincipal;\\n\\n    if (timeDiff == 0) {\\n      return poolData.rewardIndex;\\n    }\\n\\n    if (totalPrincipal == 0) {\\n      return poolData.rewardIndex;\\n    }\\n\\n    uint256 rewardIndexDiff = (timeDiff * poolData.rewardPerSecond * 1e9) / totalPrincipal;\\n\\n    return poolData.rewardIndex + rewardIndexDiff;\\n  }\\n\\n  function getUserReward(ArtPool.PoolData storage poolData, address user)\\n    internal\\n    view\\n    returns (uint256)\\n  {\\n    if (poolData.userIndex[user] == 0) {\\n      return 0;\\n    }\\n    uint256 indexDiff = getRewardIndex(poolData) - poolData.userIndex[user];\\n\\n    uint256 balance = poolData.userPrincipal[user];\\n\\n    uint256 result = poolData.userReward[user] + (balance * indexDiff) / 1e9;\\n\\n    return result;\\n  }\\n\\n  function updateStakingPool(\\n    ArtPool.PoolData storage poolData,\\n    uint8 currentRound,\\n    address user\\n  ) internal {\\n    poolData.userReward[user] = getUserReward(poolData, user);\\n    poolData.rewardIndex = poolData.userIndex[user] = getRewardIndex(poolData);\\n    poolData.lastUpdateTimestamp = block.timestamp < poolData.endTimestamp\\n      ? block.timestamp\\n      : poolData.endTimestamp;\\n    emit UpdateStakingPool(msg.sender, poolData.rewardIndex, poolData.totalPrincipal, currentRound);\\n  }\\n\\n  function initRound(\\n    ArtPool.PoolData storage poolData,\\n    string memory poolName,\\n    bool isFullLockup,\\n    uint256 lockupTimestamp,\\n    uint256 rewardPerSecond,\\n    uint256 roundStartTimestamp,\\n    uint8 duration,\\n    uint256 voteMax\\n  ) internal returns (uint256, uint256) {\\n    poolData.poolName = poolName;\\n    poolData.isFullLockup = isFullLockup;\\n    poolData.lockupTimestamp = lockupTimestamp;\\n    poolData.rewardPerSecond = rewardPerSecond;\\n    poolData.startTimestamp = roundStartTimestamp;\\n    poolData.endTimestamp = roundStartTimestamp + (duration * 1 days);\\n    poolData.lastUpdateTimestamp = roundStartTimestamp;\\n    poolData.rewardIndex = 1e18;\\n    poolData.whitelistNFT;\\n    poolData.voteMax = voteMax;\\n\\n    return (poolData.startTimestamp, poolData.endTimestamp);\\n  }\\n\\n  function resetUserData(ArtPool.PoolData storage poolData, address user) internal {\\n    poolData.userReward[user] = 0;\\n    poolData.userIndex[user] = 0;\\n    poolData.userPrincipal[user] = 0;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TimeConverter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8;\\n\\n/**\\n * @title Ethereum timestamp conversion library\\n * @author ethereum-datatime\\n */\\nlibrary TimeConverter {\\n  struct DateTime {\\n    uint16 year;\\n    uint8 month;\\n    uint8 day;\\n    uint8 hour;\\n    uint8 minute;\\n    uint8 second;\\n    uint8 weekday;\\n  }\\n\\n  uint256 constant DAY_IN_SECONDS = 86400;\\n  uint256 constant YEAR_IN_SECONDS = 31536000;\\n  uint256 constant LEAP_YEAR_IN_SECONDS = 31622400;\\n\\n  uint256 constant HOUR_IN_SECONDS = 3600;\\n  uint256 constant MINUTE_IN_SECONDS = 60;\\n\\n  uint16 constant ORIGIN_YEAR = 1970;\\n\\n  function isLeapYear(uint16 year) internal pure returns (bool) {\\n    if (year % 4 != 0) {\\n      return false;\\n    }\\n    if (year % 100 != 0) {\\n      return true;\\n    }\\n    if (year % 400 != 0) {\\n      return false;\\n    }\\n    return true;\\n  }\\n\\n  function leapYearsBefore(uint256 year) internal pure returns (uint256) {\\n    year -= 1;\\n    return year / 4 - year / 100 + year / 400;\\n  }\\n\\n  function getDaysInMonth(uint8 month, uint16 year) internal pure returns (uint8) {\\n    if (\\n      month == 1 ||\\n      month == 3 ||\\n      month == 5 ||\\n      month == 7 ||\\n      month == 8 ||\\n      month == 10 ||\\n      month == 12\\n    ) {\\n      return 31;\\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\\n      return 30;\\n    } else if (isLeapYear(year)) {\\n      return 29;\\n    } else {\\n      return 28;\\n    }\\n  }\\n\\n  function parseTimestamp(uint256 timestamp) internal pure returns (DateTime memory dateTime) {\\n    uint256 secondsAccountedFor = 0;\\n    uint256 buf;\\n    uint8 i;\\n\\n    // Year\\n    dateTime.year = getYear(timestamp);\\n    buf = leapYearsBefore(dateTime.year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n    secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\\n    secondsAccountedFor += YEAR_IN_SECONDS * (dateTime.year - ORIGIN_YEAR - buf);\\n\\n    // Month\\n    uint256 secondsInMonth;\\n    for (i = 1; i <= 12; i++) {\\n      secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dateTime.year);\\n      if (secondsInMonth + secondsAccountedFor > timestamp) {\\n        dateTime.month = i;\\n        break;\\n      }\\n      secondsAccountedFor += secondsInMonth;\\n    }\\n\\n    // Day\\n    for (i = 1; i <= getDaysInMonth(dateTime.month, dateTime.year); i++) {\\n      if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\\n        dateTime.day = i;\\n        break;\\n      }\\n      secondsAccountedFor += DAY_IN_SECONDS;\\n    }\\n\\n    // Hour\\n    dateTime.hour = getHour(timestamp);\\n    // Minute\\n    dateTime.minute = getMinute(timestamp);\\n    // Second\\n    dateTime.second = getSecond(timestamp);\\n    // Day of week.\\n    dateTime.weekday = getWeekday(timestamp);\\n  }\\n\\n  function getYear(uint256 timestamp) internal pure returns (uint16) {\\n    uint256 secondsAccountedFor = 0;\\n    uint16 year;\\n    uint256 numLeapYears;\\n\\n    // Year\\n    year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\\n    numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\\n\\n    secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\\n    secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\\n\\n    while (secondsAccountedFor > timestamp) {\\n      if (isLeapYear(uint16(year - 1))) {\\n        secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\\n      } else {\\n        secondsAccountedFor -= YEAR_IN_SECONDS;\\n      }\\n      year -= 1;\\n    }\\n    return year;\\n  }\\n\\n  function getMonth(uint256 timestamp) internal pure returns (uint8) {\\n    return parseTimestamp(timestamp).month;\\n  }\\n\\n  function getDay(uint256 timestamp) internal pure returns (uint8) {\\n    return parseTimestamp(timestamp).day;\\n  }\\n\\n  function getHour(uint256 timestamp) internal pure returns (uint8) {\\n    return uint8((timestamp / 60 / 60) % 24);\\n  }\\n\\n  function getMinute(uint256 timestamp) internal pure returns (uint8) {\\n    return uint8((timestamp / 60) % 60);\\n  }\\n\\n  function getSecond(uint256 timestamp) internal pure returns (uint8) {\\n    return uint8(timestamp % 60);\\n  }\\n\\n  function getWeekday(uint256 timestamp) internal pure returns (uint8) {\\n    return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\\n  }\\n\\n  function toTimestamp(\\n    uint16 year,\\n    uint8 month,\\n    uint8 day\\n  ) internal pure returns (uint256 timestamp) {\\n    return toTimestamp(year, month, day, 0, 0, 0);\\n  }\\n\\n  function toTimestamp(\\n    uint16 year,\\n    uint8 month,\\n    uint8 day,\\n    uint8 hour\\n  ) internal pure returns (uint256 timestamp) {\\n    return toTimestamp(year, month, day, hour, 0, 0);\\n  }\\n\\n  function toTimestamp(\\n    uint16 year,\\n    uint8 month,\\n    uint8 day,\\n    uint8 hour,\\n    uint8 minute\\n  ) internal pure returns (uint256 timestamp) {\\n    return toTimestamp(year, month, day, hour, minute, 0);\\n  }\\n\\n  function toTimestamp(\\n    uint16 year,\\n    uint8 month,\\n    uint8 day,\\n    uint8 hour,\\n    uint8 minute,\\n    uint8 second\\n  ) internal pure returns (uint256 timestamp) {\\n    uint16 i;\\n\\n    // Year\\n    for (i = ORIGIN_YEAR; i < year; i++) {\\n      if (isLeapYear(i)) {\\n        timestamp += LEAP_YEAR_IN_SECONDS;\\n      } else {\\n        timestamp += YEAR_IN_SECONDS;\\n      }\\n    }\\n\\n    // Month\\n    uint8[12] memory monthDayCounts;\\n    monthDayCounts[0] = 31;\\n    if (isLeapYear(year)) {\\n      monthDayCounts[1] = 29;\\n    } else {\\n      monthDayCounts[1] = 28;\\n    }\\n    monthDayCounts[2] = 31;\\n    monthDayCounts[3] = 30;\\n    monthDayCounts[4] = 31;\\n    monthDayCounts[5] = 30;\\n    monthDayCounts[6] = 31;\\n    monthDayCounts[7] = 31;\\n    monthDayCounts[8] = 30;\\n    monthDayCounts[9] = 31;\\n    monthDayCounts[10] = 30;\\n    monthDayCounts[11] = 31;\\n\\n    for (i = 1; i < month; i++) {\\n      timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\\n    }\\n\\n    // Day\\n    timestamp += DAY_IN_SECONDS * (day - 1);\\n    // Hour\\n    timestamp += HOUR_IN_SECONDS * (hour);\\n    // Minute\\n    timestamp += MINUTE_IN_SECONDS * (minute);\\n    // Second\\n    timestamp += second;\\n\\n    return timestamp;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardAsset_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerSecond\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"roundNumber\",\"type\":\"uint8\"}],\"name\":\"InitRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"}],\"name\":\"Vote\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAllWhitelisted\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"whitelistedToken\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"name\":\"addWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"checkWhiteListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"taxCollector\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"taxRate\",\"type\":\"uint256\"}],\"name\":\"finishVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"forcedTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"}],\"name\":\"getPoolData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"poolName\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isFullLockup\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lockupTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalNFT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteStartTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteEndTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"}],\"name\":\"getPoolDataETC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalVoted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPrincipal\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasTaxCollected\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"votedNFTs\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userPrincipal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountVoted\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"}],\"name\":\"getUserDataNFT\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"}],\"name\":\"getUserReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserVoteData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalVoted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalVoter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userVoted\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getVoteData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalVoters\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalVoted\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"}],\"name\":\"getWhitelistNFTData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAllWhitelisted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"}],\"name\":\"getWinners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"votedNFTs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winningVoteCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"winnerNFT\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"winnerTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"winners\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"poolName\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isFullLockup\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lockupTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"year\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"month\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"day\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hour\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"duration\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"voteMax\",\"type\":\"uint256\"}],\"name\":\"initNewRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRound\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardAsset\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"name\":\"setVoteTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenOwners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ArtPool", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000008bc2bcb1b1896291942c36f3cca3c1afa0aaa7fd", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}