{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity 0.8.7;\r\n\r\n\r\n// SPDX-License-Identifier: MIT\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\ninterface ITraits {\r\n  function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IDrawSvg {\r\n  function drawSvg(\r\n    string memory svgBreedColor, string memory svgBreedHead, string memory svgOffhand, string memory svgArmor, string memory svgMainhand\r\n  ) external view returns (string memory);\r\n  function drawSvgNew(\r\n    string memory svgBreedColor, string memory svgBreedHead, string memory svgOffhand, string memory svgArmor, string memory svgMainhand\r\n  ) external view returns (string memory);\r\n}\r\n\r\ninterface INameChange {\r\n  function changeName(address owner, uint256 id, string memory newName) external;\r\n}\r\n\r\ninterface IDogewood {\r\n    // struct to store each token's traits\r\n    struct Doge2 {\r\n        uint8 head;\r\n        uint8 breed;\r\n        uint8 color;\r\n        uint8 class;\r\n        uint8 armor;\r\n        uint8 offhand;\r\n        uint8 mainhand;\r\n        uint16 level;\r\n        uint16 breedRerollCount;\r\n        uint16 classRerollCount;\r\n        uint8 artStyle; // 0: new, 1: old\r\n    }\r\n\r\n    function getTokenTraits(uint256 tokenId) external view returns (Doge2 memory);\r\n    function getGenesisSupply() external view returns (uint256);\r\n    function pull(address owner, uint256[] calldata ids) external;\r\n    function manuallyAdjustDoge(uint256 id, uint8 head, uint8 breed, uint8 color, uint8 class, uint8 armor, uint8 offhand, uint8 mainhand, uint16 level, uint16 breedRerollCount, uint16 classRerollCount, uint8 artStyle) external;\r\n    function transfer(address to, uint256 tokenId) external;\r\n    // function doges(uint256 id) external view returns(uint8 head, uint8 breed, uint8 color, uint8 class, uint8 armor, uint8 offhand, uint8 mainhand, uint16 level);\r\n}\r\n\r\n// interface DogeLike {\r\n//     function pull(address owner, uint256[] calldata ids) external;\r\n//     function manuallyAdjustDoge(uint256 id, uint8 head, uint8 breed, uint8 color, uint8 class, uint8 armor, uint8 offhand, uint8 mainhand, uint16 level) external;\r\n//     function transfer(address to, uint256 tokenId) external;\r\n//     function doges(uint256 id) external view returns(uint8 head, uint8 breed, uint8 color, uint8 class, uint8 armor, uint8 offhand, uint8 mainhand, uint16 level);\r\n// }\r\ninterface PortalLike {\r\n    function sendMessage(bytes calldata message_) external;\r\n}\r\n\r\ninterface CastleLike {\r\n    function pullCallback(address owner, uint256[] calldata ids) external;\r\n}\r\n\r\n// interface DogewoodLike {\r\n//     function ownerOf(uint256 id) external view returns (address owner_);\r\n//     function activities(uint256 id) external view returns (address owner, uint88 timestamp, uint8 action);\r\n//     function doges(uint256 dogeId) external view returns (uint8 head, uint8 breed, uint8 color, uint8 class, uint8 armor, uint8 offhand, uint8 mainhand, uint16 level);\r\n// }\r\ninterface ERC20Like {\r\n    function balanceOf(address from) external view returns(uint256 balance);\r\n    function burn(address from, uint256 amount) external;\r\n    function mint(address from, uint256 amount) external;\r\n    function transfer(address to, uint256 amount) external;\r\n}\r\n\r\ninterface ERC1155Like {\r\n    function mint(address to, uint256 id, uint256 amount) external;\r\n    function burn(address from, uint256 id, uint256 amount) external;\r\n}\r\n\r\ninterface ERC721Like {\r\n    function transferFrom(address from, address to, uint256 id) external;   \r\n    function transfer(address to, uint256 id) external;\r\n    function ownerOf(uint256 id) external returns (address owner);\r\n    function mint(address to, uint256 tokenid) external;\r\n}\r\n\r\n// import \"../lib/openzeppelin-contracts/contracts/access/Ownable.sol\";\r\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\r\ncontract Traits is ITraits {\r\n\r\n  using Strings for uint256;\r\n\r\n  address implementation_;\r\n  address public admin;\r\n\r\n  mapping (uint8=>string) public traitTypes;\r\n\r\n  // storage of each traits name\r\n  // trait1 => [name1, name2, ...]\r\n  mapping(uint8 => mapping(uint8 => string)) public traitNames;\r\n\r\n  // trait1 => id1 => trait2 => id2 => address\r\n  // ex:\r\n  //   breed => 0 => head => 0 => breedHeas\r\n  //   class => {armor | offhand | mainhand} => value => address\r\n  mapping(uint8 => mapping(uint8 => mapping(uint8 => mapping(uint8 => address)))) public traitSvgs;\r\n\r\n  IDogewood public dogewood;\r\n  \r\n  string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n\r\n  // trait1 => id1 => trait2 => id2 => address\r\n  // ex:\r\n  //   breed => 0 => head => 0 => breedHeas\r\n  //   class => {armor | offhand | mainhand} => value => address\r\n  mapping(uint8 => mapping(uint8 => mapping(uint8 => mapping(uint8 => address)))) public traitSvgsNew;\r\n  \r\n  // gearType => value => traitName\r\n  //    gearType: (0: armor, 1: offhand, 2: mainhand)\r\n  // ex: 0 => 0 => \"Training Half Plate\": (Armor 0 value - Training Half Plate)\r\n  mapping(uint8 => mapping(uint8 => string)) public gearNames;\r\n\r\n  // draw contract address (Note: we separate this to reduce contract size)\r\n  IDrawSvg drawContract;\r\n\r\n  /*///////////////////////////////////////////////////////////////\r\n                  End of data\r\n  //////////////////////////////////////////////////////////////*/\r\n\r\n  function initialize() external onlyOwner {\r\n    require(msg.sender == admin);\r\n\r\n    string[8] memory traitTypes_ = ['head', 'breed', 'color', 'class', 'armor', 'offhand', 'mainhand', 'level'];\r\n    for (uint8 i = 0; i < traitTypes_.length; i++) {\r\n      traitTypes[i] = traitTypes_[i];  \r\n    }\r\n\r\n    // head\r\n    string[9] memory heads = [\"Determined\", \"High\", \"Happy\", \"Determined Tongue\", \"High Tongue\", \"Happy Tongue\", \"Determined Open\", \"High Open\", \"Happy Open\"];\r\n    for (uint8 i = 0; i < heads.length; i++) {\r\n      traitNames[0][i] = heads[i];  \r\n    }\r\n    // bread\r\n    string[8] memory breads = [\"Shiba\", \"Pug\", \"Corgi\", \"Labrador\", \"Dachshund\", \"Poodle\", \"Pitbull\", \"Bulldog\"];\r\n    for (uint8 i = 0; i < breads.length; i++) {\r\n      traitNames[1][i] = breads[i];  \r\n    }\r\n    // color\r\n    string[6] memory colors = [\"Palette 1\", \"Palette 2\", \"Palette 3\", \"Palette 4\", \"Palette 5\", \"Palette 6\"];\r\n    for (uint8 i = 0; i < colors.length; i++) {\r\n      traitNames[2][i] = colors[i];  \r\n    }\r\n    // class\r\n    string[8] memory classes = [\"Warrior\", \"Rogue\", \"Mage\", \"Hunter\", \"Cleric\", \"Bard\", \"Merchant\", \"Forager\"];\r\n    for (uint8 i = 0; i < classes.length; i++) {\r\n      traitNames[3][i] = classes[i];  \r\n    }\r\n\r\n    // gear names\r\n    gearNames[0][0] = 'Training Half Plate'; // Armor 0 value - Training Half Plate\r\n    gearNames[2][0] = 'Training Sword'; // mainhand 0 value - Training Sword\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n      require(msg.sender == admin);\r\n      _;\r\n  }\r\n\r\n  /** ADMIN */\r\n\r\n  function setDogewood(address _dogewood) external onlyOwner {\r\n    dogewood = IDogewood(_dogewood);\r\n  }\r\n\r\n  function setDrawContract(address drawContract_) external onlyOwner {\r\n    drawContract = IDrawSvg(drawContract_);\r\n  }\r\n\r\n  function setTraitTypes(uint8 id, string memory value) external onlyOwner {\r\n    traitTypes[id] = value;\r\n  }\r\n\r\n  /**\r\n   * administrative to upload the names associated with each trait\r\n   */\r\n  function uploadTraitNames(uint8 trait, uint8[] calldata traitIds, string[] calldata names) external onlyOwner {\r\n    require(traitIds.length == names.length, \"Mismatched inputs\");\r\n    for (uint256 index = 0; index < traitIds.length; index++) {\r\n      traitNames[trait][traitIds[index]] = names[index];\r\n    }\r\n  }\r\n\r\n  function uploadGearNames(uint8 gearType, uint8[] calldata values, string[] calldata names) external onlyOwner {\r\n    require(values.length == names.length, \"Mismatched inputs\");\r\n    for (uint256 index = 0; index < values.length; index++) {\r\n      gearNames[gearType][values[index]] = names[index];\r\n    }\r\n  }\r\n\r\n  function uploadTraitSvgs(uint8 trait1, uint8 id1, uint8 trait2, uint8[] calldata trait2Ids, address source) external onlyOwner {\r\n    for (uint256 index = 0; index < trait2Ids.length; index++) {\r\n        traitSvgs[trait1][id1][trait2][trait2Ids[index]] = source; \r\n    }\r\n  }\r\n\r\n  function uploadTraitSvgsNew(uint8 trait1, uint8 id1, uint8 trait2, uint8[] calldata trait2Ids, address source) external onlyOwner {\r\n    for (uint256 index = 0; index < trait2Ids.length; index++) {\r\n        traitSvgsNew[trait1][id1][trait2][trait2Ids[index]] = source; \r\n    }\r\n  }\r\n\r\n  /*///////////////////////////////////////////////////////////////\r\n                  INTERNAL FUNCTIONS\r\n  //////////////////////////////////////////////////////////////*/\r\n\r\n  function call(address source, bytes memory sig) internal view returns (string memory svg) {\r\n      (bool succ, bytes memory ret)  = source.staticcall(sig);\r\n      require(succ, \"failed to get data\");\r\n      svg = abi.decode(ret, (string));\r\n  }\r\n\r\n  function getSvg(uint8 trait1, uint8 id1, uint8 trait2, uint8 id2) internal view returns (string memory data_) {\r\n      address source = traitSvgs[trait1][id1][trait2][id2];\r\n      data_ = call(source, getData(trait1, id1, trait2, id2));\r\n  }\r\n\r\n  function getSvgNew(uint8 trait1, uint8 id1, uint8 trait2, uint8 id2) internal view returns (string memory data_) {\r\n      address source = traitSvgsNew[trait1][id1][trait2][id2];\r\n      data_ = call(source, getData(trait1, id1, trait2, id2));\r\n  }\r\n\r\n  function getData(uint8 trait1, uint8 id1, uint8 trait2, uint8 id2) internal view returns (bytes memory data) {\r\n    string memory s = string(abi.encodePacked(\r\n          traitTypes[trait1],toString(id1),\r\n          traitTypes[trait2],toString(id2),\r\n          \"()\"\r\n      ));\r\n    return abi.encodeWithSignature(s, \"\");\r\n  }\r\n\r\n  function drawSVG(uint256 tokenId) public view returns (string memory) {\r\n    IDogewood.Doge2 memory s = dogewood.getTokenTraits(tokenId);\r\n\r\n    return drawContract.drawSvg(\r\n      getSvg(1, s.breed, 2, s.color), \r\n      getSvg(1, s.breed, 0, s.head), \r\n      getSvg(3, s.class, 5, s.offhand), \r\n      getSvg(3, s.class, 4, s.armor), \r\n      getSvg(3, s.class, 6, s.mainhand)\r\n    );\r\n  }\r\n\r\n  function drawSVGNew(uint256 tokenId) public view returns (string memory) {\r\n    IDogewood.Doge2 memory s = dogewood.getTokenTraits(tokenId);\r\n\r\n    return drawContract.drawSvgNew(\r\n      getSvgNew(1, s.breed, 2, s.color), \r\n      getSvgNew(1, s.breed, 0, s.head), \r\n      getSvgNew(3, s.class, 5, s.offhand), \r\n      getSvgNew(3, s.class, 4, s.armor), \r\n      getSvgNew(3, s.class, 6, s.mainhand)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * generates an attribute for the attributes array in the ERC721 metadata standard\r\n   * @param traitType the trait type to reference as the metadata key\r\n   * @param value the token's trait associated with the key\r\n   * @return a JSON dictionary for the single attribute\r\n   */\r\n  function attributeForTypeAndValue(string memory traitType, string memory value) internal pure returns (string memory) {\r\n    return string(abi.encodePacked(\r\n      '{\"trait_type\":\"',\r\n      traitType,\r\n      '\",\"value\":\"',\r\n      value,\r\n      '\"}'\r\n    ));\r\n  }\r\n\r\n  function toString(uint256 value) internal pure returns (string memory) {\r\n      // Inspired by OraclizeAPI's implementation - MIT licence\r\n      // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n      if (value == 0) {\r\n          return \"0\";\r\n      }\r\n      uint256 temp = value;\r\n      uint256 digits;\r\n      while (temp != 0) {\r\n          digits++;\r\n          temp /= 10;\r\n      }\r\n      bytes memory buffer = new bytes(digits);\r\n      while (value != 0) {\r\n          digits -= 1;\r\n          buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n          value /= 10;\r\n      }\r\n      return string(buffer);\r\n  }\r\n\r\n  /**\r\n   * generates an array composed of all the individual traits and values\r\n   * @param tokenId the ID of the token to compose the metadata for\r\n   * @return a JSON array of all of the attributes for given token ID\r\n   */\r\n  function compileAttributes(uint256 tokenId) public view returns (string memory) {\r\n    IDogewood.Doge2 memory s = dogewood.getTokenTraits(tokenId);\r\n\r\n    string memory traits1 = string(abi.encodePacked(\r\n      attributeForTypeAndValue(traitTypes[0], traitNames[0][s.head]),',',\r\n      attributeForTypeAndValue(traitTypes[1], traitNames[1][s.breed]),',',\r\n      attributeForTypeAndValue(traitTypes[2], traitNames[2][s.color]),',',\r\n      attributeForTypeAndValue(traitTypes[3], traitNames[3][s.class]),','\r\n    ));\r\n    string memory traits2 = string(abi.encodePacked(\r\n      attributeForTypeAndValue(traitTypes[4], toString(s.armor)),',',\r\n      // attributeForTypeAndValue(traitTypes[4], gearNames[0][s.armor]),',',\r\n      attributeForTypeAndValue(traitTypes[5], toString(s.offhand)),',',\r\n      attributeForTypeAndValue(traitTypes[6], toString(s.mainhand)),',',\r\n      // attributeForTypeAndValue(traitTypes[6], gearNames[2][s.mainhand]),',',\r\n      // attributeForTypeAndValue(traitTypes[7], toString(s.level)),','\r\n      abi.encodePacked('{\"trait_type\":\"',traitTypes[7],'\",\"value\":',toString(s.level),'},'),\r\n      attributeForTypeAndValue('art', s.artStyle == 1 ? 'OG' : 'Standard'),','\r\n    ));\r\n    return string(abi.encodePacked(\r\n      '[',\r\n      traits1, traits2,\r\n      '{\"trait_type\":\"Generation\",\"value\":',\r\n      tokenId <= dogewood.getGenesisSupply() ? '\"Gen 0\"' : '\"Gen 1\"',\r\n      '},{\"display_type\":\"number\",\"trait_type\":\"Reroll Breed Count\",\"value\":', toString(s.breedRerollCount),\r\n      '},{\"display_type\":\"number\",\"trait_type\":\"Reroll Class Count\",\"value\":', toString(s.classRerollCount),\r\n      '}]'\r\n    ));\r\n  }\r\n\r\n  /**\r\n   * generates a base64 encoded metadata response without referencing off-chain content\r\n   * @param tokenId the ID of the token to generate the metadata for\r\n   * @return a base64 encoded JSON dictionary of the token's metadata and SVG\r\n   */\r\n  function tokenURI(uint256 tokenId) public view override returns (string memory) {\r\n    IDogewood.Doge2 memory s = dogewood.getTokenTraits(tokenId);\r\n    string memory svgData = s.artStyle == 1 ? drawSVG(tokenId) : drawSVGNew(tokenId);\r\n\r\n    string memory metadata = string(abi.encodePacked(\r\n      '{\"name\": \"Dogewood #',\r\n      tokenId.toString(),\r\n      '\", \"description\": \"100% on-chain\", \"image\": \"data:image/svg+xml;base64,',\r\n      base64(bytes(svgData)),\r\n      '\", \"attributes\":',\r\n      compileAttributes(tokenId),\r\n      \"}\"\r\n    ));\r\n\r\n    return string(abi.encodePacked(\r\n      \"data:application/json;base64,\",\r\n      base64(bytes(metadata))\r\n    ));\r\n  }\r\n\r\n  /** BASE 64 - Written by Brech Devos */\r\n\r\n  function base64(bytes memory data) internal pure returns (string memory) {\r\n    if (data.length == 0) return '';\r\n    \r\n    // load the table into memory\r\n    string memory table = TABLE;\r\n\r\n    // multiply by 4/3 rounded up\r\n    uint256 encodedLen = 4 * ((data.length + 2) / 3);\r\n\r\n    // add some extra buffer at the end required for the writing\r\n    string memory result = new string(encodedLen + 32);\r\n\r\n    assembly {\r\n      // set the actual output length\r\n      mstore(result, encodedLen)\r\n      \r\n      // prepare the lookup table\r\n      let tablePtr := add(table, 1)\r\n      \r\n      // input ptr\r\n      let dataPtr := data\r\n      let endPtr := add(dataPtr, mload(data))\r\n      \r\n      // result ptr, jump over length\r\n      let resultPtr := add(result, 32)\r\n      \r\n      // run over the input, 3 bytes at a time\r\n      for {} lt(dataPtr, endPtr) {}\r\n      {\r\n          dataPtr := add(dataPtr, 3)\r\n          \r\n          // read 3 bytes\r\n          let input := mload(dataPtr)\r\n          \r\n          // write 4 characters\r\n          mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\r\n          resultPtr := add(resultPtr, 1)\r\n          mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\r\n          resultPtr := add(resultPtr, 1)\r\n          mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\r\n          resultPtr := add(resultPtr, 1)\r\n          mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\r\n          resultPtr := add(resultPtr, 1)\r\n      }\r\n      \r\n      // padding with '='\r\n      switch mod(mload(data), 3)\r\n      case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\r\n      case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"compileAttributes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dogewood\",\"outputs\":[{\"internalType\":\"contract IDogewood\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"drawSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"drawSVGNew\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"gearNames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dogewood\",\"type\":\"address\"}],\"name\":\"setDogewood\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"drawContract_\",\"type\":\"address\"}],\"name\":\"setDrawContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"setTraitTypes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"traitNames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"traitSvgs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"traitSvgsNew\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"traitTypes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"gearType\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"values\",\"type\":\"uint8[]\"},{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"}],\"name\":\"uploadGearNames\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"trait\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"traitIds\",\"type\":\"uint8[]\"},{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"}],\"name\":\"uploadTraitNames\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"trait1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"id1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"trait2\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"trait2Ids\",\"type\":\"uint8[]\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"}],\"name\":\"uploadTraitSvgs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"trait1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"id1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"trait2\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"trait2Ids\",\"type\":\"uint8[]\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"}],\"name\":\"uploadTraitSvgsNew\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Traits", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ca1290712f3f67610ba459b5531cc89ff37645027f8d2746618fb91ffbb554cc"}]}