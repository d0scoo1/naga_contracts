{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"BasicToken.sol\":{\"content\":\"pragma solidity ^0.4.18;\\n\\n\\nimport \\\"./ERC20Basic.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n\\ncontract BasicToken is ERC20Basic {\\n    using SafeMath for uint256;\\n\\n    mapping(address =\\u003e uint256) balances;\\n\\n    uint256 totalSupply_;\\n\\n    function totalSupply() public view returns (uint256) {\\n        return totalSupply_;\\n    }\\n\\n    function transfer(address _to, uint256 _value) public returns (bool) {\\n        require(_to != address(0));\\n        require(_value \\u003c= balances[msg.sender]);\\n\\n        // SafeMath.sub will throw if there is not enough balance.\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    function balanceOf(address _owner) public view returns (uint256 balance) {\\n        return balances[_owner];\\n    }\\n\\n}\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.4.26;\\n\\nimport \\\"./BasicToken.sol\\\";\\n\\n\\ncontract ERC20 is BasicToken {\\n    function allowance(address owner, address spender) public view returns (uint256);\\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\\n    function approve(address spender, uint256 value) public returns (bool);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"ERC20Basic.sol\":{\"content\":\"pragma solidity ^0.4.26;\\n\\n\\ncontract ERC20Basic {\\n    function totalSupply() public view returns (uint256);\\n    function balanceOf(address who) public view returns (uint256);\\n    function transfer(address to, uint256 value) public returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.26;\\n\\nlibrary SafeMath {\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b \\u003c= a);\\n        return a - b;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        assert(c \\u003e= a);\\n        return c;\\n    }\\n}\"},\"StandardToken.sol\":{\"content\":\"pragma solidity ^0.4.26;\\n\\nimport \\\"./BasicToken.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n\\ncontract StandardToken is ERC20 {\\n\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) internal allowed;\\n\\n\\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\\n    require(_to != address(0));\\n    require(_value \\u003c= balances[_from]);\\n    require(_value \\u003c= allowed[_from][msg.sender]);\\n\\n    balances[_from] = balances[_from].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n    Transfer(_from, _to, _value);\\n    return true;\\n  }\\n\\n  function approve(address _spender, uint256 _value) public returns (bool) {\\n    allowed[msg.sender][_spender] = _value;\\n    Approval(msg.sender, _spender, _value);\\n    return true;\\n  }\\n\\n  function allowance(address _owner, address _spender) public view returns (uint256) {\\n    return allowed[_owner][_spender];\\n  }\\n\\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n    return true;\\n  }\\n\\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\\n    uint oldValue = allowed[msg.sender][_spender];\\n    if (_subtractedValue \\u003e oldValue) {\\n      allowed[msg.sender][_spender] = 0;\\n    } else {\\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\n    }\\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\n    return true;\\n  }\\n\\n}\\n\\n\"},\"SypherKoin.sol\":{\"content\":\"pragma solidity ^0.4.26;\\r\\n\\r\\ncontract SypherKoin {\\r\\n\\r\\n    function totalSupply() public constant returns (uint256 supply) {}\\r\\n    function balanceOf(address _owner) public constant returns (uint256 balance) {}\\r\\n    function transfer(address _to, uint256 _value) public returns (bool success) {}\\r\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\\r\\n    function approve(address _spender, uint256 _value) public returns (bool success) {}\\r\\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\\r\\n\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\r\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n}\\r\\n\\r\\ncontract StandardToken is SypherKoin {\\r\\n\\r\\n    function transfer(address _to, uint256 _value) public returns (bool success) {\\r\\n\\r\\n        if (balances[msg.sender] \\u003e= _value \\u0026\\u0026 _value \\u003e 0) {\\r\\n            balances[msg.sender] -= _value;\\r\\n            balances[_to] += _value;\\r\\n            emit Transfer(msg.sender, _to, _value);\\r\\n            return true;\\r\\n        } else { return false; }\\r\\n    }\\r\\n\\r\\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\\r\\n\\r\\n        if (balances[_from] \\u003e= _value \\u0026\\u0026 allowed[_from][msg.sender] \\u003e= _value \\u0026\\u0026 _value \\u003e 0) {\\r\\n            balances[_to] += _value;\\r\\n            balances[_from] -= _value;\\r\\n            allowed[_from][msg.sender] -= _value;\\r\\n           emit Transfer(_from, _to, _value);\\r\\n            return true;\\r\\n        } else { return false; }\\r\\n    }\\r\\n\\r\\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\\r\\n        return balances[_owner];\\r\\n    }\\r\\n\\r\\n    function approve(address _spender, uint256 _value) public returns (bool success) {\\r\\n        allowed[msg.sender][_spender] = _value;\\r\\n        emit Approval(msg.sender, _spender, _value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\\r\\n        return allowed[_owner][_spender];\\r\\n    }\\r\\n\\r\\n    mapping (address =\\u003e uint256) balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) allowed;\\r\\n    uint256 public totalSupply;\\r\\n}\\r\\n\\r\\ncontract BasicToken is StandardToken {\\r\\n\\r\\n    function () public {\\r\\n        //if ether is sent to this address, send it back.\\r\\n        throw;\\r\\n    }\\r\\n\\r\\n    /* Public variables of the token */\\r\\n    string public name;                   //Name of the token\\r\\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals\\r\\n    string public symbol;                 //An identifier: eg AXM\\r\\n    string public version = \\u0027H1.0\\u0027;       //human 0.1 standard. Just an arbitrary versioning scheme.\\r\\n\\r\\n//\\r\\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\\r\\n//\\r\\n\\r\\n//make sure this function name matches the contract name above. So if you\\u0027re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\\r\\n\\r\\n    function SypherKoin(\\r\\n        ) {\\r\\n        balances[msg.sender] = 100000;               // Give the creator all initial tokens (100000 for example)\\r\\n        totalSupply = 100000;                        // Update total supply (100000 for example)\\r\\n        name = \\\"SypherKoin\\\";                                   // Set the name for display purposes\\r\\n        decimals = 18;                            // Amount of decimals\\r\\n        symbol = \\\"SRK\\\";                               // Set the symbol for display purposes\\r\\n    }\\r\\n\\r\\n    /* Approves and then calls the receiving contract */\\r\\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\\r\\n        allowed[msg.sender][_spender] = _value;\\r\\n        Approval(msg.sender, _spender, _value);\\r\\n\\r\\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\\u0027t have to include a contract in here just for this.\\r\\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\\r\\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\\r\\n        if(!_spender.call(bytes4(bytes32(sha3(\\\"receiveApproval(address,uint256,address,bytes)\\\"))), msg.sender, _value, this, _extraData)) { throw; }\\r\\n        return true;\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "SypherKoin", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://7413db6ec68dd966b0427035228f7783629d4475730949ff74a8c7822d7526a0"}]}