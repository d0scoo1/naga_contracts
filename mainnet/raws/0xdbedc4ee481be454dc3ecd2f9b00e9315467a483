{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.11;\r\n\r\nlibrary Strings {\r\n  /**\r\n   * @notice Search for a needle in a haystack\r\n   * @param haystack The string to search\r\n   * @param needle The string to search for\r\n   */\r\n  function stringStartsWith(string memory haystack, string memory needle)\r\n    public\r\n    pure\r\n    returns (bool)\r\n  {\r\n    return indexOfStringInString(needle, haystack) == 0;\r\n  }\r\n\r\n  /**\r\n   * @notice Case insensitive string search\r\n   * @param needle The string to search for\r\n   * @param haystack The string to search\r\n   * @return Returns -1 if no match is found, otherwise returns the index of the match\r\n   */\r\n  function indexOfStringInString(string memory needle, string memory haystack)\r\n    public\r\n    pure\r\n    returns (int256)\r\n  {\r\n    bytes memory _needle = bytes(needle);\r\n    bytes memory _haystack = bytes(haystack);\r\n    if (_haystack.length < _needle.length) {\r\n      return -1;\r\n    }\r\n    bool _match;\r\n    for (uint256 haystackIdx; haystackIdx < _haystack.length; haystackIdx++) {\r\n      for (uint256 needleIdx; needleIdx < _needle.length; needleIdx++) {\r\n        uint8 needleChar = uint8(_needle[needleIdx]);\r\n        if (haystackIdx + needleIdx >= _haystack.length) {\r\n          return -1;\r\n        }\r\n        uint8 haystackChar = uint8(_haystack[haystackIdx + needleIdx]);\r\n        if (needleChar == haystackChar) {\r\n          _match = true;\r\n          if (needleIdx == _needle.length - 1) {\r\n            return int256(haystackIdx);\r\n          }\r\n        } else {\r\n          _match = false;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * @notice Check to see if two strings are exactly equal\r\n   */\r\n  function stringsEqual(string memory input1, string memory input2)\r\n    public\r\n    pure\r\n    returns (bool)\r\n  {\r\n    uint256 input1Length = bytes(input1).length;\r\n    uint256 input2Length = bytes(input2).length;\r\n    uint256 maxLength;\r\n    if (input1Length > input2Length) {\r\n      maxLength = input1Length;\r\n    } else {\r\n      maxLength = input2Length;\r\n    }\r\n    uint256 numberOfRowsToCompare = (maxLength / 32) + 1;\r\n    bytes32 input1Bytes32;\r\n    bytes32 input2Bytes32;\r\n    for (uint256 rowIdx; rowIdx < numberOfRowsToCompare; rowIdx++) {\r\n      uint256 offset = 0x20 * (rowIdx + 1);\r\n      assembly {\r\n        input1Bytes32 := mload(add(input1, offset))\r\n        input2Bytes32 := mload(add(input2, offset))\r\n      }\r\n      if (input1Bytes32 != input2Bytes32) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function atoi(string memory a, uint8 base) public pure returns (uint256 i) {\r\n    require(base == 2 || base == 8 || base == 10 || base == 16);\r\n    bytes memory buf = bytes(a);\r\n    for (uint256 p = 0; p < buf.length; p++) {\r\n      uint8 digit = uint8(buf[p]) - 0x30;\r\n      if (digit > 10) {\r\n        digit -= 7;\r\n      }\r\n      require(digit < base);\r\n      i *= base;\r\n      i += digit;\r\n    }\r\n    return i;\r\n  }\r\n\r\n  function itoa(uint256 i, uint8 base) public pure returns (string memory a) {\r\n    require(base == 2 || base == 8 || base == 10 || base == 16);\r\n    if (i == 0) {\r\n      return \"0\";\r\n    }\r\n    bytes memory buf = new bytes(256);\r\n    uint256 p = 0;\r\n    while (i > 0) {\r\n      uint8 digit = uint8(i % base);\r\n      uint8 ascii = digit + 0x30;\r\n      if (digit > 9) {\r\n        ascii += 7;\r\n      }\r\n      buf[p++] = bytes1(ascii);\r\n      i /= base;\r\n    }\r\n    uint256 length = p;\r\n    for (p = 0; p < length / 2; p++) {\r\n      buf[p] ^= buf[length - 1 - p];\r\n      buf[length - 1 - p] ^= buf[p];\r\n      buf[p] ^= buf[length - 1 - p];\r\n    }\r\n    return string(buf);\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"a\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"base\",\"type\":\"uint8\"}],\"name\":\"atoi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"needle\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"haystack\",\"type\":\"string\"}],\"name\":\"indexOfStringInString\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"base\",\"type\":\"uint8\"}],\"name\":\"itoa\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"a\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"haystack\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"needle\",\"type\":\"string\"}],\"name\":\"stringStartsWith\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"input1\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"input2\",\"type\":\"string\"}],\"name\":\"stringsEqual\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "Strings", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e8b8b86d3799b3919e8cf3be3974f866ba1973228bb249ff7a40b4e6d15c3e89"}]}