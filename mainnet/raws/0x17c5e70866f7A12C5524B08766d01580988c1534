{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"DecomposerMetadata.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n/**\\n* Metadata contract is upgradeable and returns metadata about Token\\n*/\\n\\nimport \\\"./Metadata.sol\\\";\\n\\ncontract DecomposerMetadata is Metadata {\\n    function tokenURI(uint _tokenId) public pure returns (string memory _infoUrl) {\\n        string memory base = \\\"https://decomposer.folia.app/v1/metadata/\\\";\\n        string memory id = uint2str(_tokenId);\\n        return base.toSlice().concat(id.toSlice());\\n    }\\n}\\n\"},\"Metadata.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n/**\\n* Metadata contract is upgradeable and returns metadata about Token\\n*/\\n\\nimport \\\"./strings.sol\\\";\\n\\ncontract Metadata {\\n    using strings for *;\\n\\n    function tokenURI(uint _tokenId) public pure returns (string memory _infoUrl) {\\n        string memory base = \\\"https://folia.app/v1/metadata/\\\";\\n        string memory id = uint2str(_tokenId);\\n        return base.toSlice().concat(id.toSlice());\\n    }\\n    function uint2str(uint i) internal pure returns (string memory) {\\n        if (i == 0) return \\\"0\\\";\\n        uint j = i;\\n        uint length;\\n        while (j != 0) {\\n            length++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(length);\\n        uint k = length - 1;\\n        while (i != 0) {\\n            uint _uint = 48 + i % 10;\\n            bstr[k--] = toBytes(_uint)[31];\\n            i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n    function toBytes(uint256 x) public pure returns (bytes memory b) {\\n        b = new bytes(32);\\n        assembly { mstore(add(b, 32), x) }\\n    }\\n}\\n\"},\"strings.sol\":{\"content\":\"/*\\n * @title String \\u0026 slice utility library for Solidity contracts.\\n * @author Nick Johnson \\u003carachnid@notdot.net\\u003e\\n */\\n\\npragma solidity ^0.5.0;\\n\\nlibrary strings {\\n    struct slice {\\n        uint _len;\\n        uint _ptr;\\n    }\\n\\n    function memcpy(uint dest, uint src, uint len) private pure {\\n        // Copy word-length chunks while possible\\n        for (; len \\u003e= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire string.\\n     * @param self The string to make a slice from.\\n     * @return A newly allocated slice containing the entire string.\\n     */\\n    function toSlice(string memory self) internal pure returns (slice memory) {\\n        uint ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns a newly allocated string containing the concatenation of\\n     *      `self` and `other`.\\n     * @param self The first slice to concatenate.\\n     * @param other The second slice to concatenate.\\n     * @return The concatenation of the two strings.\\n     */\\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\\n        string memory ret = new string(self._len + other._len);\\n        uint retptr;\\n        assembly {\\n            retptr := add(ret, 32)\\n        }\\n        memcpy(retptr, self._ptr, self._len);\\n        memcpy(retptr + self._len, other._ptr, other._len);\\n        return ret;\\n    }\\n}\\n\"}}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"toBytes\",\"outputs\":[{\"name\":\"b\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"_infoUrl\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "DecomposerMetadata", "CompilerVersion": "v0.5.0+commit.1d4f565a", "OptimizationUsed": "1", "Runs": "2000000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://b75b1bd840827b526a18e1eebd4124a49169d3ecff78e838d9c764cf17d026ea"}]}