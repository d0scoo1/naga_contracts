{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.13;\r\n\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n//\r\n//  ebox - https://ebox.io\r\n//\r\n//  ebox Liquidity Locker\r\n//\r\n//  Purpose:\r\n//  Enables users to lock LP tokens acquired by providing liquidity on DEXes (Uniswap, PancakeSwap etc), as well as any\r\n//  other ERC-20 tokens.\r\n//\r\n//  Users can:\r\n//  * lockCreate    Create a token lock that lasts until a user-defined release time\r\n//  * lockAdd       Add tokens to an existing lock\r\n//  * lockExtend    Extend an existing lock\r\n//  * lockTransfer  Transfer ownership of an existing lock to another address\r\n//  * lockRelease   Release tokens from an existing lock (partial amount, or all at once) that is past release time\r\n//\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\ncontract eboxLiquidityLocker\r\n{\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n    //  Global variables\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n\r\n    address                         contractOwner;\r\n    bool                            contractPaused;\r\n    uint                            contractReentrancyStatus;\r\n    uint constant                   CONTRACT_REENTRANCY_NOT_ENTERED = 1;\r\n    uint constant                   CONTRACT_REENTRANCY_ENTERED     = 2;\r\n\r\n    mapping(uint => TokenLock)      allLocks;\r\n    uint                            allLocksLength;\r\n\r\n    ERC20Interface                  feeToken;\r\n    FeeTier[]                       feeTiers;\r\n    uint                            feeDivisor;\r\n\r\n    mapping(address => bool)        hasSpecificFee;\r\n    mapping(address => uint)        specificFee;\r\n\r\n    mapping(ERC20Interface => uint) collectedFee;\r\n\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n    //  Data types\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n\r\n    struct TokenLock {\r\n        address                     owner;\r\n        ERC20Interface              token;\r\n        uint                        value;\r\n        uint                        releaseTime;\r\n    }\r\n\r\n    struct FeeTier {\r\n        uint                        minTokenAmount;\r\n        uint                        fee;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n    //  Events\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n\r\n    event LockCreate(uint indexed index, address indexed owner, ERC20Interface indexed token, uint value, uint releaseTime);\r\n    event LockAdd(uint indexed index, uint value);\r\n    event LockExtend(uint indexed index, uint newReleaseTime);\r\n    event LockTransfer(uint indexed index, address indexed oldOwner, address indexed newOwner);\r\n    event LockRelease(uint indexed index, uint value);\r\n\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n    //  Constructor, fallback, modifiers\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n\r\n    constructor(ERC20Interface _feeToken, FeeTier[] memory _feeTiers, uint _feeDivisor)\r\n    {\r\n        contractOwner = msg.sender;\r\n        contractReentrancyStatus = CONTRACT_REENTRANCY_NOT_ENTERED;\r\n\r\n        ownerSetFeeTiers(_feeToken, _feeTiers, _feeDivisor);\r\n    }\r\n\r\n    fallback() external payable\r\n    {\r\n        revert(\"Do not send funds directly to contract\");\r\n    }\r\n\r\n    modifier onlyOwner\r\n    {\r\n        require(msg.sender == contractOwner, \"Only available for contract owner\");\r\n        _;\r\n    }\r\n\r\n    modifier nonReentrant\r\n    {\r\n        require(contractReentrancyStatus != CONTRACT_REENTRANCY_ENTERED, \"Reentrant calling not allowed\");\r\n\r\n        contractReentrancyStatus = CONTRACT_REENTRANCY_ENTERED;\r\n        _;\r\n        contractReentrancyStatus = CONTRACT_REENTRANCY_NOT_ENTERED;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n    //  Functions: Getter\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n\r\n    function getLock(uint _index) external view returns(TokenLock memory)\r\n    {\r\n        require(_index < allLocksLength, \"Invalid index: Too high\");\r\n\r\n        return allLocks[_index];\r\n    }\r\n\r\n    function getFee() external view returns(uint, uint)\r\n    {\r\n        return (getFeeFor(msg.sender), feeDivisor);\r\n    }\r\n\r\n    function getFeeFor(address _addr) internal view returns(uint)\r\n    {\r\n        if(hasSpecificFee[_addr])\r\n            return specificFee[_addr];\r\n\r\n        for(uint i = feeTiers.length - 1; i > 0; i--)\r\n            if(feeToken.balanceOf(_addr) >= feeTiers[i].minTokenAmount)\r\n                return feeTiers[i].fee;\r\n\r\n        return feeTiers[0].fee;\r\n    }\r\n\r\n    function getFeeTiers() external view returns(ERC20Interface, FeeTier[] memory, uint)\r\n    {\r\n        return (feeToken, feeTiers, feeDivisor);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n    //  Functions: User\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n\r\n    function lockCreate(ERC20Interface _token, uint _value, uint _releaseTime) nonReentrant external\r\n    {\r\n        require(!contractPaused, \"Contract is paused\");\r\n        require(_value != 0, \"Invalid value: Must not be 0\");\r\n        require(_releaseTime > block.timestamp, \"Invalid release time: Must be in the future\");\r\n\r\n        uint oldBalance = _token.balanceOf(address(this));\r\n        _token.transferFrom(msg.sender, address(this), _value);\r\n        _value = _token.balanceOf(address(this)) - oldBalance;\r\n\r\n        uint fee = (_value * getFeeFor(msg.sender)) / feeDivisor;\r\n        collectedFee[_token] += fee;\r\n\r\n        allLocks[allLocksLength] = TokenLock(msg.sender, _token, _value - fee, _releaseTime);\r\n        allLocksLength++;\r\n\r\n        emit LockCreate(allLocksLength - 1, msg.sender, _token, _value - fee, _releaseTime);\r\n    }\r\n\r\n    function lockAdd(uint _index, uint _value) nonReentrant external\r\n    {\r\n        require(!contractPaused, \"Contract is paused\");\r\n        require(allLocks[_index].owner == msg.sender, \"Invalid index: Must be owner\");\r\n        require(allLocks[_index].value != 0, \"Invalid index: Lock must not be empty\");\r\n        require(_value != 0, \"Invalid value: Must not be 0\");\r\n\r\n        uint oldBalance = allLocks[_index].token.balanceOf(address(this));\r\n        allLocks[_index].token.transferFrom(msg.sender, address(this), _value);\r\n        _value = allLocks[_index].token.balanceOf(address(this)) - oldBalance;\r\n\r\n        uint fee = (_value * getFeeFor(msg.sender)) / feeDivisor;\r\n        collectedFee[allLocks[_index].token] += fee;\r\n\r\n        allLocks[_index].value += _value - fee;\r\n\r\n        emit LockAdd(_index, _value - fee);\r\n    }\r\n\r\n    function lockExtend(uint _index, uint _newReleaseTime) external\r\n    {\r\n        require(!contractPaused, \"Contract is paused\");\r\n        require(allLocks[_index].owner == msg.sender, \"Invalid index: Must be owner\");\r\n        require(allLocks[_index].value != 0, \"Invalid index: Lock must not be empty\");\r\n        require(allLocks[_index].releaseTime < _newReleaseTime, \"Invalid new release time: Must be greater than old release time\");\r\n        require(_newReleaseTime > block.timestamp, \"Invalid new release time: Must be in the future\");\r\n\r\n        allLocks[_index].releaseTime = _newReleaseTime;\r\n\r\n        emit LockExtend(_index, _newReleaseTime);\r\n    }\r\n\r\n    function lockTransfer(uint _index, address _newOwner) external\r\n    {\r\n//      require(!contractPaused, \"Contract is paused\");\r\n        require(allLocks[_index].owner == msg.sender, \"Invalid index: Must be owner\");\r\n        require(allLocks[_index].value != 0, \"Invalid index: Lock must not be empty\");\r\n        require(_newOwner != address(0), \"Invalid new owner: Must not be zero address\");\r\n        require(_newOwner != msg.sender, \"Invalid new owner: Must not be old owner\");\r\n\r\n        address oldOwner = allLocks[_index].owner;\r\n        allLocks[_index].owner = _newOwner;\r\n\r\n        emit LockTransfer(_index, oldOwner, _newOwner);\r\n    }\r\n\r\n    function lockRelease(uint _index, uint _value) external\r\n    {\r\n//      require(!contractPaused, \"Contract is paused\");\r\n        require(allLocks[_index].owner == msg.sender, \"Invalid index: Must be owner\");\r\n        require(allLocks[_index].releaseTime <= block.timestamp, \"Invalid index: Lock must be expired\");\r\n        require(allLocks[_index].value != 0, \"Invalid index: Lock must not be empty\");\r\n        require(allLocks[_index].value >= _value, \"Invalid value: Must be less than or equal to value stored in lock\");\r\n        \r\n        if(_value == 0)\r\n            _value = allLocks[_index].value;\r\n        allLocks[_index].value -= _value;\r\n\r\n        allLocks[_index].token.transfer(msg.sender, _value);\r\n\r\n        emit LockRelease(_index, _value);\r\n    }\r\n\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n    //  Functions: Owner / administrative\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n\r\n    function ownerSetContractPaused(bool _paused) onlyOwner external\r\n    {\r\n        contractPaused = _paused;\r\n    }\r\n\r\n    function ownerSetNewOwner(address _newOwner) onlyOwner external\r\n    {\r\n        require(_newOwner != address(0), \"Invalid new contract owner: Must not be zero address\");\r\n\r\n        contractOwner = _newOwner;\r\n    }\r\n\r\n    function ownerSetFeeTiers(ERC20Interface _feeToken, FeeTier[] memory _feeTiers, uint _feeDivisor) onlyOwner public\r\n    {\r\n        require(_feeTiers.length >= 1, \"Fee tiers: Must pass at least 1 tier\");\r\n        require(_feeTiers[0].minTokenAmount == 0, \"Fee tiers: Must include tier for 0 tokens\");\r\n        require(_feeDivisor != 0, \"Fee divisor: Must not be 0\");\r\n\r\n        feeToken = _feeToken;\r\n        feeDivisor = _feeDivisor;\r\n\r\n        uint oldLength = feeTiers.length;\r\n        for(uint i = 0; i < oldLength; i++)\r\n            feeTiers.pop();\r\n        \r\n        for(uint i = 0; i < _feeTiers.length; i++) {\r\n            if(i > 0)\r\n                require(_feeTiers[i].minTokenAmount > _feeTiers[i - 1].minTokenAmount, \"Fee tiers: Must be sorted by minTokenAmount in ascending order\");\r\n\r\n            feeTiers.push(_feeTiers[i]);\r\n        }\r\n    }\r\n\r\n    function ownerSetSpecificFeeFor(address _addr, bool _hasSpecificFee, uint _fee) onlyOwner external\r\n    {\r\n        hasSpecificFee[_addr] = _hasSpecificFee;\r\n\r\n        if(_hasSpecificFee)\r\n            specificFee[_addr] = _fee;\r\n    }\r\n\r\n    function ownerGetSpecificFeeFor(address _addr) onlyOwner external view returns(bool, uint)\r\n    {\r\n        return (hasSpecificFee[_addr], specificFee[_addr]);\r\n    }\r\n\r\n    function ownerCollectFee(ERC20Interface[] memory _tokens) onlyOwner external\r\n    {\r\n        for(uint i = 0; i < _tokens.length; i++) {\r\n            if(collectedFee[_tokens[i]] == 0)\r\n                continue;\r\n                \r\n            uint value = collectedFee[_tokens[i]];\r\n            collectedFee[_tokens[i]] = 0;\r\n\r\n            _tokens[i].transfer(msg.sender, value);\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------------------------------------------------\r\n}\r\n\r\n\r\n\r\ninterface ERC20Interface\r\n{\r\n    function totalSupply() external view returns(uint);\r\n    function balanceOf(address tokenOwner) external view returns(uint);\r\n    function allowance(address tokenOwner, address spender) external view returns(uint);\r\n    function transfer(address to, uint tokens) external returns(bool);\r\n    function approve(address spender, uint tokens) external returns(bool);\r\n    function transferFrom(address from, address to, uint tokens) external returns(bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ERC20Interface\",\"name\":\"_feeToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"internalType\":\"struct eboxLiquidityLocker.FeeTier[]\",\"name\":\"_feeTiers\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_feeDivisor\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LockAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract ERC20Interface\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"releaseTime\",\"type\":\"uint256\"}],\"name\":\"LockCreate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReleaseTime\",\"type\":\"uint256\"}],\"name\":\"LockExtend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LockRelease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"LockTransfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeTiers\",\"outputs\":[{\"internalType\":\"contract ERC20Interface\",\"name\":\"\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"internalType\":\"struct eboxLiquidityLocker.FeeTier[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getLock\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"contract ERC20Interface\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseTime\",\"type\":\"uint256\"}],\"internalType\":\"struct eboxLiquidityLocker.TokenLock\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"lockAdd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Interface\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_releaseTime\",\"type\":\"uint256\"}],\"name\":\"lockCreate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newReleaseTime\",\"type\":\"uint256\"}],\"name\":\"lockExtend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"lockRelease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"lockTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Interface[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"ownerCollectFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"ownerGetSpecificFeeFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"ownerSetContractPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20Interface\",\"name\":\"_feeToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"internalType\":\"struct eboxLiquidityLocker.FeeTier[]\",\"name\":\"_feeTiers\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_feeDivisor\",\"type\":\"uint256\"}],\"name\":\"ownerSetFeeTiers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"ownerSetNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_hasSpecificFee\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"ownerSetSpecificFeeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "eboxLiquidityLocker", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000033840024177a7daca3468912363bed8b425015c5000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000013880000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000c3500000000000000000000000000000000000000000000000000000000000000005", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9a712454114efe10c58e1d2801ca48ccec5857340af44c1550a9cb4ccaeb68ef"}]}