{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Cally.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n/**\\n\\n\\n    \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2557     \u2588\u2588\u2557  \u2588\u2588\u2557   \u2588\u2588\u2557\\n    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551  \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n    \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551   \u255a\u2588\u2588\u2588\u2588\u2554\u255d \\n    \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2551    \u255a\u2588\u2588\u2554\u255d  \\n    \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551   \\n     \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d   \\n                                      \\n\\n    \\n    NFT & ERC20 covered call vaults.\\n    this is intended to be a public good.\\n    pog pog pog.\\n    \\n\\n*/\\n\\nimport \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport \\\"solmate/utils/ReentrancyGuard.sol\\\";\\nimport \\\"openzeppelin/access/Ownable.sol\\\";\\n\\nimport \\\"./CallyNft.sol\\\";\\n\\n/// @title Cally - https://cally.finance\\n/// @author out.eth\\n/// @notice NFT & ERC20 covered call vaults\\ncontract Cally is CallyNft, ReentrancyGuard, Ownable, ERC721TokenReceiver {\\n    using SafeTransferLib for ERC20;\\n    using SafeTransferLib for address payable;\\n\\n    /// @notice Fires when a new vault has been created\\n    /// @param vaultId The newly minted vault NFT\\n    /// @param from The account that created the vault\\n    /// @param token The token address of the underlying asset\\n    event NewVault(uint256 indexed vaultId, address indexed from, address indexed token);\\n\\n    /// @notice Fires when an option has been bought from a vault\\n    /// @param optionId The newly minted option NFT\\n    /// @param from The account that bought the option\\n    /// @param token The token address of the underlying asset\\n    event BoughtOption(uint256 indexed optionId, address indexed from, address indexed token);\\n\\n    /// @notice Fires when an option is exercised\\n    /// @param optionId The option NFT which is being exercised\\n    /// @param from The account that exercised the option\\n    event ExercisedOption(uint256 indexed optionId, address indexed from);\\n\\n    /// @notice Fires when someone harvests their ETH balance\\n    /// @param from The account that is harvesting\\n    /// @param amount The amount of ETH which was harvested\\n    event Harvested(address indexed from, uint256 amount);\\n\\n    /// @notice Fires when someone initiates a withdrawal on their vault\\n    /// @param vaultId The vault NFT which is being withdrawn\\n    /// @param from The account that is initiating the withdrawal\\n    event InitiatedWithdrawal(uint256 indexed vaultId, address indexed from);\\n\\n    /// @notice Fires when someone withdraws their vault\\n    /// @param vaultId The vault NFT which is being withdrawn\\n    /// @param from The account that is withdrawing\\n    event Withdrawal(uint256 indexed vaultId, address indexed from);\\n\\n    /// @notice Fires when owner sets a new fee\\n    /// @param newFee The new feeRate\\n    event SetFee(uint256 indexed newFee);\\n\\n    /// @notice Fires when a vault owner updates the vault beneficiary\\n    /// @param vaultId The vault NFT which is being updated\\n    /// @param from The vault owner\\n    /// @param to The new beneficiary\\n    event SetVaultBeneficiary(uint256 indexed vaultId, address indexed from, address indexed to);\\n\\n    enum TokenType {\\n        ERC721,\\n        ERC20\\n    }\\n\\n    struct Vault {\\n        uint256 tokenIdOrAmount;\\n        address token;\\n        uint8 premiumIndex; // indexes into `premiumOptions`\\n        uint8 durationDays; // days\\n        uint8 dutchAuctionStartingStrikeIndex; // indexes into `strikeOptions`\\n        uint32 currentExpiration;\\n        bool isExercised;\\n        bool isWithdrawing;\\n        TokenType tokenType;\\n        uint16 feeRate;\\n        uint256 currentStrike;\\n        uint256 dutchAuctionReserveStrike;\\n    }\\n\\n    uint32 public constant AUCTION_DURATION = 24 hours;\\n\\n    // prettier-ignore\\n    uint256[17] public premiumOptions = [0.01 ether, 0.025 ether, 0.05 ether, 0.075 ether, 0.1 ether, 0.25 ether, 0.5 ether, 0.75 ether, 1.0 ether, 2.5 ether, 5.0 ether, 7.5 ether, 10 ether, 25 ether, 50 ether, 75 ether, 100 ether];\\n    // prettier-ignore\\n    uint256[19] public strikeOptions = [1 ether, 2 ether, 3 ether, 5 ether, 8 ether, 13 ether, 21 ether, 34 ether, 55 ether, 89 ether, 144 ether, 233 ether, 377 ether, 610 ether, 987 ether, 1597 ether, 2584 ether, 4181 ether, 6765 ether];\\n\\n    /// @notice the feeRate of the protocol, ex; 300 = 30%, 10 = 1%, 3 = 0.3% etc.\\n    uint16 public feeRate = 0;\\n    uint256 public protocolUnclaimedFees;\\n\\n    /// @notice The current vault index. Used for determining which\\n    ///         tokenId to use when minting a new vault. Increments by\\n    ///         2 on each new mint.\\n    uint256 public vaultIndex = 1;\\n\\n    /// @notice Mapping of vault tokenId -> vault information\\n    mapping(uint256 => Vault) private _vaults;\\n\\n    /// @notice Mapping of vault tokenId -> vault beneficiary.\\n    ///         Beneficiary is credited the premium when option is\\n    ///         purchased or strike ETH when option is exercised.\\n    mapping(uint256 => address) private _vaultBeneficiaries;\\n\\n    /// @notice The unharvested ethBalance of each account.\\n    mapping(address => uint256) public ethBalance;\\n\\n    /*********************\\n        ADMIN FUNCTIONS\\n    **********************/\\n\\n    /// @notice Sets the fee that is applied on exercise\\n    /// @param feeRate_ The new fee rate, ex: feeRate = 1% = 10.\\n    ///                 1000 is equal to 100% feeRate.\\n    function setFee(uint16 feeRate_) external payable onlyOwner {\\n        require(feeRate_ <= 300, \\\"Fee cannot be larger than 30%\\\");\\n\\n        feeRate = feeRate_;\\n\\n        emit SetFee(feeRate_);\\n    }\\n\\n    /// @notice Withdraws the protocol fees and sends to current owner\\n    /// @return amount The amount of ETH that was withdrawn\\n    function withdrawProtocolFees() external payable onlyOwner returns (uint256 amount) {\\n        amount = protocolUnclaimedFees;\\n        protocolUnclaimedFees = 0;\\n\\n        emit Harvested(msg.sender, amount);\\n\\n        payable(msg.sender).safeTransferETH(amount);\\n    }\\n\\n    /// @notice Sends any unclaimed ETH (premiums/strike) locked in the\\n    ///         contract to the current owner.\\n    /// @return amount The amount of ETH that was harvested\\n    function selfHarvest() external payable onlyOwner returns (uint256 amount) {\\n        // reset premiums\\n        amount = ethBalance[address(this)];\\n        ethBalance[address(this)] = 0;\\n\\n        emit Harvested(address(this), amount);\\n\\n        // transfer premiums to owner\\n        payable(msg.sender).safeTransferETH(amount);\\n    }\\n\\n    /**************************\\n        MAIN LOGIC FUNCTIONS\\n    ***************************/\\n\\n    /// @dev    A wrapper around createVault to allow for multiple\\n    ///         vault creations in a single transaction.\\n    function createVaults(\\n        uint256[] memory tokenIdOrAmounts,\\n        address[] memory tokens,\\n        uint8[] memory premiumIndexes,\\n        uint8[] memory durationDays,\\n        uint8[] memory dutchAuctionStartingStrikeIndexes,\\n        uint256[] memory dutchAuctionReserveStrikes,\\n        TokenType[] memory tokenTypes\\n    ) external returns (uint256[] memory vaultIds) {\\n        vaultIds = new uint256[](tokenIdOrAmounts.length);\\n\\n        for (uint256 i = 0; i < tokenIdOrAmounts.length; i++) {\\n            uint256 vaultId = createVault(\\n                tokenIdOrAmounts[i],\\n                tokens[i],\\n                premiumIndexes[i],\\n                durationDays[i],\\n                dutchAuctionStartingStrikeIndexes[i],\\n                dutchAuctionReserveStrikes[i],\\n                tokenTypes[i]\\n            );\\n\\n            vaultIds[i] = vaultId;\\n        }\\n    }\\n\\n    /*\\n        standard life cycle:\\n            createVault\\n            buyOption (repeats)\\n            exercise\\n            initiateWithdraw\\n            withdraw\\n\\n        [*] setVaultBeneficiary\\n        [*] harvest\\n\\n        [*] can be called anytime in life cycle\\n    */\\n\\n    /// @notice Creates a new vault that perpetually sells calls\\n    ///         on the underlying assets.\\n    /// @param tokenIdOrAmount The tokenId (NFT) or amount (ERC20) to vault\\n    /// @param token The address of the NFT or ERC20 contract to vault\\n    /// @param premiumIndex The index into the premiumOptions of each call that is sold\\n    /// @param durationDays The length/duration of each call that is sold in days\\n    /// @param dutchAuctionStartingStrikeIndex The index into the strikeOptions for the starting strike for each dutch auction\\n    /// @param dutchAuctionReserveStrike The reserve strike for each dutch auction\\n    /// @param tokenType The type of the underlying asset (NFT or ERC20)\\n    /// @return vaultId The tokenId of the newly minted vault NFT\\n    function createVault(\\n        uint256 tokenIdOrAmount,\\n        address token,\\n        uint8 premiumIndex,\\n        uint8 durationDays,\\n        uint8 dutchAuctionStartingStrikeIndex,\\n        uint256 dutchAuctionReserveStrike,\\n        TokenType tokenType\\n    ) public returns (uint256 vaultId) {\\n        require(premiumIndex < premiumOptions.length, \\\"Invalid premium index\\\");\\n        require(dutchAuctionStartingStrikeIndex < strikeOptions.length, \\\"Invalid strike index\\\");\\n        require(dutchAuctionReserveStrike < strikeOptions[dutchAuctionStartingStrikeIndex], \\\"Reserve strike too large\\\");\\n        require(durationDays > 0, \\\"durationDays too small\\\");\\n        require(token.code.length > 0, \\\"token is not contract\\\");\\n        require(token != address(this), \\\"token cannot be Cally contract\\\");\\n        require(tokenType == TokenType.ERC721 || tokenIdOrAmount > 0, \\\"tokenIdOrAmount is 0\\\");\\n\\n        // vault index should always be odd\\n        unchecked {\\n            vaultIndex = vaultIndex + 2;\\n        }\\n        vaultId = vaultIndex;\\n\\n        Vault storage vault = _vaults[vaultId];\\n\\n        vault.token = token;\\n        vault.premiumIndex = premiumIndex;\\n        vault.durationDays = durationDays;\\n        vault.dutchAuctionStartingStrikeIndex = dutchAuctionStartingStrikeIndex;\\n        vault.currentExpiration = uint32(block.timestamp);\\n        vault.tokenType = tokenType;\\n\\n        if (feeRate > 0) {\\n            vault.feeRate = feeRate;\\n        }\\n\\n        if (dutchAuctionReserveStrike > 0) {\\n            vault.dutchAuctionReserveStrike = dutchAuctionReserveStrike;\\n        }\\n\\n        // give msg.sender vault token\\n        _mint(msg.sender, vaultId);\\n\\n        emit NewVault(vaultId, msg.sender, token);\\n\\n        // transfer the NFTs or ERC20s to the contract\\n        if (tokenType == TokenType.ERC721) {\\n            vault.tokenIdOrAmount = tokenIdOrAmount;\\n            ERC721(token).safeTransferFrom(msg.sender, address(this), tokenIdOrAmount);\\n        } else {\\n            // check balance before and after to handle fee-on-transfer tokens\\n            uint256 balanceBefore = ERC20(token).balanceOf(address(this));\\n            ERC20(token).safeTransferFrom(msg.sender, address(this), tokenIdOrAmount);\\n            vault.tokenIdOrAmount = ERC20(token).balanceOf(address(this)) - balanceBefore;\\n        }\\n    }\\n\\n    /// @notice Buys an option from a vault at a fixed premium and variable strike\\n    ///         which is dependent on the dutch auction. Premium is credited to\\n    ///         vault beneficiary.\\n    /// @param vaultId The tokenId of the vault to buy the option from\\n    /// @return optionId The token id of the associated option NFT for the vaultId\\n    function buyOption(uint256 vaultId) external payable returns (uint256 optionId) {\\n        // vaultId should always be odd\\n        require(vaultId % 2 != 0, \\\"Not vault type\\\");\\n\\n        // check vault exists\\n        require(ownerOf(vaultId) != address(0), \\\"Vault does not exist\\\");\\n\\n        Vault storage vault = _vaults[vaultId];\\n\\n        // check that the vault still has the NFTs or ERC20s as collateral\\n        require(!vault.isExercised, \\\"Vault already exercised\\\");\\n\\n        // check that the vault is not in the withdrawing state\\n        require(!vault.isWithdrawing, \\\"Vault is being withdrawn\\\");\\n\\n        // check enough ETH was sent to cover the premium\\n        uint256 premium = premiumOptions[vault.premiumIndex];\\n        require(msg.value == premium, \\\"Incorrect ETH amount sent\\\");\\n\\n        // check option associated with the vault has expired\\n        uint32 auctionStartTimestamp = vault.currentExpiration;\\n        require(block.timestamp >= auctionStartTimestamp, \\\"Auction not started\\\");\\n\\n        // set new currentStrike based on the dutch auction curve\\n        vault.currentStrike = getDutchAuctionStrike(\\n            strikeOptions[vault.dutchAuctionStartingStrikeIndex],\\n            auctionStartTimestamp + AUCTION_DURATION,\\n            vault.dutchAuctionReserveStrike\\n        );\\n\\n        // set new expiration\\n        vault.currentExpiration = uint32(block.timestamp) + uint32(vault.durationDays) * 1 days;\\n\\n        // force transfer the vault's associated option from old owner to new owner.\\n        // option id for a respective vault is always vaultId + 1.\\n        optionId = vaultId + 1;\\n        _forceTransfer(msg.sender, optionId);\\n\\n        // increment vault beneficiary's unclaimed premiums\\n        address beneficiary = getVaultBeneficiary(vaultId);\\n        ethBalance[beneficiary] += msg.value;\\n\\n        emit BoughtOption(optionId, msg.sender, vault.token);\\n    }\\n\\n    /// @notice Exercises a call option and sends the underlying assets to the\\n    ///         exerciser and credits the strike ETH to the vault beneficiary.\\n    /// @param optionId The tokenId of the option to exercise\\n    function exercise(uint256 optionId) external payable {\\n        // optionId should always be even\\n        require(optionId % 2 == 0, \\\"Not option type\\\");\\n\\n        // check owner\\n        require(msg.sender == ownerOf(optionId), \\\"You are not the owner\\\");\\n\\n        // vault id for a respective option is always optionId - 1.\\n        uint256 vaultId = optionId - 1;\\n        Vault storage vault = _vaults[vaultId];\\n\\n        // check option hasn't expired\\n        require(block.timestamp < vault.currentExpiration, \\\"Option has expired\\\");\\n\\n        // check correct ETH amount was sent to pay the strike\\n        require(msg.value == vault.currentStrike, \\\"Incorrect ETH sent for strike\\\");\\n\\n        // burn the option token\\n        _burn(optionId);\\n\\n        // mark the vault as exercised\\n        vault.isExercised = true;\\n\\n        // collect protocol fee\\n        uint256 fee = 0;\\n        if (vault.feeRate > 0) {\\n            // ex: 5% fees means vault.feeRate == 50\\n            fee = (msg.value * vault.feeRate) / 1000;\\n            protocolUnclaimedFees += fee;\\n        }\\n\\n        // increment vault beneficiary's ETH balance\\n        ethBalance[getVaultBeneficiary(vaultId)] += msg.value - fee;\\n\\n        emit ExercisedOption(optionId, msg.sender);\\n\\n        // transfer the NFTs or ERC20s to the exerciser\\n        vault.tokenType == TokenType.ERC721\\n            ? ERC721(vault.token).safeTransferFrom(address(this), msg.sender, vault.tokenIdOrAmount)\\n            : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);\\n    }\\n\\n    /// @notice Initiates a withdrawal so that the vault will no longer sell\\n    ///         another call once the currently active call option has expired.\\n    /// @param vaultId The tokenId of the vault to initiate a withdrawal on\\n    function initiateWithdraw(uint256 vaultId) external {\\n        // vaultId should always be odd\\n        require(vaultId % 2 != 0, \\\"Not vault type\\\");\\n\\n        // check msg.sender owns the vault\\n        require(msg.sender == ownerOf(vaultId), \\\"You are not the owner\\\");\\n\\n        // check vault is not already withdrawing\\n        require(!_vaults[vaultId].isWithdrawing, \\\"Vault is already withdrawing\\\");\\n\\n        _vaults[vaultId].isWithdrawing = true;\\n\\n        emit InitiatedWithdrawal(vaultId, msg.sender);\\n    }\\n\\n    /// @notice Sends the underlying assets back to the vault owner and claims any\\n    ///         unharvested premiums for the owner. The vault NFT and it's associated\\n    ///         option NFT are burned.\\n    /// @param vaultId The tokenId of the vault to withdraw\\n    function withdraw(uint256 vaultId) external nonReentrant {\\n        // vaultId should always be odd\\n        require(vaultId % 2 != 0, \\\"Not vault type\\\");\\n\\n        // check owner\\n        require(msg.sender == ownerOf(vaultId), \\\"You are not the owner\\\");\\n\\n        Vault storage vault = _vaults[vaultId];\\n\\n        // check vault can be withdrawn\\n        require(!vault.isExercised, \\\"Vault already exercised\\\");\\n        require(vault.isWithdrawing, \\\"Vault not in withdrawable state\\\");\\n        require(block.timestamp > vault.currentExpiration, \\\"Option still active\\\");\\n\\n        // burn option and vault\\n        uint256 optionId = vaultId + 1;\\n        _burn(optionId);\\n        _burn(vaultId);\\n\\n        emit Withdrawal(vaultId, msg.sender);\\n\\n        // claim any ETH still in the account\\n        harvest();\\n\\n        // transfer the NFTs or ERC20s back to the owner\\n        vault.tokenType == TokenType.ERC721\\n            ? ERC721(vault.token).safeTransferFrom(address(this), msg.sender, vault.tokenIdOrAmount)\\n            : ERC20(vault.token).safeTransfer(msg.sender, vault.tokenIdOrAmount);\\n    }\\n\\n    /// @notice Sets the vault beneficiary that will receive premiums/strike ETH from the vault\\n    /// @param vaultId The tokenId of the vault to update\\n    /// @param beneficiary The new vault beneficiary\\n    function setVaultBeneficiary(uint256 vaultId, address beneficiary) external {\\n        // vaultIds should always be odd\\n        require(vaultId % 2 != 0, \\\"Not vault type\\\");\\n        require(msg.sender == ownerOf(vaultId), \\\"Not owner\\\");\\n\\n        _vaultBeneficiaries[vaultId] = beneficiary;\\n\\n        emit SetVaultBeneficiary(vaultId, msg.sender, beneficiary);\\n    }\\n\\n    /// @notice Sends any unclaimed ETH (premiums/strike) to the msg.sender\\n    /// @return amount The amount of ETH that was harvested\\n    function harvest() public returns (uint256 amount) {\\n        // reset premiums\\n        amount = ethBalance[msg.sender];\\n        ethBalance[msg.sender] = 0;\\n\\n        emit Harvested(msg.sender, amount);\\n\\n        // transfer premiums to msg.sender\\n        payable(msg.sender).safeTransferETH(amount);\\n    }\\n\\n    /**********************\\n        GETTER FUNCTIONS\\n    ***********************/\\n\\n    /// @notice Get the current beneficiary for a vault\\n    /// @param vaultId The tokenId of the vault to fetch the beneficiary for\\n    /// @return beneficiary The beneficiary for the vault\\n    function getVaultBeneficiary(uint256 vaultId) public view returns (address beneficiary) {\\n        address currentBeneficiary = _vaultBeneficiaries[vaultId];\\n\\n        // return the current owner if vault beneficiary is not set\\n        beneficiary = currentBeneficiary == address(0) ? ownerOf(vaultId) : currentBeneficiary;\\n    }\\n\\n    /// @notice Get details for a vault\\n    /// @param vaultId The tokenId of the vault to fetch the details for\\n    /// @return vault The vault details for the vaultId\\n    function vaults(uint256 vaultId) external view returns (Vault memory) {\\n        return _vaults[vaultId];\\n    }\\n\\n    /// @notice Get the current dutch auction strike for a starting strike, auction\\n    ///         end timestamp, and reserve strike. Strike decreases quadratically\\n    ///         to reserveStrike over time starting at startingStrike. Minimum\\n    ///         value returned is reserveStrike.\\n    /// @param startingStrike The starting strike value\\n    /// @param auctionEndTimestamp The unix timestamp when the auction ends\\n    /// @param reserveStrike The minimum value for the strike\\n    /// @return strike The strike\\n    function getDutchAuctionStrike(\\n        uint256 startingStrike,\\n        uint32 auctionEndTimestamp,\\n        uint256 reserveStrike\\n    ) public view returns (uint256 strike) {\\n        /*\\n            delta = max(auctionEnd - currentTimestamp, 0)\\n            progress = delta / auctionDuration\\n            strike = (progress^2 * (startingStrike - reserveStrike)) + reserveStrike\\n        */\\n        uint256 delta = auctionEndTimestamp > block.timestamp ? auctionEndTimestamp - block.timestamp : 0;\\n        uint256 progress = (1e18 * delta) / AUCTION_DURATION;\\n        strike = (((progress * progress * (startingStrike - reserveStrike)) / 1e18) / 1e18) + reserveStrike;\\n    }\\n\\n    /*************************\\n        OVERRIDES FUNCTIONS\\n    **************************/\\n\\n    /// @dev Resets the beneficiary address when transferring vault NFTs.\\n    ///      The new beneficiary will be the account receiving the vault NFT.\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public override {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // reset the beneficiary\\n        bool isVaultToken = id % 2 != 0;\\n        if (isVaultToken) {\\n            _vaultBeneficiaries[id] = address(0);\\n        }\\n\\n        _ownerOf[id] = to;\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        require(_ownerOf[tokenId] != address(0), \\\"URI query for NOT_MINTED token\\\");\\n\\n        bool isVaultToken = tokenId % 2 != 0;\\n        uint256 vaultId = isVaultToken ? tokenId : tokenId - 1;\\n        Vault memory vault = _vaults[vaultId];\\n\\n        string memory jsonStr = renderJson(\\n            vault.token,\\n            vault.tokenIdOrAmount,\\n            premiumOptions[vault.premiumIndex],\\n            vault.durationDays,\\n            strikeOptions[vault.dutchAuctionStartingStrikeIndex],\\n            vault.currentExpiration,\\n            vault.currentStrike,\\n            vault.isExercised,\\n            isVaultToken\\n        );\\n\\n        return string.concat(\\\"data:application/json;base64,\\\", Base64.encode(bytes(jsonStr)));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    event Debug(bool one, bool two, uint256 retsize);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() virtual {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/CallyNft.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"solmate/tokens/ERC721.sol\\\";\\nimport \\\"openzeppelin/utils/Strings.sol\\\";\\nimport \\\"hot-chain-svg/SVG.sol\\\";\\nimport \\\"base64/base64.sol\\\";\\n\\n// removes balanceOf modifications\\n// questionable tradeoff but given our use-case it's reasonable\\n// saves 20k gas when minting which about 30% gas on buys/vault creations\\nabstract contract CallyNft is ERC721(\\\"Cally\\\", \\\"CALL\\\") {\\n    // remove balanceOf modifications\\n    function _mint(address to, uint256 id) internal override {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    // burns a token without checking owner address is not 0\\n    // and removes balanceOf modifications\\n    function _burn(uint256 id) internal override {\\n        address owner = _ownerOf[id];\\n\\n        delete _ownerOf[id];\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    // set balanceOf to max for all users\\n    function balanceOf(address owner) public pure override returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n        return type(uint256).max;\\n    }\\n\\n    // forceTransfer option position NFT out of owner's wallet and give to new buyer\\n    function _forceTransfer(address to, uint256 id) internal {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        address from = _ownerOf[id];\\n        _ownerOf[id] = to;\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function renderJson(\\n        address token_,\\n        uint256 tokenIdOrAmount_,\\n        uint256 premium_,\\n        uint256 durationDays_,\\n        uint256 dutchAuctionStartingStrike_,\\n        uint256 currentExpiration_,\\n        uint256 currentStrike_,\\n        bool isExercised_,\\n        bool isVault_\\n    ) public pure returns (string memory) {\\n        string memory token = addressToString(token_);\\n        string memory tokenIdOrAmount = Strings.toString(tokenIdOrAmount_);\\n        string memory premium = Strings.toString(premium_);\\n        string memory durationDays = Strings.toString(durationDays_);\\n        string memory dutchAuctionStartingStrike = Strings.toString(dutchAuctionStartingStrike_);\\n        string memory currentExpiration = Strings.toString(currentExpiration_);\\n        string memory currentStrike = Strings.toString(currentStrike_);\\n        string memory isExercised = Strings.toString(isExercised_ ? 1 : 0);\\n        string memory nftType = isVault_ ? \\\"Vault\\\" : \\\"Option\\\";\\n\\n        string memory svgStr = renderSvg(\\n            token,\\n            tokenIdOrAmount,\\n            premium,\\n            durationDays,\\n            dutchAuctionStartingStrike,\\n            currentExpiration,\\n            currentStrike,\\n            isExercised,\\n            nftType\\n        );\\n\\n        string memory json = string.concat(\\n            /* solhint-disable quotes */\\n            '{\\\"name\\\":\\\"',\\n            \\\"Cally\\\",\\n            '\\\",\\\"description\\\":\\\"',\\n            \\\"NFT and ERC20 covered call vaults\\\",\\n            '\\\",\\\"image\\\": \\\"data:image/svg+xml;base64,',\\n            Base64.encode(bytes(svgStr)),\\n            '\\\",\\\"attributes\\\": [',\\n            '{ \\\"trait_type\\\": \\\"token\\\",',\\n            '\\\"value\\\": \\\"',\\n            token,\\n            '\\\"},',\\n            '{ \\\"trait_type\\\": \\\"tokenIdOrAmount\\\",',\\n            '\\\"value\\\": \\\"',\\n            tokenIdOrAmount,\\n            '\\\"},',\\n            '{ \\\"trait_type\\\": \\\"premium\\\",',\\n            '\\\"value\\\": \\\"',\\n            premium,\\n            '\\\"},',\\n            '{ \\\"trait_type\\\": \\\"durationDays\\\",',\\n            '\\\"value\\\": \\\"',\\n            durationDays,\\n            '\\\"},',\\n            '{ \\\"trait_type\\\": \\\"dutchAuctionStartingStrike\\\",',\\n            '\\\"value\\\": \\\"',\\n            dutchAuctionStartingStrike,\\n            '\\\"},',\\n            '{ \\\"trait_type\\\": \\\"currentExpiration\\\",',\\n            '\\\"value\\\": \\\"',\\n            currentExpiration,\\n            '\\\"},',\\n            '{ \\\"trait_type\\\": \\\"currentStrike\\\",',\\n            '\\\"value\\\": \\\"',\\n            currentStrike,\\n            '\\\"},',\\n            '{ \\\"trait_type\\\": \\\"isExercised\\\",',\\n            '\\\"value\\\": \\\"',\\n            isExercised,\\n            '\\\"},',\\n            '{ \\\"trait_type\\\": \\\"nftType\\\",',\\n            '\\\"value\\\": \\\"',\\n            nftType,\\n            '\\\"}',\\n            \\\"]}\\\"\\n            /* solhint-enable quotes */\\n        );\\n\\n        return json;\\n    }\\n\\n    function renderSvg(\\n        string memory token,\\n        string memory tokenIdOrAmount,\\n        string memory premium,\\n        string memory durationDays,\\n        string memory dutchAuctionStartingStrike,\\n        string memory currentExpiration,\\n        string memory currentStrike,\\n        string memory isExercised,\\n        string memory nftType\\n    ) public pure returns (string memory) {\\n        return\\n            string.concat(\\n                // solhint-disable-next-line quotes\\n                '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"350\\\" height=\\\"350\\\" style=\\\"background:#000\\\">',\\n                svg.text(\\n                    string.concat(\\n                        svg.prop(\\\"x\\\", \\\"10\\\"),\\n                        svg.prop(\\\"y\\\", \\\"20\\\"),\\n                        svg.prop(\\\"font-size\\\", \\\"12\\\"),\\n                        svg.prop(\\\"fill\\\", \\\"white\\\")\\n                    ),\\n                    string.concat(svg.cdata(\\\"Token: \\\"), token)\\n                ),\\n                svg.text(\\n                    string.concat(\\n                        svg.prop(\\\"x\\\", \\\"10\\\"),\\n                        svg.prop(\\\"y\\\", \\\"40\\\"),\\n                        svg.prop(\\\"font-size\\\", \\\"12\\\"),\\n                        svg.prop(\\\"fill\\\", \\\"white\\\")\\n                    ),\\n                    string.concat(svg.cdata(\\\"Token ID or Amount: \\\"), tokenIdOrAmount)\\n                ),\\n                svg.text(\\n                    string.concat(\\n                        svg.prop(\\\"x\\\", \\\"10\\\"),\\n                        svg.prop(\\\"y\\\", \\\"60\\\"),\\n                        svg.prop(\\\"font-size\\\", \\\"12\\\"),\\n                        svg.prop(\\\"fill\\\", \\\"white\\\")\\n                    ),\\n                    string.concat(svg.cdata(\\\"Premium (WEI): \\\"), premium)\\n                ),\\n                svg.text(\\n                    string.concat(\\n                        svg.prop(\\\"x\\\", \\\"10\\\"),\\n                        svg.prop(\\\"y\\\", \\\"80\\\"),\\n                        svg.prop(\\\"font-size\\\", \\\"12\\\"),\\n                        svg.prop(\\\"fill\\\", \\\"white\\\")\\n                    ),\\n                    string.concat(svg.cdata(\\\"Duration (days): \\\"), durationDays)\\n                ),\\n                svg.text(\\n                    string.concat(\\n                        svg.prop(\\\"x\\\", \\\"10\\\"),\\n                        svg.prop(\\\"y\\\", \\\"100\\\"),\\n                        svg.prop(\\\"font-size\\\", \\\"12\\\"),\\n                        svg.prop(\\\"fill\\\", \\\"white\\\")\\n                    ),\\n                    string.concat(svg.cdata(\\\"Starting strike (WEI): \\\"), dutchAuctionStartingStrike)\\n                ),\\n                svg.text(\\n                    string.concat(\\n                        svg.prop(\\\"x\\\", \\\"10\\\"),\\n                        svg.prop(\\\"y\\\", \\\"120\\\"),\\n                        svg.prop(\\\"font-size\\\", \\\"12\\\"),\\n                        svg.prop(\\\"fill\\\", \\\"white\\\")\\n                    ),\\n                    string.concat(svg.cdata(\\\"Expiration (UNIX): \\\"), currentExpiration)\\n                ),\\n                svg.text(\\n                    string.concat(\\n                        svg.prop(\\\"x\\\", \\\"10\\\"),\\n                        svg.prop(\\\"y\\\", \\\"140\\\"),\\n                        svg.prop(\\\"font-size\\\", \\\"12\\\"),\\n                        svg.prop(\\\"fill\\\", \\\"white\\\")\\n                    ),\\n                    string.concat(svg.cdata(\\\"Strike (WEI): \\\"), currentStrike)\\n                ),\\n                svg.text(\\n                    string.concat(\\n                        svg.prop(\\\"x\\\", \\\"10\\\"),\\n                        svg.prop(\\\"y\\\", \\\"160\\\"),\\n                        svg.prop(\\\"font-size\\\", \\\"12\\\"),\\n                        svg.prop(\\\"fill\\\", \\\"white\\\")\\n                    ),\\n                    string.concat(svg.cdata(\\\"Exercised (y/n): \\\"), isExercised)\\n                ),\\n                svg.text(\\n                    string.concat(\\n                        svg.prop(\\\"x\\\", \\\"10\\\"),\\n                        svg.prop(\\\"y\\\", \\\"180\\\"),\\n                        svg.prop(\\\"font-size\\\", \\\"12\\\"),\\n                        svg.prop(\\\"fill\\\", \\\"white\\\")\\n                    ),\\n                    string.concat(svg.cdata(\\\"Type: \\\"), nftType)\\n                ),\\n                \\\"</svg>\\\"\\n            );\\n    }\\n\\n    function addressToString(address account) public pure returns (string memory) {\\n        bytes memory data = abi.encodePacked(account);\\n\\n        bytes memory alphabet = \\\"0123456789abcdef\\\";\\n\\n        bytes memory str = new bytes(2 + data.length * 2);\\n        str[0] = \\\"0\\\";\\n        str[1] = \\\"x\\\";\\n        for (uint256 i = 0; i < data.length; i++) {\\n            str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\\n            str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\\n        }\\n\\n        return string(str);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/hot-chain-svg/contracts/SVG.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\nimport './Utils.sol';\\n\\n// Core SVG utilitiy library which helps us construct\\n// onchain SVG's with a simple, web-like API.\\nlibrary svg {\\n    /* MAIN ELEMENTS */\\n    function g(string memory _props, string memory _children)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return el('g', _props, _children);\\n    }\\n\\n    function path(string memory _props, string memory _children)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return el('path', _props, _children);\\n    }\\n\\n    function text(string memory _props, string memory _children)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return el('text', _props, _children);\\n    }\\n\\n    function line(string memory _props, string memory _children)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return el('line', _props, _children);\\n    }\\n\\n    function circle(string memory _props, string memory _children)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return el('circle', _props, _children);\\n    }\\n\\n    function circle(string memory _props)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return el('circle', _props);\\n    }\\n\\n    function rect(string memory _props, string memory _children)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return el('rect', _props, _children);\\n    }\\n\\n    function rect(string memory _props)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return el('rect', _props);\\n    }\\n\\n    function filter(string memory _props, string memory _children)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return el('filter', _props, _children);\\n    }\\n\\n    function cdata(string memory _content)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string.concat('<![CDATA[', _content, ']]>');\\n    }\\n\\n    /* GRADIENTS */\\n    function radialGradient(string memory _props, string memory _children)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return el('radialGradient', _props, _children);\\n    }\\n\\n    function linearGradient(string memory _props, string memory _children)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return el('linearGradient', _props, _children);\\n    }\\n\\n    function gradientStop(\\n        uint256 offset,\\n        string memory stopColor,\\n        string memory _props\\n    ) internal pure returns (string memory) {\\n        return\\n            el(\\n                'stop',\\n                string.concat(\\n                    prop('stop-color', stopColor),\\n                    ' ',\\n                    prop('offset', string.concat(utils.uint2str(offset), '%')),\\n                    ' ',\\n                    _props\\n                )\\n            );\\n    }\\n\\n    function animateTransform(string memory _props)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return el('animateTransform', _props);\\n    }\\n\\n    function image(string memory _href, string memory _props)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return\\n            el(\\n                'image',\\n                string.concat(prop('href', _href), ' ', _props)\\n            );\\n    }\\n\\n    /* COMMON */\\n    // A generic element, can be used to construct any SVG (or HTML) element\\n    function el(\\n        string memory _tag,\\n        string memory _props,\\n        string memory _children\\n    ) internal pure returns (string memory) {\\n        return\\n            string.concat(\\n                '<',\\n                _tag,\\n                ' ',\\n                _props,\\n                '>',\\n                _children,\\n                '</',\\n                _tag,\\n                '>'\\n            );\\n    }\\n\\n    // A generic element, can be used to construct any SVG (or HTML) element without children\\n    function el(\\n        string memory _tag,\\n        string memory _props\\n    ) internal pure returns (string memory) {\\n        return\\n            string.concat(\\n                '<',\\n                _tag,\\n                ' ',\\n                _props,\\n                '/>'\\n            );\\n    }\\n\\n    // an SVG attribute\\n    function prop(string memory _key, string memory _val)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string.concat(_key, '=', '\\\"', _val, '\\\" ');\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/base64/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n                    decodedLen := sub(decodedLen, 1)\\n                }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               // read 4 characters\\n               dataPtr := add(dataPtr, 4)\\n               let input := mload(dataPtr)\\n\\n               // write 3 bytes\\n               let output := add(\\n                   add(\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\n                   add(\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\n                    )\\n                )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/hot-chain-svg/contracts/Utils.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\n// Core utils used extensively to format CSS and numbers.\\nlibrary utils {\\n    // used to simulate empty strings\\n    string internal constant NULL = '';\\n\\n    // formats a CSS variable line. includes a semicolon for formatting.\\n    function setCssVar(string memory _key, string memory _val)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string.concat('--', _key, ':', _val, ';');\\n    }\\n\\n    // formats getting a css variable\\n    function getCssVar(string memory _key)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string.concat('var(--', _key, ')');\\n    }\\n\\n    // formats getting a def URL\\n    function getDefURL(string memory _id)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string.concat('url(#', _id, ')');\\n    }\\n\\n    // formats rgba white with a specified opacity / alpha\\n    function white_a(uint256 _a) internal pure returns (string memory) {\\n        return rgba(255, 255, 255, _a);\\n    }\\n\\n    // formats rgba black with a specified opacity / alpha\\n    function black_a(uint256 _a) internal pure returns (string memory) {\\n        return rgba(0, 0, 0, _a);\\n    }\\n\\n    // formats generic rgba color in css\\n    function rgba(\\n        uint256 _r,\\n        uint256 _g,\\n        uint256 _b,\\n        uint256 _a\\n    ) internal pure returns (string memory) {\\n        string memory formattedA = _a < 100\\n            ? string.concat('0.', utils.uint2str(_a))\\n            : '1';\\n        return\\n            string.concat(\\n                'rgba(',\\n                utils.uint2str(_r),\\n                ',',\\n                utils.uint2str(_g),\\n                ',',\\n                utils.uint2str(_b),\\n                ',',\\n                formattedA,\\n                ')'\\n            );\\n    }\\n\\n    // checks if two strings are equal\\n    function stringsEqual(string memory _a, string memory _b)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return\\n            keccak256(abi.encodePacked(_a)) == keccak256(abi.encodePacked(_b));\\n    }\\n\\n    // returns the length of a string in characters\\n    function utfStringLength(string memory _str)\\n        internal\\n        pure\\n        returns (uint256 length)\\n    {\\n        uint256 i = 0;\\n        bytes memory string_rep = bytes(_str);\\n\\n        while (i < string_rep.length) {\\n            if (string_rep[i] >> 7 == 0) i += 1;\\n            else if (string_rep[i] >> 5 == bytes1(uint8(0x6))) i += 2;\\n            else if (string_rep[i] >> 4 == bytes1(uint8(0xE))) i += 3;\\n            else if (string_rep[i] >> 3 == bytes1(uint8(0x1E)))\\n                i += 4;\\n                //For safety\\n            else i += 1;\\n\\n            length++;\\n        }\\n    }\\n\\n    // converts an unsigned integer to a string\\n    function uint2str(uint256 _i)\\n        internal\\n        pure\\n        returns (string memory _uintAsString)\\n    {\\n        if (_i == 0) {\\n            return '0';\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len;\\n        while (_i != 0) {\\n            k = k - 1;\\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"base64/=lib/base64/\",\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hot-chain-svg/=lib/hot-chain-svg/contracts/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"BoughtOption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"ExercisedOption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Harvested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"InitiatedWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"NewVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"SetFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"SetVaultBeneficiary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AUCTION_DURATION\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addressToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"buyOption\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenIdOrAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"premiumIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"durationDays\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"dutchAuctionStartingStrikeIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dutchAuctionReserveStrike\",\"type\":\"uint256\"},{\"internalType\":\"enum Cally.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"}],\"name\":\"createVault\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIdOrAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"premiumIndexes\",\"type\":\"uint8[]\"},{\"internalType\":\"uint8[]\",\"name\":\"durationDays\",\"type\":\"uint8[]\"},{\"internalType\":\"uint8[]\",\"name\":\"dutchAuctionStartingStrikeIndexes\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"dutchAuctionReserveStrikes\",\"type\":\"uint256[]\"},{\"internalType\":\"enum Cally.TokenType[]\",\"name\":\"tokenTypes\",\"type\":\"uint8[]\"}],\"name\":\"createVaults\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"vaultIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"optionId\",\"type\":\"uint256\"}],\"name\":\"exercise\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRate\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startingStrike\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"auctionEndTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"reserveStrike\",\"type\":\"uint256\"}],\"name\":\"getDutchAuctionStrike\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"strike\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"getVaultBeneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"initiateWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"premiumOptions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolUnclaimedFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenIdOrAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premium_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"durationDays_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dutchAuctionStartingStrike_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentExpiration_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentStrike_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isExercised_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isVault_\",\"type\":\"bool\"}],\"name\":\"renderJson\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"token\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenIdOrAmount\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"premium\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"durationDays\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"dutchAuctionStartingStrike\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"currentExpiration\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"currentStrike\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"isExercised\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"nftType\",\"type\":\"string\"}],\"name\":\"renderSvg\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selfHarvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"feeRate_\",\"type\":\"uint16\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"setVaultBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"strikeOptions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"vaults\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenIdOrAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"premiumIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"durationDays\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"dutchAuctionStartingStrikeIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currentExpiration\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isExercised\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isWithdrawing\",\"type\":\"bool\"},{\"internalType\":\"enum Cally.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"feeRate\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"currentStrike\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dutchAuctionReserveStrike\",\"type\":\"uint256\"}],\"internalType\":\"struct Cally.Vault\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawProtocolFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "Cally", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}