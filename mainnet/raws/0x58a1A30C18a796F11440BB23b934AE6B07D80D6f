{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/core/CircumnavigationOpenEdition.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\nimport \\\"./NiftyBuilderInstance.sol\\\";\\nimport \\\"./ICircumnavigationURI.sol\\\";\\n\\ncontract CircumnavigationOpenEdition is NiftyBuilderInstance {\\n\\n    ICircumnavigationURI public circumnavigationContract;\\n\\n    constructor(        \\n        address niftyRegistryContract,\\n        address defaultOwner,\\n        address circumnavigationContractAddress) NiftyBuilderInstance(\\n            \\\"Circumnavigation Collector Only Open Edition by Dave Pollot\\\", \\n            \\\"CIRCUMNAVIGATION OE\\\", \\n            2, \\n            1, \\n            \\\"\\\", \\n            \\\"Dave Pollot\\\", \\n            niftyRegistryContract, \\n            defaultOwner) {\\n        circumnavigationContract = ICircumnavigationURI(circumnavigationContractAddress);\\n    }\\n    \\n    function tokenURI(uint256 tokenId) external virtual view override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n        return circumnavigationContract.cITokenURI();\\n    }    \\n}\"\r\n    },\r\n    \"contracts/core/NiftyBuilderInstance.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"../interface/ICloneablePaymentSplitter.sol\\\";\\nimport \\\"../interface/IERC2981.sol\\\";\\nimport \\\"../standard/ERC721Burnable.sol\\\";\\nimport \\\"../util/Clones.sol\\\";\\n\\n/** \\n * XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\\n * XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  .***   XXXXXXXXXXXXXXXXXX\\n * XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  ,*********  XXXXXXXXXXXXXXXX\\n * XXXXXXXXXXXXXXXXXXXXXXXXXXXX  ***************  XXXXXXXXXXXXX\\n * XXXXXXXXXXXXXXXXXXXXXXXXX  .*******************  XXXXXXXXXXX\\n * XXXXXXXXXXXXXXXXXXXXXXX  ***********    **********  XXXXXXXX\\n * XXXXXXXXXXXXXXXXXXXX   ***********       ***********  XXXXXX\\n * XXXXXXXXXXXXXXXXXX  ***********         ***************  XXX\\n * XXXXXXXXXXXXXXXX  ***********           ****    ********* XX\\n * XXXXXXXXXXXXXXXX *********      ***    ***      *********  X\\n * XXXXXXXXXXXXXXXX  **********  *****          *********** XXX\\n * XXXXXXXXXXXX   /////.*************         ***********  XXXX\\n * XXXXXXXXX  /////////...***********      ************  XXXXXX\\n * XXXXXXX/ ///////////..... /////////   ///////////   XXXXXXXX\\n * XXXXXX  /    //////.........///////////////////   XXXXXXXXXX\\n * XXXXXXXXXX .///////...........//////////////   XXXXXXXXXXXXX\\n * XXXXXXXXX .///////.....//..////  /////////  XXXXXXXXXXXXXXXX\\n * XXXXXXX# /////////////////////  XXXXXXXXXXXXXXXXXXXXXXXXXXXX\\n * XXXXX   ////////////////////   XXXXXXXXXXXXXXXXXXXXXXXXXXXXX\\n * XX   ////////////// //////   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\\n * XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\\n *\\n * @dev Nifty Gateway extension of customized NFT contract, encapsulates\\n * logic for minting new tokens, and concluding the minting process. \\n */\\ncontract NiftyBuilderInstance is ERC721, ERC721Burnable, IERC2981 {\\n\\n    event RoyaltyReceiverUpdated(uint256 indexed niftyType, address previousReceiver, address newReceiver);\\n    event PaymentReleased(address to, uint256 amount);\\n    event ERC20PaymentReleased(IERC20 indexed token, address to, uint256 amount);\\n\\n    // The artist associated with the collection.\\n    string private _creator;    \\n\\n    uint256 immutable public _percentageTotal;\\n    mapping(uint256 => uint256) public _percentageRoyalty;\\n\\n    mapping (uint256 => address) _royaltySplitters;\\n    mapping (uint256 => address) _royaltyReceivers;\\n\\n    // Number of NFTs minted for a given 'typeCount'. \\n    mapping (uint256 => uint256) public _mintCount;\\n\\n    /**\\n     * @dev Serves as a gas cost optimized boolean flag \\n     * to indicate whether the minting process has been \\n     * concluded for a given 'typeCount', correspinds \\n     * to the {_getFinalized} and {setFinalized}.\\n     */\\n    mapping (uint256 => bytes32) private _finalized;    \\n\\n    /**\\n     * @dev Emitted when tokens are created.\\n     */\\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\\n\\n    /**\\n     * @dev Ultimate instantiation of a Nifty Gateway NFT collection. \\n     * \\n     * @param name Of the collection being deployed.\\n     * @param symbol Shorthand token identifier, for wallets, etc.\\n     * @param id Number instance deployed by {BuilderShop} contract.\\n     * @param typeCount The number of different Nifty types (different \\n     * individual NFTs) associated with the deployed collection.\\n     * @param baseURI The location where the artifact assets are stored.\\n     * @param creator_ The artist associated with the collection.\\n     * @param niftyRegistryContract Points to the repository of authenticated\\n     * addresses for stateful operations. \\n     * @param defaultOwner Intial receiver of all newly minted NFTs.\\n     */\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        uint256 id,\\n        uint256 typeCount,\\n        string memory baseURI,\\n        string memory creator_,        \\n        address niftyRegistryContract,\\n        address defaultOwner) ERC721(name, symbol, id, baseURI, typeCount, defaultOwner, niftyRegistryContract) {\\n        \\n        _creator = creator_;\\n        _percentageTotal = 10000;        \\n    }\\n\\n    function setRoyaltyBips(uint256 niftyType, uint256 percentageRoyalty_) external onlyValidSender {\\n        require(percentageRoyalty_ <= _percentageTotal, \\\"NiftyBuilderInstance: Illegal argument more than 100%\\\");\\n        _percentageRoyalty[niftyType] = percentageRoyalty_;\\n    }\\n\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public override view returns (address, uint256) {        \\n        require(_exists(tokenId), \\\"NiftyBuilderInstance: operator query for nonexistent token\\\");\\n        uint256 niftyType = _getNiftyTypeId(tokenId);\\n        uint256 royaltyAmount = (salePrice * _percentageRoyalty[niftyType]) / _percentageTotal;\\n        address royaltyReceiver = _getRoyaltyReceiverByNiftyType(niftyType);\\n        require(royaltyReceiver != address(0), \\\"NiftyBuilderInstance: No royalty receiver\\\");\\n        return (royaltyReceiver, royaltyAmount);\\n    }\\n\\n    // This function must be called after builder shop instance is created - it can be called again\\n    // to change the split; call this once per nifty type to set up royalty payments properly\\n    function initializeRoyalties(address splitterImplementation, uint256 niftyType, address[] calldata payees, uint256[] calldata shares_) external onlyValidSender {\\n        address previousReceiver = _getRoyaltyReceiverByNiftyType(niftyType);\\n        address newReceiver = address(0);\\n        if(payees.length == 1) {\\n            newReceiver = payees[0];\\n            _royaltyReceivers[niftyType] = newReceiver;\\n            delete _royaltySplitters[niftyType];\\n        } else {            \\n            delete _royaltyReceivers[niftyType];\\n            require(IERC165(splitterImplementation).supportsInterface(type(ICloneablePaymentSplitter).interfaceId), \\\"Not a valid payment splitter\\\");\\n            newReceiver = payable (Clones.clone(splitterImplementation));\\n            ICloneablePaymentSplitter(newReceiver).initialize(payees, shares_);\\n            _royaltySplitters[niftyType] = newReceiver;        \\n        }\\n\\n        emit RoyaltyReceiverUpdated(niftyType, previousReceiver, newReceiver);        \\n    }\\n\\n    function getRoyaltyReceiverByTokenId(uint256 tokenId) public view returns (address) {        \\n        return _getRoyaltyReceiverByNiftyType(_getNiftyTypeId(tokenId));\\n    }\\n\\n    function getRoyaltyReceiverByNiftyType(uint256 niftyType) public view returns (address) {\\n        return _getRoyaltyReceiverByNiftyType(niftyType);\\n    }\\n\\n    function releaseRoyalties(address payable account) external {\\n        uint256 totalPaymentAmount = 0;\\n        for(uint256 niftyType = 1; niftyType <= _typeCount; niftyType++) {\\n            address paymentSplitterAddress = _royaltySplitters[niftyType];\\n            if(paymentSplitterAddress != address(0)) {\\n                ICloneablePaymentSplitter paymentSplitter = ICloneablePaymentSplitter(paymentSplitterAddress);    \\n                uint256 pendingPaymentAmount = paymentSplitter.pendingPayment(account);\\n                if(pendingPaymentAmount > 0) {\\n                    totalPaymentAmount += pendingPaymentAmount;\\n                    paymentSplitter.release(account);\\n                }\\n            }            \\n        }\\n\\n        if(totalPaymentAmount > 0) {\\n            emit PaymentReleased(account, totalPaymentAmount);\\n        }    \\n    }\\n\\n    function releaseRoyalties(IERC20 token, address account) external {\\n        uint256 totalPaymentAmount = 0;\\n        for(uint256 niftyType = 1; niftyType <= _typeCount; niftyType++) {\\n            address paymentSplitterAddress = _royaltySplitters[niftyType];\\n            if(paymentSplitterAddress != address(0)) {\\n                ICloneablePaymentSplitter paymentSplitter = ICloneablePaymentSplitter(paymentSplitterAddress);    \\n                uint256 pendingPaymentAmount = paymentSplitter.pendingPayment(token, account);\\n                if(pendingPaymentAmount > 0) {\\n                    totalPaymentAmount += pendingPaymentAmount;\\n                    paymentSplitter.release(token, account);\\n                }\\n            }            \\n        }\\n\\n        if(totalPaymentAmount > 0) {\\n            emit ERC20PaymentReleased(token, account, totalPaymentAmount);\\n        }    \\n    }\\n    \\n    function pendingRoyaltyPayment(address account) external view returns (uint256) {\\n        uint256 totalPaymentAmount = 0;\\n        for(uint256 niftyType = 1; niftyType <= _typeCount; niftyType++) {\\n            address paymentSplitterAddress = _royaltySplitters[niftyType];\\n            if(paymentSplitterAddress != address(0)) {\\n                ICloneablePaymentSplitter paymentSplitter = ICloneablePaymentSplitter(paymentSplitterAddress);    \\n                totalPaymentAmount += paymentSplitter.pendingPayment(account);\\n            }            \\n        }\\n        return totalPaymentAmount;\\n    }\\n\\n    function pendingRoyaltyPayment(IERC20 token, address account) external view returns (uint256) {\\n        uint256 totalPaymentAmount = 0;\\n        for(uint256 niftyType = 1; niftyType <= _typeCount; niftyType++) {\\n            address paymentSplitterAddress = _royaltySplitters[niftyType];\\n            if(paymentSplitterAddress != address(0)) {\\n                ICloneablePaymentSplitter paymentSplitter = ICloneablePaymentSplitter(paymentSplitterAddress);    \\n                totalPaymentAmount += paymentSplitter.pendingPayment(token, account);\\n            }            \\n        }\\n        return totalPaymentAmount;\\n    }\\n\\n    /**\\n     * @dev Generate canonical Nifty Gateway token representation. \\n     * Nifty contracts have a data model called a 'niftyType' (typeCount) \\n     * The 'niftyType' refers to a specific nifty in our contract, note \\n     * that it gives no information about the edition size. In a given \\n     * contract, 'niftyType' 1 could be an edition of 10, while 'niftyType' \\n     * 2 is a 1/1, etc.\\n     * The token IDs are encoded as follows: {id}{niftyType}{edition #}\\n     * 'niftyType' has 4 digits, and edition number has 5 digits, to allow \\n     * for 99999 possible 'niftyType' and 99999 of each edition in each contract.\\n     * Example token id: [5000100270]\\n     * This is from contract #5, it is 'niftyType' 1 in the contract, and it is \\n     * edition #270 of 'niftyType' 1.\\n     * Example token id: [5000110000]\\n     * This is from contract #5, it is 'niftyType' 1 in the contract, and it is \\n     * edition #10000 of 'niftyType' 1.\\n     */\\n    function _encodeTokenId(uint256 niftyType, uint256 tokenNumber) private view returns (uint256) {\\n        return (topLevelMultiplier + (niftyType * midLevelMultiplier) + tokenNumber);\\n    }\\n\\n    /**\\n     * @dev Determine whether it is possible to mint additional NFTs for this 'niftyType'.\\n     */\\n    function _getFinalized(uint256 niftyType) public view returns (bool) {\\n        bytes32 chunk = _finalized[niftyType / 256];\\n        return (chunk & bytes32(1 << (niftyType % 256))) != 0x0;\\n    }\\n\\n    /**\\n     * @dev Prevent the minting of additional NFTs of this 'niftyType'.\\n     */\\n    function setFinalized(uint256 niftyType) public onlyValidSender {\\n        uint256 quotient = niftyType / 256;\\n        bytes32 chunk = _finalized[quotient];\\n        _finalized[quotient] = chunk | bytes32(1 << (niftyType % 256));\\n    }\\n\\n    /**\\n     * @dev The artist of this collection.\\n     */\\n    function creator() public view virtual returns (string memory) {\\n        return _creator;\\n    }\\n\\n    /**\\n     * @dev Assign the root location where the artifact assets are stored.\\n     */\\n    function setBaseURI(string memory baseURI) public onlyValidSender {\\n        _setBaseURI(baseURI);\\n    }\\n\\n    /**\\n     * @dev Allow owner to change nifty name, by 'niftyType'.\\n     */\\n    function setNiftyName(uint256 niftyType, string memory niftyName) public onlyValidSender {\\n        _setNiftyTypeName(niftyType, niftyName);\\n    }\\n\\n    /**\\n     * @dev Assign the IPFS hash of canonical artifcat file, by 'niftyType'.\\n     */   \\n    function setNiftyIPFSHash(uint256 niftyType, string memory hashIPFS) public onlyValidSender {\\n        _setTokenIPFSHashNiftyType(niftyType, hashIPFS);\\n    }\\n\\n    /**\\n     * @dev Create specified number of nifties en masse.\\n     * Once an NFT collection is spawned by the factory contract, we make calls to set the IPFS\\n     * hash (above) for each Nifty type in the collection. \\n     * Subsequently calls are issued to this function to mint the appropriate number of tokens \\n     * for the project.\\n     */\\n    function mintNifty(uint256 niftyType, uint256 count) public onlyValidSender {\\n        require(!_getFinalized(niftyType), \\\"NiftyBuilderInstance: minting concluded for nifty type\\\");\\n            \\n        uint256 tokenNumber = _mintCount[niftyType] + 1;\\n        uint256 tokenId00 = _encodeTokenId(niftyType, tokenNumber);\\n        uint256 tokenId01 = tokenId00 + count - 1;\\n        \\n        for (uint256 tokenId = tokenId00; tokenId <= tokenId01; tokenId++) {\\n            _owners[tokenId] = _defaultOwner;\\n        }\\n        _mintCount[niftyType] += count;\\n        _balances[_defaultOwner] += count;\\n\\n        emit ConsecutiveTransfer(tokenId00, tokenId01, address(0), _defaultOwner);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, IERC165) returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\\n    }    \\n\\n    function _getRoyaltyReceiverByNiftyType(uint256 niftyType) private view returns (address) {\\n        if(_royaltyReceivers[niftyType] != address(0)) {            \\n            return _royaltyReceivers[niftyType];\\n        } else if(_royaltySplitters[niftyType] != address(0)) {            \\n            return _royaltySplitters[niftyType];\\n        }\\n\\n        return address(0);   \\n    }\\n}\"\r\n    },\r\n    \"contracts/core/ICircumnavigationURI.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\ninterface ICircumnavigationURI {\\n    function cITokenURI() external view returns (string memory);\\n    function cIITokenURI() external view returns (string memory);\\n    function cIIITokenURI(uint8 niftyType) external view returns (string memory);    \\n    function cIOneOfOneTokenURI() external view returns (string memory);    \\n    function cIIOneOfOneTokenURI() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/core/ERC721.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\nimport \\\"../interface/IERC721.sol\\\";\\nimport \\\"../interface/IERC721Receiver.sol\\\";\\nimport \\\"../interface/IERC721Metadata.sol\\\";\\nimport \\\"../util/Context.sol\\\";\\nimport \\\"../util/Strings.sol\\\";\\nimport \\\"../standard/ERC165.sol\\\";\\nimport \\\"./NiftyEntity.sol\\\";\\n\\n/**\\n * @dev Nifty Gateway implementation of Non-Fungible Token Standard.\\n */\\ncontract ERC721 is NiftyEntity, Context, ERC165, IERC721, IERC721Metadata {\\n\\n    // Tracked individual instance spawned by {BuilderShop} contract. \\n    uint immutable public _id;\\n\\n    // Number of distinct NFTs housed in this contract. \\n    uint immutable public _typeCount;\\n\\n    // Intial receiver of all newly minted NFTs.\\n    address immutable public _defaultOwner;\\n\\n    // Component(s) of 'tokenId' calculation. \\n    uint immutable public topLevelMultiplier;\\n    uint immutable public midLevelMultiplier;\\n\\n    // Token name.\\n    string private _name;\\n\\n    // Token symbol.\\n    string private _symbol;\\n\\n    // Token artifact location.\\n    string private _baseURI;\\n\\n    // Mapping from Nifty type to name of token.\\n    mapping(uint256 => string) private _niftyTypeName;\\n\\n    // Mapping from Nifty type to IPFS hash of canonical artifcat file.\\n    mapping(uint256 => string) private _niftyTypeIPFSHashes;\\n\\n    // Mapping from token ID to owner address.\\n    mapping (uint256 => address) internal _owners;\\n\\n    // Mapping owner address to token count, by aggregating all _typeCount NFTs in the contact.\\n    mapping (address => uint256) internal _balances;\\n\\n    // Mapping from token ID to approved address.\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals.\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the token collection.\\n     *\\n     * @param name_ Of the collection being deployed.\\n     * @param symbol_ Shorthand token identifier, for wallets, etc.\\n     * @param id_ Number instance deployed by {BuilderShop} contract.\\n     * @param baseURI_ The location where the artifact assets are stored.\\n     * @param typeCount_ The number of different Nifty types (different \\n     * individual NFTs) associated with the deployed collection.\\n     * @param defaultOwner_ Intial receiver of all newly minted NFTs.\\n     * @param niftyRegistryContract Points to the repository of authenticated\\n     * addresses for stateful operations. \\n     */\\n    constructor(string memory name_, \\n                string memory symbol_,\\n                uint256 id_,\\n                string memory baseURI_,\\n                uint256 typeCount_,\\n                address defaultOwner_, \\n                address niftyRegistryContract) NiftyEntity(niftyRegistryContract) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _id = id_;\\n        _baseURI = baseURI_;\\n        _typeCount = typeCount_;\\n        _defaultOwner = defaultOwner_;\\n\\n        midLevelMultiplier = 100000;\\n        topLevelMultiplier = id_ * 1000000000;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC721).interfaceId\\n            || interfaceId == type(IERC721Metadata).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the link to artificat location for a given token by 'tokenId'.\\n     * Throws if the token ID does not exist. May return an empty string.\\n     * @param tokenId uint256 ID of the token to query.\\n     * @return The location where the artifact assets are stored.\\n     */\\n    function tokenURI(uint256 tokenId) external virtual view override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n        string memory tokenIdStr = Strings.toString(tokenId);\\n        return string(abi.encodePacked(_baseURI, tokenIdStr));\\n    }\\n\\n    /**\\n     * @dev Returns an IPFS hash for a given token ID.\\n     * Throws if the token ID does not exist. May return an empty string.\\n     * @param tokenId uint256 ID of the token to query.\\n     * @return IPFS hash for this (_typeCount) NFT. \\n     */\\n    function tokenIPFSHash(uint256 tokenId) external view returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: IPFS hash query for nonexistent token\\\");\\n        uint256 niftyType = _getNiftyTypeId(tokenId);\\n        return _niftyTypeIPFSHashes[niftyType];\\n    }\\n    \\n    /**\\n     * @dev Determine which NFT in the contract (_typeCount) is associated \\n     * with this 'tokenId'.\\n     */\\n    function _getNiftyTypeId(uint256 tokenId) internal view returns (uint256) {\\n        if(tokenId <= topLevelMultiplier) {\\n            return 0;\\n        } else {\\n            return (tokenId - topLevelMultiplier) / midLevelMultiplier;\\n        }        \\n    }\\n\\n    /**\\n     * @dev Returns the Name for a given token ID.\\n     * Throws if the token ID does not exist. May return an empty string.\\n     * @param tokenId uint256 ID of the token to query\\n     */\\n    function tokenName(uint256 tokenId) external view returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: Name query for nonexistent token\\\");\\n        uint256 niftyType = _getNiftyTypeId(tokenId);\\n        return _niftyTypeName[niftyType];\\n    }\\n   \\n    /**\\n     * @dev Internal function to set the token IPFS hash for a nifty type.\\n     * @param niftyType uint256 ID component of the token to set its IPFS hash\\n     * @param ipfs_hash string IPFS link to assign\\n     */\\n    function _setTokenIPFSHashNiftyType(uint256 niftyType, string memory ipfs_hash) internal {\\n        require(bytes(_niftyTypeIPFSHashes[niftyType]).length == 0, \\\"ERC721Metadata: IPFS hash already set\\\");\\n        _niftyTypeIPFSHashes[niftyType] = ipfs_hash;\\n    }\\n\\n    /**\\n     * @dev Internal function to set the name for a nifty type.\\n     * @param niftyType uint256 of nifty type name to be set\\n     * @param nifty_type_name name of nifty type\\n     */\\n    function _setNiftyTypeName(uint256 niftyType, string memory nifty_type_name) internal {\\n        _niftyTypeName[niftyType] = nifty_type_name;\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}.\\n     */\\n    function _setBaseURI(string memory baseURI_) internal {\\n        _baseURI = baseURI_;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (isContract(to)) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n}\"\r\n    },\r\n    \"contracts/interface/ICloneablePaymentSplitter.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\nimport \\\"./IERC165.sol\\\";\\nimport \\\"../util/SafeERC20.sol\\\";\\n\\ninterface ICloneablePaymentSplitter is IERC165 {\\n    \\n    event PayeeAdded(address account, uint256 shares);\\n    event PaymentReleased(address to, uint256 amount);\\n    event ERC20PaymentReleased(IERC20 indexed token, address to, uint256 amount);\\n    event PaymentReceived(address from, uint256 amount);\\n    \\n    function initialize(address[] calldata payees, uint256[] calldata shares_) external;        \\n    function totalShares() external view returns (uint256);    \\n    function totalReleased() external view returns (uint256);\\n    function totalReleased(IERC20 token) external view returns (uint256);\\n    function shares(address account) external view returns (uint256);    \\n    function released(address account) external view returns (uint256);\\n    function released(IERC20 token, address account) external view returns (uint256);\\n    function payee(uint256 index) external view returns (address);    \\n    function release(address payable account) external;\\n    function release(IERC20 token, address account) external;\\n    function pendingPayment(address account) external view returns (uint256);\\n    function pendingPayment(IERC20 token, address account) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IERC2981.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n///\\n/// @dev Interface for the NFT Royalty Standard\\n///\\ninterface IERC2981 is IERC165 {\\n    /// ERC165 bytes to add to interface array - set in parent contract\\n    /// implementing this standard\\n    ///\\n    /// bytes4(keccak256(\\\"royaltyInfo(uint256,uint256)\\\")) == 0x2a55205a\\n    /// bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\\n    /// _registerInterface(_INTERFACE_ID_ERC2981);\\n\\n    /// @notice Called with the sale price to determine how much royalty\\n    //          is owed and to whom.\\n    /// @param _tokenId - the NFT asset queried for royalty information\\n    /// @param _salePrice - the sale price of the NFT asset specified by _tokenId\\n    /// @return receiver - address of who should be sent the royalty payment\\n    /// @return royaltyAmount - the royalty payment amount for _salePrice\\n    function royaltyInfo(\\n        uint256 _tokenId,\\n        uint256 _salePrice\\n    ) external view returns (\\n        address receiver,\\n        uint256 royaltyAmount\\n    );\\n}\"\r\n    },\r\n    \"contracts/standard/ERC721Burnable.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\nimport \\\"../core/ERC721.sol\\\";\\n\\n/**\\n * @title ERC721 Burnable Token\\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\\n */\\nabstract contract ERC721Burnable is Context, ERC721 {\\n    /**\\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function burn(uint256 tokenId) public virtual {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721Burnable: caller is not owner nor approved\\\");\\n        _burn(tokenId);\\n    }\\n}\"\r\n    },\r\n    \"contracts/util/Clones.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n// OpenZeppelin Contract Commit Hash: 6bd6b76d1156e20e45d1016f355d154141c7e5b9                                      \\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IERC721.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IERC721Receiver.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\"\r\n    },\r\n    \"contracts/interface/IERC721Metadata.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\"\r\n    },\r\n    \"contracts/util/Context.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/util/Strings.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/standard/ERC165.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\nimport \\\"../interface/IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\"\r\n    },\r\n    \"contracts/core/NiftyEntity.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\n/**\\n * @dev Authenticator of state mutating operations for Nifty Gateway contracts. \\n *\\n * addresses for stateful operations. \\n *\\n * Rinkeby: 0xCefBf44ff649B6E0Bc63785699c6F1690b8cF73b\\n * Mainnet: 0x6e53130dDfF21E3BC963Ee902005223b9A202106\\n */\\ncontract NiftyEntity {\\n   \\n   // Address of {NiftyRegistry} contract. \\n   address internal immutable niftyRegistryContract;\\n   \\n   /**\\n    * @dev Determines whether accounts are allowed to invoke state mutating operations on child contracts.\\n    */\\n    modifier onlyValidSender() {\\n        NiftyRegistry niftyRegistry = NiftyRegistry(niftyRegistryContract);\\n        bool isValid = niftyRegistry.isValidNiftySender(msg.sender);\\n        require(isValid, \\\"NiftyEntity: Invalid msg.sender\\\");\\n        _;\\n    }\\n    \\n   /**\\n    * @param _niftyRegistryContract Points to the repository of authenticated\\n    */\\n    constructor(address _niftyRegistryContract) {\\n        niftyRegistryContract = _niftyRegistryContract;\\n    }\\n}\\n\\n/**\\n * @dev Defined to mediate interaction with externally deployed {NiftyRegistry} dependency. \\n */\\ninterface NiftyRegistry {\\n   function isValidNiftySender(address sending_key) external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interface/IERC165.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\n/**\\n * @title IERC165\\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\\n */\\ninterface IERC165 {\\n\\n  /**\\n   * @notice Query if a contract implements an interface\\n   * @param interfaceId The interface identifier, as specified in ERC-165\\n   * @dev Interface identification is specified in ERC-165. This function\\n   * uses less than 30,000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId)\\n    external\\n    view\\n    returns (bool);\\n}\"\r\n    },\r\n    \"contracts/util/SafeERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\nimport \\\"../interface/IERC20.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IERC20.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/util/Address.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"niftyRegistryContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"defaultOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"circumnavigationContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20PaymentReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newReceiver\",\"type\":\"address\"}],\"name\":\"RoyaltyReceiverUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_defaultOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"}],\"name\":\"_getFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_id\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_mintCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_percentageRoyalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_percentageTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_typeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circumnavigationContract\",\"outputs\":[{\"internalType\":\"contract ICircumnavigationURI\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"}],\"name\":\"getRoyaltyReceiverByNiftyType\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getRoyaltyReceiverByTokenId\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"splitterImplementation\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"payees\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"shares_\",\"type\":\"uint256[]\"}],\"name\":\"initializeRoyalties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"midLevelMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"mintNifty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingRoyaltyPayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingRoyaltyPayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"releaseRoyalties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"releaseRoyalties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"}],\"name\":\"setFinalized\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"hashIPFS\",\"type\":\"string\"}],\"name\":\"setNiftyIPFSHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"niftyName\",\"type\":\"string\"}],\"name\":\"setNiftyName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"niftyType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentageRoyalty_\",\"type\":\"uint256\"}],\"name\":\"setRoyaltyBips\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenIPFSHash\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"topLevelMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CircumnavigationOpenEdition", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "1500", "ConstructorArguments": "0000000000000000000000006e53130ddff21e3bc963ee902005223b9a202106000000000000000000000000e052113bd7d7700d623414a0a4585bcae754e9d5000000000000000000000000dcb34b4ceed4bd6ba0ee08445d57a27d18e66a30", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}