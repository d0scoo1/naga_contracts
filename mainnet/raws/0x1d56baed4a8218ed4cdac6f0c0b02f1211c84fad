{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"GALStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\r\\n\\r\\ncontract GALStaking is IERC20Metadata {\\r\\n\\r\\n    struct StakeInfo {\\r\\n        uint256 tokenId;\\r\\n        uint256 unlockTime;\\r\\n        address owner;\\r\\n    }\\r\\n\\r\\n    IERC721 public immutable GAL;\\r\\n    uint256 public constant MULTIPLIER = 1e12;\\r\\n    uint256 public lockDuration = 7 days;\\r\\n\\r\\n    uint256 accRPS;\\r\\n    uint256 lastETHBalance;\\r\\n\\r\\n    // Info of each user that stakes tokens.\\r\\n    mapping(uint256 => StakeInfo) private _receipt;\\r\\n    mapping(address => uint256) private _debt;\\r\\n    mapping(address => uint256[]) private _stakedListOf;\\r\\n\\r\\n    constructor(IERC721 _GAL) {\\r\\n        GAL = _GAL;\\r\\n    }\\r\\n\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return \\\"GAL DP\\\";\\r\\n    }\\r\\n\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return \\\"GALDP\\\";\\r\\n    }\\r\\n\\r\\n    function decimals() external pure override returns (uint8) {\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return GAL.balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _stakedListOf[account].length;\\r\\n    }\\r\\n\\r\\n    function transfer(address, uint256) public pure override returns (bool) {\\r\\n        revert(\\\"Not allowed\\\");\\r\\n    }\\r\\n\\r\\n    function allowance(address, address) public pure override returns (uint256) {\\r\\n        revert(\\\"Not allowed\\\");\\r\\n    }\\r\\n\\r\\n    function approve(address, uint256) public pure override returns (bool) {\\r\\n        revert(\\\"Not allowed\\\");\\r\\n    }\\r\\n\\r\\n    function transferFrom(address, address, uint256) public pure override returns (bool) {\\r\\n        revert(\\\"Not allowed\\\");\\r\\n    }\\r\\n\\r\\n    function stakedListOf(address account) external view returns (uint256[] memory) {\\r\\n        return _stakedListOf[account];\\r\\n    }\\r\\n\\r\\n    function getStakeInfo(uint256 tokenId) external view returns (uint256, uint256, address) {\\r\\n        return (\\r\\n            _receipt[tokenId].tokenId,\\r\\n            _receipt[tokenId].unlockTime,\\r\\n            _receipt[tokenId].owner\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // View function to see pending ETH rewards\\r\\n    function pendingETHRewards(address account) external view returns (uint256) {\\r\\n        uint256 currentRPS = accRPS;\\r\\n        uint256 stakedGALCount = totalSupply();\\r\\n        uint256 stakedCount = balanceOf(account);\\r\\n\\r\\n        if(stakedCount == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        if (stakedGALCount != 0) {\\r\\n            uint256 ETHSupply = address(this).balance;\\r\\n            uint256 ETHReward = ETHSupply - lastETHBalance;\\r\\n            currentRPS += (ETHReward * MULTIPLIER) / stakedGALCount;\\r\\n        }\\r\\n        return ((stakedCount * currentRPS) / MULTIPLIER) - _debt[account];\\r\\n    }\\r\\n\\r\\n    function deposit(uint256[] calldata tokenIds) external {\\r\\n        _deposit(tokenIds, msg.sender);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256[] calldata tokenIds) external {\\r\\n        _withdraw(tokenIds, msg.sender);\\r\\n    }\\r\\n\\r\\n    // Deposit A GAL token for staking.\\r\\n    function _deposit(uint256[] calldata tokenIds, address holder) internal {\\r\\n        _refreshRewards();\\r\\n\\r\\n        uint256 pending;\\r\\n        uint256 stakedCount = balanceOf(holder);\\r\\n        if(stakedCount > 0) {\\r\\n            pending = ((stakedCount * accRPS) / MULTIPLIER) - _debt[holder];\\r\\n        }\\r\\n\\r\\n        for(uint256 i = 0; i < tokenIds.length; i++) {\\r\\n            _receipt[tokenIds[i]] = StakeInfo(tokenIds[i], block.timestamp + lockDuration, holder);\\r\\n            _stakedListOf[holder].push(tokenIds[i]);\\r\\n        }\\r\\n        _debt[holder] = ((stakedCount + tokenIds.length) * accRPS) / MULTIPLIER;    \\r\\n\\r\\n        if(pending > 0) {\\r\\n            _sendRewards(holder, pending);\\r\\n        }\\r\\n\\r\\n        for(uint256 i = 0; i < tokenIds.length; i++) {\\r\\n            GAL.transferFrom(holder, address(this), tokenIds[i]);\\r\\n        }\\r\\n\\r\\n        emit Transfer(address(0), msg.sender, tokenIds.length);\\r\\n    }\\r\\n\\r\\n    // Withdraw staked GAL + ETH rewards.\\r\\n    function _withdraw(uint256[] calldata tokenIds, address holder) internal {\\r\\n        _refreshRewards();\\r\\n\\r\\n        uint256 stakedCount = balanceOf(holder);\\r\\n        uint256 pending = ((stakedCount * accRPS) / MULTIPLIER) - _debt[holder];\\r\\n        _debt[holder] += pending;\\r\\n\\r\\n        for(uint256 i = 0; i < tokenIds.length; i++) {\\r\\n            StakeInfo memory stakeInfo = _receipt[tokenIds[i]];\\r\\n            require(stakeInfo.owner == holder, \\\"GALStaking: Unauthorized\\\");\\r\\n            require(block.timestamp >= stakeInfo.unlockTime, \\\"GALStaking: Too early\\\");\\r\\n            delete _receipt[tokenIds[i]];\\r\\n\\r\\n            // delete from the list of NFTs for holder\\r\\n            uint256[] memory listOfNFTs = _stakedListOf[holder];\\r\\n            uint256 length = listOfNFTs.length;\\r\\n            for (uint256 j = 0; j < length; j++) {\\r\\n                if (listOfNFTs[j] == tokenIds[i]) {\\r\\n                    _stakedListOf[holder][j] = listOfNFTs[length - 1];\\r\\n                    _stakedListOf[holder].pop();\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n            GAL.transferFrom(address(this), holder, tokenIds[i]);\\r\\n        }\\r\\n\\r\\n        if(pending > 0) {\\r\\n            _sendRewards(holder, pending);\\r\\n        }\\r\\n        emit Transfer(msg.sender, address(0), tokenIds.length);\\r\\n    }\\r\\n\\r\\n    // Update reward variables\\r\\n    function _refreshRewards() internal {\\r\\n        uint256 ETHSupply = address(this).balance;\\r\\n        uint256 ETHReward = ETHSupply - lastETHBalance;\\r\\n        if(ETHReward == 0) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 stakedGALCount = totalSupply();\\r\\n        if (stakedGALCount == 0) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        accRPS += (ETHReward * MULTIPLIER) / stakedGALCount;\\r\\n        lastETHBalance = ETHSupply;\\r\\n    }\\r\\n\\r\\n    function _sendRewards(address _to, uint256 _amount) internal {\\r\\n        uint256 ETHBal = address(this).balance;\\r\\n        if (_amount > ETHBal) {\\r\\n            lastETHBalance = 0;\\r\\n            (bool success, ) = _to.call{ value : ETHBal }(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n        } else {\\r\\n            lastETHBalance = ETHBal - _amount;\\r\\n            (bool success, ) = _to.call{ value : _amount }(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"_GAL\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GAL\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getStakeInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingETHRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"stakedListOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GALStaking", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000dd0b8c3a48f46132a846592894ee742ebb02a8a2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}