{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/UniswapV2PathPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\nimport \\\"./libraries/FullMath.sol\\\";\\nimport \\\"./libraries/FixedPoint112.sol\\\";\\n\\nimport \\\"./interfaces/IUniswapV2PathPriceOracle.sol\\\";\\n\\n/// @title Uniswap path price oracle\\n/// @notice Contains logic for price calculation of asset which doesn't have a pair with a base asset\\ncontract UniswapV2PathPriceOracle is IUniswapV2PathPriceOracle, ERC165 {\\n    using FullMath for uint;\\n\\n    /// @notice List of assets to compose exchange pairs, where first element is input asset\\n    address[] internal path;\\n    /// @notice List of corresponding price oracles for provided path\\n    address[] internal oracles;\\n\\n    constructor(address[] memory _path, address[] memory _oracles) {\\n        uint pathsCount = _path.length;\\n        require(pathsCount >= 2, \\\"UniswapV2PathPriceOracle: PATH\\\");\\n        require(_oracles.length == pathsCount - 1, \\\"UniswapV2PathPriceOracle: ORACLES\\\");\\n\\n        path = _path;\\n        oracles = _oracles;\\n    }\\n\\n    /// @inheritdoc IPriceOracle\\n    function refreshedAssetPerBaseInUQ(address _asset) external override returns (uint currentAssetPerBaseInUQ) {\\n        currentAssetPerBaseInUQ = FixedPoint112.Q112;\\n\\n        uint oraclesCount = oracles.length;\\n        for (uint i; i < oraclesCount; ) {\\n            address asset = path[i + 1];\\n            currentAssetPerBaseInUQ = currentAssetPerBaseInUQ.mulDiv(\\n                IPriceOracle(oracles[i]).refreshedAssetPerBaseInUQ(asset),\\n                FixedPoint112.Q112\\n            );\\n            if (_asset == asset) {\\n                break;\\n            }\\n\\n            unchecked {\\n                i = i + 1;\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IUniswapV2PathPriceOracle\\n    function anatomy() external view override returns (address[] memory _path, address[] memory _oracles) {\\n        _path = path;\\n        _oracles = oracles;\\n    }\\n\\n    /// @inheritdoc IPriceOracle\\n    function lastAssetPerBaseInUQ(address _asset) external view override returns (uint currentAssetPerBaseInUQ) {\\n        currentAssetPerBaseInUQ = FixedPoint112.Q112;\\n\\n        uint oraclesCount = oracles.length;\\n        for (uint i; i < oraclesCount; ) {\\n            address asset = path[i + 1];\\n            currentAssetPerBaseInUQ = currentAssetPerBaseInUQ.mulDiv(\\n                IPriceOracle(oracles[i]).lastAssetPerBaseInUQ(asset),\\n                FixedPoint112.Q112\\n            );\\n            if (_asset == asset) {\\n                break;\\n            }\\n\\n            unchecked {\\n                i = i + 1;\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc ERC165\\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\\n        return\\n            _interfaceId == type(IUniswapV2PathPriceOracle).interfaceId ||\\n            _interfaceId == type(IPriceOracle).interfaceId ||\\n            super.supportsInterface(_interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (~denominator + 1) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/FixedPoint112.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity 0.8.13;\\n\\n/// @title FixedPoint112\\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\\nlibrary FixedPoint112 {\\n    uint8 internal constant RESOLUTION = 112;\\n    /// @dev 2**112\\n    uint256 internal constant Q112 = 0x10000000000000000000000000000;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2PathPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.13;\\n\\nimport \\\"./IPriceOracle.sol\\\";\\n\\n/// @title Uniswap path price oracle interface\\n/// @notice Contains logic for price calculation of asset which doesn't have a pair with a base asset\\ninterface IUniswapV2PathPriceOracle is IPriceOracle {\\n    /// @notice Returns anatomy data for the current oracle\\n    /// @return _path List of assets to compose exchange pairs\\n    /// @return _oracles List of corresponding price oracles for pairs provided by {_path}\\n    function anatomy() external view returns (address[] calldata _path, address[] calldata _oracles);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.8.13;\\n\\n/// @title Price oracle interface\\n/// @notice Returns price of single asset in relation to base\\ninterface IPriceOracle {\\n    /// @notice Updates and returns asset per base\\n    /// @return Asset per base in UQ\\n    function refreshedAssetPerBaseInUQ(address _asset) external returns (uint);\\n\\n    /// @notice Returns last asset per base\\n    /// @return Asset per base in UQ\\n    function lastAssetPerBaseInUQ(address _asset) external view returns (uint);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_oracles\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"anatomy\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_oracles\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"lastAssetPerBaseInUQ\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentAssetPerBaseInUQ\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"refreshedAssetPerBaseInUQ\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentAssetPerBaseInUQ\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "UniswapV2PathPriceOracle", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000003000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000d291e7a03283640fdc51b121ac401383a46cc62300000000000000000000000000000000000000000000000000000000000000020000000000000000000000006b8dc21d3a45c4b1d1f27870efc9352eda509dfa000000000000000000000000b3077d8f348733e20122d613d864613b2a92c09a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}