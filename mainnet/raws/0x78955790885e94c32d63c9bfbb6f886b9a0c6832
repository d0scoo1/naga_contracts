{"status": "1", "message": "OK", "result": [{"SourceCode": "/**\r\n *KYB\u662fKY POOL\u77ff\u6c60\u6743\u76ca\u4ee3\u5e01\uff0cKY POOL\u662f\u4e00\u4e2a\u6709\u7740\u575a\u5b9e\u5b9e\u4f53\u533a\u5757\u94fe\u6316\u77ff\u8d44\u6e90\u7684\u9879\u76ee\uff0c\r\n * KY POOL\u96b6\u5c5e\u4e8eFlyChain\u57fa\u91d1\u4f1a\uff0cKYB\u662f\u57fa\u4e8e\u4ee5\u592a\u574aEthereum\u7684\u53bb\u4e2d\u5fc3\u5316\u7684\u533a\u5757\u94fe\u6570\u5b57\u8d44\u4ea7\uff0c\r\n * \u53d1\u884c\u603b\u91cf\u6052\u5b9a10\u4ebf\u4e2a\uff0c\u6bcf\u4e2a\u9636\u6bb5\u6839\u636e\u77ff\u6c60\u8fd0\u8425\u7684\u60c5\u51b5\u5bf9KYB\u8fdb\u884c\u56de\u8d2d\uff0c\u7528\u6237\u53ef\u901a\u8fc7\u533a\u5757\u94fe\u6d4f\u89c8\u5668\u67e5\u8be2\uff0c\r\n * \u786e\u4fdd\u516c\u5f00\u900f\u660e\uff0cKYB\u4f5c\u4e3a\u77ff\u6c60\u751f\u6001\u552f\u4e00\u7684\u4ef7\u503c\u6d41\u901a\u901a\u8bc1\uff0cKYB\u4e0e\u4e1a\u5185\u6700\u5927\u7684\u5b58\u50a8\u77ff\u673a\u5382\u5546\u77ff\u7237\u5408\u4f5c\uff0c\r\n * \u81f4\u529b\u4e8e\u6784\u5efa\u5206\u5e03\u4e8e\u4e9a\u6d32\u4e43\u81f3\u5168\u7403\u6700\u5927\u6700\u7a33\u5b9a\u3001\u9ad8\u6548\u3001\u9ad8\u4ea7\u7684\u5b58\u50a8\u77ff\u6c60\u3002\r\n*/\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    return _a / _b;\r\n  }\r\n\r\n\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\nlibrary FrozenChecker {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    struct Rule {\r\n        uint256 timeT;\r\n        uint8 initPercent;\r\n        uint256[] periods;\r\n        uint8[] percents;\r\n    }\r\n\r\n    function check(Rule storage self, uint256 totalFrozenValue) internal view returns (uint256) {\r\n        if (totalFrozenValue == uint256(0)) {\r\n            return 0;\r\n        }\r\n        //uint8 temp = self.initPercent;\r\n        if (self.timeT == uint256(0) || self.timeT > now) {\r\n            return totalFrozenValue.sub(totalFrozenValue.mul(self.initPercent).div(100));\r\n        }\r\n        for (uint256 i = 0; i < self.periods.length.sub(1); i = i.add(1)) {\r\n            if (now >= self.timeT.add(self.periods[i]) && now < self.timeT.add(self.periods[i.add(1)])) {\r\n                return totalFrozenValue.sub(totalFrozenValue.mul(self.percents[i]).div(100));\r\n            }\r\n        }\r\n        if (now >= self.timeT.add(self.periods[self.periods.length.sub(1)])) {\r\n            return totalFrozenValue.sub(totalFrozenValue.mul(self.percents[self.periods.length.sub(1)]).div(100));\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nlibrary FrozenValidator {\r\n    \r\n    using SafeMath for uint256;\r\n    using FrozenChecker for FrozenChecker.Rule;\r\n\r\n    struct Validator {\r\n        mapping(address => IndexValue) data;\r\n        KeyFlag[] keys;\r\n        uint256 size;\r\n    }\r\n\r\n    struct IndexValue {\r\n        uint256 keyIndex; \r\n        FrozenChecker.Rule rule;\r\n        mapping (address => uint256) frozenBalances;\r\n    }\r\n\r\n    struct KeyFlag { \r\n        address key; \r\n        bool deleted; \r\n    }\r\n\r\n    function addRule(Validator storage self, address key, uint8 initPercent, uint256[] periods, uint8[] percents) internal returns (bool replaced) {\r\n        //require(self.size <= 10);\r\n        require(key != address(0));\r\n        require(periods.length == percents.length);\r\n        require(periods.length > 0);\r\n        require(periods[0] == uint256(0));\r\n        require(initPercent <= percents[0]);\r\n        for (uint256 i = 1; i < periods.length; i = i.add(1)) {\r\n            require(periods[i.sub(1)] < periods[i]);\r\n            require(percents[i.sub(1)] <= percents[i]);\r\n        }\r\n        require(percents[percents.length.sub(1)] == 100);\r\n        FrozenChecker.Rule memory rule = FrozenChecker.Rule(0, initPercent, periods, percents);\r\n        uint256 keyIndex = self.data[key].keyIndex;\r\n        self.data[key].rule = rule;\r\n        if (keyIndex > 0) {\r\n            return true;\r\n        } else {\r\n            keyIndex = self.keys.length++;\r\n            self.data[key].keyIndex = keyIndex.add(1);\r\n            self.keys[keyIndex].key = key;\r\n            self.size++;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function removeRule(Validator storage self, address key) internal returns (bool success) {\r\n        uint256 keyIndex = self.data[key].keyIndex;\r\n        if (keyIndex == 0) {\r\n            return false;\r\n        }\r\n        delete self.data[key];\r\n        self.keys[keyIndex.sub(1)].deleted = true;\r\n        self.size--;\r\n        return true;\r\n    }\r\n\r\n    function containRule(Validator storage self, address key) internal view returns (bool) {\r\n        return self.data[key].keyIndex > 0;\r\n    }\r\n\r\n    function addTimeT(Validator storage self, address addr, uint256 timeT) internal returns (bool) {\r\n        require(timeT > now);\r\n        self.data[addr].rule.timeT = timeT;\r\n        return true;\r\n    }\r\n\r\n    function addFrozenBalance(Validator storage self, address from, address to, uint256 value) internal returns (uint256) {\r\n        self.data[from].frozenBalances[to] = self.data[from].frozenBalances[to].add(value);\r\n        return self.data[from].frozenBalances[to];\r\n    }\r\n\r\n    function validate(Validator storage self, address addr) internal view returns (uint256) {\r\n        uint256 frozenTotal = 0;\r\n        for (uint256 i = iterateStart(self); iterateValid(self, i); i = iterateNext(self, i)) {\r\n            address ruleaddr = iterateGet(self, i);\r\n            FrozenChecker.Rule storage rule = self.data[ruleaddr].rule;\r\n            frozenTotal = frozenTotal.add(rule.check(self.data[ruleaddr].frozenBalances[addr]));\r\n        }\r\n        return frozenTotal;\r\n    }\r\n\r\n\r\n    function iterateStart(Validator storage self) internal view returns (uint256 keyIndex) {\r\n        return iterateNext(self, uint256(-1));\r\n    }\r\n\r\n    function iterateValid(Validator storage self, uint256 keyIndex) internal view returns (bool) {\r\n        return keyIndex < self.keys.length;\r\n    }\r\n\r\n    function iterateNext(Validator storage self, uint256 keyIndex) internal view returns (uint256) {\r\n        keyIndex++;\r\n        while (keyIndex < self.keys.length && self.keys[keyIndex].deleted) {\r\n            keyIndex++;\r\n        }\r\n        return keyIndex;\r\n    }\r\n\r\n    function iterateGet(Validator storage self, uint256 keyIndex) internal view returns (address) {\r\n        return self.keys[keyIndex].key;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract KYPool {\r\n\r\n    using SafeMath for uint256;\r\n    using FrozenValidator for FrozenValidator.Validator;\r\n\r\n    mapping (address => uint256) internal balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    \r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    \r\n\r\n    address internal admin;  //Admin address\r\n\r\n    \r\n    function changeAdmin(address newAdmin) public returns (bool)  {\r\n        require(msg.sender == admin);\r\n        require(newAdmin != address(0));\r\n        uint256 balAdmin = balances[admin];\r\n        balances[newAdmin] = balances[newAdmin].add(balAdmin);\r\n        balances[admin] = 0;\r\n        admin = newAdmin;\r\n        emit Transfer(admin, newAdmin, balAdmin);\r\n        return true;\r\n    }\r\n\r\n    \r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    \r\n    constructor(string tokenName, string tokenSymbol, uint8 tokenDecimals, uint256 totalTokenSupply ) public {\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n        decimals = tokenDecimals;\r\n        totalSupply = totalTokenSupply;\r\n        admin = msg.sender;\r\n        balances[msg.sender] = totalTokenSupply;\r\n        emit Transfer(0x0, msg.sender, totalTokenSupply);\r\n\r\n    }\r\n\r\n    \r\n\r\n    \r\n    mapping (address => bool) frozenAccount; \r\n    mapping (address => uint256) frozenTimestamp; \r\n\r\n    \r\n    function getFrozenTimestamp(address _target) public view returns (uint256) {\r\n        return frozenTimestamp[_target];\r\n    }\r\n\r\n    \r\n    function getFrozenAccount(address _target) public view returns (bool) {\r\n        return frozenAccount[_target];\r\n    }\r\n\r\n    \r\n    function freeze(address _target, bool _freeze) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        require(_target != admin);\r\n        frozenAccount[_target] = _freeze;\r\n        return true;\r\n    }\r\n\r\n    \r\n    function freezeWithTimestamp(address _target, uint256 _timestamp) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        require(_target != admin);\r\n        frozenTimestamp[_target] = _timestamp;\r\n        return true;\r\n    }\r\n\r\n    \r\n    function multiFreeze(address[] _targets, bool[] _freezes) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        require(_targets.length == _freezes.length);\r\n        uint256 len = _targets.length;\r\n        require(len > 0);\r\n        for (uint256 i = 0; i < len; i = i.add(1)) {\r\n            address _target = _targets[i];\r\n            require(_target != admin);\r\n            bool _freeze = _freezes[i];\r\n            frozenAccount[_target] = _freeze;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    \r\n    function multiFreezeWithTimestamp(address[] _targets, uint256[] _timestamps) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        require(_targets.length == _timestamps.length);\r\n        uint256 len = _targets.length;\r\n        require(len > 0);\r\n        for (uint256 i = 0; i < len; i = i.add(1)) {\r\n            address _target = _targets[i];\r\n            require(_target != admin);\r\n            uint256 _timestamp = _timestamps[i];\r\n            frozenTimestamp[_target] = _timestamp;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    \r\n\r\n\r\n\r\n    FrozenValidator.Validator validator;\r\n\r\n    function addRule(address addr, uint8 initPercent, uint256[] periods, uint8[] percents) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        return validator.addRule(addr, initPercent, periods, percents);\r\n    }\r\n\r\n    function addTimeT(address addr, uint256 timeT) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        return validator.addTimeT(addr, timeT);\r\n    }\r\n\r\n    function removeRule(address addr) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        return validator.removeRule(addr);\r\n    }\r\n\r\n    \r\n\r\n\r\n\r\n\r\n    function multiTransfer(address[] _tos, uint256[] _values) public returns (bool) {\r\n        require(!frozenAccount[msg.sender]);\r\n        require(now > frozenTimestamp[msg.sender]);\r\n        require(_tos.length == _values.length);\r\n        uint256 len = _tos.length;\r\n        require(len > 0);\r\n        uint256 amount = 0;\r\n        for (uint256 i = 0; i < len; i = i.add(1)) {\r\n            amount = amount.add(_values[i]);\r\n        }\r\n        require(amount <= balances[msg.sender].sub(validator.validate(msg.sender)));\r\n        for (uint256 j = 0; j < len; j = j.add(1)) {\r\n            address _to = _tos[j];\r\n            if (validator.containRule(msg.sender) && msg.sender != _to) {\r\n                validator.addFrozenBalance(msg.sender, _to, _values[j]);\r\n            }\r\n            balances[_to] = balances[_to].add(_values[j]);\r\n            balances[msg.sender] = balances[msg.sender].sub(_values[j]);\r\n            emit Transfer(msg.sender, _to, _values[j]);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        transferfix(_to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferfix(address _to, uint256 _value) public {\r\n        require(!frozenAccount[msg.sender]);\r\n        require(now > frozenTimestamp[msg.sender]);\r\n        require(balances[msg.sender].sub(_value) >= validator.validate(msg.sender));\r\n\r\n        if (validator.containRule(msg.sender) && msg.sender != _to) {\r\n            validator.addFrozenBalance(msg.sender, _to, _value);\r\n        }\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(!frozenAccount[_from]);\r\n        require(now > frozenTimestamp[_from]);\r\n        require(_value <= balances[_from].sub(validator.validate(_from)));\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        if (validator.containRule(_from) && _from != _to) {\r\n            validator.addFrozenBalance(_from, _to, _value);\r\n        }\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    \r\n    \r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner]; \r\n    }\r\n\r\n    \r\n\r\n    function kill() public {\r\n        require(msg.sender == admin);\r\n        selfdestruct(admin);\r\n    }\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tos\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"multiTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"initPercent\",\"type\":\"uint8\"},{\"name\":\"periods\",\"type\":\"uint256[]\"},{\"name\":\"percents\",\"type\":\"uint8[]\"}],\"name\":\"addRule\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"timeT\",\"type\":\"uint256\"}],\"name\":\"addTimeT\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"freeze\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"getFrozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_targets\",\"type\":\"address[]\"},{\"name\":\"_freezes\",\"type\":\"bool[]\"}],\"name\":\"multiFreeze\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferfix\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"freezeWithTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_targets\",\"type\":\"address[]\"},{\"name\":\"_timestamps\",\"type\":\"uint256[]\"}],\"name\":\"multiFreezeWithTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeRule\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"getFrozenTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenName\",\"type\":\"string\"},{\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"name\":\"tokenDecimals\",\"type\":\"uint8\"},{\"name\":\"totalTokenSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "KYPool", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000033b2e3c9fd0803ce800000000000000000000000000000000000000000000000000000000000000000000064b59506f6f6c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034b59420000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://c71363db01cd33cceded941b4cff19368943ba550aacba068545c1f291796f6e"}]}