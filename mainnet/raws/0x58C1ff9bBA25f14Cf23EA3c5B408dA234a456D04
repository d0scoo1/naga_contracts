{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/xRooStaking.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.7;\\r\\nimport \\\"../nftx/interface/INFTXVault.sol\\\";\\r\\nimport \\\"../nftx/interface/INFTXLPStaking.sol\\\";\\r\\nimport \\\"../nftx/interface/IUniswapV2Router01.sol\\\";\\r\\nimport \\\"../nftx/interface/IVaultTokenUpgradeable.sol\\\";\\r\\nimport \\\"../nftx/interface/IRewardDistributionToken.sol\\\";\\r\\nimport {IWETH} from \\\"../nftx/interface/INFTXStakingZap.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/interfaces/IERC721.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"prb-math/contracts/PRBMathUD60x18.sol\\\";\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\ncontract xRooStaking is Ownable {\\r\\n    using PRBMathUD60x18 for uint256;\\r\\n    event Staked(\\r\\n        address indexed _user,\\r\\n        uint256 _stake,\\r\\n        uint256 _liquidity,\\r\\n        uint256 _weth\\r\\n    );\\r\\n    event Unstaked(address indexed _user, uint256 _stake, uint256 _liquidity);\\r\\n\\r\\n    // --------- NFTX CONTRACTS/VARIABLES -------------\\r\\n    INFTXVault public NFTXVault;\\r\\n    INFTXLPStaking public NFTXLPStaking;\\r\\n    IRewardDistributionToken public NFTXRewardDistributionToken;\\r\\n    uint256 constant base = 10**18; // 18 decimal places\\r\\n    uint256 NFTXRewardPerLiquidity;\\r\\n\\r\\n    IWETH public WETH;\\r\\n\\r\\n    // --------- SUSHI CONTRACTS ------------\\r\\n    IUniswapV2Router01 public sushiRouter;\\r\\n    IERC20 public SLPToken;\\r\\n\\r\\n    // --------- INTERNAL CONTRACTS/VARIABLES ---------\\r\\n    IERC20 public RTRewardToken;\\r\\n    IERC721 public RTStakedToken;\\r\\n\\r\\n    uint256 public rewardPeriod;\\r\\n    uint256 public periodicReward;\\r\\n    uint256 public lockTime;\\r\\n\\r\\n    // at the start, RT rewards will not be withdrawable\\r\\n    bool public lockRTRewards = true;\\r\\n\\r\\n    // --------- STRUCTS --------------------\\r\\n    struct UserData {\\r\\n        uint256 stake;\\r\\n        uint256 liquidity;\\r\\n        uint256 lastTimestamp;\\r\\n        int256 RTRewardModifier;\\r\\n        int256 NFTXRewardModifier;\\r\\n        uint256 NFTXRewardWithdrawn;\\r\\n    }\\r\\n\\r\\n    struct Dividend {\\r\\n        uint256 RTRewardToken;\\r\\n        uint256 NFTXRewardToken;\\r\\n    }\\r\\n\\r\\n    // --------- CONTRACT DATA --------------\\r\\n    mapping(address => UserData) public users;\\r\\n\\r\\n    // ---------- EXTERNAL CONTRACT METHODS ----------\\r\\n    constructor(\\r\\n        address _NFTXVault,\\r\\n        address _NFTXLPStaking,\\r\\n        address _NFTXRewardDistributionToken,\\r\\n        address _sushiRouter,\\r\\n        address _SLPToken,\\r\\n        address _RTRewardToken,\\r\\n        address _RTStakedToken,\\r\\n        uint256 _rewardPeriod,\\r\\n        uint256 _periodicReward,\\r\\n        uint256 _lockTime\\r\\n    ) {\\r\\n        RTRewardToken = IERC20(_RTRewardToken);\\r\\n        RTStakedToken = IERC721(_RTStakedToken);\\r\\n        rewardPeriod = _rewardPeriod;\\r\\n        periodicReward = _periodicReward;\\r\\n        lockTime = _lockTime;\\r\\n\\r\\n        updateExternalReferences(\\r\\n            _NFTXVault,\\r\\n            _NFTXLPStaking,\\r\\n            _NFTXRewardDistributionToken,\\r\\n            _sushiRouter,\\r\\n            _SLPToken\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Updates all external references (NFTX/Sushiswap/WETH).\\r\\n     * @dev only for the contract owner to use, particularly in the case of near-FUBAR.\\r\\n     * @param _NFTXVault the vault token address\\r\\n     * @param _NFTXLPStaking the NFTXLPStaking contract address\\r\\n     * @param _NFTXRewardDistributionToken the NFTX Reward distribution token\\r\\n     * @param _sushiRouter the address of the Sushiswap router\\r\\n     * @param _SLPToken the address of the liquidity pool WETH/vault token\\r\\n     */\\r\\n    function updateExternalReferences(\\r\\n        address _NFTXVault,\\r\\n        address _NFTXLPStaking,\\r\\n        address _NFTXRewardDistributionToken,\\r\\n        address _sushiRouter,\\r\\n        address _SLPToken\\r\\n    ) public onlyOwner {\\r\\n        // ASSIGNMENTS\\r\\n        NFTXVault = INFTXVault(_NFTXVault);\\r\\n        NFTXLPStaking = INFTXLPStaking(_NFTXLPStaking);\\r\\n        NFTXRewardDistributionToken = IRewardDistributionToken(\\r\\n            _NFTXRewardDistributionToken\\r\\n        );\\r\\n        WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());\\r\\n        sushiRouter = IUniswapV2Router01(_sushiRouter);\\r\\n        SLPToken = IERC20(_SLPToken);\\r\\n\\r\\n        // APPROVALS\\r\\n        IERC20Upgradeable(address(WETH)).approve(\\r\\n            _sushiRouter,\\r\\n            type(uint256).max\\r\\n        );\\r\\n        SLPToken.approve(_sushiRouter, type(uint256).max);\\r\\n        NFTXRewardDistributionToken.approve(\\r\\n            address(NFTXLPStaking),\\r\\n            type(uint256).max\\r\\n        );\\r\\n        NFTXVault.approve(address(sushiRouter), type(uint256).max);\\r\\n        SLPToken.approve(address(NFTXLPStaking), type(uint256).max);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Updates the address for the reward token.\\r\\n     * @param _token the token in which rewards will be disbursed.\\r\\n     */\\r\\n    function setRTRewardToken(address _token) external onlyOwner {\\r\\n        RTRewardToken = IERC20(_token);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Locks/unlocks RT reward withdraw\\r\\n     * @param _locked the value of the lock (boolean)\\r\\n     */\\r\\n    function setLock(bool _locked) external onlyOwner {\\r\\n        lockRTRewards = _locked;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Sets the lock time where assets cannot be removed after staking.\\r\\n     * @param _lockTime the amount of seconds the lock lasts after staking\\r\\n     */\\r\\n    function setLockTime(uint256 _lockTime) external onlyOwner {\\r\\n        require(_lockTime > 0);\\r\\n        lockTime = _lockTime;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Adds liquidity to the pool using the stakable ERC721 token\\r\\n     * and WETH.\\r\\n     * @param _minWethIn the min amount of WETH that will get sent to the LP\\r\\n     * @param _wethIn the amount of WETH that has been provided by the call\\r\\n     * @param _ids the ids of the tokens to stake\\r\\n     */\\r\\n    function addLiquidityERC721(\\r\\n        uint256 _minWethIn,\\r\\n        uint256 _wethIn,\\r\\n        uint256[] calldata _ids\\r\\n    ) external {\\r\\n        uint256 initialWETH = IERC20Upgradeable(address(WETH)).balanceOf(\\r\\n            address(this)\\r\\n        );\\r\\n\\r\\n        IERC20Upgradeable(address(WETH)).transferFrom(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            _wethIn\\r\\n        );\\r\\n        _addLiquidityERC721(msg.sender, _minWethIn, _wethIn, _ids);\\r\\n\\r\\n        uint256 WETHRefund = IERC20Upgradeable(address(WETH)).balanceOf(\\r\\n            address(this)\\r\\n        ) - initialWETH;\\r\\n\\r\\n        if (WETHRefund < _wethIn && WETHRefund > 0)\\r\\n            WETH.transfer(msg.sender, WETHRefund);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Adds liquidity to the pool using the stakable ERC721 token\\r\\n     * and ETH.\\r\\n     * @param _minWethIn the min amount of WETH that will get sent to the LP\\r\\n     * @param _ids the ids of the tokens to stake\\r\\n     * @dev the value passed in is converted to WETH and sent to the LP.\\r\\n     */\\r\\n    function addLiquidityERC721ETH(uint256 _minWethIn, uint256[] calldata _ids)\\r\\n        external\\r\\n        payable\\r\\n    {\\r\\n        uint256 initialWETH = IERC20Upgradeable(address(WETH)).balanceOf(\\r\\n            address(this)\\r\\n        );\\r\\n\\r\\n        WETH.deposit{value: msg.value}();\\r\\n\\r\\n        _addLiquidityERC721(msg.sender, _minWethIn, msg.value, _ids);\\r\\n\\r\\n        uint256 wethRefund = IERC20Upgradeable(address(WETH)).balanceOf(\\r\\n            address(this)\\r\\n        ) - initialWETH;\\r\\n\\r\\n        // Return extras.\\r\\n        if (wethRefund < msg.value && wethRefund > 0) {\\r\\n            WETH.withdraw(wethRefund);\\r\\n            (bool success, ) = payable(msg.sender).call{value: wethRefund}(\\\"\\\");\\r\\n            require(success, \\\"Refund failed\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Adds liquidity to the pool using the stakable ERC20 token\\r\\n     * and WETH.\\r\\n     * @param _minWethIn the min amount of WETH that will get sent to the LP\\r\\n     * @param _wethIn the amount of WETH that has been provided by the call\\r\\n     * @param _amount the amount of the ERC20 token to stake\\r\\n     */\\r\\n    function addLiquidityERC20(\\r\\n        uint256 _minWethIn,\\r\\n        uint256 _wethIn,\\r\\n        uint256 _amount\\r\\n    ) external {\\r\\n        IERC20Upgradeable(address(WETH)).transferFrom(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            _wethIn\\r\\n        );\\r\\n\\r\\n        (, uint256 amountWETH, ) = _addLiquidityERC20(\\r\\n            msg.sender,\\r\\n            _minWethIn,\\r\\n            _wethIn,\\r\\n            _amount\\r\\n        );\\r\\n\\r\\n        // refund unused WETH\\r\\n        if (amountWETH < _wethIn && _wethIn - amountWETH > 0) {\\r\\n            WETH.transfer(msg.sender, _wethIn - amountWETH);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Adds liquidity to the pool using the stakable ERC20 token\\r\\n     * and ETH.\\r\\n     * @param _minWethIn the min amount of WETH that will get sent to the LP\\r\\n     * @param _amount the amount of the ERC20 token to stake\\r\\n     * @dev the value passed in is converted to WETH and sent to the LP.\\r\\n     */\\r\\n    function addLiquidityERC20ETH(uint256 _minWethIn, uint256 _amount)\\r\\n        external\\r\\n        payable\\r\\n    {\\r\\n        WETH.deposit{value: msg.value}();\\r\\n\\r\\n        (, uint256 amountWETH, ) = _addLiquidityERC20(\\r\\n            msg.sender,\\r\\n            _minWethIn,\\r\\n            msg.value,\\r\\n            _amount\\r\\n        );\\r\\n\\r\\n        // refund unused ETH\\r\\n        if (amountWETH < msg.value && msg.value - amountWETH > 0) {\\r\\n            WETH.withdraw(msg.value - amountWETH);\\r\\n            (bool sent, ) = payable(msg.sender).call{\\r\\n                value: msg.value - amountWETH\\r\\n            }(\\\"\\\");\\r\\n            require(sent, \\\"refund failed\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Removes all liquidity from the LP and claims rewards.\\r\\n     * @param _amountTokenMin the min amount of the ERC20 staking token to get back\\r\\n     * @param _amountWETHMin the min amount of WETH to get back\\r\\n     *\\r\\n     * NOTE you cannot withdraw until the timelock has expired.\\r\\n     */\\r\\n    function removeLiquidity(uint256 _amountTokenMin, uint256 _amountWETHMin)\\r\\n        external\\r\\n    {\\r\\n        require(\\r\\n            users[msg.sender].lastTimestamp + lockTime < block.timestamp,\\r\\n            \\\"Locked\\\"\\r\\n        );\\r\\n        _removeLiquidity(msg.sender, _amountTokenMin, _amountWETHMin);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Claims all of the dividends currently owed to the caller.\\r\\n     * Will not claim RT rewards if the lock is set.\\r\\n     */\\r\\n    function claimRewards() external {\\r\\n        _claimRewards(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Gets the rewards owed to the user.\\r\\n     */\\r\\n    function dividendOf(address _user) external view returns (Dividend memory) {\\r\\n        return _dividendOf(_user);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * An emergency function that will allow users to pull out their liquidity in the NFTX\\r\\n     * reward distribution token. DOES NOT DISTRIBUTE REWARDS. This is to be used in the\\r\\n     * case where our connection with NFTX's contracts causes transaction failures.\\r\\n     *\\r\\n     * NOTE you cannot withdraw until the timelock has expired.\\r\\n     */\\r\\n    function emergencyExit() external {\\r\\n        require(\\r\\n            users[msg.sender].lastTimestamp + lockTime < block.timestamp,\\r\\n            \\\"Locked\\\"\\r\\n        );\\r\\n        _emergencyExit(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Shows the time until the user's funds are unlocked (unix seconds).\\r\\n     * @param _user the user whose lock time we are checking\\r\\n     */\\r\\n    function lockedUntil(address _user) external view returns (uint256) {\\r\\n        require(users[_user].lastTimestamp != 0, \\\"N/A\\\");\\r\\n        return users[_user].lastTimestamp + lockTime;\\r\\n    }\\r\\n\\r\\n    // ---------- INTERNAL CONTRACT METHODS ----------\\r\\n    function _totalLiquidityStaked() internal view returns (uint256) {\\r\\n        return NFTXRewardDistributionToken.balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * An emergency escape in the unlikely case of a contract error\\r\\n     * causing unstaking methods to fail.\\r\\n     */\\r\\n    function _emergencyExit(address _user) internal {\\r\\n        uint256 liquidity = users[_user].liquidity;\\r\\n        delete users[_user];\\r\\n\\r\\n        NFTXRewardDistributionToken.transfer(_user, liquidity);\\r\\n    }\\r\\n\\r\\n    function _claimContractNFTXRewards() internal {\\r\\n        uint256 currentRewards = NFTXVault.balanceOf(address(this));\\r\\n        uint256 dividend = NFTXRewardDistributionToken.dividendOf(\\r\\n            address(this)\\r\\n        );\\r\\n        if (dividend == 0) return;\\r\\n\\r\\n        NFTXLPStaking.claimRewards(NFTXVault.vaultId());\\r\\n        require(\\r\\n            NFTXVault.balanceOf(address(this)) == currentRewards + dividend,\\r\\n            \\\"Unexpected balance\\\"\\r\\n        );\\r\\n\\r\\n        NFTXRewardPerLiquidity += dividend.div(_totalLiquidityStaked());\\r\\n    }\\r\\n\\r\\n    function _addLiquidityERC721(\\r\\n        address _user,\\r\\n        uint256 _minWethIn,\\r\\n        uint256 _wethIn,\\r\\n        uint256[] calldata _ids\\r\\n    )\\r\\n        internal\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountWETH,\\r\\n            uint256 liquidity\\r\\n        )\\r\\n    {\\r\\n        _claimContractNFTXRewards();\\r\\n        uint256 initialRewardToken = NFTXVault.balanceOf(address(this));\\r\\n\\r\\n        for (uint256 i = 0; i < _ids.length; i++) {\\r\\n            RTStakedToken.transferFrom(_user, address(this), _ids[i]);\\r\\n        }\\r\\n        RTStakedToken.setApprovalForAll(address(NFTXVault), true);\\r\\n        NFTXVault.mint(_ids, new uint256[](0));\\r\\n\\r\\n        uint256 newTokens = NFTXVault.balanceOf(address(this)) -\\r\\n            initialRewardToken;\\r\\n\\r\\n        return _stakeAndUpdate(_user, _minWethIn, _wethIn, newTokens);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Adds liquidity in ERC20 (the vault token)\\r\\n     */\\r\\n    function _addLiquidityERC20(\\r\\n        address _user,\\r\\n        uint256 _minWethIn,\\r\\n        uint256 _wethIn,\\r\\n        uint256 _amount\\r\\n    )\\r\\n        internal\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountWETH,\\r\\n            uint256 liquidity\\r\\n        )\\r\\n    {\\r\\n        _claimContractNFTXRewards();\\r\\n\\r\\n        NFTXVault.transferFrom(_user, address(this), _amount);\\r\\n        return _stakeAndUpdate(_user, _minWethIn, _wethIn, _amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Stakes on the SLP and then on NFTx's platform\\r\\n     * @dev All vault token and WETH should be owned by the\\r\\n     * contract before calling.\\r\\n     */\\r\\n    function _stakeAndUpdate(\\r\\n        address _user,\\r\\n        uint256 _minWethIn,\\r\\n        uint256 _wethIn,\\r\\n        uint256 _amount // amount of ERC20 vault token\\r\\n    )\\r\\n        internal\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountWETH,\\r\\n            uint256 liquidity\\r\\n        )\\r\\n    {\\r\\n        // stake on SUSHI\\r\\n        (\\r\\n            amountToken,\\r\\n            amountWETH, // amt used\\r\\n            liquidity\\r\\n        ) = sushiRouter.addLiquidity(\\r\\n            address(NFTXVault),\\r\\n            address(WETH),\\r\\n            _amount,\\r\\n            _wethIn,\\r\\n            _amount,\\r\\n            _minWethIn,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n\\r\\n        NFTXLPStaking.deposit(NFTXVault.vaultId(), liquidity); // DEPOSIT IN NFTX\\r\\n\\r\\n        UserData memory userData = users[_user];\\r\\n\\r\\n        uint256 NFTXRewardModifier = liquidity.mul(NFTXRewardPerLiquidity);\\r\\n        uint256 currentNumPeriods = userData.lastTimestamp == 0\\r\\n            ? 0\\r\\n            : (block.timestamp - userData.lastTimestamp) / rewardPeriod;\\r\\n\\r\\n        userData.liquidity += liquidity;\\r\\n        userData.RTRewardModifier += int256(\\r\\n            currentNumPeriods * periodicReward.mul(userData.stake)\\r\\n        );\\r\\n        userData.lastTimestamp = block.timestamp;\\r\\n        userData.stake += _amount;\\r\\n        userData.NFTXRewardModifier -= int256(NFTXRewardModifier);\\r\\n\\r\\n        users[_user] = userData;\\r\\n\\r\\n        // return unstaked vault token\\r\\n        if (amountToken < _amount) {\\r\\n            NFTXVault.transfer(_user, _amount - amountToken);\\r\\n        }\\r\\n\\r\\n        emit Staked(_user, _amount, liquidity, amountWETH);\\r\\n    }\\r\\n\\r\\n    function _dividendOf(address _user)\\r\\n        internal\\r\\n        view\\r\\n        returns (Dividend memory)\\r\\n    {\\r\\n        uint256 updatedNFTXRewardPerLiquidity = NFTXRewardPerLiquidity +\\r\\n            NFTXRewardDistributionToken.dividendOf(address(this)).div(\\r\\n                _totalLiquidityStaked()\\r\\n            );\\r\\n\\r\\n        int256 nftxReward = int256(\\r\\n            (users[_user].liquidity.mul(updatedNFTXRewardPerLiquidity))\\r\\n        ) +\\r\\n            users[_user].NFTXRewardModifier -\\r\\n            int256(users[_user].NFTXRewardWithdrawn);\\r\\n\\r\\n        uint256 numPeriods = users[_user].lastTimestamp == 0\\r\\n            ? 0\\r\\n            : (block.timestamp - users[_user].lastTimestamp) / rewardPeriod;\\r\\n\\r\\n        int256 rtReward = int256(\\r\\n            numPeriods * periodicReward.mul(users[_user].stake)\\r\\n        ) + users[_user].RTRewardModifier;\\r\\n\\r\\n        require(nftxReward >= 0 && rtReward >= 0, \\\"Negative Reward\\\");\\r\\n\\r\\n        Dividend memory dividend;\\r\\n        dividend.NFTXRewardToken = uint256(nftxReward);\\r\\n        dividend.RTRewardToken = uint256(rtReward);\\r\\n\\r\\n        return dividend;\\r\\n    }\\r\\n\\r\\n    function _claimRewards(address _user) internal {\\r\\n        _claimContractNFTXRewards();\\r\\n\\r\\n        Dividend memory rewards = _dividendOf(_user);\\r\\n        if (rewards.NFTXRewardToken > 0) {\\r\\n            users[_user].NFTXRewardWithdrawn += rewards.NFTXRewardToken;\\r\\n            NFTXVault.transfer(_user, rewards.NFTXRewardToken);\\r\\n        }\\r\\n        if (rewards.RTRewardToken > 0 && !lockRTRewards) {\\r\\n            users[_user].RTRewardModifier -= int256(rewards.RTRewardToken);\\r\\n            RTRewardToken.transfer(_user, rewards.RTRewardToken);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _removeLiquidity(\\r\\n        address _user,\\r\\n        uint256 _amountTokenMin,\\r\\n        uint256 _amountWETHMin\\r\\n    ) internal {\\r\\n        uint256 amount = users[_user].liquidity;\\r\\n        uint256 stake = users[_user].stake;\\r\\n        _claimRewards(_user);\\r\\n        delete users[_user];\\r\\n\\r\\n        // remove from NFTXLPStaking\\r\\n        NFTXLPStaking.withdraw(NFTXVault.vaultId(), amount); // gives us <amount> SLP\\r\\n        sushiRouter.removeLiquidity(\\r\\n            address(NFTXVault),\\r\\n            address(WETH),\\r\\n            amount,\\r\\n            _amountTokenMin,\\r\\n            _amountWETHMin,\\r\\n            _user, // send to user\\r\\n            block.timestamp\\r\\n        ); // return to user\\r\\n\\r\\n        emit Unstaked(_user, stake, amount);\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        // DO NOTHING\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"nftx/interface/INFTXVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interface/INFTXEligibility.sol\\\";\\nimport \\\"../token/IERC20Upgradeable.sol\\\";\\nimport \\\"../interface/INFTXVaultFactory.sol\\\";\\n\\ninterface INFTXVault is IERC20Upgradeable {\\n    function manager() external view returns (address);\\n    function assetAddress() external view returns (address);\\n    function vaultFactory() external view returns (INFTXVaultFactory);\\n    function eligibilityStorage() external view returns (INFTXEligibility);\\n\\n    function is1155() external view returns (bool);\\n    function allowAllItems() external view returns (bool);\\n    function enableMint() external view returns (bool);\\n    function enableRandomRedeem() external view returns (bool);\\n    function enableTargetRedeem() external view returns (bool);\\n    function enableRandomSwap() external view returns (bool);\\n    function enableTargetSwap() external view returns (bool);\\n\\n    function vaultId() external view returns (uint256);\\n    function nftIdAt(uint256 holdingsIndex) external view returns (uint256);\\n    function allHoldings() external view returns (uint256[] memory);\\n    function totalHoldings() external view returns (uint256);\\n    function mintFee() external view returns (uint256);\\n    function randomRedeemFee() external view returns (uint256);\\n    function targetRedeemFee() external view returns (uint256);\\n    function randomSwapFee() external view returns (uint256);\\n    function targetSwapFee() external view returns (uint256);\\n    function vaultFees() external view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n    event VaultInit(\\n        uint256 indexed vaultId,\\n        address assetAddress,\\n        bool is1155,\\n        bool allowAllItems\\n    );\\n\\n    event ManagerSet(address manager);\\n    event EligibilityDeployed(uint256 moduleIndex, address eligibilityAddr);\\n    // event CustomEligibilityDeployed(address eligibilityAddr);\\n\\n    event EnableMintUpdated(bool enabled);\\n    event EnableRandomRedeemUpdated(bool enabled);\\n    event EnableTargetRedeemUpdated(bool enabled);\\n    event EnableRandomSwapUpdated(bool enabled);\\n    event EnableTargetSwapUpdated(bool enabled);\\n\\n    event Minted(uint256[] nftIds, uint256[] amounts, address to);\\n    event Redeemed(uint256[] nftIds, uint256[] specificIds, address to);\\n    event Swapped(\\n        uint256[] nftIds,\\n        uint256[] amounts,\\n        uint256[] specificIds,\\n        uint256[] redeemedIds,\\n        address to\\n    );\\n\\n    function __NFTXVault_init(\\n        string calldata _name,\\n        string calldata _symbol,\\n        address _assetAddress,\\n        bool _is1155,\\n        bool _allowAllItems\\n    ) external;\\n\\n    function finalizeVault() external;\\n\\n    function setVaultMetadata(\\n        string memory name_, \\n        string memory symbol_\\n    ) external;\\n\\n    function setVaultFeatures(\\n        bool _enableMint,\\n        bool _enableRandomRedeem,\\n        bool _enableTargetRedeem,\\n        bool _enableRandomSwap,\\n        bool _enableTargetSwap\\n    ) external;\\n\\n    function setFees(\\n        uint256 _mintFee,\\n        uint256 _randomRedeemFee,\\n        uint256 _targetRedeemFee,\\n        uint256 _randomSwapFee,\\n        uint256 _targetSwapFee\\n    ) external;\\n    function disableVaultFees() external;\\n\\n    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.\\n    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow\\n    // a similar interface.\\n    function deployEligibilityStorage(\\n        uint256 moduleIndex,\\n        bytes calldata initData\\n    ) external returns (address);\\n\\n    // The manager has control over options like fees and features\\n    function setManager(address _manager) external;\\n\\n    function mint(\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata amounts /* ignored for ERC721 vaults */\\n    ) external returns (uint256);\\n\\n    function mintTo(\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\\n        address to\\n    ) external returns (uint256);\\n\\n    function redeem(uint256 amount, uint256[] calldata specificIds)\\n        external\\n        returns (uint256[] calldata);\\n\\n    function redeemTo(\\n        uint256 amount,\\n        uint256[] calldata specificIds,\\n        address to\\n    ) external returns (uint256[] calldata);\\n\\n    function swap(\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\\n        uint256[] calldata specificIds\\n    ) external returns (uint256[] calldata);\\n\\n    function swapTo(\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata amounts, /* ignored for ERC721 vaults */\\n        uint256[] calldata specificIds,\\n        address to\\n    ) external returns (uint256[] calldata);\\n\\n    function allValidNFTs(uint256[] calldata tokenIds)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"nftx/interface/INFTXLPStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface INFTXLPStaking {\\n    function nftxVaultFactory() external view returns (address);\\n    function rewardDistTokenImpl() external view returns (address);\\n    function stakingTokenProvider() external view returns (address);\\n    function vaultToken(address _stakingToken) external view returns (address);\\n    function stakingToken(address _vaultToken) external view returns (address);\\n    function rewardDistributionToken(uint256 vaultId) external view returns (address);\\n    function newRewardDistributionToken(uint256 vaultId) external view returns (address);\\n    function oldRewardDistributionToken(uint256 vaultId) external view returns (address);\\n    function unusedRewardDistributionToken(uint256 vaultId) external view returns (address);\\n    function rewardDistributionTokenAddr(address stakingToken, address rewardToken) external view returns (address);\\n    \\n    // Write functions.\\n    function __NFTXLPStaking__init(address _stakingTokenProvider) external;\\n    function setNFTXVaultFactory(address newFactory) external;\\n    function setStakingTokenProvider(address newProvider) external;\\n    function addPoolForVault(uint256 vaultId) external;\\n    function updatePoolForVault(uint256 vaultId) external;\\n    function updatePoolForVaults(uint256[] calldata vaultId) external;\\n    function receiveRewards(uint256 vaultId, uint256 amount) external returns (bool);\\n    function deposit(uint256 vaultId, uint256 amount) external;\\n    function timelockDepositFor(uint256 vaultId, address account, uint256 amount, uint256 timelockLength) external;\\n    function exit(uint256 vaultId, uint256 amount) external;\\n    function rescue(uint256 vaultId) external;\\n    function withdraw(uint256 vaultId, uint256 amount) external;\\n    function claimRewards(uint256 vaultId) external;\\n}\"\r\n    },\r\n    \"nftx/interface/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB)\\n        external\\n        pure\\n        returns (uint256 amountB);\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"nftx/interface/IVaultTokenUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/IERC20Upgradeable.sol\\\";\\n\\ninterface IVaultTokenUpgradeable is IERC20Upgradeable {\\n    function mint(address to, uint256 amount) external;\\n\\n    function burnFrom(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"nftx/interface/IRewardDistributionToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/IERC20Upgradeable.sol\\\";\\n\\ninterface IRewardDistributionToken is IERC20Upgradeable {\\n  function distributeRewards(uint amount) external;\\n  function __RewardDistributionToken_init(IERC20Upgradeable _target, string memory _name, string memory _symbol) external;\\n  function mint(address account, address to, uint256 amount) external;\\n  function burnFrom(address account, uint256 amount) external;\\n  function withdrawReward(address user) external;\\n  function dividendOf(address _owner) external view returns(uint256);\\n  function withdrawnRewardOf(address _owner) external view returns(uint256);\\n  function accumulativeRewardOf(address _owner) external view returns(uint256);\\n}\"\r\n    },\r\n    \"nftx/interface/INFTXStakingZap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./INFTXVault.sol\\\";\\nimport \\\"./INFTXVaultFactory.sol\\\";\\nimport \\\"./INFTXFeeDistributor.sol\\\";\\nimport \\\"./INFTXLPStaking.sol\\\";\\nimport \\\"./ITimelockRewardDistributionToken.sol\\\";\\nimport \\\"./IUniswapV2Router01.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC721.sol\\\";\\nimport \\\"../token/IERC1155Upgradeable.sol\\\";\\nimport \\\"../token/IERC20Upgradeable.sol\\\";\\nimport \\\"../token/ERC721HolderUpgradeable.sol\\\";\\nimport \\\"../token/IERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"../util/OwnableUpgradeable.sol\\\";\\n\\n// Authors: @0xKiwi_.\\nabstract contract IWETH {\\n  function deposit() virtual external payable;\\n  function transfer(address to, uint value) virtual external returns (bool);\\n  function withdraw(uint) virtual external;\\n}\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\nabstract contract INFTXStakingZap is IERC721ReceiverUpgradeable, IERC1155ReceiverUpgradeable {\\n  IWETH public immutable WETH; \\n  INFTXLPStaking public immutable lpStaking;\\n  INFTXVaultFactory public immutable nftxFactory;\\n  IUniswapV2Router01 public immutable sushiRouter;\\n  uint256 public lockTime;\\n\\n  constructor(address _nftxFactory, address _sushiRouter) {\\n    nftxFactory = INFTXVaultFactory(_nftxFactory);\\n    lpStaking = INFTXLPStaking(INFTXFeeDistributor(INFTXVaultFactory(_nftxFactory).feeDistributor()).lpStaking());\\n    sushiRouter = IUniswapV2Router01(_sushiRouter);\\n    WETH = IWETH(IUniswapV2Router01(_sushiRouter).WETH());\\n    IERC20Upgradeable(address(IUniswapV2Router01(_sushiRouter).WETH())).approve(_sushiRouter, type(uint256).max);\\n  }\\n\\n  function setLockTime(uint256 newLockTime) virtual external;\\n\\n  function addLiquidity721ETH(\\n    uint256 vaultId, \\n    uint256[] memory ids, \\n    uint256 minWethIn\\n  ) virtual external payable returns (uint256);\\n\\n  function addLiquidity721ETHTo(\\n    uint256 vaultId, \\n    uint256[] memory ids, \\n    uint256 minWethIn,\\n    address to\\n  ) virtual external payable returns (uint256);\\n\\n  function addLiquidity1155ETH(\\n    uint256 vaultId, \\n    uint256[] memory ids, \\n    uint256[] memory amounts,\\n    uint256 minEthIn\\n  ) virtual external payable returns (uint256);\\n\\n  function addLiquidity1155ETHTo(\\n    uint256 vaultId, \\n    uint256[] memory ids, \\n    uint256[] memory amounts,\\n    uint256 minEthIn,\\n    address to\\n  ) virtual external payable returns (uint256);\\n\\n  function addLiquidity721(\\n    uint256 vaultId, \\n    uint256[] memory ids, \\n    uint256 minWethIn,\\n    uint256 wethIn\\n  ) virtual external returns (uint256);\\n\\n  function addLiquidity721To(\\n    uint256 vaultId, \\n    uint256[] memory ids, \\n    uint256 minWethIn,\\n    uint256 wethIn,\\n    address to\\n  ) virtual external returns (uint256);\\n\\n  function addLiquidity1155(\\n    uint256 vaultId, \\n    uint256[] memory ids,\\n    uint256[] memory amounts,\\n    uint256 minWethIn,\\n    uint256 wethIn\\n  ) virtual external returns (uint256);\\n\\n  function addLiquidity1155To(\\n    uint256 vaultId, \\n    uint256[] memory ids,\\n    uint256[] memory amounts,\\n    uint256 minWethIn,\\n    uint256 wethIn,\\n    address to\\n  ) virtual external returns (uint256);\\n\\n  function lockedUntil(uint256 vaultId, address who) virtual external view returns (uint256);\\n\\n  function lockedLPBalance(uint256 vaultId, address who) virtual external view returns (uint256);\\n\\n  receive() virtual external payable;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"prb-math/contracts/PRBMathUD60x18.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\nimport \\\"./PRBMath.sol\\\";\\n\\n/// @title PRBMathUD60x18\\n/// @author Paul Razvan Berg\\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\\n/// maximum values permitted by the Solidity type uint256.\\nlibrary PRBMathUD60x18 {\\n    /// @dev Half the SCALE number.\\n    uint256 internal constant HALF_SCALE = 5e17;\\n\\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\\n    uint256 internal constant LOG2_E = 1_442695040888963407;\\n\\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\\n    uint256 internal constant MAX_UD60x18 =\\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\\n\\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\\n    uint256 internal constant MAX_WHOLE_UD60x18 =\\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // The operations can never overflow.\\n        unchecked {\\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\\n        }\\n    }\\n\\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\\n    ///\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\\n    function ceil(uint256 x) internal pure returns (uint256 result) {\\n        if (x > MAX_WHOLE_UD60x18) {\\n            revert PRBMathUD60x18__CeilOverflow(x);\\n        }\\n        assembly {\\n            // Equivalent to \\\"x % SCALE\\\" but faster.\\n            let remainder := mod(x, SCALE)\\n\\n            // Equivalent to \\\"SCALE - remainder\\\" but faster.\\n            let delta := sub(SCALE, remainder)\\n\\n            // Equivalent to \\\"x + delta * (remainder > 0 ? 1 : 0)\\\" but faster.\\n            result := add(x, mul(delta, gt(remainder, 0)))\\n        }\\n    }\\n\\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\\n    ///\\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    ///\\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        result = PRBMath.mulDiv(x, SCALE, y);\\n    }\\n\\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\\n    function e() internal pure returns (uint256 result) {\\n        result = 2_718281828459045235;\\n    }\\n\\n    /// @notice Calculates the natural exponent of x.\\n    ///\\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    /// - x must be less than 133.084258667509499441.\\n    ///\\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp(uint256 x) internal pure returns (uint256 result) {\\n        // Without this check, the value passed to \\\"exp2\\\" would be greater than 192.\\n        if (x >= 133_084258667509499441) {\\n            revert PRBMathUD60x18__ExpInputTooBig(x);\\n        }\\n\\n        // Do the fixed-point multiplication inline to save gas.\\n        unchecked {\\n            uint256 doubleScaleProduct = x * LOG2_E;\\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\\n        }\\n    }\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    ///\\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\\n    ///\\n    /// Requirements:\\n    /// - x must be 192 or less.\\n    /// - The result must fit within MAX_UD60x18.\\n    ///\\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\\n        if (x >= 192e18) {\\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\\n        }\\n\\n        unchecked {\\n            // Convert x to the 192.64-bit fixed-point format.\\n            uint256 x192x64 = (x << 64) / SCALE;\\n\\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\\n            result = PRBMath.exp2(x192x64);\\n        }\\n    }\\n\\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\\n    function floor(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            // Equivalent to \\\"x % SCALE\\\" but faster.\\n            let remainder := mod(x, SCALE)\\n\\n            // Equivalent to \\\"x - remainder * (remainder > 0 ? 1 : 0)\\\" but faster.\\n            result := sub(x, mul(remainder, gt(remainder, 0)))\\n        }\\n    }\\n\\n    /// @notice Yields the excess beyond the floor of x.\\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\\n    function frac(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mod(x, SCALE)\\n        }\\n    }\\n\\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\\n    ///\\n    /// @dev Requirements:\\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\\n    ///\\n    /// @param x The basic integer to convert.\\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            if (x > MAX_UD60x18 / SCALE) {\\n                revert PRBMathUD60x18__FromUintOverflow(x);\\n            }\\n            result = x * SCALE;\\n        }\\n    }\\n\\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\\n    ///\\n    /// @dev Requirements:\\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\\n    ///\\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        unchecked {\\n            // Checking for overflow this way is faster than letting Solidity do it.\\n            uint256 xy = x * y;\\n            if (xy / x != y) {\\n                revert PRBMathUD60x18__GmOverflow(x, y);\\n            }\\n\\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\\n            // during multiplication. See the comments within the \\\"sqrt\\\" function.\\n            result = PRBMath.sqrt(xy);\\n        }\\n    }\\n\\n    /// @notice Calculates 1 / x, rounding toward zero.\\n    ///\\n    /// @dev Requirements:\\n    /// - x cannot be zero.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\\n    function inv(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 1e36 is SCALE * SCALE.\\n            result = 1e36 / x;\\n        }\\n    }\\n\\n    /// @notice Calculates the natural logarithm of x.\\n    ///\\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function ln(uint256 x) internal pure returns (uint256 result) {\\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\\n        // can return is 196205294292027477728.\\n        unchecked {\\n            result = (log2(x) * SCALE) / LOG2_E;\\n        }\\n    }\\n\\n    /// @notice Calculates the common logarithm of x.\\n    ///\\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log10(uint256 x) internal pure returns (uint256 result) {\\n        if (x < SCALE) {\\n            revert PRBMathUD60x18__LogInputTooSmall(x);\\n        }\\n\\n        // Note that the \\\"mul\\\" in this block is the assembly multiplication operation, not the \\\"mul\\\" function defined\\n        // in this contract.\\n        // prettier-ignore\\n        assembly {\\n            switch x\\n            case 1 { result := mul(SCALE, sub(0, 18)) }\\n            case 10 { result := mul(SCALE, sub(1, 18)) }\\n            case 100 { result := mul(SCALE, sub(2, 18)) }\\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\\n            case 1000000000000000000 { result := 0 }\\n            case 10000000000000000000 { result := SCALE }\\n            case 100000000000000000000 { result := mul(SCALE, 2) }\\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\\n            default {\\n                result := MAX_UD60x18\\n            }\\n        }\\n\\n        if (result == MAX_UD60x18) {\\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\\n            unchecked {\\n                result = (log2(x) * SCALE) / 3_321928094887362347;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the binary logarithm of x.\\n    ///\\n    /// @dev Based on the iterative approximation algorithm.\\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n    ///\\n    /// Caveats:\\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log2(uint256 x) internal pure returns (uint256 result) {\\n        if (x < SCALE) {\\n            revert PRBMathUD60x18__LogInputTooSmall(x);\\n        }\\n        unchecked {\\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\\n\\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\\n            // because n is maximum 255 and SCALE is 1e18.\\n            result = n * SCALE;\\n\\n            // This is y = x * 2^(-n).\\n            uint256 y = x >> n;\\n\\n            // If y = 1, the fractional part is zero.\\n            if (y == SCALE) {\\n                return result;\\n            }\\n\\n            // Calculate the fractional part via the iterative approximation.\\n            // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\\n                y = (y * y) / SCALE;\\n\\n                // Is y^2 > 2 and so in the range [2,4)?\\n                if (y >= 2 * SCALE) {\\n                    // Add the 2^(-m) factor to the logarithm.\\n                    result += delta;\\n\\n                    // Corresponds to z/2 on Wikipedia.\\n                    y >>= 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\\n    /// fixed-point number.\\n    /// @dev See the documentation for the \\\"PRBMath.mulDivFixedPoint\\\" function.\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        result = PRBMath.mulDivFixedPoint(x, y);\\n    }\\n\\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\\n    function pi() internal pure returns (uint256 result) {\\n        result = 3_141592653589793238;\\n    }\\n\\n    /// @notice Raises x to the power of y.\\n    ///\\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            result = y == 0 ? SCALE : uint256(0);\\n        } else {\\n            result = exp2(mul(log2(x), y));\\n        }\\n    }\\n\\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\\n    /// famous algorithm \\\"exponentiation by squaring\\\".\\n    ///\\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within MAX_UD60x18.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The exponent as an uint256.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // Calculate the first iteration of the loop in advance.\\n        result = y & 1 > 0 ? x : SCALE;\\n\\n        // Equivalent to \\\"for(y /= 2; y > 0; y /= 2)\\\" but faster.\\n        for (y >>= 1; y > 0; y >>= 1) {\\n            x = PRBMath.mulDivFixedPoint(x, x);\\n\\n            // Equivalent to \\\"y % 2 == 1\\\" but faster.\\n            if (y & 1 > 0) {\\n                result = PRBMath.mulDivFixedPoint(result, x);\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\\n    function scale() internal pure returns (uint256 result) {\\n        result = SCALE;\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than MAX_UD60x18 / SCALE.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            if (x > MAX_UD60x18 / SCALE) {\\n                revert PRBMathUD60x18__SqrtOverflow(x);\\n            }\\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\\n            result = PRBMath.sqrt(x * SCALE);\\n        }\\n    }\\n\\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\\n    /// @return result The same number in basic integer form.\\n    function toUint(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = x / SCALE;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"nftx/interface/INFTXEligibility.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface INFTXEligibility {\\n    // Read functions.\\n    function name() external pure returns (string memory);\\n    function finalized() external view returns (bool);\\n    function targetAsset() external pure returns (address);\\n    function checkAllEligible(uint256[] calldata tokenIds)\\n        external\\n        view\\n        returns (bool);\\n    function checkEligible(uint256[] calldata tokenIds)\\n        external\\n        view\\n        returns (bool[] memory);\\n    function checkAllIneligible(uint256[] calldata tokenIds)\\n        external\\n        view\\n        returns (bool);\\n    function checkIsEligible(uint256 tokenId) external view returns (bool);\\n\\n    // Write functions.\\n    function __NFTXEligibility_init_bytes(bytes calldata configData) external;\\n    function beforeMintHook(uint256[] calldata tokenIds) external;\\n    function afterMintHook(uint256[] calldata tokenIds) external;\\n    function beforeRedeemHook(uint256[] calldata tokenIds) external;\\n    function afterRedeemHook(uint256[] calldata tokenIds) external;\\n}\\n\"\r\n    },\r\n    \"nftx/token/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20Upgradeable {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"nftx/interface/INFTXVaultFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../proxy/IBeacon.sol\\\";\\n\\ninterface INFTXVaultFactory is IBeacon {\\n  // Read functions.\\n  function numVaults() external view returns (uint256);\\n  function zapContract() external view returns (address);\\n  function feeDistributor() external view returns (address);\\n  function eligibilityManager() external view returns (address);\\n  function vault(uint256 vaultId) external view returns (address);\\n  function allVaults() external view returns (address[] memory);\\n  function vaultsForAsset(address asset) external view returns (address[] memory);\\n  function isLocked(uint256 id) external view returns (bool);\\n  function excludedFromFees(address addr) external view returns (bool);\\n  function factoryMintFee() external view returns (uint64);\\n  function factoryRandomRedeemFee() external view returns (uint64);\\n  function factoryTargetRedeemFee() external view returns (uint64);\\n  function factoryRandomSwapFee() external view returns (uint64);\\n  function factoryTargetSwapFee() external view returns (uint64);\\n  function vaultFees(uint256 vaultId) external view returns (uint256, uint256, uint256, uint256, uint256);\\n\\n  event NewFeeDistributor(address oldDistributor, address newDistributor);\\n  event NewZapContract(address oldZap, address newZap);\\n  event FeeExclusion(address feeExcluded, bool excluded);\\n  event NewEligibilityManager(address oldEligManager, address newEligManager);\\n  event NewVault(uint256 indexed vaultId, address vaultAddress, address assetAddress);\\n  event UpdateVaultFees(uint256 vaultId, uint256 mintFee, uint256 randomRedeemFee, uint256 targetRedeemFee, uint256 randomSwapFee, uint256 targetSwapFee);\\n  event DisableVaultFees(uint256 vaultId);\\n  event UpdateFactoryFees(uint256 mintFee, uint256 randomRedeemFee, uint256 targetRedeemFee, uint256 randomSwapFee, uint256 targetSwapFee);\\n\\n  // Write functions.\\n  function __NFTXVaultFactory_init(address _vaultImpl, address _feeDistributor) external;\\n  function createVault(\\n      string calldata name,\\n      string calldata symbol,\\n      address _assetAddress,\\n      bool is1155,\\n      bool allowAllItems\\n  ) external returns (uint256);\\n  function setFeeDistributor(address _feeDistributor) external;\\n  function setEligibilityManager(address _eligibilityManager) external;\\n  function setZapContract(address _zapContract) external;\\n  function setFeeExclusion(address _excludedAddr, bool excluded) external;\\n\\n  function setFactoryFees(\\n    uint256 mintFee, \\n    uint256 randomRedeemFee, \\n    uint256 targetRedeemFee,\\n    uint256 randomSwapFee, \\n    uint256 targetSwapFee\\n  ) external; \\n  function setVaultFees(\\n      uint256 vaultId, \\n      uint256 mintFee, \\n      uint256 randomRedeemFee, \\n      uint256 targetRedeemFee,\\n      uint256 randomSwapFee, \\n      uint256 targetSwapFee\\n  ) external;\\n  function disableVaultFees(uint256 vaultId) external;\\n}\\n\"\r\n    },\r\n    \"nftx/proxy/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\r\\n */\\r\\ninterface IBeacon {\\r\\n    /**\\r\\n     * @dev Must return an address that can be used as a delegate call target.\\r\\n     *\\r\\n     * {BeaconProxy} will check that this address is a contract.\\r\\n     */\\r\\n    function childImplementation() external view returns (address);\\r\\n    function upgradeChildTo(address newImplementation) external;\\r\\n}\"\r\n    },\r\n    \"nftx/interface/INFTXFeeDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface INFTXFeeDistributor {\\n  \\n  struct FeeReceiver {\\n    uint256 allocPoint;\\n    address receiver;\\n    bool isContract;\\n  }\\n\\n  function nftxVaultFactory() external returns (address);\\n  function lpStaking() external returns (address);\\n  function treasury() external returns (address);\\n  function defaultTreasuryAlloc() external returns (uint256);\\n  function defaultLPAlloc() external returns (uint256);\\n  function allocTotal(uint256 vaultId) external returns (uint256);\\n  function specificTreasuryAlloc(uint256 vaultId) external returns (uint256);\\n\\n  // Write functions.\\n  function __FeeDistributor__init__(address _lpStaking, address _treasury) external;\\n  function rescueTokens(address token) external;\\n  function distribute(uint256 vaultId) external;\\n  function addReceiver(uint256 _vaultId, uint256 _allocPoint, address _receiver, bool _isContract) external;\\n  function initializeVaultReceivers(uint256 _vaultId) external;\\n  function changeMultipleReceiverAlloc(\\n    uint256[] memory _vaultIds, \\n    uint256[] memory _receiverIdxs, \\n    uint256[] memory allocPoints\\n  ) external;\\n\\n  function changeMultipleReceiverAddress(\\n    uint256[] memory _vaultIds, \\n    uint256[] memory _receiverIdxs, \\n    address[] memory addresses, \\n    bool[] memory isContracts\\n  ) external;\\n  function changeReceiverAlloc(uint256 _vaultId, uint256 _idx, uint256 _allocPoint) external;\\n  function changeReceiverAddress(uint256 _vaultId, uint256 _idx, address _address, bool _isContract) external;\\n  function removeReceiver(uint256 _vaultId, uint256 _receiverIdx) external;\\n\\n  // Configuration functions.\\n  function setTreasuryAddress(address _treasury) external;\\n  function setDefaultTreasuryAlloc(uint256 _allocPoint) external;\\n  function setSpecificTreasuryAlloc(uint256 _vaultId, uint256 _allocPoint) external;\\n  function setLPStakingAddress(address _lpStaking) external;\\n  function setNFTXVaultFactory(address _factory) external;\\n  function setDefaultLPAlloc(uint256 _allocPoint) external;\\n} \"\r\n    },\r\n    \"nftx/interface/ITimelockRewardDistributionToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/IERC20Upgradeable.sol\\\";\\n\\ninterface ITimelockRewardDistributionToken is IERC20Upgradeable {\\n  function distributeRewards(uint amount) external;\\n  function __TimelockRewardDistributionToken_init(IERC20Upgradeable _target, string memory _name, string memory _symbol) external;\\n  function mint(address account, address to, uint256 amount) external;\\n  function timelockMint(address account, uint256 amount, uint256 timelockLength) external;\\n  function burnFrom(address account, uint256 amount) external;\\n  function withdrawReward(address user) external;\\n  function dividendOf(address _owner) external view returns(uint256);\\n  function withdrawnRewardOf(address _owner) external view returns(uint256);\\n  function accumulativeRewardOf(address _owner) external view returns(uint256);\\n  function timelockUntil(address account) external view returns (uint256);\\n}\"\r\n    },\r\n    \"nftx/token/IERC1155Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../interface/IERC165Upgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\r\\n *\\r\\n * _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\r\\n     */\\r\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\r\\n     * transfers.\\r\\n     */\\r\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\r\\n     * `approved`.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\r\\n     *\\r\\n     * If an {URI} event was emitted for `id`, the standard\\r\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\r\\n     * returned by {IERC1155MetadataURI-uri}.\\r\\n     */\\r\\n    event URI(string value, uint256 indexed id);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     */\\r\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `accounts` and `ids` must have the same length.\\r\\n     */\\r\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `operator` cannot be the caller.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\r\\n     *\\r\\n     * See {setApprovalForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\r\\n     *\\r\\n     * Emits a {TransferSingle} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\r\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\r\\n\\r\\n    /**\\r\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\r\\n     *\\r\\n     * Emits a {TransferBatch} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `ids` and `amounts` must have the same length.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\r\\n     * acceptance magic value.\\r\\n     */\\r\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"nftx/token/ERC721HolderUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC721ReceiverUpgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC721Receiver} interface.\\r\\n *\\r\\n * Accepts all token transfers.\\r\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\r\\n */\\r\\ncontract ERC721HolderUpgradeable is IERC721ReceiverUpgradeable {\\r\\n    /**\\r\\n     * @dev See {IERC721Receiver-onERC721Received}.\\r\\n     *\\r\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\r\\n     */\\r\\n    function onERC721Received(\\r\\n        address,\\r\\n        address,\\r\\n        uint256,\\r\\n        bytes memory\\r\\n    ) public virtual override returns (bytes4) {\\r\\n        return this.onERC721Received.selector;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"nftx/token/IERC1155ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../interface/IERC165Upgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev _Available since v3.1._\\r\\n */\\r\\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\\r\\n\\r\\n    /**\\r\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\r\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\r\\n        To accept the transfer, this must return\\r\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\r\\n        (i.e. 0xf23a6e61, or its own function selector).\\r\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\r\\n        @param from The address which previously owned the token\\r\\n        @param id The ID of the token being transferred\\r\\n        @param value The amount of tokens being transferred\\r\\n        @param data Additional data with no specified format\\r\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\r\\n    */\\r\\n    function onERC1155Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 id,\\r\\n        uint256 value,\\r\\n        bytes calldata data\\r\\n    )\\r\\n        external\\r\\n        returns(bytes4);\\r\\n\\r\\n    /**\\r\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\r\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\r\\n        been updated. To accept the transfer(s), this must return\\r\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\r\\n        (i.e. 0xbc197c81, or its own function selector).\\r\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\r\\n        @param from The address which previously owned the token\\r\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\r\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\r\\n        @param data Additional data with no specified format\\r\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\r\\n    */\\r\\n    function onERC1155BatchReceived(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata values,\\r\\n        bytes calldata data\\r\\n    )\\r\\n        external\\r\\n        returns(bytes4);\\r\\n}\\r\\n\"\r\n    },\r\n    \"nftx/util/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"nftx/interface/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"nftx/token/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title ERC721 token receiver interface\\r\\n * @dev Interface for any contract that wants to support safeTransfers\\r\\n * from ERC721 asset contracts.\\r\\n */\\r\\ninterface IERC721ReceiverUpgradeable {\\r\\n    /**\\r\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\r\\n     * by `operator` from `from`, this function is called.\\r\\n     *\\r\\n     * It must return its Solidity selector to confirm the token transfer.\\r\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\r\\n     *\\r\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\r\\n     */\\r\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\r\\n}\\r\\n\"\r\n    },\r\n    \"nftx/util/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"nftx/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n// solhint-disable-next-line compiler-version\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\r\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\r\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\r\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\r\\n *\\r\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\r\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\r\\n *\\r\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\r\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\r\\n */\\r\\nabstract contract Initializable {\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates that the contract has been initialized.\\r\\n     */\\r\\n    bool private _initialized;\\r\\n\\r\\n    /**\\r\\n     * @dev Indicates that the contract is in the process of being initialized.\\r\\n     */\\r\\n    bool private _initializing;\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\r\\n     */\\r\\n    modifier initializer() {\\r\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\r\\n\\r\\n        bool isTopLevelCall = !_initializing;\\r\\n        if (isTopLevelCall) {\\r\\n            _initializing = true;\\r\\n            _initialized = true;\\r\\n        }\\r\\n\\r\\n        _;\\r\\n\\r\\n        if (isTopLevelCall) {\\r\\n            _initializing = false;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"prb-math/contracts/PRBMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\n/// @notice Emitted when the result overflows uint256.\\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\\n\\n/// @notice Emitted when the result overflows uint256.\\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\\n\\n/// @notice Emitted when one of the inputs is type(int256).min.\\nerror PRBMath__MulDivSignedInputTooSmall();\\n\\n/// @notice Emitted when the intermediary absolute result overflows int256.\\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is MIN_SD59x18.\\nerror PRBMathSD59x18__AbsInputTooSmall();\\n\\n/// @notice Emitted when ceiling a number overflows SD59x18.\\nerror PRBMathSD59x18__CeilOverflow(int256 x);\\n\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\nerror PRBMathSD59x18__DivInputTooSmall();\\n\\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\\n\\n/// @notice Emitted when the input is greater than 192.\\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\\n\\n/// @notice Emitted when flooring a number underflows SD59x18.\\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\\n\\n/// @notice Emitted when the product of the inputs is negative.\\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\\n\\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\\n\\n/// @notice Emitted when the input is less than or equal to zero.\\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\\n\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\nerror PRBMathSD59x18__MulInputTooSmall();\\n\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is negative.\\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\\n\\n/// @notice Emitted when the calculating the square root overflows SD59x18.\\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\\n\\n/// @notice Emitted when addition overflows UD60x18.\\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when ceiling a number overflows UD60x18.\\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\\n\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\\n\\n/// @notice Emitted when the input is greater than 192.\\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\\n\\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when the input is less than 1.\\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\\n\\n/// @notice Emitted when the calculating the square root overflows UD60x18.\\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\\n\\n/// @notice Emitted when subtraction underflows UD60x18.\\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\\n\\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\\nlibrary PRBMath {\\n    /// STRUCTS ///\\n\\n    struct SD59x18 {\\n        int256 value;\\n    }\\n\\n    struct UD60x18 {\\n        uint256 value;\\n    }\\n\\n    /// STORAGE ///\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @dev Largest power of two divisor of SCALE.\\n    uint256 internal constant SCALE_LPOTD = 262144;\\n\\n    /// @dev SCALE inverted mod 2^256.\\n    uint256 internal constant SCALE_INVERSE =\\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\\n\\n    /// FUNCTIONS ///\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    /// @dev Has to use 192.64-bit fixed-point numbers.\\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // Start from 0.5 in the 192.64-bit fixed-point format.\\n            result = 0x800000000000000000000000000000000000000000000000;\\n\\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\\n            if (x & 0x8000000000000000 > 0) {\\n                result = (result * 0x16A09E667F3BCC909) >> 64;\\n            }\\n            if (x & 0x4000000000000000 > 0) {\\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\\n            }\\n            if (x & 0x2000000000000000 > 0) {\\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\\n            }\\n            if (x & 0x1000000000000000 > 0) {\\n                result = (result * 0x10B5586CF9890F62A) >> 64;\\n            }\\n            if (x & 0x800000000000000 > 0) {\\n                result = (result * 0x1059B0D31585743AE) >> 64;\\n            }\\n            if (x & 0x400000000000000 > 0) {\\n                result = (result * 0x102C9A3E778060EE7) >> 64;\\n            }\\n            if (x & 0x200000000000000 > 0) {\\n                result = (result * 0x10163DA9FB33356D8) >> 64;\\n            }\\n            if (x & 0x100000000000000 > 0) {\\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\\n            }\\n            if (x & 0x80000000000000 > 0) {\\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\\n            }\\n            if (x & 0x40000000000000 > 0) {\\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\\n            }\\n            if (x & 0x20000000000000 > 0) {\\n                result = (result * 0x100162F3904051FA1) >> 64;\\n            }\\n            if (x & 0x10000000000000 > 0) {\\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\\n            }\\n            if (x & 0x8000000000000 > 0) {\\n                result = (result * 0x100058BA01FB9F96D) >> 64;\\n            }\\n            if (x & 0x4000000000000 > 0) {\\n                result = (result * 0x10002C5CC37DA9492) >> 64;\\n            }\\n            if (x & 0x2000000000000 > 0) {\\n                result = (result * 0x1000162E525EE0547) >> 64;\\n            }\\n            if (x & 0x1000000000000 > 0) {\\n                result = (result * 0x10000B17255775C04) >> 64;\\n            }\\n            if (x & 0x800000000000 > 0) {\\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\\n            }\\n            if (x & 0x400000000000 > 0) {\\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\\n            }\\n            if (x & 0x200000000000 > 0) {\\n                result = (result * 0x10000162E43F4F831) >> 64;\\n            }\\n            if (x & 0x100000000000 > 0) {\\n                result = (result * 0x100000B1721BCFC9A) >> 64;\\n            }\\n            if (x & 0x80000000000 > 0) {\\n                result = (result * 0x10000058B90CF1E6E) >> 64;\\n            }\\n            if (x & 0x40000000000 > 0) {\\n                result = (result * 0x1000002C5C863B73F) >> 64;\\n            }\\n            if (x & 0x20000000000 > 0) {\\n                result = (result * 0x100000162E430E5A2) >> 64;\\n            }\\n            if (x & 0x10000000000 > 0) {\\n                result = (result * 0x1000000B172183551) >> 64;\\n            }\\n            if (x & 0x8000000000 > 0) {\\n                result = (result * 0x100000058B90C0B49) >> 64;\\n            }\\n            if (x & 0x4000000000 > 0) {\\n                result = (result * 0x10000002C5C8601CC) >> 64;\\n            }\\n            if (x & 0x2000000000 > 0) {\\n                result = (result * 0x1000000162E42FFF0) >> 64;\\n            }\\n            if (x & 0x1000000000 > 0) {\\n                result = (result * 0x10000000B17217FBB) >> 64;\\n            }\\n            if (x & 0x800000000 > 0) {\\n                result = (result * 0x1000000058B90BFCE) >> 64;\\n            }\\n            if (x & 0x400000000 > 0) {\\n                result = (result * 0x100000002C5C85FE3) >> 64;\\n            }\\n            if (x & 0x200000000 > 0) {\\n                result = (result * 0x10000000162E42FF1) >> 64;\\n            }\\n            if (x & 0x100000000 > 0) {\\n                result = (result * 0x100000000B17217F8) >> 64;\\n            }\\n            if (x & 0x80000000 > 0) {\\n                result = (result * 0x10000000058B90BFC) >> 64;\\n            }\\n            if (x & 0x40000000 > 0) {\\n                result = (result * 0x1000000002C5C85FE) >> 64;\\n            }\\n            if (x & 0x20000000 > 0) {\\n                result = (result * 0x100000000162E42FF) >> 64;\\n            }\\n            if (x & 0x10000000 > 0) {\\n                result = (result * 0x1000000000B17217F) >> 64;\\n            }\\n            if (x & 0x8000000 > 0) {\\n                result = (result * 0x100000000058B90C0) >> 64;\\n            }\\n            if (x & 0x4000000 > 0) {\\n                result = (result * 0x10000000002C5C860) >> 64;\\n            }\\n            if (x & 0x2000000 > 0) {\\n                result = (result * 0x1000000000162E430) >> 64;\\n            }\\n            if (x & 0x1000000 > 0) {\\n                result = (result * 0x10000000000B17218) >> 64;\\n            }\\n            if (x & 0x800000 > 0) {\\n                result = (result * 0x1000000000058B90C) >> 64;\\n            }\\n            if (x & 0x400000 > 0) {\\n                result = (result * 0x100000000002C5C86) >> 64;\\n            }\\n            if (x & 0x200000 > 0) {\\n                result = (result * 0x10000000000162E43) >> 64;\\n            }\\n            if (x & 0x100000 > 0) {\\n                result = (result * 0x100000000000B1721) >> 64;\\n            }\\n            if (x & 0x80000 > 0) {\\n                result = (result * 0x10000000000058B91) >> 64;\\n            }\\n            if (x & 0x40000 > 0) {\\n                result = (result * 0x1000000000002C5C8) >> 64;\\n            }\\n            if (x & 0x20000 > 0) {\\n                result = (result * 0x100000000000162E4) >> 64;\\n            }\\n            if (x & 0x10000 > 0) {\\n                result = (result * 0x1000000000000B172) >> 64;\\n            }\\n            if (x & 0x8000 > 0) {\\n                result = (result * 0x100000000000058B9) >> 64;\\n            }\\n            if (x & 0x4000 > 0) {\\n                result = (result * 0x10000000000002C5D) >> 64;\\n            }\\n            if (x & 0x2000 > 0) {\\n                result = (result * 0x1000000000000162E) >> 64;\\n            }\\n            if (x & 0x1000 > 0) {\\n                result = (result * 0x10000000000000B17) >> 64;\\n            }\\n            if (x & 0x800 > 0) {\\n                result = (result * 0x1000000000000058C) >> 64;\\n            }\\n            if (x & 0x400 > 0) {\\n                result = (result * 0x100000000000002C6) >> 64;\\n            }\\n            if (x & 0x200 > 0) {\\n                result = (result * 0x10000000000000163) >> 64;\\n            }\\n            if (x & 0x100 > 0) {\\n                result = (result * 0x100000000000000B1) >> 64;\\n            }\\n            if (x & 0x80 > 0) {\\n                result = (result * 0x10000000000000059) >> 64;\\n            }\\n            if (x & 0x40 > 0) {\\n                result = (result * 0x1000000000000002C) >> 64;\\n            }\\n            if (x & 0x20 > 0) {\\n                result = (result * 0x10000000000000016) >> 64;\\n            }\\n            if (x & 0x10 > 0) {\\n                result = (result * 0x1000000000000000B) >> 64;\\n            }\\n            if (x & 0x8 > 0) {\\n                result = (result * 0x10000000000000006) >> 64;\\n            }\\n            if (x & 0x4 > 0) {\\n                result = (result * 0x10000000000000003) >> 64;\\n            }\\n            if (x & 0x2 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n            if (x & 0x1 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n\\n            // We're doing two things at the same time:\\n            //\\n            //   1. Multiply the result by 2^n + 1, where \\\"2^n\\\" is the integer part and the one is added to account for\\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\\n            //      rather than 192.\\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\\n            //\\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \\\"ip\\\" is the integer part \\\"2^n\\\".\\n            result *= SCALE;\\n            result >>= (191 - (x >> 64));\\n        }\\n    }\\n\\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n    /// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n    /// @param x The uint256 number for which to find the index of the most significant bit.\\n    /// @return msb The index of the most significant bit as an uint256.\\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n        if (x >= 2**128) {\\n            x >>= 128;\\n            msb += 128;\\n        }\\n        if (x >= 2**64) {\\n            x >>= 64;\\n            msb += 64;\\n        }\\n        if (x >= 2**32) {\\n            x >>= 32;\\n            msb += 32;\\n        }\\n        if (x >= 2**16) {\\n            x >>= 16;\\n            msb += 16;\\n        }\\n        if (x >= 2**8) {\\n            x >>= 8;\\n            msb += 8;\\n        }\\n        if (x >= 2**4) {\\n            x >>= 4;\\n            msb += 4;\\n        }\\n        if (x >= 2**2) {\\n            x >>= 2;\\n            msb += 2;\\n        }\\n        if (x >= 2**1) {\\n            // No need to shift x any more.\\n            msb += 1;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision.\\n    ///\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The multiplicand as an uint256.\\n    /// @param y The multiplier as an uint256.\\n    /// @param denominator The divisor as an uint256.\\n    /// @return result The result as an uint256.\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2^256 + prod0.\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division.\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = prod0 / denominator;\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n        if (prod1 >= denominator) {\\n            revert PRBMath__MulDivOverflow(prod1, denominator);\\n        }\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0].\\n        uint256 remainder;\\n        assembly {\\n            // Compute remainder using mulmod.\\n            remainder := mulmod(x, y, denominator)\\n\\n            // Subtract 256 bit number from 512 bit number.\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n        // See https://cs.stackexchange.com/q/138556/92363.\\n        unchecked {\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 lpotdod = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by lpotdod.\\n                denominator := div(denominator, lpotdod)\\n\\n                // Divide [prod1 prod0] by lpotdod.\\n                prod0 := div(prod0, lpotdod)\\n\\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * lpotdod;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\u00f71e18) with full precision.\\n    ///\\n    /// @dev Variant of \\\"mulDiv\\\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\\n    /// being rounded to 1e-18.  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717.\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - The body is purposely left uncommented; see the NatSpec comments in \\\"PRBMath.mulDiv\\\" to understand how this works.\\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\\n    ///     1. x * y = type(uint256).max * SCALE\\n    ///     2. (x * y) % SCALE >= SCALE / 2\\n    ///\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        uint256 prod0;\\n        uint256 prod1;\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        if (prod1 >= SCALE) {\\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\\n        }\\n\\n        uint256 remainder;\\n        uint256 roundUpUnit;\\n        assembly {\\n            remainder := mulmod(x, y, SCALE)\\n            roundUpUnit := gt(remainder, 499999999999999999)\\n        }\\n\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = (prod0 / SCALE) + roundUpUnit;\\n                return result;\\n            }\\n        }\\n\\n        assembly {\\n            result := add(\\n                mul(\\n                    or(\\n                        div(sub(prod0, remainder), SCALE_LPOTD),\\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\\n                    ),\\n                    SCALE_INVERSE\\n                ),\\n                roundUpUnit\\n            )\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision.\\n    ///\\n    /// @dev An extension of \\\"mulDiv\\\" for signed numbers. Works by computing the signs and the absolute values separately.\\n    ///\\n    /// Requirements:\\n    /// - None of the inputs can be type(int256).min.\\n    /// - The result must fit within int256.\\n    ///\\n    /// @param x The multiplicand as an int256.\\n    /// @param y The multiplier as an int256.\\n    /// @param denominator The divisor as an int256.\\n    /// @return result The result as an int256.\\n    function mulDivSigned(\\n        int256 x,\\n        int256 y,\\n        int256 denominator\\n    ) internal pure returns (int256 result) {\\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\\n            revert PRBMath__MulDivSignedInputTooSmall();\\n        }\\n\\n        // Get hold of the absolute values of x, y and the denominator.\\n        uint256 ax;\\n        uint256 ay;\\n        uint256 ad;\\n        unchecked {\\n            ax = x < 0 ? uint256(-x) : uint256(x);\\n            ay = y < 0 ? uint256(-y) : uint256(y);\\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\\n        }\\n\\n        // Compute the absolute value of (x*y)\u00f7denominator. The result must fit within int256.\\n        uint256 rAbs = mulDiv(ax, ay, ad);\\n        if (rAbs > uint256(type(int256).max)) {\\n            revert PRBMath__MulDivSignedOverflow(rAbs);\\n        }\\n\\n        // Get the signs of x, y and the denominator.\\n        uint256 sx;\\n        uint256 sy;\\n        uint256 sd;\\n        assembly {\\n            sx := sgt(x, sub(0, 1))\\n            sy := sgt(y, sub(0, 1))\\n            sd := sgt(denominator, sub(0, 1))\\n        }\\n\\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\\n        // If yes, the result should be negative.\\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The uint256 number for which to calculate the square root.\\n    /// @return result The result as an uint256.\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Set the initial guess to the closest power of two that is higher than x.\\n        uint256 xAux = uint256(x);\\n        result = 1;\\n        if (xAux >= 0x100000000000000000000000000000000) {\\n            xAux >>= 128;\\n            result <<= 64;\\n        }\\n        if (xAux >= 0x10000000000000000) {\\n            xAux >>= 64;\\n            result <<= 32;\\n        }\\n        if (xAux >= 0x100000000) {\\n            xAux >>= 32;\\n            result <<= 16;\\n        }\\n        if (xAux >= 0x10000) {\\n            xAux >>= 16;\\n            result <<= 8;\\n        }\\n        if (xAux >= 0x100) {\\n            xAux >>= 8;\\n            result <<= 4;\\n        }\\n        if (xAux >= 0x10) {\\n            xAux >>= 4;\\n            result <<= 2;\\n        }\\n        if (xAux >= 0x8) {\\n            result <<= 1;\\n        }\\n\\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\\n        unchecked {\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1; // Seven iterations should be enough\\n            uint256 roundedDownResult = x / result;\\n            return result >= roundedDownResult ? roundedDownResult : result;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_NFTXVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_NFTXLPStaking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_NFTXRewardDistributionToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sushiRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_SLPToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_RTRewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_RTStakedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_periodicReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prod1\",\"type\":\"uint256\"}],\"name\":\"PRBMath__MulDivFixedPointOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prod1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"PRBMath__MulDivOverflow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_weth\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NFTXLPStaking\",\"outputs\":[{\"internalType\":\"contract INFTXLPStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFTXRewardDistributionToken\",\"outputs\":[{\"internalType\":\"contract IRewardDistributionToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFTXVault\",\"outputs\":[{\"internalType\":\"contract INFTXVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RTRewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RTStakedToken\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SLPToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minWethIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_wethIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addLiquidityERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minWethIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addLiquidityERC20ETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minWethIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_wethIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"addLiquidityERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minWethIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"addLiquidityERC721ETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"dividendOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"RTRewardToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"NFTXRewardToken\",\"type\":\"uint256\"}],\"internalType\":\"struct xRooStaking.Dividend\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockRTRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"lockedUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodicReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountWETHMin\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_locked\",\"type\":\"bool\"}],\"name\":\"setLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockTime\",\"type\":\"uint256\"}],\"name\":\"setLockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setRTRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router01\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_NFTXVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_NFTXLPStaking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_NFTXRewardDistributionToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sushiRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_SLPToken\",\"type\":\"address\"}],\"name\":\"updateExternalReferences\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"RTRewardModifier\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"NFTXRewardModifier\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"NFTXRewardWithdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "xRooStaking", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "0000000000000000000000002034437801b62ede275210f76e2d4e77d0198bff000000000000000000000000688c3e4658b5367da06fd629e41879beab538e37000000000000000000000000270a76ea7c3505c7203ca5ebfc4eca4299ead71c000000000000000000000000d9e1ce17f2641f24ae83637ab66a2cca9c378b9f000000000000000000000000b2dfbe49eb63bcc93f0ded83ae59291f7ecb9ad50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000928f072c009727fbad81bbf3aaa885f9fea65fcf0000000000000000000000000000000000000000000000000000000000093a800000000000000000000000000000000000000000000000008ac7230489e80000000000000000000000000000000000000000000000000000000000000002a300", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}