{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/NFTmulMint001.sol\r\n\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC721Receiver} interface.\r\n *\r\n * Accepts all token transfers.\r\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\r\n */\r\ncontract ERC721Holder is IERC721Receiver {\r\n    /**\r\n     * @dev See {IERC721Receiver-onERC721Received}.\r\n     *\r\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n// File: contracts/NftMultMint.sol\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2022-05-25\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2022-05-25\r\n*/\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\r\n *\r\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\r\n * stuck.\r\n *\r\n * @dev _Available since v3.1._\r\n */\r\ncontract ERC1155Holder is ERC1155Receiver {\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n\r\n// File: contracts/aiNFT.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////\r\n\r\n\r\ninterface mintNFT{\r\n      function mint(\r\n        uint256 _category,\r\n        bytes memory _data,\r\n        bytes memory _signature\r\n    ) external ;\r\n}\r\n\r\n\r\ninterface transNFT{\r\n      function safeBatchTransferFrom(\r\n       address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) external ;\r\n}\r\n\r\n\r\n\r\n\r\n \r\n\r\ncontract NaiveHodler {}\r\n\r\n\r\n//////////////////////////////////////////\r\n//\u666e\u901aNFT\u6279\u91cfmint\r\ninterface nftTotalSupply {\r\n      function totalSupply() external view returns (uint256);\r\n}\r\n\r\ninterface mintZerionNFT{\r\n      function mint() external ;\r\n}\r\n\r\ninterface passNFT{\r\n      function safeTransferFrom(address from, address to, uint256 tokenId) external ;\r\n}\r\n\r\n\r\n\r\ncontract CommonClaimer   is   ERC1155Holder   , ERC721Holder{\r\n\r\n         // \u5b9a\u4e49\u4e8b\u4ef6\r\n    event adressEvent(uint256 indexed tokenId);\r\n    address public contra ;\r\n    constructor(address codntrAddress){\r\n        contra = codntrAddress;\r\n    }\r\n\r\n    function mint() public{\r\n        uint256  tokenId = nftTotalSupply(contra).totalSupply();\r\n        mintZerionNFT(contra).mint();\r\n        //uint256 tokenId =  totalSupply ;\r\n          emit adressEvent(tokenId);\r\n        passNFT(contra).safeTransferFrom( address(this),  address(tx.origin),tokenId);\r\n        selfdestruct(payable(address(msg.sender)));\r\n     }\r\n\r\n\r\n\r\n     function multMint(uint times ) public{\r\n        for(uint i=0;i<times;i++){\r\n            uint256  tokenId = nftTotalSupply(contra).totalSupply();\r\n            mintZerionNFT(contra).mint();\r\n           // uint256 tokenId =  totalSupply ;\r\n              emit adressEvent(tokenId);\r\n            passNFT(contra).safeTransferFrom( address(this),  address(tx.origin),tokenId);\r\n        }\r\n        selfdestruct(payable(address(msg.sender)));\r\n     }\r\n     \r\n\r\n}\r\n/////////////////////////////////////////////////\r\n\r\ncontract Claims  is   ERC1155Holder{\r\n      \r\n\r\n     // \u5b9a\u4e49\u4e8b\u4ef6\r\n    event adressEvent(address indexed originOp, address indexed sender,address indexed myaddress);\r\n\r\n\r\n    uint public countNumber ;\r\n\r\n\r\n       uint256[] public ids =     [1,2,3,4,5,6,7,8,9];\r\n        uint256[]  public amounts = [1,1,1,1,1,1,1,1,1];\r\n        //  uint256[] public ids =     [1];\r\n        // uint256[]  public amounts = [1];\r\n        bytes public  data =\"0x\";\r\n  \r\n    constructor(uint num){\r\n          // \u89e6\u53d1\u4e8b\u4ef6\r\n        emit adressEvent(tx.origin, msg.sender,  address(this));\r\n        countNumber = num ;\r\n    } \r\n\r\n   // function doMint(address  contra ,bytes[] memory datas, bytes[] memory signatures) public  {\r\n   function doMint(address  contra , bytes[] memory signatures) public  {\r\n        mintNFT(contra).mint(1, data, signatures[0] ) ;\r\n        mintNFT(contra).mint(2,data, signatures[1] ) ;\r\n        mintNFT(contra).mint(3,data, signatures[2] ) ;\r\n        mintNFT(contra).mint(4,data, signatures[3] ) ;\r\n        mintNFT(contra).mint(5,data, signatures[4] ) ;\r\n        mintNFT(contra).mint(6,data, signatures[5] ) ;\r\n        mintNFT(contra).mint(7,data, signatures[6] ) ;\r\n        mintNFT(contra).mint(8,data, signatures[7] ) ;\r\n        mintNFT(contra).mint(9,data, signatures[8] ) ;\r\n\r\n        transNFT(contra).safeBatchTransferFrom( \r\n           address(this), \r\n           address(tx.origin) ,\r\n           ids,\r\n           amounts,\r\n           data\r\n        );\r\n        selfdestruct(payable(address(tx.origin)));\r\n    }\r\n\r\n\r\n}\r\n\r\ncontract  NftMultiClaimForTest  is Ownable{\r\n\r\n    uint256  public PRICE = 0.00001 ether;\r\n\r\n    address constant contra = address(0xFD43D1dA000558473822302e1d44D81dA2e4cC0d);\r\n  //  address constant nftContra = address(0xFD43D1dA000558473822302e1d44D81dA2e4cC0d);//\u4e3b\u7f51\u5408\u7ea6\r\n  // address constant nftContra = address(0xc169B28d3eA128ACe729fb7E7C27f6Ec0a95f549);//ROPSTEN\u6d4b\u8bd5\u7f51\r\n\r\n    //address constant contra = address(0x951331F36F27ebe99c1008AF68dC11D5A802E340);//RK \u6d4b\u8bd5\r\n\r\n    //  address public nowAdr;\r\n    //  address public prenowAdr;\r\n\r\n    struct Record {\r\n       uint countNumber;\r\n      // bytes[]  data;\r\n       bytes[]  signature;\r\n    }\r\n\r\n\r\n   //\u5355\u4e2a\u94b1\u5305mint\r\n   // function singleMint(bytes32 salt,uint countNumber,  bytes[] memory _data, bytes[] memory _signature) public  {\r\n   function singleMint(bytes32 salt,uint countNumber,  bytes[] memory _signature) public  {\r\n          // bytes32 mintsalt =0x1;\r\n           Claims claims = new Claims{salt: salt}(countNumber);\r\n           claims.doMint(  contra ,  _signature) ;\r\n           // claims.doMint(  contra , _data,  _signature) ;\r\n   } \r\n\r\n     //duo\u4e2a\u94b1\u5305mint\r\n   function mulMint(bytes32 salt,  Record[] memory records) public  {\r\n           // bytes32 mintsalt =0x1;\r\n         for(uint i= 0;i<records.length ;i++ ){\r\n              Record memory record =  records[i];\r\n              uint countNumber = record.countNumber;\r\n             // bytes[]  memory data = record.data;\r\n               bytes[]  memory signature = record.signature;\r\n             Claims claims = new Claims{salt: salt}(countNumber);\r\n            // claims.doMint(  contra , data,  signature) ;\r\n              claims.doMint(  contra ,  signature) ;\r\n         }\r\n       \r\n   } \r\n\r\n    function getAddress(bytes32 salt,uint arg) public view returns (address) {\r\n         address predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(\r\n            bytes1(0xff),\r\n            address(this),\r\n            salt,\r\n            keccak256(abi.encodePacked(\r\n                type(Claims).creationCode,\r\n                arg\r\n            ))\r\n        )))));\r\n        return predictedAddress;\r\n    }\r\n\r\n\r\n\r\n     function updatePrice(uint256 price)   external onlyOwner{\r\n        PRICE = price;\r\n     }\r\n\r\n\r\n\r\n    //\u666e\u901amint\u65b9\u6cd5\r\n    address constant zerionContra = address(0x932261f9Fc8DA46C4a22e31B45c4De60623848bF);\r\n    //address constant zerionContra = address(0x932261f9Fc8DA46C4a22e31B45c4De60623848bF);//\u4e3b\u7f51  \r\n\r\n    //address constant zerionContra = address(0xB86cBC82Ae295DfF283bA5998Ae6B53782f70513);//\u6d4b\u8bd5\u7f51\r\n\r\n    //RK   0xB86cBC82Ae295DfF283bA5998Ae6B53782f70513\r\n    function  zerionCall(uint times) public {\r\n        for(uint i=0;i<times;i++){\r\n              CommonClaimer comClaims = new CommonClaimer(zerionContra);\r\n              comClaims.mint() ;\r\n        }\r\n    }\r\n\r\n     function zerionSingleMultMint(uint times) public  payable{\r\n        require(msg.value >= times * PRICE, \"wrong price\");  \r\n         CommonClaimer comClaims = new CommonClaimer(zerionContra);\r\n            comClaims.multMint(times) ;\r\n        //payable(owner()).transfer(fee);\r\n\t   payable(owner()).transfer(address(this).balance);\r\n     }\r\n\r\n    function commonCall(uint times ,address cAdress) public  payable {\r\n         require(msg.value >= times * PRICE, \"wrong price\");  \r\n        for(uint i=0;i<times;i++){\r\n            CommonClaimer comClaims = new CommonClaimer(cAdress);\r\n              comClaims.mint() ;\r\n        }\r\n         payable(owner()).transfer(address(this).balance);\r\n    }\r\n\r\n\r\n     function commonSingleMultMint(uint times ,address cAdress) public  payable{\r\n         require(msg.value >= times * PRICE, \"wrong price\");  \r\n         payable(owner()).transfer(address(this).balance);\r\n           CommonClaimer comClaims = new CommonClaimer(cAdress);\r\n            comClaims.multMint(times) ;\r\n     }\r\n   \r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"cAdress\",\"type\":\"address\"}],\"name\":\"commonCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"cAdress\",\"type\":\"address\"}],\"name\":\"commonSingleMultMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"arg\",\"type\":\"uint256\"}],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"countNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"signature\",\"type\":\"bytes[]\"}],\"internalType\":\"struct NftMultiClaimForTest.Record[]\",\"name\":\"records\",\"type\":\"tuple[]\"}],\"name\":\"mulMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"countNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"_signature\",\"type\":\"bytes[]\"}],\"name\":\"singleMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"updatePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"}],\"name\":\"zerionCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"}],\"name\":\"zerionSingleMultMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "NftMultiClaimForTest", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://68bdbc8188ea64f7694b6c503ac47da93ddf2f2bc23932557add72093c4d47b7"}]}