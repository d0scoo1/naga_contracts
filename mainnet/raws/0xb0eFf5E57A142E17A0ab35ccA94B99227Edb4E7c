{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/allocators/AaveAllocatorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.10;\\n\\n// types\\nimport \\\"../types/BaseAllocator.sol\\\";\\n\\ninterface ILendingPool {\\n    function deposit(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external;\\n\\n    function withdraw(\\n        address asset,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256);\\n}\\n\\ninterface IStakedTokenIncentivesController {\\n    function claimRewards(\\n        address[] memory assets,\\n        uint256 amount,\\n        address to\\n    ) external;\\n\\n    function claimRewardsOnBehalf(\\n        address[] memory assets,\\n        uint256 amount,\\n        address user,\\n        address to\\n    ) external;\\n\\n    function getRewardsBalance(address[] memory assets, address user) external view returns (uint256);\\n}\\n\\ncontract AaveAllocatorV2 is BaseAllocator {\\n    address public constant treasury = 0x9A315BdF513367C0377FB36545857d12e85813Ef;\\n\\n    // stkAave incentive controller\\n    IStakedTokenIncentivesController public immutable incentives =\\n        IStakedTokenIncentivesController(0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5);\\n\\n    // Aave Lending Pool\\n    ILendingPool public immutable pool = ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\\n\\n    IERC20[] internal _aTokens;\\n\\n    uint16 public referralCode;\\n\\n    constructor(AllocatorInitData memory data) BaseAllocator(data) {}\\n\\n    function _update(uint256 id) internal override returns (uint128 gain, uint128 loss) {\\n        // reads\\n        uint256 tokenId = tokenIds[id];\\n        IERC20 token = _tokens[tokenId];\\n        IERC20 aToken = _aTokens[tokenId];\\n        uint256 balance = token.balanceOf(address(this));\\n\\n        // interactions\\n        if (balance > 0) {\\n            token.approve(address(pool), balance);\\n            pool.deposit(address(token), balance, address(this), referralCode);\\n        }\\n\\n        uint256 aBalance = aToken.balanceOf(address(this));\\n        uint256 last = extender.getAllocatorAllocated(id) + extender.getAllocatorPerformance(id).gain;\\n\\n        // we can do this because aToken is 1:1 with deposited\\n        if (aBalance >= last) {\\n            gain = uint128(aBalance - last);\\n        } else {\\n            loss = uint128(last - aBalance);\\n        }\\n    }\\n\\n    function deallocate(uint256[] memory amounts) public override {\\n        // checks\\n        _onlyGuardian();\\n\\n        for (uint256 i; i < amounts.length; i++) {\\n            uint256 amount = amounts[i];\\n            if (amount > 0) {\\n                IERC20 token = _tokens[i];\\n                IERC20 aToken = _aTokens[i];\\n\\n                aToken.approve(address(pool), amount);\\n                pool.withdraw(address(token), amount, address(this));\\n            }\\n        }\\n    }\\n\\n    function _deactivate(bool panic) internal override {\\n        _deallocateAll();\\n\\n        if (panic) {\\n            for (uint256 i; i < _tokens.length; i++) {\\n                IERC20 token = _tokens[i];\\n                token.transfer(treasury, token.balanceOf(address(this)));\\n            }\\n        }\\n    }\\n\\n    function _prepareMigration() internal override {}\\n\\n    function amountAllocated(uint256 id) public view override returns (uint256) {\\n        return _aTokens[tokenIds[id]].balanceOf(address(this));\\n    }\\n\\n    function rewardTokens() public pure override returns (IERC20[] memory) {\\n        IERC20[] memory empty = new IERC20[](0);\\n        return empty;\\n    }\\n\\n    function name() external pure override returns (string memory) {\\n        return \\\"AaveAllocatorV2\\\";\\n    }\\n\\n    function addToken(address token) external {\\n        _onlyGuardian();\\n        _tokens.push(IERC20(token));\\n        IERC20(token).approve(address(extender), type(uint256).max);\\n    }\\n\\n    function addAToken(address aToken) external {\\n        _onlyGuardian();\\n        _aTokens.push(IERC20(aToken));\\n        IERC20(aToken).approve(address(extender), type(uint256).max);\\n    }\\n\\n    function setReferralCode(uint16 code) external {\\n        _onlyGuardian();\\n        referralCode = code;\\n    }\\n\\n    function utilityTokens() public view override returns (IERC20[] memory) {\\n        return _aTokens;\\n    }\\n\\n    function _deallocateAll() internal {\\n        // reads\\n        uint256[] memory amounts = new uint256[](_tokens.length);\\n\\n        // interactions\\n        for (uint256 i; i < _tokens.length; i++) {\\n            amounts[i] = _aTokens[i].balanceOf(address(this));\\n        }\\n\\n        deallocate(amounts);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/types/BaseAllocator.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\n// interfaces\\nimport \\\"../interfaces/IAllocator.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\n\\n// types\\nimport \\\"../types/OlympusAccessControlledV2.sol\\\";\\n\\n// libraries\\nimport \\\"../libraries/SafeERC20.sol\\\";\\n\\nerror BaseAllocator_AllocatorNotActivated();\\nerror BaseAllocator_AllocatorNotOffline();\\nerror BaseAllocator_Migrating();\\nerror BaseAllocator_NotMigrating();\\nerror BaseAllocator_OnlyExtender(address sender);\\n\\n/**\\n * @title BaseAllocator\\n * @notice\\n *  This abstract contract serves as a template for writing new Olympus Allocators.\\n *  Many of the functionalities regarding handling of Treasury funds by the Guardian have\\n *  been delegated to the `TreasuryExtender` contract, and thus an explanation for them can be found\\n *  in `TreasuryExtender.sol`.\\n *\\n *  The main purpose of this abstract contract and the `IAllocator` interface is to provide\\n *  a unified framework for how an Allocator should behave. Below an explanation of how\\n *  we expect an Allocator to behave in general, mentioning the most important points.\\n *\\n *  Activation:\\n *   - An Allocator is first deployed with all necessary arguments.\\n *     Thereafter, each deposit is registered with the `TreasuryExtender`.\\n *     This assigns a unique id for each deposit (set of allocations) in an Allocator.\\n *   - Next, the Allocators allocation and loss limits are set via the extender function.\\n *   - Finally, the Allocator is activated by calling `activate`.\\n *\\n *  Runtime:\\n *   The Allocator is in communication with the Extender, it must inform the Extender\\n *   what the status of the tokens is which were allocated. We only care about noting down\\n *   their status in the Extender. A quick summary of the important functions on this topic:\\n *\\n *   - `update(uint256 id)` is the main function that deals with state reporting, where\\n *     `_update(uint256 id)` is the internal function to implement, which should update Allocator\\n *     internal state. `update(uint256 id)` then continues to report the Allocators state via `report`\\n *     to the extender. `_update(uint256 id)` should handle _investment_ of funds present in Contract.\\n *\\n *   - `deallocate` should handle allocated token withdrawal, preparing the tokens to be withdrawn\\n *     by the Extender. It is not necessary to handle approvals for this token, because it is automatically\\n *     approved in the constructor. For other token withdrawals, it is assumed that reward tokens will\\n *     either be sold into underlying (allocated) or that they will simply rest in the Contract, being reward tokens.\\n *     Please also check function documentation.\\n *\\n *   - `rewardTokens` and `utilityTokens` should return the above mentioned simple reward tokens for the former case,\\n *     while utility tokens should be those tokens which are continously reinvested or otherwise used by the contract\\n *     in order to accrue more rewards. A reward token can also be a utility token, but then one must prepare them\\n *     separately for withdrawal if they are to be returned to the treasury.\\n *\\n *  Migration & Deactivation:\\n *   - `prepareMigration()` together with the virtual `_prepareMigration()` sets the state of the Allocator into\\n *     MIGRATING, disabling further token deposits, enabling only withdrawals, and preparing all funds for withdrawal.\\n *\\n *   - `migrate` then executes the migration and also deactivates the Allocator.\\n *\\n *   - `deactivate` sets `status` to OFFLINE, meaning it simply deactivates the Allocator. It can be passed\\n *     a panic boolean, meaning it handles deactivation logic in `deactivate`. The Allocator panic deactivates if\\n *     this state if the loss limit is reached via `update`. The Allocator can otherwise also simply be deactivated\\n *     and funds transferred back to the Treasury.\\n *\\n *  This was a short summary of the Allocator lifecycle.\\n */\\nabstract contract BaseAllocator is OlympusAccessControlledV2, IAllocator {\\n    using SafeERC20 for IERC20;\\n\\n    // Indices which represent the ids of the deposits in the `TreasuryExtender`\\n    uint256[] internal _ids;\\n\\n    // The allocated (underlying) tokens of the Allocator\\n    IERC20[] internal _tokens;\\n\\n    // From deposit id to the token's id\\n    mapping(uint256 => uint256) public tokenIds;\\n\\n    // Allocator status: OFFLINE, ACTIVATED, MIGRATING\\n    AllocatorStatus public status;\\n\\n    // The extender with which the Allocator communicates.\\n    ITreasuryExtender public immutable extender;\\n\\n    constructor(AllocatorInitData memory data) OlympusAccessControlledV2(data.authority) {\\n        _tokens = data.tokens;\\n        extender = data.extender;\\n\\n        for (uint256 i; i < data.tokens.length; i++) {\\n            data.tokens[i].approve(address(data.extender), type(uint256).max);\\n        }\\n\\n        emit AllocatorDeployed(address(data.authority), address(data.extender));\\n    }\\n\\n    /////// MODIFIERS\\n\\n    modifier onlyExtender {\\n\\t_onlyExtender(msg.sender);\\n\\t_;\\n    }\\n\\n    modifier onlyActivated {\\n\\t_onlyActivated(status);\\n\\t_;\\n    }\\n\\n    modifier onlyOffline {\\n\\t_onlyOffline(status);\\n\\t_;\\n    }\\n\\n    modifier notMigrating {\\n\\t_notMigrating(status);\\n\\t_;\\n    }\\n\\n    modifier isMigrating {\\n\\t_isMigrating(status);\\n\\t_;\\n    }\\n\\n    /////// VIRTUAL FUNCTIONS WHICH NEED TO BE IMPLEMENTED\\n    /////// SORTED BY EXPECTED COMPLEXITY AND DEPENDENCY\\n\\n    /**\\n     * @notice\\n     *  Updates an Allocators state.\\n     * @dev\\n     *  This function should be implemented by the developer of the Allocator.\\n     *  This function should fulfill the following purposes:\\n     *   - invest token specified by deposit id\\n     *   - handle rebalancing / harvesting for token as needed\\n     *   - calculate gain / loss for token and return those values\\n     *   - handle any other necessary runtime calculations, such as fees etc.\\n     *\\n     *  In essence, this function should update the main runtime state of the Allocator\\n     *  so that everything is properly invested, harvested, accounted for.\\n     * @param id the id of the deposit in the `TreasuryExtender`\\n     */\\n    function _update(uint256 id) internal virtual returns (uint128 gain, uint128 loss);\\n\\n    /**\\n     * @notice\\n     *  Deallocates tokens, prepares tokens for return to the Treasury.\\n     * @dev\\n     *  This function should deallocate (withdraw) `amounts` of each token so that they may be withdrawn\\n     *  by the TreasuryExtender. Otherwise, this function may also prepare the withdraw if it is time-bound.\\n     * @param amounts is the amount of each of token from `_tokens` to withdraw\\n     */\\n    function deallocate(uint256[] memory amounts) public virtual;\\n\\n    /**\\n     * @notice\\n     *  Handles deactivation logic for the Allocator.\\n     */\\n    function _deactivate(bool panic) internal virtual;\\n\\n    /**\\n     * @notice\\n     *  Handles migration preparatory logic.\\n     * @dev\\n     *  Within this function, the developer should arrange the withdrawal of all assets for migration.\\n     *  A useful function, say, to be passed into this could be `deallocate` with all of the amounts,\\n     *  so with n places for n-1 utility tokens + 1 allocated token, maxed out.\\n     */\\n    function _prepareMigration() internal virtual;\\n\\n    /**\\n     * @notice\\n     *  Should estimate total amount of Allocated tokens\\n     * @dev\\n     *  The difference between this and `treasury.getAllocatorAllocated`, is that the latter is a static\\n     *  value recorded during reporting, but no data is available on _new_ amounts after reporting.\\n     *  Thus, this should take into consideration the new amounts. This can be used for say aTokens.\\n     * @param id the id of the deposit in `TreasuryExtender`\\n     */\\n    function amountAllocated(uint256 id) public view virtual returns (uint256);\\n\\n    /**\\n     * @notice\\n     *  Should return all reward token addresses\\n     */\\n    function rewardTokens() public view virtual returns (IERC20[] memory);\\n\\n    /**\\n     * @notice\\n     *  Should return all utility token addresses\\n     */\\n    function utilityTokens() public view virtual returns (IERC20[] memory);\\n\\n    /**\\n     * @notice\\n     *  Should return the Allocator name\\n     */\\n    function name() external view virtual returns (string memory);\\n\\n    /////// IMPLEMENTATION OPTIONAL\\n\\n    /**\\n     * @notice\\n     *  Should handle activation logic\\n     * @dev\\n     *  If there is a need to handle any logic during activation, this is the function you should implement it into\\n     */\\n    function _activate() internal virtual {}\\n\\n    /////// FUNCTIONS\\n\\n    /**\\n     * @notice\\n     *  Updates an Allocators state and reports to `TreasuryExtender` if necessary.\\n     * @dev\\n     *  Can only be called by the Guardian.\\n     *  Can only be called while the Allocator is activated.\\n     *\\n     *  This function should update the Allocators internal state via `_update`, which should in turn\\n     *  return the `gain` and `loss` the Allocator has sustained in underlying allocated `token` from `_tokens`\\n     *  decided by the `id`.\\n     *  Please check the docs on `_update` to see what its function should be.\\n     *\\n     *  `_lossLimitViolated` checks if the Allocators is above its loss limit and deactivates it in case\\n     *  of serious losses. The loss limit should be set to some value which is unnacceptable to be lost\\n     *  in the case of normal runtime and thus require a panic shutdown, whatever it is defined to be.\\n     *\\n     *  Lastly, the Allocator reports its state to the Extender, which handles gain, loss, allocated logic.\\n     *  The documentation on this can be found in `TreasuryExtender.sol`.\\n     * @param id the id of the deposit in `TreasuryExtender`\\n     */\\n    function update(uint256 id) external override onlyGuardian onlyActivated {\\n        // effects\\n        // handle depositing, harvesting, compounding logic inside of _update()\\n        // if gain is in allocated then gain > 0 otherwise gain == 0\\n        // we only use so we know initia\\n        // loss always in allocated\\n        (uint128 gain, uint128 loss) = _update(id);\\n\\n        if (_lossLimitViolated(id, loss)) {\\n            deactivate(true);\\n            return;\\n        }\\n\\n        // interactions\\n        // there is no interactions happening inside of report\\n        // so allocator has no state changes to make after it\\n        if (gain + loss > 0) extender.report(id, gain, loss);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Prepares the Allocator for token migration.\\n     * @dev\\n     *  This function prepares the Allocator for token migration by calling the to-be-implemented\\n     *  `_prepareMigration`, which should logically withdraw ALL allocated (1) + utility AND reward tokens\\n     *  from the contract. The ALLOCATED token and THE UTILITY TOKEN is going to be migrated, while the REWARD\\n     *  tokens can be withdrawn by the Extender to the Treasury.\\n     */\\n    function prepareMigration() external override onlyGuardian notMigrating {\\n        // effects\\n        _prepareMigration();\\n\\n        status = AllocatorStatus.MIGRATING;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Migrates the allocated and all utility tokens to the next Allocator.\\n     * @dev\\n     *  The allocated token and the utility tokens will be migrated by this function, while it is\\n     *  assumed that the reward tokens are either simply kept or already harvested into the underlying\\n     *  essentially being the edge case of this contract. This contract is also going to report to the\\n     *  Extender that a migration happened and as such it is important to follow the proper sequence of\\n     *  migrating.\\n     *\\n     *  Steps to migrate:\\n     *   - FIRST call `_prepareMigration()` to prepare funds for migration.\\n     *   - THEN deploy the new Allocator and activate it according to the normal procedure.\\n     *     NOTE: This is to be done RIGHT BEFORE migration as to avoid allocating to the wrong allocator.\\n     *   - FINALLY call migrate. This is going to migrate the funds to the LAST allocator registered.\\n     *   - Check if everything went fine.\\n     *\\n     *  End state should be that allocator amounts have been swapped for allocators, that gain + loss is netted out 0\\n     *  for original allocator, and that the new allocators gain has been set to the original allocators gain.\\n     *  We don't transfer the loss because we have the information how much was initially invested + gain,\\n     *  and the new allocator didn't cause any loss thus we don't really need to add to it.\\n     */\\n    function migrate() external override onlyGuardian isMigrating {\\n        // reads\\n        IERC20[] memory utilityTokensArray = utilityTokens();\\n        address newAllocator = extender.getAllocatorByID(extender.getTotalAllocatorCount() - 1);\\n\\tuint256 idLength = _ids.length;\\n\\tuint256 utilLength = utilityTokensArray.length;\\n\\n        // interactions\\n        for (uint256 i; i < idLength; i++) {\\n            IERC20 token = _tokens[i];\\n\\n            token.safeTransfer(newAllocator, token.balanceOf(address(this)));\\n            extender.report(_ids[i], type(uint128).max, type(uint128).max);\\n        }\\n\\n        for (uint256 i; i < utilLength; i++) {\\n            IERC20 utilityToken = utilityTokensArray[i];\\n            utilityToken.safeTransfer(newAllocator, utilityToken.balanceOf(address(this)));\\n        }\\n\\n        // turn off Allocator\\n        deactivate(false);\\n\\n        emit MigrationExecuted(newAllocator);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Activates the Allocator.\\n     * @dev\\n     *  Only the Guardian can call this.\\n     *\\n     *  Add any logic you need during activation, say interactions with Extender or something else,\\n     *  in the virtual method `_activate`.\\n     */\\n    function activate() external override onlyGuardian onlyOffline {\\n        // effects\\n        _activate();\\n        status = AllocatorStatus.ACTIVATED;\\n\\n        emit AllocatorActivated();\\n    }\\n\\n    /**\\n     * @notice\\n     *  Adds a deposit ID to the Allocator.\\n     * @dev\\n     *  Only the Extender calls this.\\n     * @param id id to add to the allocator\\n     */\\n    function addId(uint256 id) external override onlyExtender {\\n        _ids.push(id);\\n        tokenIds[id] = _ids.length - 1;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Returns all deposit IDs registered with the Allocator.\\n     * @return the deposit IDs registered\\n     */\\n    function ids() external view override returns (uint256[] memory) {\\n        return _ids;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Returns all tokens registered with the Allocator.\\n     * @return the tokens\\n     */\\n    function tokens() external view override returns (IERC20[] memory) {\\n        return _tokens;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Deactivates the Allocator.\\n     * @dev\\n     *  Only the Guardian can call this.\\n     *\\n     *  Add any logic you need during deactivation, say interactions with Extender or something else,\\n     *  in the virtual method `_deactivate`. Be careful to specifically use the internal or public function\\n     *  depending on what you need.\\n     * @param panic should panic logic be executed\\n     */\\n    function deactivate(bool panic) public override onlyGuardian {\\n        // effects\\n        _deactivate(panic);\\n        status = AllocatorStatus.OFFLINE;\\n\\n        emit AllocatorDeactivated(panic);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Getter for Allocator version.\\n     * @return Returns the Allocators version.\\n     */\\n    function version() public pure override returns (string memory) {\\n        return \\\"v2.0.0\\\";\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check if the loss limit has been violated by the Allocator.\\n     * @dev\\n     *  Called as part of `update`. The rule is that the already sustained loss + newly sustained\\n     *  has to be larger or equal to the limit to break the contract.\\n     * @param id deposit id as in `TreasuryExtender`\\n     * @param loss the amount of newly sustained loss\\n     * @return true if the the loss limit has been broken\\n     */\\n    function _lossLimitViolated(uint256 id, uint128 loss) internal returns (bool) {\\n        // read\\n        uint128 lastLoss = extender.getAllocatorPerformance(id).loss;\\n\\n        // events\\n        if ((loss + lastLoss) >= extender.getAllocatorLimits(id).loss) {\\n            emit LossLimitViolated(lastLoss, loss, amountAllocated(tokenIds[id]));\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if sender is extender.\\n     */\\n    function _onlyExtender(address sender) internal view {\\n        if (sender != address(extender)) revert BaseAllocator_OnlyExtender(sender);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if allocator is activated.\\n     */\\n    function _onlyActivated(AllocatorStatus inputStatus) internal pure {\\n        if (inputStatus != AllocatorStatus.ACTIVATED) revert BaseAllocator_AllocatorNotActivated();\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if allocator is offline.\\n     */\\n    function _onlyOffline(AllocatorStatus inputStatus) internal pure {\\n        if (inputStatus != AllocatorStatus.OFFLINE) revert BaseAllocator_AllocatorNotOffline();\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if allocator is not migrating.\\n     */\\n    function _notMigrating(AllocatorStatus inputStatus) internal pure {\\n        if (inputStatus == AllocatorStatus.MIGRATING) revert BaseAllocator_Migrating();\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if allocator is migrating.\\n     */\\n    function _isMigrating(AllocatorStatus inputStatus) internal pure {\\n        if (inputStatus != AllocatorStatus.MIGRATING) revert BaseAllocator_NotMigrating();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAllocator.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\n// interfaces\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ITreasuryExtender.sol\\\";\\nimport \\\"./IOlympusAuthority.sol\\\";\\n\\nenum AllocatorStatus {\\n    OFFLINE,\\n    ACTIVATED,\\n    MIGRATING\\n}\\n\\nstruct AllocatorInitData {\\n    IOlympusAuthority authority;\\n    ITreasuryExtender extender;\\n    IERC20[] tokens;\\n}\\n\\n/**\\n * @title Interface for the BaseAllocator\\n * @dev\\n *  These are the standard functions that an Allocator should implement. A subset of these functions\\n *  is implemented in the `BaseAllocator`. Similar to those implemented, if for some reason the developer\\n *  decides to implement a dedicated base contract, or not at all and rather a dedicated Allocator contract\\n *  without base, imitate the functionalities implemented in it.\\n */\\ninterface IAllocator {\\n    /**\\n     * @notice\\n     *  Emitted when the Allocator is deployed.\\n     */\\n    event AllocatorDeployed(address authority, address extender);\\n\\n    /**\\n     * @notice\\n     *  Emitted when the Allocator is activated.\\n     */\\n    event AllocatorActivated();\\n\\n    /**\\n     * @notice\\n     *  Emitted when the Allocator is deactivated.\\n     */\\n    event AllocatorDeactivated(bool panic);\\n\\n    /**\\n     * @notice\\n     *  Emitted when the Allocators loss limit is violated.\\n     */\\n    event LossLimitViolated(uint128 lastLoss, uint128 dloss, uint256 estimatedTotalAllocated);\\n\\n    /**\\n     * @notice\\n     *  Emitted when a Migration is executed.\\n     * @dev\\n     *  After this also `AllocatorDeactivated` should follow.\\n     */\\n    event MigrationExecuted(address allocator);\\n\\n    /**\\n     * @notice\\n     *  Emitted when Ether is received by the contract.\\n     * @dev\\n     *  Only the Guardian is able to send the ether.\\n     */\\n    event EtherReceived(uint256 amount);\\n\\n    function update(uint256 id) external;\\n\\n    function deallocate(uint256[] memory amounts) external;\\n\\n    function prepareMigration() external;\\n\\n    function migrate() external;\\n\\n    function activate() external;\\n\\n    function deactivate(bool panic) external;\\n\\n    function addId(uint256 id) external;\\n\\n    function name() external view returns (string memory);\\n\\n    function ids() external view returns (uint256[] memory);\\n\\n    function tokenIds(uint256 id) external view returns (uint256);\\n\\n    function version() external view returns (string memory);\\n\\n    function status() external view returns (AllocatorStatus);\\n\\n    function tokens() external view returns (IERC20[] memory);\\n\\n    function utilityTokens() external view returns (IERC20[] memory);\\n\\n    function rewardTokens() external view returns (IERC20[] memory);\\n\\n    function amountAllocated(uint256 id) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface ITreasury {\\n    function deposit(\\n        uint256 _amount,\\n        address _token,\\n        uint256 _profit\\n    ) external returns (uint256);\\n\\n    function withdraw(uint256 _amount, address _token) external;\\n\\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\\n\\n    function mint(address _recipient, uint256 _amount) external;\\n\\n    function manage(address _token, uint256 _amount) external;\\n\\n    function incurDebt(uint256 amount_, address token_) external;\\n\\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\\n\\n    function excessReserves() external view returns (uint256);\\n\\n    function baseSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/types/OlympusAccessControlledV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\nimport \\\"../interfaces/IOlympusAuthority.sol\\\";\\n\\nerror UNAUTHORIZED();\\nerror AUTHORITY_INITIALIZED();\\n\\n/// @dev Reasoning for this contract = modifiers literaly copy code\\n/// instead of pointing towards the logic to execute. Over many\\n/// functions this bloats contract size unnecessarily.\\n/// imho modifiers are a meme.\\nabstract contract OlympusAccessControlledV2 {\\n    /* ========== EVENTS ========== */\\n\\n    event AuthorityUpdated(IOlympusAuthority authority);\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IOlympusAuthority public authority;\\n\\n    /* ========== Constructor ========== */\\n\\n    constructor(IOlympusAuthority _authority) {\\n        authority = _authority;\\n        emit AuthorityUpdated(_authority);\\n    }\\n\\n    /* ========== \\\"MODIFIERS\\\" ========== */\\n\\n    modifier onlyGovernor {\\n\\t_onlyGovernor();\\n\\t_;\\n    }\\n\\n    modifier onlyGuardian {\\n\\t_onlyGuardian();\\n\\t_;\\n    }\\n\\n    modifier onlyPolicy {\\n\\t_onlyPolicy();\\n\\t_;\\n    }\\n\\n    modifier onlyVault {\\n\\t_onlyVault();\\n\\t_;\\n    }\\n\\n    /* ========== GOV ONLY ========== */\\n\\n    function initializeAuthority(IOlympusAuthority _newAuthority) internal {\\n        if (authority != IOlympusAuthority(address(0))) revert AUTHORITY_INITIALIZED();\\n        authority = _newAuthority;\\n        emit AuthorityUpdated(_newAuthority);\\n    }\\n\\n    function setAuthority(IOlympusAuthority _newAuthority) external {\\n        _onlyGovernor();\\n        authority = _newAuthority;\\n        emit AuthorityUpdated(_newAuthority);\\n    }\\n\\n    /* ========== INTERNAL CHECKS ========== */\\n\\n    function _onlyGovernor() internal view {\\n        if (msg.sender != authority.governor()) revert UNAUTHORIZED();\\n    }\\n\\n    function _onlyGuardian() internal view {\\n        if (msg.sender != authority.guardian()) revert UNAUTHORIZED();\\n    }\\n\\n    function _onlyPolicy() internal view {\\n        if (msg.sender != authority.policy()) revert UNAUTHORIZED();\\n    }\\n\\n    function _onlyVault() internal view {\\n        if (msg.sender != authority.vault()) revert UNAUTHORIZED();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.5;\\n\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\\n/// Taken from Solmate\\nlibrary SafeERC20 {\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        (bool success, ) = to.call{value: amount}(new bytes(0));\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasuryExtender.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\nstruct AllocatorPerformance {\\n    uint128 gain;\\n    uint128 loss;\\n}\\n\\nstruct AllocatorLimits {\\n    uint128 allocated;\\n    uint128 loss;\\n}\\n\\nstruct AllocatorHoldings {\\n    uint256 allocated;\\n}\\n\\nstruct AllocatorData {\\n    AllocatorHoldings holdings;\\n    AllocatorLimits limits;\\n    AllocatorPerformance performance;\\n}\\n\\n/**\\n * @title Interface for the TreasuryExtender\\n */\\ninterface ITreasuryExtender {\\n    /**\\n     * @notice\\n     *  Emitted when a new Deposit is registered.\\n     */\\n    event NewDepositRegistered(address allocator, address token, uint256 id);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator is funded\\n     */\\n    event AllocatorFunded(uint256 id, uint256 amount, uint256 value);\\n\\n    /**\\n     * @notice\\n     *  Emitted when allocated funds are withdrawn from an Allocator\\n     */\\n    event AllocatorWithdrawal(uint256 id, uint256 amount, uint256 value);\\n\\n    /**\\n     * @notice\\n     *  Emitted when rewards are withdrawn from an Allocator\\n     */\\n    event AllocatorRewardsWithdrawal(address allocator, uint256 amount, uint256 value);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator reports a gain\\n     */\\n    event AllocatorReportedGain(uint256 id, uint128 gain);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator reports a loss\\n     */\\n    event AllocatorReportedLoss(uint256 id, uint128 loss);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator reports a migration\\n     */\\n    event AllocatorReportedMigration(uint256 id);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator limits are modified\\n     */\\n    event AllocatorLimitsChanged(uint256 id, uint128 allocationLimit, uint128 lossLimit);\\n\\n    function registerDeposit(address newAllocator) external;\\n\\n    function setAllocatorLimits(uint256 id, AllocatorLimits memory limits) external;\\n\\n    function report(\\n        uint256 id,\\n        uint128 gain,\\n        uint128 loss\\n    ) external;\\n\\n    function requestFundsFromTreasury(uint256 id, uint256 amount) external;\\n\\n    function returnFundsToTreasury(uint256 id, uint256 amount) external;\\n\\n    function returnRewardsToTreasury(\\n        uint256 id,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    function getTotalAllocatorCount() external view returns (uint256);\\n\\n    function getAllocatorByID(uint256 id) external view returns (address);\\n\\n    function getAllocatorAllocated(uint256 id) external view returns (uint256);\\n\\n    function getAllocatorLimits(uint256 id) external view returns (AllocatorLimits memory);\\n\\n    function getAllocatorPerformance(uint256 id) external view returns (AllocatorPerformance memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOlympusAuthority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IOlympusAuthority {\\n    /* ========== EVENTS ========== */\\n\\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n\\n    event GovernorPulled(address indexed from, address indexed to);\\n    event GuardianPulled(address indexed from, address indexed to);\\n    event PolicyPulled(address indexed from, address indexed to);\\n    event VaultPulled(address indexed from, address indexed to);\\n\\n    /* ========== VIEW ========== */\\n\\n    function governor() external view returns (address);\\n\\n    function guardian() external view returns (address);\\n\\n    function policy() external view returns (address);\\n\\n    function vault() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"authority\",\"type\":\"address\"},{\"internalType\":\"contract ITreasuryExtender\",\"name\":\"extender\",\"type\":\"address\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"internalType\":\"struct AllocatorInitData\",\"name\":\"data\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BaseAllocator_AllocatorNotActivated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseAllocator_AllocatorNotOffline\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseAllocator_Migrating\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseAllocator_NotMigrating\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"BaseAllocator_OnlyExtender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UNAUTHORIZED\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AllocatorActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"panic\",\"type\":\"bool\"}],\"name\":\"AllocatorDeactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"extender\",\"type\":\"address\"}],\"name\":\"AllocatorDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IOlympusAuthority\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"lastLoss\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"dloss\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"estimatedTotalAllocated\",\"type\":\"uint256\"}],\"name\":\"LossLimitViolated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"allocator\",\"type\":\"address\"}],\"name\":\"MigrationExecuted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aToken\",\"type\":\"address\"}],\"name\":\"addAToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"addId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"amountAllocated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"panic\",\"type\":\"bool\"}],\"name\":\"deactivate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"deallocate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extender\",\"outputs\":[{\"internalType\":\"contract ITreasuryExtender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ids\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incentives\",\"outputs\":[{\"internalType\":\"contract IStakedTokenIncentivesController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract ILendingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prepareMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralCode\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"_newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"code\",\"type\":\"uint16\"}],\"name\":\"setReferralCode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"internalType\":\"enum AllocatorStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"utilityTokens\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "AaveAllocatorV2", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000200000000000000000000000001c21f8ea7e39e2ba00bc12d2968d63f4acb38b7a000000000000000000000000ed1c1ada5520f198e1284e7f0ac88a52cc66489100000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}