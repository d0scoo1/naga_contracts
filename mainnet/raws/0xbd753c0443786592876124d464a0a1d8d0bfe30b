{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: contracts/utils/Fixidity.sol\r\n\r\n\r\npragma solidity ^0.8.12;\r\n\r\n\r\n/**\r\n * @title Fixidity\r\n * @author Gadi Guy, Alberto Cuesta Canada\r\n * @notice This library provides fixed point arithmetic with protection against\r\n * overflow. \r\n * All operations are done with int256 and the operands must have been created \r\n * with any of the newFrom* functions, which shift the comma digits() to the \r\n * right and check for limits.\r\n * When using this library be sure of using maxNewFixed() as the upper limit for\r\n * creation of fixed point numbers. Use maxFixedMul(), maxFixedDiv() and\r\n * maxFixedAdd() if you want to be certain that those operations don't \r\n * overflow.\r\n */\r\nlibrary Fixidity {\r\n\r\n    /**\r\n     * @notice Number of positions that the comma is shifted to the right.\r\n     */\r\n    function digits() public pure returns(int8) {\r\n        return 24;\r\n    }\r\n    \r\n    /**\r\n     * @notice This is 1 in the fixed point units used in this library.\r\n     * @dev Test fixed1() equals 10^digits()\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function fixed1() public pure returns(int256) {\r\n        return 1000000000000000000000000;\r\n    }\r\n\r\n    /**\r\n     * @notice The amount of decimals lost on each multiplication operand.\r\n     * @dev Test mulPrecision() equals sqrt(fixed1)\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function mulPrecision() public pure returns(int256) {\r\n        return 1000000000000;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be represented in an int256\r\n     * @dev Test maxInt256() equals 2^255 -1\r\n     */\r\n    function maxInt256() public pure returns(int256) {\r\n        return 57896044618658097711785492504343953926634992332820282019728792003956564819967;\r\n    }\r\n\r\n    /**\r\n     * @notice Minimum value that can be represented in an int256\r\n     * @dev Test minInt256 equals (2^255) * (-1)\r\n     */\r\n    function minInt256() public pure returns(int256) {\r\n        return -57896044618658097711785492504343953926634992332820282019728792003956564819968;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be converted to fixed point. Optimize for\r\n     * @dev deployment. \r\n     * Test maxNewFixed() equals maxInt256() / fixed1()\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxNewFixed() public pure returns(int256) {\r\n        return 57896044618658097711785492504343953926634992332820282;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be converted to fixed point. Optimize for\r\n     * deployment. \r\n     * @dev Test minNewFixed() equals -(maxInt256()) / fixed1()\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function minNewFixed() public pure returns(int256) {\r\n        return -57896044618658097711785492504343953926634992332820282;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as an addition operator.\r\n     * @dev Test maxFixedAdd() equals maxInt256()-1 / 2\r\n     * Test add(maxFixedAdd(),maxFixedAdd()) equals maxFixedAdd() + maxFixedAdd()\r\n     * Test add(maxFixedAdd()+1,maxFixedAdd()) throws \r\n     * Test add(-maxFixedAdd(),-maxFixedAdd()) equals -maxFixedAdd() - maxFixedAdd()\r\n     * Test add(-maxFixedAdd(),-maxFixedAdd()-1) throws \r\n     */\r\n    function maxFixedAdd() public pure returns(int256) {\r\n        return 28948022309329048855892746252171976963317496166410141009864396001978282409983;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum negative value that can be safely in a subtraction.\r\n     * @dev Test maxFixedSub() equals minInt256() / 2\r\n     */\r\n    function maxFixedSub() public pure returns(int256) {\r\n        return -28948022309329048855892746252171976963317496166410141009864396001978282409984;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as a multiplication operator.\r\n     * @dev Calculated as sqrt(maxInt256()*fixed1()). \r\n     * Be careful with your sqrt() implementation. I couldn't find a calculator\r\n     * that would give the exact square root of maxInt256*fixed1 so this number\r\n     * is below the real number by no more than 3*10**28. It is safe to use as\r\n     * a limit for your multiplications, although powers of two of numbers over\r\n     * this value might still work.\r\n     * Test multiply(maxFixedMul(),maxFixedMul()) equals maxFixedMul() * maxFixedMul()\r\n     * Test multiply(maxFixedMul(),maxFixedMul()+1) throws \r\n     * Test multiply(-maxFixedMul(),maxFixedMul()) equals -maxFixedMul() * maxFixedMul()\r\n     * Test multiply(-maxFixedMul(),maxFixedMul()+1) throws \r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxFixedMul() public pure returns(int256) {\r\n        return 240615969168004498257251713877715648331380787511296;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as a dividend.\r\n     * @dev divide(maxFixedDiv,newFixedFraction(1,fixed1())) = maxInt256().\r\n     * Test maxFixedDiv() equals maxInt256()/fixed1()\r\n     * Test divide(maxFixedDiv(),multiply(mulPrecision(),mulPrecision())) = maxFixedDiv()*(10^digits())\r\n     * Test divide(maxFixedDiv()+1,multiply(mulPrecision(),mulPrecision())) throws\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxFixedDiv() public pure returns(int256) {\r\n        return 57896044618658097711785492504343953926634992332820282;\r\n    }\r\n\r\n    /**\r\n     * @notice Maximum value that can be safely used as a divisor.\r\n     * @dev Test maxFixedDivisor() equals fixed1()*fixed1() - Or 10**(digits()*2)\r\n     * Test divide(10**(digits()*2 + 1),10**(digits()*2)) = returns 10*fixed1()\r\n     * Test divide(10**(digits()*2 + 1),10**(digits()*2 + 1)) = throws\r\n     * Hardcoded to 24 digits.\r\n     */\r\n    function maxFixedDivisor() public pure returns(int256) {\r\n        return 1000000000000000000000000000000000000000000000000;\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 to fixed point units, equivalent to multiplying\r\n     * by 10^digits().\r\n     * @dev Test newFixed(0) returns 0\r\n     * Test newFixed(1) returns fixed1()\r\n     * Test newFixed(maxNewFixed()) returns maxNewFixed() * fixed1()\r\n     * Test newFixed(maxNewFixed()+1) fails\r\n     */\r\n    function newFixed(int256 x)\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        assert(x <= maxNewFixed());\r\n        assert(x >= minNewFixed());\r\n        return x * fixed1();\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 in the fixed point representation of this \r\n     * library to a non decimal. All decimal digits will be truncated.\r\n     */\r\n    function fromFixed(int256 x)\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        return x / fixed1();\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 which is already in some fixed point \r\n     * representation to a different fixed precision representation.\r\n     * Both the origin and destination precisions must be 38 or less digits.\r\n     * Origin values with a precision higher than the destination precision\r\n     * will be truncated accordingly.\r\n     * @dev \r\n     * Test convertFixed(1,0,0) returns 1;\r\n     * Test convertFixed(1,1,1) returns 1;\r\n     * Test convertFixed(1,1,0) returns 0;\r\n     * Test convertFixed(1,0,1) returns 10;\r\n     * Test convertFixed(10,1,0) returns 1;\r\n     * Test convertFixed(10,0,1) returns 100;\r\n     * Test convertFixed(100,1,0) returns 10;\r\n     * Test convertFixed(100,0,1) returns 1000;\r\n     * Test convertFixed(1000,2,0) returns 10;\r\n     * Test convertFixed(1000,0,2) returns 100000;\r\n     * Test convertFixed(1000,2,1) returns 100;\r\n     * Test convertFixed(1000,1,2) returns 10000;\r\n     * Test convertFixed(maxInt256,1,0) returns maxInt256/10;\r\n     * Test convertFixed(maxInt256,0,1) throws\r\n     * Test convertFixed(maxInt256,38,0) returns maxInt256/(10**38);\r\n     * Test convertFixed(1,0,38) returns 10**38;\r\n     * Test convertFixed(maxInt256,39,0) throws\r\n     * Test convertFixed(1,0,39) throws\r\n     */\r\n    function convertFixed(int256 x, int8 _originDigits, int8 _destinationDigits)\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        assert(_originDigits <= 38 && _destinationDigits <= 38);\r\n        \r\n        int8 decimalDifference;\r\n        if ( _originDigits > _destinationDigits ){\r\n            decimalDifference = _originDigits - _destinationDigits;\r\n            return x/(int128(10)**uint8(decimalDifference));\r\n        }\r\n        else if ( _originDigits < _destinationDigits ){\r\n            decimalDifference = _destinationDigits - _originDigits;\r\n            // Cast uint8 -> uint128 is safe\r\n            // Exponentiation is safe:\r\n            //     _originDigits and _destinationDigits limited to 38 or less\r\n            //     decimalDifference = abs(_destinationDigits - _originDigits)\r\n            //     decimalDifference < 38\r\n            //     10**38 < 2**128-1\r\n            assert(x <= maxInt256()/int128(10)**uint8(decimalDifference));\r\n            assert(x >= minInt256()/int128(10)**uint8(decimalDifference));\r\n            return x*(int128(10)**uint8(decimalDifference));\r\n        }\r\n        // _originDigits == digits()) \r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 which is already in some fixed point \r\n     * representation to that of this library. The _originDigits parameter is the\r\n     * precision of x. Values with a precision higher than FixidityLib.digits()\r\n     * will be truncated accordingly.\r\n     */\r\n    function newFixed(int256 x, int8 _originDigits)\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        return convertFixed(x, _originDigits, digits());\r\n    }\r\n\r\n    /**\r\n     * @notice Converts an int256 in the fixed point representation of this \r\n     * library to a different representation. The _destinationDigits parameter is the\r\n     * precision of the output x. Values with a precision below than \r\n     * FixidityLib.digits() will be truncated accordingly.\r\n     */\r\n    function fromFixed(int256 x, int8 _destinationDigits)\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        return convertFixed(x, digits(), _destinationDigits);\r\n    }\r\n\r\n    /**\r\n     * @notice Converts two int256 representing a fraction to fixed point units,\r\n     * equivalent to multiplying dividend and divisor by 10^digits().\r\n     * @dev \r\n     * Test newFixedFraction(maxFixedDiv()+1,1) fails\r\n     * Test newFixedFraction(1,maxFixedDiv()+1) fails\r\n     * Test newFixedFraction(1,0) fails     \r\n     * Test newFixedFraction(0,1) returns 0\r\n     * Test newFixedFraction(1,1) returns fixed1()\r\n     * Test newFixedFraction(maxFixedDiv(),1) returns maxFixedDiv()*fixed1()\r\n     * Test newFixedFraction(1,fixed1()) returns 1\r\n     * Test newFixedFraction(1,fixed1()-1) returns 0\r\n     */\r\n    function newFixedFraction(\r\n        int256 numerator, \r\n        int256 denominator\r\n        )\r\n        public\r\n        pure\r\n        returns (int256)\r\n    {\r\n        assert(numerator <= maxNewFixed());\r\n        assert(denominator <= maxNewFixed());\r\n        assert(denominator != 0);\r\n        int256 convertedNumerator = newFixed(numerator);\r\n        int256 convertedDenominator = newFixed(denominator);\r\n        return divide(convertedNumerator, convertedDenominator);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the integer part of a fixed point number.\r\n     * @dev \r\n     * Test integer(0) returns 0\r\n     * Test integer(fixed1()) returns fixed1()\r\n     * Test integer(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\r\n     * Test integer(-fixed1()) returns -fixed1()\r\n     * Test integer(newFixed(-maxNewFixed())) returns -maxNewFixed()*fixed1()\r\n     */\r\n    function integer(int256 x) public pure returns (int256) {\r\n        return (x / fixed1()) * fixed1(); // Can't overflow\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the fractional part of a fixed point number. \r\n     * In the case of a negative number the fractional is also negative.\r\n     * @dev \r\n     * Test fractional(0) returns 0\r\n     * Test fractional(fixed1()) returns 0\r\n     * Test fractional(fixed1()-1) returns 10^24-1\r\n     * Test fractional(-fixed1()) returns 0\r\n     * Test fractional(-fixed1()+1) returns -10^24-1\r\n     */\r\n    function fractional(int256 x) public pure returns (int256) {\r\n        return x - (x / fixed1()) * fixed1(); // Can't overflow\r\n    }\r\n\r\n    /**\r\n     * @notice Converts to positive if negative.\r\n     * Due to int256 having one more negative number than positive numbers \r\n     * abs(minInt256) reverts.\r\n     * @dev \r\n     * Test abs(0) returns 0\r\n     * Test abs(fixed1()) returns -fixed1()\r\n     * Test abs(-fixed1()) returns fixed1()\r\n     * Test abs(newFixed(maxNewFixed())) returns maxNewFixed()*fixed1()\r\n     * Test abs(newFixed(minNewFixed())) returns -minNewFixed()*fixed1()\r\n     */\r\n    function abs(int256 x) public pure returns (int256) {\r\n        if (x >= 0) {\r\n            return x;\r\n        } else {\r\n            int256 result = -x;\r\n            assert (result > 0);\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice x+y. If any operator is higher than maxFixedAdd() it \r\n     * might overflow.\r\n     * In solidity maxInt256 + 1 = minInt256 and viceversa.\r\n     * @dev \r\n     * Test add(maxFixedAdd(),maxFixedAdd()) returns maxInt256()-1\r\n     * Test add(maxFixedAdd()+1,maxFixedAdd()+1) fails\r\n     * Test add(-maxFixedSub(),-maxFixedSub()) returns minInt256()\r\n     * Test add(-maxFixedSub()-1,-maxFixedSub()-1) fails\r\n     * Test add(maxInt256(),maxInt256()) fails\r\n     * Test add(minInt256(),minInt256()) fails\r\n     */\r\n    function add(int256 x, int256 y) public pure returns (int256) {\r\n        int256 z = x + y;\r\n        if (x > 0 && y > 0) assert(z > x && z > y);\r\n        if (x < 0 && y < 0) assert(z < x && z < y);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n     * @notice x-y. You can use add(x,-y) instead. \r\n     * @dev Tests covered by add(x,y)\r\n     */\r\n    function subtract(int256 x, int256 y) public pure returns (int256) {\r\n        return add(x,-y);\r\n    }\r\n\r\n    /**\r\n     * @notice x*y. If any of the operators is higher than maxFixedMul() it \r\n     * might overflow.\r\n     * @dev \r\n     * Test multiply(0,0) returns 0\r\n     * Test multiply(maxFixedMul(),0) returns 0\r\n     * Test multiply(0,maxFixedMul()) returns 0\r\n     * Test multiply(maxFixedMul(),fixed1()) returns maxFixedMul()\r\n     * Test multiply(fixed1(),maxFixedMul()) returns maxFixedMul()\r\n     * Test all combinations of (2,-2), (2, 2.5), (2, -2.5) and (0.5, -0.5)\r\n     * Test multiply(fixed1()/mulPrecision(),fixed1()*mulPrecision())\r\n     * Test multiply(maxFixedMul()-1,maxFixedMul()) equals multiply(maxFixedMul(),maxFixedMul()-1)\r\n     * Test multiply(maxFixedMul(),maxFixedMul()) returns maxInt256() // Probably not to the last digits\r\n     * Test multiply(maxFixedMul()+1,maxFixedMul()) fails\r\n     * Test multiply(maxFixedMul(),maxFixedMul()+1) fails\r\n     */\r\n    function multiply(int256 x, int256 y) public pure returns (int256) {\r\n        if (x == 0 || y == 0) return 0;\r\n        if (y == fixed1()) return x;\r\n        if (x == fixed1()) return y;\r\n\r\n        // Separate into integer and fractional parts\r\n        // x = x1 + x2, y = y1 + y2\r\n        int256 x1 = integer(x) / fixed1();\r\n        int256 x2 = fractional(x);\r\n        int256 y1 = integer(y) / fixed1();\r\n        int256 y2 = fractional(y);\r\n        \r\n        // (x1 + x2) * (y1 + y2) = (x1 * y1) + (x1 * y2) + (x2 * y1) + (x2 * y2)\r\n        int256 x1y1 = x1 * y1;\r\n        if (x1 != 0) assert(x1y1 / x1 == y1); // Overflow x1y1\r\n        \r\n        // x1y1 needs to be multiplied back by fixed1\r\n        // solium-disable-next-line mixedcase\r\n        int256 fixed_x1y1 = x1y1 * fixed1();\r\n        if (x1y1 != 0) assert(fixed_x1y1 / x1y1 == fixed1()); // Overflow x1y1 * fixed1\r\n        x1y1 = fixed_x1y1;\r\n\r\n        int256 x2y1 = x2 * y1;\r\n        if (x2 != 0) assert(x2y1 / x2 == y1); // Overflow x2y1\r\n\r\n        int256 x1y2 = x1 * y2;\r\n        if (x1 != 0) assert(x1y2 / x1 == y2); // Overflow x1y2\r\n\r\n        x2 = x2 / mulPrecision();\r\n        y2 = y2 / mulPrecision();\r\n        int256 x2y2 = x2 * y2;\r\n        if (x2 != 0) assert(x2y2 / x2 == y2); // Overflow x2y2\r\n\r\n        // result = fixed1() * x1 * y1 + x1 * y2 + x2 * y1 + x2 * y2 / fixed1();\r\n        int256 result = x1y1;\r\n        result = add(result, x2y1); // Add checks for overflow\r\n        result = add(result, x1y2); // Add checks for overflow\r\n        result = add(result, x2y2); // Add checks for overflow\r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * @notice 1/x\r\n     * @dev \r\n     * Test reciprocal(0) fails\r\n     * Test reciprocal(fixed1()) returns fixed1()\r\n     * Test reciprocal(fixed1()*fixed1()) returns 1 // Testing how the fractional is truncated\r\n     * Test reciprocal(2*fixed1()*fixed1()) returns 0 // Testing how the fractional is truncated\r\n     */\r\n    function reciprocal(int256 x) public pure returns (int256) {\r\n        assert(x != 0);\r\n        return (fixed1()*fixed1()) / x; // Can't overflow\r\n    }\r\n\r\n    /**\r\n     * @notice x/y. If the dividend is higher than maxFixedDiv() it \r\n     * might overflow. You can use multiply(x,reciprocal(y)) instead.\r\n     * There is a loss of precision on division for the lower mulPrecision() decimals.\r\n     * @dev \r\n     * Test divide(fixed1(),0) fails\r\n     * Test divide(maxFixedDiv(),1) = maxFixedDiv()*(10^digits())\r\n     * Test divide(maxFixedDiv()+1,1) throws\r\n     * Test divide(maxFixedDiv(),maxFixedDiv()) returns fixed1()\r\n     */\r\n    function divide(int256 x, int256 y) public pure returns (int256) {\r\n        if (y == fixed1()) return x;\r\n        assert(y != 0);\r\n        assert(y <= maxFixedDivisor());\r\n        return multiply(x, reciprocal(y));\r\n    }\r\n}\r\n\r\n// File: contracts/Oracle.sol\r\n\r\n\r\npragma solidity ^0.8.12;\r\n\r\n/*\r\n\r\n\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\r\n\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\r\n\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551        \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2554\u255d    \u2588\u2588\u2554\u255d\r\n\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551        \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u255a\u2550\u2550\u2550\u2588\u2588\u2557   \u2588\u2588\u2554\u255d \r\n \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d   \u2588\u2588\u2551  \r\n  \u255a\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d  \r\nhttps://vetcor37.com                                                           \r\n\r\nIf you use this contract, please consider donating to support our initiatives:\r\n\r\n* Ethereum: 0xf32d4B3A52F98E0793A40609025f450Bb98f40C5\r\n* Polygon: 0xdCB281707B5Fedf0f3cD05e003F55C1E58c5cbd8\r\n* Arbitrum: 0x6D380f1949Ba2D272375F94ee689ce9BaB4F1892\r\n\r\n*/\r\n\r\n\r\n/// @custom:security-contact 0xdarni@pm.me\r\ncontract ChainlinkEurEthPriceOracle {\r\n    AggregatorV3Interface internal EurUsd;\r\n    AggregatorV3Interface internal EthUsd;\r\n\r\n    constructor() {\r\n        // EUR / USD\r\n        // https://data.chain.link/ethereum/mainnet/fiat/eur-usd\r\n        EurUsd = AggregatorV3Interface(0xb49f677943BC038e9857d61E7d053CaA2C1734C1);\r\n        // ETH / USD\r\n        // https://data.chain.link/ethereum/mainnet/crypto-usd/eth-usd\r\n        EthUsd = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\r\n\r\n    }\r\n\r\n    function getLatestPriceEthEur() public view returns (int) {\r\n        (\r\n            /*uint80 roundIDEurUsd*/,\r\n            int priceEurUsd,\r\n            /*uint startedAtEurUsd*/,\r\n            /*uint timeStampEurUsd*/,\r\n            /*uint80 answeredInRoundEurUsd*/\r\n        ) = EurUsd.latestRoundData();\r\n\r\n        (\r\n            /*uint80 roundIDEthUsd*/,\r\n            int priceEthUsd,\r\n            /*uint startedAtEthUsd*/,\r\n            /*uint timeStampEthUsd*/,\r\n            /*uint80 answeredInRoundEthUsd*/\r\n        ) = EthUsd.latestRoundData();\r\n        \r\n        int256 P1 = Fixidity.convertFixed(priceEurUsd, 8, Fixidity.digits());\r\n        int256 P2 = Fixidity.convertFixed(priceEthUsd, 8, Fixidity.digits());\r\n\r\n        return Fixidity.convertFixed(Fixidity.divide(P2, P1), 24, 8);\r\n    }\r\n\r\n    function getLatestPriceEurEth() public view returns (int) {\r\n        (\r\n            uint80 roundIDEurUsd,\r\n            int priceEurUsd,\r\n            uint startedAtEurUsd,\r\n            uint timeStampEurUsd,\r\n            uint80 answeredInRoundEurUsd\r\n        ) = EurUsd.latestRoundData();\r\n\r\n        (\r\n            uint80 roundIDEthUsd,\r\n            int priceEthUsd,\r\n            uint startedAtEthUsd,\r\n            uint timeStampEthUsd,\r\n            uint80 answeredInRoundEthUsd\r\n        ) = EthUsd.latestRoundData();\r\n\r\n        int256 P1 = Fixidity.convertFixed(priceEurUsd, 8, Fixidity.digits());\r\n        int256 P2 = Fixidity.convertFixed(priceEthUsd, 8, Fixidity.digits());\r\n\r\n        return Fixidity.convertFixed(Fixidity.divide(P1, P2), 24, 8);\r\n    }\r\n}\r\n\r\ninterface AggregatorV3Interface {\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (\r\n            uint80 roundId,\r\n            int answer,\r\n            uint startedAt,\r\n            uint updatedAt,\r\n            uint80 answeredInRound\r\n        );\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"getLatestPriceEthEur\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPriceEurEth\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ChainlinkEurEthPriceOracle", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "Fixidity:e7aad6113fd663f528e1082fd72e444732aa0f55", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://627a4ab0b1e4155f22d6e131f173322d23d6c3178a7709e53794616556f100e7"}]}