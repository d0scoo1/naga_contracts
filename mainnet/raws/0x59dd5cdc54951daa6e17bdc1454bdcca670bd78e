{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: @openzeppelin/contracts/utils/Strings.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n* @dev String operations.\r\n*/\r\nlibrary Strings {\r\nbytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n/**\r\n* @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n*/\r\nfunction toString(uint256 value) internal pure returns (string memory) {\r\n// Inspired by OraclizeAPI's implementation - MIT licence\r\n// https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\nif (value == 0) {\r\nreturn \"0\";\r\n}\r\nuint256 temp = value;\r\nuint256 digits;\r\nwhile (temp != 0) {\r\ndigits++;\r\ntemp /= 10;\r\n}\r\nbytes memory buffer = new bytes(digits);\r\nwhile (value != 0) {\r\ndigits -= 1;\r\nbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\nvalue /= 10;\r\n}\r\nreturn string(buffer);\r\n}\r\n\r\n/**\r\n* @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n*/\r\nfunction toHexString(uint256 value) internal pure returns (string memory) {\r\nif (value == 0) {\r\nreturn \"0x00\";\r\n}\r\nuint256 temp = value;\r\nuint256 length = 0;\r\nwhile (temp != 0) {\r\nlength++;\r\ntemp >>= 8;\r\n}\r\nreturn toHexString(value, length);\r\n}\r\n\r\n/**\r\n* @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n*/\r\nfunction toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\nbytes memory buffer = new bytes(2 * length + 2);\r\nbuffer[0] = \"0\";\r\nbuffer[1] = \"x\";\r\nfor (uint256 i = 2 * length + 1; i > 1; --i) {\r\nbuffer[i] = _HEX_SYMBOLS[value & 0xf];\r\nvalue >>= 4;\r\n}\r\nrequire(value == 0, \"Strings: hex length insufficient\");\r\nreturn string(buffer);\r\n}\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n* @dev Collection of functions related to the address type\r\n*/\r\nlibrary Address {\r\n/**\r\n* @dev Returns true if `account` is a contract.\r\n*\r\n* [IMPORTANT]\r\n* ====\r\n* It is unsafe to assume that an address for which this function returns\r\n* false is an externally-owned account (EOA) and not a contract.\r\n*\r\n* Among others, `isContract` will return false for the following\r\n* types of addresses:\r\n*\r\n* - an externally-owned account\r\n* - a contract in construction\r\n* - an address where a contract will be created\r\n* - an address where a contract lived, but was destroyed\r\n* ====\r\n*/\r\nfunction isContract(address account) internal view returns (bool) {\r\n// This method relies on extcodesize, which returns 0 for contracts in\r\n// construction, since the code is only stored at the end of the\r\n// constructor execution.\r\n\r\nuint256 size;\r\nassembly {\r\nsize := extcodesize(account)\r\n}\r\nreturn size > 0;\r\n}\r\n\r\n/**\r\n* @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n* `recipient`, forwarding all available gas and reverting on errors.\r\n*\r\n* https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n* of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n* imposed by `transfer`, making them unable to receive funds via\r\n* `transfer`. {sendValue} removes this limitation.\r\n*\r\n* https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n*\r\n* IMPORTANT: because control is transferred to `recipient`, care must be\r\n* taken to not create reentrancy vulnerabilities. Consider using\r\n* {ReentrancyGuard} or the\r\n* https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n*/\r\nfunction sendValue(address payable recipient, uint256 amount) internal {\r\nrequire(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n(bool success, ) = recipient.call{value: amount}(\"\");\r\nrequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n}\r\n\r\n/**\r\n* @dev Performs a Solidity function call using a low level `call`. A\r\n* plain `call` is an unsafe replacement for a function call: use this\r\n* function instead.\r\n*\r\n* If `target` reverts with a revert reason, it is bubbled up by this\r\n* function (like regular Solidity function calls).\r\n*\r\n* Returns the raw returned data. To convert to the expected return value,\r\n* use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n*\r\n* Requirements:\r\n*\r\n* - `target` must be a contract.\r\n* - calling `target` with `data` must not revert.\r\n*\r\n* _Available since v3.1._\r\n*/\r\nfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\nreturn functionCall(target, data, \"Address: low-level call failed\");\r\n}\r\n\r\n/**\r\n* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n* `errorMessage` as a fallback revert reason when `target` reverts.\r\n*\r\n* _Available since v3.1._\r\n*/\r\nfunction functionCall(\r\naddress target,\r\nbytes memory data,\r\nstring memory errorMessage\r\n) internal returns (bytes memory) {\r\nreturn functionCallWithValue(target, data, 0, errorMessage);\r\n}\r\n\r\n/**\r\n* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n* but also transferring `value` wei to `target`.\r\n*\r\n* Requirements:\r\n*\r\n* - the calling contract must have an ETH balance of at least `value`.\r\n* - the called Solidity function must be `payable`.\r\n*\r\n* _Available since v3.1._\r\n*/\r\nfunction functionCallWithValue(\r\naddress target,\r\nbytes memory data,\r\nuint256 value\r\n) internal returns (bytes memory) {\r\nreturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n}\r\n\r\n/**\r\n* @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n* with `errorMessage` as a fallback revert reason when `target` reverts.\r\n*\r\n* _Available since v3.1._\r\n*/\r\nfunction functionCallWithValue(\r\naddress target,\r\nbytes memory data,\r\nuint256 value,\r\nstring memory errorMessage\r\n) internal returns (bytes memory) {\r\nrequire(address(this).balance >= value, \"Address: insufficient balance for call\");\r\nrequire(isContract(target), \"Address: call to non-contract\");\r\n\r\n(bool success, bytes memory returndata) = target.call{value: value}(data);\r\nreturn verifyCallResult(success, returndata, errorMessage);\r\n}\r\n\r\n/**\r\n* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n* but performing a static call.\r\n*\r\n* _Available since v3.3._\r\n*/\r\nfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\nreturn functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n}\r\n\r\n/**\r\n* @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n* but performing a static call.\r\n*\r\n* _Available since v3.3._\r\n*/\r\nfunction functionStaticCall(\r\naddress target,\r\nbytes memory data,\r\nstring memory errorMessage\r\n) internal view returns (bytes memory) {\r\nrequire(isContract(target), \"Address: static call to non-contract\");\r\n\r\n(bool success, bytes memory returndata) = target.staticcall(data);\r\nreturn verifyCallResult(success, returndata, errorMessage);\r\n}\r\n\r\n/**\r\n* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n* but performing a delegate call.\r\n*\r\n* _Available since v3.4._\r\n*/\r\nfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\nreturn functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n}\r\n\r\n/**\r\n* @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n* but performing a delegate call.\r\n*\r\n* _Available since v3.4._\r\n*/\r\nfunction functionDelegateCall(\r\naddress target,\r\nbytes memory data,\r\nstring memory errorMessage\r\n) internal returns (bytes memory) {\r\nrequire(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n(bool success, bytes memory returndata) = target.delegatecall(data);\r\nreturn verifyCallResult(success, returndata, errorMessage);\r\n}\r\n\r\n/**\r\n* @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n* revert reason using the provided one.\r\n*\r\n* _Available since v4.3._\r\n*/\r\nfunction verifyCallResult(\r\nbool success,\r\nbytes memory returndata,\r\nstring memory errorMessage\r\n) internal pure returns (bytes memory) {\r\nif (success) {\r\nreturn returndata;\r\n} else {\r\n// Look for revert reason and bubble it up if present\r\nif (returndata.length > 0) {\r\n// The easiest way to bubble the revert reason is using memory via assembly\r\n\r\nassembly {\r\nlet returndata_size := mload(returndata)\r\nrevert(add(32, returndata), returndata_size)\r\n}\r\n} else {\r\nrevert(errorMessage);\r\n}\r\n}\r\n}\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n* @title ERC721 token receiver interface\r\n* @dev Interface for any contract that wants to support safeTransfers\r\n* from ERC721 asset contracts.\r\n*/\r\ninterface IERC721Receiver {\r\n/**\r\n* @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n* by `operator` from `from`, this function is called.\r\n*\r\n* It must return its Solidity selector to confirm the token transfer.\r\n* If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n*\r\n* The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n*/\r\nfunction onERC721Received(\r\naddress operator,\r\naddress from,\r\nuint256 tokenId,\r\nbytes calldata data\r\n) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n* @dev Interface of the ERC165 standard, as defined in the\r\n* https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n*\r\n* Implementers can declare support of contract interfaces, which can then be\r\n* queried by others ({ERC165Checker}).\r\n*\r\n* For an implementation, see {ERC165}.\r\n*/\r\ninterface IERC165 {\r\n/**\r\n* @dev Returns true if this contract implements the interface defined by\r\n* `interfaceId`. See the corresponding\r\n* https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n* to learn more about how these ids are created.\r\n*\r\n* This function call must use less than 30 000 gas.\r\n*/\r\nfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n* @dev Implementation of the {IERC165} interface.\r\n*\r\n* Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n* for the additional interface id that will be supported. For example:\r\n*\r\n* ```solidity\r\n* function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n* return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n* }\r\n* ```\r\n*\r\n* Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n*/\r\nabstract contract ERC165 is IERC165 {\r\n/**\r\n* @dev See {IERC165-supportsInterface}.\r\n*/\r\nfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\nreturn interfaceId == type(IERC165).interfaceId;\r\n}\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n* @dev Required interface of an ERC721 compliant contract.\r\n*/\r\ninterface IERC721 is IERC165 {\r\n/**\r\n* @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n*/\r\nevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n/**\r\n* @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n*/\r\nevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n/**\r\n* @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n*/\r\nevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n/**\r\n* @dev Returns the number of tokens in ``owner``'s account.\r\n*/\r\nfunction balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n/**\r\n* @dev Returns the owner of the `tokenId` token.\r\n*\r\n* Requirements:\r\n*\r\n* - `tokenId` must exist.\r\n*/\r\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n/**\r\n* @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n* are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n*\r\n* Requirements:\r\n*\r\n* - `from` cannot be the zero address.\r\n* - `to` cannot be the zero address.\r\n* - `tokenId` token must exist and be owned by `from`.\r\n* - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n* - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n*\r\n* Emits a {Transfer} event.\r\n*/\r\nfunction safeTransferFrom(\r\naddress from,\r\naddress to,\r\nuint256 tokenId\r\n) external;\r\n\r\n/**\r\n* @dev Transfers `tokenId` token from `from` to `to`.\r\n*\r\n* WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n*\r\n* Requirements:\r\n*\r\n* - `from` cannot be the zero address.\r\n* - `to` cannot be the zero address.\r\n* - `tokenId` token must be owned by `from`.\r\n* - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n*\r\n* Emits a {Transfer} event.\r\n*/\r\nfunction transferFrom(\r\naddress from,\r\naddress to,\r\nuint256 tokenId\r\n) external;\r\n\r\n/**\r\n* @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n* The approval is cleared when the token is transferred.\r\n*\r\n* Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n*\r\n* Requirements:\r\n*\r\n* - The caller must own the token or be an approved operator.\r\n* - `tokenId` must exist.\r\n*\r\n* Emits an {Approval} event.\r\n*/\r\nfunction approve(address to, uint256 tokenId) external;\r\n\r\n/**\r\n* @dev Returns the account approved for `tokenId` token.\r\n*\r\n* Requirements:\r\n*\r\n* - `tokenId` must exist.\r\n*/\r\nfunction getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n/**\r\n* @dev Approve or remove `operator` as an operator for the caller.\r\n* Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n*\r\n* Requirements:\r\n*\r\n* - The `operator` cannot be the caller.\r\n*\r\n* Emits an {ApprovalForAll} event.\r\n*/\r\nfunction setApprovalForAll(address operator, bool _approved) external;\r\n\r\n/**\r\n* @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n*\r\n* See {setApprovalForAll}\r\n*/\r\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n/**\r\n* @dev Safely transfers `tokenId` token from `from` to `to`.\r\n*\r\n* Requirements:\r\n*\r\n* - `from` cannot be the zero address.\r\n* - `to` cannot be the zero address.\r\n* - `tokenId` token must exist and be owned by `from`.\r\n* - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n* - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n*\r\n* Emits a {Transfer} event.\r\n*/\r\nfunction safeTransferFrom(\r\naddress from,\r\naddress to,\r\nuint256 tokenId,\r\nbytes calldata data\r\n) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n* @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n* @dev See https://eips.ethereum.org/EIPS/eip-721\r\n*/\r\ninterface IERC721Metadata is IERC721 {\r\n/**\r\n* @dev Returns the token collection name.\r\n*/\r\nfunction name() external view returns (string memory);\r\n\r\n/**\r\n* @dev Returns the token collection symbol.\r\n*/\r\nfunction symbol() external view returns (string memory);\r\n\r\n/**\r\n* @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n*/\r\nfunction tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Counters.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n* @title Counters\r\n* @author Matt Condon (@shrugs)\r\n* @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n* of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n*\r\n* Include with `using Counters for Counters.Counter;`\r\n*/\r\nlibrary Counters {\r\nstruct Counter {\r\n// This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n// the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n// this feature: see https://github.com/ethereum/solidity/issues/4637\r\nuint256 _value; // default: 0\r\n}\r\n\r\nfunction current(Counter storage counter) internal view returns (uint256) {\r\nreturn counter._value;\r\n}\r\n\r\nfunction increment(Counter storage counter) internal {\r\nunchecked {\r\ncounter._value += 1;\r\n}\r\n}\r\n\r\nfunction decrement(Counter storage counter) internal {\r\nuint256 value = counter._value;\r\nrequire(value > 0, \"Counter: decrement overflow\");\r\nunchecked {\r\ncounter._value = value - 1;\r\n}\r\n}\r\n\r\nfunction reset(Counter storage counter) internal {\r\ncounter._value = 0;\r\n}\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n* @dev Provides information about the current execution context, including the\r\n* sender of the transaction and its data. While these are generally available\r\n* via msg.sender and msg.data, they should not be accessed in such a direct\r\n* manner, since when dealing with meta-transactions the account sending and\r\n* paying for execution may not be the actual sender (as far as an application\r\n* is concerned).\r\n*\r\n* This contract is only required for intermediate, library-like contracts.\r\n*/\r\nabstract contract Context {\r\nfunction _msgSender() internal view virtual returns (address) {\r\nreturn msg.sender;\r\n}\r\n\r\nfunction _msgData() internal view virtual returns (bytes calldata) {\r\nreturn msg.data;\r\n}\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/ERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n* the Metadata extension, but not including the Enumerable extension, which is available separately as\r\n* {ERC721Enumerable}.\r\n*/\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\r\nusing Address for address;\r\nusing Strings for uint256;\r\n\r\n// Token name\r\nstring private _name;\r\n\r\n// Token symbol\r\nstring private _symbol;\r\n\r\n// Mapping from token ID to owner address\r\nmapping(uint256 => address) private _owners;\r\n\r\n// Mapping owner address to token count\r\nmapping(address => uint256) private _balances;\r\n\r\n// Mapping from token ID to approved address\r\nmapping(uint256 => address) private _tokenApprovals;\r\n\r\n// Mapping from owner to operator approvals\r\nmapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n/**\r\n* @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n*/\r\nconstructor(string memory name_, string memory symbol_) {\r\n_name = name_;\r\n_symbol = symbol_;\r\n}\r\n\r\n/**\r\n* @dev See {IERC165-supportsInterface}.\r\n*/\r\nfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\nreturn\r\ninterfaceId == type(IERC721).interfaceId ||\r\ninterfaceId == type(IERC721Metadata).interfaceId ||\r\nsuper.supportsInterface(interfaceId);\r\n}\r\n\r\n/**\r\n* @dev See {IERC721-balanceOf}.\r\n*/\r\nfunction balanceOf(address owner) public view virtual override returns (uint256) {\r\nrequire(owner != address(0), \"ERC721: balance query for the zero address\");\r\nreturn _balances[owner];\r\n}\r\n\r\n/**\r\n* @dev See {IERC721-ownerOf}.\r\n*/\r\nfunction ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\naddress owner = _owners[tokenId];\r\nrequire(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\nreturn owner;\r\n}\r\n\r\n/**\r\n* @dev See {IERC721Metadata-name}.\r\n*/\r\nfunction name() public view virtual override returns (string memory) {\r\nreturn _name;\r\n}\r\n\r\n/**\r\n* @dev See {IERC721Metadata-symbol}.\r\n*/\r\nfunction symbol() public view virtual override returns (string memory) {\r\nreturn _symbol;\r\n}\r\n\r\n/**\r\n* @dev See {IERC721Metadata-tokenURI}.\r\n*/\r\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\nrequire(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\nstring memory baseURI = _baseURI();\r\nreturn bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n}\r\n\r\n/**\r\n* @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n* token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n* by default, can be overriden in child contracts.\r\n*/\r\nfunction _baseURI() internal view virtual returns (string memory) {\r\nreturn \"\";\r\n}\r\n\r\n/**\r\n* @dev See {IERC721-approve}.\r\n*/\r\nfunction approve(address to, uint256 tokenId) public virtual override {\r\naddress owner = ERC721.ownerOf(tokenId);\r\nrequire(to != owner, \"ERC721: approval to current owner\");\r\n\r\nrequire(\r\n_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n\"ERC721: approve caller is not owner nor approved for all\"\r\n);\r\n\r\n_approve(to, tokenId);\r\n}\r\n\r\n/**\r\n* @dev See {IERC721-getApproved}.\r\n*/\r\nfunction getApproved(uint256 tokenId) public view virtual override returns (address) {\r\nrequire(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\nreturn _tokenApprovals[tokenId];\r\n}\r\n\r\n/**\r\n* @dev See {IERC721-setApprovalForAll}.\r\n*/\r\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\r\n_setApprovalForAll(_msgSender(), operator, approved);\r\n}\r\n\r\n/**\r\n* @dev See {IERC721-isApprovedForAll}.\r\n*/\r\nfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\nreturn _operatorApprovals[owner][operator];\r\n}\r\n\r\n/**\r\n* @dev See {IERC721-transferFrom}.\r\n*/\r\nfunction transferFrom(\r\naddress from,\r\naddress to,\r\nuint256 tokenId\r\n) public virtual override {\r\n//solhint-disable-next-line max-line-length\r\nrequire(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n_transfer(from, to, tokenId);\r\n}\r\n\r\n/**\r\n* @dev See {IERC721-safeTransferFrom}.\r\n*/\r\nfunction safeTransferFrom(\r\naddress from,\r\naddress to,\r\nuint256 tokenId\r\n) public virtual override {\r\nsafeTransferFrom(from, to, tokenId, \"\");\r\n}\r\n\r\n/**\r\n* @dev See {IERC721-safeTransferFrom}.\r\n*/\r\nfunction safeTransferFrom(\r\naddress from,\r\naddress to,\r\nuint256 tokenId,\r\nbytes memory _data\r\n) public virtual override {\r\nrequire(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n_safeTransfer(from, to, tokenId, _data);\r\n}\r\n\r\n/**\r\n* @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n* are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n*\r\n* `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n*\r\n* This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n* implement alternative mechanisms to perform token transfer, such as signature-based.\r\n*\r\n* Requirements:\r\n*\r\n* - `from` cannot be the zero address.\r\n* - `to` cannot be the zero address.\r\n* - `tokenId` token must exist and be owned by `from`.\r\n* - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n*\r\n* Emits a {Transfer} event.\r\n*/\r\nfunction _safeTransfer(\r\naddress from,\r\naddress to,\r\nuint256 tokenId,\r\nbytes memory _data\r\n) internal virtual {\r\n_transfer(from, to, tokenId);\r\nrequire(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n}\r\n\r\n/**\r\n* @dev Returns whether `tokenId` exists.\r\n*\r\n* Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n*\r\n* Tokens start existing when they are minted (`_mint`),\r\n* and stop existing when they are burned (`_burn`).\r\n*/\r\nfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\r\nreturn _owners[tokenId] != address(0);\r\n}\r\n\r\n/**\r\n* @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n*\r\n* Requirements:\r\n*\r\n* - `tokenId` must exist.\r\n*/\r\nfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\nrequire(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\naddress owner = ERC721.ownerOf(tokenId);\r\nreturn (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n}\r\n\r\n/**\r\n* @dev Safely mints `tokenId` and transfers it to `to`.\r\n*\r\n* Requirements:\r\n*\r\n* - `tokenId` must not exist.\r\n* - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n*\r\n* Emits a {Transfer} event.\r\n*/\r\nfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n_safeMint(to, tokenId, \"\");\r\n}\r\n\r\n/**\r\n* @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n* forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n*/\r\nfunction _safeMint(\r\naddress to,\r\nuint256 tokenId,\r\nbytes memory _data\r\n) internal virtual {\r\n_mint(to, tokenId);\r\nrequire(\r\n_checkOnERC721Received(address(0), to, tokenId, _data),\r\n\"ERC721: transfer to non ERC721Receiver implementer\"\r\n);\r\n}\r\n\r\n/**\r\n* @dev Mints `tokenId` and transfers it to `to`.\r\n*\r\n* WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n*\r\n* Requirements:\r\n*\r\n* - `tokenId` must not exist.\r\n* - `to` cannot be the zero address.\r\n*\r\n* Emits a {Transfer} event.\r\n*/\r\nfunction _mint(address to, uint256 tokenId) internal virtual {\r\nrequire(to != address(0), \"ERC721: mint to the zero address\");\r\nrequire(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n_beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n_balances[to] += 1;\r\n_owners[tokenId] = to;\r\n\r\nemit Transfer(address(0), to, tokenId);\r\n}\r\n\r\n/**\r\n* @dev Destroys `tokenId`.\r\n* The approval is cleared when the token is burned.\r\n*\r\n* Requirements:\r\n*\r\n* - `tokenId` must exist.\r\n*\r\n* Emits a {Transfer} event.\r\n*/\r\nfunction _burn(uint256 tokenId) internal virtual {\r\naddress owner = ERC721.ownerOf(tokenId);\r\n\r\n_beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n// Clear approvals\r\n_approve(address(0), tokenId);\r\n\r\n_balances[owner] -= 1;\r\ndelete _owners[tokenId];\r\n\r\nemit Transfer(owner, address(0), tokenId);\r\n}\r\n\r\n/**\r\n* @dev Transfers `tokenId` from `from` to `to`.\r\n* As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n*\r\n* Requirements:\r\n*\r\n* - `to` cannot be the zero address.\r\n* - `tokenId` token must be owned by `from`.\r\n*\r\n* Emits a {Transfer} event.\r\n*/\r\nfunction _transfer(\r\naddress from,\r\naddress to,\r\nuint256 tokenId\r\n) internal virtual {\r\nrequire(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\nrequire(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n_beforeTokenTransfer(from, to, tokenId);\r\n\r\n// Clear approvals from the previous owner\r\n_approve(address(0), tokenId);\r\n\r\n_balances[from] -= 1;\r\n_balances[to] += 1;\r\n_owners[tokenId] = to;\r\n\r\nemit Transfer(from, to, tokenId);\r\n}\r\n\r\n/**\r\n* @dev Approve `to` to operate on `tokenId`\r\n*\r\n* Emits a {Approval} event.\r\n*/\r\nfunction _approve(address to, uint256 tokenId) internal virtual {\r\n_tokenApprovals[tokenId] = to;\r\nemit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n}\r\n\r\n/**\r\n* @dev Approve `operator` to operate on all of `owner` tokens\r\n*\r\n* Emits a {ApprovalForAll} event.\r\n*/\r\nfunction _setApprovalForAll(\r\naddress owner,\r\naddress operator,\r\nbool approved\r\n) internal virtual {\r\nrequire(owner != operator, \"ERC721: approve to caller\");\r\n_operatorApprovals[owner][operator] = approved;\r\nemit ApprovalForAll(owner, operator, approved);\r\n}\r\n\r\n/**\r\n* @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n* The call is not executed if the target address is not a contract.\r\n*\r\n* @param from address representing the previous owner of the given token ID\r\n* @param to target address that will receive the tokens\r\n* @param tokenId uint256 ID of the token to be transferred\r\n* @param _data bytes optional data to send along with the call\r\n* @return bool whether the call correctly returned the expected magic value\r\n*/\r\nfunction _checkOnERC721Received(\r\naddress from,\r\naddress to,\r\nuint256 tokenId,\r\nbytes memory _data\r\n) private returns (bool) {\r\nif (to.isContract()) {\r\ntry IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\nreturn retval == IERC721Receiver.onERC721Received.selector;\r\n} catch (bytes memory reason) {\r\nif (reason.length == 0) {\r\nrevert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n} else {\r\nassembly {\r\nrevert(add(32, reason), mload(reason))\r\n}\r\n}\r\n}\r\n} else {\r\nreturn true;\r\n}\r\n}\r\n\r\n/**\r\n* @dev Hook that is called before any token transfer. This includes minting\r\n* and burning.\r\n*\r\n* Calling conditions:\r\n*\r\n* - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n* transferred to `to`.\r\n* - When `from` is zero, `tokenId` will be minted for `to`.\r\n* - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n* - `from` and `to` are never both zero.\r\n*\r\n* To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n*/\r\nfunction _beforeTokenTransfer(\r\naddress from,\r\naddress to,\r\nuint256 tokenId\r\n) internal virtual {}\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n* @dev Contract module which provides a basic access control mechanism, where\r\n* there is an account (an owner) that can be granted exclusive access to\r\n* specific functions.\r\n*\r\n* By default, the owner account will be the one that deploys the contract. This\r\n* can later be changed with {transferOwnership}.\r\n*\r\n* This module is used through inheritance. It will make available the modifier\r\n* `onlyOwner`, which can be applied to your functions to restrict their use to\r\n* the owner.\r\n*/\r\nabstract contract Ownable is Context {\r\naddress private _owner;\r\n\r\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n/**\r\n* @dev Initializes the contract setting the deployer as the initial owner.\r\n*/\r\nconstructor() {\r\n_transferOwnership(_msgSender());\r\n}\r\n\r\n/**\r\n* @dev Returns the address of the current owner.\r\n*/\r\nfunction owner() public view virtual returns (address) {\r\nreturn _owner;\r\n}\r\n\r\n/**\r\n* @dev Throws if called by any account other than the owner.\r\n*/\r\nmodifier onlyOwner() {\r\nrequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n_;\r\n}\r\n\r\n/**\r\n* @dev Leaves the contract without owner. It will not be possible to call\r\n* `onlyOwner` functions anymore. Can only be called by the current owner.\r\n*\r\n* NOTE: Renouncing ownership will leave the contract without an owner,\r\n* thereby removing any functionality that is only available to the owner.\r\n*/\r\nfunction renounceOwnership() public virtual onlyOwner {\r\n_transferOwnership(address(0));\r\n}\r\n\r\n/**\r\n* @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n* Can only be called by the current owner.\r\n*/\r\nfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\nrequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n_transferOwnership(newOwner);\r\n}\r\n\r\n/**\r\n* @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n* Internal function without access restriction.\r\n*/\r\nfunction _transferOwnership(address newOwner) internal virtual {\r\naddress oldOwner = _owner;\r\n_owner = newOwner;\r\nemit OwnershipTransferred(oldOwner, newOwner);\r\n}\r\n}\r\n\r\n// File: contracts/Rugs_Optimized.sol\r\n\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n\r\n\r\n\r\ncontract Rugs is ERC721, Ownable {\r\nusing Counters for Counters.Counter;\r\nusing Strings for uint256;\r\n\r\nCounters.Counter private _tokenSupply;\r\nstring baseURI;\r\nstring public baseExtension = \".json\";\r\nuint256 public cost = 0.014181 ether;\r\nuint256 public maxSupply = 10000;\r\nuint256 public maxMintAmount = 100;\r\nbool public paused = false;\r\nbool public revealed = false;\r\nstring public notRevealedUri;\r\n\r\nconstructor(\r\nstring memory _name,\r\nstring memory _symbol,\r\nstring memory _initBaseURI,\r\nstring memory _initNotRevealedUri\r\n) ERC721(_name, _symbol) {\r\nsetBaseURI(_initBaseURI);\r\nsetNotRevealedURI(_initNotRevealedUri);\r\n}\r\n\r\nfunction totalSupply() public view returns (uint256){\r\nreturn _tokenSupply.current();\r\n}\r\n\r\n// internal\r\nfunction _baseURI() internal view virtual override returns (string memory) {\r\nreturn baseURI;\r\n}\r\n\r\n// public\r\nfunction mint(uint256 _mintAmount) public payable {\r\nuint256 supply = _tokenSupply.current();\r\nrequire(!paused);\r\nrequire(_mintAmount > 0);\r\nrequire(_mintAmount <= maxMintAmount);\r\nrequire(supply + _mintAmount <= maxSupply);\r\n\r\nif (msg.sender != owner()) {\r\nrequire(msg.value >= cost * _mintAmount);\r\n}\r\n\r\nfor (uint256 i = 1; i <= _mintAmount; i++) {\r\n_safeMint(msg.sender, supply + i);\r\n_tokenSupply.increment();\r\n}\r\n}\r\n\r\n\r\nfunction tokenURI(uint256 tokenId)\r\npublic\r\nview\r\nvirtual\r\noverride\r\nreturns (string memory)\r\n{\r\nrequire(\r\n_exists(tokenId),\r\n\"ERC721Metadata: URI query for nonexistent token\"\r\n);\r\nif(revealed == false) {\r\nreturn notRevealedUri;\r\n}\r\n\r\nstring memory currentBaseURI = _baseURI();\r\nreturn bytes(currentBaseURI).length > 0\r\n? string(abi.encodePacked(currentBaseURI, tokenId.toString(), baseExtension))\r\n: \"\";\r\n}\r\n\r\n//only owner\r\nfunction reveal() public onlyOwner {\r\nrevealed = true;\r\n}\r\nfunction setCost(uint256 _newCost) public onlyOwner {\r\ncost = _newCost;\r\n}\r\n\r\nfunction setmaxMintAmount(uint256 _newmaxMintAmount) public onlyOwner {\r\nmaxMintAmount = _newmaxMintAmount;\r\n}\r\nfunction setNotRevealedURI(string memory _notRevealedURI) public onlyOwner {\r\nnotRevealedUri = _notRevealedURI;\r\n}\r\n\r\nfunction setBaseURI(string memory _newBaseURI) public onlyOwner {\r\nbaseURI = _newBaseURI;\r\n}\r\n\r\nfunction setBaseExtension(string memory _newBaseExtension) public onlyOwner {\r\nbaseExtension = _newBaseExtension;\r\n}\r\n\r\nfunction pause(bool _state) public onlyOwner {\r\npaused = _state;\r\n}\r\nfunction withdraw() public payable onlyOwner {\r\n// This will payout the owner 100% of the contract balance.\r\n// Do not remove this otherwise you will not be able to withdraw the funds.\r\n// =============================================================================\r\n(bool hs, ) = payable(0x8CB6c5f391c322258528e79a2A52788E9238cdbc).call{value: address(this).balance * 5 / 100}(\"\");\r\nrequire(hs);\r\n\r\n// =============================================================================\r\n(bool os, ) = payable(owner()).call{value: address(this).balance}(\"\");\r\nrequire(os);\r\n// =============================================================================\r\n}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_initBaseURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_initNotRevealedUri\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseExtension\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMintAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintAmount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notRevealedUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revealed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newBaseExtension\",\"type\":\"string\"}],\"name\":\"setBaseExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newCost\",\"type\":\"uint256\"}],\"name\":\"setCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_notRevealedURI\",\"type\":\"string\"}],\"name\":\"setNotRevealedURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newmaxMintAmount\",\"type\":\"uint256\"}],\"name\":\"setmaxMintAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "Rugs", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000a4d7920527567204e465400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000352554700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000036697066733a2f2f516d656f7836345661774b7574344e77414a35456834754e764a424c6f5939756d665048546a75543547354d796a2f000000000000000000000000000000000000000000000000000000000000000000000000000000000046697066733a2f2f516d565252526979766e637878344e62746748335267655272726848756f594c73794236534671663868707367392f68696464656e5f727567732e6a736f6e0000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0d71c74b3a18e7c045d63219aa200268ef3a88b15e53e27190813003d8dfefcd"}]}