{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\npragma solidity 0.8.10;\r\n\r\nabstract contract Initializable {\r\n    bool private _initialized;\r\n\r\n    bool private _initializing;\r\n\r\n    modifier initializer() {\r\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\r\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\r\n        // contract may have been reentered.\r\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n\r\n    modifier onlyInitializing() {\r\n        require(_initializing, \"Initializable: contract is not initializing\");\r\n        _;\r\n    }\r\n\r\n    function _isConstructor() private view returns (bool) {\r\n        return !AddressUpgradeable.isContract(address(this));\r\n    }\r\n}\r\n\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __Context_init_unchained() internal onlyInitializing {\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n}\r\n\r\n\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function __Ownable_init() internal onlyInitializing {\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable_init_unchained() internal onlyInitializing {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    uint256[49] private __gap;\r\n}\r\n\r\ninterface IERC20Upgradeable {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nlibrary AddressUpgradeable {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\r\n        __ERC20_init_unchained(name_, symbol_);\r\n    }\r\n\r\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = _allowances[owner][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n        }\r\n        _balances[to] += amount;\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    uint256[45] private __gap;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\r\n\tfunction addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n}\r\n\r\ninterface IOceidonNFT {\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n}\r\n\r\nlibrary Babylonian {\r\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n        // else z = 0\r\n    }\r\n}\r\n\r\nlibrary SafeERC20Upgradeable {\r\n    using AddressUpgradeable for address;\r\n\r\n    function safeTransfer(\r\n        IERC20Upgradeable token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20Upgradeable token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20Upgradeable token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20Upgradeable token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20Upgradeable token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract OceidonBlox is ERC20Upgradeable, OwnableUpgradeable {\r\n    using AddressUpgradeable for address;\r\n    using SafeERC20Upgradeable for IERC20Upgradeable;\r\n\t\r\n    IUniswapV2Router02 public uniswapV2Router;\r\n    address public uniswapV2Pair;\r\n\t\r\n    uint256[] public developmentFee;\r\n    uint256[] public liquidityFee;\r\n\tuint256[] public otherFee;\r\n\t\t\r\n\tuint256 private developmentFeeTotal;\r\n\tuint256 private liquidityFeeTotal;\r\n\tuint256 private otherFeeTotal;\r\n\t\r\n    uint256 public swapTokensAtAmount;\r\n\tuint256 public maxTxAmount;\r\n\tuint256 public maxWalletAmount;\r\n\t\r\n\taddress public constant USDCAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\r\n\taddress public otherTokenAddress;\r\n\t\r\n\taddress public developmentFeeAddress;\r\n\taddress public otherTokenFeeAddress;\r\n\t\r\n\tbool private swapping;\r\n\tbool public swapEnable;\r\n    bool public tradingEnabled;\r\n    bool private initFlag;\r\n\t\r\n    mapping (address => bool) public isExcludedFromFees;\r\n    mapping (address => bool) public automatedMarketMakerPairs;\r\n\tmapping (address => bool) public isExcludedFromMaxWalletToken;\r\n    address public constant uniswapV2_OBLOXUSDCPair = 0xB1636Da7243bED31B988d68026C3289Df258d252;\r\n    mapping (address => bool) public blacklist;\r\n    address public constant OBLOXNFT = 0xD7e603aC5A64a7327Db5a40cc45e88ae272ECd1C;\r\n    bool public tokenDiscountEnable;\r\n    uint256 public token2Discount;\r\n    uint256 public token3Discount;\r\n    uint256 public token2DiscountBuyDev;\r\n    uint256 public token2DiscountBuyLiquidity;\r\n    uint256 public token3DiscountBuyDev;\r\n    uint256 public token3DiscountBuyLiquidity;\r\n    uint256 public token2DiscountSellDev;\r\n    uint256 public token2DiscountSellLiquidity;\r\n    uint256 public token3DiscountSellDev;\r\n    uint256 public token3DiscountSellLiquidity;\r\n\t\r\n    event ExcludeFromFees(address indexed account, bool isExcluded);\r\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\r\n\tevent ExcludeMaxWalletToken(address indexed account, bool isExcluded);\r\n    event TradingEnabled(bool enabled);\r\n    event SetBlacklist(address indexed account, bool indexed isBanned);\r\n\r\n    function initialize() external initializer {\r\n        __Ownable_init();\r\n        __ERC20_init(\"Oceidon Blox\", \"OBLOX\");\r\n        \r\n    \tIUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), USDCAddress);\r\n\r\n        uniswapV2Router = _uniswapV2Router;\r\n        uniswapV2Pair   = _uniswapV2Pair;\r\n\r\n        _setAutomatedMarketMakerPair(uniswapV2Pair, true);\r\n\t\t\r\n        excludeFromFees(address(this), true);\r\n\t\texcludeFromFees(owner(), true);\r\n\r\n\t\tisExcludedFromMaxWalletToken[uniswapV2Pair] = true;\r\n\t\tisExcludedFromMaxWalletToken[address(this)] = true;\r\n\t\tisExcludedFromMaxWalletToken[owner()] = true;\r\n\r\n        swapTokensAtAmount = 10_000_000 * (10**18);\r\n        maxTxAmount = 10_000_000_000 * (10**18);\r\n        maxWalletAmount = 10_000_000_000 * (10**18);\r\n\r\n        developmentFeeAddress = 0xeC82E2d1184a38c192A0cBD8Fa84b6A3d6A127DB;\r\n\r\n\t\tdevelopmentFee.push(200);\r\n\t\tdevelopmentFee.push(200);\r\n\t\tdevelopmentFee.push(200);\r\n\t\t\r\n\t\tliquidityFee.push(500);\r\n\t\tliquidityFee.push(500);\r\n\t\tliquidityFee.push(500);\r\n\t\t\r\n\t\totherFee.push(0);\r\n\t\totherFee.push(0);\r\n\t\totherFee.push(0);\r\n\r\n        swapEnable = true;\r\n        initFlag = true;\r\n\t\t\r\n        _mint(0x1e091F3B36C2771F39DD1b30f698689811478188, 10_000_000_000 * (10**18));\r\n    }\r\n\r\n    function initsecond() external onlyOwner {\r\n        tokenDiscountEnable = true;\r\n        token2Discount = 2855;\r\n        token3Discount = 1439;\r\n        blacklist[0xd14Ff3cADe49954cea0119b54B97935688cCa53F] = true;\r\n        isExcludedFromMaxWalletToken[uniswapV2_OBLOXUSDCPair] = true;\r\n        automatedMarketMakerPairs[uniswapV2_OBLOXUSDCPair] = true;\r\n        swapTokensAtAmount = 4_000_000 * (10**18);\r\n        swapEnable = true;\r\n    }\r\n\r\n    function initthird() external onlyOwner {\r\n        token2DiscountBuyDev = 10000;\r\n        token3DiscountBuyDev = 10000;\r\n        token2DiscountBuyLiquidity = 10000;\r\n        token3DiscountBuyLiquidity = 10000;\r\n        developmentFeeTotal = 0;\r\n        liquidityFeeTotal = 0;\r\n    }\r\n\t\r\n    receive() external payable {\r\n  \t}\r\n\r\n    function getDevelopmentFeeTotal() external view onlyOwner returns (uint256) {\r\n        return developmentFeeTotal;\r\n    }\r\n\r\n    function getLiquidityFeeTotal() external view onlyOwner returns (uint256) {\r\n        return liquidityFeeTotal;\r\n    }\r\n\r\n    function setDevelopmentFeeTotal(uint256 amount) external onlyOwner {\r\n        developmentFeeTotal = amount;\r\n    }\r\n\r\n    function setLiquidityFeeTotal(uint256 amount) external onlyOwner {\r\n        liquidityFeeTotal = amount;\r\n    }\r\n\r\n    function enableTrading(bool _enabled) external onlyOwner {\r\n        tradingEnabled = _enabled;\r\n        emit TradingEnabled(_enabled);\r\n    }\r\n\t\r\n\tfunction setSwapTokensAtAmount(uint256 amount) external onlyOwner {\r\n  \t     require(amount <= totalSupply(), \"Amount cannot be over the total supply.\");\r\n\t\t swapTokensAtAmount = amount;\r\n  \t}\r\n\t\r\n\tfunction setMaxTxAmount(uint256 amount) external onlyOwner {\r\n\t     require(amount <= totalSupply(), \"Amount cannot be over the total supply.\");\r\n         maxTxAmount = amount;\r\n    }\r\n\t\r\n\tfunction setMaxWalletAmount(uint256 amount) public onlyOwner {\r\n\t\trequire(amount <= totalSupply(), \"Amount cannot be over the total supply.\");\r\n\t\tmaxWalletAmount = amount;\r\n\t}\r\n\t\r\n\tfunction setSwapEnable(bool _enabled) public onlyOwner {\r\n        swapEnable = _enabled;\r\n    }\r\n\t\r\n\tfunction setDevelopmentFee(uint256 buy, uint256 sell, uint256 p2p) external onlyOwner {\r\n        require(buy <= 10000, \"Exceeds maximum fee\");\r\n        require(sell <= 10000, \"Exceeds maximum fee\");\r\n        require(p2p <= 10000, \"Exceeds maximum fee\");\r\n\r\n\t\tdevelopmentFee[0] = buy;\r\n\t\tdevelopmentFee[1] = sell;\r\n\t\tdevelopmentFee[2] = p2p;\r\n\t}\r\n\t\r\n\tfunction setLiquidityFee(uint256 buy, uint256 sell, uint256 p2p) external onlyOwner {\r\n        require(buy <= 10000, \"Exceeds maximum fee\");\r\n        require(sell <= 10000, \"Exceeds maximum fee\");\r\n        require(p2p <= 10000, \"Exceeds maximum fee\");\r\n\r\n\t\tliquidityFee[0] = buy;\r\n\t\tliquidityFee[1] = sell;\r\n\t\tliquidityFee[2] = p2p;\r\n\t}\r\n\t\r\n\tfunction setOtherFee(uint256 buy, uint256 sell, uint256 p2p) external onlyOwner {\r\n        require(buy <= 10000, \"Exceeds maximum fee\");\r\n        require(sell <= 10000, \"Exceeds maximum fee\");\r\n        require(p2p <= 10000, \"Exceeds maximum fee\");\r\n        \r\n\t\totherFee[0] = buy;\r\n\t\totherFee[1] = sell;\r\n\t\totherFee[2] = p2p;\r\n\t}\r\n\t\r\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\r\n        require(isExcludedFromFees[account] != excluded, \"Account is already the value of 'excluded'\");\r\n        isExcludedFromFees[account] = excluded;\r\n        emit ExcludeFromFees(account, excluded);\r\n    }\r\n\t\r\n\tfunction excludeFromMaxWalletToken(address account, bool excluded) public onlyOwner {\r\n        require(isExcludedFromMaxWalletToken[account] != excluded, \"Account is already the value of 'excluded'\");\r\n        isExcludedFromMaxWalletToken[account] = excluded;\r\n        emit ExcludeMaxWalletToken(account, excluded);\r\n    }\r\n\t\r\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\r\n        require(pair != uniswapV2Pair, \"The Uniswap pair cannot be removed from automatedMarketMakerPairs\");\r\n        _setAutomatedMarketMakerPair(pair, value);\r\n    }\r\n\t\r\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\r\n        require(automatedMarketMakerPairs[pair] != value, \"Automated market maker pair is already set to that value\");\r\n        automatedMarketMakerPairs[pair] = value;\r\n        emit SetAutomatedMarketMakerPair(pair, value);\r\n    }\r\n\t\r\n\tfunction setDevelopmentFeeAddress(address payable newAddress) external onlyOwner {\r\n       require(newAddress != address(0), \"zero-address not allowed\");\r\n\t   developmentFeeAddress = newAddress;\r\n    }\r\n\t\r\n\tfunction setOtherTokenFeeAddress(address payable newAddress) external onlyOwner {\r\n       require(newAddress != address(0), \"zero-address not allowed\");\r\n\t   otherTokenFeeAddress = newAddress;\r\n    }\r\n\t\r\n\tfunction setOtherTokenAddress(address newAddress) external onlyOwner {\r\n       require(newAddress != address(0), \"zero-address not allowed\");\r\n\t   otherTokenAddress = newAddress;\r\n    }\r\n\r\n    function setBlacklist(address account, bool isBanned) public onlyOwner {\r\n        require(blacklist[account] != isBanned, \"This account is already set to that value\");\r\n        blacklist[account] = isBanned;\r\n        emit SetBlacklist(account, isBanned);\r\n    }\r\n\r\n    function setBlacklistBatch(address[] memory accounts, bool isBanned) public onlyOwner {\r\n        for (uint256 i = 0; i < accounts.length; i++) {\r\n            blacklist[accounts[i]] = isBanned;\r\n        }\r\n    }\r\n\r\n    function setTokenDiscountEnable(bool _enabled) public onlyOwner {\r\n        tokenDiscountEnable = _enabled;\r\n    }\r\n\r\n    function setTokensDiscount(uint256 _token2Discount, uint256 _token3Discount) public onlyOwner {\r\n        require(_token2Discount <= 10000, \"Exceeds maximum fee\");\r\n        require(_token3Discount <= 10000, \"Exceeds maximum fee\");\r\n\r\n        token2Discount = _token2Discount;\r\n        token3Discount = _token3Discount;\r\n    }\r\n\r\n    function setTokensDiscountOnBuy(uint256 _token2DiscountBuyDev, uint256 _token2DiscountBuyLiquidity, uint256 _token3DiscountBuyDev, uint256 _token3DiscountBuyLiquidity) public onlyOwner {\r\n        require(_token2DiscountBuyDev <= 10000, \"Exceeds maximum fee\");\r\n        require(_token2DiscountBuyLiquidity <= 10000, \"Exceeds maximum fee\");\r\n        require(_token3DiscountBuyDev <= 10000, \"Exceeds maximum fee\");\r\n        require(_token3DiscountBuyLiquidity <= 10000, \"Exceeds maximum fee\");\r\n\r\n        token2DiscountBuyDev = _token2DiscountBuyDev;\r\n        token2DiscountBuyLiquidity = _token2DiscountBuyLiquidity;\r\n        token3DiscountBuyDev = _token3DiscountBuyDev;\r\n        token3DiscountBuyLiquidity = _token3DiscountBuyLiquidity;\r\n    }\r\n\r\n    function setTokensDiscountOnSell(uint256 _token2DiscountSellDev, uint256 _token2DiscountSellLiquidity, uint256 _token3DiscountSellDev, uint256 _token3DiscountSellLiquidity) public onlyOwner {\r\n        require(_token2DiscountSellDev <= 10000, \"Exceeds maximum fee\");\r\n        require(_token2DiscountSellLiquidity <= 10000, \"Exceeds maximum fee\");\r\n        require(_token3DiscountSellDev <= 10000, \"Exceeds maximum fee\");\r\n        require(_token3DiscountSellLiquidity <= 10000, \"Exceeds maximum fee\");\r\n\r\n        token2DiscountSellDev = _token2DiscountSellDev;\r\n        token2DiscountSellLiquidity = _token2DiscountSellLiquidity;\r\n        token3DiscountSellDev = _token3DiscountSellDev;\r\n        token3DiscountSellLiquidity = _token3DiscountSellLiquidity;\r\n    }\r\n\t\r\n\tfunction _transfer(address from, address to, uint256 amount) internal override {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(blacklist[from] == false && blacklist[to] == false, \"Sender or receiver are not allowed to trade\");\r\n        \r\n        if(from != owner() && to != owner()) {\r\n\t\t    require(amount <= maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\r\n            require(tradingEnabled, \"Trading and token transfers disabled.\");\r\n\t\t}\r\n\t\t\r\n\t\tif(!isExcludedFromMaxWalletToken[to] && !automatedMarketMakerPairs[to]) {\r\n            uint256 balanceRecepient = balanceOf(to);\r\n            require(balanceRecepient + amount <= maxWalletAmount, \"Exceeds maximum wallet token amount\");\r\n        }\r\n\t\t\r\n\t\tuint256 contractTokenBalance = balanceOf(address(this));\r\n\t\tbool canSwap = contractTokenBalance >= swapTokensAtAmount;\r\n\t\t\r\n\t\tif (!swapping && canSwap && swapEnable) {\r\n\t\t\tswapping = true;\r\n\t\t\t\r\n\t\t\tuint256 tokenToDevelopment = developmentFeeTotal;\r\n\t\t\tuint256 tokenToLiqudity = liquidityFeeTotal;\r\n\t\t\tuint256 tokenToOther = otherFeeTotal;\r\n\t\t\t\r\n\t\t\tswapTokensForUSDC(tokenToDevelopment, developmentFeeAddress);\r\n\t\t\t\r\n\t\t\tif(tokenToOther > 0 && otherTokenAddress != address(0)){\r\n\t\t\t   swapTokensForOther(tokenToOther);\r\n\t\t\t}\r\n\t\t\t\r\n            IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2_OBLOXUSDCPair);\r\n            (uint256 res0, uint256 res1, ) = pair.getReserves();\r\n\r\n            uint256 tokenReserve;\r\n            if(address(this) == pair.token0()) {\r\n                tokenReserve = res0;\r\n            } else {\r\n                tokenReserve = res1;\r\n            }\r\n            uint256 originalAmount = IERC20Upgradeable(USDCAddress).balanceOf(address(this));\r\n            uint256 amountToSwap = calculateSwapInAmount(tokenReserve, tokenToLiqudity);\r\n\t\t\tuint256 amountLeft = tokenToLiqudity - amountToSwap;\r\n\t\t\tswapTokensForUSDC(amountToSwap, address(this));\r\n            uint256 initialBalance = IERC20Upgradeable(USDCAddress).balanceOf(address(this)) - originalAmount;\r\n\t\t\taddLiquidity(amountLeft, initialBalance);\r\n\t\t\t\r\n\t\t\tdevelopmentFeeTotal = developmentFeeTotal - tokenToDevelopment;\r\n\t\t\tliquidityFeeTotal = liquidityFeeTotal - tokenToLiqudity;\r\n\t\t\totherFeeTotal = otherFeeTotal - tokenToOther;\r\n\t\t\tswapping = false;\r\n\t\t}\r\n\t\t\r\n        bool takeFee = !swapping;\r\n\t\tif(isExcludedFromFees[from] || isExcludedFromFees[to]) {\r\n            takeFee = false;\r\n        }\r\n\t\t\r\n\t\tif(takeFee) \r\n\t\t{\r\n            uint256 devDiscount = 10000;\r\n            uint256 liquidityDiscount = 10000;\r\n            if(tokenDiscountEnable) {\r\n                // P2P discount\r\n                uint256 token2DevDiscount = token2Discount;\r\n                uint256 token2LiquidityDiscount = token2Discount;\r\n                uint256 token3DevDiscount = token3Discount;\r\n                uint256 token3LiquidityDiscount = token3Discount;\r\n\r\n                // SELL discount\r\n                if(automatedMarketMakerPairs[to]) {\r\n                    token2DevDiscount = token2DiscountSellDev;\r\n                    token2LiquidityDiscount = token2DiscountSellLiquidity;\r\n                    token3DevDiscount = token3DiscountSellDev;\r\n                    token3LiquidityDiscount = token3DiscountSellLiquidity;\r\n                }\r\n\r\n                // BUY discount\r\n                if(automatedMarketMakerPairs[from]) {\r\n                    token2DevDiscount = token2DiscountBuyDev;\r\n                    token2LiquidityDiscount = token2DiscountBuyLiquidity;\r\n                    token3DevDiscount = token3DiscountBuyDev;\r\n                    token3LiquidityDiscount = token3DiscountBuyLiquidity;\r\n                }\r\n                \r\n                if(IOceidonNFT(OBLOXNFT).balanceOf(from, 2) >= 1 || IOceidonNFT(OBLOXNFT).balanceOf(to, 2) >= 1) {\r\n                    devDiscount = token2DevDiscount;\r\n                    liquidityDiscount = token2LiquidityDiscount;\r\n                }\r\n                if(IOceidonNFT(OBLOXNFT).balanceOf(from, 3) >= 1 || IOceidonNFT(OBLOXNFT).balanceOf(to, 3) >= 1) {\r\n                    devDiscount = token3DevDiscount;\r\n                    liquidityDiscount = token3LiquidityDiscount;\r\n                }\r\n            }\r\n\r\n\t\t    uint256 allfee;\r\n\t\t    allfee = collectFee(amount, automatedMarketMakerPairs[to], !automatedMarketMakerPairs[from] && !automatedMarketMakerPairs[to], devDiscount, liquidityDiscount);\r\n            if(allfee > 0) {\r\n\t\t\t    super._transfer(from, address(this), allfee);\r\n            }\r\n\t\t\tamount = amount - allfee;\r\n\t\t}\r\n        super._transfer(from, to, amount);\r\n    }\r\n\r\n    function calculateSwapInAmount(uint256 reserveIn, uint256 userIn)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return\r\n            (Babylonian.sqrt(\r\n                reserveIn * ((userIn * 3988000) + (reserveIn * 3988009))\r\n            ) - (reserveIn * 1997)) / 1994;\r\n    }\r\n\t\r\n\tfunction collectFee(uint256 amount, bool sell, bool p2p, uint256 devDiscount, uint256 liquidityDiscount) private returns (uint256) {\r\n        uint256 totalFee;\r\n\t\t\r\n        uint256 _developmentFee = amount * (p2p ? developmentFee[2] : sell ? developmentFee[1] : developmentFee[0]) / 10000 * (10000 - devDiscount) / 10000;\r\n\t\tdevelopmentFeeTotal = developmentFeeTotal + _developmentFee;\r\n\t\t\r\n\t\tuint256 _liquidityFee = amount * (p2p ? liquidityFee[2] : sell ? liquidityFee[1] : liquidityFee[0]) / 10000 * (10000 - liquidityDiscount) / 10000;\r\n\t\tliquidityFeeTotal = liquidityFeeTotal + _liquidityFee;\r\n\t\t\r\n\t\tuint256 _otherFee = amount * (p2p ? otherFee[2] : sell ? otherFee[1] : otherFee[0]) / 10000;\r\n\t\totherFeeTotal = otherFeeTotal + _otherFee;\r\n\t\t\r\n\t\ttotalFee = _developmentFee + _liquidityFee + _otherFee;\r\n        return totalFee;\r\n    }\r\n\t\r\n\tfunction addLiquidity(uint256 tokenAmount, uint256 usdcAmount) private {\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        IERC20Upgradeable(USDCAddress).approve(address(uniswapV2Router), usdcAmount);\r\n        uniswapV2Router.addLiquidity(\r\n            address(this),\r\n            USDCAddress,\r\n            tokenAmount,\r\n            usdcAmount, \r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\t\r\n\tfunction swapTokensForETH(uint256 tokenAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n\t\t\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n\tfunction swapTokensForUSDC(uint256 tokenAmount, address receiver) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = USDCAddress;\r\n\t\t\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            receiver,\r\n            block.timestamp\r\n        );\r\n    }\r\n\t\r\n\tfunction swapTokensForOther(uint256 tokenAmount) private {\r\n        address[] memory path = new address[](3);\r\n        path[0] = address(this);\r\n        path[1] = USDCAddress;\r\n        path[2] = otherTokenAddress;\r\n\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            otherTokenFeeAddress,\r\n            block.timestamp\r\n        );\r\n    }\r\n\t\r\n\tfunction transferTokens(address tokenAddress, address to, uint256 amount) public onlyOwner {\r\n        IERC20Upgradeable(tokenAddress).transfer(to, amount);\r\n        if(tokenAddress == address(this)) {\r\n            uint256 totalBalance = balanceOf(address(this));\r\n            developmentFeeTotal = totalBalance * developmentFee[2] / (developmentFee[2] + liquidityFee[2]);\r\n            liquidityFeeTotal = totalBalance - developmentFeeTotal;\r\n        }\r\n    }\r\n\t\r\n\tfunction migrateETH(address payable recipient) public onlyOwner {\r\n        AddressUpgradeable.sendValue(recipient, address(this).balance);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeMaxWalletToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"isBanned\",\"type\":\"bool\"}],\"name\":\"SetBlacklist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"TradingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"OBLOXNFT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDCAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"developmentFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developmentFeeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromMaxWalletToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDevelopmentFeeTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidityFeeTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initsecond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initthird\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromMaxWalletToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"migrateETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"otherFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"otherTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"otherTokenFeeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBanned\",\"type\":\"bool\"}],\"name\":\"setBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"isBanned\",\"type\":\"bool\"}],\"name\":\"setBlacklistBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"p2p\",\"type\":\"uint256\"}],\"name\":\"setDevelopmentFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setDevelopmentFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setDevelopmentFeeTotal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"p2p\",\"type\":\"uint256\"}],\"name\":\"setLiquidityFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setLiquidityFeeTotal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"p2p\",\"type\":\"uint256\"}],\"name\":\"setOtherFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setOtherTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setOtherTokenFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setTokenDiscountEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_token2Discount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_token3Discount\",\"type\":\"uint256\"}],\"name\":\"setTokensDiscount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_token2DiscountBuyDev\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_token2DiscountBuyLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_token3DiscountBuyDev\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_token3DiscountBuyLiquidity\",\"type\":\"uint256\"}],\"name\":\"setTokensDiscountOnBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_token2DiscountSellDev\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_token2DiscountSellLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_token3DiscountSellDev\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_token3DiscountSellLiquidity\",\"type\":\"uint256\"}],\"name\":\"setTokensDiscountOnSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token2Discount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token2DiscountBuyDev\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token2DiscountBuyLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token2DiscountSellDev\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token2DiscountSellLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token3Discount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token3DiscountBuyDev\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token3DiscountBuyLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token3DiscountSellDev\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token3DiscountSellLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenDiscountEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2_OBLOXUSDCPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "OceidonBlox", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8e0b30c44c9820e5cbc89d0e4039d718dd1094c1b286b20f5bbfdf0c8e5b6816"}]}