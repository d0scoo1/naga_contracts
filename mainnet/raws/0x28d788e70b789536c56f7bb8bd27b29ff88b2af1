{"status": "1", "message": "OK", "result": [{"SourceCode": "/**\r\n\u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2580\u2588\u2580\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580\u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2580\u2580\u2588\r\n\u2591\u2592\u2588\u2591\u2591\u2591\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2580\u2591\u2592\u2588\u2584\u2584\u2580\u2591\u2591\u2580\u2580\u2580\u2584\u2584\r\n\u2591\u2592\u2588\u2584\u2584\u2580\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2584\u2584\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2584\u2584\u2584\u2588\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\n\r\nlibrary Strings {\r\n\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n\r\n\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval( address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner,address indexed operator,bool approved);\r\n    \r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from,address to,uint256 tokenId) external;\r\n    function transferFrom(address from,address to,uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId)external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator)external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\ninterface IERC721Enumerable is IERC721 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index)external view returns (uint256);\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\ninterface IERC721Metadata is IERC721 {\r\n \r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n\r\n    function onERC721Received(address operator,address from,uint256 tokenId,bytes calldata data) external returns (bytes4);\r\n}\r\n\r\nerror ApprovalCallerNotOwnerNorApproved();\r\nerror ApprovalQueryForNonexistentToken();\r\nerror ApproveToCaller();\r\nerror ApprovalToCurrentOwner();\r\nerror BalanceQueryForZeroAddress();\r\nerror MintedQueryForZeroAddress();\r\nerror MintToZeroAddress();\r\nerror MintZeroQuantity();\r\nerror OwnerIndexOutOfBounds();\r\nerror OwnerQueryForNonexistentToken();\r\nerror TokenIndexOutOfBounds();\r\nerror TransferCallerNotOwnerNorApproved();\r\nerror TransferFromIncorrectOwner();\r\nerror TransferToNonERC721ReceiverImplementer();\r\nerror TransferToZeroAddress();\r\nerror UnableDetermineTokenOwner();\r\nerror URIQueryForNonexistentToken();\r\n\r\ncontract ERC721A is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable{\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n    struct TokenOwnership {\r\n        address addr;\r\n        uint64 startTimestamp;\r\n    }\r\n\r\n    struct AddressData {\r\n        uint128 balance;\r\n        uint128 numberMinted;\r\n    }\r\n\r\n    uint256 internal _currentIndex;\r\n \r\n\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    mapping(uint256 => TokenOwnership) internal _ownerships;\r\n    mapping(address => AddressData) private _addressData;\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _currentIndex;\r\n    }\r\n\r\n    function tokenByIndex(uint256 index)public  view  override  returns (uint256){\r\n        if (index >= totalSupply()) revert TokenIndexOutOfBounds();\r\n        return index;\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index)public view override returns (uint256 a){\r\n        if (index >= balanceOf(owner)) revert OwnerIndexOutOfBounds();\r\n        uint256 numMintedSoFar = totalSupply();\r\n        uint256 tokenIdsIdx;\r\n        address currOwnershipAddr;\r\n\r\n        // Counter overflow is impossible as the loop breaks when uint256 i is equal to another uint256 numMintedSoFar.\r\n        unchecked {\r\n            for (uint256 i; i < numMintedSoFar; i++) {\r\n                TokenOwnership memory ownership = _ownerships[i];\r\n                if (ownership.addr != address(0)) {\r\n                    currOwnershipAddr = ownership.addr;\r\n                }\r\n                if (currOwnershipAddr == owner) {\r\n                    if (tokenIdsIdx == index) {\r\n                        return i;\r\n                    }\r\n                    tokenIdsIdx++;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Execution should never reach this point.\r\n        assert(false);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)public view virtual override(ERC165, IERC165) returns (bool){\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            interfaceId == type(IERC721Enumerable).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function balanceOf(address owner) public view override returns (uint256) {\r\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\r\n        return uint256(_addressData[owner].balance);\r\n    }\r\n\r\n    function _numberMinted(address owner) internal view returns (uint256) {\r\n        if (owner == address(0)) revert MintedQueryForZeroAddress();\r\n        return uint256(_addressData[owner].numberMinted);\r\n    }\r\n\r\n    /**\r\n     * Gas spent here starts off proportional to the maximum mint batch size.\r\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\r\n     */\r\n    function ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory){\r\n        if (!_exists(tokenId)) revert OwnerQueryForNonexistentToken();\r\n\r\n        unchecked {\r\n            for (uint256 curr = tokenId; curr >= 0; curr--) {\r\n                TokenOwnership memory ownership = _ownerships[curr];\r\n                if (ownership.addr != address(0)) {\r\n                    return ownership;\r\n                }\r\n            }\r\n        }\r\n\r\n        revert UnableDetermineTokenOwner();\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view override returns (address) {\r\n        return ownershipOf(tokenId).addr;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory){\r\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n    }\r\n\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) public override {\r\n        address owner = ERC721A.ownerOf(tokenId);\r\n        if (to == owner) revert ApprovalToCurrentOwner();\r\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender()))\r\n            revert ApprovalCallerNotOwnerNorApproved();\r\n\r\n        _approve(to, tokenId, owner);\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) public view override returns (address){\r\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved)public override{\r\n        if (operator == _msgSender()) revert ApproveToCaller();\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator)  public view virtual override returns (bool){\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function transferFrom( address from, address to, uint256 tokenId) public virtual override {\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public override {\r\n        _transfer(from, to, tokenId);\r\n        if (!_checkOnERC721Received(from, to, tokenId, _data))\r\n            revert TransferToNonERC721ReceiverImplementer();\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        return tokenId < _currentIndex;\r\n    }\r\n\r\n    function _safeMint(address to, uint256 quantity) internal {\r\n        _safeMint(to, quantity, \"\");\r\n    }\r\n\r\n    function _safeMint(  address to, uint256 quantity, bytes memory _data) internal {\r\n        _mint(to, quantity, _data, true);\r\n    }\r\n\r\n    function _mint(address to, uint256 quantity, bytes memory _data, bool safe) internal {\r\n        uint256 startTokenId = _currentIndex;\r\n        if (to == address(0)) revert MintToZeroAddress();\r\n        if (quantity == 0) revert MintZeroQuantity();\r\n\r\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n        // Overflows are incredibly unrealistic.\r\n        // balance or numberMinted overflow if current value of either + quantity > 3.4e38 (2**128) - 1\r\n        // updatedIndex overflows if _currentIndex + quantity > 1.56e77 (2**256) - 1\r\n        unchecked {\r\n            _addressData[to].balance += uint128(quantity);\r\n            _addressData[to].numberMinted += uint128(quantity);\r\n\r\n            _ownerships[startTokenId].addr = to;\r\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\r\n\r\n            uint256 updatedIndex = startTokenId;\r\n\r\n            for (uint256 i; i < quantity; i++) {\r\n                emit Transfer(address(0), to, updatedIndex);\r\n                if (\r\n                    safe &&\r\n                    !_checkOnERC721Received(address(0), to, updatedIndex, _data)\r\n                )\r\n                 {\r\n                    revert TransferToNonERC721ReceiverImplementer();\r\n                }\r\n\r\n                updatedIndex++;\r\n            }\r\n\r\n            _currentIndex = updatedIndex;\r\n\r\n           \r\n               \r\n            \r\n        }\r\n\r\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 tokenId) private {\r\n        TokenOwnership memory prevOwnership = ownershipOf(tokenId);\r\n        bool isApprovedOrOwner = (_msgSender() == prevOwnership.addr || getApproved(tokenId) == _msgSender() || isApprovedForAll(prevOwnership.addr, _msgSender()));\r\n\r\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\r\n        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();\r\n        if (to == address(0)) revert TransferToZeroAddress();\r\n        _beforeTokenTransfers(from, to, tokenId, 1);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId, prevOwnership.addr);\r\n\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\r\n        unchecked {\r\n            _addressData[from].balance -= 1;\r\n            _addressData[to].balance += 1;\r\n\r\n            _ownerships[tokenId].addr = to;\r\n            _ownerships[tokenId].startTimestamp = uint64(block.timestamp);\r\n\r\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\r\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\r\n            uint256 nextTokenId = tokenId + 1;\r\n            if (_ownerships[nextTokenId].addr == address(0)) {\r\n                if (_exists(nextTokenId)) {\r\n                    _ownerships[nextTokenId].addr = prevOwnership.addr;\r\n                    _ownerships[nextTokenId].startTimestamp = prevOwnership\r\n                        .startTimestamp;\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, tokenId);\r\n        _afterTokenTransfers(from, to, tokenId, 1);\r\n    }\r\n\r\n    function _approve( address to, uint256 tokenId, address owner) private {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    function _checkOnERC721Received(address from,address to, uint256 tokenId, bytes memory _data) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try\r\n                IERC721Receiver(to).onERC721Received(\r\n                    _msgSender(),\r\n                    from,\r\n                    tokenId,\r\n                    _data\r\n                )\r\n            returns (bytes4 retval) {\r\n                return retval == IERC721Receiver(to).onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0)\r\n                    revert TransferToNonERC721ReceiverImplementer();\r\n                else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfers(address from, address to, uint256 startTokenId, uint256 quantity) internal virtual {}\r\n    function _afterTokenTransfers(address from, address to, uint256 startTokenId, uint256 quantity) internal virtual {}\r\n}\r\n\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs & pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = _efficientHash(computedHash, proofElement);\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = _efficientHash(proofElement, computedHash);\r\n            }\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b)\r\n        private\r\n        pure\r\n        returns (bytes32 value)\r\n    {\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n\r\ncontract DRAGONSOFMIDGARD is ERC721A, Ownable {\r\n    \r\n    uint256 public maxSupply = 5555;\r\n    uint256 public reserveQuantity = 169;\r\n    uint256 private winnersQuantity=50;\r\n    uint256 public price = 0.1 ether;\r\n    uint256 public preSaleSupply = 2277;\r\n    uint256 public preSalePrice = 0.07 ether;\r\n    uint256 public maxPerWallet = 2;\r\n    uint256 public maxPerTransaction = 5;\r\n    bytes32 private merkleRoot;\r\n    string  public _baseURI1;\r\n    bool    public isPaused =true;\r\n    bool    public isPreSalePaused =true;\r\n    IERC721 public _juvenileObj;\r\n    IERC721 public _ancientObj;\r\n    IERC721 public _greatWyrmObj;\r\n    IERC721 public deployedDragon;\r\n\r\n    struct UserPreSaleCounter {    \r\n        uint256 counter;\r\n    }\r\n\r\n    struct EVOLVING {\r\n        bool juvenileAge;\r\n        bool ancientAge;\r\n        bool greatWyrmAge;\r\n    }\r\n\r\n    mapping(address => UserPreSaleCounter)  public  _preSaleCounter;\r\n    mapping(address => bool)                public  _preSaleAddressExist;\r\n    mapping(uint256 => EVOLVING)            public   evolving;\r\n    mapping(address =>bool)                 public   oldNftAddressExist;\r\n    \r\n    constructor(string memory baseUri) ERC721A(\"DragonsOfMidgard\", \"DRAGONS\") {\r\n        _baseURI1= baseUri;\r\n    }\r\n\r\n    function setMaxSupply(uint256 _maxSupply) public onlyOwner {\r\n        maxSupply = _maxSupply;\r\n    }\r\n\r\n    function setReserve(uint256 _reserve) public onlyOwner {\r\n        reserveQuantity = _reserve;\r\n    }\r\n\r\n    function setWinnersQuantity(uint256 _winnersQuantity) public onlyOwner {\r\n        require(_winnersQuantity < maxSupply, \"amount exceeds\");\r\n        winnersQuantity = _winnersQuantity;\r\n    }\r\n\r\n    function setPrice(uint256 _price) public onlyOwner {\r\n        price = _price;\r\n    }\r\n    \r\n    function setPresaleSupply(uint256 _preSaleSupply) public onlyOwner {\r\n        preSaleSupply = _preSaleSupply;\r\n    }\r\n    \r\n    function setPreSalePrice(uint256 _price) public onlyOwner {\r\n        preSalePrice = _price;\r\n    }\r\n    \r\n    function setMaxPerWallet(uint256 quantity) public onlyOwner {\r\n        maxPerWallet = quantity;\r\n    }\r\n    \r\n    function setMaxPerTrasaction(uint256 quantity) public onlyOwner {\r\n        maxPerTransaction = quantity;\r\n    }\r\n\r\n    function setRoot(bytes32 root) public onlyOwner {\r\n        merkleRoot = root;\r\n    }\r\n\r\n    function setBaseURI(string memory baseuri) public onlyOwner {\r\n        _baseURI1 = baseuri;\r\n    }\r\n    \r\n    function flipPauseStatus() public onlyOwner {\r\n        isPaused = !isPaused;\r\n    }\r\n\r\n    function flipPreSalePauseStatus() public onlyOwner {\r\n        isPreSalePaused = !isPreSalePaused;\r\n    }\r\n\r\n    function setJuvenile(address juvenileAddress) public onlyOwner {\r\n        _juvenileObj = IERC721(juvenileAddress);\r\n    }\r\n\r\n    function setAncient(address ancientAddress) public onlyOwner {\r\n        _ancientObj = IERC721(ancientAddress);\r\n    }\r\n\r\n    function setGreatWyrm(address greatWyrm) public onlyOwner {\r\n        _greatWyrmObj = IERC721(greatWyrm);\r\n    }\r\n\r\n    function setDragonAddress(address contractaddress) public onlyOwner {\r\n        deployedDragon = IERC721(contractaddress);\r\n    }\r\n        \r\n    function _baseURI()internal view override  returns (string memory){\r\n        return _baseURI1;\r\n    }\r\n\r\n    function mint(uint256 quantity) public payable {\r\n        require(quantity > 0 ,\"quantity should be greater than 0\");\r\n        require(isPaused==false,\"minting is stopped\");\r\n        require(quantity <=maxPerTransaction,\"per transaction amount exceeds\");\r\n        require(totalSupply()+quantity<=maxSupply-reserveQuantity-winnersQuantity,\"all tokens have been minted\");\r\n        require(price*quantity == msg.value, \"Sent ether value is incorrect\");\r\n        _safeMint(msg.sender, quantity);\r\n    }\r\n\r\n    function reserve(uint256 quantity) public onlyOwner {\r\n        require(quantity <= reserveQuantity, \"the quantity exceeds reserve\");\r\n        reserveQuantity -= quantity;\r\n        _safeMint(msg.sender, quantity);\r\n    }\r\n\r\n    function mintPreSale(bytes32[] calldata _merkleProof, uint256 quantity) public payable {\r\n         if (_preSaleAddressExist[msg.sender] == false) {\r\n            _preSaleCounter[msg.sender] = UserPreSaleCounter({\r\n                counter: 0\r\n            });\r\n            _preSaleAddressExist[msg.sender] = true;\r\n        }  \r\n        require(isPreSalePaused== false, \"turn on minting\");\r\n        require(_preSaleCounter[msg.sender].counter + quantity <= maxPerWallet, \"Sorry can not mint more than maxwallet\");\r\n        require(quantity > 0, \"zero not allowed\");\r\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\r\n        require(\r\n            MerkleProof.verify(_merkleProof, merkleRoot, leaf),\r\n            \"Invalid Proof\"\r\n        );\r\n        require(totalSupply() + quantity <= preSaleSupply, \"presale amount exceeds\");\r\n        require(preSalePrice*quantity==msg.value,\"invalid amount\");\r\n        _safeMint(msg.sender,quantity);\r\n        _preSaleCounter[msg.sender].counter += quantity;\r\n    }\r\n\r\n    function tokensOfOwner(address _owner)public view returns (uint256[] memory) {\r\n        uint256 count = balanceOf(_owner);\r\n        uint256[] memory result = new uint256[](count);\r\n        for (uint256 index = 0; index < count; index++) {\r\n            result[index] = tokenOfOwnerByIndex(_owner, index);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function enterage(uint256 tokenid, string memory age) external {\r\n        if (keccak256(abi.encodePacked(age)) == keccak256(abi.encodePacked(\"juvenile\"))) {\r\n            _juvenileObj.ownerOf(tokenid) == msg.sender;\r\n            evolving[tokenid].juvenileAge = true;\r\n        }\r\n         else if (keccak256(abi.encodePacked(age)) == keccak256(abi.encodePacked(\"ancient\"))) {\r\n            _ancientObj.ownerOf(tokenid) == msg.sender;\r\n            evolving[tokenid].ancientAge = true;\r\n        }\r\n         else if (keccak256(abi.encodePacked(age)) == keccak256(abi.encodePacked(\"greatwyrm\"))) {\r\n            _greatWyrmObj.ownerOf(tokenid) == msg.sender;\r\n            evolving[tokenid].greatWyrmAge = true;\r\n        } else {\r\n            revert(\"wrong age entered\");\r\n        }\r\n    }\r\n    \r\n    function OldNftHolders(uint startIndex ,uint endIndex)public onlyOwner { \r\n        address owner;\r\n        for(uint i=startIndex; i<= endIndex; i++){\r\n            owner = deployedDragon.ownerOf(i);\r\n            if(oldNftAddressExist[owner]==false){\r\n            uint256  nftBalance  =   deployedDragon.balanceOf(owner);\r\n            _safeMint(owner,nftBalance);\r\n            oldNftAddressExist[owner]=true;\r\n        }\r\n      }\r\n    }\r\n      \r\n    function airDropForWinners(address[] memory _accounts,uint [] memory _balances)public onlyOwner { \r\n        for(uint i=0; i< _accounts.length; i++){\r\n            _safeMint(_accounts[i],_balances[i]);\r\n            winnersQuantity-=_balances[i];\r\n        }\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        uint balance = address(this).balance;\r\n        payable(msg.sender).transfer(balance);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseUri\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalToCurrentOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveToCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerIndexOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenIndexOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnableDetermineTokenOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"OldNftHolders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ancientObj\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_baseURI1\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_greatWyrmObj\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_juvenileObj\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_preSaleAddressExist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_preSaleCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_balances\",\"type\":\"uint256[]\"}],\"name\":\"airDropForWinners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployedDragon\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"age\",\"type\":\"string\"}],\"name\":\"enterage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"evolving\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"juvenileAge\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ancientAge\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"greatWyrmAge\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flipPauseStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flipPreSalePauseStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPreSalePaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPerTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPerWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"mintPreSale\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"oldNftAddressExist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preSalePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preSaleSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"reserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveQuantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ancientAddress\",\"type\":\"address\"}],\"name\":\"setAncient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseuri\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractaddress\",\"type\":\"address\"}],\"name\":\"setDragonAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"greatWyrm\",\"type\":\"address\"}],\"name\":\"setGreatWyrm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"juvenileAddress\",\"type\":\"address\"}],\"name\":\"setJuvenile\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"setMaxPerTrasaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"setMaxPerWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"}],\"name\":\"setMaxSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPreSalePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_preSaleSupply\",\"type\":\"uint256\"}],\"name\":\"setPresaleSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reserve\",\"type\":\"uint256\"}],\"name\":\"setReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"setRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_winnersQuantity\",\"type\":\"uint256\"}],\"name\":\"setWinnersQuantity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DRAGONSOFMIDGARD", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003268747470733a2f2f6170692e647261676f6e736f666d6964676172642e636f6d2f6170692f6e66742f7779726d6c696e672f0000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a2bc42b4f4a5db9a6b29e1887523f29f4bc207e2d297fd1310b6ae409d463955"}]}