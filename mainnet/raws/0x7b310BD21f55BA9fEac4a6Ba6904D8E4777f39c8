{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Sale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\ncontract MetaAndMagicSale {\\n\\n    uint256 constant PS_MAX  = 1;\\n\\n    uint8   public stage; // 0 -> init, 1 -> hero wl, 2 -> hero ps  3 -> item wl sale, 4 -> items hero sale ,5 -> items public sale \\n    bytes32 public root;\\n\\n    Sale public heroes;\\n    Sale public items;\\n\\n    struct Sale { address token; uint16  left; uint16 amtPs; uint32  priceWl; uint32  pricePS; }\\n\\n    function initialize(address heroes_, address items_) external {\\n        require(msg.sender == _owner(), \\\"not allowed\\\");\\n\\n        heroes = Sale(heroes_, 3_000, 1, 15, 20);\\n        items  = Sale(items_,  9_863, 5, 5, 8);\\n    }\\n\\n    // ADMIN FUNCTION\\n    function moveStage() external {\\n        require(msg.sender == _owner(), \\\"not allowed\\\");\\n        stage++;\\n    }\\n\\n    function setRoot(bytes32 root_) external {\\n        require(msg.sender == _owner(), \\\"not allowed\\\");\\n        root = root_;\\n    }\\n\\n    function withdraw(address destination) external {\\n        require(msg.sender == _owner(), \\\"not allowed\\\");\\n\\n        (bool succ, ) = destination.call{value: address(this).balance}(\\\"\\\");\\n        require(succ, \\\"failed\\\");\\n    }\\n\\n    function ownerMint(address token, address destination, uint256 quantity) external {\\n        require(msg.sender == _owner(), \\\"not allowed\\\");\\n\\n        if (token == heroes.token) {\\n            heroes.left -= uint16(quantity);\\n        } else if (token == items.token) {\\n            items.left -= uint16(quantity);\\n        }\\n        IERC721MM(token).mint(destination, quantity, 2);\\n    }\\n\\n    function mint(uint256 amt) external payable returns(uint256 id) {\\n        uint256 cacheStage = stage; \\n\\n        require(cacheStage == 2 ||cacheStage == 5, \\\"not on public sale\\\");\\n\\n        Sale memory sale = cacheStage == 5 ? items : heroes;\\n        \\n        // Make sure use sent enough money\\n        require(uint256(sale.pricePS) * amt * 1e16 == msg.value, \\\"not enough sent\\\");\\n\\n        // Make sure that user is only minting the allowed amount\\n        uint256 minted  = IERC721MM(sale.token).publicMinted(msg.sender);\\n        require(minted + amt <= sale.amtPs, \\\"already minted\\\");\\n\\n        // Effects\\n        sale.left -= uint16(amt);   \\n\\n        if (cacheStage == 5) {\\n            items  = sale;\\n        } else {\\n            heroes = sale;\\n        }\\n\\n        // Interactions\\n        id = IERC721MM(sale.token).mint(msg.sender, amt, 2);\\n    }\\n\\n    function mint(uint256 allowedAmount, uint8 stage_, uint256 amount,  bytes32[] calldata proof_) external payable returns(uint256 id){\\n        uint256 cacheStage = stage; \\n        Sale memory sale   = cacheStage >= 3 ? items : heroes;\\n\\n        // Make sure use sent enough money \\n        require(amount > 0, \\\"zero amount\\\");\\n        require(uint256(sale.priceWl) * 1e16 * amount == msg.value, \\\"not enough sent\\\");\\n\\n        // Make sure sale is open\\n        require(stage_ == cacheStage, \\\"wrong stage\\\");\\n\\n        // Make sure that user is only minting the allowed amount\\n        uint256 minted  = IERC721MM(sale.token).listMinted(msg.sender);\\n        require(minted + amount <= allowedAmount, \\\"already minted\\\");\\n\\n        bytes32 leaf_ = keccak256(abi.encode(allowedAmount, stage_, msg.sender));\\n        require(_verify(proof_, root, leaf_), \\\"not on list\\\");\\n\\n        // Effects\\n        sale.left -= uint16(amount);\\n\\n        if (cacheStage >= 3) {\\n            items = sale;\\n        } else {\\n            heroes = sale;\\n        }\\n\\n        id = IERC721MM(sale.token).mint(msg.sender, amount, 1);\\n    }\\n\\n    function _verify(bytes32[] memory proof_, bytes32 root_, bytes32 leaf_) internal pure returns (bool allowed) {\\n       allowed =  MerkleProof.verify(proof_, root_, leaf_);\\n    }\\n\\n    function _owner() internal view returns (address owner_) {\\n        bytes32 slot = bytes32(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103);\\n        assembly {\\n            owner_ := sload(slot)\\n        }\\n    }\\n\\n}\\n\\ninterface IERC721MM {\\n    function mint(address to, uint256 amount, uint256 stage) external returns (uint256 id);\\n    function listMinted(address to) external returns (uint256 minted);\\n    function publicMinted(address to) external returns (uint256 minted);\\n}\\n\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = _efficientHash(computedHash, proofElement);\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = _efficientHash(proofElement, computedHash);\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"heroes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"left\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"amtPs\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"priceWl\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"pricePS\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroes_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"items_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"items\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"left\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"amtPs\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"priceWl\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"pricePS\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"allowedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"stage_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof_\",\"type\":\"bytes32[]\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moveStage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"ownerMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"root\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root_\",\"type\":\"bytes32\"}],\"name\":\"setRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MetaAndMagicSale", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}