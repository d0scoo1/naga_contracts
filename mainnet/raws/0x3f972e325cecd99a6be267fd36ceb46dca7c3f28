{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AztecTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nlibrary AztecTypes {\\n    enum AztecAssetType {\\n        NOT_USED,\\n        ETH,\\n        ERC20,\\n        VIRTUAL\\n    }\\n\\n    struct AztecAsset {\\n        uint256 id;\\n        address erc20Address;\\n        AztecAssetType assetType;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/ReentryBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {IDefiBridge} from '../interfaces/IDefiBridge.sol';\\nimport {AztecTypes} from '../AztecTypes.sol';\\nimport {IRollupProcessor} from '../interfaces/IRollupProcessor.sol';\\n\\n/**\\n * @dev Warning: do not deploy in real environments, for testing only\\n */\\ncontract ReentryBridge is IDefiBridge {\\n    /*----------------------------------------\\n      ERROR TAGS\\n      ----------------------------------------*/\\n    error PAUSED();\\n    error NOT_PAUSED();\\n    error LOCKED_NO_REENTER();\\n    error INVALID_PROVIDER();\\n    error THIRD_PARTY_CONTRACTS_FLAG_NOT_SET();\\n    error INSUFFICIENT_DEPOSIT();\\n    error INVALID_ASSET_ID();\\n    error INVALID_ASSET_ADDRESS();\\n    error INVALID_LINKED_TOKEN_ADDRESS();\\n    error INVALID_LINKED_BRIDGE_ADDRESS();\\n    error INVALID_BRIDGE_ID();\\n    error INVALID_BRIDGE_ADDRESS();\\n    error BRIDGE_ID_IS_INCONSISTENT();\\n    error BRIDGE_WITH_IDENTICAL_INPUT_ASSETS(uint256 inputAssetId);\\n    error BRIDGE_WITH_IDENTICAL_OUTPUT_ASSETS(uint256 outputAssetId);\\n    error ZERO_TOTAL_INPUT_VALUE();\\n    error ARRAY_OVERFLOW();\\n    error MSG_VALUE_WRONG_AMOUNT();\\n    error INSUFFICIENT_ETH_PAYMENT();\\n    error WITHDRAW_TO_ZERO_ADDRESS();\\n    error DEPOSIT_TOKENS_WRONG_PAYMENT_TYPE();\\n    error INSUFFICIENT_TOKEN_APPROVAL();\\n    error NONZERO_OUTPUT_VALUE_ON_NOT_USED_ASSET(uint256 outputValue);\\n    error INCORRECT_STATE_HASH(bytes32 oldStateHash, bytes32 newStateHash);\\n    error INCORRECT_DATA_START_INDEX(uint256 providedIndex, uint256 expectedIndex);\\n    error INCORRECT_PREVIOUS_DEFI_INTERACTION_HASH(\\n        bytes32 providedDefiInteractionHash,\\n        bytes32 expectedDefiInteractionHash\\n    );\\n    error PUBLIC_INPUTS_HASH_VERIFICATION_FAILED(uint256, uint256);\\n    error PROOF_VERIFICATION_FAILED();\\n\\n    address public immutable rollupProcessor;\\n\\n    struct Action {\\n        uint256 id;\\n        uint256 nonce;\\n        bool noOp;\\n        bool canFinalise;\\n        bool isAsync;\\n        bytes nextAction;\\n        uint256 a;\\n        uint256 b;\\n    }\\n\\n    mapping(uint256 => bool) public executed;\\n    uint256 idCount;\\n    Action[] public actions;\\n\\n    bool public died;\\n\\n    uint256 public lastNonce;\\n\\n    receive() external payable {}\\n\\n    constructor(address _rollupProcessor) {\\n        rollupProcessor = _rollupProcessor;\\n    }\\n\\n    function addAction(\\n        uint256 _nonce,\\n        bool _isAsync,\\n        bool _canFinalise,\\n        bool _noOp,\\n        bytes memory _nextAction,\\n        uint256 _a,\\n        uint256 _b\\n    ) external {\\n        Action memory action = Action({\\n            id: idCount++,\\n            nonce: _nonce,\\n            isAsync: _isAsync,\\n            canFinalise: _canFinalise,\\n            noOp: _noOp,\\n            nextAction: _nextAction,\\n            a: _a,\\n            b: _b\\n        });\\n        actions.push(action);\\n    }\\n\\n    function convert(\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        uint256,\\n        uint256,\\n        uint64,\\n        address\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            bool\\n        )\\n    {\\n        Action memory action = actions[actions.length - 1];\\n        bool isAsync = action.isAsync;\\n\\n        if (isAsync) {\\n            return (0, 0, isAsync);\\n        }\\n\\n        execute();\\n        return (action.a, action.b, isAsync);\\n    }\\n\\n    function canFinalise(uint256) external view override returns (bool) {\\n        return actions[actions.length - 1].canFinalise;\\n    }\\n\\n    function finalise(\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        uint256,\\n        uint64\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            bool\\n        )\\n    {\\n        require(msg.sender == rollupProcessor, 'invalid sender!');\\n\\n        (uint256 a, uint256 b) = execute();\\n\\n        return (a, b, true);\\n    }\\n\\n    function execute() internal returns (uint256, uint256) {\\n        Action memory action = actions[actions.length - 1];\\n        executed[action.id] = true;\\n        actions.pop();\\n\\n        lastNonce = action.nonce;\\n        IRollupProcessor(rollupProcessor).receiveEthFromBridge{value: 1}(action.nonce);\\n\\n        if (!action.noOp) {\\n            (bool success, ) = rollupProcessor.call(action.nextAction);\\n            assembly {\\n                if iszero(success) {\\n                    returndatacopy(0, 0, returndatasize())\\n                    revert(0, returndatasize())\\n                }\\n            }\\n            if (!success) {\\n                died = true;\\n            }\\n        }\\n\\n        return (action.a, action.b);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDefiBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {AztecTypes} from '../AztecTypes.sol';\\n\\ninterface IDefiBridge {\\n    function convert(\\n        AztecTypes.AztecAsset memory inputAssetA,\\n        AztecTypes.AztecAsset memory inputAssetB,\\n        AztecTypes.AztecAsset memory outputAssetA,\\n        AztecTypes.AztecAsset memory outputAssetB,\\n        uint256 totalInputValue,\\n        uint256 interactionNonce,\\n        uint64 auxData,\\n        address rollupBeneficiary\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 outputValueA,\\n            uint256 outputValueB,\\n            bool isAsync\\n        );\\n\\n    function canFinalise(uint256 interactionNonce) external view returns (bool);\\n\\n    function finalise(\\n        AztecTypes.AztecAsset memory inputAssetA,\\n        AztecTypes.AztecAsset memory inputAssetB,\\n        AztecTypes.AztecAsset memory outputAssetA,\\n        AztecTypes.AztecAsset memory outputAssetB,\\n        uint256 interactionNonce,\\n        uint64 auxData\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 outputValueA,\\n            uint256 outputValueB,\\n            bool interactionCompleted\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRollupProcessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\ninterface IRollupProcessor {\\n    /*----------------------------------------\\n      MUTATING FUNCTIONS\\n      ----------------------------------------*/\\n\\n    function pause() external;\\n\\n    function unpause() external;\\n\\n    function setRollupProvider(address providerAddress, bool valid) external;\\n\\n    function setVerifier(address verifierAddress) external;\\n\\n    function setAllowThirdPartyContracts(bool _flag) external;\\n\\n    function setDefiBridgeProxy(address feeDistributorAddress) external;\\n\\n    function setSupportedAsset(address linkedToken, uint256 gasLimit) external;\\n\\n    function setSupportedBridge(address linkedBridge, uint256 gasLimit) external;\\n\\n    function processRollup(bytes calldata proofData, bytes calldata signatures) external;\\n\\n    function receiveEthFromBridge(uint256 interactionNonce) external payable;\\n\\n    function approveProof(bytes32 _proofHash) external;\\n\\n    function depositPendingFunds(\\n        uint256 assetId,\\n        uint256 amount,\\n        address owner,\\n        bytes32 proofHash\\n    ) external payable;\\n\\n    function depositPendingFundsPermit(\\n        uint256 assetId,\\n        uint256 amount,\\n        address owner,\\n        bytes32 proofHash,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function depositPendingFundsPermitNonStandard(\\n        uint256 assetId,\\n        uint256 amount,\\n        address owner,\\n        bytes32 proofHash,\\n        uint256 nonce,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function offchainData(\\n        uint256 rollupId,\\n        uint256 chunk,\\n        uint256 totalChunks,\\n        bytes calldata offchainTxData\\n    ) external;\\n\\n    function processAsyncDefiInteraction(uint256 interactionNonce) external returns (bool);\\n\\n    /*----------------------------------------\\n      NON-MUTATING FUNCTIONS\\n      ----------------------------------------*/\\n\\n    function rollupStateHash() external view returns (bytes32);\\n\\n    function userPendingDeposits(uint256 assetId, address userAddress) external view returns (uint256);\\n\\n    function defiBridgeProxy() external view returns (address);\\n\\n    function prevDefiInteractionsHash() external view returns (bytes32);\\n\\n    function paused() external view returns (bool);\\n\\n    function verifier() external view returns (address);\\n\\n    function getDataSize() external view returns (uint256);\\n\\n    function getPendingDefiInteractionHashesLength() external view returns (uint256);\\n\\n    function getDefiInteractionHashesLength() external view returns (uint256);\\n\\n    function getAsyncDefiInteractionHashesLength() external view returns (uint256 res);\\n\\n    function getSupportedBridge(uint256 bridgeAddressId) external view returns (address);\\n\\n    function getSupportedBridgesLength() external view returns (uint256);\\n\\n    function getSupportedAssetsLength() external view returns (uint256);\\n\\n    function getSupportedAsset(uint256 assetId) external view returns (address);\\n\\n    function getBridgeGasLimit(uint256 bridgeAddressId) external view returns (uint256);\\n\\n    function getEscapeHatchStatus() external view returns (bool, uint256);\\n\\n    function getDefiInteractionHashes() external view returns (bytes32[] memory);\\n\\n    function getAsyncDefiInteractionHashes() external view returns (bytes32[] memory);\\n\\n    function getSupportedAssets() external view returns (address[] memory, uint256[] memory);\\n\\n    function getSupportedBridges() external view returns (address[] memory, uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/test/ReenterAsync.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport {IDefiBridge} from '../interfaces/IDefiBridge.sol';\\nimport {AztecTypes} from '../AztecTypes.sol';\\nimport {IRollupProcessor} from '../interfaces/IRollupProcessor.sol';\\n\\n/**\\n * @dev Warning: do not deploy in real environments, for testing only\\n */\\ncontract ReentryAsync is IDefiBridge {\\n    address public immutable rollupProcessor;\\n\\n    uint256 public nonce;\\n    uint256 public counter;\\n    uint256 public aOut;\\n\\n    receive() external payable {}\\n\\n    constructor(address _rollupProcessor) {\\n        rollupProcessor = _rollupProcessor;\\n    }\\n\\n    function setValues(uint256 _nonce, uint256 _aOut) public {\\n        nonce = _nonce;\\n        aOut = _aOut;\\n    }\\n\\n    function convert(\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        uint256,\\n        uint256,\\n        uint64,\\n        address\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            bool\\n        )\\n    {\\n        return (0, 0, true);\\n    }\\n\\n    function canFinalise(uint256) external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    function finalise(\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        uint256,\\n        uint64\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            bool\\n        )\\n    {\\n        require(msg.sender == rollupProcessor, 'invalid sender!');\\n        counter++;\\n\\n        if (counter < 2) {\\n            IRollupProcessor(rollupProcessor).processAsyncDefiInteraction(nonce);\\n        }\\n\\n        IRollupProcessor(rollupProcessor).receiveEthFromBridge{value: aOut}(nonce);\\n\\n        return (aOut, 0, true);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/test/MockDefiBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport {IDefiBridge} from '../interfaces/IDefiBridge.sol';\\nimport {AztecTypes} from '../AztecTypes.sol';\\n\\n/**\\n * @dev Warning: do not deploy in real environments, for testing only\\n */\\ncontract MockDefiBridge is IDefiBridge {\\n    address public immutable rollupProcessor;\\n\\n    bool immutable canConvert;\\n    bool immutable isAsync;\\n    uint256 immutable outputValueA;\\n    uint256 immutable outputValueB;\\n    uint256 immutable returnValueA;\\n    uint256 immutable returnValueB;\\n    uint256 immutable returnInputValue;\\n\\n    mapping(uint256 => uint256) interestRates;\\n\\n    mapping(uint256 => uint256) interactions;\\n\\n    enum AUX_DATA_SELECTOR {\\n        NADA,\\n        OPEN_LOAN,\\n        CLOSE_LOAN,\\n        OPEN_LP,\\n        CLOSE_LP\\n    }\\n\\n    receive() external payable {}\\n\\n    constructor(\\n        address _rollupProcessor,\\n        bool _canConvert,\\n        uint256 _outputValueA,\\n        uint256 _outputValueB,\\n        uint256 _returnValueA,\\n        uint256 _returnValueB,\\n        uint256 _returnInputValue,\\n        bool _isAsync\\n    ) {\\n        rollupProcessor = _rollupProcessor;\\n        canConvert = _canConvert;\\n        outputValueA = _outputValueA;\\n        outputValueB = _outputValueB;\\n        returnValueA = _returnValueA;\\n        returnValueB = _returnValueB;\\n        returnInputValue = _returnInputValue;\\n        isAsync = _isAsync;\\n    }\\n\\n    // Input cases:\\n    // Case1: 1 real input.\\n    // Case2: 1 virtual asset input.\\n    // Case3: 1 real 1 virtual input.\\n\\n    // Output cases:\\n    // 1 real\\n    // 2 real\\n    // 1 real 1 virtual\\n    // 1 virtual\\n\\n    // E2E example use cases.\\n    // 1 1: Swapping.\\n    // 1 2: Swapping with incentives (2nd output reward token).\\n    // 1 3: Borrowing. Lock up collateral, get back loan asset and virtual position asset.\\n    // 1 4: Opening lending position OR Purchasing NFT. Input real asset, get back virtual asset representing NFT or position.\\n    // 2 1: Selling NFT. Input the virtual asset, get back a real asset.\\n    // 2 2: Closing a lending position. Get back original asset and reward asset.\\n    // 2 3: Claiming fees from an open position.\\n    // 2 4: Voting on a 1 4 case.\\n    // 3 1: Repaying a borrow. Return loan plus interest. Get collateral back.\\n    // 3 2: Repaying a borrow. Return loan plus interest. Get collateral plus reward token. (AAVE)\\n    // 3 3: Partial loan repayment.\\n    // 3 4: DAO voting stuff.\\n    function convert(\\n        AztecTypes.AztecAsset memory inputAssetA,\\n        AztecTypes.AztecAsset memory inputAssetB,\\n        AztecTypes.AztecAsset memory outputAssetA,\\n        AztecTypes.AztecAsset memory outputAssetB,\\n        uint256 totalInputValue,\\n        uint256 interactionNonce,\\n        uint64 auxData,\\n        address\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            bool\\n        )\\n    {\\n        require(canConvert, 'MockDefiBridge: canConvert = false');\\n\\n        uint256 modifiedReturnValueA = returnValueA;\\n        if (auxData == uint32(AUX_DATA_SELECTOR.CLOSE_LOAN) && inputAssetB.id > 0) {\\n            require(\\n                inputAssetB.assetType == AztecTypes.AztecAssetType.VIRTUAL,\\n                'MockDefiBridge: INPUT_ASSET_A_NOT_VIRTUAL'\\n            );\\n            // get interest rate from the mapping interestRates\\n            modifiedReturnValueA -= (returnValueA * interestRates[inputAssetB.id]) / 100;\\n        }\\n\\n        if (!isAsync) {\\n            approveTransfer(inputAssetA, returnInputValue, interactionNonce);\\n            approveTransfer(outputAssetA, modifiedReturnValueA, interactionNonce);\\n            approveTransfer(outputAssetB, returnValueB, interactionNonce);\\n        }\\n        interactions[interactionNonce] = totalInputValue;\\n        if (isAsync) {\\n            return (0, 0, isAsync);\\n        }\\n        return (modifiedReturnValueA, returnValueB, isAsync);\\n    }\\n\\n    function recordInterestRate(uint256 interactionNonce, uint256 rate) external {\\n        interestRates[interactionNonce] = rate;\\n    }\\n\\n    function canFinalise(\\n        uint256 /*interactionNonce*/\\n    ) external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    function finalise(\\n        AztecTypes.AztecAsset memory inputAssetA,\\n        AztecTypes.AztecAsset memory, /*inputAssetB*/\\n        AztecTypes.AztecAsset memory outputAssetA,\\n        AztecTypes.AztecAsset memory outputAssetB,\\n        uint256 interactionNonce,\\n        uint64\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            bool\\n        )\\n    {\\n        require(msg.sender == rollupProcessor, 'invalid sender!');\\n        approveTransfer(inputAssetA, returnInputValue, interactionNonce);\\n        approveTransfer(outputAssetA, returnValueA, interactionNonce);\\n        approveTransfer(outputAssetB, returnValueB, interactionNonce);\\n\\n        return (outputValueA, outputValueB, true);\\n    }\\n\\n    function approveTransfer(\\n        AztecTypes.AztecAsset memory asset,\\n        uint256 value,\\n        uint256 interactionNonce\\n    ) internal returns (uint256 msgCallValue) {\\n        if (asset.assetType == AztecTypes.AztecAssetType.ETH) {\\n            msgCallValue = value;\\n            bytes memory payload = abi.encodeWithSignature('receiveEthFromBridge(uint256)', interactionNonce);\\n            (bool success, ) = address(rollupProcessor).call{value: msgCallValue}(payload);\\n            assembly {\\n                if iszero(success) {\\n                    returndatacopy(0x00, 0x00, returndatasize())\\n                    revert(0x00, returndatasize())\\n                }\\n            }\\n        } else if (asset.assetType == AztecTypes.AztecAssetType.ERC20) {\\n            IERC20(asset.erc20Address).approve(rollupProcessor, value);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/FailingBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport {IDefiBridge} from '../interfaces/IDefiBridge.sol';\\nimport {AztecTypes} from '../AztecTypes.sol';\\nimport {IRollupProcessor} from '../interfaces/IRollupProcessor.sol';\\n\\n/**\\n * @dev Warning: do not deploy in real environments, for testing only\\n */\\ncontract FailingBridge is IDefiBridge {\\n    address public immutable rollupProcessor;\\n\\n    bool public complete;\\n    uint256 public nonce;\\n\\n    receive() external payable {}\\n\\n    constructor(address _rollupProcessor) {\\n        rollupProcessor = _rollupProcessor;\\n    }\\n\\n    function setComplete(bool flag, uint256 _nonce) public {\\n        complete = flag;\\n        nonce = _nonce;\\n    }\\n\\n    function convert(\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        uint256,\\n        uint256,\\n        uint64,\\n        address\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            bool\\n        )\\n    {\\n        return (0, 0, true);\\n    }\\n\\n    function canFinalise(uint256) external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    function finalise(\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        uint256,\\n        uint64\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            bool\\n        )\\n    {\\n        require(msg.sender == rollupProcessor, 'invalid sender!');\\n\\n        if (!complete) {\\n            return (0, 0, false);\\n        }\\n\\n        IRollupProcessor(rollupProcessor).receiveEthFromBridge{value: 1}(nonce);\\n\\n        return (1, 0, true);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/FailingAsyncBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport {IDefiBridge} from '../interfaces/IDefiBridge.sol';\\nimport {AztecTypes} from '../AztecTypes.sol';\\nimport {IRollupProcessor} from '../interfaces/IRollupProcessor.sol';\\n\\n/**\\n * @dev Warning: do not deploy in real environments, for testing only\\n */\\ncontract FailingAsyncBridge is IDefiBridge {\\n    address public immutable rollupProcessor;\\n\\n    uint256 public a;\\n    uint256 public b;\\n\\n    receive() external payable {}\\n\\n    constructor(address _rollupProcessor) {\\n        rollupProcessor = _rollupProcessor;\\n    }\\n\\n    function setReturnValues(uint256 _a, uint256 _b) public {\\n        a = _a;\\n        b = _b;\\n    }\\n\\n    function convert(\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        uint256,\\n        uint256,\\n        uint64,\\n        address\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            bool\\n        )\\n    {\\n        return (a, b, true);\\n    }\\n\\n    function canFinalise(uint256) external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    function finalise(\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        AztecTypes.AztecAsset memory,\\n        uint256,\\n        uint64\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            bool\\n        )\\n    {\\n        return (1, 0, true);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/RollupProcessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec.\\npragma solidity >=0.8.4;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\\nimport {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\\n\\nimport {IVerifier} from './interfaces/IVerifier.sol';\\nimport {IRollupProcessor} from './interfaces/IRollupProcessor.sol';\\nimport {IERC20Permit} from './interfaces/IERC20Permit.sol';\\nimport {IDefiBridge} from './interfaces/IDefiBridge.sol';\\n\\nimport {Decoder} from './Decoder.sol';\\nimport {AztecTypes} from './AztecTypes.sol';\\n\\nimport {TokenTransfers} from './libraries/TokenTransfers.sol';\\nimport './libraries/RollupProcessorLibrary.sol';\\n\\n/**\\n * @title Rollup Processor\\n * @dev Smart contract responsible for processing Aztec zkRollups, including relaying them to a verifier\\n * contract for validation and performing all relevant ERC20 token transfers\\n */\\ncontract RollupProcessor is IRollupProcessor, Decoder, Initializable, AccessControl {\\n    /*----------------------------------------\\n      ERROR TAGS\\n      ----------------------------------------*/\\n    error PAUSED();\\n    error NOT_PAUSED();\\n    error LOCKED_NO_REENTER();\\n    error INVALID_PROVIDER();\\n    error THIRD_PARTY_CONTRACTS_FLAG_NOT_SET();\\n    error INSUFFICIENT_DEPOSIT();\\n    error INVALID_ASSET_ID();\\n    error INVALID_ASSET_ADDRESS();\\n    error INVALID_LINKED_TOKEN_ADDRESS();\\n    error INVALID_LINKED_BRIDGE_ADDRESS();\\n    error INVALID_BRIDGE_ID();\\n    error INVALID_BRIDGE_ADDRESS();\\n    error BRIDGE_ID_IS_INCONSISTENT();\\n    error BRIDGE_WITH_IDENTICAL_INPUT_ASSETS(uint256 inputAssetId);\\n    error BRIDGE_WITH_IDENTICAL_OUTPUT_ASSETS(uint256 outputAssetId);\\n    error ZERO_TOTAL_INPUT_VALUE();\\n    error ARRAY_OVERFLOW();\\n    error MSG_VALUE_WRONG_AMOUNT();\\n    error INSUFFICIENT_ETH_PAYMENT();\\n    error WITHDRAW_TO_ZERO_ADDRESS();\\n    error DEPOSIT_TOKENS_WRONG_PAYMENT_TYPE();\\n    error INSUFFICIENT_TOKEN_APPROVAL();\\n    error NONZERO_OUTPUT_VALUE_ON_NOT_USED_ASSET(uint256 outputValue);\\n    error INCORRECT_STATE_HASH(bytes32 oldStateHash, bytes32 newStateHash);\\n    error INCORRECT_DATA_START_INDEX(uint256 providedIndex, uint256 expectedIndex);\\n    error INCORRECT_PREVIOUS_DEFI_INTERACTION_HASH(\\n        bytes32 providedDefiInteractionHash,\\n        bytes32 expectedDefiInteractionHash\\n    );\\n    error PUBLIC_INPUTS_HASH_VERIFICATION_FAILED(uint256, uint256);\\n    error PROOF_VERIFICATION_FAILED();\\n\\n    /*----------------------------------------\\n      EVENTS\\n      ----------------------------------------*/\\n    event OffchainData(uint256 indexed rollupId, uint256 chunk, uint256 totalChunks, address sender);\\n    event RollupProcessed(uint256 indexed rollupId, bytes32[] nextExpectedDefiHashes, address sender);\\n    event DefiBridgeProcessed(\\n        uint256 indexed bridgeId,\\n        uint256 indexed nonce,\\n        uint256 totalInputValue,\\n        uint256 totalOutputValueA,\\n        uint256 totalOutputValueB,\\n        bool result,\\n        bytes errorReason\\n    );\\n    event AsyncDefiBridgeProcessed(uint256 indexed bridgeId, uint256 indexed nonce, uint256 totalInputValue);\\n    event Deposit(uint256 indexed assetId, address indexed depositorAddress, uint256 depositValue);\\n    event WithdrawError(bytes errorReason);\\n    event AssetAdded(uint256 indexed assetId, address indexed assetAddress, uint256 assetGasLimit);\\n    event BridgeAdded(uint256 indexed bridgeAddressId, address indexed bridgeAddress, uint256 bridgeGasLimit);\\n    event RollupProviderUpdated(address indexed providerAddress, bool valid);\\n    event VerifierUpdated(address indexed verifierAddress);\\n    event Paused(address account);\\n    event Unpaused(address account);\\n\\n    /*----------------------------------------\\n      STRUCTS\\n      ----------------------------------------*/\\n\\n    enum Lock {\\n        UNLOCKED,\\n        ALLOW_ASYNC_REENTER,\\n        LOCKED\\n    }\\n\\n    /**\\n     * @dev RollupState struct contains the following data (offsets are for when used as storage slot):\\n     *\\n     * | bit offset   | num bits    | description |\\n     * | ---          | ---         | ---         |\\n     * | 0            | 160         | PLONK verifier contract address |\\n     * | 160          | 32          | datasize: number of filled entries in note tree |\\n     * | 192          | 16          | asyncDefiInteractionHashes.length : number of entries in asyncDefiInteractionHashes array |\\n     * | 208          | 16          | defiInteractionHashes.length : number of entries in defiInteractionHashes array |\\n     * | 224          | 8           | Lock enum used to guard against reentrancy attacks (minimum value to store in is uint8)\\n     * |\u00a0232          | 8           | pause flag, true if contract is paused, false otherwise\\n     */\\n    struct RollupState {\\n        IVerifier verifier;\\n        uint32 datasize;\\n        uint16 numAsyncDefiInteractionHashes;\\n        uint16 numDefiInteractionHashes;\\n        Lock lock;\\n        bool paused;\\n    }\\n\\n    /**\\n     * @dev Contains information that describes a specific DeFi bridge\\n     * @notice A single smart contract can be used to represent multiple bridges\\n     *\\n     * @param bridgeAddressId the bridge contract address = supportedBridges[bridgeAddressId]\\n     * @param bridgeAddress   the bridge contract address\\n     * @param inputAssetIdA\\n     */\\n    struct BridgeData {\\n        uint256 bridgeAddressId;\\n        address bridgeAddress;\\n        uint256 inputAssetIdA;\\n        uint256 inputAssetIdB;\\n        uint256 outputAssetIdA;\\n        uint256 outputAssetIdB;\\n        uint256 auxData;\\n        bool firstInputVirtual;\\n        bool secondInputVirtual;\\n        bool firstOutputVirtual;\\n        bool secondOutputVirtual;\\n        bool secondInputInUse;\\n        bool secondOutputInUse;\\n        uint256 bridgeGasLimit;\\n    }\\n\\n    /**\\n     * @dev Represents an asynchronous defi bridge interaction that has not been resolved\\n     * @param bridgeId the bridge id\\n     * @param totalInputValue number of tokens/wei sent to the bridge\\n     */\\n    struct PendingDefiBridgeInteraction {\\n        uint256 bridgeId;\\n        uint256 totalInputValue;\\n    }\\n\\n    /**\\n     * @dev Container for the results of a DeFi interaction\\n     * @param outputValueA number of returned tokens for the interaction's first output asset\\n     * @param outputValueB number of returned tokens for the interaction's second output asset (if relevant)\\n     * @param isAsync is the interaction asynchronous? i.e. triggering an interaction does not immediately resolve\\n     * @param success did the call to the bridge succeed or fail?\\n     *\\n     * @notice async interactions must have outputValueA == 0 and outputValueB == 0 (tokens get returned later via calling `processAsyncDefiInteraction`)\\n     */\\n    struct BridgeResult {\\n        uint256 outputValueA;\\n        uint256 outputValueB;\\n        bool isAsync;\\n        bool success;\\n    }\\n\\n    /**\\n     * @dev Container for the inputs of a Defi interaction\\n     * @param totalInputValue number of tokens/wei sent to the bridge\\n     * @param interactionNonce the unique id of the interaction\\n     * @param auxData additional input specific to the type of interaction\\n     */\\n    struct InteractionInputs {\\n        uint256 totalInputValue;\\n        uint256 interactionNonce;\\n        uint64 auxData;\\n    }\\n\\n    /*----------------------------------------\\n      FUNCTION SELECTORS (PRECOMPUTED)\\n      ----------------------------------------*/\\n    // DEFI_BRIDGE_PROXY_CONVERT_SELECTOR = function signature of:\\n    //   function convert(\\n    //       address,\\n    //       AztecTypes.AztecAsset memory inputAssetA,\\n    //       AztecTypes.AztecAsset memory inputAssetB,\\n    //       AztecTypes.AztecAsset memory outputAssetA,\\n    //       AztecTypes.AztecAsset memory outputAssetB,\\n    //       uint256 totalInputValue,\\n    //       uint256 interactionNonce,\\n    //       uint256 auxData,\\n    //       uint256 ethPaymentsSlot\\n    //       address rollupBeneficary)\\n    // N.B. this is the selector of the 'convert' function of the DefiBridgeProxy contract.\\n    //      This has a different interface to the IDefiBridge.convert function\\n    bytes4 private constant DEFI_BRIDGE_PROXY_CONVERT_SELECTOR = 0x4bd947a8;\\n\\n    /*----------------------------------------\\n      CONSTANT STATE VARIABLES\\n      ----------------------------------------*/\\n    uint256 private constant ethAssetId = 0; // if assetId == ethAssetId, treat as native ETH and not ERC20 token\\n\\n    // starting root hash of the DeFi interaction result Merkle tree\\n    bytes32 private constant INIT_DEFI_ROOT = 0x2e4ab7889ab3139204945f9e722c7a8fdb84e66439d787bd066c3d896dba04ea;\\n\\n    bytes32 private constant DEFI_BRIDGE_PROCESSED_SIGHASH =\\n        0x692cf5822a02f5edf084dc7249b3a06293621e069f11975ed70908ed10ed2e2c;\\n\\n    bytes32 private constant ASYNC_BRIDGE_PROCESSED_SIGHASH =\\n        0x38ce48f4c2f3454bcf130721f25a4262b2ff2c8e36af937b30edf01ba481eb1d;\\n\\n    // We need to cap the amount of gas sent to the DeFi bridge contract for two reasons.\\n    // 1: To provide consistency to rollup providers around costs.\\n    // 2: To prevent griefing attacks where a bridge consumes all our gas.\\n    uint256 private constant MIN_BRIDGE_GAS_LIMIT = 35000;\\n    uint256 private constant MIN_ERC20_GAS_LIMIT = 55000;\\n    uint256 private constant MAX_BRIDGE_GAS_LIMIT = 5000000;\\n    uint256 private constant MAX_ERC20_GAS_LIMIT = 1500000;\\n\\n    // Bit offsets and bit masks used to convert a `uint256 bridgeId` into a BridgeData member\\n    uint256 private constant INPUT_ASSET_ID_A_SHIFT = 32;\\n    uint256 private constant INPUT_ASSET_ID_B_SHIFT = 62;\\n    uint256 private constant OUTPUT_ASSET_ID_A_SHIFT = 92;\\n    uint256 private constant OUTPUT_ASSET_ID_B_SHIFT = 122;\\n    uint256 private constant BITCONFIG_SHIFT = 152;\\n    uint256 private constant AUX_DATA_SHIFT = 184;\\n    uint256 private constant VIRTUAL_ASSET_ID_FLAG_SHIFT = 29;\\n    uint256 private constant VIRTUAL_ASSET_ID_FLAG = 0x20000000; // 2 ** 29\\n    uint256 private constant MASK_THIRTY_TWO_BITS = 0xffffffff;\\n    uint256 private constant MASK_THIRTY_BITS = 0x3fffffff;\\n    uint256 private constant MASK_SIXTY_FOUR_BITS = 0xffffffffffffffff;\\n\\n    // Offsets and masks used to encode/decode the stateHash storage variable of RollupProcessor\\n    uint256 private constant DATASIZE_BIT_OFFSET = 160;\\n    uint256 private constant ASYNCDEFIINTERACTIONHASHES_BIT_OFFSET = 192;\\n    uint256 private constant DEFIINTERACTIONHASHES_BIT_OFFSET = 208;\\n    uint256 private constant ARRAY_LENGTH_MASK = 0x3ff; // 1023\\n    uint256 private constant DATASIZE_MASK = 0xffffffff;\\n\\n    // the value of hashing a 'zeroed' defi interaction result\\n    bytes32 private constant DEFI_RESULT_ZERO_HASH = 0x2d25a1e3a51eb293004c4b56abe12ed0da6bca2b4a21936752a85d102593c1b4;\\n\\n    // roles used in access control\\n    bytes32 public constant OWNER_ROLE = keccak256('OWNER_ROLE');\\n    bytes32 public constant EMERGENCY_ROLE = keccak256('EMERGENCY_ROLE');\\n\\n    // bounds used for escapehatch\\n    uint256 public immutable escapeBlockLowerBound;\\n    uint256 public immutable escapeBlockUpperBound;\\n\\n    /*----------------------------------------\\n      STATE VARIABLES\\n      ----------------------------------------*/\\n    RollupState internal rollupState;\\n\\n    // Array of supported ERC20 token address.\\n    address[] internal supportedAssets;\\n\\n    // Array of supported bridge contract addresses (similar to assetIds)\\n    address[] internal supportedBridges;\\n\\n    // Mapping from index to async interaction hash (emulates an array), next index stored in the RollupState\\n    mapping(uint256 => bytes32) public asyncDefiInteractionHashes;\\n\\n    // Mapping from index to sync interaction hash (emulates an array), next index stored in the RollupState\\n    mapping(uint256 => bytes32) public defiInteractionHashes;\\n\\n    // Mapping from assetId to mapping of userAddress to public userBalance stored on this contract\\n    mapping(uint256 => mapping(address => uint256)) public userPendingDeposits;\\n\\n    // Mapping from user address to mapping of proof hashes to flag for approval\\n    mapping(address => mapping(bytes32 => bool)) public depositProofApprovals;\\n\\n    // The hash of the latest rollup state\\n    bytes32 public override(IRollupProcessor) rollupStateHash;\\n\\n    // The address of the defi bridge proxy\\n    address public override(IRollupProcessor) defiBridgeProxy;\\n\\n    // Flag to allow third party contracts to list assets and bridges when out of BETA\\n    bool public allowThirdPartyContracts;\\n\\n    // Mapping from address to flag, true if address is approved, false otherwise\\n    mapping(address => bool) public rollupProviders;\\n\\n    // map defiInteractionNonce to PendingDefiBridgeInteraction\\n    mapping(uint256 => PendingDefiBridgeInteraction) public pendingDefiInteractions;\\n\\n    // map interaction nonces to eth send to RollupProcessor during a bridge interaction\\n    mapping(uint256 => uint256) public ethPayments;\\n\\n    // map asset id to Gas Limit\\n    mapping(uint256 => uint256) public assetGasLimits;\\n\\n    // map bridge id to Gas Limit\\n    mapping(uint256 => uint256) public bridgeGasLimits;\\n\\n    // stores the hash of the hashes of the pending defi interactions, the notes of which are expected to be added in the 'next' rollup\\n    bytes32 public override(IRollupProcessor) prevDefiInteractionsHash;\\n\\n    /*----------------------------------------\\n      MODIFIERS\\n      ----------------------------------------*/\\n    /**\\n     * @dev Modifier to protect functions from being called while the contract is still in BETA.\\n     */\\n    modifier checkThirdPartyContractStatus() {\\n        if (!hasRole(OWNER_ROLE, msg.sender) && !allowThirdPartyContracts) {\\n            revert THIRD_PARTY_CONTRACTS_FLAG_NOT_SET();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier reverting if contract is paused\\n     */\\n    modifier whenNotPaused() {\\n        if (rollupState.paused) {\\n            revert PAUSED();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier reverting if contract is NOT paused\\n     */\\n    modifier whenPaused() {\\n        if (!rollupState.paused) {\\n            revert NOT_PAUSED();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier reverting on any re-enter.\\n     */\\n    modifier noReenter() {\\n        if (rollupState.lock != Lock.UNLOCKED) {\\n            revert LOCKED_NO_REENTER();\\n        }\\n        rollupState.lock = Lock.LOCKED;\\n        _;\\n        rollupState.lock = Lock.UNLOCKED;\\n    }\\n\\n    /**\\n     * @dev Modifier reverting on any re-enter but allowing async to be called.\\n     */\\n    modifier allowAsyncReenter() {\\n        if (rollupState.lock != Lock.UNLOCKED) {\\n            revert LOCKED_NO_REENTER();\\n        }\\n        rollupState.lock = Lock.ALLOW_ASYNC_REENTER;\\n        _;\\n        rollupState.lock = Lock.UNLOCKED;\\n    }\\n\\n    /**\\n     * @dev Modifier reverting if re-entering after locking, but passes if unlocked or allowing async.\\n     */\\n    modifier noReenterButAsync() {\\n        Lock lock = rollupState.lock;\\n        if (lock == Lock.ALLOW_ASYNC_REENTER) {\\n            _;\\n        } else if (lock == Lock.UNLOCKED) {\\n            rollupState.lock = Lock.ALLOW_ASYNC_REENTER;\\n            _;\\n            rollupState.lock = Lock.UNLOCKED;\\n        } else {\\n            revert LOCKED_NO_REENTER();\\n        }\\n    }\\n\\n    /**\\n     * @dev throw if a given assetId represents a virtual asset\\n     * @param assetId 30-bit integer that describes the asset.\\n     * If assetId's 29th bit is set, it represents a virtual asset with no ERC20 equivalent\\n     * Virtual assets are used by defi bridges to track non-token data. E.g. to represent a loan.\\n     * If an assetId is *not* a virtual asset, its ERC20 address can be recovered from `supportedAssets[assetId]`\\n     */\\n    modifier validateAssetIdIsNotVirtual(uint256 assetId) {\\n        if (assetId > 0x1fffffff) {\\n            revert INVALID_ASSET_ID();\\n        }\\n        _;\\n    }\\n\\n    /*----------------------------------------\\n      CONSTRUCTORS & INITIALIZERS\\n      ----------------------------------------*/\\n    /**\\n     * @dev Constructor used to store immutable values for escape hatch window and\\n     * ensure that the implementation cannot be initialized\\n     * @param _escapeBlockLowerBound defines start of escape hatch window\\n     * @param _escapeBlockUpperBound defines end of the escape hatch window\\n     */\\n    constructor(uint256 _escapeBlockLowerBound, uint256 _escapeBlockUpperBound) {\\n        _disableInitializers();\\n        rollupState.paused = true;\\n\\n        escapeBlockLowerBound = _escapeBlockLowerBound;\\n        escapeBlockUpperBound = _escapeBlockUpperBound;\\n    }\\n\\n    /**\\n     * @dev Initialiser function. Emulates constructor behaviour for upgradeable contracts\\n     * @param _verifierAddress the address of the Plonk verification smart contract\\n     * @param _defiBridgeProxy address of the proxy contract that we route defi bridge calls through via `delegateCall`\\n     * @param _contractOwner owner address of RollupProcessor. Should be a multisig contract\\n     * @param _initDataRoot starting state of the Aztec data tree. Init tree state should be all-zeroes excluding migrated account notes\\n     * @param _initNullRoot starting state of the Aztec nullifier tree. Init tree state should be all-zeroes excluding migrated account nullifiers\\n     * @param _initRootRoot starting state of the Aztec data roots tree. Init tree state should be all-zeroes excluding 1 leaf containing _initDataRoot\\n     * @param _initDatasize starting size of the Aztec data tree.\\n     * @param _allowThirdPartyContracts flag that specifies whether 3rd parties are allowed to add state to the contract\\n     */\\n    function initialize(\\n        address _verifierAddress,\\n        address _defiBridgeProxy,\\n        address _contractOwner,\\n        bytes32 _initDataRoot,\\n        bytes32 _initNullRoot,\\n        bytes32 _initRootRoot,\\n        uint32 _initDatasize,\\n        bool _allowThirdPartyContracts\\n    ) external reinitializer(getImplementationVersion()) {\\n        _grantRole(DEFAULT_ADMIN_ROLE, _contractOwner);\\n        _grantRole(OWNER_ROLE, _contractOwner);\\n        _grantRole(EMERGENCY_ROLE, _contractOwner);\\n        // compute rollupStateHash\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, 0) // nextRollupId\\n            mstore(add(mPtr, 0x20), _initDataRoot)\\n            mstore(add(mPtr, 0x40), _initNullRoot)\\n            mstore(add(mPtr, 0x60), _initRootRoot)\\n            mstore(add(mPtr, 0x80), INIT_DEFI_ROOT)\\n            sstore(rollupStateHash.slot, keccak256(mPtr, 0xa0))\\n        }\\n        rollupState.datasize = _initDatasize;\\n        rollupState.verifier = IVerifier(_verifierAddress);\\n        defiBridgeProxy = _defiBridgeProxy;\\n        allowThirdPartyContracts = _allowThirdPartyContracts;\\n        // initial value of the hash of 32 'zero' defi note hashes\\n        prevDefiInteractionsHash = 0x14e0f351ade4ba10438e9b15f66ab2e6389eea5ae870d6e8b2df1418b2e6fd5b;\\n    }\\n\\n    /*----------------------------------------\\n      MUTATING FUNCTIONS WITH ACCESS CONTROL \\n      ----------------------------------------*/\\n    /**\\n     * @dev Allow the multisig owner to pause the contract.\\n     */\\n    function pause() public override(IRollupProcessor) whenNotPaused onlyRole(EMERGENCY_ROLE) noReenter {\\n        rollupState.paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allow the multisig owner to unpause the contract.\\n     */\\n    function unpause() public override(IRollupProcessor) whenPaused onlyRole(OWNER_ROLE) noReenter {\\n        rollupState.paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    /**\\n     * @dev adds/removes an authorized rollup provider that can publish rollup blocks. Admin only\\n     * @param providerAddress address of rollup provider\\n     * @param valid are we adding or removing the provider?\\n     */\\n    function setRollupProvider(address providerAddress, bool valid)\\n        external\\n        override(IRollupProcessor)\\n        onlyRole(OWNER_ROLE)\\n        noReenter\\n    {\\n        rollupProviders[providerAddress] = valid;\\n        emit RollupProviderUpdated(providerAddress, valid);\\n    }\\n\\n    /**\\n     * @dev sets the address of the PLONK verification smart contract. Admin only\\n     * @param _verifierAddress address of the verification smart contract\\n     */\\n    function setVerifier(address _verifierAddress) public override(IRollupProcessor) onlyRole(OWNER_ROLE) noReenter {\\n        rollupState.verifier = IVerifier(_verifierAddress);\\n        emit VerifierUpdated(_verifierAddress);\\n    }\\n\\n    /**\\n     * @dev Set a flag that allows a third party dev to register assets and bridges.\\n     * @param _flag - bool if the flag should be set or not\\n     */\\n    function setAllowThirdPartyContracts(bool _flag)\\n        external\\n        override(IRollupProcessor)\\n        onlyRole(OWNER_ROLE)\\n        noReenter\\n    {\\n        allowThirdPartyContracts = _flag;\\n    }\\n\\n    /**\\n     * @dev sets the address of the defi bridge proxy. Admin only\\n     * @param defiBridgeProxyAddress address of the defi bridge proxy contract\\n     */\\n    function setDefiBridgeProxy(address defiBridgeProxyAddress)\\n        public\\n        override(IRollupProcessor)\\n        onlyRole(OWNER_ROLE)\\n        noReenter\\n    {\\n        defiBridgeProxy = defiBridgeProxyAddress;\\n    }\\n\\n    /**\\n     * @dev Set the mapping between an assetId and the address of the linked asset.\\n     * @param linkedToken - address of the asset\\n     * @param gasLimit - uint256 gas limit for ERC20 token transfers of this asset\\n     */\\n    function setSupportedAsset(address linkedToken, uint256 gasLimit)\\n        external\\n        override(IRollupProcessor)\\n        whenNotPaused\\n        checkThirdPartyContractStatus\\n        noReenter\\n    {\\n        if (linkedToken == address(0)) {\\n            revert INVALID_LINKED_TOKEN_ADDRESS();\\n        }\\n\\n        supportedAssets.push(linkedToken);\\n\\n        uint256 assetId = supportedAssets.length;\\n        assetGasLimits[assetId] = sanitiseAssetGasLimit(gasLimit);\\n\\n        emit AssetAdded(assetId, linkedToken, assetGasLimits[assetId]);\\n    }\\n\\n    /**\\n     * @dev Set the mapping between an bridge contract id and the address of the linked bridge contract.\\n     * @param linkedBridge - address of the bridge contract\\n     * @param gasLimit - uint256 gas limit to send to the bridge convert function\\n     */\\n    function setSupportedBridge(address linkedBridge, uint256 gasLimit)\\n        external\\n        override(IRollupProcessor)\\n        whenNotPaused\\n        checkThirdPartyContractStatus\\n        noReenter\\n    {\\n        if (linkedBridge == address(0)) {\\n            revert INVALID_LINKED_BRIDGE_ADDRESS();\\n        }\\n        supportedBridges.push(linkedBridge);\\n\\n        uint256 bridgeAddressId = supportedBridges.length;\\n        bridgeGasLimits[bridgeAddressId] = sanitiseBridgeGasLimit(gasLimit);\\n\\n        emit BridgeAdded(bridgeAddressId, linkedBridge, bridgeGasLimits[bridgeAddressId]);\\n    }\\n\\n    /**\\n     * @dev Process a rollup - decode the rollup, update relevant state variables and\\n     * verify the proof\\n     * @param - cryptographic proof data associated with a rollup\\n     * @param signatures - bytes array of secp256k1 ECDSA signatures, authorising a transfer of tokens\\n     * from the publicOwner for the particular inner proof in question. There is a signature for each\\n     * inner proof.\\n     *\\n     * Structure of each signature in the bytes array is:\\n     * 0x00 - 0x20 : r\\n     * 0x20 - 0x40 : s\\n     * 0x40 - 0x60 : v (in form: 0x0000....0001b for example)\\n     *\\n     * @param - offchainTxData Note: not used in the logic\\n     * of the rollupProcessor contract, but called here as a convenient to place data on chain\\n     */\\n    function processRollup(\\n        bytes calldata, /* encodedProofData */\\n        bytes calldata signatures\\n    ) external override(IRollupProcessor) whenNotPaused allowAsyncReenter {\\n        // 1. Process a rollup if the escape hatch is open or,\\n        // 2. There msg.sender is an authorised rollup provider\\n        // 3. Always transfer fees to the passed in feeReceiver\\n        (bool isOpen, ) = getEscapeHatchStatus();\\n        if (!(rollupProviders[msg.sender] || isOpen)) {\\n            revert INVALID_PROVIDER();\\n        }\\n\\n        (bytes memory proofData, uint256 numTxs, uint256 publicInputsHash) = decodeProof();\\n        address rollupBeneficiary = extractRollupBeneficiaryAddress(proofData);\\n\\n        processRollupProof(proofData, signatures, numTxs, publicInputsHash, rollupBeneficiary);\\n\\n        transferFee(proofData, rollupBeneficiary);\\n    }\\n\\n    /*----------------------------------------\\n      PUBLIC/EXTERNAL MUTATING FUNCTIONS \\n      ----------------------------------------*/\\n\\n    /**\\n     * @dev Used by bridge contracts to send RollupProcessor ETH during a bridge interaction\\n     * @param interactionNonce the Defi interaction nonce that this payment is logged against\\n     */\\n    function receiveEthFromBridge(uint256 interactionNonce) external payable override(IRollupProcessor) {\\n        assembly {\\n            // ethPayments[interactionNonce] += msg.value\\n            mstore(0x00, interactionNonce)\\n            mstore(0x20, ethPayments.slot)\\n            let slot := keccak256(0x00, 0x40)\\n            // no need to check for overflows as this would require sending more than the blockchain's total supply of ETH!\\n            sstore(slot, add(sload(slot), callvalue()))\\n        }\\n    }\\n\\n    /**\\n     * @dev Approve a proofHash for spending a users deposited funds, this is one way and must be called by the owner of the funds\\n     * @param _proofHash - keccack256 hash of the inner proof public inputs\\n     */\\n    function approveProof(bytes32 _proofHash) public override(IRollupProcessor) whenNotPaused {\\n        // asm implementation to reduce compiled bytecode size\\n        assembly {\\n            // depositProofApprovals[msg.sender][_proofHash] = true;\\n            mstore(0x00, caller())\\n            mstore(0x20, depositProofApprovals.slot)\\n            mstore(0x20, keccak256(0x00, 0x40))\\n            mstore(0x00, _proofHash)\\n            sstore(keccak256(0x00, 0x40), 1)\\n        }\\n    }\\n\\n    /**\\n     * @dev Deposit funds as part of the first stage of the two stage deposit. Non-permit flow\\n     * @param assetId - unique ID of the asset\\n     * @param amount - number of tokens being deposited\\n     * @param owner - address that can spend the deposited funds\\n     * @param proofHash - the 32 byte transaction id that can spend the deposited funds\\n     */\\n    function depositPendingFunds(\\n        uint256 assetId,\\n        uint256 amount,\\n        address owner,\\n        bytes32 proofHash\\n    ) external payable override(IRollupProcessor) whenNotPaused noReenter {\\n        // Perform sanity checks on user input\\n        if (assetId == ethAssetId && msg.value != amount) {\\n            revert MSG_VALUE_WRONG_AMOUNT();\\n        }\\n        if (assetId != ethAssetId && msg.value != 0) {\\n            revert DEPOSIT_TOKENS_WRONG_PAYMENT_TYPE();\\n        }\\n\\n        internalDeposit(assetId, owner, amount, proofHash);\\n\\n        if (assetId != ethAssetId) {\\n            address assetAddress = getSupportedAsset(assetId);\\n            // check user approved contract to transfer funds, so can throw helpful error to user\\n            if (IERC20(assetAddress).allowance(msg.sender, address(this)) < amount) {\\n                revert INSUFFICIENT_TOKEN_APPROVAL();\\n            }\\n            TokenTransfers.safeTransferFrom(assetAddress, msg.sender, address(this), amount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Deposit funds as part of the first stage of the two stage deposit. Permit flow\\n     * @param assetId - unique ID of the asset\\n     * @param amount - number of tokens being deposited\\n     * @param depositorAddress - address from which funds are being transferred to the contract\\n     * @param proofHash - the 32 byte transaction id that can spend the deposited funds\\n     * @param deadline - when the permit signature expires\\n     * @param v - ECDSA sig param\\n     * @param r - ECDSA sig param\\n     * @param s - ECDSA sig param\\n     */\\n    function depositPendingFundsPermit(\\n        uint256 assetId,\\n        uint256 amount,\\n        address depositorAddress,\\n        bytes32 proofHash,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override(IRollupProcessor) whenNotPaused noReenter {\\n        internalDeposit(assetId, depositorAddress, amount, proofHash);\\n\\n        address assetAddress = getSupportedAsset(assetId);\\n        IERC20Permit(assetAddress).permit(depositorAddress, address(this), amount, deadline, v, r, s);\\n        TokenTransfers.safeTransferFrom(assetAddress, depositorAddress, address(this), amount);\\n    }\\n\\n    /**\\n     * @dev Deposit funds as part of the first stage of the two stage deposit. Permit flow\\n     * @param assetId - unique ID of the asset\\n     * @param amount - number of tokens being deposited\\n     * @param depositorAddress - address from which funds are being transferred to the contract\\n     * @param proofHash - the 32 byte transaction id that can spend the deposited funds\\n     * @param nonce - user's nonce on the erc20 contract, for replay protection\\n     * @param deadline - when the permit signature expires\\n     * @param v - ECDSA sig param\\n     * @param r - ECDSA sig param\\n     * @param s - ECDSA sig param\\n     */\\n    function depositPendingFundsPermitNonStandard(\\n        uint256 assetId,\\n        uint256 amount,\\n        address depositorAddress,\\n        bytes32 proofHash,\\n        uint256 nonce,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override(IRollupProcessor) whenNotPaused noReenter {\\n        internalDeposit(assetId, depositorAddress, amount, proofHash);\\n\\n        address assetAddress = getSupportedAsset(assetId);\\n        IERC20Permit(assetAddress).permit(depositorAddress, address(this), nonce, deadline, true, v, r, s);\\n        TokenTransfers.safeTransferFrom(assetAddress, depositorAddress, address(this), amount);\\n    }\\n\\n    /**\\n     * @dev Used to publish data that doesn't need to be on chain. Should eventually be published elsewhere.\\n     * This maybe called multiple times to work around maximum tx size limits.\\n     * The data will need to be reconstructed by the client.\\n     * @param rollupId - the rollup id this data is related to.\\n     * @param chunk - the chunk number, from 0 to totalChunks-1.\\n     * @param totalChunks - the total number of chunks.\\n     * @param - the data.\\n     */\\n    function offchainData(\\n        uint256 rollupId,\\n        uint256 chunk,\\n        uint256 totalChunks,\\n        bytes calldata /* offchainTxData */\\n    ) external override(IRollupProcessor) whenNotPaused {\\n        emit OffchainData(rollupId, chunk, totalChunks, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Process asyncdefi interactions.\\n     *      Callback function for asynchronous bridge interactions.\\n     * @param interactionNonce - unique id of the interaection\\n     */\\n    function processAsyncDefiInteraction(uint256 interactionNonce)\\n        external\\n        override(IRollupProcessor)\\n        whenNotPaused\\n        noReenterButAsync\\n        returns (bool)\\n    {\\n        uint256 bridgeId;\\n        uint256 totalInputValue;\\n        assembly {\\n            mstore(0x00, interactionNonce)\\n            mstore(0x20, pendingDefiInteractions.slot)\\n            let interactionPtr := keccak256(0x00, 0x40)\\n\\n            bridgeId := sload(interactionPtr)\\n            totalInputValue := sload(add(interactionPtr, 0x01))\\n        }\\n        if (bridgeId == 0) {\\n            revert INVALID_BRIDGE_ID();\\n        }\\n        BridgeData memory bridgeData = getBridgeData(bridgeId);\\n\\n        (\\n            AztecTypes.AztecAsset memory inputAssetA,\\n            AztecTypes.AztecAsset memory inputAssetB,\\n            AztecTypes.AztecAsset memory outputAssetA,\\n            AztecTypes.AztecAsset memory outputAssetB\\n        ) = getAztecAssetTypes(bridgeData, interactionNonce);\\n\\n        // Extract the bridge address from the bridgeId\\n        IDefiBridge bridgeContract;\\n        assembly {\\n            mstore(0x00, supportedBridges.slot)\\n            let bridgeSlot := keccak256(0x00, 0x20)\\n\\n            bridgeContract := and(bridgeId, 0xffffffff)\\n            bridgeContract := sload(add(bridgeSlot, sub(bridgeContract, 0x01)))\\n            bridgeContract := and(bridgeContract, ADDRESS_MASK)\\n        }\\n        if (address(bridgeContract) == address(0)) {\\n            revert INVALID_BRIDGE_ADDRESS();\\n        }\\n\\n        // delete pendingDefiInteractions[interactionNonce]\\n        // N.B. only need to delete 1st slot value `bridgeId`. Deleting vars costs gas post-London\\n        // setting bridgeId to 0 is enough to cause future calls with this interaction nonce to fail\\n        pendingDefiInteractions[interactionNonce].bridgeId = 0;\\n\\n        // Copy some variables to front of stack to get around stack too deep errors\\n        InteractionInputs memory inputs = InteractionInputs(\\n            totalInputValue,\\n            interactionNonce,\\n            uint64(bridgeData.auxData)\\n        );\\n        (uint256 outputValueA, uint256 outputValueB, bool interactionCompleted) = bridgeContract.finalise(\\n            inputAssetA,\\n            inputAssetB,\\n            outputAssetA,\\n            outputAssetB,\\n            inputs.interactionNonce,\\n            inputs.auxData\\n        );\\n\\n        if (!interactionCompleted) {\\n            pendingDefiInteractions[inputs.interactionNonce].bridgeId = bridgeId;\\n            return false;\\n        }\\n\\n        if (outputValueB > 0 && outputAssetB.assetType == AztecTypes.AztecAssetType.NOT_USED) {\\n            revert NONZERO_OUTPUT_VALUE_ON_NOT_USED_ASSET(outputValueB);\\n        }\\n\\n        if (outputValueA == 0 && outputValueB == 0) {\\n            // issue refund.\\n            transferTokensAsync(address(bridgeContract), inputAssetA, inputs.totalInputValue, inputs.interactionNonce);\\n        } else {\\n            // transfer output tokens to rollup contract\\n            transferTokensAsync(address(bridgeContract), outputAssetA, outputValueA, inputs.interactionNonce);\\n            transferTokensAsync(address(bridgeContract), outputAssetB, outputValueB, inputs.interactionNonce);\\n        }\\n\\n        // compute defiInteractionHash and push it onto the asyncDefiInteractionHashes array\\n        bool result;\\n        assembly {\\n            // Load values from `input` (to get around stack too deep)\\n            let inputValue := mload(inputs)\\n            let nonce := mload(add(inputs, 0x20))\\n            result := iszero(and(eq(outputValueA, 0), eq(outputValueB, 0)))\\n\\n            // Compute defi interaction hash\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, bridgeId)\\n            mstore(add(mPtr, 0x20), nonce)\\n            mstore(add(mPtr, 0x40), inputValue)\\n            mstore(add(mPtr, 0x60), outputValueA)\\n            mstore(add(mPtr, 0x80), outputValueB)\\n            mstore(add(mPtr, 0xa0), result)\\n            pop(staticcall(gas(), 0x2, mPtr, 0xc0, 0x00, 0x20))\\n            let defiInteractionHash := mod(mload(0x00), CIRCUIT_MODULUS)\\n\\n            // Load sync and async array lengths from rollup state\\n            let state := sload(rollupState.slot)\\n            // asyncArrayLen = rollupState.numAsyncDefiInteractionHashes\\n            let asyncArrayLen := and(ARRAY_LENGTH_MASK, shr(ASYNCDEFIINTERACTIONHASHES_BIT_OFFSET, state))\\n            // defiArrayLen = rollupState.numDefiInteractionHashes\\n            let defiArrayLen := and(ARRAY_LENGTH_MASK, shr(DEFIINTERACTIONHASHES_BIT_OFFSET, state))\\n\\n            // check that size of asyncDefiInteractionHashes isn't such that\\n            // adding 1 to it will make the next block's defiInteractionHashes length hit 512\\n            if gt(add(add(1, asyncArrayLen), defiArrayLen), 512) {\\n                // store keccak256(\\\"ARRAY_OVERFLOW()\\\")\\n                // this code is equivalent to `revert ARRAY_OVERFLOW()`\\n                mstore(mPtr, 0x58a4ab0e00000000000000000000000000000000000000000000000000000000)\\n                revert(mPtr, 0x04)\\n            }\\n\\n            // asyncDefiInteractionHashes[asyncArrayLen] = defiInteractionHash\\n            mstore(0x00, asyncArrayLen)\\n            mstore(0x20, asyncDefiInteractionHashes.slot)\\n            sstore(keccak256(0x00, 0x40), defiInteractionHash)\\n\\n            // increase asyncDefiInteractionHashes.length by 1\\n            let oldState := and(not(shl(ASYNCDEFIINTERACTIONHASHES_BIT_OFFSET, ARRAY_LENGTH_MASK)), state)\\n            let newState := or(oldState, shl(ASYNCDEFIINTERACTIONHASHES_BIT_OFFSET, add(asyncArrayLen, 0x01)))\\n\\n            sstore(rollupState.slot, newState)\\n        }\\n        emit DefiBridgeProcessed(\\n            bridgeId,\\n            inputs.interactionNonce,\\n            inputs.totalInputValue,\\n            outputValueA,\\n            outputValueB,\\n            result,\\n            ''\\n        );\\n\\n        return true;\\n    }\\n\\n    /*----------------------------------------\\n      INTERNAL/PRIVATE MUTATING FUNCTIONS \\n      ----------------------------------------*/\\n\\n    /**\\n     * @dev Increase the userPendingDeposits mapping\\n     * assembly impl to reduce compiled bytecode size and improve gas costs\\n     */\\n    function increasePendingDepositBalance(\\n        uint256 assetId,\\n        address depositorAddress,\\n        uint256 amount\\n    ) internal validateAssetIdIsNotVirtual(assetId) {\\n        assembly {\\n            // userPendingDeposit = userPendingDeposits[assetId][depositorAddress]\\n            mstore(0x00, assetId)\\n            mstore(0x20, userPendingDeposits.slot)\\n            mstore(0x20, keccak256(0x00, 0x40))\\n            mstore(0x00, depositorAddress)\\n            let userPendingDepositSlot := keccak256(0x00, 0x40)\\n            let userPendingDeposit := sload(userPendingDepositSlot)\\n            let newDeposit := add(userPendingDeposit, amount)\\n            if lt(newDeposit, userPendingDeposit) {\\n                revert(0, 0)\\n            }\\n            sstore(userPendingDepositSlot, newDeposit)\\n        }\\n    }\\n\\n    /**\\n     * @dev Decrease the userPendingDeposits mapping\\n     * assembly impl to reduce compiled bytecode size. Also removes a sload op and saves a fair chunk of gas per deposit tx\\n     */\\n    function decreasePendingDepositBalance(\\n        uint256 assetId,\\n        address transferFromAddress,\\n        uint256 amount\\n    ) internal validateAssetIdIsNotVirtual(assetId) {\\n        bool insufficientDeposit = false;\\n        assembly {\\n            // userPendingDeposit = userPendingDeposits[assetId][transferFromAddress]\\n            mstore(0x00, assetId)\\n            mstore(0x20, userPendingDeposits.slot)\\n            mstore(0x20, keccak256(0x00, 0x40))\\n            mstore(0x00, transferFromAddress)\\n            let userPendingDepositSlot := keccak256(0x00, 0x40)\\n            let userPendingDeposit := sload(userPendingDepositSlot)\\n\\n            insufficientDeposit := lt(userPendingDeposit, amount)\\n\\n            let newDeposit := sub(userPendingDeposit, amount)\\n\\n            sstore(userPendingDepositSlot, newDeposit)\\n        }\\n\\n        if (insufficientDeposit) {\\n            revert INSUFFICIENT_DEPOSIT();\\n        }\\n    }\\n\\n    /**\\n     * @dev Deposit funds as part of the first stage of the two stage deposit. Non-permit flow\\n     * @param assetId - unique ID of the asset\\n     * @param depositorAddress - address from which funds are being transferred to the contract\\n     * @param amount - amount being deposited\\n     * @param proofHash - the 32 byte transaction id that can spend the deposited funds\\n     */\\n    function internalDeposit(\\n        uint256 assetId,\\n        address depositorAddress,\\n        uint256 amount,\\n        bytes32 proofHash\\n    ) internal {\\n        increasePendingDepositBalance(assetId, depositorAddress, amount);\\n\\n        if (proofHash != 0) {\\n            approveProof(proofHash);\\n        }\\n\\n        emit Deposit(assetId, depositorAddress, amount);\\n    }\\n\\n    /**\\n     * @dev processes a rollup proof. Will verify the proof's correctness and use the provided\\n     * proof data to update the rollup state + merkle roots, as well as validate/enact any deposits/withdrawals in the block.\\n     * Finally any defi interactions specified in the block will be executed\\n     * @param proofData the block's proof data (contains PLONK proof and public input data linked to the proof)\\n     * @param signatures ECDSA signatures from users authorizing deposit transactions\\n     * @param numTxs the number of transactions in the block\\n     * @param publicInputsHash the SHA256 hash of the proof's public inputs\\n     */\\n    function processRollupProof(\\n        bytes memory proofData,\\n        bytes memory signatures,\\n        uint256 numTxs,\\n        uint256 publicInputsHash,\\n        address rollupBeneficiary\\n    ) internal {\\n        uint256 rollupId = verifyProofAndUpdateState(proofData, publicInputsHash);\\n        processDepositsAndWithdrawals(proofData, numTxs, signatures);\\n        bytes32[] memory nextDefiHashes = processDefiBridges(proofData, rollupBeneficiary);\\n        emit RollupProcessed(rollupId, nextDefiHashes, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Verify the zk proof and update the contract state variables with those provided by the rollup.\\n     * @param proofData - cryptographic zk proof data. Passed to the verifier for verification.\\n     */\\n    function verifyProofAndUpdateState(bytes memory proofData, uint256 publicInputsHash)\\n        internal\\n        returns (uint256 rollupId)\\n    {\\n        // Verify the rollup proof.\\n        //\\n        // We manually call the verifier contract via assembly to save on gas costs and to reduce contract bytecode size\\n        assembly {\\n            /**\\n             * Validate correctness of zk proof.\\n             *\\n             * 1st Item is to format verifier calldata.\\n             **/\\n\\n            // Our first input param `encodedProofData` contains the concatenation of\\n            // encoded 'broadcasted inputs' and the actual zk proof data.\\n            // (The `boadcasted inputs` is converted into a 32-byte SHA256 hash, which is\\n            // validated to equal the first public inputs of the zk proof. This is done in `Decoder.sol`).\\n            // We need to identify the location in calldata that points to the start of the zk proof data.\\n\\n            // Step 1: compute size of zk proof data and its calldata pointer.\\n            /**\\n                Data layout for `bytes encodedProofData`...\\n\\n                0x00 : 0x20 : length of array\\n                0x20 : 0x20 + header : root rollup header data\\n                0x20 + header : 0x24 + header : X, the length of encoded inner join-split public inputs\\n                0x24 + header : 0x24 + header + X : (inner join-split public inputs)\\n                0x24 + header + X : 0x28 + header + X : Y, the length of the zk proof data\\n                0x28 + header + X : 0x28 + haeder + X + Y : zk proof data\\n\\n                We need to recover the numeric value of `0x28 + header + X` and `Y`\\n             **/\\n            // Begin by getting length of encoded inner join-split public inputs.\\n            // `calldataload(0x04)` points to start of bytes array. Add 0x24 to skip over length param and function signature.\\n            // The calldata param 4 bytes *after* the header is the length of the pub inputs array. However it is a packed 4-byte param.\\n            // To extract it, we subtract 24 bytes from the calldata pointer and mask off all but the 4 least significant bytes.\\n            let encodedInnerDataSize := and(\\n                calldataload(add(add(calldataload(0x04), 0x24), sub(ROLLUP_HEADER_LENGTH, 0x18))),\\n                0xffffffff\\n            )\\n\\n            // add 8 bytes to skip over the two packed params that follow the rollup header data\\n            // broadcastedDataSize = inner join-split pubinput size + header size\\n            let broadcastedDataSize := add(add(ROLLUP_HEADER_LENGTH, 8), encodedInnerDataSize)\\n\\n            // Compute zk proof data size by subtracting broadcastedDataSize from overall length of bytes encodedProofsData\\n            let zkProofDataSize := sub(calldataload(add(calldataload(0x04), 0x04)), broadcastedDataSize)\\n\\n            // Compute calldata pointer to start of zk proof data by adding calldata offset to broadcastedDataSize\\n            // (+0x24 skips over function signature and length param of bytes encodedProofData)\\n            let zkProofDataPtr := add(broadcastedDataSize, add(calldataload(0x04), 0x24))\\n\\n            // Step 2: Format calldata for verifier contract call.\\n\\n            // Get free memory pointer - we copy calldata into memory starting here\\n            let dataPtr := mload(0x40)\\n\\n            // We call the function `verify(bytes,uint256)`\\n            // The function signature is 0xac318c5d\\n            // Calldata map is:\\n            // 0x00 - 0x04 : 0xac318c5d\\n            // 0x04 - 0x24 : 0x40 (number of bytes between 0x04 and the start of the `proofData` array at 0x44)\\n            // 0x24 - 0x44 : publicInputsHash\\n            // 0x44 - .... : proofData\\n            mstore8(dataPtr, 0xac)\\n            mstore8(add(dataPtr, 0x01), 0x31)\\n            mstore8(add(dataPtr, 0x02), 0x8c)\\n            mstore8(add(dataPtr, 0x03), 0x5d)\\n            mstore(add(dataPtr, 0x04), 0x40)\\n            mstore(add(dataPtr, 0x24), publicInputsHash)\\n            mstore(add(dataPtr, 0x44), zkProofDataSize) // length of zkProofData bytes array\\n            calldatacopy(add(dataPtr, 0x64), zkProofDataPtr, zkProofDataSize) // copy the zk proof data into memory\\n\\n            // Step 3: Call our verifier contract. If does not return any values, but will throw an error if the proof is not valid\\n            // i.e. verified == false if proof is not valid\\n            let verifierAddress := and(sload(rollupState.slot), ADDRESS_MASK)\\n            let proof_verified := staticcall(gas(), verifierAddress, dataPtr, add(zkProofDataSize, 0x64), 0x00, 0x00)\\n\\n            // Check the proof is valid!\\n            if iszero(proof_verified) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        // Validate and update state hash\\n        rollupId = validateAndUpdateMerkleRoots(proofData);\\n    }\\n\\n    /**\\n     * @dev Extract public inputs and validate they are inline with current contract rollupState.\\n     * @param proofData - Rollup proof data.\\n     */\\n    function validateAndUpdateMerkleRoots(bytes memory proofData) internal returns (uint256) {\\n        (\\n            uint256 rollupId,\\n            bytes32 oldStateHash,\\n            bytes32 newStateHash,\\n            uint32 numDataLeaves,\\n            uint32 dataStartIndex\\n        ) = computeRootHashes(proofData);\\n\\n        if (oldStateHash != rollupStateHash) {\\n            revert INCORRECT_STATE_HASH(oldStateHash, newStateHash);\\n        }\\n\\n        unchecked {\\n            uint32 storedDataSize = rollupState.datasize;\\n            // Ensure we are inserting at the next subtree boundary.\\n            if (storedDataSize % numDataLeaves == 0) {\\n                if (dataStartIndex != storedDataSize) {\\n                    revert INCORRECT_DATA_START_INDEX(dataStartIndex, storedDataSize);\\n                }\\n            } else {\\n                uint256 expected = storedDataSize + numDataLeaves - (storedDataSize % numDataLeaves);\\n                if (dataStartIndex != expected) {\\n                    revert INCORRECT_DATA_START_INDEX(dataStartIndex, expected);\\n                }\\n            }\\n\\n            rollupStateHash = newStateHash;\\n            rollupState.datasize = dataStartIndex + numDataLeaves;\\n        }\\n        return rollupId;\\n    }\\n\\n    /**\\n     * @dev Process deposits and withdrawls.\\n     * @param proofData - the proof data\\n     * @param numTxs - number of transactions rolled up in the proof\\n     * @param signatures - bytes array of secp256k1 ECDSA signatures, authorising a transfer of tokens\\n     */\\n    function processDepositsAndWithdrawals(\\n        bytes memory proofData,\\n        uint256 numTxs,\\n        bytes memory signatures\\n    ) internal {\\n        uint256 sigIndex = 0x00;\\n        uint256 proofDataPtr;\\n        uint256 end;\\n        assembly {\\n            // add 0x20 to skip over 1st member of the bytes type (the length field).\\n            // Also skip over the rollup header.\\n            proofDataPtr := add(ROLLUP_HEADER_LENGTH, add(proofData, 0x20))\\n\\n            // compute the position of proofDataPtr after we iterate through every transaction\\n            end := add(proofDataPtr, mul(numTxs, TX_PUBLIC_INPUT_LENGTH))\\n        }\\n\\n        // This is a bit of a hot loop, we iterate over every tx to determine whether to process deposits or withdrawals.\\n        while (proofDataPtr < end) {\\n            // extract the minimum information we need to determine whether to skip this iteration\\n            uint256 publicValue;\\n            assembly {\\n                publicValue := mload(add(proofDataPtr, 0xa0))\\n            }\\n            if (publicValue > 0) {\\n                uint256 proofId;\\n                uint256 assetId;\\n                address publicOwner;\\n                assembly {\\n                    proofId := mload(proofDataPtr)\\n                    assetId := mload(add(proofDataPtr, 0xe0))\\n                    publicOwner := mload(add(proofDataPtr, 0xc0))\\n                }\\n\\n                if (proofId == 1) {\\n                    // validate user has approved deposit\\n                    bytes32 digest;\\n                    assembly {\\n                        // compute the tx id to check if user has approved tx\\n                        digest := keccak256(proofDataPtr, TX_PUBLIC_INPUT_LENGTH)\\n                    }\\n                    // check if there is an existing entry in depositProofApprovals\\n                    // if there is, no further work required.\\n                    // we don't need to clear `depositProofApprovals[publicOwner][digest]` because proofs cannot be re-used.\\n                    // A single proof describes the creation of 2 output notes and the addition of 2 input note nullifiers\\n                    // (both of these nullifiers can be categorised as \\\"fake\\\". They may not map to existing notes but are still inserted in the nullifier set)\\n                    // Replaying the proof will fail to satisfy the rollup circuit's non-membership check on the input nullifiers.\\n                    // We avoid resetting `depositProofApprovals` because that would cost additional gas post-London hard fork.\\n                    if (!depositProofApprovals[publicOwner][digest]) {\\n                        // extract and validate signature\\n                        // we can create a bytes memory container for the signature without allocating new memory,\\n                        // by overwriting the previous 32 bytes in the `signatures` array with the 'length' of our synthetic byte array (92)\\n                        // we store the memory we overwrite in `temp`, so that we can restore it\\n                        bytes memory signature;\\n                        uint256 temp;\\n                        assembly {\\n                            // set `signature` to point to 32 bytes less than the desired `r, s, v` values in `signatures`\\n                            signature := add(signatures, sigIndex)\\n                            // cache the memory we're about to overwrite\\n                            temp := mload(signature)\\n                            // write in a 92-byte 'length' parameter into the `signature` bytes array\\n                            mstore(signature, 0x60)\\n                        }\\n\\n                        bytes32 hashedMessage = RollupProcessorLibrary.getSignedMessageForTxId(digest);\\n\\n                        RollupProcessorLibrary.validateSheildSignatureUnpacked(hashedMessage, signature, publicOwner);\\n                        // restore the memory we overwrote\\n                        assembly {\\n                            mstore(signature, temp)\\n                            sigIndex := add(sigIndex, 0x60)\\n                        }\\n                    }\\n                    decreasePendingDepositBalance(assetId, publicOwner, publicValue);\\n                }\\n\\n                if (proofId == 2) {\\n                    withdraw(publicValue, publicOwner, assetId);\\n                }\\n            }\\n            // don't check for overflow, would take > 2^200 iterations of this loop for that to happen!\\n            unchecked {\\n                proofDataPtr += TX_PUBLIC_INPUT_LENGTH;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Token transfer method used by processAsyncDefiInteraction\\n     * Calls `transferFrom` on the target erc20 token, if asset is of type ERC\\n     * If asset is ETH, we validate a payment has been made against the provided interaction nonce\\n     * @param bridgeContract address of bridge contract we're taking tokens from\\n     * @param asset the AztecAsset being transferred\\n     * @param outputValue the expected value transferred\\n     * @param interactionNonce the defi interaction nonce of the interaction\\n     */\\n    function transferTokensAsync(\\n        address bridgeContract,\\n        AztecTypes.AztecAsset memory asset,\\n        uint256 outputValue,\\n        uint256 interactionNonce\\n    ) internal {\\n        if (outputValue == 0) {\\n            return;\\n        }\\n        if (asset.assetType == AztecTypes.AztecAssetType.ETH) {\\n            if (outputValue > ethPayments[interactionNonce]) {\\n                revert INSUFFICIENT_ETH_PAYMENT();\\n            }\\n            ethPayments[interactionNonce] = 0;\\n        } else if (asset.assetType == AztecTypes.AztecAssetType.ERC20) {\\n            address tokenAddress = asset.erc20Address;\\n            TokenTransfers.safeTransferFrom(tokenAddress, bridgeContract, address(this), outputValue);\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfer a fee to the feeReceiver\\n     * @param proofData proof of knowledge of a rollup block update\\n     * @param feeReceiver fee beneficiary as described kby the rollup provider\\n     */\\n    function transferFee(bytes memory proofData, address feeReceiver) internal {\\n        for (uint256 i = 0; i < NUMBER_OF_ASSETS; ) {\\n            uint256 txFee = extractTotalTxFee(proofData, i);\\n            if (txFee > 0) {\\n                uint256 assetId = extractAssetId(proofData, i);\\n                if (assetId == ethAssetId) {\\n                    // We explicitly do not throw if this call fails, as this opens up the possiblity of\\n                    // griefing attacks, as engineering a failed fee will invalidate an entire rollup block\\n                    assembly {\\n                        pop(call(50000, feeReceiver, txFee, 0, 0, 0, 0))\\n                    }\\n                } else {\\n                    address assetAddress = getSupportedAsset(assetId);\\n                    TokenTransfers.transferToDoNotBubbleErrors(\\n                        assetAddress,\\n                        feeReceiver,\\n                        txFee,\\n                        assetGasLimits[assetId]\\n                    );\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal utility function to withdraw funds from the contract to a receiver address\\n     * @param withdrawValue - value being withdrawn from the contract\\n     * @param receiverAddress - address receiving public ERC20 tokens\\n     * @param assetId - ID of the asset for which a withdrawl is being performed\\n     */\\n    function withdraw(\\n        uint256 withdrawValue,\\n        address receiverAddress,\\n        uint256 assetId\\n    ) internal validateAssetIdIsNotVirtual(assetId) {\\n        if (receiverAddress == address(0)) {\\n            revert WITHDRAW_TO_ZERO_ADDRESS();\\n        }\\n        if (assetId == 0) {\\n            // We explicitly do not throw if this call fails, as this opens up the possiblity of\\n            // griefing attacks, as engineering a failed withdrawal will invalidate an entire rollup block\\n            assembly {\\n                pop(call(30000, receiverAddress, withdrawValue, 0, 0, 0, 0))\\n            }\\n            // payable(receiverAddress).call{gas: 30000, value: withdrawValue}('');\\n        } else {\\n            // We explicitly do not throw if this call fails, as this opens up the possiblity of\\n            // griefing attacks, as engineering a failed withdrawal will invalidate an entire rollup block\\n            // the user should ensure their withdrawal will succeed or they will loose funds\\n            address assetAddress = getSupportedAsset(assetId);\\n            TokenTransfers.transferToDoNotBubbleErrors(\\n                assetAddress,\\n                receiverAddress,\\n                withdrawValue,\\n                assetGasLimits[assetId]\\n            );\\n        }\\n    }\\n\\n    /*----------------------------------------\\n      PUBLIC/EXTERNAL NON-MUTATING FUNCTIONS \\n      ----------------------------------------*/\\n\\n    /**\\n     * @dev Get the version number of the implementation\\n     * @return version - The version number of the implementation\\n     */\\n    function getImplementationVersion() public view virtual returns (uint8 version) {\\n        return 1;\\n    }\\n\\n    /**\\n     * @dev Get true if the contract is paused, false otherwise\\n     * @return isPaused - True if paused, false otherwise\\n     */\\n    function paused() external view override(IRollupProcessor) returns (bool isPaused) {\\n        return rollupState.paused;\\n    }\\n\\n    /**\\n     * @dev get the number of filled entries in the data tree.\\n     * This is equivalent to the number of notes created in the Aztec L2\\n     * @return dataSize\\n     */\\n    function getDataSize() public view override(IRollupProcessor) returns (uint256 dataSize) {\\n        assembly {\\n            dataSize := and(DATASIZE_MASK, shr(DATASIZE_BIT_OFFSET, sload(rollupState.slot)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Get number of pending defi interactions that have resolved but have not yet added into the Defi Tree\\n     * This value can never exceed 512. This is to prevent griefing attacks; `processRollup` iterates through `asyncDefiInteractionHashes` and\\n     * copies their values into `defiInteractionHashes`. Loop is bounded to < 512 so that tx does not exceed block gas limit\\n     * @return res the number of pending interactions\\n     */\\n    function getPendingDefiInteractionHashesLength() public view override(IRollupProcessor) returns (uint256 res) {\\n        assembly {\\n            let state := sload(rollupState.slot)\\n            let defiInteractionHashesLength := and(ARRAY_LENGTH_MASK, shr(DEFIINTERACTIONHASHES_BIT_OFFSET, state))\\n            let asyncDefiInteractionhashesLength := and(\\n                ARRAY_LENGTH_MASK,\\n                shr(ASYNCDEFIINTERACTIONHASHES_BIT_OFFSET, state)\\n            )\\n            res := add(defiInteractionHashesLength, asyncDefiInteractionhashesLength)\\n        }\\n    }\\n\\n    /**\\n     * @dev get the address of the PLONK verification smart contract\\n     * @return verifierAddress - address of the verification smart contract\\n     */\\n    function verifier() public view override(IRollupProcessor) returns (address verifierAddress) {\\n        // asm implementation to reduce compiled bytecode size\\n        assembly {\\n            verifierAddress := and(sload(rollupState.slot), ADDRESS_MASK)\\n        }\\n    }\\n\\n    /**\\n     * @dev Get the number of supported bridges\\n     * @return res The number of supported bridges\\n     */\\n    function getSupportedBridgesLength() external view override(IRollupProcessor) returns (uint256 res) {\\n        res = supportedBridges.length;\\n    }\\n\\n    /**\\n     * @dev Get the bridge contract address for a given bridgeAddressId\\n     * @param bridgeAddressId - identifier used to denote a particular bridge\\n     */\\n    function getSupportedBridge(uint256 bridgeAddressId) public view override(IRollupProcessor) returns (address) {\\n        return supportedBridges[bridgeAddressId - 1];\\n    }\\n\\n    /**\\n     * @dev Get the number of supported assets\\n     * @return res The number of supported assets\\n     */\\n    function getSupportedAssetsLength() external view override(IRollupProcessor) returns (uint256 res) {\\n        res = supportedAssets.length;\\n    }\\n\\n    /**\\n     * @dev Get the ERC20 token address of a supported asset, for a given assetId\\n     * @param assetId - identifier used to denote a particular asset\\n     */\\n    function getSupportedAsset(uint256 assetId) public view override(IRollupProcessor) returns (address) {\\n        // If the asset ID is >= 2^29, the asset represents a 'virtual' asset that has no ERC20 analogue\\n        // Virtual assets are used by defi bridges to track non-token data. E.g. to represent a loan.\\n        // If an assetId is *not* a virtual asset, its ERC20 address can be recovered from `supportedAssets[assetId]`\\n        if (assetId > 0x1fffffff) {\\n            revert INVALID_ASSET_ID();\\n        }\\n\\n        // If assetId == ethAssetId (i.e. 0), this represents native ETH.\\n        // ERC20 token asset id values start at 1\\n        if (assetId == ethAssetId) {\\n            return address(0x0);\\n        }\\n        address result = supportedAssets[assetId - 1];\\n        if (result == address(0)) {\\n            revert INVALID_ASSET_ADDRESS();\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Get the gas limit for the bridge specified by bridgeAddressId\\n     * @param bridgeAddressId - identifier used to denote a particular bridge\\n     */\\n    function getBridgeGasLimit(uint256 bridgeAddressId) public view override(IRollupProcessor) returns (uint256) {\\n        return bridgeGasLimits[bridgeAddressId];\\n    }\\n\\n    /**\\n     * @dev Get the status of the escape hatch, specifically retrieve whether the\\n     * hatch is open and also the number of blocks until the hatch will switch from\\n     * open to closed or vice versa\\n     */\\n    function getEscapeHatchStatus() public view override(IRollupProcessor) returns (bool, uint256) {\\n        uint256 blockNum = block.number;\\n\\n        bool isOpen = blockNum % escapeBlockUpperBound >= escapeBlockLowerBound;\\n        uint256 blocksRemaining = 0;\\n        if (isOpen) {\\n            // num blocks escape hatch will remain open for\\n            blocksRemaining = escapeBlockUpperBound - (blockNum % escapeBlockUpperBound);\\n        } else {\\n            // num blocks until escape hatch will be opened\\n            blocksRemaining = escapeBlockLowerBound - (blockNum % escapeBlockUpperBound);\\n        }\\n        return (isOpen, blocksRemaining);\\n    }\\n\\n    /**\\n     * @dev Get number of defi interaction hashes\\n     * A defi interaction hash represents a synchronous defi interaction that has resolved, but whose interaction result data\\n     * has not yet been added into the Aztec Defi Merkle tree. This step is needed in order to convert L2 Defi claim notes into L2 value notes\\n     * @return res the number of pending defi interaction hashes\\n     */\\n    function getDefiInteractionHashesLength() public view override(IRollupProcessor) returns (uint256 res) {\\n        assembly {\\n            res := and(ARRAY_LENGTH_MASK, shr(DEFIINTERACTIONHASHES_BIT_OFFSET, sload(rollupState.slot)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Get all pending defi interaction hashes\\n     * A defi interaction hash represents a synchronous defi interaction that has resolved, but whose interaction result data\\n     * has not yet been added into the Aztec Defi Merkle tree. This step is needed in order to convert L2 Defi claim notes into L2 value notes\\n     * @return res the set of all pending defi interaction hashes\\n     */\\n    function getDefiInteractionHashes() external view override(IRollupProcessor) returns (bytes32[] memory res) {\\n        uint256 len = getDefiInteractionHashesLength();\\n        assembly {\\n            // Allocate memory for return value\\n            res := mload(0x40)\\n            mstore(res, len)\\n            // Update 0x40 (the free memory pointer)\\n            mstore(0x40, add(res, add(0x20, mul(len, 0x20))))\\n\\n            // Prepare slot computation\\n            mstore(0x20, defiInteractionHashes.slot)\\n            let ptr := add(res, 0x20)\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n                i := add(i, 0x01)\\n            } {\\n                // Fetch defiInteractionHashes[i] and add it to the return value\\n                mstore(0x00, i)\\n                mstore(ptr, sload(keccak256(0x00, 0x40)))\\n                ptr := add(ptr, 0x20)\\n            }\\n        }\\n        return res;\\n    }\\n\\n    /**\\n     * @dev Get number of asynchronous defi interaction hashes\\n     * An async defi interaction hash represents an asynchronous defi interaction that has resolved, but whose interaction result data\\n     * has not yet been added into the Aztec Defi Merkle tree. This step is needed in order to convert L2 Defi claim notes into L2 value notes\\n     * @return res the number of pending async defi interaction hashes\\n     */\\n    function getAsyncDefiInteractionHashesLength() public view override(IRollupProcessor) returns (uint256 res) {\\n        assembly {\\n            res := and(ARRAY_LENGTH_MASK, shr(ASYNCDEFIINTERACTIONHASHES_BIT_OFFSET, sload(rollupState.slot)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Get all pending async defi interaction hashes\\n     * An async defi interaction hash represents an asynchronous defi interaction that has resolved, but whose interaction result data\\n     * has not yet been added into the Aztec Defi Merkle tree. This step is needed in order to convert L2 Defi claim notes into L2 value notes\\n     * @return res the set of all pending async defi interaction hashes\\n     */\\n    function getAsyncDefiInteractionHashes() external view override(IRollupProcessor) returns (bytes32[] memory res) {\\n        uint256 len = getAsyncDefiInteractionHashesLength();\\n        assembly {\\n            // Allocate memory for return value\\n            res := mload(0x40)\\n            mstore(res, len)\\n            // Update 0x40 (the free memory pointer)\\n            mstore(0x40, add(res, add(0x20, mul(len, 0x20))))\\n\\n            // Prepare slot computation\\n            mstore(0x20, asyncDefiInteractionHashes.slot)\\n            let ptr := add(res, 0x20)\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n                i := add(i, 0x01)\\n            } {\\n                // Fetch asyncDefiInteractionHashes[i] and add it to the return value\\n                mstore(0x00, i)\\n                mstore(ptr, sload(keccak256(0x00, 0x40)))\\n                ptr := add(ptr, 0x20)\\n            }\\n        }\\n        return res;\\n    }\\n\\n    /**\\n     * @dev Get the addresses of all supported bridge contracts\\n     */\\n    function getSupportedBridges()\\n        external\\n        view\\n        override(IRollupProcessor)\\n        returns (address[] memory, uint256[] memory)\\n    {\\n        uint256 supportedBridgesLength = supportedBridges.length;\\n        uint256[] memory gasLimits = new uint256[](supportedBridgesLength);\\n        for (uint256 i = 0; i < supportedBridgesLength; ) {\\n            gasLimits[i] = bridgeGasLimits[i + 1];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return (supportedBridges, gasLimits);\\n    }\\n\\n    /**\\n     * @dev Get the addresses of all supported ERC20 tokens\\n     */\\n    function getSupportedAssets()\\n        external\\n        view\\n        override(IRollupProcessor)\\n        returns (address[] memory, uint256[] memory)\\n    {\\n        uint256 supportedAssetsLength = supportedAssets.length;\\n        uint256[] memory gasLimits = new uint256[](supportedAssetsLength);\\n        for (uint256 i = 0; i < supportedAssetsLength; ) {\\n            gasLimits[i] = assetGasLimits[i + 1];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return (supportedAssets, gasLimits);\\n    }\\n\\n    /*----------------------------------------\\n      INTERNAL/PRIVATE NON-MUTATING FUNCTIONS\\n      ----------------------------------------*/\\n\\n    /**\\n     * @dev helper function to sanitise a given bridge gas limit value to be within pre-defined limits\\n     * @param bridgeGasLimit - the gas limit that needs to be sanitised\\n     */\\n    function sanitiseBridgeGasLimit(uint256 bridgeGasLimit) internal pure returns (uint256) {\\n        if (bridgeGasLimit < MIN_BRIDGE_GAS_LIMIT) {\\n            return MIN_BRIDGE_GAS_LIMIT;\\n        }\\n        if (bridgeGasLimit > MAX_BRIDGE_GAS_LIMIT) {\\n            return MAX_BRIDGE_GAS_LIMIT;\\n        }\\n        return bridgeGasLimit;\\n    }\\n\\n    /**\\n     * @dev helper function to sanitise a given asset gas limit value to be within pre-defined limits\\n     * @param assetGasLimit - the gas limit that needs to be sanitised\\n     */\\n    function sanitiseAssetGasLimit(uint256 assetGasLimit) internal pure returns (uint256) {\\n        if (assetGasLimit < MIN_ERC20_GAS_LIMIT) {\\n            return MIN_ERC20_GAS_LIMIT;\\n        }\\n        if (assetGasLimit > MAX_ERC20_GAS_LIMIT) {\\n            return MAX_ERC20_GAS_LIMIT;\\n        }\\n        return assetGasLimit;\\n    }\\n\\n    /**\\n     * @dev Unpack the bridgeId into a BridgeData struct\\n     * @param bridgeId - Bit-array that encodes data that describes a DeFi bridge.\\n     *\\n     * Structure of the bit array is as follows (starting at least significant bit):\\n     * | bit range | parameter       | description |\\n     * | 0 - 32    | bridgeAddressId | The address ID. Bridge address = `supportedBridges[bridgeAddressId]` |\\n     * | 32 - 62   | inputAssetIdA   | First input asset ID. |\\n     * | 62 - 92   | inputAssetIdB   | Second input asset ID. Must be 0 if bridge does not have a 2nd input asset. |\\n     * | 92 - 122  | outputAssetIdA  | First output asset ID. |\\n     * | 122 - 152 | outputAssetIdB  | Second output asset ID. Must be 0 if bridge does not have a 2nd output asset. |\\n     * | 152 - 184 | bitConfig       | Bit-array that contains boolean bridge settings. |\\n     * | 184 - 248 | auxData         | 64 bits of custom data to be passed to the bridge contract. Structure is defined/checked by the bridge contract. |\\n     *\\n     * Structure of the `bitConfig` parameter is as follows\\n     * | bit | parameter               | description |\\n     * | 0   | secondInputInUse        | Does the bridge have a second input asset? |\\n     * | 1   | secondOutputInUse       | Does the bridge have a second output asset? |\\n     *\\n     * Brief note on virtual assets: Virtual assets are assets that don't have an ERC20 token analogue and exist solely as notes within the Aztec network.\\n     * They can be created/spent as a result of DeFi interactions. They are used to enable defi bridges to track internally-defined data without having to\\n     * mint a new token on-chain.\\n     * An example use of a virtual asset would a virtual loan asset that tracks an outstanding debt that must be repaid to recover collateral deposited into the bridge.\\n     *\\n     * @return bridgeData - struct that contains bridgeId data in a human-readable form.\\n     */\\n    function getBridgeData(uint256 bridgeId) internal view returns (BridgeData memory bridgeData) {\\n        assembly {\\n            mstore(bridgeData, and(bridgeId, MASK_THIRTY_TWO_BITS)) // bridgeAddressId\\n            mstore(add(bridgeData, 0x40), and(shr(INPUT_ASSET_ID_A_SHIFT, bridgeId), MASK_THIRTY_BITS)) // inputAssetIdA\\n            mstore(add(bridgeData, 0x60), and(shr(INPUT_ASSET_ID_B_SHIFT, bridgeId), MASK_THIRTY_BITS)) // inputAssetIdB\\n            mstore(add(bridgeData, 0x80), and(shr(OUTPUT_ASSET_ID_A_SHIFT, bridgeId), MASK_THIRTY_BITS)) // outputAssetIdA\\n            mstore(add(bridgeData, 0xa0), and(shr(OUTPUT_ASSET_ID_B_SHIFT, bridgeId), MASK_THIRTY_BITS)) // outputAssetIdB\\n            mstore(add(bridgeData, 0xc0), and(shr(AUX_DATA_SHIFT, bridgeId), MASK_SIXTY_FOUR_BITS)) // auxData\\n\\n            mstore(\\n                add(bridgeData, 0xe0),\\n                and(shr(add(INPUT_ASSET_ID_A_SHIFT, VIRTUAL_ASSET_ID_FLAG_SHIFT), bridgeId), 1)\\n            ) // firstInputVirtual (30th bit of inputAssetIdA) == 1\\n            mstore(\\n                add(bridgeData, 0x100),\\n                and(shr(add(INPUT_ASSET_ID_B_SHIFT, VIRTUAL_ASSET_ID_FLAG_SHIFT), bridgeId), 1)\\n            ) // secondInputVirtual (30th bit of inputAssetIdB) == 1\\n            mstore(\\n                add(bridgeData, 0x120),\\n                and(shr(add(OUTPUT_ASSET_ID_A_SHIFT, VIRTUAL_ASSET_ID_FLAG_SHIFT), bridgeId), 1)\\n            ) // firstOutputVirtual (30th bit of outputAssetIdA) == 1\\n            mstore(\\n                add(bridgeData, 0x140),\\n                and(shr(add(OUTPUT_ASSET_ID_B_SHIFT, VIRTUAL_ASSET_ID_FLAG_SHIFT), bridgeId), 1)\\n            ) // secondOutputVirtual (30th bit of outputAssetIdB) == 1\\n            let bitConfig := and(shr(BITCONFIG_SHIFT, bridgeId), MASK_THIRTY_TWO_BITS)\\n            // bitConfig = bit mask that contains bridge ID settings\\n            // bit 0 = second input asset in use?\\n            // bit 1 = second output asset in use?\\n            mstore(add(bridgeData, 0x160), eq(and(bitConfig, 1), 1)) // secondInputInUse (bitConfig & 1) == 1\\n            mstore(add(bridgeData, 0x180), eq(and(shr(1, bitConfig), 1), 1)) // secondOutputInUse ((bitConfig >> 1) & 1) == 1\\n        }\\n        bridgeData.bridgeAddress = supportedBridges[bridgeData.bridgeAddressId - 1];\\n        bridgeData.bridgeGasLimit = getBridgeGasLimit(bridgeData.bridgeAddressId);\\n\\n        // potential conflicting states that are explicitly ruled out by circuit constraints:\\n        if (!bridgeData.secondInputInUse && bridgeData.inputAssetIdB > 0) {\\n            revert BRIDGE_ID_IS_INCONSISTENT();\\n        }\\n        if (!bridgeData.secondOutputInUse && bridgeData.outputAssetIdB > 0) {\\n            revert BRIDGE_ID_IS_INCONSISTENT();\\n        }\\n        if (bridgeData.secondInputInUse && (bridgeData.inputAssetIdA == bridgeData.inputAssetIdB)) {\\n            revert BRIDGE_WITH_IDENTICAL_INPUT_ASSETS(bridgeData.inputAssetIdA);\\n        }\\n        // Outputs can both be virtual. In that case, their asset ids will both be 2 ** 29.\\n        bool secondOutputReal = bridgeData.secondOutputInUse && !bridgeData.secondOutputVirtual;\\n        if (secondOutputReal && bridgeData.outputAssetIdA == bridgeData.outputAssetIdB) {\\n            revert BRIDGE_WITH_IDENTICAL_OUTPUT_ASSETS(bridgeData.outputAssetIdA);\\n        }\\n    }\\n\\n    /**\\n     * @dev Get the four input/output assets associated with a DeFi bridge\\n     * @param bridgeData - Information about the DeFi bridge\\n     * @param defiInteractionNonce - The defi interaction nonce\\n     *\\n     * @return inputAssetA inputAssetB outputAssetA outputAssetB : input and output assets represented as AztecAsset structs\\n     */\\n    function getAztecAssetTypes(BridgeData memory bridgeData, uint256 defiInteractionNonce)\\n        internal\\n        view\\n        returns (\\n            AztecTypes.AztecAsset memory inputAssetA,\\n            AztecTypes.AztecAsset memory inputAssetB,\\n            AztecTypes.AztecAsset memory outputAssetA,\\n            AztecTypes.AztecAsset memory outputAssetB\\n        )\\n    {\\n        if (bridgeData.firstInputVirtual) {\\n            // asset id will be defi interaction nonce that created note\\n            inputAssetA.id = bridgeData.inputAssetIdA - VIRTUAL_ASSET_ID_FLAG;\\n            inputAssetA.erc20Address = address(0x0);\\n            inputAssetA.assetType = AztecTypes.AztecAssetType.VIRTUAL;\\n        } else {\\n            inputAssetA.id = bridgeData.inputAssetIdA;\\n            inputAssetA.erc20Address = getSupportedAsset(bridgeData.inputAssetIdA);\\n            inputAssetA.assetType = inputAssetA.erc20Address == address(0x0)\\n                ? AztecTypes.AztecAssetType.ETH\\n                : AztecTypes.AztecAssetType.ERC20;\\n        }\\n        if (bridgeData.firstOutputVirtual) {\\n            // use nonce as asset id.\\n            outputAssetA.id = defiInteractionNonce;\\n            outputAssetA.erc20Address = address(0x0);\\n            outputAssetA.assetType = AztecTypes.AztecAssetType.VIRTUAL;\\n        } else {\\n            outputAssetA.id = bridgeData.outputAssetIdA;\\n            outputAssetA.erc20Address = getSupportedAsset(bridgeData.outputAssetIdA);\\n            outputAssetA.assetType = outputAssetA.erc20Address == address(0x0)\\n                ? AztecTypes.AztecAssetType.ETH\\n                : AztecTypes.AztecAssetType.ERC20;\\n        }\\n\\n        if (bridgeData.secondInputVirtual) {\\n            // asset id will be defi interaction nonce that created note\\n            inputAssetB.id = bridgeData.inputAssetIdB - VIRTUAL_ASSET_ID_FLAG;\\n            inputAssetB.erc20Address = address(0x0);\\n            inputAssetB.assetType = AztecTypes.AztecAssetType.VIRTUAL;\\n        } else if (bridgeData.secondInputInUse) {\\n            inputAssetB.id = bridgeData.inputAssetIdB;\\n            inputAssetB.erc20Address = getSupportedAsset(bridgeData.inputAssetIdB);\\n            inputAssetB.assetType = inputAssetB.erc20Address == address(0x0)\\n                ? AztecTypes.AztecAssetType.ETH\\n                : AztecTypes.AztecAssetType.ERC20;\\n        } else {\\n            inputAssetB.id = 0;\\n            inputAssetB.erc20Address = address(0x0);\\n            inputAssetB.assetType = AztecTypes.AztecAssetType.NOT_USED;\\n        }\\n\\n        if (bridgeData.secondOutputVirtual) {\\n            // use nonce as asset id.\\n            outputAssetB.id = defiInteractionNonce;\\n            outputAssetB.erc20Address = address(0x0);\\n            outputAssetB.assetType = AztecTypes.AztecAssetType.VIRTUAL;\\n        } else if (bridgeData.secondOutputInUse) {\\n            outputAssetB.id = bridgeData.outputAssetIdB;\\n            outputAssetB.erc20Address = getSupportedAsset(bridgeData.outputAssetIdB);\\n            outputAssetB.assetType = outputAssetB.erc20Address == address(0x0)\\n                ? AztecTypes.AztecAssetType.ETH\\n                : AztecTypes.AztecAssetType.ERC20;\\n        } else {\\n            outputAssetB.id = 0;\\n            outputAssetB.erc20Address = address(0x0);\\n            outputAssetB.assetType = AztecTypes.AztecAssetType.NOT_USED;\\n        }\\n    }\\n\\n    /**\\n     * @dev Get the length of the defi interaction hashes array and the number of pending interactions\\n     *\\n     * @return defiInteractionHashesLength the complete length of the defi interaction array\\n     * @return numPendingInteractions the current number of pending defi interactions\\n     */\\n    function getDefiHashesLengths()\\n        internal\\n        view\\n        returns (uint256 defiInteractionHashesLength, uint256 numPendingInteractions)\\n    {\\n        assembly {\\n            // retrieve the total length of the defi interactions array and also the number of pending interactions to a maximum of NUMBER_OF_BRIDGE_CALLS\\n            let state := sload(rollupState.slot)\\n            {\\n                defiInteractionHashesLength := and(ARRAY_LENGTH_MASK, shr(DEFIINTERACTIONHASHES_BIT_OFFSET, state))\\n                numPendingInteractions := defiInteractionHashesLength\\n                if gt(numPendingInteractions, NUMBER_OF_BRIDGE_CALLS) {\\n                    numPendingInteractions := NUMBER_OF_BRIDGE_CALLS\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Get the set of hashes that comprise the current pending defi interactions\\n     *\\n     * @return hashes the set of valid (i.e. non-zero) hashes that comprise the pending defi interactions\\n     * @return nextExpectedHash the hash of all hashes (including zero hashes) that comprise the pending defi interactions\\n     */\\n    function calculateNextExpectedDefiHash() internal view returns (bytes32[] memory hashes, bytes32 nextExpectedHash) {\\n        /**----------------------------------------\\n         * Compute nextExpectedHash\\n         *-----------------------------------------\\n         *\\n         * The `defiInteractionHashes` mapping emulates an array that represents the\\n         * set of defi interactions from previous blocks that have been resolved.\\n         *\\n         * We need to take the interaction result data from each of the above defi interactions,\\n         * and add that data into the Aztec L2 merkle tree that contains defi interaction results\\n         * (the \\\"Defi Tree\\\". Its merkle root is one of the inputs to the storage variable `rollupStateHash`)\\n         *\\n         * It is the rollup provider's responsibility to perform these additions.\\n         * In the current block being processed, the rollup provider must take these pending interaction results,\\n         * create commitments to each result and insert each commitment into the next empty leaf of the defi tree.\\n         *\\n         * The following code validates that this has happened! This is how:\\n         *\\n         * Part 1: What are we checking?\\n         *\\n         * The rollup circuit will receive, as a private input from the rollup provider, the pending defi interaction results\\n         * (`bridgeId`, `totalInputValue`, `totalOutputValueA`, `totalOutputValueB`, `result`)\\n         * The rollup circuit will compute the SHA256 hash of each interaction result (the defiInteractionHash)\\n         * Finally the SHA256 hash of `NUMBER_OF_BRIDGE_CALLS` of these defiInteractionHash values is computed.\\n         * (if there are fewer than `NUMBER_OF_BRIDGE_CALLS` pending defi interaction results, the SHA256 hash of an empty defi interaction result is used instead. i.e. all variable values are set to 0)\\n         * The above SHA256 hash, the `pendingDefiInteractionHash` is one of the broadcasted values that forms the `publicInputsHash` public input to the rollup circuit.\\n         * When verifying a rollup proof, this smart contract will compute `publicInputsHash` from the input calldata. The PLONK Verifier smart contract will then validate\\n         * that our computed value for `publicInputHash` matches the value used when generating the rollup proof.\\n         *\\n         * TLDR of the above: our proof data contains a variable `pendingDefiInteractionHash`, which is the CLAIMED VALUE of SHA256 hashing the SHA256 hashes of the defi interactions that have resolved but whose data has not yet been added into the defi tree.\\n         *\\n         * Part 2: How do we check `pendingDefiInteractionHash` is correct???\\n         *\\n         * This contract will call `DefiBridgeProxy.convert` (via delegatecall) on every new defi interaction present in the block.\\n         * The return values from the bridge proxy contract are used to construct a defi interaction result. Its hash is then computed\\n         * and stored in `defiInteractionHashes`.\\n         *\\n         * N.B. It's very important that DefiBridgeProxy does not call selfdestruct, or makes a delegatecall out to a contract that can selfdestruct :o\\n         *\\n         * Similarly, when async defi interactions resolve, the interaction result is stored in `asyncDefiInteractionHashes`. At the end of the processDefiBridges function,\\n         * the contents of the async array is copied into `defiInteractionHashes` (i.e. async interaction results are delayed by 1 rollup block. This is to prevent griefing attacks where\\n         * the rollup state changes between the time taken for a rollup tx to be constructed and the rollup tx to be mined)\\n         *\\n         * We use the contents of `defiInteractionHashes` to reconstruct `pendingDefiInteractionHash`, and validate it matches the value present in calldata and\\n         * therefore the value used in the rollup circuit when this block's rollup proof was constructed.\\n         * This validates that all of the required defi interaction results were added into the defi tree by the rollup provider\\n         * (the circuit logic enforces this, we just need to check the rollup provider used the correct inputs)\\n         */\\n        (uint256 defiInteractionHashesLength, uint256 numPendingInteractions) = getDefiHashesLengths();\\n        uint256 offset = defiInteractionHashesLength - numPendingInteractions;\\n        assembly {\\n            // allocate the output array of hashes\\n            hashes := mload(0x40)\\n            let hashData := add(hashes, 0x20)\\n            // update the free memory pointer to point past the end of our array\\n            // our array will consume 32 bytes for the length field plus NUMBER_OF_BRIDGE_BYTES for all of the hashes\\n            mstore(0x40, add(hashes, add(NUMBER_OF_BRIDGE_BYTES, 0x20)))\\n            // set the length of hashes to only include the non-zero hash values\\n            // although this function will write all of the hashes into our allocated memory, we only want to return the non-zero hashes\\n            mstore(hashes, numPendingInteractions)\\n\\n            // Prepare the reusable part of the defi interaction hashes slot computation\\n            mstore(0x20, defiInteractionHashes.slot)\\n            let i := 0\\n\\n            // Iterate over numPendingInteractions (will be between 0 and NUMBER_OF_BRIDGE_CALLS)\\n            // Load defiInteractionHashes[offset + i] and store in memory\\n            // in order to compute SHA2 hash (nextExpectedHash)\\n            for {\\n\\n            } lt(i, numPendingInteractions) {\\n                i := add(i, 0x01)\\n            } {\\n                // hashData[i] = defiInteractionHashes[offset + i]\\n                mstore(0x00, add(offset, i))\\n                mstore(add(hashData, mul(i, 0x20)), sload(keccak256(0x00, 0x40)))\\n            }\\n\\n            // If numPendingInteractions < NUMBER_OF_BRIDGE_CALLS, continue iterating up to NUMBER_OF_BRIDGE_CALLS, this time\\n            // inserting the \\\"zero hash\\\", the result of sha256(emptyDefiInteractionResult)\\n            for {\\n\\n            } lt(i, NUMBER_OF_BRIDGE_CALLS) {\\n                i := add(i, 0x01)\\n            } {\\n                // hashData[i] = DEFI_RESULT_ZERO_HASH\\n                mstore(add(hashData, mul(i, 0x20)), DEFI_RESULT_ZERO_HASH)\\n            }\\n            pop(staticcall(gas(), 0x2, hashData, NUMBER_OF_BRIDGE_BYTES, 0x00, 0x20))\\n            nextExpectedHash := mod(mload(0x00), CIRCUIT_MODULUS)\\n        }\\n    }\\n\\n    /**\\n     * @dev Process defi interactions.\\n     *      1. pop NUMBER_OF_BRIDGE_CALLS (if available) interaction hashes off of `defiInteractionHashes`,\\n     *         validate their hash (calculated at the end of the previous rollup and stored as nextExpectedDefiInteractionsHash) equals `numPendingInteractions`\\n     *         (this validates that rollup block has added these interaction results into the L2 data tree)\\n     *      2. iterate over rollup block's new defi interactions (up to NUMBER_OF_BRIDGE_CALLS). Trigger interactions by\\n     *         calling DefiBridgeProxy contract. Record results in either `defiInteractionHashes` (for synchrohnous txns)\\n     *         or, for async txns, the `pendingDefiInteractions` mapping\\n     *      3. copy the contents of `asyncInteractionHashes` into `defiInteractionHashes` && clear `asyncInteractionHashes`\\n     *      4. calculate the next value of nextExpectedDefiInteractionsHash from the new set of defiInteractionHashes\\n     * @param proofData - the proof data\\n     * @param rollupBeneficiary - the address that should be paid any subsidy for processing a defi bridge\\n     * @return nextExpectedHashes - the set of non-zero hashes that comprise the current pending defi interactions\\n     */\\n    function processDefiBridges(bytes memory proofData, address rollupBeneficiary)\\n        internal\\n        returns (bytes32[] memory nextExpectedHashes)\\n    {\\n        uint256 defiInteractionHashesLength;\\n        // Verify that nextExpectedDefiInteractionsHash equals the value given in the rollup\\n        // Then remove the set of pending hashes\\n        {\\n            // Extract the claimed value of previousDefiInteractionHash present in the proof data\\n            bytes32 providedDefiInteractionsHash = extractPrevDefiInteractionHash(proofData);\\n\\n            // Validate the stored interactionHash matches the value used when making the rollup proof!\\n            if (providedDefiInteractionsHash != prevDefiInteractionsHash) {\\n                revert INCORRECT_PREVIOUS_DEFI_INTERACTION_HASH(providedDefiInteractionsHash, prevDefiInteractionsHash);\\n            }\\n            uint256 numPendingInteractions;\\n            (defiInteractionHashesLength, numPendingInteractions) = getDefiHashesLengths();\\n            // numPendingInteraction equals the number of interactions expected to be in the given rollup\\n            // this is the length of the defiInteractionHashes array, capped at the NUM_BRIDGE_CALLS as per the following\\n            // numPendingInteractions = min(defiInteractionsHashesLength, numberOfBridgeCalls)\\n\\n            // Reduce DefiInteractionHashes.length by numPendingInteractions\\n            defiInteractionHashesLength -= numPendingInteractions;\\n\\n            assembly {\\n                // Update DefiInteractionHashes.length in storage\\n                let state := sload(rollupState.slot)\\n                let oldState := and(not(shl(DEFIINTERACTIONHASHES_BIT_OFFSET, ARRAY_LENGTH_MASK)), state)\\n                let newState := or(oldState, shl(DEFIINTERACTIONHASHES_BIT_OFFSET, defiInteractionHashesLength))\\n                sstore(rollupState.slot, newState)\\n            }\\n        }\\n        uint256 interactionNonce = getRollupId(proofData) * NUMBER_OF_BRIDGE_CALLS;\\n\\n        // ### Process DefiBridge Calls\\n        uint256 proofDataPtr;\\n        assembly {\\n            proofDataPtr := add(proofData, BRIDGE_IDS_OFFSET)\\n        }\\n        BridgeResult memory bridgeResult;\\n        assembly {\\n            bridgeResult := mload(0x40)\\n            mstore(0x40, add(bridgeResult, 0x80))\\n        }\\n        for (uint256 i = 0; i < NUMBER_OF_BRIDGE_CALLS; ) {\\n            uint256 bridgeId;\\n            assembly {\\n                bridgeId := mload(proofDataPtr)\\n            }\\n            if (bridgeId == 0) {\\n                // no more bridges to call\\n                break;\\n            }\\n            uint256 totalInputValue;\\n            assembly {\\n                totalInputValue := mload(add(proofDataPtr, mul(0x20, NUMBER_OF_BRIDGE_CALLS)))\\n            }\\n            if (totalInputValue == 0) {\\n                revert ZERO_TOTAL_INPUT_VALUE();\\n            }\\n\\n            BridgeData memory bridgeData = getBridgeData(bridgeId);\\n\\n            (\\n                AztecTypes.AztecAsset memory inputAssetA,\\n                AztecTypes.AztecAsset memory inputAssetB,\\n                AztecTypes.AztecAsset memory outputAssetA,\\n                AztecTypes.AztecAsset memory outputAssetB\\n            ) = getAztecAssetTypes(bridgeData, interactionNonce);\\n            assembly {\\n                // call the following function of DefiBridgeProxy via delegatecall...\\n                //     function convert(\\n                //          address bridgeAddress,\\n                //          AztecTypes.AztecAsset calldata inputAssetA,\\n                //          AztecTypes.AztecAsset calldata inputAssetB,\\n                //          AztecTypes.AztecAsset calldata outputAssetA,\\n                //          AztecTypes.AztecAsset calldata outputAssetB,\\n                //          uint256 totalInputValue,\\n                //          uint256 interactionNonce,\\n                //          uint256 auxInputData,\\n                //          uint256 ethPaymentsSlot,\\n                //          address rollupBeneficary\\n                //     )\\n\\n                // Construct the calldata we send to DefiBridgeProxy\\n                // mPtr = memory pointer. Set to free memory location (0x40)\\n                let mPtr := mload(0x40)\\n                // first 4 bytes is the function signature\\n                mstore(mPtr, DEFI_BRIDGE_PROXY_CONVERT_SELECTOR)\\n                mPtr := add(mPtr, 0x04)\\n\\n                let bridgeAddress := mload(add(bridgeData, 0x20))\\n                mstore(mPtr, bridgeAddress)\\n                mstore(add(mPtr, 0x20), mload(inputAssetA))\\n                mstore(add(mPtr, 0x40), mload(add(inputAssetA, 0x20)))\\n                mstore(add(mPtr, 0x60), mload(add(inputAssetA, 0x40)))\\n                mstore(add(mPtr, 0x80), mload(inputAssetB))\\n                mstore(add(mPtr, 0xa0), mload(add(inputAssetB, 0x20)))\\n                mstore(add(mPtr, 0xc0), mload(add(inputAssetB, 0x40)))\\n                mstore(add(mPtr, 0xe0), mload(outputAssetA))\\n                mstore(add(mPtr, 0x100), mload(add(outputAssetA, 0x20)))\\n                mstore(add(mPtr, 0x120), mload(add(outputAssetA, 0x40)))\\n                mstore(add(mPtr, 0x140), mload(outputAssetB))\\n                mstore(add(mPtr, 0x160), mload(add(outputAssetB, 0x20)))\\n                mstore(add(mPtr, 0x180), mload(add(outputAssetB, 0x40)))\\n                mstore(add(mPtr, 0x1a0), totalInputValue)\\n                mstore(add(mPtr, 0x1c0), interactionNonce)\\n\\n                let auxData := mload(add(bridgeData, 0xc0))\\n                mstore(add(mPtr, 0x1e0), auxData)\\n                mstore(add(mPtr, 0x200), ethPayments.slot)\\n                mstore(add(mPtr, 0x220), rollupBeneficiary)\\n\\n                // Call the bridge proxy via delegatecall!\\n                // We want the proxy to share state with the rollup processor, as the proxy is the entity sending/recovering tokens from the bridge contracts.\\n                // We wrap this logic in a delegatecall so that if the call fails (i.e. the bridge interaction fails), we can unwind bridge-interaction specific state changes,\\n                // without reverting the entire transaction.\\n                let success := delegatecall(\\n                    mload(add(bridgeData, 0x1a0)), // bridgeData.gasSentToBridge\\n                    sload(defiBridgeProxy.slot),\\n                    sub(mPtr, 0x04),\\n                    0x244,\\n                    0,\\n                    0\\n                )\\n                returndatacopy(mPtr, 0, returndatasize())\\n\\n                switch success\\n                case 1 {\\n                    mstore(bridgeResult, mload(mPtr)) // outputValueA\\n                    mstore(add(bridgeResult, 0x20), mload(add(mPtr, 0x20))) // outputValueB\\n                    mstore(add(bridgeResult, 0x40), mload(add(mPtr, 0x40))) // isAsync\\n                    mstore(add(bridgeResult, 0x60), 1) // success\\n                }\\n                default {\\n                    // If the call failed, mark this interaction as failed. No tokens have been exchanged, users can\\n                    // use the \\\"claim\\\" circuit to recover the initial tokens they sent to the bridge\\n                    mstore(bridgeResult, 0) // outputValueA\\n                    mstore(add(bridgeResult, 0x20), 0) // outputValueB\\n                    mstore(add(bridgeResult, 0x40), 0) // isAsync\\n                    mstore(add(bridgeResult, 0x60), 0) // success\\n                }\\n            }\\n\\n            if (!bridgeData.secondOutputInUse) {\\n                bridgeResult.outputValueB = 0;\\n            }\\n\\n            // emit events and update state\\n            assembly {\\n                // if interaction is Async, update pendingDefiInteractions\\n                // if interaction is synchronous, compute the interaction hash and add to defiInteractionHashes\\n                switch mload(add(bridgeResult, 0x40)) // switch isAsync\\n                case 1 {\\n                    let mPtr := mload(0x40)\\n                    // emit AsyncDefiBridgeProcessed(indexed bridgeId, indexed interactionNonce, totalInputValue)\\n                    {\\n                        mstore(mPtr, totalInputValue)\\n                        log3(mPtr, 0x20, ASYNC_BRIDGE_PROCESSED_SIGHASH, bridgeId, interactionNonce)\\n                    }\\n                    // pendingDefiInteractions[interactionNonce] = PendingDefiBridgeInteraction(bridgeId, totalInputValue)\\n                    mstore(0x00, interactionNonce)\\n                    mstore(0x20, pendingDefiInteractions.slot)\\n                    let pendingDefiInteractionsSlotBase := keccak256(0x00, 0x40)\\n\\n                    sstore(pendingDefiInteractionsSlotBase, bridgeId)\\n                    sstore(add(pendingDefiInteractionsSlotBase, 0x01), totalInputValue)\\n                }\\n                default {\\n                    let mPtr := mload(0x40)\\n                    // prepare the data required to publish the DefiBridgeProcessed event, we will only publish it if isAsync == false\\n                    // async interactions that have failed, have their isAsync property modified to false above\\n                    // emit DefiBridgeProcessed(indexed bridgeId, indexed interactionNonce, totalInputValue, outputValueA, outputValueB, success)\\n\\n                    {\\n                        mstore(mPtr, totalInputValue)\\n                        mstore(add(mPtr, 0x20), mload(bridgeResult)) // outputValueA\\n                        mstore(add(mPtr, 0x40), mload(add(bridgeResult, 0x20))) // outputValueB\\n                        mstore(add(mPtr, 0x60), mload(add(bridgeResult, 0x60))) // success\\n                        mstore(add(mPtr, 0x80), 0xa0) // position in event data block of `bytes` object\\n\\n                        if mload(add(bridgeResult, 0x60)) {\\n                            mstore(add(mPtr, 0xa0), 0)\\n                            log3(mPtr, 0xc0, DEFI_BRIDGE_PROCESSED_SIGHASH, bridgeId, interactionNonce)\\n                        }\\n                        if iszero(mload(add(bridgeResult, 0x60))) {\\n                            mstore(add(mPtr, 0xa0), returndatasize())\\n                            let size := returndatasize()\\n                            let remainder := mul(iszero(iszero(size)), sub(32, mod(size, 32)))\\n                            returndatacopy(add(mPtr, 0xc0), 0, size)\\n                            mstore(add(mPtr, add(0xc0, size)), 0)\\n                            log3(\\n                                mPtr,\\n                                add(0xc0, add(size, remainder)),\\n                                DEFI_BRIDGE_PROCESSED_SIGHASH,\\n                                bridgeId,\\n                                interactionNonce\\n                            )\\n                        }\\n                    }\\n                    // compute defiInteractionnHash\\n                    mstore(mPtr, bridgeId)\\n                    mstore(add(mPtr, 0x20), interactionNonce)\\n                    mstore(add(mPtr, 0x40), totalInputValue)\\n                    mstore(add(mPtr, 0x60), mload(bridgeResult)) // outputValueA\\n                    mstore(add(mPtr, 0x80), mload(add(bridgeResult, 0x20))) // outputValueB\\n                    mstore(add(mPtr, 0xa0), mload(add(bridgeResult, 0x60))) // success\\n                    pop(staticcall(gas(), 0x2, mPtr, 0xc0, 0x00, 0x20))\\n                    let defiInteractionHash := mod(mload(0x00), CIRCUIT_MODULUS)\\n\\n                    // defiInteractionHashes[defiInteractionHashesLength] = defiInteractionHash;\\n                    mstore(0x00, defiInteractionHashesLength)\\n                    mstore(0x20, defiInteractionHashes.slot)\\n                    sstore(keccak256(0x00, 0x40), defiInteractionHash)\\n\\n                    // Increase the length of defiInteractionHashes by 1\\n                    defiInteractionHashesLength := add(defiInteractionHashesLength, 0x01)\\n                }\\n\\n                // advance interactionNonce and proofDataPtr\\n                interactionNonce := add(interactionNonce, 0x01)\\n                proofDataPtr := add(proofDataPtr, 0x20)\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        assembly {\\n            /**\\n             * Cleanup\\n             *\\n             * 1. Copy asyncDefiInteractionHashes into defiInteractionHashes\\n             * 2. Update defiInteractionHashes.length\\n             * 2. Clear asyncDefiInteractionHashes.length\\n             */\\n            let state := sload(rollupState.slot)\\n\\n            let asyncDefiInteractionHashesLength := and(\\n                ARRAY_LENGTH_MASK,\\n                shr(ASYNCDEFIINTERACTIONHASHES_BIT_OFFSET, state)\\n            )\\n\\n            // Validate we are not overflowing our 1024 array size\\n            let arrayOverflow := gt(\\n                add(asyncDefiInteractionHashesLength, defiInteractionHashesLength),\\n                ARRAY_LENGTH_MASK\\n            )\\n\\n            // Throw an error if defiInteractionHashesLength > ARRAY_LENGTH_MASK (i.e. is >= 1024)\\n            // should never hit this! If block `i` generates synchronous txns,\\n            // block 'i + 1' must process them.\\n            // Only way this array size hits 1024 is if we produce a glut of async interaction results\\n            // between blocks. HOWEVER we ensure that async interaction callbacks fail iff they would increase\\n            // defiInteractionHashes length to be >= 512\\n            // Still, can't hurt to check...\\n            if arrayOverflow {\\n                // keccak256(\\\"ARRAY_OVERFLOW()\\\")\\n                mstore(0x00, 0x58a4ab0e00000000000000000000000000000000000000000000000000000000)\\n                revert(0x00, 0x04)\\n            }\\n\\n            // Now, copy async hashes into defiInteractionHashes\\n\\n            // Cache the free memory pointer\\n            let freePtr := mload(0x40)\\n\\n            // Prepare the reusable parts of slot computation\\n            mstore(0x20, defiInteractionHashes.slot)\\n            mstore(0x60, asyncDefiInteractionHashes.slot)\\n            for {\\n                let i := 0\\n            } lt(i, asyncDefiInteractionHashesLength) {\\n                i := add(i, 1)\\n            } {\\n                // defiInteractionHashesLength[defiInteractionHashesLength + i] = asyncDefiInteractionHashes[i]\\n                mstore(0x00, add(defiInteractionHashesLength, i))\\n                mstore(0x40, i)\\n                sstore(keccak256(0x00, 0x40), sload(keccak256(0x40, 0x40)))\\n            }\\n            // Restore the free memory pointer\\n            mstore(0x40, freePtr)\\n\\n            // clear defiInteractionHashesLength in state\\n            state := and(not(shl(DEFIINTERACTIONHASHES_BIT_OFFSET, ARRAY_LENGTH_MASK)), state)\\n\\n            // write new defiInteractionHashesLength in state\\n            state := or(\\n                shl(\\n                    DEFIINTERACTIONHASHES_BIT_OFFSET,\\n                    add(asyncDefiInteractionHashesLength, defiInteractionHashesLength)\\n                ),\\n                state\\n            )\\n\\n            // clear asyncDefiInteractionHashesLength in state\\n            state := and(not(shl(ASYNCDEFIINTERACTIONHASHES_BIT_OFFSET, ARRAY_LENGTH_MASK)), state)\\n\\n            // write new state\\n            sstore(rollupState.slot, state)\\n        }\\n\\n        // now we want to extract the next set of pending defi interaction hashes and calculate their hash to store for the next rollup\\n        (bytes32[] memory hashes, bytes32 nextExpectedHash) = calculateNextExpectedDefiHash();\\n        nextExpectedHashes = hashes;\\n        prevDefiInteractionsHash = nextExpectedHash;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = _setInitializedVersion(1);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        bool isTopLevelCall = _setInitializedVersion(version);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(version);\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        _setInitializedVersion(type(uint8).max);\\n    }\\n\\n    function _setInitializedVersion(uint8 version) private returns (bool) {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\\n        // of initializers, because in other contexts the contract may have been reentered.\\n        if (_initializing) {\\n            require(\\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\\n                \\\"Initializable: contract is already initialized\\\"\\n            );\\n            return false;\\n        } else {\\n            require(_initialized < version, \\\"Initializable: contract is already initialized\\\");\\n            _initialized = version;\\n            return true;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\ninterface IVerifier {\\n    function verify(bytes memory serialized_proof, uint256 _publicInputsHash) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IERC20Permit is IERC20 {\\n    function nonces(address user) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Decoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\n/**\\n * ----------------------------------------\\n *  PROOF DATA SPECIFICATION\\n * ----------------------------------------\\n * Our input \\\"proof data\\\" is represented as a single byte array - we use a custom encoding the encode the\\n * data associated with a rollup block. The encoded structure is as follows (excluding the length param of the bytes type):\\n * \\n   | byte range      | num bytes        | name                             | description |\\n   | ---             | ---              | ---                              | ---         |\\n   | 0x00  - 0x20    | 32               | rollupId                         | Unique rollup block identifier. Equivalent to block number |\\n   | 0x20  - 0x40    | 32               | rollupSize                       | Max number of transactions in the block |\\n   | 0x40  - 0x60    | 32               | dataStartIndex                   | Position of the next empty slot in the Aztec data tree |\\n   | 0x60  - 0x80    | 32               | oldDataRoot                      | Root of the data tree prior to rollup block's state updates |\\n   | 0x80  - 0xa0    | 32               | newDataRoot                      | Root of the data tree after rollup block's state updates |\\n   | 0xa0  - 0xc0    | 32               | oldNullRoot                      | Root of the nullifier tree prior to rollup block's state updates |\\n   | 0xc0  - 0xe0    | 32               | newNullRoot                      | Root of the nullifier tree after rollup block's state updates |\\n   | 0xe0  - 0x100   | 32               | oldDataRootsRoot                 | Root of the tree of data tree roots prior to rollup block's state updates |\\n   | 0x100 - 0x120   | 32               | newDataRootsRoot                 | Root of the tree of data tree roots after rollup block's state updates |\\n   | 0x120 - 0x140   | 32               | oldDefiRoot                      | Root of the defi tree prior to rollup block's state updates |\\n   | 0x140 - 0x160   | 32               | newDefiRoot                      | Root of the defi tree after rollup block's state updates |\\n   | 0x160 - 0x560   | 1024             | bridgeIds[NUMBER_OF_BRIDGE_CALLS]   | Size-32 array of bridgeIds for bridges being called in this block. If bridgeId == 0, no bridge is called |\\n   | 0x560 - 0x960   | 1024             | depositSums[NUMBER_OF_BRIDGE_CALLS] | Size-32 array of deposit values being sent for bridges being called in this block |\\n   | 0x960 - 0xb60   | 512              | assetIds[NUMBER_OF_ASSETS]         | Size-16 array of the assetIds for assets being deposited/withdrawn/used to pay fees in this block |\\n   | 0xb60 - 0xd60   | 512              | txFees[NUMBER_OF_ASSETS]           | Size-16 array of transaction fees paid to the rollup beneficiary, denominated in each assetId |\\n   | 0xd60 - 0x1160  | 1024             | interactionNotes[NUMBER_OF_BRIDGE_CALLS] | Size-32 array of defi interaction result commitments that must be inserted into the defi tree at this rollup block |\\n   | 0x1160 - 0x1180 | 32               | prevDefiInteractionHash          | A SHA256 hash of the data used to create each interaction result commitment. Used to validate correctness of interactionNotes |\\n   | 0x1180 - 0x11a0 | 32               | rollupBeneficiary                | The address that the fees from this rollup block should be sent to. Prevents a rollup proof being taken from the transaction pool and having its fees redirected |\\n   | 0x11a0 - 0x11c0 | 32               | numRollupTxs                     | Number of \\\"inner rollup\\\" proofs used to create the block proof. \\\"inner rollup\\\" circuits process 3-28 user txns, the outer rollup circuit processes 1-28 inner rollup proofs. |\\n   | 0x11c0 - 0x11c4 | 4                | numRealTxs                       | Number of transactions in the rollup excluding right-padded padding proofs\\n   | 0x11c4 - 0x11c8 | 4                | encodedInnerTxData.length        | Number of bytes of encodedInnerTxData |\\n   | 0x11c8 - end    | encodedInnerTxData.length | encodedInnerTxData      | Encoded inner transaction data. Contains encoded form of the broadcasted data associated with each tx in the rollup block |\\n **/\\n\\n /**\\n  * --------------------------------------------\\n  *  DETERMINING THE NUMBER OF REAL TRANSACTIONS\\n  * --------------------------------------------\\n  * The `rollupSize` parameter describes the MAX number of txns in a block.\\n  * However the block may not be full.\\n  * Incomplete blocks will be padded with \\\"padding\\\" transactions that represent empty txns.\\n  *\\n  * The amount of end padding is not explicitly defined in `proofData`. It is derived.\\n  * The encodedInnerTxData does not include tx data for the txns associated with this end padding.\\n  * (it does include any padding transactions that are not part of the end padding, which can sometimes happen)\\n  * When decoded, the transaction data for each transaction is a fixed size (256 bytes)\\n  * Number of real transactions = rollupSize - (decoded tx data size / 256)\\n  *\\n  * The decoded transaction data associated with padding transactions is 256 zero bytes.\\n **/\\n\\n/**\\n * @title Decoder\\n * @dev contains functions for decoding/extracting the encoded proof data passed in as calldata,\\n * as well as computing the SHA256 hash of the decoded data (publicInputsHash).\\n * The publicInputsHash is used to ensure the data passed in as calldata matches the data used within the rollup circuit\\n */\\ncontract Decoder {\\n\\n    /*----------------------------------------\\n      CONSTANTS\\n      ----------------------------------------*/\\n    uint256 internal constant NUMBER_OF_ASSETS = 16; // max number of assets in a block\\n    uint256 internal constant NUMBER_OF_BRIDGE_CALLS = 32; // max number of bridge calls in a block\\n    uint256 internal constant NUMBER_OF_BRIDGE_BYTES = 1024; // NUMBER_OF_BRIDGE_CALLS * 32\\n    uint256 internal constant NUMBER_OF_PUBLIC_INPUTS_PER_TX = 8; // number of ZK-SNARK \\\"public inputs\\\" per join-split/account/claim transaction\\n    uint256 internal constant TX_PUBLIC_INPUT_LENGTH = 256; // byte-length of NUMBER_OF_PUBLIC_INPUTS_PER_TX. NUMBER_OF_PUBLIC_INPUTS_PER_TX * 32;\\n    uint256 internal constant ROLLUP_NUM_HEADER_INPUTS = 142; // 58; // number of ZK-SNARK \\\"public inputs\\\" that make up the rollup header 14 + (NUMBER_OF_BRIDGE_CALLS * 3) + (NUMBER_OF_ASSETS * 2);\\n    uint256 internal constant ROLLUP_HEADER_LENGTH = 4544; // 1856; // ROLLUP_NUM_HEADER_INPUTS * 32;\\n\\n    // ENCODED_PROOF_DATA_LENGTH_OFFSET = byte offset into the rollup header such that `numRealTransactions` occupies\\n    // the least significant 4 bytes of the 32-byte word being pointed to.\\n    // i.e. ROLLUP_HEADER_LENGTH - 28\\n    uint256 internal constant NUM_REAL_TRANSACTIONS_OFFSET = 4516;\\n\\n    // ENCODED_PROOF_DATA_LENGTH_OFFSET = byte offset into the rollup header such that `encodedInnerProofData.length` occupies\\n    // the least significant 4 bytes of the 32-byte word being pointed to.\\n    // i.e. ROLLUP_HEADER_LENGTH - 24\\n    uint256 internal constant ENCODED_PROOF_DATA_LENGTH_OFFSET = 4520;\\n\\n    // offset we add to `proofData` to point to the bridgeIds\\n    uint256 internal constant BRIDGE_IDS_OFFSET = 0x180;\\n\\n    // offset we add to `proofData` to point to prevDefiInteractionhash\\n    uint256 internal constant PREVIOUS_DEFI_INTERACTION_HASH_OFFSET = 4480; // ROLLUP_HEADER_LENGTH - 0x40\\n\\n    // offset we add to `proofData` to point to rollupBeneficiary\\n    uint256 internal constant ROLLUP_BENEFICIARY_OFFSET = 4512; // ROLLUP_HEADER_LENGTH - 0x20\\n\\n    // CIRCUIT_MODULUS = group order of the BN254 elliptic curve. All arithmetic gates in our ZK-SNARK circuits are evaluated modulo this prime.\\n    // Is used when computing the public inputs hash - our SHA256 hash outputs are reduced modulo CIRCUIT_MODULUS\\n    uint256 internal constant CIRCUIT_MODULUS =\\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n    // SHA256 hashes\\n    uint256 internal constant PADDING_ROLLUP_HASH_SIZE_1 =\\n        0x22dd983f8337d97d56071f7986209ab2ee6039a422242e89126701c6ee005af0;\\n    uint256 internal constant PADDING_ROLLUP_HASH_SIZE_2 =\\n        0x076a27c79e5ace2a3d47f9dd2e83e4ff6ea8872b3c2218f66c92b89b55f36560;\\n    uint256 internal constant PADDING_ROLLUP_HASH_SIZE_4 =\\n        0x2f0c70a5bf5460465e9902f9c96be324e8064e762a5de52589fdb97cbce3c6ee;\\n    uint256 internal constant PADDING_ROLLUP_HASH_SIZE_8 =\\n        0x240ed0de145447ff0ceff2aa477f43e0e2ed7f3543ee3d8832f158ec76b183a9;\\n    uint256 internal constant PADDING_ROLLUP_HASH_SIZE_16 =\\n        0x1c52c159b4dae66c3dcf33b44d4d61ead6bc4d260f882ac6ba34dccf78892ca4;\\n    uint256 internal constant PADDING_ROLLUP_HASH_SIZE_32 =\\n        0x0df0e06ab8a02ce2ff08babd7144ab23ca2e99ddf318080cf88602eeb8913d44;\\n    uint256 internal constant PADDING_ROLLUP_HASH_SIZE_64 =\\n        0x1f83672815ac9b3ca31732d641784035834e96b269eaf6a2e759bf4fcc8e5bfd;\\n\\n    uint256 internal constant ADDRESS_MASK = 0x00ffffffffffffffffffffffffffffffffffffffff;\\n\\n    /*----------------------------------------\\n      ERROR TAGS\\n      ----------------------------------------*/\\n    error ENCODING_BYTE_INVALID();\\n    error INVALID_ROLLUP_TOPOLOGY();\\n\\n    /*----------------------------------------\\n      DECODING FUNCTIONS\\n      ----------------------------------------*/\\n    /**\\n     * In `bytes proofData`, transaction data is appended after the rollup header data\\n     * Each transaction is described by 8 'public inputs' used to create a user transaction ZK-SNARK proof\\n     * (i.e. there are 8 public inputs for each of the \\\"join-split\\\", \\\"account\\\" and \\\"claim\\\" circuits)\\n     * The public inputs are represented in calldata according to the following specification:\\n     *\\n     * | public input idx | calldata size (bytes) | variable | description |\\n     * | 0                | 1                     |proofId         | transaction type identifier       |\\n     * | 1                | 32                    | encrypted form of 1st output note |\\n     * | 2                | 32                    | encrypted form of 2nd output note |\\n     * | 3                | 32                    | nullifier of 1st input note       |\\n     * | 4                | 32                    | nullifier of 2nd input note       |\\n     * | 5                | 32                    | amount being deposited or withdrawn |\\n     * | 6                | 20                    | address of depositor or withdraw destination |\\n     * | 7                | 4                     | assetId used in transaction |\\n     *\\n     * The following table maps proofId values to transaction types\\n     *\\n     *\\n     * | proofId | tx type     | description |\\n     * | ---     | ---         | ---         |\\n     * | 0       | padding     | empty transaction. Rollup blocks have a fixed number of txns. If number of real txns is less than block size, padding txns make up the difference |\\n     * | 1       | deposit     | deposit Eth/tokens into Aztec in exchange for encrypted Aztec notes |\\n     * | 2       | withdraw    | exchange encrypted Aztec notes for Eth/tokens sent to a public address |\\n     * | 3       | send        | private send |\\n     * | 4       | account     | creates an Aztec account |\\n     * | 5       | defiDeposit | deposit Eth/tokens into a L1 smart contract via a Defi bridge contract |\\n     * | 6       | defiClaim   | convert proceeds of defiDeposit tx back into encrypted Aztec notes |\\n     *\\n     * Most of the above transaction types do not use the full set of 8 public inputs (i.e. some are zero).\\n     * To save on calldata costs, we encode each transaction into the smallest payload possible.\\n     * In `decodeProof`, the encoded transaction data decoded, with the decoded tx data written into memory\\n     *\\n     * As part of the decoding algorithms we must convert the 20-byte `publicOwner` and 4-byte `assetId` fields\\n     * into 32-byte EVM words\\n     *\\n     * The following functions perform transaction-specific decoding. The `proofId` field is decoded prior to calling these functions\\n     */\\n\\n    /**\\n     * @dev decode a padding tx\\n     * @param inPtr location in calldata of the encoded transaction\\n     * @return location in calldata of the next encoded transaction\\n     *\\n     * Encoded padding tx consists of 1 byte, the `proofId`\\n     * The proofId has been written into memory before we called this function so there is nothing to copy.\\n     * Advance the calldatapointer by 1 byte to move to the next transaction\\n     */\\n    function paddingTx(uint256 inPtr, uint256) internal pure returns (uint256) {\\n        unchecked{\\n            return (inPtr + 0x1);\\n        }\\n    }\\n\\n    /**\\n     * @dev decode a deposit or a withdraw tx\\n     * @param inPtr location in calldata of the encoded transaction\\n     * @param outPtr location in memory to write the decoded transaction to\\n     * @return location in calldata of the next encoded transaction\\n     *\\n     * the deposit tx uses all 8 public inputs. All calldata is copied into memory\\n     */\\n    function depositOrWithdrawTx(uint256 inPtr, uint256 outPtr) internal pure returns (uint256) {\\n        // Copy deposit calldata into memory\\n        assembly {\\n            // start copying into `outPtr + 0x20`, as `outPtr` points to `proofId`, which has already been written into memry\\n            calldatacopy(add(outPtr, 0x20), add(inPtr, 0x20), 0xa0) // noteCommitment1 ... publicValue\\n            calldatacopy(add(outPtr, 0xcc), add(inPtr, 0xc0), 0x14) // convert 20-byte publicOwner calldata variable into 32-byte EVM word\\n            calldatacopy(add(outPtr, 0xfc), add(inPtr, 0xd4), 0x4) // convert 4-byte assetId variable into 32-byte EVM word\\n        }\\n        // advance calldata ptr by 185 bytes\\n        unchecked {\\n            return (inPtr + 0xb9);\\n        }\\n    }\\n\\n    /**\\n     * @dev decode a send tx\\n     * @param inPtr location in calldata of the encoded transaction\\n     * @param outPtr location in memory to write the decoded transaction to\\n     * @return location in calldata of the next encoded transaction\\n     *\\n     * The send tx has 0-values for `publicValue`, `publicOwner` and `assetId`\\n     * No need to copy anything into memory for these fields as memory defaults to 0\\n     */\\n    function sendTx(uint256 inPtr, uint256 outPtr) internal pure returns (uint256) {\\n        assembly {\\n            calldatacopy(add(outPtr, 0x20), add(inPtr, 0x20), 0x80) // noteCommitment1 ... nullifier2\\n        }\\n        unchecked {\\n            return (inPtr + 0x81);\\n        }\\n    }\\n\\n    /**\\n     * @dev decode an account tx\\n     * @param inPtr location in calldata of the encoded transaction\\n     * @param outPtr location in memory to write the decoded transaction to\\n     * @return location in calldata of the next encoded transaction\\n     *\\n     * The send tx has 0-values for `nullifier2`, `publicValue`, `publicOwner` and `assetId`\\n     * No need to copy anything into memory for these fields as memory defaults to 0\\n     */\\n    function accountTx(uint256 inPtr, uint256 outPtr) internal pure returns (uint256) {\\n        assembly {\\n            calldatacopy(add(outPtr, 0x20), add(inPtr, 0x20), 0x80) // noteCommitment1 ... nullifier2\\n        }\\n        unchecked {\\n            return (inPtr + 0x81);\\n        }\\n    }\\n\\n    /**\\n     * @dev decode a defi deposit or claim tx\\n     * @param inPtr location in calldata of the encoded transaction\\n     * @param outPtr location in memory to write the decoded transaction to\\n     * @return location in calldata of the next encoded transaction\\n     *\\n     * The defi deposit/claim txns has 0-values for `publicValue`, `publicOwner` and `assetId`\\n     * No need to copy anything into memory for these fields as memory defaults to 0\\n     */\\n    function defiDepositOrClaimTx(uint256 inPtr, uint256 outPtr) internal pure returns (uint256) {\\n        assembly {\\n            calldatacopy(add(outPtr, 0x20), add(inPtr, 0x20), 0x80) // noteCommitment1 ... nullifier2\\n        }\\n        unchecked {\\n            return (inPtr + 0x81);\\n        }\\n    }\\n\\n    /**\\n     * @dev invalid transaction function\\n     * If we hit this, there is a transaction whose proofId is invalid (i.e. not 0 to 7).\\n     * Throw an error and revert the tx.\\n     */\\n    function invalidTx(uint256, uint256) internal pure returns (uint256) {\\n        revert ENCODING_BYTE_INVALID();\\n    }\\n\\n    /**\\n     * @dev decodes the rollup block's proof data\\n     * This function converts the proof data into a representation we can work with in memory\\n     * In particular, encoded transaction calldata is decoded and written into memory\\n     * The rollup header is also copied from calldata into memory\\n     * @return proofData numTxs publicInputsHash\\n     * proofData is a memory pointer to the decoded proof data\\n     *\\n     * The publicInputsHash is a sha256 hash of the public inputs associated with each transaction in the rollup.\\n     * It is used to validate the correctness of the data being fed into the rollup circuit\\n     * (there is a bit of nomenclature abuse here. Processing a public input in the verifier algorithm costs 150 gas, which\\n     * adds up very quickly. Instead of this, we sha256 hash what used to be the \\\"public\\\" inputs and only set the hash to be public.\\n     * We then make the old \\\"public\\\" inputs private in the rollup circuit, and validate their correctness by checking their sha256 hash matches\\n     * what we compute in the decodeProof function!\\n     *\\n     * numTxs = number of transactions in the rollup, excluding end-padding transactions\\n     * \\n     */\\n    function decodeProof()\\n        internal\\n        view\\n        returns (\\n            bytes memory proofData,\\n            uint256 numTxs,\\n            uint256 publicInputsHash\\n        )\\n    {\\n        // declare some variables that will be set inside asm blocks\\n        uint256 dataSize; // size of our decoded transaction data, in bytes\\n        uint256 outPtr; // memory pointer to where we will write our decoded transaction data\\n        uint256 inPtr; // calldata pointer into our proof data\\n        uint256 rollupSize; // max number of transactions in the rollup block\\n        uint256 decodedTxDataStart;\\n\\n        {\\n            uint256 tailInPtr; // calldata pointer to the end of our proof data\\n\\n            /**\\n             * Let's build a function table!\\n             *\\n             * To decode our tx data, we need to iterate over every encoded transaction and call its\\n             * associated decoding function. If we did this via a `switch` statement this would be VERY expensive,\\n             * due to the large number of JUMPI instructions that would be called.\\n             *\\n             * Instead, we use function pointers.\\n             * The `proofId` field in our encoded proof data is an integer from 0-6,\\n             * we can use `proofId` to index a table of function pointers for our respective decoding functions.\\n             * This is much faster as there is no conditional branching!\\n             */\\n            function(uint256, uint256) pure returns (uint256) callfunc; // we're going to use `callfunc` as a function pointer\\n            // `functionTable` is a pointer to a table in memory, containing function pointers\\n            // Step 1: reserve memory for functionTable\\n            uint256 functionTable;\\n            assembly {\\n                functionTable := mload(0x40)\\n                mstore(0x40, add(functionTable, 0x100)) // reserve 256 bytes for function pointers\\n            }\\n            {\\n                // Step 2: copy function pointers into local variables so that inline asm code can access them\\n                function(uint256, uint256) pure returns (uint256) t0 = paddingTx;\\n                function(uint256, uint256) pure returns (uint256) t1 = depositOrWithdrawTx;\\n                function(uint256, uint256) pure returns (uint256) t3 = sendTx;\\n                function(uint256, uint256) pure returns (uint256) t4 = accountTx;\\n                function(uint256, uint256) pure returns (uint256) t5 = defiDepositOrClaimTx;\\n                function(uint256, uint256) pure returns (uint256) t7 = invalidTx;\\n\\n                // Step 3: write function pointers into the table!\\n                assembly {\\n                    mstore(functionTable, t0)\\n                    mstore(add(functionTable, 0x20), t1)\\n                    mstore(add(functionTable, 0x40), t1)\\n                    mstore(add(functionTable, 0x60), t3)\\n                    mstore(add(functionTable, 0x80), t4)\\n                    mstore(add(functionTable, 0xa0), t5)\\n                    mstore(add(functionTable, 0xc0), t5)\\n                    mstore(add(functionTable, 0xe0), t7) // a proofId of 7 is not a valid transaction type, set to invalidTx\\n                }\\n            }\\n            uint256 decodedTransactionDataSize;\\n            assembly {\\n                // Add encoded proof data size to dataSize, minus the 4 bytes of encodedInnerProofData.length.\\n                // Set inPtr to point to the length parameter of `bytes calldata proofData`\\n                inPtr := add(calldataload(0x04), 0x4) // `proofData = first input parameter. Calldata offset to proofData will be at 0x04. Add 0x04 to account for function signature.\\n                \\n                // set dataSize to be the length of `bytes calldata proofData`\\n                // dataSize := sub(calldataload(inPtr), 0x4)\\n\\n                // Advance inPtr to point to the start of proofData\\n                inPtr := add(inPtr, 0x20)\\n\\n                numTxs := and(\\n                    calldataload(add(inPtr, NUM_REAL_TRANSACTIONS_OFFSET)),\\n                    0xffffffff\\n                )\\n                // Get encoded inner proof data size.\\n                // add ENCODED_PROOF_DATA_LENGTH_OFFSET to inPtr to point to the correct variable in our header block,\\n                // mask off all but 4 least significant bytes as this is a packed 32-bit variable.\\n                let encodedInnerDataSize := and(\\n                    calldataload(add(inPtr, ENCODED_PROOF_DATA_LENGTH_OFFSET)),\\n                    0xffffffff\\n                )\\n                // Add the size of trimmed zero bytes to dataSize.\\n\\n                // load up the rollup size from `proofData`\\n                rollupSize := calldataload(add(inPtr, 0x20))\\n\\n                // compute the number of bytes our decoded proof data will take up.\\n                // i.e. num total txns in the rollup (including padding) * number of public inputs per transaction\\n                let decodedInnerDataSize := mul(rollupSize, TX_PUBLIC_INPUT_LENGTH)\\n\\n                // we want dataSize to equal: rollup header length + decoded tx length (excluding padding blocks)\\n                let numInnerRollups := calldataload(add(inPtr, sub(ROLLUP_HEADER_LENGTH, 0x20)))\\n                let numTxsPerRollup := div(rollupSize, numInnerRollups)\\n\\n                let numFilledBlocks := div(numTxs, numTxsPerRollup)\\n                numFilledBlocks := add(numFilledBlocks, iszero(eq(mul(numFilledBlocks, numTxsPerRollup), numTxs)))\\n\\n                decodedTransactionDataSize := mul(mul(numFilledBlocks, numTxsPerRollup), TX_PUBLIC_INPUT_LENGTH)\\n                // i.e. current dataSize value + (difference between decoded and encoded data)\\n                dataSize := add(ROLLUP_HEADER_LENGTH, decodedTransactionDataSize)\\n\\n                // Allocate memory for `proofData`.\\n                proofData := mload(0x40)\\n                // set free mem ptr to dataSize + 0x20 (to account for the 0x20 bytes for the length param of proofData)\\n                // This allocates memory whose size is equal to the rollup header size, plus the data required for\\n                // each transaction's decoded tx data (256 bytes * number of non-padding blocks)\\n                // only reserve memory for blocks that contain non-padding proofs. These \\\"padding\\\" blocks don't need to be\\n                // stored in memory as we don't need their data for any computations\\n                mstore(0x40, add(proofData, add(dataSize, 0x20)))\\n\\n                // set outPtr to point to the proofData length parameter\\n                outPtr := proofData\\n                // write dataSize into proofData.length\\n                mstore(outPtr, dataSize)\\n                // advance outPtr to point to start of proofData\\n                outPtr := add(outPtr, 0x20)\\n\\n                // Copy rollup header data to `proofData`.\\n                calldatacopy(outPtr, inPtr, ROLLUP_HEADER_LENGTH)\\n                // Advance outPtr to point to the end of the header data (i.e. the start of the decoded inner transaction data)\\n                outPtr := add(outPtr, ROLLUP_HEADER_LENGTH)\\n\\n                // Advance inPtr to point to the start of our encoded inner transaction data.\\n                // Add (ROLLUP_HEADER_LENGTH + 0x08) to skip over the packed (numRealTransactions, encodedProofData.length) parameters\\n                inPtr := add(inPtr, add(ROLLUP_HEADER_LENGTH, 0x08))\\n\\n                // Set tailInPtr to point to the end of our encoded transaction data\\n                tailInPtr := add(inPtr, encodedInnerDataSize)\\n                // Set decodedTxDataStart pointer\\n                decodedTxDataStart := outPtr\\n            }\\n            /**\\n             * Start of decoding algorithm\\n             *\\n             * Iterate over every encoded transaction, load out the first byte (`proofId`) and use it to\\n             * jump to the relevant transaction's decoding function\\n             */\\n            assembly {\\n                // subtract 31 bytes off of inPtr, so that the first byte of the encoded transaction data\\n                // is located at the least significant byte of calldataload(inPtr)\\n                // also adjust tailInPtr as we compare inPtr against tailInPtr\\n                inPtr := sub(inPtr, 0x1f)\\n                tailInPtr := sub(tailInPtr, 0x1f)\\n            }\\n            unchecked {\\n                for (; tailInPtr > inPtr; ) {\\n                    assembly {\\n                        // For each tx, the encoding byte determines how we decode the tx calldata\\n                        // The encoding byte can take values from 0 to 7; we want to turn these into offsets that can index our function table.\\n                        // 1. Access encoding byte via `calldataload(inPtr)`. The least significant byte is our encoding byte. Mask off all but the 3 least sig bits\\n                        // 2. Shift left by 5 bits. This is equivalent to multiplying the encoding byte by 32.\\n                        // 4. The result will be 1 of 8 offset values (0x00, 0x20, ..., 0xe0) which we can use to retrieve the relevant function pointer from `functionTable`\\n                        let encoding := and(calldataload(inPtr), 7)\\n                        // store proofId at outPtr.\\n                        mstore(outPtr, encoding) // proofId\\n\\n                        // use proofId to extract the relevant function pointer from functionTable\\n                        callfunc := mload(add(functionTable, shl(5, encoding)))\\n                    }\\n                    // call the decoding function. Return value will be next required value of inPtr\\n                    inPtr = callfunc(inPtr, outPtr);\\n                    // advance outPtr by the size of a decoded transaction\\n                    outPtr += TX_PUBLIC_INPUT_LENGTH;\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Compute the public inputs hash\\n         *\\n         * We need to take our decoded proof data and compute its SHA256 hash.\\n         * This hash is fed into our rollup proof as a public input.\\n         * If the hash does not match the SHA256 hash computed within the rollup circuit\\n         * on the equivalent parameters, the proof will reject.\\n         * This check ensures that the transaction data present in calldata are equal to\\n         * the transaction data values present in the rollup ZK-SNARK circuit.\\n         *\\n         * One complication is the structure of the SHA256 hash.\\n         * We slice transactions into chunks equal to the number of transactions in the \\\"inner rollup\\\" circuit\\n         * (a rollup circuit verifies multiple \\\"inner rollup\\\" circuits, which each verify 3-28 private user transactions.\\n         *  This tree structure helps parallelise proof construction)\\n         * We then SHA256 hash each transaction *chunk*\\n         * Finally we SHA256 hash the above SHA256 hashes to get our public input hash!\\n         *\\n         * We do the above instead of a straight hash of all of the transaction data,\\n         * because it's faster to parallelise proof construction if the majority of the SHA256 hashes are computed in\\n         * the \\\"inner rollup\\\" circuit and not the main rollup circuit.\\n         */\\n        // Step 1: compute the hashes that constitute the inner proofs data\\n        bool invalidRollupTopology;\\n        assembly {\\n            // we need to figure out how many rollup proofs are in this tx and how many user transactions are in each rollup\\n            let numRollupTxs := mload(add(proofData, ROLLUP_HEADER_LENGTH))\\n            let numJoinSplitsPerRollup := div(rollupSize, numRollupTxs)\\n            let rollupDataSize := mul(mul(numJoinSplitsPerRollup, NUMBER_OF_PUBLIC_INPUTS_PER_TX), 32)\\n\\n            // Compute the number of inner rollups that don't contain padding proofs\\n            let numNotEmptyInnerRollups := div(numTxs, numJoinSplitsPerRollup)\\n            numNotEmptyInnerRollups := add(\\n                numNotEmptyInnerRollups,\\n                iszero(eq(mul(numNotEmptyInnerRollups, numJoinSplitsPerRollup), numTxs))\\n            )\\n            // Compute the number of inner rollups that only contain padding proofs!\\n            // For these \\\"empty\\\" inner rollups, we don't need to compute their public inputs hash directly,\\n            // we can use a precomputed value\\n            let numEmptyInnerRollups := sub(numRollupTxs, numNotEmptyInnerRollups)\\n\\n            let proofdataHashPtr := mload(0x40)\\n            // copy the header data into the proofdataHash\\n            // header start is at calldataload(0x04) + 0x24 (+0x04 to skip over func signature, +0x20 to skip over byte array length param)\\n            calldatacopy(proofdataHashPtr, add(calldataload(0x04), 0x24), ROLLUP_HEADER_LENGTH)\\n\\n            // update pointer\\n            proofdataHashPtr := add(proofdataHashPtr, ROLLUP_HEADER_LENGTH)\\n\\n            // compute the endpoint for the proofdataHashPtr (used as a loop boundary condition)\\n            let endPtr := add(proofdataHashPtr, mul(numNotEmptyInnerRollups, 0x20))\\n            // iterate over the public inputs for each inner rollup proof and compute their SHA256 hash\\n\\n            // better solution here is ... iterate over number of non-padding rollup blocks\\n            // and hash those\\n            // for padding rollup blocks...just append the zero hash\\n            for {\\n\\n            } lt(proofdataHashPtr, endPtr) {\\n                proofdataHashPtr := add(proofdataHashPtr, 0x20)\\n            } {\\n                // address(0x02) is the SHA256 precompile address\\n                if iszero(staticcall(gas(), 0x02, decodedTxDataStart, rollupDataSize, 0x00, 0x20)) {\\n                    revert(0x00, 0x00)\\n                }\\n\\n                mstore(proofdataHashPtr, mod(mload(0x00), CIRCUIT_MODULUS))\\n                decodedTxDataStart := add(decodedTxDataStart, rollupDataSize)\\n            }\\n\\n            // If there are empty inner rollups, we can use a precomputed hash\\n            // of their public inputs instead of computing it directly.\\n            if iszero(iszero(numEmptyInnerRollups))\\n            {\\n                let zeroHash\\n                switch numJoinSplitsPerRollup\\n                case 32 {\\n                    zeroHash := PADDING_ROLLUP_HASH_SIZE_32\\n                }\\n                case 16 {\\n                    zeroHash := PADDING_ROLLUP_HASH_SIZE_16\\n                }\\n                case 64 {\\n                    zeroHash := PADDING_ROLLUP_HASH_SIZE_64\\n                }\\n                case 1 {\\n                    zeroHash := PADDING_ROLLUP_HASH_SIZE_1\\n                }\\n                case 2 {\\n                    zeroHash := PADDING_ROLLUP_HASH_SIZE_2\\n                }\\n                case 4 {\\n                    zeroHash := PADDING_ROLLUP_HASH_SIZE_4\\n                }\\n                case 8 {\\n                    zeroHash := PADDING_ROLLUP_HASH_SIZE_8\\n                }\\n                default {\\n                    invalidRollupTopology := true\\n                }\\n    \\n                endPtr := add(endPtr, mul(numEmptyInnerRollups, 0x20))\\n                for {\\n\\n                } lt (proofdataHashPtr, endPtr) {\\n                    proofdataHashPtr := add(proofdataHashPtr, 0x20)\\n                } {\\n                    mstore(proofdataHashPtr, zeroHash)\\n                }\\n            }\\n            // compute SHA256 hash of header data + inner public input hashes\\n            let startPtr := mload(0x40)\\n            if iszero(staticcall(gas(), 0x02, startPtr, sub(proofdataHashPtr, startPtr), 0x00, 0x20)) {\\n                revert(0x00, 0x00)\\n            }\\n            publicInputsHash := mod(mload(0x00), CIRCUIT_MODULUS)\\n        }\\n        if (invalidRollupTopology)\\n        {\\n            revert INVALID_ROLLUP_TOPOLOGY();\\n        }\\n    }\\n\\n    /**\\n     * @dev Extract the `rollupId` param from the decoded proof data.\\n     * represents the rollupId of the next valid rollup block\\n     * @param proofData the decoded proof data\\n     * @return nextRollupId the expected id of the next rollup block\\n     */\\n    function getRollupId(bytes memory proofData) internal pure returns (uint256 nextRollupId) {\\n        assembly {\\n            nextRollupId := mload(add(proofData, 0x20))\\n        }\\n    }\\n\\n    /**\\n     * @dev Decode the public inputs component of proofData and compute sha3 hash of merkle roots && dataStartIndex\\n     *      The rollup's state is uniquely defined by the following variables:\\n     *          * The next empty location in the data root tree (rollupId + 1)\\n     *          * The next empty location in the data tree (dataStartIndex + rollupSize)\\n     *          * The root of the data tree\\n     *          * The root of the nullifier set\\n     *          * The root of the data root tree (tree containing all previous roots of the data tree)\\n     *          * The root of the defi tree\\n     *      Instead of storing all of these variables in storage (expensive!), we store a keccak256 hash of them.\\n     *      To validate the correctness of a block's state transition, we must perform the following:\\n     *          * Use proof broadcasted inputs to reconstruct the \\\"old\\\" state hash\\n     *          * Use proof broadcasted inputs to reconstruct the \\\"new\\\" state hash\\n     *          * Validate the old state hash matches what is in storage\\n     *          * Set the old state hash to the new state hash\\n     *      N.B. we still store dataSize as a separate storage var as proofData does not contain all\\n     *           neccessary information to reconstruct its old value.\\n     * @param proofData - cryptographic proofData associated with a rollup\\n     */\\n    function computeRootHashes(bytes memory proofData)\\n        internal\\n        pure\\n        returns (\\n            uint256 rollupId,\\n            bytes32 oldStateHash,\\n            bytes32 newStateHash,\\n            uint32 numDataLeaves,\\n            uint32 dataStartIndex\\n        )\\n    {\\n        assembly {\\n            let dataStart := add(proofData, 0x20) // jump over first word, it's length of data\\n            numDataLeaves := shl(1, mload(add(dataStart, 0x20))) // rollupSize * 2 (2 notes per tx)\\n            dataStartIndex := mload(add(dataStart, 0x40))\\n\\n            // validate numDataLeaves && dataStartIndex are uint32s\\n            if or(gt(numDataLeaves, 0xffffffff), gt(dataStartIndex, 0xffffffff))\\n            {\\n                revert(0,0)\\n            }\\n            rollupId := mload(dataStart)\\n\\n            let mPtr := mload(0x40)\\n\\n            mstore(mPtr, rollupId) // old nextRollupId\\n            mstore(add(mPtr, 0x20), mload(add(dataStart, 0x60))) // oldDataRoot\\n            mstore(add(mPtr, 0x40), mload(add(dataStart, 0xa0))) // oldNullRoot\\n            mstore(add(mPtr, 0x60), mload(add(dataStart, 0xe0))) // oldRootRoot\\n            mstore(add(mPtr, 0x80), mload(add(dataStart, 0x120))) // oldDefiRoot\\n            oldStateHash := keccak256(mPtr, 0xa0)\\n\\n            mstore(mPtr, add(rollupId, 0x01)) // new nextRollupId\\n            mstore(add(mPtr, 0x20), mload(add(dataStart, 0x80))) // newDataRoot\\n            mstore(add(mPtr, 0x40), mload(add(dataStart, 0xc0))) // newNullRoot\\n            mstore(add(mPtr, 0x60), mload(add(dataStart, 0x100))) // newRootRoot\\n            mstore(add(mPtr, 0x80), mload(add(dataStart, 0x140))) // newDefiRoot\\n            newStateHash := keccak256(mPtr, 0xa0)\\n        }\\n    }\\n\\n    /**\\n     * @dev extract the `prevDefiInterationHash` from the proofData's rollup header\\n     * @param proofData byte array of our input proof data\\n     * @return prevDefiInteractionHash the defiInteractionHash of the previous rollup block\\n     */\\n    function extractPrevDefiInteractionHash(bytes memory proofData)\\n        internal\\n        pure\\n        returns (bytes32 prevDefiInteractionHash)\\n    {\\n        assembly {\\n            prevDefiInteractionHash := mload(add(proofData, PREVIOUS_DEFI_INTERACTION_HASH_OFFSET))\\n        }\\n    }\\n\\n    /**\\n     * @dev extract the address we pay the rollup fee to, from the proofData's rollup header\\n     * This \\\"rollup beneficiary\\\" address is included as part of the ZK-SNARK circuit data, so that\\n     * the rollup provider can explicitly define who should get the fee at the point they generate the ZK-SNARK proof.\\n     * (instead of simply sending the fee to msg.sender)\\n     * This prevents front-running attacks where an attacker can take somebody else's rollup proof from out of the tx pool and replay it, stealing the fee.\\n     * @param proofData byte array of our input proof data\\n     * @return rollupBeneficiaryAddress the address we pay this rollup block's fee to\\n     */\\n    function extractRollupBeneficiaryAddress(bytes memory proofData)\\n        internal\\n        pure\\n        returns (address rollupBeneficiaryAddress)\\n    {\\n        assembly {\\n            rollupBeneficiaryAddress := mload(add(proofData, ROLLUP_BENEFICIARY_OFFSET))\\n            // validate rollupBeneficiaryAddress is an address!\\n            if gt(rollupBeneficiaryAddress, ADDRESS_MASK) {\\n                revert(0, 0)\\n            }\\n\\n        }\\n    }\\n\\n    /**\\n     * @dev Extract an assetId from the rollup block.\\n     * The rollup block contains up to 16 different assets, which can be recovered from the rollup header data.\\n     * @param proofData byte array of our input proof data\\n     * @param idx The index of the asset we want. assetId = header.assetIds[idx]\\n     * @return assetId the 30-bit identifier of an asset. The ERC20 token address is obtained via the mapping `supportedAssets[assetId]`, \\n     */\\n    function extractAssetId(\\n        bytes memory proofData,\\n        uint256 idx\\n    ) internal pure returns (uint256 assetId) {\\n        assembly {\\n            assetId := mload(add(add(add(proofData, BRIDGE_IDS_OFFSET), mul(0x40, NUMBER_OF_BRIDGE_CALLS)), mul(0x20, idx)))\\n            // validate assetId is a uint32!\\n            if gt(assetId, 0xffffffff) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Extract the transaction fee, for a given asset, due to be paid to the rollup beneficiary\\n     * The total fee is the sum of the individual fees paid by each transaction in the rollup block.\\n     * This sum is computed directly in the rollup circuit, and is present in the rollup header data\\n     * @param proofData byte array of our input proof data\\n     * @param idx The index of the asset the fee is denominated in\\n     * @return totalTxFee \\n     */\\n    function extractTotalTxFee(\\n        bytes memory proofData,\\n        uint256 idx\\n    ) internal pure returns (uint256 totalTxFee) {\\n        assembly {\\n            totalTxFee := mload(add(add(add(proofData, 0x380), mul(0x40, NUMBER_OF_BRIDGE_CALLS)), mul(0x20, idx)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TokenTransfers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\n/**\\n * @title TokenTransfers\\n * @dev Provides functions to safely call `transfer` and `transferFrom` methods on ERC20 tokens,\\n * as well as the ability to call `transfer` and `transferFrom` without bubbling up errors\\n */\\nlibrary TokenTransfers {\\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb; // bytes4(keccak256('transfer(address,uint256)'));\\n    bytes4 private constant TRANSFER_FROM_SELECTOR = 0x23b872dd; // bytes4(keccak256('transferFrom(address,address,uint256)'));\\n\\n    /**\\n     * @dev Safely call ERC20.transfer, handles tokens that do not throw on transfer failure or do not return transfer result\\n     * @param tokenAddress Where does the token live?\\n     * @param to Who are we sending tokens to?\\n     * @param amount How many tokens are we transferring?\\n     */\\n    function safeTransferTo(\\n        address tokenAddress,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        // The ERC20 token standard states that:\\n        // 1. failed transfers must throw\\n        // 2. the result of the transfer (success/fail) is returned as a boolean\\n        // Some token contracts don't implement the spec correctly and will do one of the following:\\n        // 1. Contract does not throw if transfer fails, instead returns false\\n        // 2. Contract throws if transfer fails, but does not return any boolean value\\n        // We can check for these by evaluating the following:\\n        // | call succeeds? (c) | return value (v) | returndatasize == 0 (r)| interpreted result |\\n        // | ---                | ---              | ---                    | ---                |\\n        // | false              | false            | false                  | transfer fails     |\\n        // | false              | false            | true                   | transfer fails     |\\n        // | false              | true             | false                  | transfer fails     |\\n        // | false              | true             | true                   | transfer fails     |\\n        // | true               | false            | false                  | transfer fails     |\\n        // | true               | false            | true                   | transfer succeeds  |\\n        // | true               | true             | false                  | transfer succeeds  |\\n        // | true               | true             | true                   | transfer succeeds  |\\n        //\\n        // i.e. failure state = !(c && (r || v))\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, TRANSFER_SELECTOR)\\n            mstore(add(ptr, 0x4), to)\\n            mstore(add(ptr, 0x24), amount)\\n            let call_success := call(gas(), tokenAddress, 0, ptr, 0x44, 0x00, 0x20)\\n            let result_success := or(iszero(returndatasize()), and(mload(0), 1))\\n            if iszero(and(call_success, result_success)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Safely call ERC20.transferFrom, handles tokens that do not throw on transfer failure or do not return transfer result\\n     * @param tokenAddress Where does the token live?\\n     * @param source Who are we transferring tokens from\\n     * @param target Who are we transferring tokens to?\\n     * @param amount How many tokens are being transferred?\\n     */\\n    function safeTransferFrom(\\n        address tokenAddress,\\n        address source,\\n        address target,\\n        uint256 amount\\n    ) internal {\\n        assembly {\\n            // call tokenAddress.transferFrom(source, target, value)\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, TRANSFER_FROM_SELECTOR)\\n            mstore(add(mPtr, 0x04), source)\\n            mstore(add(mPtr, 0x24), target)\\n            mstore(add(mPtr, 0x44), amount)\\n            let call_success := call(gas(), tokenAddress, 0, mPtr, 0x64, 0x00, 0x20)\\n            let result_success := or(iszero(returndatasize()), and(mload(0), 1))\\n            if iszero(and(call_success, result_success)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Calls ERC(tokenAddress).transfer(to, amount). Errors are ignored! Use with caution!\\n     * @param tokenAddress Where does the token live?\\n     * @param to Who are we sending to?\\n     * @param amount How many tokens are being transferred?\\n     * @param gasToSend Amount of gas to send the contract. If value is 0, function uses gas() instead\\n     */\\n    function transferToDoNotBubbleErrors(\\n        address tokenAddress,\\n        address to,\\n        uint256 amount,\\n        uint256 gasToSend\\n    ) internal {\\n        assembly {\\n            let callGas := gas()\\n            if gasToSend {\\n                callGas := gasToSend\\n            }\\n            let ptr := mload(0x40)\\n            mstore(ptr, TRANSFER_SELECTOR)\\n            mstore(add(ptr, 0x4), to)\\n            mstore(add(ptr, 0x24), amount)\\n            pop(call(callGas, tokenAddress, 0, ptr, 0x44, 0x00, 0x00))\\n        }\\n    }\\n\\n    /**\\n     * @dev Calls ERC(tokenAddress).transferFrom(source, target, amount). Errors are ignored! Use with caution!\\n     * @param tokenAddress Where does the token live?\\n     * @param source Who are we transferring tokens from\\n     * @param target Who are we transferring tokens to?\\n     * @param amount How many tokens are being transferred?\\n     * @param gasToSend Amount of gas to send the contract. If value is 0, function uses gas() instead\\n     */\\n    function transferFromDoNotBubbleErrors(\\n        address tokenAddress,\\n        address source,\\n        address target,\\n        uint256 amount,\\n        uint256 gasToSend\\n    ) internal {\\n        assembly {\\n            let callGas := gas()\\n            if gasToSend {\\n                callGas := gasToSend\\n            }\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, TRANSFER_FROM_SELECTOR)\\n            mstore(add(mPtr, 0x04), source)\\n            mstore(add(mPtr, 0x24), target)\\n            mstore(add(mPtr, 0x44), amount)\\n            pop(call(callGas, tokenAddress, 0, mPtr, 0x64, 0x00, 0x00))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/RollupProcessorLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nlibrary RollupProcessorLibrary {\\n    error SIGNATURE_ADDRESS_IS_ZERO();\\n    error SIGNATURE_RECOVERY_FAILED();\\n    error INVALID_SIGNATURE();\\n\\n    /**\\n     * Extracts the address of the signer with ECDSA. Performs checks on `s` and `v` to\\n     * to prevent signature malleability based attacks\\n     * @param digest - Hashed data being signed over.\\n     * @param signature - ECDSA signature over the secp256k1 elliptic curve.\\n     * @param signer - Address that signs the signature.\\n     */\\n    function validateSignature(\\n        bytes32 digest,\\n        bytes memory signature,\\n        address signer\\n    ) internal view {\\n        bool result;\\n        address recoveredSigner = address(0x0);\\n        if (signer == address(0x0)) {\\n            revert SIGNATURE_ADDRESS_IS_ZERO();\\n        }\\n\\n        // prepend \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\" to the digest to create the signed message\\n        bytes32 message;\\n        assembly {\\n            mstore(0, '\\\\x19Ethereum Signed Message:\\\\n32')\\n            mstore(add(0, 28), digest)\\n            message := keccak256(0, 60)\\n        }\\n        assembly {\\n            let mPtr := mload(0x40)\\n            let byteLength := mload(signature)\\n\\n            // store the signature digest\\n            mstore(mPtr, message)\\n\\n            // load 'v' - we need it for a condition check\\n            // add 0x60 to jump over 3 words - length of bytes array, r and s\\n            let v := shr(248, mload(add(signature, 0x60))) // bitshifting, to resemble padLeft\\n            let s := mload(add(signature, 0x40))\\n\\n            /**\\n             * Original memory map for input to precompile\\n             *\\n             * signature : signature + 0x20            message\\n             * signature + 0x20 : signature + 0x40     r\\n             * signature + 0x40 : signature + 0x60     s\\n             * signature + 0x60 : signature + 0x80     v\\n             * Desired memory map for input to precompile\\n             *\\n             * signature : signature + 0x20            message\\n             * signature + 0x20 : signature + 0x40     v\\n             * signature + 0x40 : signature + 0x60     r\\n             * signature + 0x60 : signature + 0x80     s\\n             */\\n\\n            // store s\\n            mstore(add(mPtr, 0x60), s)\\n            // store r\\n            mstore(add(mPtr, 0x40), mload(add(signature, 0x20)))\\n            // store v\\n            mstore(add(mPtr, 0x20), v)\\n            result := and(\\n                and(\\n                    // validate s is in lower half order\\n                    lt(s, 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A1),\\n                    and(\\n                        // validate signature length == 0x41\\n                        eq(byteLength, 0x41),\\n                        // validate v == 27 or v == 28\\n                        or(eq(v, 27), eq(v, 28))\\n                    )\\n                ),\\n                // validate call to ecrecover precompile succeeds\\n                staticcall(gas(), 0x01, mPtr, 0x80, mPtr, 0x20)\\n            )\\n\\n            // save the recoveredSigner only if the first word in signature is not `message` anymore\\n            switch eq(message, mload(mPtr))\\n            case 0 {\\n                recoveredSigner := mload(mPtr)\\n            }\\n            mstore(mPtr, byteLength) // and put the byte length back where it belongs\\n\\n            // validate that recoveredSigner is not address(0x00)\\n            result := and(result, not(iszero(recoveredSigner)))\\n        }\\n        if (!result) {\\n            revert SIGNATURE_RECOVERY_FAILED();\\n        }\\n        if (recoveredSigner != signer) {\\n            revert INVALID_SIGNATURE();\\n        }\\n    }\\n\\n    /**\\n     * Extracts the address of the signer with ECDSA. Performs checks on `s` and `v` to\\n     * to prevent signature malleability based attacks\\n     * This 'Unpacked' version expects 'signature' to be a 92-byte array.\\n     * i.e. the `v` parameter occupies a full 32 bytes of memory, not 1 byte\\n     * @param hashedMessage - Hashed data being signed over. This function only works if the message has been pre formated to EIP https://eips.ethereum.org/EIPS/eip-191\\n     * @param signature - ECDSA signature over the secp256k1 elliptic curve.\\n     * @param signer - Address that signs the signature.\\n     */\\n    function validateSheildSignatureUnpacked(\\n        bytes32 hashedMessage,\\n        bytes memory signature,\\n        address signer\\n    ) internal view {\\n        bool result;\\n        address recoveredSigner = address(0x0);\\n        if (signer == address(0x0)) {\\n            revert SIGNATURE_ADDRESS_IS_ZERO();\\n        }\\n        assembly {\\n            let mPtr := mload(0x40)\\n            // There's a little trick we can pull. We expect `signature` to be a byte array, of length 0x60, with\\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `signature`.\\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\\n            // load length as a temporary variable\\n            // N.B. we mutate the signature by re-ordering r, s, and v!\\n            let byteLength := mload(signature)\\n\\n            // store the signature digest\\n            mstore(signature, hashedMessage)\\n\\n            // load 'v' - we need it for a condition check\\n            // add 0x60 to jump over 3 words - length of bytes array, r and s\\n            let v := mload(add(signature, 0x60))\\n            let s := mload(add(signature, 0x40))\\n\\n            /**\\n             * Original memory map for input to precompile\\n             *\\n             * signature : signature + 0x20            message\\n             * signature + 0x20 : signature + 0x40     r\\n             * signature + 0x40 : signature + 0x60     s\\n             * signature + 0x60 : signature + 0x80     v\\n             * Desired memory map for input to precompile\\n             *\\n             * signature : signature + 0x20            message\\n             * signature + 0x20 : signature + 0x40     v\\n             * signature + 0x40 : signature + 0x60     r\\n             * signature + 0x60 : signature + 0x80     s\\n             */\\n\\n            // move s to v position\\n            mstore(add(signature, 0x60), s)\\n            // move r to s position\\n            mstore(add(signature, 0x40), mload(add(signature, 0x20)))\\n            // move v to r position\\n            mstore(add(signature, 0x20), v)\\n            result := and(\\n                and(\\n                    // validate s is in lower half order\\n                    lt(s, 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A1),\\n                    and(\\n                        // validate signature length == 0x60 (unpacked)\\n                        eq(byteLength, 0x60),\\n                        // validate v == 27 or v == 28\\n                        or(eq(v, 27), eq(v, 28))\\n                    )\\n                ),\\n                // validate call to ecrecover precompile succeeds\\n                staticcall(gas(), 0x01, signature, 0x80, signature, 0x20)\\n            )\\n\\n            // save the recoveredSigner only if the first word in signature is not `message` anymore\\n            switch eq(hashedMessage, mload(signature))\\n            case 0 {\\n                recoveredSigner := mload(signature)\\n            }\\n            mstore(signature, byteLength) // and put the byte length back where it belongs\\n\\n            // validate that recoveredSigner is not address(0x00)\\n            result := and(result, not(iszero(recoveredSigner)))\\n        }\\n        if (!result) {\\n            revert SIGNATURE_RECOVERY_FAILED();\\n        }\\n        if (recoveredSigner != signer) {\\n            revert INVALID_SIGNATURE();\\n        }\\n    }\\n\\n    /**\\n     * Extracts the address of the signer with ECDSA. Performs checks on `s` and `v` to\\n     * to prevent signature malleability based attacks\\n     * This 'Unpacked' version expects 'signature' to be a 92-byte array.\\n     * i.e. the `v` parameter occupies a full 32 bytes of memory, not 1 byte\\n     * @param digest - Hashed data being signed over.\\n     * @param signature - ECDSA signature over the secp256k1 elliptic curve.\\n     * @param signer - Address that signs the signature.\\n     */\\n    function validateUnpackedSignature(\\n        bytes32 digest,\\n        bytes memory signature,\\n        address signer\\n    ) internal view {\\n        bool result;\\n        address recoveredSigner = address(0x0);\\n        if (signer == address(0x0)) {\\n            revert SIGNATURE_ADDRESS_IS_ZERO();\\n        }\\n\\n        // prepend \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\" to the digest to create the signed message\\n        bytes32 message;\\n        assembly {\\n            mstore(0, '\\\\x19Ethereum Signed Message:\\\\n32')\\n            mstore(28, digest)\\n            message := keccak256(0, 60)\\n        }\\n        assembly {\\n            // There's a little trick we can pull. We expect `signature` to be a byte array, of length 0x60, with\\n            // 'v', 'r' and 's' located linearly in memory. Preceeding this is the length parameter of `signature`.\\n            // We *replace* the length param with the signature msg to get a memory block formatted for the precompile\\n            // load length as a temporary variable\\n            // N.B. we mutate the signature by re-ordering r, s, and v!\\n            let byteLength := mload(signature)\\n\\n            // store the signature digest\\n            mstore(signature, message)\\n\\n            // load 'v' - we need it for a condition check\\n            // add 0x60 to jump over 3 words - length of bytes array, r and s\\n            let v := mload(add(signature, 0x60))\\n            let s := mload(add(signature, 0x40))\\n\\n            /**\\n             * Original memory map for input to precompile\\n             *\\n             * signature : signature + 0x20            message\\n             * signature + 0x20 : signature + 0x40     r\\n             * signature + 0x40 : signature + 0x60     s\\n             * signature + 0x60 : signature + 0x80     v\\n             * Desired memory map for input to precompile\\n             *\\n             * signature : signature + 0x20            message\\n             * signature + 0x20 : signature + 0x40     v\\n             * signature + 0x40 : signature + 0x60     r\\n             * signature + 0x60 : signature + 0x80     s\\n             */\\n\\n            // move s to v position\\n            mstore(add(signature, 0x60), s)\\n            // move r to s position\\n            mstore(add(signature, 0x40), mload(add(signature, 0x20)))\\n            // move v to r position\\n            mstore(add(signature, 0x20), v)\\n            result := and(\\n                and(\\n                    // validate s is in lower half order\\n                    lt(s, 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A1),\\n                    and(\\n                        // validate signature length == 0x60 (unpacked)\\n                        eq(byteLength, 0x60),\\n                        // validate v == 27 or v == 28\\n                        or(eq(v, 27), eq(v, 28))\\n                    )\\n                ),\\n                // validate call to ecrecover precompile succeeds\\n                staticcall(gas(), 0x01, signature, 0x80, signature, 0x20)\\n            )\\n\\n            // save the recoveredSigner only if the first word in signature is not `message` anymore\\n            switch eq(message, mload(signature))\\n            case 0 {\\n                recoveredSigner := mload(signature)\\n            }\\n            mstore(signature, byteLength) // and put the byte length back where it belongs\\n\\n            // validate that recoveredSigner is not address(0x00)\\n            result := and(result, not(iszero(recoveredSigner)))\\n        }\\n        if (!result) {\\n            revert SIGNATURE_RECOVERY_FAILED();\\n        }\\n        if (recoveredSigner != signer) {\\n            revert INVALID_SIGNATURE();\\n        }\\n    }\\n\\n    /**\\n     * Convert a bytes32 into an ASCII encoded hex string\\n     * @param input bytes32 variable\\n     * @return result hex-encoded string\\n     */\\n    function toHexString(bytes32 input) public pure returns (string memory result) {\\n        if (uint256(input) == 0x00) {\\n            assembly {\\n                result := mload(0x40)\\n                mstore(result, 0x40)\\n                mstore(add(result, 0x20), 0x3030303030303030303030303030303030303030303030303030303030303030)\\n                mstore(add(result, 0x40), 0x3030303030303030303030303030303030303030303030303030303030303030)\\n                mstore(0x40, add(result, 0x60))\\n            }\\n            return result;\\n        }\\n        assembly {\\n            result := mload(0x40)\\n            let table := add(result, 0x60)\\n\\n            // Store lookup table that maps an integer from 0 to 99 into a 2-byte ASCII equivalent\\n            // Store lookup table that maps an integer from 0 to ff into a 2-byte ASCII equivalent\\n            mstore(add(table, 0x1e), 0x3030303130323033303430353036303730383039306130623063306430653066)\\n            mstore(add(table, 0x3e), 0x3130313131323133313431353136313731383139316131623163316431653166)\\n            mstore(add(table, 0x5e), 0x3230323132323233323432353236323732383239326132623263326432653266)\\n            mstore(add(table, 0x7e), 0x3330333133323333333433353336333733383339336133623363336433653366)\\n            mstore(add(table, 0x9e), 0x3430343134323433343434353436343734383439346134623463346434653466)\\n            mstore(add(table, 0xbe), 0x3530353135323533353435353536353735383539356135623563356435653566)\\n            mstore(add(table, 0xde), 0x3630363136323633363436353636363736383639366136623663366436653666)\\n            mstore(add(table, 0xfe), 0x3730373137323733373437353736373737383739376137623763376437653766)\\n            mstore(add(table, 0x11e), 0x3830383138323833383438353836383738383839386138623863386438653866)\\n            mstore(add(table, 0x13e), 0x3930393139323933393439353936393739383939396139623963396439653966)\\n            mstore(add(table, 0x15e), 0x6130613161326133613461356136613761386139616161626163616461656166)\\n            mstore(add(table, 0x17e), 0x6230623162326233623462356236623762386239626162626263626462656266)\\n            mstore(add(table, 0x19e), 0x6330633163326333633463356336633763386339636163626363636463656366)\\n            mstore(add(table, 0x1be), 0x6430643164326433643464356436643764386439646164626463646464656466)\\n            mstore(add(table, 0x1de), 0x6530653165326533653465356536653765386539656165626563656465656566)\\n            mstore(add(table, 0x1fe), 0x6630663166326633663466356636663766386639666166626663666466656666)\\n            /**\\n             * Convert `input` into ASCII.\\n             *\\n             * Slice 2 base-10  digits off of the input, use to index the ASCII lookup table.\\n             *\\n             * We start from the least significant digits, write results into mem backwards,\\n             * this prevents us from overwriting memory despite the fact that each mload\\n             * only contains 2 byteso f useful data.\\n             **/\\n\\n            let base := input\\n            function slice(v, tableptr) {\\n                mstore(0x1e, mload(add(tableptr, shl(1, and(v, 0xff)))))\\n                mstore(0x1c, mload(add(tableptr, shl(1, and(shr(8, v), 0xff)))))\\n                mstore(0x1a, mload(add(tableptr, shl(1, and(shr(16, v), 0xff)))))\\n                mstore(0x18, mload(add(tableptr, shl(1, and(shr(24, v), 0xff)))))\\n                mstore(0x16, mload(add(tableptr, shl(1, and(shr(32, v), 0xff)))))\\n                mstore(0x14, mload(add(tableptr, shl(1, and(shr(40, v), 0xff)))))\\n                mstore(0x12, mload(add(tableptr, shl(1, and(shr(48, v), 0xff)))))\\n                mstore(0x10, mload(add(tableptr, shl(1, and(shr(56, v), 0xff)))))\\n                mstore(0x0e, mload(add(tableptr, shl(1, and(shr(64, v), 0xff)))))\\n                mstore(0x0c, mload(add(tableptr, shl(1, and(shr(72, v), 0xff)))))\\n                mstore(0x0a, mload(add(tableptr, shl(1, and(shr(80, v), 0xff)))))\\n                mstore(0x08, mload(add(tableptr, shl(1, and(shr(88, v), 0xff)))))\\n                mstore(0x06, mload(add(tableptr, shl(1, and(shr(96, v), 0xff)))))\\n                mstore(0x04, mload(add(tableptr, shl(1, and(shr(104, v), 0xff)))))\\n                mstore(0x02, mload(add(tableptr, shl(1, and(shr(112, v), 0xff)))))\\n                mstore(0x00, mload(add(tableptr, shl(1, and(shr(120, v), 0xff)))))\\n            }\\n\\n            mstore(result, 0x40)\\n            slice(base, table)\\n            mstore(add(result, 0x40), mload(0x1e))\\n            base := shr(128, base)\\n            slice(base, table)\\n            mstore(add(result, 0x20), mload(0x1e))\\n            mstore(0x40, add(result, 0x60))\\n        }\\n    }\\n\\n    function getSignedMessageForTxId(bytes32 txId) internal pure returns (bytes32 hashedMessage) {\\n        // we know this string length is 64 bytes\\n        string memory txIdHexString = toHexString(txId);\\n\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(add(mPtr, 32), '\\\\x19Ethereum Signed Message:\\\\n210')\\n            mstore(add(mPtr, 61), 'Signing this message will allow ')\\n            mstore(add(mPtr, 93), 'your pending funds to be spent i')\\n            mstore(add(mPtr, 125), 'n Aztec transaction:\\\\n\\\\n0x')\\n            mstore(add(mPtr, 149), mload(add(txIdHexString, 0x20)))\\n            mstore(add(mPtr, 181), mload(add(txIdHexString, 0x40)))\\n            mstore(add(mPtr, 213), '\\\\n\\\\nIMPORTANT: Only sign the messa')\\n            mstore(add(mPtr, 245), 'ge if you trust the client')\\n            hashedMessage := keccak256(add(mPtr, 32), 239)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/TestRollupProcessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {RollupProcessor} from '../RollupProcessor.sol';\\n\\n/**\\n * @title Rollup processor contract\\n * @dev Warning: do not deploy in real environments, for testing only\\n * Adds some methods to fiddle around with storage vars\\n */\\ncontract TestRollupProcessor is RollupProcessor {\\n    constructor(uint256 _escapeBlockLowerBound, uint256 _escapeBlockUpperBound)\\n        RollupProcessor(_escapeBlockLowerBound, _escapeBlockUpperBound)\\n    {}\\n\\n    // Used to pre-fund the rollup with some Eth (to mimic deposited Eth for defi interactions)\\n    receive() external payable {}\\n\\n    // Used to test we correctly check the length of asyncDefiTransactionHashes\\n    function stubAsyncTransactionHashesLength(uint256 size) public {\\n        rollupState.numAsyncDefiInteractionHashes = uint16(size);\\n    }\\n\\n    // Used to test we correctly check length of defiTransactionhashes\\n    function stubTransactionHashesLength(uint256 size) public {\\n        rollupState.numDefiInteractionHashes = uint16(size);\\n        assembly {\\n            mstore(0x00, defiInteractionHashes.slot)\\n            // Write the 'zero-hash' into the last `numberOfBridgeCalls` entries to ensure that computed\\n            // defiInteractionHash will be correct\\n            let slot := keccak256(0x00, 0x20)\\n            for {\\n                let i := 0\\n            } lt(i, NUMBER_OF_BRIDGE_CALLS) {\\n                i := add(i, 1)\\n            } {\\n                sstore(\\n                    add(slot, sub(size, add(i, 1))),\\n                    0x2d25a1e3a51eb293004c4b56abe12ed0da6bca2b4a21936752a85d102593c1b4\\n                )\\n            }\\n        }\\n    }\\n}\\n\\ncontract UpgradedTestRollupProcessorV0 is TestRollupProcessor {\\n    constructor(uint256 _escapeBlockLowerBound, uint256 _escapeBlockUpperBound)\\n        TestRollupProcessor(_escapeBlockLowerBound, _escapeBlockUpperBound)\\n    {}\\n\\n    function getImplementationVersion() public pure override returns (uint8) {\\n        return 0;\\n    }\\n}\\n\\ncontract UpgradedTestRollupProcessorV2 is TestRollupProcessor {\\n    constructor(uint256 _escapeBlockLowerBound, uint256 _escapeBlockUpperBound)\\n        TestRollupProcessor(_escapeBlockLowerBound, _escapeBlockUpperBound)\\n    {}\\n\\n    function getImplementationVersion() public pure override returns (uint8) {\\n        return 2;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/AztecFeeDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\n\\nimport {IUniswapV2Router02} from '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\\nimport {IUniswapV2Pair} from '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\\nimport {IWETH} from '@uniswap/v2-periphery/contracts/interfaces/IWETH.sol';\\n\\nimport {TokenTransfers} from '../libraries/TokenTransfers.sol';\\nimport {IFeeDistributor} from './interfaces/IFeeDistributor.sol';\\n\\n/**\\n * @title UniswapV2LibraryErrata\\n * @dev Methods from UniswapV2Library that we need. Re-implemented due to the original from @uniswap failing to compile w. Solidity >=0.8.0\\n */\\nlibrary UniswapV2LibraryErrata {\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        uint256 pairUint = uint256(\\n            keccak256(\\n                abi.encodePacked(\\n                    hex'ff',\\n                    factory,\\n                    keccak256(abi.encodePacked(token0, token1)),\\n                    hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\\n                )\\n            )\\n        );\\n        assembly {\\n            pair := and(pairUint, 0xffffffffffffffffffffffffffffffffffffffff)\\n        }\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\\n        (address token0, ) = sortTokens(tokenA, tokenB);\\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountOut) {\\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        uint256 amountInWithFee = amountIn * 997;\\n        uint256 numerator = amountInWithFee * reserveOut;\\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\\n        amountOut = numerator / denominator;\\n    }\\n}\\n\\ncontract AztecFeeDistributor is IFeeDistributor, Ownable {\\n    using TokenTransfers for address;\\n\\n    uint256 public override feeLimit = 4e17;\\n    address public override aztecFeeClaimer;\\n    address public rollupProcessor;\\n\\n    uint256 public override convertConstant = 157768 * 20; // gas for calling convert() / 5%\\n\\n    address public immutable override router;\\n    address public immutable override factory;\\n    address public immutable override WETH;\\n\\n    constructor(\\n        address _feeClaimer,\\n        address _rollupProcessor,\\n        address _router\\n    ) {\\n        aztecFeeClaimer = _feeClaimer;\\n        rollupProcessor = _rollupProcessor;\\n        router = _router;\\n        factory = IUniswapV2Router02(_router).factory();\\n        WETH = IUniswapV2Router02(_router).WETH();\\n    }\\n\\n    // @dev top up the designated address by feeLimit\\n    receive() external payable {\\n        if (msg.sender == rollupProcessor) {\\n            if (aztecFeeClaimer.balance < feeLimit) {\\n                uint256 toSend = address(this).balance > feeLimit ? feeLimit : address(this).balance;\\n                (bool success, ) = aztecFeeClaimer.call{gas: 3000, value: toSend}('');\\n                emit FeeReimbursed(aztecFeeClaimer, toSend);\\n            }\\n        }\\n    }\\n\\n    function setFeeLimit(uint256 _feeLimit) external override onlyOwner {\\n        feeLimit = _feeLimit;\\n    }\\n\\n    function setConvertConstant(uint256 _convertConstant) external override onlyOwner {\\n        convertConstant = _convertConstant;\\n    }\\n\\n    function setFeeClaimer(address _feeClaimer) external override onlyOwner {\\n        aztecFeeClaimer = _feeClaimer;\\n    }\\n\\n    function txFeeBalance(address assetAddress) public view override returns (uint256) {\\n        if (assetAddress == address(0)) {\\n            return address(this).balance;\\n        } else {\\n            return IERC20(assetAddress).balanceOf(address(this));\\n        }\\n    }\\n\\n    function convert(address assetAddress, uint256 minOutputValue)\\n        public\\n        override\\n        onlyOwner\\n        returns (uint256 outputValue)\\n    {\\n        require(assetAddress != address(0), 'Fee Distributor: NOT_A_TOKEN_ASSET');\\n\\n        uint256 inputValue = IERC20(assetAddress).balanceOf(address(this));\\n        require(inputValue > 0, 'Fee Distributor: EMPTY_BALANCE');\\n\\n        if (assetAddress == WETH) {\\n            IWETH(WETH).withdraw(inputValue);\\n        } else {\\n            outputValue = getAmountOut(assetAddress, inputValue);\\n            require(outputValue >= minOutputValue, 'Fee Distributor: INSUFFICIENT_OUTPUT_AMOUNT');\\n            swapTokensForETH(assetAddress, inputValue, outputValue);\\n        }\\n\\n        emit Convert(assetAddress, inputValue, outputValue);\\n    }\\n\\n    function getAmountOut(address assetAddress, uint256 inputValue) internal view returns (uint256 outputValue) {\\n        (uint256 reserveIn, uint256 reserveOut) = UniswapV2LibraryErrata.getReserves(factory, assetAddress, WETH);\\n        outputValue = UniswapV2LibraryErrata.getAmountOut(inputValue, reserveIn, reserveOut);\\n    }\\n\\n    function swapTokensForETH(\\n        address assetAddress,\\n        uint256 inputValue,\\n        uint256 outputValue\\n    ) internal {\\n        address pair = UniswapV2LibraryErrata.pairFor(factory, assetAddress, WETH);\\n        assetAddress.safeTransferTo(pair, inputValue);\\n\\n        (uint256 amountOut0, uint256 amountOut1) = assetAddress < WETH\\n            ? (uint256(0), outputValue)\\n            : (outputValue, uint256(0));\\n        IUniswapV2Pair(pair).swap(amountOut0, amountOut1, address(this), new bytes(0));\\n\\n        IWETH(WETH).withdraw(outputValue);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/interfaces/IFeeDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\ninterface IFeeDistributor {\\n    event FeeReimbursed(address receiver, uint256 amount);\\n    event Convert(address assetAddress, uint256 inputValue, uint256 outputValue);\\n\\n    function convertConstant() external view returns (uint256);\\n\\n    function feeLimit() external view returns (uint256);\\n\\n    function aztecFeeClaimer() external view returns (address);\\n\\n    function router() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function WETH() external view returns (address);\\n\\n    function setFeeClaimer(address _feeClaimer) external;\\n\\n    function setFeeLimit(uint256 _feeLimit) external;\\n\\n    function setConvertConstant(uint256 _convertConstant) external;\\n\\n    function txFeeBalance(address assetAddress) external view returns (uint256);\\n\\n    function convert(address assetAddress, uint256 minOutputValue) external returns (uint256 outputValue);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/bridges/UniswapBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\n// import {UniswapV2Library} from '@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol';\\nimport {IUniswapV2Router02} from '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\\n\\nimport {IDefiBridge} from '../interfaces/IDefiBridge.sol';\\nimport {IERC20Permit} from '../interfaces/IERC20Permit.sol';\\n\\nimport {AztecTypes} from '../AztecTypes.sol';\\n\\ncontract UniswapBridge is IDefiBridge {\\n    address public immutable rollupProcessor;\\n    address public weth;\\n\\n    IUniswapV2Router02 router;\\n\\n    constructor(address _rollupProcessor, address _router) {\\n        rollupProcessor = _rollupProcessor;\\n        router = IUniswapV2Router02(_router);\\n        weth = router.WETH();\\n    }\\n\\n    receive() external payable {}\\n\\n    function convert(\\n        AztecTypes.AztecAsset memory inputAssetA,\\n        AztecTypes.AztecAsset memory inputAssetB,\\n        AztecTypes.AztecAsset memory outputAssetA,\\n        AztecTypes.AztecAsset memory outputAssetB,\\n        uint256 totalInputValue,\\n        uint256 interactionNonce,\\n        uint64, /*auxData*/\\n        address\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            uint256 outputValueA,\\n            uint256 outputValueB,\\n            bool isAsync\\n        )\\n    {\\n        // ### INITIALIZATION AND SANITY CHECKS\\n        require(msg.sender == rollupProcessor, 'UniswapBridge: INVALID_CALLER');\\n        require(\\n            inputAssetB.assetType == AztecTypes.AztecAssetType.NOT_USED,\\n            'UniswapBridge: EXPECTED_SECOND_INPUT_ASSET_NOT_USED'\\n        );\\n        require(\\n            outputAssetB.assetType == AztecTypes.AztecAssetType.NOT_USED,\\n            'UniswapBridge: EXPECTED_SECOND_OUTPUT_ASSET_NOT_USED'\\n        );\\n        outputValueB = 0;\\n        isAsync = false;\\n\\n        // ### BRIDGE LOGIC\\n        uint256[] memory amounts;\\n        uint256 deadline = block.timestamp;\\n        if (inputAssetA.assetType == AztecTypes.AztecAssetType.ETH) {\\n            require(\\n                outputAssetA.assetType != AztecTypes.AztecAssetType.ETH,\\n                'UniswapBridge: INPUT_AND_OUTPUT_BOTH_ETH!'\\n            );\\n            address[] memory path = new address[](2);\\n            path[0] = weth;\\n            path[1] = outputAssetA.erc20Address;\\n            amounts = router.swapExactETHForTokens{value: totalInputValue}(0, path, address(this), deadline);\\n            outputValueA = amounts[1];\\n            IERC20Permit(outputAssetA.erc20Address).approve(rollupProcessor, outputValueA);\\n        } else if (outputAssetA.assetType == AztecTypes.AztecAssetType.ETH) {\\n            address[] memory path = new address[](2);\\n            path[0] = inputAssetA.erc20Address;\\n            path[1] = weth;\\n            require(\\n                IERC20Permit(inputAssetA.erc20Address).approve(address(router), totalInputValue),\\n                'UniswapBridge: APPROVE_FAILED'\\n            );\\n            amounts = router.swapExactTokensForETH(totalInputValue, 0, path, address(this), deadline);\\n            outputValueA = amounts[1];\\n            bytes memory payload = abi.encodeWithSignature('receiveEthFromBridge(uint256)', interactionNonce);\\n            (bool success, ) = address(rollupProcessor).call{value: outputValueA}(payload);\\n        } else {\\n            require(\\n                inputAssetA.assetType == AztecTypes.AztecAssetType.ERC20,\\n                'UniswapBridge: INPUT_ASSET_A_NOT_ETH_OR_ERC20'\\n            );\\n            require(\\n                outputAssetA.assetType == AztecTypes.AztecAssetType.ERC20,\\n                'UniswapBridge: OUTPUT_ASSET_A_NOT_ETH_OR_ERC20'\\n            );\\n            address[] memory path = new address[](3);\\n            path[0] = inputAssetA.erc20Address;\\n            path[1] = weth;\\n            path[2] = outputAssetA.erc20Address;\\n            require(\\n                IERC20Permit(inputAssetA.erc20Address).approve(address(router), totalInputValue),\\n                'UniswapBridge: APPROVE_FAILED'\\n            );\\n            amounts = router.swapExactTokensForTokens(totalInputValue, 0, path, rollupProcessor, deadline);\\n            outputValueA = amounts[2];\\n            IERC20Permit(outputAssetA.erc20Address).approve(rollupProcessor, outputValueA);\\n        }\\n    }\\n\\n    function canFinalise(\\n        uint256 /*interactionNonce*/\\n    ) external pure override returns (bool) {\\n        return false;\\n    }\\n\\n    function finalise(\\n        AztecTypes.AztecAsset memory, /*inputAssetA*/\\n        AztecTypes.AztecAsset memory, /*inputAssetB*/\\n        AztecTypes.AztecAsset memory, /*outputAssetA*/\\n        AztecTypes.AztecAsset memory, /*outputAssetB*/\\n        uint256, /*interactionNonce*/\\n        uint64 /*auxData*/\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            bool\\n        )\\n    {\\n        require(false);\\n        return (0, 0, false);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./TransparentUpgradeableProxy.sol\\\";\\nimport \\\"../../access/Ownable.sol\\\";\\n\\n/**\\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\\n */\\ncontract ProxyAdmin is Ownable {\\n    /**\\n     * @dev Returns the current implementation of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"implementation()\\\")) == 0x5c60da1b\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\\\"5c60da1b\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Returns the current admin of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"admin()\\\")) == 0xf851a440\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\\\"f851a440\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Changes the admin of `proxy` to `newAdmin`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the current admin of `proxy`.\\n     */\\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\\n        proxy.changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\\n        proxy.upgradeTo(implementation);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgradeAndCall(\\n        TransparentUpgradeableProxy proxy,\\n        address implementation,\\n        bytes memory data\\n    ) public payable virtual onlyOwner {\\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1967/ERC1967Proxy.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n *\\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n *\\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n *\\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n *\\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\\n */\\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\\n    /**\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\\n     */\\n    constructor(\\n        address _logic,\\n        address admin_,\\n        bytes memory _data\\n    ) payable ERC1967Proxy(_logic, _data) {\\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _changeAdmin(admin_);\\n    }\\n\\n    /**\\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _getAdmin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function admin() external ifAdmin returns (address admin_) {\\n        admin_ = _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function implementation() external ifAdmin returns (address implementation_) {\\n        implementation_ = _implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\\n     */\\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\\n        _changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\\n     */\\n    function upgradeTo(address newImplementation) external ifAdmin {\\n        _upgradeToAndCall(newImplementation, bytes(\\\"\\\"), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n     * proxied contract.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\\n        _upgradeToAndCall(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _admin() internal view virtual returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\\n     */\\n    function _beforeFallback() internal virtual override {\\n        require(msg.sender != _getAdmin(), \\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\n        super._beforeFallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/ProxyDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {TransparentUpgradeableProxy} from '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\\n\\ncontract ProxyDeployer {\\n    event ProxyDeployed(address logic, address admin, bytes32 salt, address proxy);\\n\\n    constructor() {}\\n\\n    function deployProxy(\\n        address _logic,\\n        address _admin,\\n        bytes memory _data,\\n        bytes32 _salt\\n    ) public returns (address) {\\n        TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy{salt: _salt}(_logic, _admin, _data);\\n\\n        emit ProxyDeployed(_logic, _admin, _salt, address(proxy));\\n\\n        return address(proxy);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport {TransparentUpgradeableProxy} from '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\\nimport {ProxyAdmin} from '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';\"\r\n    },\r\n    \"contracts/DefiBridgeProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {IDefiBridge} from './interfaces/IDefiBridge.sol';\\nimport {AztecTypes} from './AztecTypes.sol';\\nimport {TokenTransfers} from './libraries/TokenTransfers.sol';\\n\\ncontract DefiBridgeProxy {\\n    error OUTPUT_A_EXCEEDS_252_BITS(uint256 outputValue);\\n    error OUTPUT_B_EXCEEDS_252_BITS(uint256 outputValue);\\n    error ASYNC_NONZERO_OUTPUT_VALUES(uint256 outputValueA, uint256 outputValueB);\\n    error INSUFFICIENT_ETH_PAYMENT();\\n\\n    /**\\n     * @dev Use interaction result data to pull tokens into DefiBridgeProxy\\n     * @param asset The AztecAsset being targetted\\n     * @param outputValue The claimed output value provided by the bridge\\n     * @param interactionNonce The defi interaction nonce of the interaction\\n     * @param bridgeContract Address of the defi bridge contract\\n     * @param ethPaymentsSlot The slot value of the `ethPayments` storage mapping in RollupProcessor.sol!\\n     * More details on ethPaymentsSlot are in the comments for the `convert` function\\n     */\\n    function recoverTokens(\\n        AztecTypes.AztecAsset memory asset,\\n        uint256 outputValue,\\n        uint256 interactionNonce,\\n        address bridgeContract,\\n        uint256 ethPaymentsSlot\\n    ) internal {\\n        if (outputValue == 0) {\\n            return;\\n        }\\n        if (asset.assetType == AztecTypes.AztecAssetType.ETH) {\\n            uint256 ethPayment;\\n            uint256 ethPaymentsSlotBase;\\n            assembly {\\n                mstore(0x00, interactionNonce)\\n                mstore(0x20, ethPaymentsSlot)\\n                ethPaymentsSlotBase := keccak256(0x00, 0x40)\\n                ethPayment := sload(ethPaymentsSlotBase) // ethPayment = ethPayments[interactionNonce]\\n            }\\n            if (outputValue > ethPayment) {\\n                revert INSUFFICIENT_ETH_PAYMENT();\\n            }\\n            assembly {\\n                sstore(ethPaymentsSlotBase, 0) // ethPayments[interactionNonce] = 0;\\n            }\\n        } else if (asset.assetType == AztecTypes.AztecAssetType.ERC20) {\\n            TokenTransfers.safeTransferFrom(asset.erc20Address, bridgeContract, address(this), outputValue);\\n        }\\n    }\\n\\n    /**\\n     * @dev Convert input assets into output assets via calling a defi bridge contract\\n     * @param bridgeAddress Address of the defi bridge contract\\n     * @param inputAssetA First input asset\\n     * @param inputAssetB Second input asset. Is either VIRTUAL or NOT_USED (checked by RollupProcessor)\\n     * @param outputAssetA First output asset\\n     * @param outputAssetB Second output asset\\n     * @param totalInputValue The total amount of inputAssetA to be sent to the bridge\\n     * @param interactionNonce Integer that is unique for a given defi interaction\\n     * @param auxInputData Optional custom data to be sent to the bridge (defined in the L2 SNARK circuits when creating claim notes)\\n     * @param ethPaymentsSlot The slot value of the `ethPayments` storage mapping in RollupProcessor.sol!\\n     * @param rollupBeneficiary The address that should be payed any fees / subsidy for executing this bridge.\\n\\n     * We assume this contract is called from the RollupProcessor via `delegateCall`,\\n     * if not... this contract behaviour is undefined! So don't do that.\\n     * The idea here is that, if the defi bridge has returned native ETH, they will do so via calling\\n     * `RollupProcessor.receiveEthPayment(uint256 interactionNonce)`.\\n     * To summarise the issue, we must solve for the following:\\n     * 1. We need to be able to read the `ethPayments` state variable to determine how much Eth has been sent (and reset it)\\n     * 2. We must encapsulate the entire defi interaction flow via a 'delegatecall' so that we can safely revert\\n     *    all token/eth transfers if the defi interaction fails, *without* throwing the entire rollup transaction\\n     * 3. We don't want to directly call `delegateCall` on RollupProcessor.sol to minimise the attack surface against delegatecall re-entrancy exploits\\n     *\\n     * Solution is to pass the ethPayments.slot storage slot in as a param during the delegateCall and update in assembly via `sstore`\\n     * We could achieve the same effect via getters/setters on the function, but that would be expensive as that would trigger additional `call` opcodes.\\n     * We could *also* just hard-code the slot value, but that is quite brittle as\\n     * any re-ordering of storage variables during development would require updating the hardcoded constant\\n     *\\n     * @return outputValueA outputvalueB isAsync\\n     * outputValueA = the number of outputAssetA tokens we must recover from the bridge\\n     * outputValueB = the number of outputAssetB tokens we must recover from the bridge\\n     * isAsync describes whether the defi interaction has instantly resolved, or if the interaction must be finalised in a future Eth block\\n     * if isAsync == true, outputValueA and outputValueB must both equal 0\\n     */\\n    function convert(\\n        address bridgeAddress,\\n        AztecTypes.AztecAsset memory inputAssetA,\\n        AztecTypes.AztecAsset memory inputAssetB,\\n        AztecTypes.AztecAsset memory outputAssetA,\\n        AztecTypes.AztecAsset memory outputAssetB,\\n        uint256 totalInputValue,\\n        uint256 interactionNonce,\\n        uint256 auxInputData, // (auxData)\\n        uint256 ethPaymentsSlot,\\n        address rollupBeneficiary\\n    )\\n        external\\n        returns (\\n            uint256 outputValueA,\\n            uint256 outputValueB,\\n            bool isAsync\\n        )\\n    {\\n        if (inputAssetA.assetType == AztecTypes.AztecAssetType.ERC20) {\\n            // Transfer totalInputValue to the bridge contract if erc20. ETH is sent on call to convert.\\n            TokenTransfers.safeTransferTo(inputAssetA.erc20Address, bridgeAddress, totalInputValue);\\n        }\\n        if (inputAssetB.assetType == AztecTypes.AztecAssetType.ERC20) {\\n            // Transfer totalInputValue to the bridge contract if erc20. ETH is sent on call to convert.\\n            TokenTransfers.safeTransferTo(inputAssetB.erc20Address, bridgeAddress, totalInputValue);\\n        }\\n        // Call bridge.convert(), which will return output values for the two output assets.\\n        // If input is ETH, send it along with call to convert.\\n        uint256 ethValue = (inputAssetA.assetType == AztecTypes.AztecAssetType.ETH ||\\n            inputAssetB.assetType == AztecTypes.AztecAssetType.ETH)\\n            ? totalInputValue\\n            : 0;\\n        (outputValueA, outputValueB, isAsync) = IDefiBridge(bridgeAddress).convert{value: ethValue}(\\n            inputAssetA,\\n            inputAssetB,\\n            outputAssetA,\\n            outputAssetB,\\n            totalInputValue,\\n            interactionNonce,\\n            uint64(auxInputData),\\n            rollupBeneficiary\\n        );\\n\\n        if (isAsync) {\\n            if (outputValueA > 0 || outputValueB > 0) {\\n                revert ASYNC_NONZERO_OUTPUT_VALUES(outputValueA, outputValueB);\\n            }\\n        } else {\\n            address bridgeAddressCopy = bridgeAddress; // stack overflow workaround\\n            if (outputValueA >= (1 << 252)) {\\n                revert OUTPUT_A_EXCEEDS_252_BITS(outputValueA);\\n            }\\n            if (outputValueB >= (1 << 252)) {\\n                revert OUTPUT_B_EXCEEDS_252_BITS(outputValueB);\\n            }\\n            recoverTokens(outputAssetA, outputValueA, interactionNonce, bridgeAddressCopy, ethPaymentsSlot);\\n            recoverTokens(outputAssetB, outputValueB, interactionNonce, bridgeAddressCopy, ethPaymentsSlot);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/HashInputs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {Decoder} from '../Decoder.sol';\\nimport {IVerifier} from '../interfaces/IVerifier.sol';\\n\\n/**\\n * TODO: Pretty sure this should all be removed and we should be testing decodeProof response directly.\\n */\\ncontract HashInputs is Decoder {\\n    IVerifier public verifier;\\n    error PUBLIC_INPUTS_HASH_VERIFICATION_FAILED(uint256, uint256);\\n\\n    constructor(address _verifierAddress) {\\n        verifier = IVerifier(_verifierAddress);\\n    }\\n\\n    function computePublicInputHash(\\n        bytes calldata /* encodedProofData */\\n    ) external view returns (bytes32) {\\n        decodeProof();\\n        return 0;\\n    }\\n\\n    function verifyProofTest(\\n        bytes calldata /* encodedProofData */\\n    ) external view {\\n        (, , uint256 publicInputsHash) = decodeProof();\\n        uint256 broadcastedDataSize = ROLLUP_HEADER_LENGTH + 8; // add 8 bytes for two packed params at end of header\\n        bool proof_verified;\\n        assembly {\\n            /**\\n             * Validate correctness of zk proof.\\n             *\\n             * 1st Item is to format verifier calldata.\\n             **/\\n\\n            // Our first input param `encodedProofData` contains the concatenation of\\n            // encoded 'broadcasted inputs' and the actual zk proof data.\\n            // (The `boadcasted inputs` is converted into a 32-byte SHA256 hash, which is\\n            // validated to equal the first public inputs of the zk proof. This is done in `Decoder.sol`).\\n            // We need to identify the location in calldata that points to the start of the zk proof data.\\n\\n            // Step 1: compute size of zk proof data and its calldata pointer.\\n            /**\\n                Data layout for `bytes encodedProofData`...\\n\\n                0x00 : 0x20 : length of array\\n                0x20 : 0x20 + header : root rollup header data\\n                0x20 + header : 0x24 + header : X, the length of encoded inner join-split public inputs\\n                0x24 + header : 0x24 + header + X : (inner join-split public inputs)\\n                0x24 + header + X : 0x28 + header + X : Y, the length of the zk proof data\\n                0x28 + header + X : 0x28 + haeder + X + Y : zk proof data\\n\\n                We need to recover the numeric value of `0x28 + header + X` and `Y`\\n             **/\\n            // Begin by getting length of encoded inner join-split public inputs.\\n            // `calldataload(0x04)` points to start of bytes array. Add 0x24 to skip over length param and function signature.\\n            // The calldata param *after* the header is the length of the pub inputs array. However it is a packed 4-byte param.\\n            // To extract it, we subtract 28 bytes from the calldata pointer and mask off all but the 4 least significant bytes.\\n            let encodedInnerDataSize := and(\\n                calldataload(add(add(calldataload(0x04), 0x24), sub(ROLLUP_HEADER_LENGTH, 0x18))),\\n                0xffffffff\\n            )\\n\\n            // broadcastedDataSize = inner join-split pubinput size + header size + 8 bytes (skip over zk proof length param)\\n            broadcastedDataSize := add(broadcastedDataSize, encodedInnerDataSize)\\n\\n            // Compute zk proof data size by subtracting broadcastedDataSize from overall length of bytes encodedProofsData\\n            let zkProofDataSize := sub(calldataload(add(calldataload(0x04), 0x04)), broadcastedDataSize)\\n\\n            // Compute calldata pointer to start of zk proof data by adding calldata offset to broadcastedDataSize\\n            // (+0x24 skips over function signature and numRealTxs param and length param of bytes encodedProofData)\\n            // add +4 for new param or not?\\n            let zkProofDataPtr := add(broadcastedDataSize, add(calldataload(0x04), 0x24))\\n\\n            // Step 2: Format calldata for verifier contract call.\\n\\n            // Get free memory pointer - we copy calldata into memory starting here\\n            let dataPtr := mload(0x40)\\n\\n            // We call the function `verify(bytes,uint256)`\\n            // The function signature is 0xac318c5d\\n            // Calldata map is:\\n            // 0x00 - 0x04 : 0xac318c5d\\n            // 0x04 - 0x24 : 0x40 (number of bytes between 0x04 and the start of the `proofData` array at 0x44)\\n            // 0x24 - 0x44 : publicInputsHash\\n            // 0x44 - .... : proofData\\n            mstore8(dataPtr, 0xac)\\n            mstore8(add(dataPtr, 0x01), 0x31)\\n            mstore8(add(dataPtr, 0x02), 0x8c)\\n            mstore8(add(dataPtr, 0x03), 0x5d)\\n            mstore(add(dataPtr, 0x04), 0x40)\\n            mstore(add(dataPtr, 0x24), publicInputsHash)\\n            mstore(add(dataPtr, 0x44), zkProofDataSize) // length of zkProofData bytes array\\n            calldatacopy(add(dataPtr, 0x64), zkProofDataPtr, zkProofDataSize) // copy the zk proof data into memory\\n\\n            // Step 3: Call our verifier contract. If does not return any values, but will throw an error if the proof is not valid\\n            // i.e. verified == false if proof is not valid\\n            proof_verified := staticcall(gas(), sload(verifier.slot), dataPtr, add(zkProofDataSize, 0x64), 0x00, 0x00)\\n        }\\n\\n        if (!proof_verified) {\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/StandardVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n// gas count: 299,341 (includes 21,000 tx base cost, includes cost of 3 pub inputs. Cost of circuit without pub inputs is 298,312)\\n\\nimport {IVerifier} from '../interfaces/IVerifier.sol';\\nimport {VerificationKey} from './keys/VerificationKey.sol';\\nimport {StandardTypes} from './cryptography/StandardTypes.sol';\\n\\n/**\\n * @title Standard Plonk proof verification contract\\n * @dev Top level Plonk proof verification contract, which allows Plonk proof to be verified\\n *\\n * Copyright 2022 Aztec\\n *\\n * Licensed under the GNU General Public License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n *\\n * This program is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n * GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n */\\ncontract StandardVerifier is IVerifier {\\n    // VERIFICATION KEY MEMORY LOCATIONS\\n    uint256 internal constant N_LOC =                                    0x200 + 0x00;\\n    uint256 internal constant NUM_INPUTS_LOC =                           0x200 + 0x20;\\n    uint256 internal constant OMEGA_LOC =                                0x200 + 0x40;\\n    uint256 internal constant DOMAIN_INVERSE_LOC =                       0x200 + 0x60;\\n    uint256 internal constant Q1_X_LOC =                                 0x200 + 0x80;\\n    uint256 internal constant Q1_Y_LOC =                                 0x200 + 0xa0;\\n    uint256 internal constant Q2_X_LOC =                                 0x200 + 0xc0;\\n    uint256 internal constant Q2_Y_LOC =                                 0x200 + 0xe0;\\n    uint256 internal constant Q3_X_LOC =                                 0x200 + 0x100;\\n    uint256 internal constant Q3_Y_LOC =                                 0x200 + 0x120;\\n    uint256 internal constant QM_X_LOC =                                 0x200 + 0x140;\\n    uint256 internal constant QM_Y_LOC =                                 0x200 + 0x160;\\n    uint256 internal constant QC_X_LOC =                                 0x200 + 0x180;\\n    uint256 internal constant QC_Y_LOC =                                 0x200 + 0x1a0;\\n    uint256 internal constant SIGMA1_X_LOC =                             0x200 + 0x1c0;\\n    uint256 internal constant SIGMA1_Y_LOC =                             0x200 + 0x1e0;\\n    uint256 internal constant SIGMA2_X_LOC =                             0x200 + 0x200;\\n    uint256 internal constant SIGMA2_Y_LOC =                             0x200 + 0x220;\\n    uint256 internal constant SIGMA3_X_LOC =                             0x200 + 0x240;\\n    uint256 internal constant SIGMA3_Y_LOC =                             0x200 + 0x260;\\n    uint256 internal constant CONTAINS_RECURSIVE_PROOF_LOC =             0x200 + 0x280;\\n    uint256 internal constant RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC = 0x200 + 0x2a0;\\n    uint256 internal constant G2X_X0_LOC =                               0x200 + 0x2c0;\\n    uint256 internal constant G2X_X1_LOC =                               0x200 + 0x2e0;\\n    uint256 internal constant G2X_Y0_LOC =                               0x200 + 0x300;\\n    uint256 internal constant G2X_Y1_LOC =                               0x200 + 0x320;\\n    // 26\\n\\n    // ### PROOF DATA MEMORY LOCATIONS\\n    uint256 internal constant W1_X_LOC =                                 0x200 + 0x340 + 0x00;\\n    uint256 internal constant W1_Y_LOC =                                 0x200 + 0x340 + 0x20;\\n    uint256 internal constant W2_X_LOC =                                 0x200 + 0x340 + 0x40;\\n    uint256 internal constant W2_Y_LOC =                                 0x200 + 0x340 + 0x60;\\n    uint256 internal constant W3_X_LOC =                                 0x200 + 0x340 + 0x80;\\n    uint256 internal constant W3_Y_LOC =                                 0x200 + 0x340 + 0xa0;\\n    uint256 internal constant Z_X_LOC =                                  0x200 + 0x340 + 0xc0;\\n    uint256 internal constant Z_Y_LOC =                                  0x200 + 0x340 + 0xe0;\\n    uint256 internal constant T1_X_LOC =                                 0x200 + 0x340 + 0x100;\\n    uint256 internal constant T1_Y_LOC =                                 0x200 + 0x340 + 0x120;\\n    uint256 internal constant T2_X_LOC =                                 0x200 + 0x340 + 0x140;\\n    uint256 internal constant T2_Y_LOC =                                 0x200 + 0x340 + 0x160;\\n    uint256 internal constant T3_X_LOC =                                 0x200 + 0x340 + 0x180;\\n    uint256 internal constant T3_Y_LOC =                                 0x200 + 0x340 + 0x1a0;\\n    uint256 internal constant W1_EVAL_LOC =                              0x200 + 0x340 + 0x1c0;\\n    uint256 internal constant W2_EVAL_LOC =                              0x200 + 0x340 + 0x1e0;\\n    uint256 internal constant W3_EVAL_LOC =                              0x200 + 0x340 + 0x200;\\n    uint256 internal constant SIGMA1_EVAL_LOC =                          0x200 + 0x340 + 0x220;\\n    uint256 internal constant SIGMA2_EVAL_LOC =                          0x200 + 0x340 + 0x240;\\n    uint256 internal constant Z_OMEGA_EVAL_LOC =                         0x200 + 0x340 + 0x260;\\n    uint256 internal constant PI_Z_X_LOC =                               0x200 + 0x340 + 0x280;\\n    uint256 internal constant PI_Z_Y_LOC =                               0x200 + 0x340 + 0x2a0;\\n    uint256 internal constant PI_Z_OMEGA_X_LOC =                         0x200 + 0x340 + 0x2c0;\\n    uint256 internal constant PI_Z_OMEGA_Y_LOC =                         0x200 + 0x340 + 0x2e0;\\n    // 25\\n\\n    // ### CHALLENGES MEMORY OFFSETS\\n    uint256 internal constant C_BETA_LOC =                               0x200 + 0x340 + 0x300 + 0x00;\\n    uint256 internal constant C_GAMMA_LOC =                              0x200 + 0x340 + 0x300 + 0x20;\\n    uint256 internal constant C_ALPHA_LOC =                              0x200 + 0x340 + 0x300 + 0x40;\\n    uint256 internal constant C_ARITHMETIC_ALPHA_LOC =                   0x200 + 0x340 + 0x300 + 0x60;\\n    uint256 internal constant C_ZETA_LOC =                               0x200 + 0x340 + 0x300 + 0x80;\\n    uint256 internal constant C_CURRENT_LOC =                            0x200 + 0x340 + 0x300 + 0xa0;\\n    uint256 internal constant C_V0_LOC =                                 0x200 + 0x340 + 0x300 + 0xc0;\\n    uint256 internal constant C_V1_LOC =                                 0x200 + 0x340 + 0x300 + 0xe0;\\n    uint256 internal constant C_V2_LOC =                                 0x200 + 0x340 + 0x300 + 0x100;\\n    uint256 internal constant C_V3_LOC =                                 0x200 + 0x340 + 0x300 + 0x120;\\n    uint256 internal constant C_V4_LOC =                                 0x200 + 0x340 + 0x300 + 0x140;\\n    uint256 internal constant C_V5_LOC =                                 0x200 + 0x340 + 0x300 + 0x160;\\n    uint256 internal constant C_U_LOC =                                  0x200 + 0x340 + 0x300 + 0x180;\\n    // 13\\n\\n    // ### LOCAL VARIABLES MEMORY OFFSETS\\n    uint256 internal constant DELTA_NUMERATOR_LOC =                      0x200 + 0x340 + 0x300 + 0x1a0 + 0x00;\\n    uint256 internal constant DELTA_DENOMINATOR_LOC =                    0x200 + 0x340 + 0x300 + 0x1a0 + 0x20;\\n    uint256 internal constant ZETA_POW_N_LOC =                           0x200 + 0x340 + 0x300 + 0x1a0 + 0x40;\\n    uint256 internal constant PUBLIC_INPUT_DELTA_LOC =                   0x200 + 0x340 + 0x300 + 0x1a0 + 0x60;\\n    uint256 internal constant ZERO_POLY_LOC =                            0x200 + 0x340 + 0x300 + 0x1a0 + 0x80;\\n    uint256 internal constant L_START_LOC =                              0x200 + 0x340 + 0x300 + 0x1a0 + 0xa0;\\n    uint256 internal constant L_END_LOC =                                0x200 + 0x340 + 0x300 + 0x1a0 + 0xc0;\\n    uint256 internal constant R_ZERO_EVAL_LOC =                          0x200 + 0x340 + 0x300 + 0x1a0 + 0xe0;\\n    uint256 internal constant ACCUMULATOR_X_LOC =                        0x200 + 0x340 + 0x300 + 0x1a0 + 0x100;\\n    uint256 internal constant ACCUMULATOR_Y_LOC =                        0x200 + 0x340 + 0x300 + 0x1a0 + 0x120;\\n    uint256 internal constant ACCUMULATOR2_X_LOC =                       0x200 + 0x340 + 0x300 + 0x1a0 + 0x140;\\n    uint256 internal constant ACCUMULATOR2_Y_LOC =                       0x200 + 0x340 + 0x300 + 0x1a0 + 0x160;\\n    uint256 internal constant PAIRING_LHS_X_LOC =                        0x200 + 0x340 + 0x300 + 0x1a0 + 0x180;\\n    uint256 internal constant PAIRING_LHS_Y_LOC =                        0x200 + 0x340 + 0x300 + 0x1a0 + 0x1a0;\\n    uint256 internal constant PAIRING_RHS_X_LOC =                        0x200 + 0x340 + 0x300 + 0x1a0 + 0x1c0;\\n    uint256 internal constant PAIRING_RHS_Y_LOC =                        0x200 + 0x340 + 0x300 + 0x1a0 + 0x1e0;\\n    // 21\\n\\n    // ### SUCCESS FLAG MEMORY LOCATIONS\\n    uint256 internal constant GRAND_PRODUCT_SUCCESS_FLAG =               0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0x00;\\n    uint256 internal constant ARITHMETIC_TERM_SUCCESS_FLAG =             0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0x20;\\n    uint256 internal constant BATCH_OPENING_SUCCESS_FLAG =               0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0x40;\\n    uint256 internal constant OPENING_COMMITMENT_SUCCESS_FLAG =          0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0x60;\\n    uint256 internal constant PAIRING_PREAMBLE_SUCCESS_FLAG =            0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0x80;\\n    uint256 internal constant PAIRING_SUCCESS_FLAG =                     0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xa0;\\n    uint256 internal constant RESULT_FLAG =                              0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xc0;\\n    // 7\\n\\n    // misc stuff\\n    uint256 internal constant OMEGA_INVERSE_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0;\\n    uint256 internal constant C_ALPHA_SQR_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0x20;\\n    // 3\\n\\n    // ### RECURSION VARIABLE MEMORY LOCATIONS\\n    uint256 internal constant RECURSIVE_P1_X_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0x40;\\n    uint256 internal constant RECURSIVE_P1_Y_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0x60;\\n    uint256 internal constant RECURSIVE_P2_X_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0x80;\\n    uint256 internal constant RECURSIVE_P2_Y_LOC = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0xa0;\\n\\n    uint256 internal constant PUBLIC_INPUTS_HASH_LOCATION = 0x200 + 0x340 + 0x300 + 0x1a0 + 0x200 + 0xe0 + 0xc0;\\n\\n    error PUBLIC_INPUTS_HASH_VERIFICATION_FAILED(uint256, uint256);\\n    /**\\n     * @dev Verify a Plonk proof\\n     * @param - array of serialized proof data\\n     * @param - public input hash as computed from the broadcast data\\n     */\\n    function verify(bytes calldata, uint256 public_inputs_hash) external view override returns (bool) {\\n        // validate the correctness of the public inputs hash\\n        {\\n            bool hash_matches_input;\\n            uint256 recovered_hash;\\n            assembly {\\n                recovered_hash := calldataload(add(calldataload(0x04), 0x24))\\n                hash_matches_input := eq(recovered_hash, public_inputs_hash)\\n            }\\n            if (!hash_matches_input)\\n            {\\n                revert PUBLIC_INPUTS_HASH_VERIFICATION_FAILED(public_inputs_hash, recovered_hash);\\n            }\\n        }\\n\\n        StandardTypes.VerificationKey memory vk = VerificationKey.get_verification_key();\\n\\n        assembly {\\n            /**\\n             * LOAD VKEY\\n             * TODO REPLACE THIS WITH A CONTRACT CALL\\n             */\\n            {\\n                mstore(N_LOC, mload(vk))\\n                mstore(NUM_INPUTS_LOC, mload(add(vk, 0x20)))\\n                mstore(OMEGA_LOC,           mload(add(vk, 0x40)))\\n                mstore(DOMAIN_INVERSE_LOC,  mload(add(vk, 0x60)))\\n                mstore(OMEGA_INVERSE_LOC,   mload(add(vk, 0x80)))\\n                mstore(Q1_X_LOC,            mload(mload(add(vk, 0xa0))))\\n                mstore(Q1_Y_LOC,            mload(add(mload(add(vk, 0xa0)), 0x20)))\\n                mstore(Q2_X_LOC,            mload(mload(add(vk, 0xc0))))\\n                mstore(Q2_Y_LOC,            mload(add(mload(add(vk, 0xc0)), 0x20)))\\n                mstore(Q3_X_LOC,            mload(mload(add(vk, 0xe0))))\\n                mstore(Q3_Y_LOC,            mload(add(mload(add(vk, 0xe0)), 0x20)))\\n                mstore(QM_X_LOC,            mload(mload(add(vk, 0x100))))\\n                mstore(QM_Y_LOC,            mload(add(mload(add(vk, 0x100)), 0x20)))\\n                mstore(QC_X_LOC,            mload(mload(add(vk, 0x120))))\\n                mstore(QC_Y_LOC,            mload(add(mload(add(vk, 0x120)), 0x20)))\\n                mstore(SIGMA1_X_LOC,        mload(mload(add(vk, 0x140))))\\n                mstore(SIGMA1_Y_LOC,        mload(add(mload(add(vk, 0x140)), 0x20)))\\n                mstore(SIGMA2_X_LOC,        mload(mload(add(vk, 0x160))))\\n                mstore(SIGMA2_Y_LOC,        mload(add(mload(add(vk, 0x160)), 0x20)))\\n                mstore(SIGMA3_X_LOC,        mload(mload(add(vk, 0x180))))\\n                mstore(SIGMA3_Y_LOC,        mload(add(mload(add(vk, 0x180)), 0x20)))\\n                mstore(CONTAINS_RECURSIVE_PROOF_LOC, mload(add(vk, 0x1a0)))\\n                mstore(RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC, mload(add(vk, 0x1c0)))\\n                mstore(G2X_X0_LOC, 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1)\\n                mstore(G2X_X1_LOC, 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0)\\n                mstore(G2X_Y0_LOC, 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4)\\n                mstore(G2X_Y1_LOC, 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55)\\n            }\\n\\n            let q := 21888242871839275222246405745257275088696311157297823662689037894645226208583 // EC group order\\n            let p := 21888242871839275222246405745257275088548364400416034343698204186575808495617 // Prime field order\\n\\n\\n            /**\\n             * LOAD PROOF FROM CALLDATA\\n             */\\n            {\\n                let data_ptr := add(calldataload(0x04), 0x24)\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC)\\n                {\\n                    let index_counter := add(mul(mload(RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC), 32), data_ptr)\\n\\n                    let x0 := calldataload(index_counter)\\n                    x0 := add(x0, shl(68, calldataload(add(index_counter, 0x20))))\\n                    x0 := add(x0, shl(136, calldataload(add(index_counter, 0x40))))\\n                    x0 := add(x0, shl(204, calldataload(add(index_counter, 0x60))))\\n                    let y0 := calldataload(add(index_counter, 0x80))\\n                    y0 := add(y0, shl(68, calldataload(add(index_counter, 0xa0))))\\n                    y0 := add(y0, shl(136, calldataload(add(index_counter, 0xc0))))\\n                    y0 := add(y0, shl(204, calldataload(add(index_counter, 0xe0))))\\n                    let x1 := calldataload(add(index_counter, 0x100))\\n                    x1 := add(x1, shl(68, calldataload(add(index_counter, 0x120))))\\n                    x1 := add(x1, shl(136, calldataload(add(index_counter, 0x140))))\\n                    x1 := add(x1, shl(204, calldataload(add(index_counter, 0x160))))\\n                    let y1 := calldataload(add(index_counter, 0x180))\\n                    y1 := add(y1, shl(68, calldataload(add(index_counter, 0x1a0))))\\n                    y1 := add(y1, shl(136, calldataload(add(index_counter, 0x1c0))))\\n                    y1 := add(y1, shl(204, calldataload(add(index_counter, 0x1e0))))\\n                    mstore(RECURSIVE_P1_X_LOC, x0)\\n                    mstore(RECURSIVE_P1_Y_LOC, y0)\\n                    mstore(RECURSIVE_P2_X_LOC, x1)\\n                    mstore(RECURSIVE_P2_Y_LOC, y1)\\n\\n                    // validate these are valid bn128 G1 points\\n                    if iszero(and(\\n                        and(lt(x0, q), lt(x1, q)),\\n                        and(lt(y0, q), lt(y1, q))\\n                    )) {\\n                        revert(0x00, 0x00)\\n                    }\\n                }\\n\\n            let public_input_byte_length := mul(mload(NUM_INPUTS_LOC), 32)\\n            data_ptr := add(data_ptr, public_input_byte_length)\\n\\n\\n            mstore(W1_X_LOC, mod(calldataload(add(data_ptr, 0x20)), q))\\n            mstore(W1_Y_LOC, mod(calldataload(data_ptr), q))\\n            mstore(W2_X_LOC, mod(calldataload(add(data_ptr, 0x60)), q))\\n            mstore(W2_Y_LOC, mod(calldataload(add(data_ptr, 0x40)), q))\\n            mstore(W3_X_LOC, mod(calldataload(add(data_ptr, 0xa0)), q))\\n            mstore(W3_Y_LOC, mod(calldataload(add(data_ptr, 0x80)), q))\\n            mstore(Z_X_LOC, mod(calldataload(add(data_ptr, 0xe0)), q))\\n            mstore(Z_Y_LOC, mod(calldataload(add(data_ptr, 0xc0)), q))\\n            mstore(T1_X_LOC, mod(calldataload(add(data_ptr, 0x120)), q))\\n            mstore(T1_Y_LOC, mod(calldataload(add(data_ptr, 0x100)), q))\\n            mstore(T2_X_LOC, mod(calldataload(add(data_ptr, 0x160)), q))\\n            mstore(T2_Y_LOC, mod(calldataload(add(data_ptr, 0x140)), q))\\n            mstore(T3_X_LOC, mod(calldataload(add(data_ptr, 0x1a0)), q))\\n            mstore(T3_Y_LOC, mod(calldataload(add(data_ptr, 0x180)), q))\\n            mstore(W1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x1c0)), p))\\n            mstore(W2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x1e0)), p))\\n            mstore(W3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x200)), p))\\n            mstore(SIGMA1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x220)), p))\\n            mstore(SIGMA2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x240)), p))\\n            mstore(Z_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x260)), p))\\n            mstore(PI_Z_X_LOC, mod(calldataload(add(data_ptr, 0x2a0)), q))\\n            mstore(PI_Z_Y_LOC, mod(calldataload(add(data_ptr, 0x280)), q))\\n            mstore(PI_Z_OMEGA_X_LOC, mod(calldataload(add(data_ptr, 0x2e0)), q))\\n            mstore(PI_Z_OMEGA_Y_LOC, mod(calldataload(add(data_ptr, 0x2c0)), q))\\n            }\\n\\n            {\\n            /**\\n             * Generate initial challenge\\n             **/\\n\\n            mstore(0x00, shl(224, mload(N_LOC)))\\n            mstore(0x04, shl(224, mload(NUM_INPUTS_LOC)))\\n            let challenge := keccak256(0x00, 0x08)\\n\\n            /**\\n             * Generate beta, gamma challenges\\n             */\\n            mstore(PUBLIC_INPUTS_HASH_LOCATION, challenge)\\n            let inputs_start := add(calldataload(0x04), 0x24)\\n            let num_calldata_bytes := add(0xc0, mul(mload(NUM_INPUTS_LOC), 0x20))\\n            calldatacopy(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), inputs_start, num_calldata_bytes)\\n\\n            challenge := keccak256(PUBLIC_INPUTS_HASH_LOCATION, add(num_calldata_bytes, 0x20))\\n\\n            mstore(C_BETA_LOC, mod(challenge, p))\\n\\n            mstore(0x00, challenge)\\n            mstore8(0x20, 0x01)\\n            challenge := keccak256(0x00, 0x21)\\n            mstore(C_GAMMA_LOC, mod(challenge, p))\\n\\n            /**\\n             * Generate alpha challenge\\n             */\\n            mstore(0x00, challenge)\\n            mstore(0x20, mload(Z_Y_LOC))\\n            mstore(0x40, mload(Z_X_LOC))\\n            challenge := keccak256(0x00, 0x60)\\n            mstore(C_ALPHA_LOC, mod(challenge, p))\\n            /**\\n             * Generate zeta challenge\\n             */\\n            mstore(0x00, challenge)\\n            mstore(0x20, mload(T1_Y_LOC))\\n            mstore(0x40, mload(T1_X_LOC))\\n            mstore(0x60, mload(T2_Y_LOC))\\n            mstore(0x80, mload(T2_X_LOC))\\n            mstore(0xa0, mload(T3_Y_LOC))\\n            mstore(0xc0, mload(T3_X_LOC))\\n            challenge := keccak256(0x00, 0xe0)\\n\\n            mstore(C_ZETA_LOC, mod(challenge, p))\\n            mstore(C_CURRENT_LOC, challenge)\\n            }\\n\\n            /**\\n             * EVALUATE FIELD OPERATIONS\\n             */\\n\\n            /**\\n             * COMPUTE PUBLIC INPUT DELTA\\n             */\\n            {\\n                let gamma := mload(C_GAMMA_LOC)\\n                let work_root := mload(OMEGA_LOC)\\n                let endpoint := sub(mul(mload(NUM_INPUTS_LOC), 0x20), 0x20)\\n                let public_inputs\\n                let root_1 := mload(C_BETA_LOC)\\n                let root_2 := root_1\\n                let numerator_value := 1\\n                let denominator_value := 1\\n\\n                let p_clone := p // move p to the front of the stack\\n                let valid := true\\n\\n                root_1 := mulmod(root_1, 0x05, p_clone) // k1.beta\\n                root_2 := mulmod(root_2, 0x07, p_clone) // 0x05 + 0x07 = 0x0c = external coset generator\\n\\n                public_inputs := add(calldataload(0x04), 0x24)\\n                endpoint := add(endpoint, public_inputs)\\n\\n                for {} lt(public_inputs, endpoint) {}\\n                {\\n                    let input0 := calldataload(public_inputs)\\n                    let N0 := add(root_1, add(input0, gamma))\\n                    let D0 := add(root_2, N0) // 4x overloaded\\n\\n                    root_1 := mulmod(root_1, work_root, p_clone)\\n                    root_2 := mulmod(root_2, work_root, p_clone)\\n\\n                    let input1 := calldataload(add(public_inputs, 0x20))\\n                    let N1 := add(root_1, add(input1, gamma))\\n\\n                    denominator_value := mulmod(mulmod(D0, denominator_value, p_clone), add(N1, root_2), p_clone)\\n                    numerator_value := mulmod(mulmod(N1, N0, p_clone), numerator_value, p_clone)\\n\\n                    root_1 := mulmod(root_1, work_root, p_clone)\\n                    root_2 := mulmod(root_2, work_root, p_clone)\\n\\n                    valid := and(valid, and(lt(input0, p_clone), lt(input1, p_clone)))\\n                    public_inputs := add(public_inputs, 0x40)\\n\\n                    // validate public inputs are field elements (i.e. < p)\\n                    if iszero(and(lt(input0, p), lt(input1, p)))\\n                    {\\n                        revert(0x00, 0x00)\\n                    }\\n                }\\n\\n                endpoint := add(endpoint, 0x20)\\n                for {} lt(public_inputs, endpoint) { public_inputs := add(public_inputs, 0x20) }\\n                {\\n                    let input0 := calldataload(public_inputs)\\n\\n                    // validate public inputs are field elements (i.e. < p)\\n                    if iszero(lt(input0, p))\\n                    {\\n                        revert(0x00, 0x00)\\n                    }\\n        \\n                    valid := and(valid, lt(input0, p_clone))\\n                    let T0 := addmod(input0, gamma, p_clone)\\n                    numerator_value := mulmod(\\n                        numerator_value,\\n                        add(root_1, T0), // 0x05 = coset_generator0\\n                        p\\n                    )\\n                    denominator_value := mulmod(\\n                        denominator_value,\\n                        add(add(root_1, root_2), T0), // 0x0c = coset_generator7\\n                        p\\n                    )\\n                    root_1 := mulmod(root_1, work_root, p_clone)\\n                    root_2 := mulmod(root_2, work_root, p_clone)\\n                }\\n\\n                mstore(DELTA_NUMERATOR_LOC, numerator_value)\\n                mstore(DELTA_DENOMINATOR_LOC, denominator_value)\\n            }\\n\\n            /**\\n             * Compute lagrange poly and vanishing poly fractions\\n             */\\n            {\\n                let zeta := mload(C_ZETA_LOC)\\n\\n                // compute zeta^n, where n is a power of 2\\n                let vanishing_numerator := zeta\\n                {\\n                    // pow_small\\n                    let exponent := mload(N_LOC)\\n                    let count := 1\\n                    for {} lt(count, exponent) { count := add(count, count) }\\n                    {\\n                        vanishing_numerator := mulmod(vanishing_numerator, vanishing_numerator, p)\\n                    }\\n                }\\n                mstore(ZETA_POW_N_LOC, vanishing_numerator)\\n                vanishing_numerator := addmod(vanishing_numerator, sub(p, 1), p)\\n\\n                let accumulating_root := mload(OMEGA_INVERSE_LOC)\\n                let work_root := sub(p, accumulating_root)\\n                let domain_inverse := mload(DOMAIN_INVERSE_LOC)\\n\\n                let vanishing_denominator := addmod(zeta, work_root, p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, mulmod(work_root, accumulating_root, p), p), p)\\n\\n                work_root := mload(OMEGA_LOC)\\n\\n                let lagrange_numerator := mulmod(vanishing_numerator, domain_inverse, p)\\n                let l_start_denominator := addmod(zeta, sub(p, 1), p)\\n\\n                // l_end_denominator term contains a term \\\\omega^5 to cut out 5 roots of unity from vanishing poly\\n                accumulating_root := mulmod(work_root, work_root, p)\\n\\n                let l_end_denominator := addmod(\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(accumulating_root, accumulating_root, p),\\n                            work_root, p\\n                        ),\\n                        zeta, p\\n                    ),\\n                    sub(p, 1), p\\n                )\\n\\n            /**\\n             * Compute inversions using Montgomery's batch inversion trick\\n             */\\n                let accumulator := mload(DELTA_DENOMINATOR_LOC)\\n                let t0 := accumulator\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n                let t1 := accumulator\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n                let t2 := accumulator\\n                {\\n                    mstore(0, 0x20)\\n                    mstore(0x20, 0x20)\\n                    mstore(0x40, 0x20)\\n                    mstore(0x60, mulmod(accumulator, l_end_denominator, p))\\n                    mstore(0x80, sub(p, 2))\\n                    mstore(0xa0, p)\\n                    if iszero(staticcall(gas(), 0x05, 0x00, 0xc0, 0x00, 0x20))\\n                    {\\n                        mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                        mstore(0x04, 0x20)\\n                        mstore(0x24, 32)\\n                        mstore(0x44, \\\"PROOF_VERIFICATION_FAILED_TYPE_1\\\")\\n                        revert(0x00, 0x64)\\n                    }\\n                    accumulator := mload(0x00)\\n                }\\n\\n                t2 := mulmod(accumulator, t2, p)\\n                accumulator := mulmod(accumulator, l_end_denominator, p)\\n\\n                t1 := mulmod(accumulator, t1, p)\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n\\n                t0 := mulmod(accumulator, t0, p)\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n\\n                accumulator := mulmod(mulmod(accumulator, accumulator, p), mload(DELTA_DENOMINATOR_LOC), p)\\n\\n                mstore(PUBLIC_INPUT_DELTA_LOC, mulmod(mload(DELTA_NUMERATOR_LOC), accumulator, p))\\n                mstore(ZERO_POLY_LOC, mulmod(vanishing_numerator, t0, p))\\n                mstore(L_START_LOC, mulmod(lagrange_numerator, t1, p))\\n                mstore(L_END_LOC, mulmod(lagrange_numerator, t2, p))\\n            }\\n\\n            /**\\n             * COMPUTE CONSTANT TERM (r_0) OF LINEARISATION POLYNOMIAL\\n             */\\n            {\\n                let alpha := mload(C_ALPHA_LOC)\\n                let beta := mload(C_BETA_LOC)\\n                let gamma := mload(C_GAMMA_LOC)\\n                let r_0 := sub(p,\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(\\n                                add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA1_EVAL_LOC), p)),\\n                                add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA2_EVAL_LOC), p)),\\n                                p\\n                            ),\\n                            add(mload(W3_EVAL_LOC), gamma),\\n                            p\\n                        ),\\n                        mload(Z_OMEGA_EVAL_LOC),\\n                        p\\n                    )\\n                )\\n                // r_0 = -(\u0101 + \u03b2s\u0304_\u03c31 + \u03b3)( b\u0304 + \u03b2s\u0304_\u03c32 + \u03b3)(c\u0304 + \u03b3)z\u0304_\u03c9\\n                let alpha_sqr := mulmod(alpha, alpha, p)\\n                mstore(C_ALPHA_SQR_LOC, alpha_sqr)\\n                mstore(C_ARITHMETIC_ALPHA_LOC, mulmod(alpha_sqr, alpha_sqr, p))\\n\\n                mstore(R_ZERO_EVAL_LOC,\\n                            mulmod(\\n                                addmod(\\n                                    addmod(r_0, sub(p, mulmod(mload(L_START_LOC), alpha_sqr, p)), p),\\n                                    mulmod(\\n                                        mulmod(mload(L_END_LOC), alpha, p),\\n                                        addmod(mload(Z_OMEGA_EVAL_LOC), sub(p, mload(PUBLIC_INPUT_DELTA_LOC)), p), p\\n                                    ), p\\n                                ),\\n                                alpha, p\\n                            )\\n                        )\\n            }\\n\\n\\n            /**\\n             * GENERATE NU AND SEPARATOR CHALLENGES\\n             */\\n            {\\n                let current_challenge := mload(C_CURRENT_LOC)\\n                // get a calldata pointer that points to the start of the data we want to copy\\n                let calldata_ptr := add(calldataload(0x04), 0x24)\\n                // skip over the public inputs\\n                calldata_ptr := add(calldata_ptr, mul(mload(NUM_INPUTS_LOC), 0x20))\\n                // There are SEVEN G1 group elements added into the transcript in the `beta` round, that we need to skip over\\n                // W1, W2, W3 (W4), Z, T1, T2, T3, (T4)\\n                calldata_ptr := add(calldata_ptr, 0x1c0) // 7 * 0x40 = 0x1c0\\n\\n                mstore(0x00, current_challenge)\\n                calldatacopy(0x20, calldata_ptr, 0xc0) // 6 * 0x20 = 0xc0\\n                let challenge := keccak256(0x00, 0xe0) // hash length = 0xe0 (0x20 + num field elements), we include the previous challenge in the hash\\n\\n                mstore(C_V0_LOC, mod(challenge, p))\\n\\n                mstore(0x00, challenge)\\n                mstore8(0x20, 0x01)\\n                mstore(C_V1_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                mstore8(0x20, 0x02)\\n                mstore(C_V2_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                mstore8(0x20, 0x03)\\n                mstore(C_V3_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                mstore8(0x20, 0x04)\\n                mstore(C_V4_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                mstore8(0x20, 0x05)\\n                challenge := keccak256(0x00, 0x21)\\n                mstore(C_V5_LOC, mod(challenge, p))\\n\\n                // separator\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, mload(PI_Z_OMEGA_X_LOC))\\n\\n                mstore(C_U_LOC, mod(keccak256(0x00, 0xa0), p))\\n            }\\n\\n            // mstore(C_ALPHA_BASE_LOC, mload(C_ALPHA_LOC))\\n\\n            /**\\n             * COMPUTE LINEARISED OPENING TERMS\\n             */\\n            {\\n                // /**\\n                //  * COMPUTE GRAND PRODUCT OPENING GROUP ELEMENT\\n                //  */\\n                let beta := mload(C_BETA_LOC)\\n                let zeta := mload(C_ZETA_LOC)\\n                let gamma := mload(C_GAMMA_LOC)\\n                let alpha := mload(C_ALPHA_LOC)\\n                let beta_zeta := mulmod(beta, zeta, p)\\n\\n                let witness_term := addmod(mload(W1_EVAL_LOC), gamma, p)\\n                let partial_grand_product := addmod(beta_zeta, witness_term, p)\\n                let sigma_multiplier := addmod(mulmod(mload(SIGMA1_EVAL_LOC), beta, p), witness_term, p)\\n                witness_term := addmod(mload(W2_EVAL_LOC), gamma, p)\\n                sigma_multiplier := mulmod(sigma_multiplier, addmod(mulmod(mload(SIGMA2_EVAL_LOC), beta, p), witness_term, p), p)\\n                let k1_beta_zeta := mulmod(0x05, beta_zeta, p)\\n                //  partial_grand_product = mulmod( mulmod( partial_grand_product, w2 + k1.beta.zeta + gamma , p), k2.beta.zeta + gamma + w3, p)\\n                partial_grand_product := mulmod(\\n                    mulmod(\\n                        partial_grand_product,\\n                        addmod(k1_beta_zeta, witness_term, p), // w2 + k1.beta.zeta + gamma\\n                        p\\n                    ),\\n                    addmod(addmod(add(k1_beta_zeta, beta_zeta), gamma, p), mload(W3_EVAL_LOC), p), // k2.beta.zeta + gamma + w3 where k2 = k1+1\\n                    p\\n                )\\n\\n\\n                let linear_challenge := alpha // Owing to the simplified Plonk, nu =1, linear_challenge = nu * alpha = alpha\\n\\n\\n                mstore(0x00, mload(SIGMA3_X_LOC))\\n                mstore(0x20, mload(SIGMA3_Y_LOC))\\n                mstore(0x40, mulmod(\\n                    mulmod(\\n                        sub(p, mulmod(sigma_multiplier, mload(Z_OMEGA_EVAL_LOC), p)),\\n                        beta,\\n                        p\\n                    ),\\n                    linear_challenge,\\n                    p\\n                ))\\n\\n                // Validate Z\\n                let success\\n                {\\n                    let x := mload(Z_X_LOC)\\n                    let y := mload(Z_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                    mstore(0x60, x)\\n                    mstore(0x80, y)\\n                }\\n                mstore(0xa0, addmod(\\n                    mulmod(\\n                        addmod(partial_grand_product, mulmod(mload(L_START_LOC), mload(C_ALPHA_SQR_LOC), p), p),\\n                        linear_challenge,\\n                        p),\\n                    mload(C_U_LOC),\\n                    p\\n                ))\\n            // 0x00 = SIGMA3_X_LOC,\\n            // 0x20 = SIGMA3_Y_LOC,\\n            // 0x40 = \u2212(\u0101 + \u03b2s\u0304_\u03c31 + \u03b3)( b\u0304 + \u03b2s\u0304_\u03c32 + \u03b3)\u03b1\u03b2z\u0304_\u03c9,\\n            // 0x60 = Z_X_LOC,\\n            // 0x80 = Z_Y_LOC,\\n            // 0xa0 = (\u0101 + \u03b2z + \u03b3)( b\u0304 + \u03b2k_1 z + \u03b3)(c\u0304 + \u03b2k_2 z + \u03b3)\u03b1 + L_1(z)\u03b1^3 + u\\n                success := and(success, and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    // Why ACCUMULATOR_X_LOC := ACCUMULATOR_X_LOC + ACCUMULATOR2_X_LOC? Inner parenthesis is executed before?\\n                    and(\\n                        staticcall(gas(), 7, 0x60, 0x60, ACCUMULATOR_X_LOC, 0x40),\\n                        // [ACCUMULATOR_X_LOC, ACCUMULATOR_X_LOC + 0x40) = ((\u0101 + \u03b2z + \u03b3)( b\u0304 + \u03b2k_1 z + \u03b3)(c\u0304 + \u03b2k_2 z + \u03b3)\u03b1 + L_1(z)\u03b1^3 + u)*[z]_1\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                        // [ACCUMULATOR2_X_LOC, ACCUMULATOR2_X_LOC + 0x40) = \u2212(\u0101 + \u03b2s\u0304_\u03c31 + \u03b3)( b\u0304 + \u03b2s\u0304_\u03c32 + \u03b3)\u03b1\u03b2z\u0304_\u03c9 * [s_\u03c33]_1\\n                    )\\n                ))\\n\\n                mstore(GRAND_PRODUCT_SUCCESS_FLAG, success)\\n\\n            }\\n\\n            /**\\n             * COMPUTE ARITHMETIC SELECTOR OPENING GROUP ELEMENT\\n             */\\n            {\\n                let linear_challenge := mload(C_ARITHMETIC_ALPHA_LOC) // Owing to simplified Plonk, nu = 1,  linear_challenge = C_ARITHMETIC_ALPHA (= alpha^4)\\n\\n                let t1 := mulmod(mload(W1_EVAL_LOC), linear_challenge, p) // reuse this for QM scalar multiplier\\n                // Q1\\n                mstore(0x00, mload(Q1_X_LOC))\\n                mstore(0x20, mload(Q1_Y_LOC))\\n                mstore(0x40, t1)\\n\\n                // add Q1 scalar mul into grand product scalar mul\\n                // Observe that ACCUMULATOR_X_LOC and ACCUMULATOR2_X_LOC are 0x40 bytes apart. Below, ACCUMULATOR2_X_LOC\\n                // captures new terms Q1, Q2, and so on and they get accumulated to ACCUMULATOR_X_LOC\\n                let success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    // [ACCUMULATOR_X_LOC, ACCUMULATOR_X_LOC + 0x40) = ((\u0101 + \u03b2z + \u03b3)( b\u0304 + \u03b2k_1 z + \u03b3)(c\u0304 + \u03b2k_2 z + \u03b3)\u03b1 + L_1(z)\u03b1^3 + u)*[z]_1 \u2212(\u0101 + \u03b2s\u0304_\u03c31 + \u03b3)( b\u0304 + \u03b2s\u0304_\u03c32 + \u03b3)\u03b1\u03b2z\u0304_\u03c9 * [s_\u03c33]_1\\n                    staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    // [ACCUMULATOR2_X_LOC, ACCUMULATOR2_X_LOC + 0x40) = \u0101 * [q_L]_1\\n                )\\n\\n                // Q2\\n                mstore(0x00, mload(Q2_X_LOC))\\n                mstore(0x20, mload(Q2_Y_LOC))\\n                mstore(0x40, mulmod(mload(W2_EVAL_LOC), linear_challenge, p))\\n                success := and(\\n                    success,\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                // Q3\\n                mstore(0x00, mload(Q3_X_LOC))\\n                mstore(0x20, mload(Q3_Y_LOC))\\n                mstore(0x40, mulmod(mload(W3_EVAL_LOC), linear_challenge, p))\\n                success := and(\\n                    success,\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                // QM\\n                mstore(0x00, mload(QM_X_LOC))\\n                mstore(0x20, mload(QM_Y_LOC))\\n                mstore(0x40, mulmod(t1, mload(W2_EVAL_LOC), p))\\n                success := and(\\n                    success,\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                // QC\\n                mstore(0x00, mload(QC_X_LOC))\\n                mstore(0x20, mload(QC_Y_LOC))\\n                mstore(0x40, linear_challenge)\\n                success := and(\\n                    success,\\n                    and(\\n                        staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                mstore(ARITHMETIC_TERM_SUCCESS_FLAG, success)\\n            }\\n\\n             /**\\n             * COMPUTE BATCH OPENING COMMITMENT\\n             */\\n            {\\n                // previous scalar_multiplier = 1, z^n, z^2n\\n                // scalar_multiplier owing to the simplified Plonk = 1 * -Z_H(z), z^n * -Z_H(z), z^2n * -Z_H(z)\\n                // VALIDATE T1\\n                let success\\n                {\\n                    let x := mload(T1_X_LOC)\\n                    let y := mload(T1_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                    mstore(0x40, sub(p, mload(ZERO_POLY_LOC)))\\n                    // mstore(ACCUMULATOR2_X_LOC, x)\\n                    // mstore(ACCUMULATOR2_Y_LOC, y)\\n                }\\n                success := and(success,\\n                and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                ))\\n\\n                // VALIDATE T2\\n                let scalar_multiplier := mload(ZETA_POW_N_LOC)\\n                {\\n                    let x := mload(T2_X_LOC)\\n                    let y := mload(T2_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mulmod(scalar_multiplier, sub(p, mload(ZERO_POLY_LOC)), p))\\n\\n                success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                // VALIDATE T3\\n                {\\n                    let x := mload(T3_X_LOC)\\n                    let y := mload(T3_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mulmod(scalar_multiplier, mulmod(scalar_multiplier, sub(p, mload(ZERO_POLY_LOC)), p), p))\\n                success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                // VALIDATE W1\\n                {\\n                    let x := mload(W1_X_LOC)\\n                    let y := mload(W1_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mload(C_V0_LOC))\\n\\n                success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                // VALIDATE W2\\n                {\\n                    let x := mload(W2_X_LOC)\\n                    let y := mload(W2_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mload(C_V1_LOC))\\n                success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                // VALIDATE W3\\n                {\\n                    let x := mload(W3_X_LOC)\\n                    let y := mload(W3_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mload(C_V2_LOC))\\n                success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                mstore(0x00, mload(SIGMA1_X_LOC))\\n                mstore(0x20, mload(SIGMA1_Y_LOC))\\n                mstore(0x40, mload(C_V3_LOC))\\n                success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                mstore(0x00, mload(SIGMA2_X_LOC))\\n                mstore(0x20, mload(SIGMA2_Y_LOC))\\n                mstore(0x40, mload(C_V4_LOC))\\n                success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                mstore(BATCH_OPENING_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * COMPUTE BATCH EVALUATION SCALAR MULTIPLIER\\n             */\\n            {\\n                mstore(0x00, 0x01) // [1].x\\n                mstore(0x20, 0x02) // [1].y\\n                // Yul stack optimizer doing some work here...\\n                mstore(0x40, sub(p,\\n                    addmod(\\n                        mulmod(mload(C_U_LOC), mload(Z_OMEGA_EVAL_LOC), p),\\n                        addmod(\\n                            sub(p, mload(R_ZERO_EVAL_LOC)), // Change owing to the simplified Plonk\\n                                addmod(\\n                                    mulmod(mload(C_V4_LOC), mload(SIGMA2_EVAL_LOC), p),\\n                                    addmod(\\n                                        mulmod(mload(C_V3_LOC), mload(SIGMA1_EVAL_LOC), p),\\n                                        addmod(\\n                                            mulmod(mload(C_V2_LOC), mload(W3_EVAL_LOC), p),\\n                                            addmod(\\n                                                mulmod(mload(C_V1_LOC), mload(W2_EVAL_LOC), p),\\n                                                mulmod(mload(C_V0_LOC), mload(W1_EVAL_LOC), p),\\n                                                p\\n                                            ),\\n                                            p\\n                                        ),\\n                                        p\\n                                    ),\\n                                    p\\n                                ),\\n                                p\\n                            ),\\n                            p\\n                        )\\n                    )\\n                )\\n\\n                let success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                )\\n                mstore(OPENING_COMMITMENT_SUCCESS_FLAG, success)\\n            }\\n\\n             /**\\n             * PERFORM PAIRING PREAMBLE\\n             */\\n            {\\n                let u := mload(C_U_LOC)\\n                let zeta := mload(C_ZETA_LOC)\\n                let success\\n                // VALIDATE PI_Z\\n                {\\n                    let x := mload(PI_Z_X_LOC)\\n                    let y := mload(PI_Z_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                // compute zeta.[PI_Z] and add into accumulator\\n                mstore(0x40, zeta)\\n                success := and(success, and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40),\\n                    staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                ))\\n\\n                // VALIDATE PI_Z_OMEGA\\n                {\\n                    let x := mload(PI_Z_OMEGA_X_LOC)\\n                    let y := mload(PI_Z_OMEGA_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                // compute u.zeta.omega.[PI_Z_OMEGA] and add into accumulator\\n                mstore(0x40, mulmod(mulmod(u, zeta, p), mload(OMEGA_LOC), p))\\n                success := and(\\n                    staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, PAIRING_RHS_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40)\\n                    )\\n                )\\n\\n                mstore(0x00, mload(PI_Z_X_LOC))\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_OMEGA_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, u)\\n                success := and(\\n                    staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40),\\n                    and(\\n                        success,\\n                        staticcall(gas(), 7, 0x40, 0x60, 0x40, 0x40)\\n                    )\\n                )\\n                // negate lhs y-coordinate\\n                mstore(PAIRING_LHS_Y_LOC, sub(q, mload(PAIRING_LHS_Y_LOC)))\\n\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC)\\n                {\\n                    // VALIDATE RECURSIVE P1\\n                    {\\n                        let x := mload(RECURSIVE_P1_X_LOC)\\n                        let y := mload(RECURSIVE_P1_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n\\n                    // compute u.u.[recursive_p1] and write into 0x60\\n                    mstore(0x40, mulmod(u, u, p))\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x60, 0x40))\\n                    // VALIDATE RECURSIVE P2\\n                    {\\n                        let x := mload(RECURSIVE_P2_X_LOC)\\n                        let y := mload(RECURSIVE_P2_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n                    // compute u.u.[recursive_p2] and write into 0x00\\n                    // 0x40 still contains u*u\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x00, 0x40))\\n\\n                    // compute u.u.[recursiveP1] + rhs and write into rhs\\n                    mstore(0xa0, mload(PAIRING_RHS_X_LOC))\\n                    mstore(0xc0, mload(PAIRING_RHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x60, 0x80, PAIRING_RHS_X_LOC, 0x40))\\n\\n                    // compute u.u.[recursiveP2] + lhs and write into lhs\\n                    mstore(0x40, mload(PAIRING_LHS_X_LOC))\\n                    mstore(0x60, mload(PAIRING_LHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\\n                }\\n\\n                if iszero(success)\\n                {\\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                    mstore(0x04, 0x20)\\n                    mstore(0x24, 32)\\n                    mstore(0x44, \\\"PROOF_VERIFICATION_FAILED_TYPE_2\\\")\\n                    revert(0x00, 0x64)\\n                }\\n                mstore(PAIRING_PREAMBLE_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * PERFORM PAIRING\\n             */\\n            {\\n                // rhs paired with [1]_2\\n                // lhs paired with [x]_2\\n\\n                mstore(0x00, mload(PAIRING_RHS_X_LOC))\\n                mstore(0x20, mload(PAIRING_RHS_Y_LOC))\\n                mstore(0x40, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2) // this is [1]_2\\n                mstore(0x60, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\\n                mstore(0x80, 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\\n                mstore(0xa0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\\n\\n                mstore(0xc0, mload(PAIRING_LHS_X_LOC))\\n                mstore(0xe0, mload(PAIRING_LHS_Y_LOC))\\n                mstore(0x100, mload(G2X_X0_LOC))\\n                mstore(0x120, mload(G2X_X1_LOC))\\n                mstore(0x140, mload(G2X_Y0_LOC))\\n                mstore(0x160, mload(G2X_Y1_LOC))\\n\\n                let success := staticcall(\\n                    gas(),\\n                    8,\\n                    0x00,\\n                    0x180,\\n                    0x00,\\n                    0x20\\n                )\\n                mstore(PAIRING_SUCCESS_FLAG, success)\\n                mstore(RESULT_FLAG, mload(0x00))\\n            }\\n            if iszero(and(\\n                and(\\n                    and(\\n                        and(\\n                            and(\\n                                and(\\n                                    mload(PAIRING_SUCCESS_FLAG),\\n                                    mload(RESULT_FLAG)\\n                                ),\\n                                mload(PAIRING_PREAMBLE_SUCCESS_FLAG)\\n                            ),\\n                            mload(OPENING_COMMITMENT_SUCCESS_FLAG)\\n                        ),\\n                        mload(BATCH_OPENING_SUCCESS_FLAG)\\n                    ),\\n                    mload(ARITHMETIC_TERM_SUCCESS_FLAG)\\n                ),\\n                mload(GRAND_PRODUCT_SUCCESS_FLAG)\\n            ))\\n            {\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x04, 0x20)\\n                mstore(0x24, 32)\\n                mstore(0x44, \\\"PROOF_VERIFICATION_FAILED_TYPE_3\\\")\\n                revert(0x00, 0x64)\\n            }\\n            {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20) // Proof succeeded!\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/VerificationKey.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {StandardTypes} from '../cryptography/StandardTypes.sol';\\n\\n// Placeholder VK\\nlibrary VerificationKey {\\n    function get_verification_key() external pure returns (StandardTypes.VerificationKey memory) {\\n        StandardTypes.VerificationKey memory vk;\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/cryptography/StandardTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\n/**\\n * @title Bn254Crypto library used for the fr, g1 and g2 point types\\n * @dev Used to manipulate fr, g1, g2 types, perform modular arithmetic on them and call\\n * the precompiles add, scalar mul and pairing\\n *\\n * Notes on optimisations\\n * 1) Perform addmod, mulmod etc. in assembly - removes the check that Solidity performs to confirm that\\n * the supplied modulus is not 0. This is safe as the modulus's used (r_mod, q_mod) are hard coded\\n * inside the contract and not supplied by the user\\n */\\nlibrary StandardTypes {\\n    uint256 internal constant PROGRAM_WIDTH = 3;\\n    uint256 internal constant NUM_NU_CHALLENGES = 6;\\n\\n    uint256 internal constant coset_generator0 = 0x0000000000000000000000000000000000000000000000000000000000000005;\\n    uint256 internal constant coset_generator1 = 0x0000000000000000000000000000000000000000000000000000000000000006;\\n    uint256 internal constant coset_generator2 = 0x0000000000000000000000000000000000000000000000000000000000000007;\\n\\n    // TODO: add external_coset_generator() method to compute this\\n    uint256 internal constant coset_generator7 = 0x000000000000000000000000000000000000000000000000000000000000000c;\\n\\n    struct G1Point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    // G2 group element where x \\\\in Fq2 = x0 * z + x1\\n    struct G2Point {\\n        uint256 x0;\\n        uint256 x1;\\n        uint256 y0;\\n        uint256 y1;\\n    }\\n\\n    // N>B. Do not re-order these fields! They must appear in the same order as they\\n    // appear in the proof data\\n    struct Proof {\\n        G1Point W1;\\n        G1Point W2;\\n        G1Point W3;\\n        G1Point Z;\\n        G1Point T1;\\n        G1Point T2;\\n        G1Point T3;\\n        uint256 w1;\\n        uint256 w2;\\n        uint256 w3;\\n        uint256 sigma1;\\n        uint256 sigma2;\\n        //    uint256 linearization_polynomial;\\n        uint256 grand_product_at_z_omega;\\n        G1Point PI_Z;\\n        G1Point PI_Z_OMEGA;\\n        G1Point recursive_P1;\\n        G1Point recursive_P2;\\n        uint256 r_0; // Changes owing to the simplified Plonk\\n    }\\n\\n    struct ChallengeTranscript {\\n        uint256 alpha_base;\\n        uint256 alpha;\\n        uint256 zeta;\\n        uint256 beta;\\n        uint256 gamma;\\n        uint256 u;\\n        uint256 v0;\\n        uint256 v1;\\n        uint256 v2;\\n        uint256 v3;\\n        uint256 v4;\\n        uint256 v5;\\n        uint256 v6;\\n        // uint256 v7;\\n    }\\n\\n    struct VerificationKey {\\n        uint256 circuit_size;\\n        uint256 num_inputs;\\n        uint256 work_root;\\n        uint256 domain_inverse;\\n        uint256 work_root_inverse;\\n        G1Point Q1;\\n        G1Point Q2;\\n        G1Point Q3;\\n        G1Point QM;\\n        G1Point QC;\\n        G1Point SIGMA1;\\n        G1Point SIGMA2;\\n        G1Point SIGMA3;\\n        bool contains_recursive_proof;\\n        uint256 recursive_proof_indices;\\n        G2Point g2_x;\\n        // zeta challenge raised to the power of the circuit size.\\n        // Not actually part of the verification key, but we put it here to prevent stack depth errors\\n        uint256 zeta_pow_n;\\n    }\\n}\\n\\n/**\\n\\n    ### MEMORY LAYOUT\\n\\n    0x00 - 0x200 RESERVED FOR SCRATCH SPACE\\n\\n    0x200 - 0x600 RESERVED FOR VERIFICATION KEY\\n\\n    0x600 - 0x900 RESERVED FOR LOCAL VARIABLES\\n\\n    ### VERIFICATION KEY ###\\n    ### ALL LOCALTIONS ARE RELATIVE TO THE START OF THIS BLOCK IN MEMORY (0x200)\\n\\n    0x00          : n\\n    0x20          : num_inputs\\n    0x40          : omega\\n    0x60          : n^{-1}\\n    0x80          : omega^{-1}\\n    0xa0 - 0xe0   : Q1\\n    0xe0 - 0x120  : Q2\\n    0x120 - 0x160 : Q3\\n    0x160 - 0x1a0 : QM\\n    0x1a0 - 0x1e0 : QC\\n    0x1e0 - 0x220 : SIGMA1\\n    0x220 - 0x260 : SIGMA2\\n    0x260 - 0x2a0 : SIGMA3\\n    0x2a0 - 0x2c0 : contains_recursive_proof\\n    0x2c0 - 0x340 : G2_x ([x]_2)\\n\\n    ### LOCAL VARIABLES ###\\n    ### ALL LOCALTIONS ARE RELATIVE TO THE START OF THIS BLOCK IN MEMORY (0x200)\\n\\n    0x00  : zeta_pow_n\\n    0x20  : quotient_poly_eval\\n    0x40  : public_input_delta_numerator\\n    0x60  : public_input_delta_denominator\\n    0x80  : vanishing_numerator\\n    0xa0  : vanishing_denominator\\n    0xc0  : lagrange_numerator\\n    0xe0  : l_start_denominator\\n    0x100 : l_end_denominator\\n    0x120 : zero_poly_eval\\n    0x140 : public_input_delta\\n    0x160 : l_start\\n    0x180 : l_end\\n    0x200 : p\\n    0x220 : proof_calldata_ptr\\n\\n    ### PROOF ###\\n\\n    0x00  - 0x40  : W1\\n    0x40  - 0x80  : W2\\n    0x80  - 0xc0  : W3\\n    0xc0  - 0x100 : Z\\n    0x100 - 0x140 : T1\\n    0x140 - 0x180 : T2\\n    0x180 - 0x1c0 : T3\\n    0x1c0 - 0x200 : w1\\n    0x200 - 0x220 : w2\\n    0x220 - 0x240 : w3\\n    0x240 - 0x260 : sigma1\\n    0x260 - 0x280 : sigma2\\n    0x280 - 0x2a0 : r\\n    0x2a0 - 0x2c0 : z_omega\\n    0x2c0 - 0x300 : PI_Z\\n    0x300 - 0x340 : PI_Z_OMEGA\\n    0x340 - 0x380 : RECURSIVE_P1\\n    0x380 - 0x3c0 : RECURSIVE_P2\\n */\\n\"\r\n    },\r\n    \"contracts/verifier/keys/VerificationKey28x32.sol\": {\r\n      \"content\": \"// Verification Key Hash: 231a6b3ded1c9472f543428e5fa1b7dd085d852173f37b4659308745c9e930e6\\n// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {StandardTypes} from '../cryptography/StandardTypes.sol';\\n\\nlibrary VerificationKey28x32 {\\n\\n    function get_verification_key() external pure returns (StandardTypes.VerificationKey memory) {\\n        StandardTypes.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 8388608) // vk.circuit_size\\n            mstore(add(vk, 0x20), 17) // vk.num_inputs\\n            mstore(add(vk, 0x40),0x0210fe635ab4c74d6b7bcf70bc23a1395680c64022dd991fb54d4506ab80c59d) // vk.work_root\\n            mstore(add(vk, 0x60),0x30644e121894ba67550ff245e0f5eb5a25832df811e8df9dd100d30c2c14d821) // vk.domain_inverse\\n            mstore(add(vk, 0x80),0x2165a1a5bda6792b1dd75c9f4e2b8e61126a786ba1a6eadf811b03e7d69ca83b) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x0f7c715011823362f824b9de259a685032eedb928431724439a567967852d773)//vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x17ec42a324359512a7d093faa7e55103b1f017af1bfaa5e1ccd31cc9e4ff8df0)\\n            mstore(mload(add(vk, 0xc0)), 0x12bba50d7bc3e87e00bd3ce419001f3b2c59201b5ddf8cd1bba70f74061c7e7b)//vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x2c3cd5dbb0d5a28b93f57660812ad5ae468aa908c5cf3ec3499973af026d9e2a)\\n            mstore(mload(add(vk, 0xe0)), 0x07c448ca9631b9d24fc45d555f1b1952134eaf083c3bd46a000fcf5434a94478)//vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x0e18227b6c1a461c1cbb59826cac7ebabe89e6490d80312be1504d0f7fb98059)\\n            mstore(mload(add(vk, 0x100)), 0x24a14b8c3bc0ee2a31a5a8bb1c69a1519a814de7c78cb5fe3248b1717893e7f8)//vk.QM\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x1abd8e73735327575cec64e8d3c20fe5ae58f23468478a9dc6aee652332ed569)\\n            mstore(mload(add(vk, 0x120)), 0x1531778c4bbda77a659dd68bf49102ceb1ab6fbd96fd5cc2f7f335e3c1ec2ce5)//vk.QC\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x166f3cd25cc14370885bf52637ff5dc382c8a6243f552cfb96a09a64f314631f)\\n            mstore(mload(add(vk, 0x140)), 0x289dcb3bb09ce8d1a5c6d08cdf87ba9fc0f22ea255cf644523a602e6d3ae348e)//vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x2d21049d7f8b99c666d353e6f7101663ed09b4877f0a829d275bb83c223d1076)\\n            mstore(mload(add(vk, 0x160)), 0x0d4e31a8d510770f6912e7ee0f7454ecaf51b4df1c5f5865e0017023eab933c8)//vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x0f974eb06e1bae83bf339bc7d15b5ea18d826aa4c877ca1b63317e2a8debe7d1)\\n            mstore(mload(add(vk, 0x180)), 0x2d1d6ae2a57defc6f3a789129f67f9c9969961b8642a92b91a9bdc0afb8b7f99)//vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x300c3f15de1f550c772a7306a3a7e491b84ec7e7a9d4601c8b88107eff4f45ee)\\n            mstore(add(vk, 0x1a0), 0x01) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x1c0), 1) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x1e0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x1e0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x1e0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/VerificationKey1x1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {StandardTypes} from '../cryptography/StandardTypes.sol';\\n\\nlibrary VerificationKey1x1 {\\n    function get_verification_key() external pure returns (StandardTypes.VerificationKey memory) {\\n        StandardTypes.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 8388608) // vk.circuit_size\\n            mstore(add(vk, 0x20), 17) // vk.num_inputs\\n            mstore(add(vk, 0x40), 0x0210fe635ab4c74d6b7bcf70bc23a1395680c64022dd991fb54d4506ab80c59d) // vk.work_root\\n            mstore(add(vk, 0x60), 0x30644e121894ba67550ff245e0f5eb5a25832df811e8df9dd100d30c2c14d821) // vk.domain_inverse\\n            mstore(add(vk, 0x80), 0x2165a1a5bda6792b1dd75c9f4e2b8e61126a786ba1a6eadf811b03e7d69ca83b) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x0f7c715011823362f824b9de259a685032eedb928431724439a567967852d773) //vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x17ec42a324359512a7d093faa7e55103b1f017af1bfaa5e1ccd31cc9e4ff8df0)\\n            mstore(mload(add(vk, 0xc0)), 0x3010206be637307bc068ce5169be29f803e7fd6c2b69f653ca3b745864d30996) //vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x0de1236425db4e2287118dec6d53937eb1cb8d3b4a0e3816ef3d9c61aa394cf0)\\n            mstore(mload(add(vk, 0xe0)), 0x07c448ca9631b9d24fc45d555f1b1952134eaf083c3bd46a000fcf5434a94478) //vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x0e18227b6c1a461c1cbb59826cac7ebabe89e6490d80312be1504d0f7fb98059)\\n            mstore(mload(add(vk, 0x100)), 0x24a14b8c3bc0ee2a31a5a8bb1c69a1519a814de7c78cb5fe3248b1717893e7f8) //vk.QM\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x1abd8e73735327575cec64e8d3c20fe5ae58f23468478a9dc6aee652332ed569)\\n            mstore(mload(add(vk, 0x120)), 0x1531778c4bbda77a659dd68bf49102ceb1ab6fbd96fd5cc2f7f335e3c1ec2ce5) //vk.QC\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x166f3cd25cc14370885bf52637ff5dc382c8a6243f552cfb96a09a64f314631f)\\n            mstore(mload(add(vk, 0x140)), 0x289dcb3bb09ce8d1a5c6d08cdf87ba9fc0f22ea255cf644523a602e6d3ae348e) //vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x2d21049d7f8b99c666d353e6f7101663ed09b4877f0a829d275bb83c223d1076)\\n            mstore(mload(add(vk, 0x160)), 0x0d4e31a8d510770f6912e7ee0f7454ecaf51b4df1c5f5865e0017023eab933c8) //vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x0f974eb06e1bae83bf339bc7d15b5ea18d826aa4c877ca1b63317e2a8debe7d1)\\n            mstore(mload(add(vk, 0x180)), 0x2d1d6ae2a57defc6f3a789129f67f9c9969961b8642a92b91a9bdc0afb8b7f99) //vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x300c3f15de1f550c772a7306a3a7e491b84ec7e7a9d4601c8b88107eff4f45ee)\\n            mstore(add(vk, 0x1a0), 0x01) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x1c0), 1) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x1e0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x1e0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x1e0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/MockVerificationKey.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {StandardTypes} from '../cryptography/StandardTypes.sol';\\n\\nlibrary MockVerificationKey {\\n    function get_verification_key() external pure returns (StandardTypes.VerificationKey memory) {\\n        StandardTypes.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 8192) // vk.circuit_size\\n            mstore(add(vk, 0x20), 17) // vk.num_inputs\\n            mstore(add(vk, 0x40), 0x006fab49b869ae62001deac878b2667bd31bf3e28e3a2d764aa49b8d9bbdd310) // vk.work_root\\n            mstore(add(vk, 0x60), 0x3062cb506d9a969cb702833453cd4c52654aa6a93775a2c5bf57d68443608001) // vk.domain_inverse\\n            mstore(add(vk, 0x80), 0x1670ed58bfac610408e124db6a1cb6c8c8df74fa978188ca3b0b205aabd95dc9) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x0be8a2b6819e5ed4fd15bb5cb484086e452297e53e83878519ea8dd5f7abbf2c) //vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x295a1fca477ff3f65be1f71f2f4fc2df95cb23bf05de6b9cd2779348570c9236)\\n            mstore(mload(add(vk, 0xc0)), 0x0b051497e878ea0d54f0004fec15b1c6d3be2d8872a688e39d43b61499942094) //vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x19ae5022420456ca185141db41f6a64ed82b8a2217fd9d50f6dddb0dab725f45)\\n            mstore(mload(add(vk, 0xe0)), 0x043a124edd1942909fbd2ba016716b174326462cf54f8c20e567eb39b858e83a) //vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x0d50bd8e2c83217fdbf3c150d51f3b9e4baa4b1dc3ee57e305d3896a53bc3562)\\n            mstore(mload(add(vk, 0x100)), 0x137d4c5f8e111374a1b162a273b058ac41c42735a7f26910443e48796206171c) //vk.QM\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x047e986785533350b315c24a1e029349870e22258c4c1293f7094a6376c1ab12)\\n            mstore(mload(add(vk, 0x120)), 0x06a31854eac27a0a9b65f9b098d3a47ca10ee3d5ae1c178d9704e94c8b889f4b) //vk.QC\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x08d9b7926623abaab8b5decac0415b3849c112d3396b5296ee3a7a0a34285469)\\n            mstore(mload(add(vk, 0x140)), 0x095f1b2a902ebe4a8351574b3ccbf9a2024b0e56b3d0cbe781b9244505d52894) //vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x1314e8bb583f3166f76f0d1e1ce9f964c06d88e6bbecfc64ce38aab8df55f1fc)\\n            mstore(mload(add(vk, 0x160)), 0x0db72f65f3a6cf58085528d93d19b58ea26919ac206b240822616015185d2f3d) //vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x2b3c4c58a3cc75c104c9f0f5af5218616b71d7430df19b2a1bd5f4ecc0dac64e)\\n            mstore(mload(add(vk, 0x180)), 0x09342cc8fc28c2fd14f3a3219c311575d4ab9adeba8385a53f201d8afba4312d) //vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x1156442cf1bd1cd4d4583d3b21a054b3171b5452e4fa96a2ddcd769004ecd3d8)\\n            mstore(add(vk, 0x1a0), 0x00) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x1c0), 0) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x1e0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x1e0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x1e0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/MockVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {IVerifier} from '../interfaces/IVerifier.sol';\\n\\n/**\\n * @title Plonk proof verification contract\\n * @dev Warning: do not deploy in real environments, for testing only\\n * Mocks the role of a PLONK verifier contract\\n */\\ncontract MockVerifier is IVerifier {\\n    /**\\n     * @dev Mock verify a Plonk proof\\n     */\\n    function verify(bytes memory, uint256) external pure override returns (bool) {\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/ERC20Mintable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\n\\n/**\\n * @dev Warning: do not deploy in real environments, for testing only\\n * ERC20 contract where anybody is able to mint\\n */\\ncontract ERC20Mintable is ERC20 {\\n    uint8 public asset_decimals = 18;\\n\\n    constructor(string memory symbol_) ERC20(symbol_, symbol_) {}\\n\\n    function mint(address _to, uint256 _value) public returns (bool) {\\n        _mint(_to, _value);\\n        return true;\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return asset_decimals;\\n    }\\n\\n    function setDecimals(uint8 _decimals) external {\\n        asset_decimals = _decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/ERC20Reenter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {ERC20Mintable} from './ERC20Mintable.sol';\\n\\nimport {IRollupProcessor} from '../interfaces/IRollupProcessor.sol';\\n\\n/**\\n * @dev Warning: do not deploy in real environments, for testing only\\n * ERC20 contract where the transfer() fn will always throw\\n */\\ncontract ERC20Reenter is ERC20Mintable {\\n    error LOCKED_NO_REENTER();\\n\\n    constructor() ERC20Mintable('TEST') {}\\n\\n    function transferFrom(\\n        address,\\n        address to,\\n        uint256\\n    ) public override returns (bool) {\\n        IRollupProcessor(to).processRollup('', '');\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {ERC20Mintable} from './ERC20Mintable.sol';\\n\\n/**\\n * @dev Warning: do not deploy in real environments, for testing only\\n * ERC20 contract which has permit implementation and is mintable\\n */\\ncontract ERC20Permit is ERC20Mintable {\\n    bytes32 public DOMAIN_SEPARATOR;\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint256) public nonces;\\n\\n    // bytes32 public constant PERMIT_TYPEHASH_NON_STANDARD = keccak256(\\\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH_NON_STANDARD =\\n        0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\\n\\n    constructor(string memory symbol_) ERC20Mintable(symbol_) {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\\n                keccak256(bytes(name())),\\n                keccak256(bytes('1')),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        require(deadline >= block.timestamp, 'EXPIRED');\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                '\\\\x19\\\\x01',\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNATURE');\\n        _approve(owner, spender, value);\\n    }\\n\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                '\\\\x19\\\\x01',\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(PERMIT_TYPEHASH_NON_STANDARD, holder, spender, nonce, expiry, allowed))\\n            )\\n        );\\n\\n        require(holder != address(0), 'INVALID_HOLDER');\\n        require(holder == ecrecover(digest, v, r, s), 'INVALID_SIGNATURE');\\n        require(expiry == 0 || expiry >= block.timestamp, 'EXPIRED');\\n        require(nonce == nonces[holder]++, 'INVALID_NONCE');\\n        uint256 value = allowed ? (2**256) - 1 : 0;\\n        _approve(holder, spender, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/ERC20FaultyTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {ERC20Mintable} from './ERC20Mintable.sol';\\n\\n/**\\n * @dev Warning: do not deploy in real environments, for testing only\\n * ERC20 contract where the transfer() fn will always throw\\n */\\ncontract ERC20FaultyTransfer is ERC20Mintable {\\n    constructor() ERC20Mintable('TEST') {}\\n\\n    function transfer(address, uint256) public pure override returns (bool) {\\n        require(true == false, 'ERC20FaultyTransfer: FAILED');\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/DummyDefiBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IDefiBridge} from '../interfaces/IDefiBridge.sol';\\nimport {AztecTypes} from '../AztecTypes.sol';\\n\\n/**\\n * @dev Warning: do not deploy in real environments, for testing only\\n */\\ncontract DummyDefiBridge is IDefiBridge {\\n    address public immutable rollupProcessor;\\n    uint256 immutable outputValueEth;\\n    uint256 immutable outputValueToken;\\n    uint256 immutable outputVirtualValueA;\\n    uint256 immutable outputVirtualValueB;\\n\\n    receive() external payable {}\\n\\n    constructor(\\n        address _rollupProcessor,\\n        uint256 _outputValueEth,\\n        uint256 _outputValueToken,\\n        uint256 _outputVirtualValueA,\\n        uint256 _outputVirtualValueB\\n    ) {\\n        rollupProcessor = _rollupProcessor;\\n        outputValueEth = _outputValueEth;\\n        outputValueToken = _outputValueToken;\\n        outputVirtualValueA = _outputVirtualValueA;\\n        outputVirtualValueB = _outputVirtualValueB;\\n    }\\n\\n    function convert(\\n        AztecTypes.AztecAsset memory, /*inputAssetA*/\\n        AztecTypes.AztecAsset memory, /*inputAssetB*/\\n        AztecTypes.AztecAsset memory outputAssetA,\\n        AztecTypes.AztecAsset memory outputAssetB,\\n        uint256, /*totalInputValue*/\\n        uint256 interactionNonce,\\n        uint64 auxData,\\n        address\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            bool\\n        )\\n    {\\n        bool isAsync = auxData > 0;\\n        if (isAsync) {\\n            return (0, 0, isAsync);\\n        }\\n\\n        uint256 returnValueA = approveTransfer(outputAssetA, outputVirtualValueA, interactionNonce);\\n        uint256 returnValueB = approveTransfer(outputAssetB, outputVirtualValueB, interactionNonce);\\n        return (returnValueA, returnValueB, isAsync);\\n    }\\n\\n    function canFinalise(\\n        uint256 /*interactionNonce*/\\n    ) external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    function finalise(\\n        AztecTypes.AztecAsset memory, /*inputAssetA*/\\n        AztecTypes.AztecAsset memory, /*inputAssetB*/\\n        AztecTypes.AztecAsset memory outputAssetA,\\n        AztecTypes.AztecAsset memory outputAssetB,\\n        uint256 interactionNonce,\\n        uint64\\n    )\\n        external\\n        payable\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            bool\\n        )\\n    {\\n        require(msg.sender == rollupProcessor, 'invalid sender!');\\n\\n        uint256 returnValueA = approveTransfer(outputAssetA, outputVirtualValueA, interactionNonce);\\n        uint256 returnValueB = approveTransfer(outputAssetB, outputVirtualValueB, interactionNonce);\\n        return (returnValueA, returnValueB, true);\\n    }\\n\\n    function approveTransfer(\\n        AztecTypes.AztecAsset memory asset,\\n        uint256 virtualValue,\\n        uint256 interactionNonce\\n    ) internal returns (uint256 returnValue) {\\n        if (asset.assetType == AztecTypes.AztecAssetType.VIRTUAL) {\\n            returnValue = virtualValue;\\n        } else if (asset.assetType == AztecTypes.AztecAssetType.ETH) {\\n            returnValue = outputValueEth;\\n            bytes memory payload = abi.encodeWithSignature('receiveEthFromBridge(uint256)', interactionNonce);\\n            (bool success, ) = address(rollupProcessor).call{value: outputValueEth}(payload);\\n            assembly {\\n                if iszero(success) {\\n                    returndatacopy(0x00, 0x00, returndatasize())\\n                    revert(0x00, returndatasize())\\n                }\\n            }\\n        } else if (asset.assetType == AztecTypes.AztecAssetType.ERC20) {\\n            returnValue = outputValueToken;\\n            IERC20(asset.erc20Address).approve(rollupProcessor, outputValueToken);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 5000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_escapeBlockLowerBound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_escapeBlockUpperBound\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ARRAY_OVERFLOW\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BRIDGE_ID_IS_INCONSISTENT\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAssetId\",\"type\":\"uint256\"}],\"name\":\"BRIDGE_WITH_IDENTICAL_INPUT_ASSETS\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAssetId\",\"type\":\"uint256\"}],\"name\":\"BRIDGE_WITH_IDENTICAL_OUTPUT_ASSETS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DEPOSIT_TOKENS_WRONG_PAYMENT_TYPE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ENCODING_BYTE_INVALID\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"providedIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedIndex\",\"type\":\"uint256\"}],\"name\":\"INCORRECT_DATA_START_INDEX\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"providedDefiInteractionHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"expectedDefiInteractionHash\",\"type\":\"bytes32\"}],\"name\":\"INCORRECT_PREVIOUS_DEFI_INTERACTION_HASH\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"oldStateHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"newStateHash\",\"type\":\"bytes32\"}],\"name\":\"INCORRECT_STATE_HASH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_DEPOSIT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_ETH_PAYMENT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INSUFFICIENT_TOKEN_APPROVAL\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_ASSET_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_ASSET_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_BRIDGE_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_BRIDGE_ID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_LINKED_BRIDGE_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_LINKED_TOKEN_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_PROVIDER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_ROLLUP_TOPOLOGY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_SIGNATURE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LOCKED_NO_REENTER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MSG_VALUE_WRONG_AMOUNT\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"outputValue\",\"type\":\"uint256\"}],\"name\":\"NONZERO_OUTPUT_VALUE_ON_NOT_USED_ASSET\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NOT_PAUSED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PAUSED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PROOF_VERIFICATION_FAILED\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PUBLIC_INPUTS_HASH_VERIFICATION_FAILED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SIGNATURE_ADDRESS_IS_ZERO\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SIGNATURE_RECOVERY_FAILED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"THIRD_PARTY_CONTRACTS_FLAG_NOT_SET\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WITHDRAW_TO_ZERO_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_TOTAL_INPUT_VALUE\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetGasLimit\",\"type\":\"uint256\"}],\"name\":\"AssetAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bridgeId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalInputValue\",\"type\":\"uint256\"}],\"name\":\"AsyncDefiBridgeProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bridgeAddressId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bridgeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bridgeGasLimit\",\"type\":\"uint256\"}],\"name\":\"BridgeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"bridgeId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalInputValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalOutputValueA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalOutputValueB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"errorReason\",\"type\":\"bytes\"}],\"name\":\"DefiBridgeProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositValue\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rollupId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chunk\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalChunks\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"OffchainData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rollupId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"nextExpectedDefiHashes\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RollupProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"providerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"name\":\"RollupProviderUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"verifierAddress\",\"type\":\"address\"}],\"name\":\"VerifierUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"errorReason\",\"type\":\"bytes\"}],\"name\":\"WithdrawError\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EMERGENCY_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OWNER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowThirdPartyContracts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proofHash\",\"type\":\"bytes32\"}],\"name\":\"approveProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assetGasLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"asyncDefiInteractionHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bridgeGasLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defiBridgeProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"defiInteractionHashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"proofHash\",\"type\":\"bytes32\"}],\"name\":\"depositPendingFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"depositorAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"proofHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"depositPendingFundsPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"depositorAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"proofHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"depositPendingFundsPermitNonStandard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"depositProofApprovals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"escapeBlockLowerBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"escapeBlockUpperBound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ethPayments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAsyncDefiInteractionHashes\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"res\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAsyncDefiInteractionHashesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bridgeAddressId\",\"type\":\"uint256\"}],\"name\":\"getBridgeGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDataSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dataSize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDefiInteractionHashes\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"res\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDefiInteractionHashesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEscapeHatchStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementationVersion\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingDefiInteractionHashesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"getSupportedAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupportedAssets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupportedAssetsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bridgeAddressId\",\"type\":\"uint256\"}],\"name\":\"getSupportedBridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupportedBridges\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupportedBridgesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_verifierAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defiBridgeProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contractOwner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_initDataRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_initNullRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_initRootRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_initDatasize\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"_allowThirdPartyContracts\",\"type\":\"bool\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rollupId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chunk\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalChunks\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"offchainData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingDefiInteractions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bridgeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInputValue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prevDefiInteractionsHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"interactionNonce\",\"type\":\"uint256\"}],\"name\":\"processAsyncDefiInteraction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"processRollup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"interactionNonce\",\"type\":\"uint256\"}],\"name\":\"receiveEthFromBridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rollupProviders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollupStateHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setAllowThirdPartyContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"defiBridgeProxyAddress\",\"type\":\"address\"}],\"name\":\"setDefiBridgeProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"providerAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"name\":\"setRollupProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"linkedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"setSupportedAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"linkedBridge\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"setSupportedBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_verifierAddress\",\"type\":\"address\"}],\"name\":\"setVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userPendingDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"verifierAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RollupProcessor", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "5000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000008700000000000000000000000000000000000000000000000000000000000000960", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}