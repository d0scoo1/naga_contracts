{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/habibiz/Oil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.7;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// Inspired by Solmate: https://github.com/Rari-Capital/solmate\\n/// Developed originally by 0xBasset\\n/// Upgraded by <redacted>\\n/// Additions by Tsuki Labs: https://tsukiyomigroup.com/ :)\\n\\ncontract Oil {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public impl_;\\n    address public ruler;\\n    address public treasury;\\n    address public uniPair;\\n    address public weth;\\n\\n    uint256 public totalSupply;\\n    uint256 public startingTime;\\n    uint256 public baseTax;\\n    uint256 public minSwap;\\n\\n    bool public paused;\\n    bool public swapping;\\n\\n    ERC721Like public habibi;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    mapping(address => bool) public isMinter;\\n\\n    mapping(uint256 => uint256) public claims;\\n\\n    mapping(address => Staker) internal stakers;\\n\\n    uint256 public sellFee;\\n\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    uint256 public doubleBaseTimestamp;\\n\\n    struct Habibi {\\n        uint256 stakedTimestamp;\\n        uint256 tokenId;\\n    }\\n\\n    struct Staker {\\n        Habibi[] habibiz;\\n        uint256 lastClaim;\\n    }\\n\\n    struct Rescueable {\\n        address revoker;\\n        bool adminAllowedAsRevoker;\\n    }\\n\\n    mapping(address => Rescueable) private rescueable;\\n\\n    address public sushiswapPair;\\n    IUniswapV2Router02 public uniswapV2Router;\\n    IUniswapV2Router02 public sushiswapV2Router;\\n\\n    mapping(address => bool) public excludedFromFees;\\n    mapping(address => bool) public blockList;\\n\\n    struct RoyalStaker {\\n        Royal[] royals;\\n    }\\n\\n    struct Royal {\\n        uint256 stakedTimestamp;\\n        uint256 tokenId;\\n    }\\n\\n    ERC721Like public royals;\\n\\n    uint256[] public frozenHabibiz;\\n\\n    mapping(uint256 => address) public claimedRoyals;\\n    mapping(address => RoyalStaker) internal royalStakers;\\n    mapping(uint256 => address) public ownerOfRoyal;\\n    mapping(uint256 => uint256) public royalSwaps;\\n    mapping(uint256 => uint256) public escrowedOil;\\n    mapping(address => uint256) public lastUnstakedTimestamp;\\n    uint256 public swapRoyalsCost;\\n    uint256 public royalsHabibiRatio;\\n    bool public swappingActive;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function name() external pure returns (string memory) {\\n        return \\\"OIL\\\";\\n    }\\n\\n    function symbol() external pure returns (string memory) {\\n        return \\\"OIL\\\";\\n    }\\n\\n    function decimals() external pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function initialize(address habibi_, address treasury_) external {\\n        require(msg.sender == ruler, \\\"NOT ALLOWED TO RULE\\\");\\n        ruler = msg.sender;\\n        treasury = treasury_;\\n        habibi = ERC721Like(habibi_);\\n        sellFee = 15000;\\n        royalsHabibiRatio = 8;\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        allowance[msg.sender][spender] = value;\\n\\n        emit Approval(msg.sender, spender, value);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external whenNotPaused returns (bool) {\\n        require(!blockList[msg.sender], \\\"Address Blocked\\\");\\n        _transfer(msg.sender, to, value);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external whenNotPaused returns (bool) {\\n        require(!blockList[msg.sender], \\\"Address Blocked\\\");\\n        if (allowance[from][msg.sender] != type(uint256).max) {\\n            allowance[from][msg.sender] -= value;\\n        }\\n\\n        _transfer(from, to, value);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              STAKING\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _tokensOfStaker(address staker_, bool royals_) internal view returns (uint256[] memory) {\\n        uint256 i;\\n        if (royals_) {\\n            uint256[] memory tokenIds = new uint256[](royalStakers[staker_].royals.length);\\n            for (i = 0; i < royalStakers[staker_].royals.length; i++) {\\n                tokenIds[i] = royalStakers[staker_].royals[i].tokenId;\\n            }\\n            return tokenIds;\\n        } else {\\n            uint256[] memory tokenIds = new uint256[](stakers[staker_].habibiz.length);\\n            for (i = 0; i < stakers[staker_].habibiz.length; i++) {\\n                tokenIds[i] = stakers[staker_].habibiz[i].tokenId;\\n            }\\n            return tokenIds;\\n        }\\n    }\\n\\n    function habibizOfStaker(address staker_) public view returns (uint256[] memory) {\\n        return _tokensOfStaker(staker_, false);\\n    }\\n\\n    function royalsOfStaker(address staker_) public view returns (uint256[] memory) {\\n        return _tokensOfStaker(staker_, true);\\n    }\\n\\n    function allStakedOfStaker(address staker_) public view returns (uint256[] memory, uint256[] memory) {\\n        return (habibizOfStaker(staker_), royalsOfStaker(staker_));\\n    }\\n\\n    function stake(uint256[] memory habibiz_, uint256[] memory royals_) public whenNotPaused {\\n        uint256 i;\\n        for (i = 0; i < habibiz_.length; i++) {\\n            require(habibi.ownerOf(habibiz_[i]) == msg.sender, \\\"At least one Habibi is not owned by you.\\\");\\n            habibi.transferFrom(msg.sender, address(this), habibiz_[i]);\\n            stakers[msg.sender].habibiz.push(Habibi(block.timestamp, habibiz_[i]));\\n        }\\n\\n        for (i = 0; i < royals_.length; i++) {\\n            require(royals.ownerOf(royals_[i]) == msg.sender, \\\"At least one Royals is not owned by you.\\\");\\n            royals.transferFrom(msg.sender, address(this), royals_[i]);\\n            royalStakers[msg.sender].royals.push(Royal(block.timestamp, royals_[i]));\\n        }\\n    }\\n\\n    function stakeAll() external whenNotPaused {\\n        uint256[] memory habibizTokenIds = habibi.walletOfOwner(msg.sender);\\n        uint256[] memory royalsTokenIds = royals.tokensOfOwner(msg.sender);\\n        stake(habibizTokenIds, royalsTokenIds);\\n    }\\n\\n    function isOwnedByStaker(\\n        address staker_,\\n        uint256 tokenId_,\\n        bool isRoyal_\\n    ) public view returns (uint256, bool) {\\n        uint256 i;\\n        if (isRoyal_) {\\n            for (i = 0; i < royalStakers[staker_].royals.length; i++) {\\n                if (tokenId_ == royalStakers[staker_].royals[i].tokenId) {\\n                    return (i, true);\\n                }\\n            }\\n        } else {\\n            for (i = 0; i < stakers[staker_].habibiz.length; i++) {\\n                if (tokenId_ == stakers[staker_].habibiz[i].tokenId) {\\n                    return (i, true);\\n                }\\n            }\\n        }\\n        return (0, false);\\n    }\\n\\n    function _unstake(bool habibiz_, bool royals_) internal {\\n        uint256 i;\\n        uint256 oil;\\n        lastUnstakedTimestamp[msg.sender] = block.timestamp;\\n        if (habibiz_) {\\n            for (i = 0; i < stakers[msg.sender].habibiz.length; i++) {\\n                Habibi memory _habibi = stakers[msg.sender].habibiz[i];\\n                habibi.transferFrom(address(this), msg.sender, _habibi.tokenId);\\n                oil += _calculateOil(msg.sender, _habibi.tokenId, _habibi.stakedTimestamp, false);\\n            }\\n            delete stakers[msg.sender].habibiz;\\n        }\\n\\n        if (royals_) {\\n            for (i = 0; i < royalStakers[msg.sender].royals.length; i++) {\\n                Royal memory _royal = royalStakers[msg.sender].royals[i];\\n                royals.transferFrom(address(this), msg.sender, _royal.tokenId);\\n                oil += _calculateOil(msg.sender, _royal.tokenId, _royal.stakedTimestamp, true);\\n            }\\n            delete royalStakers[msg.sender].royals;\\n        }\\n        if (oil > 0) _claimAmount(msg.sender, oil);\\n    }\\n\\n    function _unstakeByIds(uint256[] memory habibizIds_, uint256[] memory royalsIds_) internal {\\n        uint256 i;\\n        uint256 oil;\\n        uint256 balanceBonus = holderBonusPercentage(msg.sender);\\n        uint256 lastClaim = stakers[msg.sender].lastClaim;\\n        uint256 royalsBase = getRoyalsBase(msg.sender);\\n        lastUnstakedTimestamp[msg.sender] = block.timestamp;\\n        if (habibizIds_.length > 0) {\\n            for (i = 0; i < habibizIds_.length; i++) {\\n                (uint256 stakedIndex, bool isOwned) = isOwnedByStaker(msg.sender, habibizIds_[i], false);\\n                require(isOwned, \\\"Habibi not owned by sender\\\");\\n                oil += calculateOilOfToken(\\n                    _isAnimated(habibizIds_[i]),\\n                    lastClaim,\\n                    stakers[msg.sender].habibiz[stakedIndex].stakedTimestamp,\\n                    balanceBonus,\\n                    false,\\n                    0\\n                );\\n                habibi.transferFrom(address(this), msg.sender, habibizIds_[i]);\\n                _removeTokenFromStakerAtIndex(stakedIndex, msg.sender, false);\\n            }\\n        }\\n        if (royalsIds_.length > 0) {\\n            for (i = 0; i < royalsIds_.length; i++) {\\n                (uint256 stakedIndex, bool isOwned) = isOwnedByStaker(msg.sender, royalsIds_[i], true);\\n                require(isOwned, \\\"Royal not owned by sender\\\");\\n                oil += calculateOilOfToken(\\n                    false,\\n                    lastClaim,\\n                    royalStakers[msg.sender].royals[stakedIndex].stakedTimestamp,\\n                    balanceBonus,\\n                    true,\\n                    royalsBase\\n                );\\n                _removeTokenFromStakerAtIndex(stakedIndex, msg.sender, true);\\n                royals.transferFrom(address(this), msg.sender, royalsIds_[i]);\\n            }\\n        }\\n        if (oil > 0) _claimAmount(msg.sender, oil);\\n    }\\n\\n    function unstakeAllHabibiz() external whenNotPaused {\\n        require(stakers[msg.sender].habibiz.length > 0, \\\"No Habibiz staked\\\");\\n        _unstake(true, false);\\n    }\\n\\n    function unstakeAllRoyals() external whenNotPaused {\\n        require(royalStakers[msg.sender].royals.length > 0, \\\"No Royals staked\\\");\\n        _unstake(false, true);\\n    }\\n\\n    function unstakeAll() external whenNotPaused {\\n        require(\\n            stakers[msg.sender].habibiz.length > 0 || royalStakers[msg.sender].royals.length > 0,\\n            \\\"No Habibiz or Royals staked\\\"\\n        );\\n        _unstake(true, true);\\n    }\\n\\n    function unstakeHabibizByIds(uint256[] calldata tokenIds_) external whenNotPaused {\\n        _unstakeByIds(tokenIds_, new uint256[](0));\\n    }\\n\\n    function unstakeRoyalsByIds(uint256[] calldata tokenIds_) external whenNotPaused {\\n        _unstakeByIds(new uint256[](0), tokenIds_);\\n    }\\n\\n    function _removeTokenFromStakerAtIndex(\\n        uint256 index_,\\n        address staker_,\\n        bool isRoyal_\\n    ) internal {\\n        if (isRoyal_) {\\n            royalStakers[staker_].royals[index_] = royalStakers[staker_].royals[\\n                royalStakers[staker_].royals.length - 1\\n            ];\\n            royalStakers[staker_].royals.pop();\\n        } else {\\n            stakers[staker_].habibiz[index_] = stakers[staker_].habibiz[stakers[staker_].habibiz.length - 1];\\n            stakers[staker_].habibiz.pop();\\n        }\\n    }\\n\\n    function _removeRoyalsFromStaker(address staker_, uint256[] memory tokenIds_) internal {\\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\\n            for (uint256 j = 0; j < royalStakers[staker_].royals.length; j++) {\\n                if (tokenIds_[i] == royalStakers[staker_].royals[j].tokenId) {\\n                    _removeTokenFromStakerAtIndex(j, staker_, true);\\n                }\\n            }\\n        }\\n    }\\n\\n    function _removeHabibizFromStaker(address staker_, uint256[] memory tokenIds_) internal {\\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\\n            for (uint256 j = 0; j < stakers[staker_].habibiz.length; j++) {\\n                if (tokenIds_[i] == stakers[staker_].habibiz[j].tokenId) {\\n                    _removeTokenFromStakerAtIndex(j, staker_, false);\\n                }\\n            }\\n        }\\n    }\\n\\n    function approveRescue(\\n        address revoker_,\\n        bool confirm_,\\n        bool rescueableByAdmin_\\n    ) external {\\n        require(confirm_, \\\"Did not confirm\\\");\\n        require(revoker_ != address(0), \\\"Revoker cannot be null address\\\");\\n        rescueable[msg.sender] = Rescueable(revoker_, rescueableByAdmin_);\\n    }\\n\\n    function revokeRescue(address rescueable_, bool confirm_) external {\\n        if (msg.sender == ruler) {\\n            require(rescueable[rescueable_].adminAllowedAsRevoker, \\\"Admin is not allowed to revoke\\\");\\n        } else {\\n            require(rescueable[rescueable_].revoker == msg.sender, \\\"Sender is not revoker\\\");\\n        }\\n        require(confirm_, \\\"Did not confirm\\\");\\n\\n        delete rescueable[rescueable_];\\n    }\\n\\n    /*////////////////////////////////////////////////////////////\\n                        Sacrifice for Royals\\n    ////////////////////////////////////////////////////////////*/\\n\\n    function freeze(\\n        address staker_,\\n        uint256[] calldata habibizIds_,\\n        uint256 royalId_\\n    ) external returns (bool) {\\n        require(msg.sender == address(royals), \\\"You do not have permission to call this function\\\");\\n        require(\\n            royals.ownerOf(royalId_) == address(this) && claimedRoyals[royalId_] == address(0),\\n            \\\"Invalid or claimed token id\\\"\\n        );\\n        uint256 oil;\\n\\n        for (uint256 i = 0; i < habibizIds_.length; i++) {\\n            (uint256 index, bool isOwned) = isOwnedByStaker(staker_, habibizIds_[i], false);\\n            require(isOwned, \\\"Habibi not owned\\\");\\n            oil += _calculateOil(staker_, habibizIds_[i], stakers[staker_].habibiz[index].stakedTimestamp, false);\\n            _removeTokenFromStakerAtIndex(index, staker_, false);\\n        }\\n\\n        claimedRoyals[royalId_] = staker_;\\n        royalStakers[staker_].royals.push(Royal(block.timestamp, royalId_));\\n        return true;\\n    }\\n\\n    function setRoyalOwner(\\n        address staker_,\\n        uint256 royalId_,\\n        bool force_\\n    ) external onlyRuler {\\n        require(!force_ || claimedRoyals[royalId_] == address(0), \\\"Royal already claimed\\\");\\n        claimedRoyals[royalId_] = staker_;\\n        royalStakers[staker_].royals.push(Royal(block.timestamp, royalId_));\\n    }\\n\\n    function swapRoyals(uint256 myRoyalId_, uint256 theirRoyalId_) external whenSwappingActive returns (bool) {\\n        uint256 cost = swapRoyalsCost == 0 ? swapRoyalsCost : swapRoyalsCost / 2;\\n        require(swapRoyalsCost == 0 || balanceOf[msg.sender] >= cost, \\\"Not enough OIL\\\");\\n        (uint256 index, bool isOwned) = isOwnedByStaker(msg.sender, myRoyalId_, true);\\n        require(isOwned, \\\"You don't own that Royal\\\");\\n        if (royalSwaps[theirRoyalId_] == myRoyalId_) {\\n            uint256 stakedTimestamp = royalStakers[msg.sender].royals[index].stakedTimestamp;\\n            address theirAddress = ownerOfRoyal[theirRoyalId_];\\n            (uint256 theirIndex, bool theirOwned) = isOwnedByStaker(theirAddress, theirRoyalId_, true);\\n            if (!theirOwned) {\\n                delete royalSwaps[theirRoyalId_];\\n                escrowedOil[theirRoyalId_] = 0;\\n                return false;\\n            }\\n            uint256 theirStakedTimestamp = royalStakers[theirAddress].royals[theirIndex].stakedTimestamp;\\n\\n            _removeTokenFromStakerAtIndex(index, msg.sender, true);\\n            _removeTokenFromStakerAtIndex(theirIndex, theirAddress, true);\\n\\n            royalStakers[msg.sender].royals.push(Royal(stakedTimestamp, theirRoyalId_));\\n            royalStakers[theirAddress].royals.push(Royal(theirStakedTimestamp, myRoyalId_));\\n\\n            balanceOf[msg.sender] -= cost;\\n            escrowedOil[theirRoyalId_] = 0;\\n\\n            ownerOfRoyal[myRoyalId_] = theirAddress;\\n            ownerOfRoyal[theirRoyalId_] = msg.sender;\\n        } else {\\n            royalSwaps[myRoyalId_] = theirRoyalId_;\\n            balanceOf[msg.sender] -= cost;\\n            escrowedOil[myRoyalId_] += cost;\\n            ownerOfRoyal[myRoyalId_] = msg.sender;\\n        }\\n        return true;\\n    }\\n\\n    function cancelSwap(uint256 myRoyalId_) external whenSwappingActive {\\n        require(ownerOfRoyal[myRoyalId_] == msg.sender, \\\"You don't own that Royal\\\");\\n        balanceOf[msg.sender] += escrowedOil[myRoyalId_];\\n        escrowedOil[myRoyalId_] = 0;\\n        delete royalSwaps[myRoyalId_];\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              CLAIMING\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function claim() public whenNotPaused {\\n        require(!blockList[msg.sender], \\\"Address Blocked\\\");\\n        _claim(msg.sender);\\n    }\\n\\n    function _claim(address to_) internal {\\n        uint256 oil = calculateOilRewards(to_);\\n        if (oil > 0) {\\n            _claimAmount(to_, oil);\\n        }\\n    }\\n\\n    function _claimAmount(address to_, uint256 amount_) internal {\\n        stakers[to_].lastClaim = block.timestamp;\\n        _mint(to_, amount_);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            OIL REWARDS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function calculateOilRewards(address staker_) public view returns (uint256 oilAmount) {\\n        uint256 balanceBonus = holderBonusPercentage(staker_);\\n        uint256 habibizAmount = stakers[staker_].habibiz.length;\\n        uint256 royalsAmount = royalStakers[staker_].royals.length;\\n        uint256 totalStaked = habibizAmount + royalsAmount;\\n        uint256 royalsBase = getRoyalsBase(staker_);\\n        uint256 lastClaimTimestamp = stakers[staker_].lastClaim;\\n\\n        for (uint256 i = 0; i < totalStaked; i++) {\\n            bool isAnimated;\\n            uint256 tokenId;\\n            bool isRoyal;\\n            uint256 stakedTimestamp;\\n            if (i < habibizAmount) {\\n                tokenId = stakers[staker_].habibiz[i].tokenId;\\n                stakedTimestamp = stakers[staker_].habibiz[i].stakedTimestamp;\\n                isAnimated = _isAnimated(tokenId);\\n            } else {\\n                tokenId = royalStakers[staker_].royals[i - habibizAmount].tokenId;\\n                stakedTimestamp = royalStakers[staker_].royals[i - habibizAmount].stakedTimestamp;\\n                isRoyal = true;\\n            }\\n            oilAmount += calculateOilOfToken(\\n                isAnimated,\\n                lastClaimTimestamp,\\n                stakedTimestamp,\\n                balanceBonus,\\n                isRoyal,\\n                royalsBase\\n            );\\n        }\\n    }\\n\\n    function _calculateTimes(uint256 stakedTimestamp_, uint256 lastClaimedTimestamp_)\\n        internal\\n        view\\n        returns (uint256, uint256)\\n    {\\n        if (lastClaimedTimestamp_ < stakedTimestamp_) {\\n            lastClaimedTimestamp_ = stakedTimestamp_;\\n        }\\n        return (block.timestamp - stakedTimestamp_, block.timestamp - lastClaimedTimestamp_);\\n    }\\n\\n    function _calculateOil(\\n        address staker_,\\n        uint256 tokenId_,\\n        uint256 stakedTimestamp_,\\n        bool isRoyal_\\n    ) internal view returns (uint256) {\\n        uint256 balanceBonus = holderBonusPercentage(staker_);\\n        uint256 lastClaimTimestamp = stakers[staker_].lastClaim;\\n        uint256 royalsBase = getRoyalsBase(staker_);\\n        return\\n            calculateOilOfToken(\\n                isRoyal_ ? false : _isAnimated(tokenId_),\\n                lastClaimTimestamp,\\n                stakedTimestamp_,\\n                balanceBonus,\\n                isRoyal_,\\n                royalsBase\\n            );\\n    }\\n\\n    function calculateOilOfToken(\\n        bool isAnimated_,\\n        uint256 lastClaimedTimestamp_,\\n        uint256 stakedTimestamp_,\\n        uint256 balanceBonus_,\\n        bool isRoyal_,\\n        uint256 royalsBase\\n    ) internal view returns (uint256 oil) {\\n        uint256 bonusPercentage;\\n        uint256 baseOilMultiplier = 1;\\n\\n        (uint256 stakedTime, uint256 unclaimedTime) = _calculateTimes(stakedTimestamp_, lastClaimedTimestamp_);\\n\\n        if (stakedTime >= 15 days || stakedTimestamp_ <= doubleBaseTimestamp) {\\n            baseOilMultiplier = 2;\\n        }\\n\\n        if (stakedTime >= 90 days) {\\n            bonusPercentage = 100;\\n        } else {\\n            for (uint256 i = 2; i < 4; i++) {\\n                uint256 timeRequirement = 15 days * i;\\n                if (timeRequirement > 0 && timeRequirement <= stakedTime) {\\n                    bonusPercentage += 15;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if (isRoyal_) {\\n            oil = (unclaimedTime * royalsBase * 1 ether) / 1 days;\\n        } else if (isAnimated_) {\\n            oil = (unclaimedTime * 2500 ether * baseOilMultiplier) / 1 days;\\n        } else {\\n            bonusPercentage += balanceBonus_;\\n            oil = (unclaimedTime * 500 ether * baseOilMultiplier) / 1 days;\\n        }\\n        oil += ((oil * bonusPercentage) / 100);\\n    }\\n\\n    function getRoyalsBase(address staker_) public view returns (uint256 base) {\\n        if (royalStakers[staker_].royals.length == 1) {\\n            base = 12000;\\n        } else if (royalStakers[staker_].royals.length == 2) {\\n            base = 13500;\\n        } else if (royalStakers[staker_].royals.length >= 3) {\\n            base = 15000;\\n        } else {\\n            base = 0;\\n        }\\n    }\\n\\n    function staker(address staker_) public view returns (Staker memory, RoyalStaker memory) {\\n        return (stakers[staker_], royalStakers[staker_]);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            OIL PRIVILEGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mint(address to, uint256 value) external onlyMinter {\\n        _mint(to, value);\\n    }\\n\\n    function burn(address from, uint256 value) external onlyMinter {\\n        _burn(from, value);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         Ruler Function\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setDoubleBaseTimestamp(uint256 doubleBaseTimestamp_) external onlyRuler {\\n        doubleBaseTimestamp = doubleBaseTimestamp_;\\n    }\\n\\n    function setMinter(address minter_, bool canMint_) external onlyRuler {\\n        isMinter[minter_] = canMint_;\\n    }\\n\\n    function setRuler(address ruler_) external onlyRuler {\\n        ruler = ruler_;\\n    }\\n\\n    function setPaused(bool paused_) external onlyRuler {\\n        paused = paused_;\\n    }\\n\\n    function setHabibiAddress(address habibiAddress_) external onlyRuler {\\n        habibi = ERC721Like(habibiAddress_);\\n    }\\n\\n    function setRoyalsAddress(address royalsAddress_) external onlyRuler {\\n        royals = ERC721Like(royalsAddress_);\\n    }\\n\\n    function setSellFee(uint256 fee_) external onlyRuler {\\n        sellFee = fee_;\\n    }\\n\\n    function setUniswapV2Router(address router_) external onlyRuler {\\n        uniswapV2Router = IUniswapV2Router02(router_);\\n    }\\n\\n    function setSushiswapV2Router(address router_) external onlyRuler {\\n        sushiswapV2Router = IUniswapV2Router02(router_);\\n    }\\n\\n    function setV2Routers(address uniswapRouter_, address sushiswapRouter_) external onlyRuler {\\n        uniswapV2Router = IUniswapV2Router02(uniswapRouter_);\\n        sushiswapV2Router = IUniswapV2Router02(sushiswapRouter_);\\n    }\\n\\n    function setUniPair(address uniPair_) external onlyRuler {\\n        uniPair = uniPair_;\\n    }\\n\\n    function setSushiswapPair(address sushiswapPair_) external onlyRuler {\\n        sushiswapPair = sushiswapPair_;\\n    }\\n\\n    function setPairs(address uniPair_, address sushiswapPair_) external onlyRuler {\\n        uniPair = uniPair_;\\n        sushiswapPair = sushiswapPair_;\\n    }\\n\\n    function excludeFromFees(address[] calldata addresses_, bool[] calldata excluded_) external onlyRuler {\\n        for (uint256 i = 0; i < addresses_.length; i++) {\\n            excludedFromFees[addresses_[i]] = excluded_[i];\\n        }\\n    }\\n\\n    function blockOrUnblockAddresses(address[] calldata addresses_, bool[] calldata blocked_) external onlyRuler {\\n        for (uint256 i = 0; i < addresses_.length; i++) {\\n            blockList[addresses_[i]] = blocked_[i];\\n        }\\n    }\\n\\n    function setRoyalSwapCost(uint256 cost_) external onlyRuler {\\n        swapRoyalsCost = cost_;\\n    }\\n\\n    function setSwappingActive(bool active_) external onlyRuler {\\n        swappingActive = active_;\\n    }\\n\\n    function setRoyalsHabibiRatio(uint256 ratio_) external onlyRuler {\\n        royalsHabibiRatio = ratio_;\\n    }\\n\\n    /// emergency\\n    function rescue(\\n        address staker_,\\n        address to_,\\n        uint256[] calldata habibiIds_,\\n        uint256[] calldata royalIds_\\n    ) external onlyRuler {\\n        require(rescueable[staker_].revoker != address(0), \\\"User has not opted-in for rescue\\\");\\n        if (habibiIds_.length > 0) {\\n            for (uint256 i = 0; i < habibiIds_.length; i++) {\\n                (uint256 stakedIndex, bool isOwned) = isOwnedByStaker(staker_, habibiIds_[i], false);\\n                require(isOwned, \\\"Habibi TokenID not found\\\");\\n                stakers[to_].habibiz.push(Habibi(block.timestamp, habibiIds_[i]));\\n                _removeTokenFromStakerAtIndex(stakedIndex, staker_, false);\\n            }\\n        }\\n\\n        if (royalIds_.length > 0) {\\n            for (uint256 i = 0; i < royalIds_.length; i++) {\\n                (uint256 stakedIndex, bool isOwned) = isOwnedByStaker(staker_, royalIds_[i], true);\\n                require(isOwned, \\\"Royal TokenID not found\\\");\\n                royalStakers[to_].royals.push(Royal(block.timestamp, royalIds_[i]));\\n                _removeTokenFromStakerAtIndex(stakedIndex, staker_, true);\\n            }\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          INTERNAL UTILS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _getRouterFromPair(address pairAddress_) internal view returns (IUniswapV2Router02) {\\n        return pairAddress_ == address(uniPair) ? uniswapV2Router : sushiswapV2Router;\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(balanceOf[from] >= value, \\\"ERC20: transfer amount exceeds balance\\\");\\n        uint256 tax;\\n\\n        bool shouldTax = ((to == uniPair && balanceOf[to] != 0) || (to == sushiswapPair && balanceOf[to] != 0)) &&\\n            !swapping;\\n        if (shouldTax && !excludedFromFees[from]) {\\n            tax = (value * sellFee) / 100_000;\\n            if (tax > 0) {\\n                balanceOf[address(this)] += tax;\\n                swapTokensForEth(to, tax, treasury);\\n            }\\n        }\\n        uint256 taxedAmount = value - tax;\\n        balanceOf[from] -= value;\\n        balanceOf[to] += taxedAmount;\\n        emit Transfer(from, to, taxedAmount);\\n    }\\n\\n    function swapTokensForEth(\\n        address pairAddress_,\\n        uint256 amountIn_,\\n        address to_\\n    ) private lockTheSwap {\\n        IUniswapV2Router02 router = _getRouterFromPair(pairAddress_);\\n        IERC20(address(this)).approve(address(router), amountIn_);\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = router.WETH(); // or router.WETH();\\n\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(amountIn_, 1, path, to_, block.timestamp);\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply += value;\\n\\n        // This is safe because the sum of all user\\n        // balances can't exceed type(uint256).max!\\n        unchecked {\\n            balanceOf[to] += value;\\n        }\\n\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] -= value;\\n\\n        // This is safe because a user won't ever\\n        // have a balance larger than totalSupply!\\n        unchecked {\\n            totalSupply -= value;\\n        }\\n\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function holderBonusPercentage(address staker_) public view returns (uint256) {\\n        uint256 balance = stakers[staker_].habibiz.length + royalStakers[staker_].royals.length * royalsHabibiRatio;\\n\\n        if (balance < 5) return 0;\\n        if (balance < 10) return 15;\\n        if (balance < 20) return 25;\\n        return 35;\\n    }\\n\\n    function _isAnimated(uint256 id_) internal pure returns (bool animated) {\\n        return\\n            id_ == 40 ||\\n            id_ == 108 ||\\n            id_ == 169 ||\\n            id_ == 191 ||\\n            id_ == 246 ||\\n            id_ == 257 ||\\n            id_ == 319 ||\\n            id_ == 386 ||\\n            id_ == 496 ||\\n            id_ == 562 ||\\n            id_ == 637 ||\\n            id_ == 692 ||\\n            id_ == 832 ||\\n            id_ == 942 ||\\n            id_ == 943 ||\\n            id_ == 957 ||\\n            id_ == 1100 ||\\n            id_ == 1108 ||\\n            id_ == 1169 ||\\n            id_ == 1178 ||\\n            id_ == 1627 ||\\n            id_ == 1706 ||\\n            id_ == 1843 ||\\n            id_ == 1884 ||\\n            id_ == 2137 ||\\n            id_ == 2158 ||\\n            id_ == 2165 ||\\n            id_ == 2214 ||\\n            id_ == 2232 ||\\n            id_ == 2238 ||\\n            id_ == 2508 ||\\n            id_ == 2629 ||\\n            id_ == 2863 ||\\n            id_ == 3055 ||\\n            id_ == 3073 ||\\n            id_ == 3280 ||\\n            id_ == 3297 ||\\n            id_ == 3322 ||\\n            id_ == 3327 ||\\n            id_ == 3361 ||\\n            id_ == 3411 ||\\n            id_ == 3605 ||\\n            id_ == 3639 ||\\n            id_ == 3774 ||\\n            id_ == 4250 ||\\n            id_ == 4267 ||\\n            id_ == 4302 ||\\n            id_ == 4362 ||\\n            id_ == 4382 ||\\n            id_ == 4397 ||\\n            id_ == 4675 ||\\n            id_ == 4707 ||\\n            id_ == 4863;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          MODIFIERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    modifier onlyMinter() {\\n        require(isMinter[msg.sender], \\\"FORBIDDEN TO MINT OR BURN\\\");\\n        _;\\n    }\\n\\n    modifier onlyRuler() {\\n        require(msg.sender == ruler, \\\"NOT ALLOWED TO RULE\\\");\\n        _;\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(!paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier whenSwappingActive() {\\n        require(swappingActive, \\\"Swapping is paused\\\");\\n        _;\\n    }\\n\\n    modifier lockTheSwap() {\\n        swapping = true;\\n        _;\\n        swapping = false;\\n    }\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4) {\\n        return ERC721Like.onERC721Received.selector;\\n    }\\n}\\n\\ninterface ERC721Like {\\n    function balanceOf(address holder_) external view returns (uint256);\\n\\n    function ownerOf(uint256 id_) external view returns (address);\\n\\n    function walletOfOwner(address _owner) external view returns (uint256[] calldata);\\n\\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\\n\\n    function isApprovedForAll(address operator_, address address_) external view returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function WETH() external pure returns (address);\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\ninterface UniPairLike {\\n    function token0() external returns (address);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"}],\"name\":\"allStakedOfStaker\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"revoker_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"confirm_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"rescueableByAdmin_\",\"type\":\"bool\"}],\"name\":\"approveRescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blockList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses_\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"blocked_\",\"type\":\"bool[]\"}],\"name\":\"blockOrUnblockAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"}],\"name\":\"calculateOilRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"oilAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"myRoyalId_\",\"type\":\"uint256\"}],\"name\":\"cancelSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimedRoyals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claims\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"doubleBaseTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"escrowedOil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses_\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"excluded_\",\"type\":\"bool[]\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"habibizIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"royalId_\",\"type\":\"uint256\"}],\"name\":\"freeze\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"frozenHabibiz\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"}],\"name\":\"getRoyalsBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"base\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"habibi\",\"outputs\":[{\"internalType\":\"contract ERC721Like\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"}],\"name\":\"habibizOfStaker\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"}],\"name\":\"holderBonusPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"impl_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"habibi_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasury_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isRoyal_\",\"type\":\"bool\"}],\"name\":\"isOwnedByStaker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastUnstakedTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOfRoyal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"habibiIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"royalIds_\",\"type\":\"uint256[]\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rescueable_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"confirm_\",\"type\":\"bool\"}],\"name\":\"revokeRescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"royalSwaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royals\",\"outputs\":[{\"internalType\":\"contract ERC721Like\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royalsHabibiRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"}],\"name\":\"royalsOfStaker\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ruler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"doubleBaseTimestamp_\",\"type\":\"uint256\"}],\"name\":\"setDoubleBaseTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"habibiAddress_\",\"type\":\"address\"}],\"name\":\"setHabibiAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"canMint_\",\"type\":\"bool\"}],\"name\":\"setMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniPair_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sushiswapPair_\",\"type\":\"address\"}],\"name\":\"setPairs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused_\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royalId_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force_\",\"type\":\"bool\"}],\"name\":\"setRoyalOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cost_\",\"type\":\"uint256\"}],\"name\":\"setRoyalSwapCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"royalsAddress_\",\"type\":\"address\"}],\"name\":\"setRoyalsAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"name\":\"setRoyalsHabibiRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ruler_\",\"type\":\"address\"}],\"name\":\"setRuler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee_\",\"type\":\"uint256\"}],\"name\":\"setSellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sushiswapPair_\",\"type\":\"address\"}],\"name\":\"setSushiswapPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router_\",\"type\":\"address\"}],\"name\":\"setSushiswapV2Router\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"active_\",\"type\":\"bool\"}],\"name\":\"setSwappingActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniPair_\",\"type\":\"address\"}],\"name\":\"setUniPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router_\",\"type\":\"address\"}],\"name\":\"setUniswapV2Router\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniswapRouter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sushiswapRouter_\",\"type\":\"address\"}],\"name\":\"setV2Routers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"habibiz_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"royals_\",\"type\":\"uint256[]\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"}],\"name\":\"staker\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct Oil.Habibi[]\",\"name\":\"habibiz\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"lastClaim\",\"type\":\"uint256\"}],\"internalType\":\"struct Oil.Staker\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct Oil.Royal[]\",\"name\":\"royals\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Oil.RoyalStaker\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiswapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"myRoyalId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"theirRoyalId_\",\"type\":\"uint256\"}],\"name\":\"swapRoyals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRoyalsCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapping\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swappingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeAllHabibiz\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeAllRoyals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"unstakeHabibizByIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"unstakeRoyalsByIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Oil", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}