{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/registrar/ZNSHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport {ContextUpgradeable} from \\\"../oz/utils/ContextUpgradeable.sol\\\";\\r\\nimport {ERC165Upgradeable} from \\\"../oz/introspection/ERC165Upgradeable.sol\\\";\\r\\nimport {OwnableUpgradeable} from \\\"../oz/access/OwnableUpgradeable.sol\\\";\\r\\nimport {IZNSHub} from \\\"../interfaces/IZNSHub.sol\\\";\\r\\nimport {IRegistrar} from \\\"../interfaces/IRegistrar.sol\\\";\\r\\n\\r\\ncontract ZNSHub is\\r\\n  ContextUpgradeable,\\r\\n  ERC165Upgradeable,\\r\\n  IZNSHub,\\r\\n  OwnableUpgradeable\\r\\n{\\r\\n  event EETransferV1(\\r\\n    address registrar,\\r\\n    address indexed from,\\r\\n    address indexed to,\\r\\n    uint256 indexed tokenId\\r\\n  );\\r\\n\\r\\n  event EEDomainCreatedV2(\\r\\n    address registrar,\\r\\n    uint256 indexed id,\\r\\n    string label,\\r\\n    uint256 indexed labelHash,\\r\\n    uint256 indexed parent,\\r\\n    address minter,\\r\\n    address controller,\\r\\n    string metadataUri,\\r\\n    uint256 royaltyAmount\\r\\n  );\\r\\n\\r\\n  event EEMetadataLockChanged(\\r\\n    address registrar,\\r\\n    uint256 indexed id,\\r\\n    address locker,\\r\\n    bool isLocked\\r\\n  );\\r\\n\\r\\n  event EEMetadataChanged(address registrar, uint256 indexed id, string uri);\\r\\n\\r\\n  event EERoyaltiesAmountChanged(\\r\\n    address registrar,\\r\\n    uint256 indexed id,\\r\\n    uint256 amount\\r\\n  );\\r\\n\\r\\n  event EENewSubdomainRegistrar(\\r\\n    address parentRegistrar,\\r\\n    uint256 rootId,\\r\\n    address childRegistrar\\r\\n  );\\r\\n\\r\\n  // Contains all zNS Registrars that are authentic\\r\\n  mapping(address => bool) public authorizedRegistrars;\\r\\n\\r\\n  // Contains all authorized global zNS controllers\\r\\n  mapping(address => bool) public controllers;\\r\\n\\r\\n  // The original default registrar\\r\\n  address public defaultRegistrar;\\r\\n\\r\\n  // Contains mapping of domain id to contract\\r\\n  mapping(uint256 => address) public domainToContract;\\r\\n\\r\\n  // Subdomain Contracts (root id => contract)\\r\\n  mapping(uint256 => address) public subdomainRegistrars;\\r\\n\\r\\n  // Beacon Proxy used by zNS Registrars\\r\\n  address public beacon;\\r\\n\\r\\n  modifier onlyRegistrar() {\\r\\n    require(\\r\\n      authorizedRegistrars[_msgSender()],\\r\\n      \\\"REE: Not authorized registrar\\\"\\r\\n    );\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function initialize(address defaultRegistrar_, address registrarBeacon_)\\r\\n    public\\r\\n    initializer\\r\\n  {\\r\\n    __ERC165_init();\\r\\n    __Context_init();\\r\\n    __Ownable_init();\\r\\n    defaultRegistrar = defaultRegistrar_;\\r\\n    beacon = registrarBeacon_;\\r\\n  }\\r\\n\\r\\n  function registrarBeacon() external view returns (address) {\\r\\n    return beacon;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   Adds a new registrar to the set of authorized registrars.\\r\\n   Only the contract owner or an already registered registrar may\\r\\n   add new registrars.\\r\\n   */\\r\\n  function addRegistrar(uint256 rootDomainId, address registrar) external {\\r\\n    require(\\r\\n      _msgSender() == owner() || authorizedRegistrars[_msgSender()],\\r\\n      \\\"REE: Not Authorized\\\"\\r\\n    );\\r\\n\\r\\n    require(!authorizedRegistrars[registrar], \\\"ZH: Already Registered\\\");\\r\\n\\r\\n    authorizedRegistrars[registrar] = true;\\r\\n    subdomainRegistrars[rootDomainId] = registrar;\\r\\n\\r\\n    emit EENewSubdomainRegistrar(_msgSender(), rootDomainId, registrar);\\r\\n  }\\r\\n\\r\\n  function isController(address controller) external view returns (bool) {\\r\\n    return controllers[controller];\\r\\n  }\\r\\n\\r\\n  function addController(address controller) external onlyOwner {\\r\\n    require(!controllers[controller], \\\"ZH: Already controller\\\");\\r\\n    controllers[controller] = true;\\r\\n  }\\r\\n\\r\\n  function removeController(address controller) external onlyOwner {\\r\\n    require(controllers[controller], \\\"ZH: Not a controller\\\");\\r\\n    controllers[controller] = false;\\r\\n  }\\r\\n\\r\\n  function getRegistrarForDomain(uint256 domainId)\\r\\n    public\\r\\n    view\\r\\n    returns (IRegistrar)\\r\\n  {\\r\\n    address registrar = domainToContract[domainId];\\r\\n    if (registrar == address(0)) {\\r\\n      registrar = defaultRegistrar;\\r\\n    }\\r\\n    return IRegistrar(registrar);\\r\\n  }\\r\\n\\r\\n  function ownerOf(uint256 domainId) public view returns (address) {\\r\\n    IRegistrar reg = getRegistrarForDomain(domainId);\\r\\n    require(reg.domainExists(domainId), \\\"ZH: Domain doesn't exist\\\");\\r\\n    return reg.ownerOf(domainId);\\r\\n  }\\r\\n\\r\\n  function domainExists(uint256 domainId) public view returns (bool) {\\r\\n    IRegistrar reg = getRegistrarForDomain(domainId);\\r\\n    return reg.domainExists(domainId);\\r\\n  }\\r\\n\\r\\n  // Used by registrars to emit transfer events so that we can pick it\\r\\n  // up on subgraph\\r\\n  function domainTransferred(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId\\r\\n  ) external onlyRegistrar {\\r\\n    emit EETransferV1(_msgSender(), from, to, tokenId);\\r\\n  }\\r\\n\\r\\n  function domainCreated(\\r\\n    uint256 id,\\r\\n    string calldata label,\\r\\n    uint256 labelHash,\\r\\n    uint256 parent,\\r\\n    address minter,\\r\\n    address controller,\\r\\n    string calldata metadataUri,\\r\\n    uint256 royaltyAmount\\r\\n  ) external onlyRegistrar {\\r\\n    emit EEDomainCreatedV2(\\r\\n      _msgSender(),\\r\\n      id,\\r\\n      label,\\r\\n      labelHash,\\r\\n      parent,\\r\\n      minter,\\r\\n      controller,\\r\\n      metadataUri,\\r\\n      royaltyAmount\\r\\n    );\\r\\n    domainToContract[id] = _msgSender();\\r\\n  }\\r\\n\\r\\n  function metadataLockChanged(\\r\\n    uint256 id,\\r\\n    address locker,\\r\\n    bool isLocked\\r\\n  ) external onlyRegistrar {\\r\\n    emit EEMetadataLockChanged(_msgSender(), id, locker, isLocked);\\r\\n  }\\r\\n\\r\\n  function metadataChanged(uint256 id, string calldata uri)\\r\\n    external\\r\\n    onlyRegistrar\\r\\n  {\\r\\n    emit EEMetadataChanged(_msgSender(), id, uri);\\r\\n  }\\r\\n\\r\\n  function royaltiesAmountChanged(uint256 id, uint256 amount)\\r\\n    external\\r\\n    onlyRegistrar\\r\\n  {\\r\\n    emit EERoyaltiesAmountChanged(_msgSender(), id, amount);\\r\\n  }\\r\\n\\r\\n  function owner()\\r\\n    public\\r\\n    view\\r\\n    override(OwnableUpgradeable, IZNSHub)\\r\\n    returns (address)\\r\\n  {\\r\\n    return super.owner();\\r\\n  }\\r\\n\\r\\n  function parentOf(uint256 domainId) external view returns (uint256) {\\r\\n    IRegistrar registrar = getRegistrarForDomain(domainId);\\r\\n    return registrar.parentOf(domainId);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oz/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\nimport \\\"../proxy/Initializable.sol\\\";\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract ContextUpgradeable is Initializable {\\r\\n  function __Context_init() internal initializer {\\r\\n    __Context_init_unchained();\\r\\n  }\\r\\n\\r\\n  function __Context_init_unchained() internal initializer {}\\r\\n\\r\\n  function _msgSender() internal view virtual returns (address) {\\r\\n    return msg.sender;\\r\\n  }\\r\\n\\r\\n  function _msgData() internal view virtual returns (bytes memory) {\\r\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n    return msg.data;\\r\\n  }\\r\\n\\r\\n  uint256[50] private __gap;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oz/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./IERC165Upgradeable.sol\\\";\\r\\nimport \\\"../proxy/Initializable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC165} interface.\\r\\n *\\r\\n * Contracts may inherit from this and call {_registerInterface} to declare\\r\\n * their support of an interface.\\r\\n */\\r\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\r\\n  /*\\r\\n   * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\r\\n   */\\r\\n  bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\r\\n\\r\\n  /**\\r\\n   * @dev Mapping of interface ids to whether or not it's supported.\\r\\n   */\\r\\n  mapping(bytes4 => bool) private _supportedInterfaces;\\r\\n\\r\\n  function __ERC165_init() internal initializer {\\r\\n    __ERC165_init_unchained();\\r\\n  }\\r\\n\\r\\n  function __ERC165_init_unchained() internal initializer {\\r\\n    // Derived contracts need only register support for their own interfaces,\\r\\n    // we register support for ERC165 itself here\\r\\n    _registerInterface(_INTERFACE_ID_ERC165);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {IERC165-supportsInterface}.\\r\\n   *\\r\\n   * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\r\\n   */\\r\\n  function supportsInterface(bytes4 interfaceId)\\r\\n    public\\r\\n    view\\r\\n    virtual\\r\\n    override\\r\\n    returns (bool)\\r\\n  {\\r\\n    return _supportedInterfaces[interfaceId];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Registers the contract as an implementer of the interface defined by\\r\\n   * `interfaceId`. Support of the actual ERC165 interface is automatic and\\r\\n   * registering its interface id is not required.\\r\\n   *\\r\\n   * See {IERC165-supportsInterface}.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\r\\n   */\\r\\n  function _registerInterface(bytes4 interfaceId) internal virtual {\\r\\n    require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\r\\n    _supportedInterfaces[interfaceId] = true;\\r\\n  }\\r\\n\\r\\n  uint256[49] private __gap;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oz/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\r\\nimport \\\"../proxy/Initializable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\r\\n  address private _owner;\\r\\n\\r\\n  event OwnershipTransferred(\\r\\n    address indexed previousOwner,\\r\\n    address indexed newOwner\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n   */\\r\\n  function __Ownable_init() internal initializer {\\r\\n    __Context_init_unchained();\\r\\n    __Ownable_init_unchained();\\r\\n  }\\r\\n\\r\\n  function __Ownable_init_unchained() internal initializer {\\r\\n    address msgSender = _msgSender();\\r\\n    _owner = msgSender;\\r\\n    emit OwnershipTransferred(address(0), msgSender);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the address of the current owner.\\r\\n   */\\r\\n  function owner() public view virtual returns (address) {\\r\\n    return _owner;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Throws if called by any account other than the owner.\\r\\n   */\\r\\n  modifier onlyOwner() {\\r\\n    require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Leaves the contract without owner. It will not be possible to call\\r\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n   *\\r\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n   * thereby removing any functionality that is only available to the owner.\\r\\n   */\\r\\n  function renounceOwnership() public virtual onlyOwner {\\r\\n    emit OwnershipTransferred(_owner, address(0));\\r\\n    _owner = address(0);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n   * Can only be called by the current owner.\\r\\n   */\\r\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n    emit OwnershipTransferred(_owner, newOwner);\\r\\n    _owner = newOwner;\\r\\n  }\\r\\n\\r\\n  uint256[49] private __gap;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IZNSHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport {IRegistrar} from \\\"./IRegistrar.sol\\\";\\r\\n\\r\\ninterface IZNSHub {\\r\\n  function addRegistrar(uint256 rootDomainId, address registrar) external;\\r\\n\\r\\n  function isController(address controller) external returns (bool);\\r\\n\\r\\n  function getRegistrarForDomain(uint256 domainId)\\r\\n    external\\r\\n    view\\r\\n    returns (IRegistrar);\\r\\n\\r\\n  function ownerOf(uint256 domainId) external view returns (address);\\r\\n\\r\\n  function domainExists(uint256 domainId) external view returns (bool);\\r\\n\\r\\n  function owner() external view returns (address);\\r\\n\\r\\n  function registrarBeacon() external view returns (address);\\r\\n\\r\\n  function domainTransferred(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId\\r\\n  ) external;\\r\\n\\r\\n  function domainCreated(\\r\\n    uint256 id,\\r\\n    string calldata name,\\r\\n    uint256 nameHash,\\r\\n    uint256 parent,\\r\\n    address minter,\\r\\n    address controller,\\r\\n    string calldata metadataUri,\\r\\n    uint256 royaltyAmount\\r\\n  ) external;\\r\\n\\r\\n  function metadataLockChanged(\\r\\n    uint256 id,\\r\\n    address locker,\\r\\n    bool isLocked\\r\\n  ) external;\\r\\n\\r\\n  function metadataChanged(uint256 id, string calldata uri) external;\\r\\n\\r\\n  function royaltiesAmountChanged(uint256 id, uint256 amount) external;\\r\\n\\r\\n  // Returns the parent domain of a child domain\\r\\n  function parentOf(uint256 id) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IRegistrar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"../oz/token/ERC721/IERC721EnumerableUpgradeable.sol\\\";\\r\\nimport \\\"../oz/token/ERC721/IERC721MetadataUpgradeable.sol\\\";\\r\\n\\r\\ninterface IRegistrar is\\r\\n  IERC721MetadataUpgradeable,\\r\\n  IERC721EnumerableUpgradeable\\r\\n{\\r\\n  // Emitted when a controller is removed\\r\\n  event ControllerAdded(address indexed controller);\\r\\n\\r\\n  // Emitted whenever a controller is removed\\r\\n  event ControllerRemoved(address indexed controller);\\r\\n\\r\\n  // Emitted whenever a new domain is created\\r\\n  event DomainCreated(\\r\\n    uint256 indexed id,\\r\\n    string label,\\r\\n    uint256 indexed labelHash,\\r\\n    uint256 indexed parent,\\r\\n    address minter,\\r\\n    address controller,\\r\\n    string metadataUri,\\r\\n    uint256 royaltyAmount\\r\\n  );\\r\\n\\r\\n  // Emitted whenever the metadata of a domain is locked\\r\\n  event MetadataLockChanged(uint256 indexed id, address locker, bool isLocked);\\r\\n\\r\\n  // Emitted whenever the metadata of a domain is changed\\r\\n  event MetadataChanged(uint256 indexed id, string uri);\\r\\n\\r\\n  // Emitted whenever the royalty amount is changed\\r\\n  event RoyaltiesAmountChanged(uint256 indexed id, uint256 amount);\\r\\n\\r\\n  // Authorises a controller, who can register domains.\\r\\n  function addController(address controller) external;\\r\\n\\r\\n  // Revoke controller permission for an address.\\r\\n  function removeController(address controller) external;\\r\\n\\r\\n  // Registers a new sub domain\\r\\n  function registerDomain(\\r\\n    uint256 parentId,\\r\\n    string memory label,\\r\\n    address minter,\\r\\n    string memory metadataUri,\\r\\n    uint256 royaltyAmount,\\r\\n    bool locked\\r\\n  ) external returns (uint256);\\r\\n\\r\\n  function registerDomainAndSend(\\r\\n    uint256 parentId,\\r\\n    string memory label,\\r\\n    address minter,\\r\\n    string memory metadataUri,\\r\\n    uint256 royaltyAmount,\\r\\n    bool locked,\\r\\n    address sendToUser\\r\\n  ) external returns (uint256);\\r\\n\\r\\n  function registerSubdomainContract(\\r\\n    uint256 parentId,\\r\\n    string memory label,\\r\\n    address minter,\\r\\n    string memory metadataUri,\\r\\n    uint256 royaltyAmount,\\r\\n    bool locked,\\r\\n    address sendToUser\\r\\n  ) external returns (uint256);\\r\\n\\r\\n  // Set a domains metadata uri and lock that domain from being modified\\r\\n  function setAndLockDomainMetadata(uint256 id, string memory uri) external;\\r\\n\\r\\n  // Lock a domain's metadata so that it cannot be changed\\r\\n  function lockDomainMetadata(uint256 id, bool toLock) external;\\r\\n\\r\\n  // Update a domain's metadata uri\\r\\n  function setDomainMetadataUri(uint256 id, string memory uri) external;\\r\\n\\r\\n  // Sets the asked royalty amount on a domain (amount is a percentage with 5 decimal places)\\r\\n  function setDomainRoyaltyAmount(uint256 id, uint256 amount) external;\\r\\n\\r\\n  // Returns whether an address is a controller\\r\\n  function isController(address account) external view returns (bool);\\r\\n\\r\\n  // Checks whether or not a domain exists\\r\\n  function domainExists(uint256 id) external view returns (bool);\\r\\n\\r\\n  // Returns the original minter of a domain\\r\\n  function minterOf(uint256 id) external view returns (address);\\r\\n\\r\\n  // Checks if a domains metadata is locked\\r\\n  function isDomainMetadataLocked(uint256 id) external view returns (bool);\\r\\n\\r\\n  // Returns the address which locked the domain metadata\\r\\n  function domainMetadataLockedBy(uint256 id) external view returns (address);\\r\\n\\r\\n  // Gets the controller that registered a domain\\r\\n  function domainController(uint256 id) external view returns (address);\\r\\n\\r\\n  // Gets a domains current royalty amount\\r\\n  function domainRoyaltyAmount(uint256 id) external view returns (uint256);\\r\\n\\r\\n  // Returns the parent domain of a child domain\\r\\n  function parentOf(uint256 id) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oz/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n// solhint-disable-next-line compiler-version\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"../utils/AddressUpgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\r\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\r\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\r\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\r\\n *\\r\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\r\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\r\\n *\\r\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\r\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\r\\n */\\r\\nabstract contract Initializable {\\r\\n  /**\\r\\n   * @dev Indicates that the contract has been initialized.\\r\\n   */\\r\\n  bool private _initialized;\\r\\n\\r\\n  /**\\r\\n   * @dev Indicates that the contract is in the process of being initialized.\\r\\n   */\\r\\n  bool private _initializing;\\r\\n\\r\\n  /**\\r\\n   * @dev Modifier to protect an initializer function from being invoked twice.\\r\\n   */\\r\\n  modifier initializer() {\\r\\n    require(\\r\\n      _initializing || _isConstructor() || !_initialized,\\r\\n      \\\"Initializable: contract is already initialized\\\"\\r\\n    );\\r\\n\\r\\n    bool isTopLevelCall = !_initializing;\\r\\n    if (isTopLevelCall) {\\r\\n      _initializing = true;\\r\\n      _initialized = true;\\r\\n    }\\r\\n\\r\\n    _;\\r\\n\\r\\n    if (isTopLevelCall) {\\r\\n      _initializing = false;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev Returns true if and only if the function is running in the constructor\\r\\n  function _isConstructor() private view returns (bool) {\\r\\n    return !AddressUpgradeable.isContract(address(this));\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oz/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary AddressUpgradeable {\\r\\n  /**\\r\\n   * @dev Returns true if `account` is a contract.\\r\\n   *\\r\\n   * [IMPORTANT]\\r\\n   * ====\\r\\n   * It is unsafe to assume that an address for which this function returns\\r\\n   * false is an externally-owned account (EOA) and not a contract.\\r\\n   *\\r\\n   * Among others, `isContract` will return false for the following\\r\\n   * types of addresses:\\r\\n   *\\r\\n   *  - an externally-owned account\\r\\n   *  - a contract in construction\\r\\n   *  - an address where a contract will be created\\r\\n   *  - an address where a contract lived, but was destroyed\\r\\n   * ====\\r\\n   */\\r\\n  function isContract(address account) internal view returns (bool) {\\r\\n    // This method relies on extcodesize, which returns 0 for contracts in\\r\\n    // construction, since the code is only stored at the end of the\\r\\n    // constructor execution.\\r\\n\\r\\n    uint256 size;\\r\\n    // solhint-disable-next-line no-inline-assembly\\r\\n    assembly {\\r\\n      size := extcodesize(account)\\r\\n    }\\r\\n    return size > 0;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\r\\n   * `recipient`, forwarding all available gas and reverting on errors.\\r\\n   *\\r\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n   * imposed by `transfer`, making them unable to receive funds via\\r\\n   * `transfer`. {sendValue} removes this limitation.\\r\\n   *\\r\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n   *\\r\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n   * taken to not create reentrancy vulnerabilities. Consider using\\r\\n   * {ReentrancyGuard} or the\\r\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n   */\\r\\n  function sendValue(address payable recipient, uint256 amount) internal {\\r\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n    require(\\r\\n      success,\\r\\n      \\\"Address: unable to send value, recipient may have reverted\\\"\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Performs a Solidity function call using a low level `call`. A\\r\\n   * plain`call` is an unsafe replacement for a function call: use this\\r\\n   * function instead.\\r\\n   *\\r\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n   * function (like regular Solidity function calls).\\r\\n   *\\r\\n   * Returns the raw returned data. To convert to the expected return value,\\r\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `target` must be a contract.\\r\\n   * - calling `target` with `data` must not revert.\\r\\n   *\\r\\n   * _Available since v3.1._\\r\\n   */\\r\\n  function functionCall(address target, bytes memory data)\\r\\n    internal\\r\\n    returns (bytes memory)\\r\\n  {\\r\\n    return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n   *\\r\\n   * _Available since v3.1._\\r\\n   */\\r\\n  function functionCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    return functionCallWithValue(target, data, 0, errorMessage);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n   * but also transferring `value` wei to `target`.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - the calling contract must have an ETH balance of at least `value`.\\r\\n   * - the called Solidity function must be `payable`.\\r\\n   *\\r\\n   * _Available since v3.1._\\r\\n   */\\r\\n  function functionCallWithValue(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    uint256 value\\r\\n  ) internal returns (bytes memory) {\\r\\n    return\\r\\n      functionCallWithValue(\\r\\n        target,\\r\\n        data,\\r\\n        value,\\r\\n        \\\"Address: low-level call with value failed\\\"\\r\\n      );\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n   *\\r\\n   * _Available since v3.1._\\r\\n   */\\r\\n  function functionCallWithValue(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    uint256 value,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    require(\\r\\n      address(this).balance >= value,\\r\\n      \\\"Address: insufficient balance for call\\\"\\r\\n    );\\r\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n    // solhint-disable-next-line avoid-low-level-calls\\r\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n    return _verifyCallResult(success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n   * but performing a static call.\\r\\n   *\\r\\n   * _Available since v3.3._\\r\\n   */\\r\\n  function functionStaticCall(address target, bytes memory data)\\r\\n    internal\\r\\n    view\\r\\n    returns (bytes memory)\\r\\n  {\\r\\n    return\\r\\n      functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n   * but performing a static call.\\r\\n   *\\r\\n   * _Available since v3.3._\\r\\n   */\\r\\n  function functionStaticCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n    // solhint-disable-next-line avoid-low-level-calls\\r\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n    return _verifyCallResult(success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function _verifyCallResult(\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) private pure returns (bytes memory) {\\r\\n    if (success) {\\r\\n      return returndata;\\r\\n    } else {\\r\\n      // Look for revert reason and bubble it up if present\\r\\n      if (returndata.length > 0) {\\r\\n        // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n          let returndata_size := mload(returndata)\\r\\n          revert(add(32, returndata), returndata_size)\\r\\n        }\\r\\n      } else {\\r\\n        revert(errorMessage);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oz/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165Upgradeable {\\r\\n  /**\\r\\n   * @dev Returns true if this contract implements the interface defined by\\r\\n   * `interfaceId`. See the corresponding\\r\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n   * to learn more about how these ids are created.\\r\\n   *\\r\\n   * This function call must use less than 30 000 gas.\\r\\n   */\\r\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oz/token/ERC721/IERC721EnumerableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\nimport \\\"./IERC721Upgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\r\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n */\\r\\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\\r\\n  /**\\r\\n   * @dev Returns the total amount of tokens stored by the contract.\\r\\n   */\\r\\n  function totalSupply() external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\r\\n   * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\r\\n   */\\r\\n  function tokenOfOwnerByIndex(address owner, uint256 index)\\r\\n    external\\r\\n    view\\r\\n    returns (uint256 tokenId);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\r\\n   * Use along with {totalSupply} to enumerate all tokens.\\r\\n   */\\r\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oz/token/ERC721/IERC721MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\nimport \\\"./IERC721Upgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\r\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n */\\r\\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\\r\\n  /**\\r\\n   * @dev Returns the token collection name.\\r\\n   */\\r\\n  function name() external view returns (string memory);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token collection symbol.\\r\\n   */\\r\\n  function symbol() external view returns (string memory);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\r\\n   */\\r\\n  function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oz/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\nimport \\\"../../introspection/IERC165Upgradeable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC721 compliant contract.\\r\\n */\\r\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\r\\n  /**\\r\\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\r\\n   */\\r\\n  event Transfer(\\r\\n    address indexed from,\\r\\n    address indexed to,\\r\\n    uint256 indexed tokenId\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\r\\n   */\\r\\n  event Approval(\\r\\n    address indexed owner,\\r\\n    address indexed approved,\\r\\n    uint256 indexed tokenId\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\r\\n   */\\r\\n  event ApprovalForAll(\\r\\n    address indexed owner,\\r\\n    address indexed operator,\\r\\n    bool approved\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the number of tokens in ``owner``'s account.\\r\\n   */\\r\\n  function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the owner of the `tokenId` token.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `tokenId` must exist.\\r\\n   */\\r\\n  function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n  /**\\r\\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `from` cannot be the zero address.\\r\\n   * - `to` cannot be the zero address.\\r\\n   * - `tokenId` token must exist and be owned by `from`.\\r\\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\r\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers `tokenId` token from `from` to `to`.\\r\\n   *\\r\\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `from` cannot be the zero address.\\r\\n   * - `to` cannot be the zero address.\\r\\n   * - `tokenId` token must be owned by `from`.\\r\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n   * The approval is cleared when the token is transferred.\\r\\n   *\\r\\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - The caller must own the token or be an approved operator.\\r\\n   * - `tokenId` must exist.\\r\\n   *\\r\\n   * Emits an {Approval} event.\\r\\n   */\\r\\n  function approve(address to, uint256 tokenId) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the account approved for `tokenId` token.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `tokenId` must exist.\\r\\n   */\\r\\n  function getApproved(uint256 tokenId)\\r\\n    external\\r\\n    view\\r\\n    returns (address operator);\\r\\n\\r\\n  /**\\r\\n   * @dev Approve or remove `operator` as an operator for the caller.\\r\\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - The `operator` cannot be the caller.\\r\\n   *\\r\\n   * Emits an {ApprovalForAll} event.\\r\\n   */\\r\\n  function setApprovalForAll(address operator, bool _approved) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n   *\\r\\n   * See {setApprovalForAll}\\r\\n   */\\r\\n  function isApprovedForAll(address owner, address operator)\\r\\n    external\\r\\n    view\\r\\n    returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `from` cannot be the zero address.\\r\\n   * - `to` cannot be the zero address.\\r\\n   * - `tokenId` token must exist and be owned by `from`.\\r\\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function safeTransferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 tokenId,\\r\\n    bytes calldata data\\r\\n  ) external;\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"labelHash\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"parent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"metadataUri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"name\":\"EEDomainCreatedV2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"EEMetadataChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isLocked\",\"type\":\"bool\"}],\"name\":\"EEMetadataLockChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"parentRegistrar\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rootId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"childRegistrar\",\"type\":\"address\"}],\"name\":\"EENewSubdomainRegistrar\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EERoyaltiesAmountChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"EETransferV1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"addController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rootDomainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"registrar\",\"type\":\"address\"}],\"name\":\"addRegistrar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedRegistrars\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beacon\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"controllers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRegistrar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"labelHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parent\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"metadataUri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"name\":\"domainCreated\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"domainId\",\"type\":\"uint256\"}],\"name\":\"domainExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"domainToContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"domainTransferred\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"domainId\",\"type\":\"uint256\"}],\"name\":\"getRegistrarForDomain\",\"outputs\":[{\"internalType\":\"contract IRegistrar\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"defaultRegistrar_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"registrarBeacon_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"isController\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"metadataChanged\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"locker\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLocked\",\"type\":\"bool\"}],\"name\":\"metadataLockChanged\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"domainId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"domainId\",\"type\":\"uint256\"}],\"name\":\"parentOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registrarBeacon\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"removeController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"royaltiesAmountChanged\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"subdomainRegistrars\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ZNSHub", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}