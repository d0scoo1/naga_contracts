{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/factories/BalancerVaultFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\\\";\\nimport \\\"../strategy/BalancerVault.sol\\\";\\nimport \\\"../interfaces/IGaugeController.sol\\\";\\nimport \\\"../interfaces/ILiquidityGaugeStrat.sol\\\";\\n\\ninterface IBalancerLiquidityGauge {\\n\\tfunction lp_token() external view returns (address);\\n}\\n\\n/**\\n * @title Factory contract usefull for creating new balancer vaults that supports BPT related\\n * to the balancer platform, and the gauge multi rewards attached to it.\\n */\\n\\ncontract BalancerVaultFactory {\\n\\tusing ClonesUpgradeable for address;\\n\\n\\taddress public immutable vaultImpl = address(new BalancerVault());\\n\\taddress public constant GAUGE_IMPL = 0x3Dc56D46F0Bd13655EfB29594a2e44534c453BF9;\\n\\taddress public constant GOVERNANCE = 0xF930EBBd05eF8b25B1797b9b2109DDC9B0d43063;\\n\\taddress public constant GAUGE_CONTROLLER = 0xC128468b7Ce63eA702C1f104D55A2566b13D3ABD;\\n\\taddress public constant BAL = 0xba100000625a3754423978a60c9317c58a424e3D;\\n\\taddress public constant VESDT = 0x0C30476f66034E11782938DF8e4384970B6c9e8a;\\n\\taddress public constant SDT = 0x73968b9a57c6E53d41345FD57a6E6ae27d6CDB2F;\\n\\taddress public constant VEBOOST = 0xD67bdBefF01Fc492f1864E61756E5FBB3f173506;\\n\\taddress public constant CLAIM_REWARDS = 0x633120100e108F03aCe79d6C78Aac9a56db1be0F; // v2\\n\\taddress public constant BALANCER_STRATEGY = 0x873b031Ea6E4236E44d933Aae5a66AF6d4DA419d;\\n\\taddress public constant SDT_DISTRIBUTOR = 0x9C99dffC1De1AfF7E7C1F36fCdD49063A281e18C;\\n\\tevent VaultDeployed(address proxy, address lpToken, address impl);\\n\\tevent GaugeDeployed(address proxy, address stakeToken, address impl);\\n\\n\\t/**\\n\\t@dev Function to clone Balancer Vault and its gauge contracts \\n\\t@param _balGaugeAddress balancer liquidity gauge address\\n\\t */\\n\\tfunction cloneAndInit(address _balGaugeAddress) public {\\n\\t\\tuint256 weight = IGaugeController(GAUGE_CONTROLLER).get_gauge_weight(_balGaugeAddress);\\n\\t\\trequire(weight > 0, \\\"must have weight\\\");\\n\\t\\taddress vaultLpToken = IBalancerLiquidityGauge(_balGaugeAddress).lp_token();\\n\\t\\tstring memory tokenSymbol = ERC20Upgradeable(vaultLpToken).symbol();\\n\\t\\taddress vaultImplAddress = _cloneAndInitVault(\\n\\t\\t\\tERC20Upgradeable(vaultLpToken),\\n\\t\\t\\tstring(abi.encodePacked(\\\"sd\\\", tokenSymbol, \\\" Vault\\\")),\\n\\t\\t\\tstring(abi.encodePacked(\\\"sd\\\", tokenSymbol, \\\"-vault\\\"))\\n\\t\\t);\\n\\t\\taddress gaugeImplAddress = _cloneAndInitGauge(\\n\\t\\t\\tvaultImplAddress,\\n\\t\\t\\ttokenSymbol\\n\\t\\t);\\n\\t\\tBalancerVault(vaultImplAddress).setLiquidityGauge(gaugeImplAddress);\\n\\t\\tBalancerVault(vaultImplAddress).setGovernance(GOVERNANCE);\\n\\t\\tBalancerStrategy(BALANCER_STRATEGY).toggleVault(vaultImplAddress);\\n\\t\\tBalancerStrategy(BALANCER_STRATEGY).setGauge(vaultLpToken, _balGaugeAddress);\\n\\t\\tBalancerStrategy(BALANCER_STRATEGY).setMultiGauge(_balGaugeAddress, gaugeImplAddress);\\n\\t\\tBalancerStrategy(BALANCER_STRATEGY).manageFee(BalancerStrategy.MANAGEFEE.PERFFEE, _balGaugeAddress, 200); //%2 default\\n\\t\\tBalancerStrategy(BALANCER_STRATEGY).manageFee(BalancerStrategy.MANAGEFEE.VESDTFEE, _balGaugeAddress, 500); //%5 default\\n\\t\\tBalancerStrategy(BALANCER_STRATEGY).manageFee(BalancerStrategy.MANAGEFEE.ACCUMULATORFEE, _balGaugeAddress, 800); //%8 default\\n\\t\\tBalancerStrategy(BALANCER_STRATEGY).manageFee(BalancerStrategy.MANAGEFEE.CLAIMERREWARD, _balGaugeAddress, 50); //%0.5 default\\n\\t\\tILiquidityGaugeStrat(gaugeImplAddress).add_reward(BAL, BALANCER_STRATEGY);\\n\\t\\tILiquidityGaugeStrat(gaugeImplAddress).set_claimer(CLAIM_REWARDS);\\n\\t\\tILiquidityGaugeStrat(gaugeImplAddress).commit_transfer_ownership(GOVERNANCE);\\n\\t}\\n\\n\\t/**\\n\\t@dev Internal function to clone the vault \\n\\t@param _lpToken balancer BPT token address \\n\\t@param _name vault name\\n\\t@param _symbol vault symbol\\n\\t */\\n\\tfunction _cloneAndInitVault(\\n\\t\\tERC20Upgradeable _lpToken,\\n\\t\\tstring memory _name,\\n\\t\\tstring memory _symbol\\n\\t) internal returns (address) {\\n\\t\\tBalancerVault deployed = cloneVault(\\n\\t\\t\\t_lpToken,\\n\\t\\t\\tkeccak256(abi.encodePacked(GOVERNANCE, _name, _symbol, BALANCER_STRATEGY))\\n\\t\\t);\\n\\t\\tdeployed.init(_lpToken, address(this), _name, _symbol, BalancerStrategy(BALANCER_STRATEGY));\\n\\t\\treturn address(deployed);\\n\\t}\\n\\n\\t/**\\n\\t@dev Internal function to clone the gauge multi rewards\\n\\t@param _stakingToken sd LP token address \\n\\t@param _symbol gauge symbol\\n\\t */\\n\\tfunction _cloneAndInitGauge(\\n\\t\\taddress _stakingToken,\\n\\t\\tstring memory _symbol\\n\\t) internal returns (address) {\\n\\t\\tILiquidityGaugeStrat deployed = cloneGauge(_stakingToken, keccak256(abi.encodePacked(GOVERNANCE, _symbol)));\\n\\t\\tdeployed.initialize(\\n\\t\\t\\t_stakingToken,\\n\\t\\t\\taddress(this),\\n\\t\\t\\tSDT,\\n\\t\\t\\tVESDT,\\n\\t\\t\\tVEBOOST,\\n\\t\\t\\tSDT_DISTRIBUTOR,\\n\\t\\t\\t_stakingToken,\\n\\t\\t\\t_symbol\\n\\t\\t);\\n\\t\\treturn address(deployed);\\n\\t}\\n\\n\\t/**\\n\\t@dev Internal function that deploy and returns a clone of vault impl\\n\\t@param _lpToken balancer BPT token address\\n\\t@param _paramsHash governance+name+symbol+strategy parameters hash\\n\\t */\\n\\tfunction cloneVault(\\n\\t\\tERC20Upgradeable _lpToken,\\n\\t\\tbytes32 _paramsHash\\n\\t) internal returns (BalancerVault) {\\n\\t\\taddress deployed = address(vaultImpl).cloneDeterministic(keccak256(abi.encodePacked(address(_lpToken), _paramsHash)));\\n\\t\\temit VaultDeployed(deployed, address(_lpToken), vaultImpl);\\n\\t\\treturn BalancerVault(deployed);\\n\\t}\\n\\n\\t/**\\n\\t@dev Internal function that deploy and returns a clone of gauge impl\\n\\t@param _stakingToken sd LP token address\\n\\t@param _paramsHash governance+name+symbol parameters hash\\n\\t */\\n\\tfunction cloneGauge(\\n\\t\\taddress _stakingToken,\\n\\t\\tbytes32 _paramsHash\\n\\t) internal returns (ILiquidityGaugeStrat) {\\n\\t\\taddress deployed = address(GAUGE_IMPL).cloneDeterministic(\\n\\t\\t\\tkeccak256(abi.encodePacked(address(_stakingToken), _paramsHash))\\n\\t\\t);\\n\\t\\temit GaugeDeployed(deployed, _stakingToken, GAUGE_IMPL);\\n\\t\\treturn ILiquidityGaugeStrat(deployed);\\n\\t}\\n\\n\\t/**\\n\\t@dev Function that predicts the future address passing the parameters\\n\\t@param _impl address of contract to clone\\n\\t@param _token token (LP or sdLP)\\n\\t@param _paramsHash parameters hash\\n\\t */\\n\\tfunction predictAddress(\\n\\t\\taddress _impl,\\n\\t\\tIERC20 _token,\\n\\t\\tbytes32 _paramsHash\\n\\t) public view returns (address) {\\n\\t\\treturn address(_impl).predictDeterministicAddress(keccak256(abi.encodePacked(address(_token), _paramsHash)));\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary ClonesUpgradeable {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = _allowances[owner][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/strategy/BalancerVault.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"../interfaces/ILiquidityGaugeStrat.sol\\\";\\nimport \\\"./BalancerStrategy.sol\\\";\\nimport \\\"../interfaces/BalancerVault/IBalancerVault.sol\\\";\\nimport \\\"../interfaces/IBalancerPool.sol\\\";\\n\\ncontract BalancerVault is ERC20Upgradeable {\\n\\tusing SafeERC20Upgradeable for ERC20Upgradeable;\\n\\tusing AddressUpgradeable for address;\\n\\n\\tERC20Upgradeable public token;\\n\\taddress public governance;\\n\\tuint256 public withdrawalFee;\\n\\tuint256 public keeperFee;\\n\\taddress public liquidityGauge;\\n\\tuint256 public accumulatedFee;\\n\\tbytes32 public poolId;\\n\\taddress public constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;\\n\\tuint256 public min;\\n\\tuint256 public constant max = 10000;\\n\\tBalancerStrategy public balancerStrategy;\\n\\tevent Earn(address _token, uint256 _amount);\\n\\tevent Deposit(address _depositor, uint256 _amount);\\n\\tevent Withdraw(address _depositor, uint256 _amount);\\n\\n\\tfunction init(\\n\\t\\tERC20Upgradeable _token,\\n\\t\\taddress _governance,\\n\\t\\tstring memory name_,\\n\\t\\tstring memory symbol_,\\n\\t\\tBalancerStrategy _balancerStrategy\\n\\t) public initializer {\\n\\t\\t__ERC20_init(name_, symbol_);\\n\\t\\ttoken = _token;\\n\\t\\tgovernance = _governance;\\n\\t\\tmin = 10000;\\n\\t\\tkeeperFee = 10; // %0.1\\n\\t\\tpoolId = IBalancerPool(address(_token)).getPoolId();\\n\\t\\tbalancerStrategy = _balancerStrategy;\\n\\t}\\n\\n\\t/// @notice function to deposit the BPT token\\n\\t/// @param _staker address to stake for\\n\\t/// @param _amount amount to deposit\\n\\t/// @param _earn earn or not \\n\\tfunction deposit(\\n\\t\\taddress _staker,\\n\\t\\tuint256 _amount,\\n\\t\\tbool _earn\\n\\t) public {\\n\\t\\trequire(address(liquidityGauge) != address(0), \\\"Gauge not yet initialized\\\");\\n\\t\\ttoken.safeTransferFrom(msg.sender, address(this), _amount);\\n\\t\\t_deposit(_staker, _amount, _earn);\\n\\t}\\n\\n\\t/// @notice function to provide liquidity in underlying tokens \\n\\t/// @param _staker address to stake for\\n\\t/// @param _maxAmountsIn amounts for each underlying token\\n\\t/// @param _earn earn or not \\n\\t/// @param _minAmount amount to deposit\\n\\tfunction provideLiquidityAndDeposit(\\n\\t\\taddress _staker,\\n\\t\\tuint256[] calldata _maxAmountsIn,\\n\\t\\tbool _earn,\\n\\t\\tuint256 _minAmount\\n\\t) public {\\n\\t\\trequire(address(liquidityGauge) != address(0), \\\"Gauge not yet initialized\\\");\\n\\t\\t(IERC20[] memory tokens, , ) = IBalancerVault(BALANCER_VAULT).getPoolTokens(poolId);\\n\\t\\trequire(tokens.length == _maxAmountsIn.length, \\\"!length\\\");\\n\\t\\taddress[] memory assets = new address[](tokens.length);\\n\\t\\tfor (uint256 i; i < tokens.length; i++) {\\n\\t\\t\\tif (_maxAmountsIn[i] > 0) {\\n\\t\\t\\t\\ttokens[i].transferFrom(msg.sender, address(this), _maxAmountsIn[i]);\\n\\t\\t\\t\\ttokens[i].approve(BALANCER_VAULT, _maxAmountsIn[i]);\\n\\t\\t\\t}\\n\\t\\t\\tassets[i] = address(tokens[i]);\\n\\t\\t}\\n\\t\\tIBalancerVault.JoinPoolRequest memory pr = IBalancerVault.JoinPoolRequest(\\n\\t\\t\\tassets,\\n\\t\\t\\t_maxAmountsIn,\\n\\t\\t\\tabi.encode(1, _maxAmountsIn, _minAmount),\\n\\t\\t\\tfalse\\n\\t\\t);\\n\\t\\tuint256 lpBalanceBefore = token.balanceOf(address(this));\\n\\t\\tIBalancerVault(BALANCER_VAULT).joinPool(\\n\\t\\t\\tpoolId, // poolId\\n\\t\\t\\taddress(this),\\n\\t\\t\\taddress(this),\\n\\t\\t\\tpr\\n\\t\\t);\\n\\t\\tuint256 lpBalanceAfter = token.balanceOf(address(this));\\n\\n\\t\\t_deposit(_staker, lpBalanceAfter - lpBalanceBefore, _earn);\\n\\t}\\n\\n\\t/// @notice internal deposit function\\n\\t/// @param _staker address to stake for\\n\\t/// @param _amount amount to deposit\\n\\t/// @param _earn earn or not \\n\\tfunction _deposit(\\n\\t\\taddress _staker,\\n\\t\\tuint256 _amount,\\n\\t\\tbool _earn\\n\\t) internal {\\n\\t\\tif (!_earn) {\\n\\t\\t\\tuint256 keeperCut = (_amount * keeperFee) / 10000;\\n\\t\\t\\t_amount -= keeperCut;\\n\\t\\t\\taccumulatedFee += keeperCut;\\n\\t\\t} else {\\n\\t\\t\\t_amount += accumulatedFee;\\n\\t\\t\\taccumulatedFee = 0;\\n\\t\\t}\\n\\t\\t_mint(address(this), _amount);\\n\\t\\tILiquidityGaugeStrat(liquidityGauge).deposit(_amount, _staker);\\n\\t\\tif (_earn) {\\n\\t\\t\\tearn();\\n\\t\\t}\\n\\t\\temit Deposit(_staker, _amount);\\n\\t}\\n\\n\\t/// @notice function to withdraw\\n\\t/// @param _shares amount to withdraw\\n\\tfunction withdraw(uint256 _shares) public {\\n\\t\\tuint256 userTotalShares = ILiquidityGaugeStrat(liquidityGauge).balanceOf(msg.sender);\\n\\t\\trequire(_shares <= userTotalShares, \\\"Not enough staked\\\");\\n\\t\\tILiquidityGaugeStrat(liquidityGauge).withdraw(_shares, msg.sender, true);\\n\\t\\t_burn(address(this), _shares);\\n\\t\\tuint256 tokenBalance = token.balanceOf(address(this)) - accumulatedFee;\\n\\t\\tuint256 withdrawFee;\\n\\t\\tif (_shares > tokenBalance) {\\n\\t\\t\\tuint256 amountToWithdraw = _shares - tokenBalance;\\n\\t\\t\\tbalancerStrategy.withdraw(address(token), amountToWithdraw);\\n\\t\\t\\twithdrawFee = (amountToWithdraw * withdrawalFee) / 10000;\\n\\t\\t\\tif (withdrawFee > 0) {\\n\\t\\t\\t\\ttoken.safeTransfer(governance, withdrawFee);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ttoken.safeTransfer(msg.sender, _shares - withdrawFee);\\n\\t\\temit Withdraw(msg.sender, _shares - withdrawFee);\\n\\t}\\n\\n\\t/// @notice function to set the governance\\n\\t/// @param _governance governance address\\n\\tfunction setGovernance(address _governance) external {\\n\\t\\trequire(msg.sender == governance, \\\"!governance\\\");\\n\\t\\tgovernance = _governance;\\n\\t}\\n\\n\\t/// @notice function to set the keeper fee\\n\\t/// @param _newFee keeper fee\\n\\tfunction setKeeperFee(uint256 _newFee) external {\\n\\t\\trequire(msg.sender == governance, \\\"!governance\\\");\\n\\t\\tkeeperFee = _newFee;\\n\\t}\\n\\n\\t/// @notice function to set the gauge multi rewards\\n\\t/// @param _liquidityGauge gauge address\\n\\tfunction setLiquidityGauge(address _liquidityGauge) external {\\n\\t\\trequire(msg.sender == governance, \\\"!governance\\\");\\n\\t\\tliquidityGauge = _liquidityGauge;\\n\\t\\tERC20Upgradeable(address(this)).approve(liquidityGauge, type(uint256).max);\\n\\t}\\n\\t\\n\\t/// @notice function to set the balancer strategy\\n\\t/// @param _newStrat balancer strategy infos\\n\\tfunction setBalancerStrategy(BalancerStrategy _newStrat) external {\\n\\t\\trequire(msg.sender == governance, \\\"!governance\\\");\\n\\t\\tbalancerStrategy = _newStrat;\\n\\t}\\n\\n\\t/// @notice function to return the vault token decimals\\n\\tfunction decimals() public view override returns (uint8) {\\n\\t\\treturn token.decimals();\\n\\t}\\n\\n\\t/// @notice function to set the withdrawn fee\\n\\t/// @param _newFee withdrawn fee\\n\\tfunction setWithdrawnFee(uint256 _newFee) external {\\n\\t\\trequire(msg.sender == governance, \\\"!governance\\\");\\n\\t\\twithdrawalFee = _newFee;\\n\\t}\\n\\n\\t/// @notice function to set the min\\n\\t/// @param _min min amount\\n\\tfunction setMin(uint256 _min) external {\\n\\t\\trequire(msg.sender == governance, \\\"!governance\\\");\\n\\t\\tmin = _min;\\n\\t}\\n\\n\\t/// @notice view function to fetch the available amount to send to the strategy\\n\\tfunction available() public view returns (uint256) {\\n\\t\\treturn ((token.balanceOf(address(this)) - accumulatedFee) * min) / max;\\n\\t}\\n\\n\\t/// @notice internal function to move funds to the strategy\\n\\tfunction earn() internal {\\n\\t\\tuint256 tokenBalance = available();\\n\\t\\ttoken.approve(address(balancerStrategy), 0);\\n\\t\\ttoken.approve(address(balancerStrategy), tokenBalance);\\n\\t\\tbalancerStrategy.deposit(address(token), tokenBalance);\\n\\t\\temit Earn(address(token), tokenBalance);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGaugeController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.7;\\n\\ninterface IGaugeController {\\n\\t//solhint-disable-next-line\\n\\tfunction gauge_types(address addr) external view returns (int128);\\n\\n\\t//solhint-disable-next-line\\n\\tfunction gauge_relative_weight_write(address addr, uint256 timestamp) external returns (uint256);\\n\\n\\t//solhint-disable-next-line\\n\\tfunction gauge_relative_weight(address addr) external view returns (uint256);\\n\\n\\t//solhint-disable-next-line\\n\\tfunction gauge_relative_weight(address addr, uint256 timestamp) external view returns (uint256);\\n\\n\\t//solhint-disable-next-line\\n\\tfunction get_total_weight() external view returns (uint256);\\n\\n\\t//solhint-disable-next-line\\n\\tfunction get_gauge_weight(address addr) external view returns (uint256);\\n\\n\\tfunction vote_for_gauge_weights(address, uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILiquidityGaugeStrat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.7;\\n\\ninterface ILiquidityGaugeStrat {\\n\\tstruct Reward {\\n\\t\\taddress token;\\n\\t\\taddress distributor;\\n\\t\\tuint256 period_finish;\\n\\t\\tuint256 rate;\\n\\t\\tuint256 last_update;\\n\\t\\tuint256 integral;\\n\\t}\\n\\n\\t// solhint-disable-next-line\\n\\tfunction deposit_reward_token(address _rewardToken, uint256 _amount) external;\\n\\n\\t// solhint-disable-next-line\\n\\tfunction claim_rewards_for(address _user, address _recipient) external;\\n\\n\\t// // solhint-disable-next-line\\n\\t// function claim_rewards_for(address _user) external;\\n\\n\\t// solhint-disable-next-line\\n\\tfunction deposit(uint256 _value, address _addr) external;\\n\\n\\t// solhint-disable-next-line\\n\\tfunction reward_tokens(uint256 _i) external view returns (address);\\n\\n\\tfunction withdraw(\\n\\t\\tuint256 _value,\\n\\t\\taddress _addr,\\n\\t\\tbool _claim_rewards\\n\\t) external;\\n\\n\\t// solhint-disable-next-line\\n\\tfunction reward_data(address _tokenReward) external view returns (Reward memory);\\n\\n\\tfunction balanceOf(address) external returns (uint256);\\n\\n\\tfunction claimable_reward(address _user, address _reward_token) external view returns (uint256);\\n\\n\\tfunction user_checkpoint(address _user) external returns (bool);\\n\\n\\tfunction commit_transfer_ownership(address) external;\\n\\n\\tfunction initialize(\\n\\t\\taddress _staking_token,\\n\\t\\taddress _admin,\\n\\t\\taddress _SDT,\\n\\t\\taddress _voting_escrow,\\n\\t\\taddress _veBoost_proxy,\\n\\t\\taddress _distributor,\\n\\t\\taddress _vault,\\n\\t\\tstring memory _symbol\\n\\t) external;\\n\\n\\tfunction add_reward(address, address) external;\\n\\n\\tfunction set_claimer(address) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = _allowances[owner][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/strategy/BalancerStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./BaseStrategy.sol\\\";\\nimport \\\"../accumulator/BalancerAccumulator.sol\\\";\\nimport \\\"../interfaces/ILiquidityGauge.sol\\\";\\nimport \\\"../interfaces/IMultiRewards.sol\\\";\\nimport \\\"../staking/SdtDistributorV2.sol\\\";\\n\\ncontract BalancerStrategy is BaseStrategy {\\n\\tusing SafeERC20 for IERC20;\\n\\n\\tBalancerAccumulator public accumulator;\\n\\taddress public sdtDistributor;\\n\\taddress public constant BAL_MINTER = 0x239e55F427D44C3cc793f49bFB507ebe76638a2b;\\n\\taddress public constant BAL = 0xba100000625a3754423978a60c9317c58a424e3D;\\n\\n\\tstruct ClaimerReward {\\n\\t\\taddress rewardToken;\\n\\t\\tuint256 amount;\\n\\t}\\n\\tenum MANAGEFEE {\\n\\t\\tPERFFEE,\\n\\t\\tVESDTFEE,\\n\\t\\tACCUMULATORFEE,\\n\\t\\tCLAIMERREWARD\\n\\t}\\n\\n\\t/* ========== CONSTRUCTOR ========== */\\n\\tconstructor(\\n\\t\\tILocker _locker,\\n\\t\\taddress _governance,\\n\\t\\taddress _receiver,\\n\\t\\tBalancerAccumulator _accumulator,\\n\\t\\taddress _veSDTFeeProxy,\\n\\t\\taddress _sdtDistributor\\n\\t) BaseStrategy(_locker, _governance, _receiver) {\\n\\t\\taccumulator = _accumulator;\\n\\t\\tveSDTFeeProxy = _veSDTFeeProxy;\\n\\t\\tsdtDistributor = _sdtDistributor;\\n\\t}\\n\\n\\t/* ========== MUTATIVE FUNCTIONS ========== */\\n\\t/// @notice function to deposit into a gauge\\n\\t/// @param _token token address\\n\\t/// @param _amount amount to deposit\\n\\tfunction deposit(address _token, uint256 _amount) external override onlyApprovedVault {\\n\\t\\tIERC20(_token).transferFrom(msg.sender, address(locker), _amount);\\n\\t\\taddress gauge = gauges[_token];\\n\\t\\trequire(gauge != address(0), \\\"!gauge\\\");\\n\\t\\tlocker.execute(_token, 0, abi.encodeWithSignature(\\\"approve(address,uint256)\\\", gauge, 0));\\n\\t\\tlocker.execute(_token, 0, abi.encodeWithSignature(\\\"approve(address,uint256)\\\", gauge, _amount));\\n\\n\\t\\t(bool success, ) = locker.execute(gauge, 0, abi.encodeWithSignature(\\\"deposit(uint256)\\\", _amount));\\n\\t\\trequire(success, \\\"Deposit failed!\\\");\\n\\t\\temit Deposited(gauge, _token, _amount);\\n\\t}\\n\\n\\t/// @notice function to withdraw from a gauge\\n\\t/// @param _token token address\\n\\t/// @param _amount amount to withdraw\\n\\tfunction withdraw(address _token, uint256 _amount) external override onlyApprovedVault {\\n\\t\\tuint256 _before = IERC20(_token).balanceOf(address(locker));\\n\\t\\taddress gauge = gauges[_token];\\n\\t\\trequire(gauge != address(0), \\\"!gauge\\\");\\n\\t\\t(bool success, ) = locker.execute(gauge, 0, abi.encodeWithSignature(\\\"withdraw(uint256)\\\", _amount));\\n\\t\\trequire(success, \\\"Transfer failed!\\\");\\n\\t\\tuint256 _after = IERC20(_token).balanceOf(address(locker));\\n\\n\\t\\tuint256 _net = _after - _before;\\n\\t\\t(success, ) = locker.execute(_token, 0, abi.encodeWithSignature(\\\"transfer(address,uint256)\\\", msg.sender, _net));\\n\\t\\trequire(success, \\\"Transfer failed!\\\");\\n\\t\\temit Withdrawn(gauge, _token, _amount);\\n\\t}\\n\\n\\t/// @notice function to send funds into the related accumulator\\n\\t/// @param _token token address\\n\\t/// @param _amount amount to send\\n\\tfunction sendToAccumulator(address _token, uint256 _amount) external onlyGovernance {\\n\\t\\tIERC20(_token).approve(address(accumulator), _amount);\\n\\t\\taccumulator.depositToken(_token, _amount);\\n\\t}\\n\\n\\t/// @notice function to claim the reward and distribute it\\n\\t/// @param _token BPT token address\\n\\tfunction claim(address _token) external override {\\n\\t\\taddress gauge = gauges[_token];\\n\\t\\trequire(gauge != address(0), \\\"!gauge\\\");\\n\\n\\t\\tuint256 balBeforeClaim = IERC20(BAL).balanceOf(address(locker));\\n\\n\\t\\t// Claim BAL\\n\\t\\t// within the mint() it calls the user checkpoint\\n\\t\\t(bool success, ) = locker.execute(\\n\\t\\t\\tBAL_MINTER,\\n\\t\\t\\t0,\\n\\t\\t\\tabi.encodeWithSignature(\\\"mint(address)\\\", gauge)\\n\\t\\t);\\t\\n\\t\\trequire(success, \\\"BAL mint failed!\\\");\\n\\n\\t\\tuint256 balMinted = IERC20(BAL).balanceOf(address(locker)) - balBeforeClaim;\\n\\t\\t\\n\\t\\t// Send BAL here\\n\\t\\t(success, ) = locker.execute(\\n\\t\\t\\tBAL,\\n\\t\\t\\t0,\\n\\t\\t\\tabi.encodeWithSignature(\\\"transfer(address,uint256)\\\", address(this), balMinted)\\n\\t\\t);\\n\\t\\trequire(success, \\\"BAL transfer failed!\\\");\\n\\n\\t\\t// Distribute BAL\\n\\t\\tuint256 balNetRewards = sendFee(gauge, balMinted);\\n\\t\\tIERC20(BAL).approve(multiGauges[gauge], balNetRewards);\\n\\t\\tILiquidityGauge(multiGauges[gauge]).deposit_reward_token(BAL, balNetRewards);\\n\\t\\temit Claimed(gauge, BAL, balMinted);\\n\\n\\t\\t// Distribute SDT to the related gauge\\n\\t\\tSdtDistributorV2(sdtDistributor).distribute(multiGauges[gauge]);\\n\\n\\t\\t// Claim rewards only if there is at least one extra reward\\n\\t\\tif(ILiquidityGauge(gauge).reward_tokens(0) != address(0)) {\\n\\t\\t\\t(success, ) = locker.execute(\\n\\t\\t\\t\\tgauge, 0, abi.encodeWithSignature(\\\"claim_rewards(address,address)\\\", address(locker), address(this))\\n\\t\\t\\t);\\n\\t\\t\\taddress rewardToken;\\n\\t\\t\\tuint256 rewardsBalance;\\n\\t\\t\\tfor (uint8 i = 0; i < 8; i++) {\\n\\t\\t\\t\\trewardToken = ILiquidityGauge(gauge).reward_tokens(i);\\n\\t\\t\\t\\tif (rewardToken == address(0)) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n                rewardsBalance = IERC20(rewardToken).balanceOf(address(this));\\n\\t\\t\\t\\tIERC20(rewardToken).approve(multiGauges[gauge], rewardsBalance);\\n\\t\\t\\t\\tILiquidityGauge(multiGauges[gauge]).deposit_reward_token(rewardToken, rewardsBalance);\\n\\t\\t\\t\\temit Claimed(gauge, rewardToken, rewardsBalance);\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice internal function for distributing fees to recipients \\n\\t/// @param _gauge gauge address\\n\\t/// @param _rewardsBalance total balance to distribute\\n\\tfunction sendFee(address _gauge, uint256 _rewardsBalance) internal returns(uint256) {\\n\\t\\t// calculate the amount for each fee recipient\\n\\t\\tuint256 multisigFee = (_rewardsBalance * perfFee[_gauge]) / BASE_FEE;\\n\\t\\tuint256 accumulatorPart = (_rewardsBalance * accumulatorFee[_gauge]) / BASE_FEE;\\n\\t\\tuint256 veSDTPart = (_rewardsBalance * veSDTFee[_gauge]) / BASE_FEE;\\n\\t\\tuint256 claimerPart = (_rewardsBalance * claimerRewardFee[_gauge]) / BASE_FEE;\\n\\t\\t// send \\n\\t\\tIERC20(BAL).approve(address(accumulator), accumulatorPart);\\n\\t\\taccumulator.depositToken(BAL, accumulatorPart);\\n\\t\\tIERC20(BAL).transfer(rewardsReceiver, multisigFee);\\n\\t\\tIERC20(BAL).transfer(veSDTFeeProxy, veSDTPart);\\n\\t\\tIERC20(BAL).transfer(msg.sender, claimerPart);\\n\\t\\treturn _rewardsBalance - multisigFee - accumulatorPart - veSDTPart - claimerPart;\\n\\t}\\n\\n\\t/// @notice function to toggle a vault\\n\\t/// @param _vault vault address\\n\\tfunction toggleVault(address _vault) external override onlyGovernanceOrFactory {\\n\\t\\trequire(_vault != address(0), \\\"zero address\\\");\\n\\t\\tvaults[_vault] = !vaults[_vault];\\n\\t\\temit VaultToggled(_vault, vaults[_vault]);\\n\\t}\\n\\n\\t/// @notice function to set a new gauge\\n\\t/// It permits to set it as address(0), for disabling it\\n\\t/// @param _token token address\\n\\t/// @param _gauge gauge address\\n\\tfunction setGauge(address _token, address _gauge) external override onlyGovernanceOrFactory {\\n\\t\\trequire(_token != address(0), \\\"zero address\\\");\\n\\t\\t// Set new gauge\\n\\t\\tgauges[_token] = _gauge;\\n\\t\\temit GaugeSet(_gauge, _token);\\n\\t}\\n\\n\\t/// @notice function to set a multi gauge\\n\\t/// @param _gauge gauge address\\n\\t/// @param _multiGauge multi gauge address\\n\\tfunction setMultiGauge(address _gauge, address _multiGauge) external override onlyGovernanceOrFactory {\\n\\t\\trequire(_gauge != address(0), \\\"zero address\\\");\\n\\t\\trequire(_multiGauge != address(0), \\\"zero address\\\");\\n\\t\\tmultiGauges[_gauge] = _multiGauge;\\n\\t}\\n\\n\\t/// @notice function to set a new veSDTProxy\\n\\t/// @param _newVeSDTProxy veSdtProxy address\\n\\tfunction setVeSDTProxy(address _newVeSDTProxy) external onlyGovernance {\\n\\t\\trequire(_newVeSDTProxy != address(0), \\\"zero address\\\");\\n\\t\\tveSDTFeeProxy = _newVeSDTProxy;\\n\\t}\\n\\n\\t/// @notice function to set a new accumulator\\n\\t/// @param _newAccumulator accumulator address\\n\\tfunction setAccumulator(address _newAccumulator) external onlyGovernance {\\n\\t\\trequire(_newAccumulator != address(0), \\\"zero address\\\");\\n\\t\\taccumulator = BalancerAccumulator(_newAccumulator);\\n\\t}\\n\\n\\t/// @notice function to set a new reward receiver\\n\\t/// @param _newRewardsReceiver reward receiver address\\n\\tfunction setRewardsReceiver(address _newRewardsReceiver) external onlyGovernance {\\n\\t\\trequire(_newRewardsReceiver != address(0), \\\"zero address\\\");\\n\\t\\trewardsReceiver = _newRewardsReceiver;\\n\\t}\\n\\n\\t/// @notice function to set a new governance address\\n\\t/// @param _newGovernance governance address\\n\\tfunction setGovernance(address _newGovernance) external onlyGovernance {\\n\\t\\trequire(_newGovernance != address(0), \\\"zero address\\\");\\n\\t\\tgovernance = _newGovernance;\\n\\t}\\n\\n\\t/// @notice function to set the vault/gauge factory\\n\\t/// @param _newVaultGaugeFactory factory address\\n\\tfunction setVaultGaugeFactory(address _newVaultGaugeFactory) external onlyGovernance {\\n\\t\\trequire(_newVaultGaugeFactory != address(0), \\\"zero address\\\");\\n\\t\\tvaultGaugeFactory = _newVaultGaugeFactory;\\n\\t}\\n\\n\\t/// @notice function to set new fees\\n\\t/// @param _manageFee manageFee\\n\\t/// @param _gauge gauge address\\n\\t/// @param _newFee new fee to set\\n\\tfunction manageFee(\\n\\t\\tMANAGEFEE _manageFee,\\n\\t\\taddress _gauge,\\n\\t\\tuint256 _newFee\\n\\t) external onlyGovernanceOrFactory {\\n\\t\\trequire(_gauge != address(0), \\\"zero address\\\");\\n\\t\\tif (_manageFee == MANAGEFEE.PERFFEE) {\\n\\t\\t\\t// 0\\n\\t\\t\\tperfFee[_gauge] = _newFee;\\n\\t\\t} else if (_manageFee == MANAGEFEE.VESDTFEE) {\\n\\t\\t\\t// 1\\n\\t\\t\\tveSDTFee[_gauge] = _newFee;\\n\\t\\t} else if (_manageFee == MANAGEFEE.ACCUMULATORFEE) {\\n\\t\\t\\t//2\\n\\t\\t\\taccumulatorFee[_gauge] = _newFee;\\n\\t\\t} else if (_manageFee == MANAGEFEE.CLAIMERREWARD) {\\n\\t\\t\\t// 3\\n\\t\\t\\tclaimerRewardFee[_gauge] = _newFee;\\n\\t\\t}\\n\\t\\trequire(\\n\\t\\t\\tperfFee[_gauge] + \\n\\t\\t\\tveSDTFee[_gauge] + \\n\\t\\t\\taccumulatorFee[_gauge] + \\n\\t\\t\\tclaimerRewardFee[_gauge] \\n\\t\\t\\t<= BASE_FEE, \\\"fee to high\\\"\\n\\t\\t);\\n\\t}\\n\\n\\t/// @notice execute a function\\n\\t/// @param _to Address to sent the value to\\n\\t/// @param _value Value to be sent\\n\\t/// @param _data Call function data\\n\\tfunction execute(\\n\\t\\taddress _to,\\n\\t\\tuint256 _value,\\n\\t\\tbytes calldata _data\\n\\t) external onlyGovernance returns (bool, bytes memory) {\\n\\t\\t(bool success, bytes memory result) = _to.call{ value: _value }(_data);\\n\\t\\treturn (success, result);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/BalancerVault/IBalancerVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.7;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./IAsset.sol\\\";\\nimport \\\"./IAuthorizer.sol\\\";\\nimport \\\"./IFlashLoanRecipient.sol\\\";\\n\\n/**\\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\\n * don't override one of these declarations.\\n */\\ninterface IBalancerVault {\\n\\t// Generalities about the Vault:\\n\\t//\\n\\t// - Whenever documentation refers to 'tokens', it strictly refers to ERC20-compliant token contracts. Tokens are\\n\\t// transferred out of the Vault by calling the `IERC20.transfer` function, and transferred in by calling\\n\\t// `IERC20.transferFrom`. In these cases, the sender must have previously allowed the Vault to use their tokens by\\n\\t// calling `IERC20.approve`. The only deviation from the ERC20 standard that is supported is functions not returning\\n\\t// a boolean value: in these scenarios, a non-reverting call is assumed to be successful.\\n\\t//\\n\\t// - All non-view functions in the Vault are non-reentrant: calling them while another one is mid-execution (e.g.\\n\\t// while execution control is transferred to a token contract during a swap) will result in a revert. View\\n\\t// functions can be called in a re-reentrant way, but doing so might cause them to return inconsistent results.\\n\\t// Contracts calling view functions in the Vault must make sure the Vault has not already been entered.\\n\\t//\\n\\t// - View functions revert if referring to either unregistered Pools, or unregistered tokens for registered Pools.\\n\\n\\t// Authorizer\\n\\t//\\n\\t// Some system actions are permissioned, like setting and collecting protocol fees. This permissioning system exists\\n\\t// outside of the Vault in the Authorizer contract: the Vault simply calls the Authorizer to check if the caller\\n\\t// can perform a given action.\\n\\n\\t/**\\n\\t * @dev Returns the Vault's Authorizer.\\n\\t */\\n\\tfunction getAuthorizer() external view returns (IAuthorizer);\\n\\n\\t/**\\n\\t * @dev Sets a new Authorizer for the Vault. The caller must be allowed by the current Authorizer to do this.\\n\\t *\\n\\t * Emits an `AuthorizerChanged` event.\\n\\t */\\n\\tfunction setAuthorizer(IAuthorizer newAuthorizer) external;\\n\\n\\t/**\\n\\t * @dev Emitted when a new authorizer is set by `setAuthorizer`.\\n\\t */\\n\\tevent AuthorizerChanged(IAuthorizer indexed newAuthorizer);\\n\\n\\t// Relayers\\n\\t//\\n\\t// Additionally, it is possible for an account to perform certain actions on behalf of another one, using their\\n\\t// Vault ERC20 allowance and Internal Balance. These accounts are said to be 'relayers' for these Vault functions,\\n\\t// and are expected to be smart contracts with sound authentication mechanisms. For an account to be able to wield\\n\\t// this power, two things must occur:\\n\\t//  - The Authorizer must grant the account the permission to be a relayer for the relevant Vault function. This\\n\\t//    means that Balancer governance must approve each individual contract to act as a relayer for the intended\\n\\t//    functions.\\n\\t//  - Each user must approve the relayer to act on their behalf.\\n\\t// This double protection means users cannot be tricked into approving malicious relayers (because they will not\\n\\t// have been allowed by the Authorizer via governance), nor can malicious relayers approved by a compromised\\n\\t// Authorizer or governance drain user funds, since they would also need to be approved by each individual user.\\n\\n\\t/**\\n\\t * @dev Returns true if `user` has approved `relayer` to act as a relayer for them.\\n\\t */\\n\\tfunction hasApprovedRelayer(address user, address relayer) external view returns (bool);\\n\\n\\t/**\\n\\t * @dev Allows `relayer` to act as a relayer for `sender` if `approved` is true, and disallows it otherwise.\\n\\t *\\n\\t * Emits a `RelayerApprovalChanged` event.\\n\\t */\\n\\tfunction setRelayerApproval(\\n\\t\\taddress sender,\\n\\t\\taddress relayer,\\n\\t\\tbool approved\\n\\t) external;\\n\\n\\t/**\\n\\t * @dev Emitted every time a relayer is approved or disapproved by `setRelayerApproval`.\\n\\t */\\n\\tevent RelayerApprovalChanged(address indexed relayer, address indexed sender, bool approved);\\n\\n\\t// Internal Balance\\n\\t//\\n\\t// Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\\n\\t// transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\\n\\t// when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\\n\\t// gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\\n\\t//\\n\\t// Internal Balance management features batching, which means a single contract call can be used to perform multiple\\n\\t// operations of different kinds, with different senders and recipients, at once.\\n\\n\\t/**\\n\\t * @dev Returns `user`'s Internal Balance for a set of tokens.\\n\\t */\\n\\tfunction getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\\n\\n\\t/**\\n\\t * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\\n\\t * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\\n\\t * it lets integrators reuse a user's Vault allowance.\\n\\t *\\n\\t * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\\n\\t */\\n\\tfunction manageUserBalance(UserBalanceOp[] memory ops) external payable;\\n\\n\\t/**\\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\\n     without manual WETH wrapping or unwrapping.\\n     */\\n\\tstruct UserBalanceOp {\\n\\t\\tUserBalanceOpKind kind;\\n\\t\\tIAsset asset;\\n\\t\\tuint256 amount;\\n\\t\\taddress sender;\\n\\t\\taddress payable recipient;\\n\\t}\\n\\n\\t// There are four possible operations in `manageUserBalance`:\\n\\t//\\n\\t// - DEPOSIT_INTERNAL\\n\\t// Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\\n\\t// `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\\n\\t//\\n\\t// ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\\n\\t// and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\\n\\t// relevant for relayers).\\n\\t//\\n\\t// Emits an `InternalBalanceChanged` event.\\n\\t//\\n\\t//\\n\\t// - WITHDRAW_INTERNAL\\n\\t// Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\\n\\t//\\n\\t// ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\\n\\t// it to the recipient as ETH.\\n\\t//\\n\\t// Emits an `InternalBalanceChanged` event.\\n\\t//\\n\\t//\\n\\t// - TRANSFER_INTERNAL\\n\\t// Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\\n\\t//\\n\\t// Reverts if the ETH sentinel value is passed.\\n\\t//\\n\\t// Emits an `InternalBalanceChanged` event.\\n\\t//\\n\\t//\\n\\t// - TRANSFER_EXTERNAL\\n\\t// Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\\n\\t// relayers, as it lets them reuse a user's Vault allowance.\\n\\t//\\n\\t// Reverts if the ETH sentinel value is passed.\\n\\t//\\n\\t// Emits an `ExternalBalanceTransfer` event.\\n\\n\\tenum UserBalanceOpKind {\\n\\t\\tDEPOSIT_INTERNAL,\\n\\t\\tWITHDRAW_INTERNAL,\\n\\t\\tTRANSFER_INTERNAL,\\n\\t\\tTRANSFER_EXTERNAL\\n\\t}\\n\\n\\t/**\\n\\t * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\\n\\t * interacting with Pools using Internal Balance.\\n\\t *\\n\\t * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\\n\\t * address.\\n\\t */\\n\\tevent InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\\n\\n\\t/**\\n\\t * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\\n\\t */\\n\\tevent ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\\n\\n\\t// Pools\\n\\t//\\n\\t// There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\\n\\t// functionality:\\n\\t//\\n\\t//  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\\n\\t// balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\\n\\t// which increase with the number of registered tokens.\\n\\t//\\n\\t//  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\\n\\t// balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\\n\\t// constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\\n\\t// independent of the number of registered tokens.\\n\\t//\\n\\t//  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\\n\\t// minimal swap info Pools, these are called via IMinimalSwapInfoPool.\\n\\n\\tenum PoolSpecialization {\\n\\t\\tGENERAL,\\n\\t\\tMINIMAL_SWAP_INFO,\\n\\t\\tTWO_TOKEN\\n\\t}\\n\\n\\t/**\\n\\t * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\\n\\t * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\\n\\t * changed.\\n\\t *\\n\\t * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\\n\\t * depending on the chosen specialization setting. This contract is known as the Pool's contract.\\n\\t *\\n\\t * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\\n\\t * multiple Pools may share the same contract.\\n\\t *\\n\\t * Emits a `PoolRegistered` event.\\n\\t */\\n\\tfunction registerPool(PoolSpecialization specialization) external returns (bytes32);\\n\\n\\t/**\\n\\t * @dev Emitted when a Pool is registered by calling `registerPool`.\\n\\t */\\n\\tevent PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\\n\\n\\t/**\\n\\t * @dev Returns a Pool's contract address and specialization setting.\\n\\t */\\n\\tfunction getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\\n\\n\\t/**\\n\\t * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n\\t *\\n\\t * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\\n\\t * exit by receiving registered tokens, and can only swap registered tokens.\\n\\t *\\n\\t * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\\n\\t * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\\n\\t * ascending order.\\n\\t *\\n\\t * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\\n\\t * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\\n\\t * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\\n\\t * expected to be highly secured smart contracts with sound design principles, and the decision to register an\\n\\t * Asset Manager should not be made lightly.\\n\\t *\\n\\t * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\\n\\t * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\\n\\t * different Asset Manager.\\n\\t *\\n\\t * Emits a `TokensRegistered` event.\\n\\t */\\n\\tfunction registerTokens(\\n\\t\\tbytes32 poolId,\\n\\t\\tIERC20[] memory tokens,\\n\\t\\taddress[] memory assetManagers\\n\\t) external;\\n\\n\\t/**\\n\\t * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\\n\\t */\\n\\tevent TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\\n\\n\\t/**\\n\\t * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n\\t *\\n\\t * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\\n\\t * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\\n\\t * must be deregistered in the same `deregisterTokens` call.\\n\\t *\\n\\t * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\\n\\t *\\n\\t * Emits a `TokensDeregistered` event.\\n\\t */\\n\\tfunction deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;\\n\\n\\t/**\\n\\t * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\\n\\t */\\n\\tevent TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\\n\\n\\t/**\\n\\t * @dev Returns detailed information for a Pool's registered token.\\n\\t *\\n\\t * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\\n\\t * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\\n\\t * equals the sum of `cash` and `managed`.\\n\\t *\\n\\t * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\\n\\t * `managed` or `total` balance to be greater than 2^112 - 1.\\n\\t *\\n\\t * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\\n\\t * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\\n\\t * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\\n\\t * change for this purpose, and will update `lastChangeBlock`.\\n\\t *\\n\\t * `assetManager` is the Pool's token Asset Manager.\\n\\t */\\n\\tfunction getPoolTokenInfo(bytes32 poolId, IERC20 token)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tuint256 cash,\\n\\t\\t\\tuint256 managed,\\n\\t\\t\\tuint256 lastChangeBlock,\\n\\t\\t\\taddress assetManager\\n\\t\\t);\\n\\n\\t/**\\n\\t * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\\n\\t * the tokens' `balances` changed.\\n\\t *\\n\\t * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\\n\\t * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\\n\\t *\\n\\t * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\\n\\t * order as passed to `registerTokens`.\\n\\t *\\n\\t * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\\n\\t * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\\n\\t * instead.\\n\\t */\\n\\tfunction getPoolTokens(bytes32 poolId)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tIERC20[] memory tokens,\\n\\t\\t\\tuint256[] memory balances,\\n\\t\\t\\tuint256 lastChangeBlock\\n\\t\\t);\\n\\n\\t/**\\n\\t * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\\n\\t * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\\n\\t * Pool shares.\\n\\t *\\n\\t * If the caller is not `sender`, it must be an authorized relayer for them.\\n\\t *\\n\\t * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\\n\\t * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\\n\\t * these maximums.\\n\\t *\\n\\t * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\\n\\t * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\\n\\t * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\\n\\t * back to the caller (not the sender, which is important for relayers).\\n\\t *\\n\\t * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n\\t * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\\n\\t * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\\n\\t * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\\n\\t *\\n\\t * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\\n\\t * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\\n\\t * withdrawn from Internal Balance: attempting to do so will trigger a revert.\\n\\t *\\n\\t * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\\n\\t * their own custom logic. This typically requires additional information from the user (such as the expected number\\n\\t * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\\n\\t * directly to the Pool's contract, as is `recipient`.\\n\\t *\\n\\t * Emits a `PoolBalanceChanged` event.\\n\\t */\\n\\tfunction joinPool(\\n\\t\\tbytes32 poolId,\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tJoinPoolRequest memory request\\n\\t) external payable;\\n\\n\\tstruct JoinPoolRequest {\\n\\t\\taddress[] assets;\\n\\t\\tuint256[] maxAmountsIn;\\n\\t\\tbytes userData;\\n\\t\\tbool fromInternalBalance;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\\n\\t * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\\n\\t * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\\n\\t * `getPoolTokenInfo`).\\n\\t *\\n\\t * If the caller is not `sender`, it must be an authorized relayer for them.\\n\\t *\\n\\t * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\\n\\t * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\\n\\t * it just enforces these minimums.\\n\\t *\\n\\t * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\\n\\t * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\\n\\t * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\\n\\t *\\n\\t * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n\\t * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\\n\\t * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\\n\\t * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\\n\\t *\\n\\t * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\\n\\t * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\\n\\t * do so will trigger a revert.\\n\\t *\\n\\t * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\\n\\t * `tokens` array. This array must match the Pool's registered tokens.\\n\\t *\\n\\t * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\\n\\t * their own custom logic. This typically requires additional information from the user (such as the expected number\\n\\t * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\\n\\t * passed directly to the Pool's contract.\\n\\t *\\n\\t * Emits a `PoolBalanceChanged` event.\\n\\t */\\n\\tfunction exitPool(\\n\\t\\tbytes32 poolId,\\n\\t\\taddress sender,\\n\\t\\taddress payable recipient,\\n\\t\\tExitPoolRequest memory request\\n\\t) external;\\n\\n\\tstruct ExitPoolRequest {\\n\\t\\tIAsset[] assets;\\n\\t\\tuint256[] minAmountsOut;\\n\\t\\tbytes userData;\\n\\t\\tbool toInternalBalance;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\\n\\t */\\n\\tevent PoolBalanceChanged(\\n\\t\\tbytes32 indexed poolId,\\n\\t\\taddress indexed liquidityProvider,\\n\\t\\tIERC20[] tokens,\\n\\t\\tint256[] deltas,\\n\\t\\tuint256[] protocolFeeAmounts\\n\\t);\\n\\n\\tenum PoolBalanceChangeKind {\\n\\t\\tJOIN,\\n\\t\\tEXIT\\n\\t}\\n\\n\\t// Swaps\\n\\t//\\n\\t// Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\\n\\t// they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\\n\\t// aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\\n\\t//\\n\\t// The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\\n\\t// In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\\n\\t// and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\\n\\t// More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\\n\\t// individual swaps.\\n\\t//\\n\\t// There are two swap kinds:\\n\\t//  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\\n\\t// `onSwap` hook) the amount of tokens out (to send to the recipient).\\n\\t//  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\\n\\t// (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\\n\\t//\\n\\t// Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\\n\\t// the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\\n\\t// tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\\n\\t// swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\\n\\t// the final intended token.\\n\\t//\\n\\t// In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\\n\\t// Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\\n\\t// certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\\n\\t// much less gas than they would otherwise.\\n\\t//\\n\\t// It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\\n\\t// Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\\n\\t// updating the Pool's internal accounting).\\n\\t//\\n\\t// To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\\n\\t// involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\\n\\t// minimum amount of tokens to receive (by passing a negative value) is specified.\\n\\t//\\n\\t// Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\\n\\t// this point in time (e.g. if the transaction failed to be included in a block promptly).\\n\\t//\\n\\t// If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\\n\\t// the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\\n\\t// passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\\n\\t// same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\\n\\t//\\n\\t// Finally, Internal Balance can be used when either sending or receiving tokens.\\n\\n\\tenum SwapKind {\\n\\t\\tGIVEN_IN,\\n\\t\\tGIVEN_OUT\\n\\t}\\n\\n\\t/**\\n\\t * @dev Performs a swap with a single Pool.\\n\\t *\\n\\t * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\\n\\t * taken from the Pool, which must be greater than or equal to `limit`.\\n\\t *\\n\\t * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\\n\\t * sent to the Pool, which must be less than or equal to `limit`.\\n\\t *\\n\\t * Internal Balance usage and the recipient are determined by the `funds` struct.\\n\\t *\\n\\t * Emits a `Swap` event.\\n\\t */\\n\\tfunction swap(\\n\\t\\tSingleSwap memory singleSwap,\\n\\t\\tFundManagement memory funds,\\n\\t\\tuint256 limit,\\n\\t\\tuint256 deadline\\n\\t) external payable returns (uint256);\\n\\n\\t/**\\n\\t * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\\n\\t * the `kind` value.\\n\\t *\\n\\t * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\\n\\t * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\\n\\t *\\n\\t * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n\\t * used to extend swap behavior.\\n\\t */\\n\\tstruct SingleSwap {\\n\\t\\tbytes32 poolId;\\n\\t\\tSwapKind kind;\\n\\t\\tIAsset assetIn;\\n\\t\\tIAsset assetOut;\\n\\t\\tuint256 amount;\\n\\t\\tbytes userData;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\\n\\t * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\\n\\t *\\n\\t * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\\n\\t * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\\n\\t * the same index in the `assets` array.\\n\\t *\\n\\t * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\\n\\t * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\\n\\t * `amountOut` depending on the swap kind.\\n\\t *\\n\\t * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\\n\\t * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\\n\\t * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\\n\\t *\\n\\t * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\\n\\t * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\\n\\t * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\\n\\t * or unwrapped from WETH by the Vault.\\n\\t *\\n\\t * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\\n\\t * the minimum or maximum amount of each token the vault is allowed to transfer.\\n\\t *\\n\\t * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\\n\\t * equivalent `swap` call.\\n\\t *\\n\\t * Emits `Swap` events.\\n\\t */\\n\\tfunction batchSwap(\\n\\t\\tSwapKind kind,\\n\\t\\tBatchSwapStep[] memory swaps,\\n\\t\\tIAsset[] memory assets,\\n\\t\\tFundManagement memory funds,\\n\\t\\tint256[] memory limits,\\n\\t\\tuint256 deadline\\n\\t) external payable returns (int256[] memory);\\n\\n\\t/**\\n\\t * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\\n\\t * `assets` array passed to that function, and ETH assets are converted to WETH.\\n\\t *\\n\\t * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\\n\\t * from the previous swap, depending on the swap kind.\\n\\t *\\n\\t * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n\\t * used to extend swap behavior.\\n\\t */\\n\\tstruct BatchSwapStep {\\n\\t\\tbytes32 poolId;\\n\\t\\tuint256 assetInIndex;\\n\\t\\tuint256 assetOutIndex;\\n\\t\\tuint256 amount;\\n\\t\\tbytes userData;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\\n\\t */\\n\\tevent Swap(\\n\\t\\tbytes32 indexed poolId,\\n\\t\\tIERC20 indexed tokenIn,\\n\\t\\tIERC20 indexed tokenOut,\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOut\\n\\t);\\n\\n\\t/**\\n\\t * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\\n\\t * `recipient` account.\\n\\t *\\n\\t * If the caller is not `sender`, it must be an authorized relayer for them.\\n\\t *\\n\\t * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\\n\\t * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\\n\\t * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\\n\\t * `joinPool`.\\n\\t *\\n\\t * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\\n\\t * transferred. This matches the behavior of `exitPool`.\\n\\t *\\n\\t * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\\n\\t * revert.\\n\\t */\\n\\tstruct FundManagement {\\n\\t\\taddress sender;\\n\\t\\tbool fromInternalBalance;\\n\\t\\taddress payable recipient;\\n\\t\\tbool toInternalBalance;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\\n\\t * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\\n\\t *\\n\\t * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\\n\\t * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\\n\\t * receives are the same that an equivalent `batchSwap` call would receive.\\n\\t *\\n\\t * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\\n\\t * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\\n\\t * approve them for the Vault, or even know a user's address.\\n\\t *\\n\\t * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\\n\\t * eth_call instead of eth_sendTransaction.\\n\\t */\\n\\tfunction queryBatchSwap(\\n\\t\\tSwapKind kind,\\n\\t\\tBatchSwapStep[] memory swaps,\\n\\t\\tIAsset[] memory assets,\\n\\t\\tFundManagement memory funds\\n\\t) external returns (int256[] memory assetDeltas);\\n\\n\\t// Flash Loans\\n\\n\\t/**\\n\\t * @dev Performs a 'flash loan', sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it,\\n\\t * and then reverting unless the tokens plus a proportional protocol fee have been returned.\\n\\t *\\n\\t * The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount\\n\\t * for each token contract. `tokens` must be sorted in ascending order.\\n\\t *\\n\\t * The 'userData' field is ignored by the Vault, and forwarded as-is to `recipient` as part of the\\n\\t * `receiveFlashLoan` call.\\n\\t *\\n\\t * Emits `FlashLoan` events.\\n\\t */\\n\\tfunction flashLoan(\\n\\t\\tIFlashLoanRecipient recipient,\\n\\t\\tIERC20[] memory tokens,\\n\\t\\tuint256[] memory amounts,\\n\\t\\tbytes memory userData\\n\\t) external;\\n\\n\\t/**\\n\\t * @dev Emitted for each individual flash loan performed by `flashLoan`.\\n\\t */\\n\\tevent FlashLoan(IFlashLoanRecipient indexed recipient, IERC20 indexed token, uint256 amount, uint256 feeAmount);\\n\\n\\t// Asset Management\\n\\t//\\n\\t// Each token registered for a Pool can be assigned an Asset Manager, which is able to freely withdraw the Pool's\\n\\t// tokens from the Vault, deposit them, or assign arbitrary values to its `managed` balance (see\\n\\t// `getPoolTokenInfo`). This makes them extremely powerful and dangerous. Even if an Asset Manager only directly\\n\\t// controls one of the tokens in a Pool, a malicious manager could set that token's balance to manipulate the\\n\\t// prices of the other tokens, and then drain the Pool with swaps. The risk of using Asset Managers is therefore\\n\\t// not constrained to the tokens they are managing, but extends to the entire Pool's holdings.\\n\\t//\\n\\t// However, a properly designed Asset Manager smart contract can be safely used for the Pool's benefit,\\n\\t// for example by lending unused tokens out for interest, or using them to participate in voting protocols.\\n\\t//\\n\\t// This concept is unrelated to the IAsset interface.\\n\\n\\t/**\\n\\t * @dev Performs a set of Pool balance operations, which may be either withdrawals, deposits or updates.\\n\\t *\\n\\t * Pool Balance management features batching, which means a single contract call can be used to perform multiple\\n\\t * operations of different kinds, with different Pools and tokens, at once.\\n\\t *\\n\\t * For each operation, the caller must be registered as the Asset Manager for `token` in `poolId`.\\n\\t */\\n\\tfunction managePoolBalance(PoolBalanceOp[] memory ops) external;\\n\\n\\tstruct PoolBalanceOp {\\n\\t\\tPoolBalanceOpKind kind;\\n\\t\\tbytes32 poolId;\\n\\t\\tIERC20 token;\\n\\t\\tuint256 amount;\\n\\t}\\n\\n\\t/**\\n\\t * Withdrawals decrease the Pool's cash, but increase its managed balance, leaving the total balance unchanged.\\n\\t *\\n\\t * Deposits increase the Pool's cash, but decrease its managed balance, leaving the total balance unchanged.\\n\\t *\\n\\t * Updates don't affect the Pool's cash balance, but because the managed balance changes, it does alter the total.\\n\\t * The external amount can be either increased or decreased by this call (i.e., reporting a gain or a loss).\\n\\t */\\n\\tenum PoolBalanceOpKind {\\n\\t\\tWITHDRAW,\\n\\t\\tDEPOSIT,\\n\\t\\tUPDATE\\n\\t}\\n\\n\\t/**\\n\\t * @dev Emitted when a Pool's token Asset Manager alters its balance via `managePoolBalance`.\\n\\t */\\n\\tevent PoolBalanceManaged(\\n\\t\\tbytes32 indexed poolId,\\n\\t\\taddress indexed assetManager,\\n\\t\\tIERC20 indexed token,\\n\\t\\tint256 cashDelta,\\n\\t\\tint256 managedDelta\\n\\t);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBalancerPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\npragma experimental ABIEncoderV2;\\n\\ninterface IBalancerPool {\\n\\tfunction getPoolId() external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/strategy/BaseStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\nimport \\\"../interfaces/ILocker.sol\\\";\\n\\ncontract BaseStrategy {\\n\\t/* ========== STATE VARIABLES ========== */\\n\\tILocker public locker;\\n\\taddress public governance;\\n\\taddress public rewardsReceiver;\\n\\taddress public veSDTFeeProxy;\\n\\taddress public vaultGaugeFactory;\\n\\tuint256 public constant BASE_FEE = 10_000;\\n\\tmapping(address => address) public gauges;\\n\\tmapping(address => bool) public vaults;\\n\\tmapping(address => uint256) public perfFee;\\n\\tmapping(address => address) public multiGauges;\\n\\tmapping(address => uint256) public accumulatorFee; // gauge -> fee\\n\\tmapping(address => uint256) public claimerRewardFee; // gauge -> fee\\n\\tmapping(address => uint256) public veSDTFee; // gauge -> fee\\n\\n\\t/* ========== EVENTS ========== */\\n\\tevent Deposited(address _gauge, address _token, uint256 _amount);\\n\\tevent Withdrawn(address _gauge, address _token, uint256 _amount);\\n\\tevent Claimed(address _gauge, address _token, uint256 _amount);\\n\\tevent RewardReceiverSet(address _gauge, address _receiver);\\n\\tevent VaultToggled(address _vault, bool _newState);\\n\\tevent GaugeSet(address _gauge, address _token);\\n\\n\\t/* ========== MODIFIERS ========== */\\n\\tmodifier onlyGovernance() {\\n\\t\\trequire(msg.sender == governance, \\\"!governance\\\");\\n\\t\\t_;\\n\\t}\\n\\tmodifier onlyApprovedVault() {\\n\\t\\trequire(vaults[msg.sender], \\\"!approved vault\\\");\\n\\t\\t_;\\n\\t}\\n\\tmodifier onlyGovernanceOrFactory() {\\n\\t\\trequire(msg.sender == governance || msg.sender == vaultGaugeFactory, \\\"!governance && !factory\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\t/* ========== CONSTRUCTOR ========== */\\n\\tconstructor(\\n\\t\\tILocker _locker,\\n\\t\\taddress _governance,\\n\\t\\taddress _receiver\\n\\t) {\\n\\t\\tlocker = _locker;\\n\\t\\tgovernance = _governance;\\n\\t\\trewardsReceiver = _receiver;\\n\\t}\\n\\n\\t/* ========== MUTATIVE FUNCTIONS ========== */\\n\\tfunction deposit(address _token, uint256 _amount) external virtual onlyApprovedVault {}\\n\\n\\tfunction withdraw(address _token, uint256 _amount) external virtual onlyApprovedVault {}\\n\\n\\tfunction claim(address _gauge) external virtual {}\\n\\n\\tfunction toggleVault(address _vault) external virtual onlyGovernanceOrFactory {}\\n\\n\\tfunction setGauge(address _token, address _gauge) external virtual onlyGovernanceOrFactory {}\\n\\n\\tfunction setMultiGauge(address _gauge, address _multiGauge) external virtual onlyGovernanceOrFactory {}\\n}\\n\"\r\n    },\r\n    \"contracts/accumulator/BalancerAccumulator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport \\\"./BaseAccumulator.sol\\\";\\n\\n/// @title A contract that accumulates rewards and notifies them to the LGV4\\n/// @author StakeDAO\\ncontract BalancerAccumulator is BaseAccumulator {\\n\\taddress[] public tokenData;\\n\\n\\t/* ========== CONSTRUCTOR ========== */\\n\\tconstructor(address _tokenReward, address _gauge) BaseAccumulator(_tokenReward, _gauge) {}\\n\\n\\t/* ========== MUTATIVE FUNCTIONS ========== */\\n\\t/// @notice Claims rewards from the locker and notifies it to the LGV4\\n\\t/// @param _amount amount to notify\\n\\tfunction claimAndNotify(uint256 _amount) external {\\n\\t\\trequire(locker != address(0), \\\"locker not set\\\");\\n\\t\\tILocker(locker).claimRewards(tokenReward, address(this));\\n\\t\\t_notifyReward(tokenReward, _amount);\\n\\t\\t_distributeSDT();\\n\\t}\\n\\n\\t/// @notice Claims rewards from the locker and notify all to the LGV4\\n\\tfunction claimAndNotifyAll() external {\\n\\t\\trequire(locker != address(0), \\\"locker not set\\\");\\n\\t\\tILocker(locker).claimRewards(tokenReward, address(this));\\n\\t\\tuint256 amount = IERC20(tokenReward).balanceOf(address(this));\\n\\t\\t_notifyReward(tokenReward, amount);\\n\\t\\t_distributeSDT();\\n\\t}\\n\\n\\t/// @notice Claims rewards from the locker and notify all to the LGV4\\n\\tfunction claimAllRewardsAndNotify() external {\\n\\t\\trequire(locker != address(0), \\\"locker not set\\\");\\n\\t\\tILocker(locker).claimAllRewards(tokenData, address(this));\\n\\t\\t_notifyAllExtraReward(tokenData);\\n\\t}\\n\\n\\tfunction addReward(address token) external {\\n\\t\\trequire(msg.sender == governance, \\\"!gov\\\");\\n\\t\\ttokenData.push(token);\\n\\t}\\n\\n\\tfunction setTokenRewards(address[] calldata tokens) external {\\n\\t\\trequire(msg.sender == governance, \\\"!gov\\\");\\n\\t\\ttokenData = tokens;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILiquidityGauge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.7;\\n\\ninterface ILiquidityGauge {\\n\\tstruct Reward {\\n\\t\\taddress token;\\n\\t\\taddress distributor;\\n\\t\\tuint256 period_finish;\\n\\t\\tuint256 rate;\\n\\t\\tuint256 last_update;\\n\\t\\tuint256 integral;\\n\\t}\\n\\n\\t// solhint-disable-next-line\\n\\tfunction deposit_reward_token(address _rewardToken, uint256 _amount) external;\\n\\n\\t// solhint-disable-next-line\\n\\tfunction claim_rewards_for(address _user, address _recipient) external;\\n\\n\\t// // solhint-disable-next-line\\n\\t// function claim_rewards_for(address _user) external;\\n\\n\\t// solhint-disable-next-line\\n\\tfunction deposit(uint256 _value, address _addr) external;\\n\\n\\t// solhint-disable-next-line\\n\\tfunction reward_tokens(uint256 _i) external view returns (address);\\n\\n\\t// solhint-disable-next-line\\n\\tfunction reward_data(address _tokenReward) external view returns (Reward memory);\\n\\n\\tfunction balanceOf(address) external returns (uint256);\\n\\n\\tfunction claimable_reward(address _user, address _reward_token) external view returns (uint256);\\n\\n\\tfunction claimable_tokens(address _user) external returns (uint256);\\n\\n\\tfunction user_checkpoint(address _user) external returns (bool);\\n\\n\\tfunction commit_transfer_ownership(address) external;\\n\\n\\tfunction claim_rewards(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMultiRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\ninterface IMultiRewards {\\n\\tfunction balanceOf(address) external returns (uint256);\\n\\n\\tfunction stakeFor(address, uint256) external;\\n\\n\\tfunction withdrawFor(address, uint256) external;\\n\\n\\tfunction notifyRewardAmount(address, uint256) external;\\n\\n\\tfunction mintFor(address recipient, uint256 amount) external;\\n\\n\\tfunction burnFrom(address _from, uint256 _amount) external;\\n\\n\\tfunction stakeOf(address account) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/SdtDistributorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.7;\\n\\nimport \\\"./SdtDistributorEvents.sol\\\";\\n\\n/// @title SdtDistributorV2\\n/// @notice Earn from Masterchef SDT and distribute it to gauges\\ncontract SdtDistributorV2 is ReentrancyGuardUpgradeable, AccessControlUpgradeable, SdtDistributorEvents {\\n\\tusing SafeERC20 for IERC20;\\n\\n\\t////////////////////////////////////////////////////////////////\\n\\t/// --- CONSTANTS\\n\\t///////////////////////////////////////////////////////////////\\n\\n\\t/// @notice Accounting\\n\\tuint256 public constant BASE_UNIT = 10_000;\\n\\n\\t/// @notice Address of the SDT token given as a reward.\\n\\tIERC20 public constant rewardToken = IERC20(0x73968b9a57c6E53d41345FD57a6E6ae27d6CDB2F);\\n\\n\\t/// @notice Address of the masterchef.\\n\\tIMasterchef public constant masterchef = IMasterchef(0xfEA5E213bbD81A8a94D0E1eDB09dBD7CEab61e1c);\\n\\n\\t/// @notice Role for governors only.\\n\\tbytes32 public constant GOVERNOR_ROLE = keccak256(\\\"GOVERNOR_ROLE\\\");\\n\\t/// @notice Role for the guardian\\n\\tbytes32 public constant GUARDIAN_ROLE = keccak256(\\\"GUARDIAN_ROLE\\\");\\n\\n\\t////////////////////////////////////////////////////////////////\\n\\t/// --- STORAGE SLOTS\\n\\t///////////////////////////////////////////////////////////////\\n\\n\\t/// @notice Time between SDT Harvest.\\n\\tuint256 public timePeriod;\\n\\n\\t/// @notice Address of the token that will be deposited in masterchef.\\n\\tIERC20 public masterchefToken;\\n\\n\\t/// @notice Address of the `GaugeController` contract.\\n\\tIGaugeController public controller;\\n\\n\\t/// @notice Address responsible for pulling rewards of type >= 2 gauges and distributing it to the\\n\\t/// associated contracts if there is not already an address delegated for this specific contract.\\n\\taddress public delegateGauge;\\n\\n\\t/// @notice Whether SDT distribution through this contract is on or no.\\n\\tbool public distributionsOn;\\n\\n\\t/// @notice Maps the address of a type >= 2 gauge to a delegate address responsible\\n\\t/// for giving rewards to the actual gauge.\\n\\tmapping(address => address) public delegateGauges;\\n\\n\\t/// @notice Maps the address of a gauge to whether it was killed or not\\n\\t/// A gauge killed in this contract cannot receive any rewards.\\n\\tmapping(address => bool) public killedGauges;\\n\\n\\t/// @notice Maps the address of a gauge delegate to whether this delegate supports the `notifyReward` interface\\n\\t/// and is therefore built for automation.\\n\\tmapping(address => bool) public isInterfaceKnown;\\n\\n\\t/// @notice Masterchef PID\\n\\tuint256 public masterchefPID;\\n\\n\\t/// @notice Timestamp of the last pull from masterchef.\\n\\tuint256 public lastMasterchefPull;\\n\\n\\t/// @notice Maps the timestamp of pull action to the amount of SDT that pulled.\\n\\tmapping(uint256 => uint256) public pulls; // day => SDT amount\\n\\n\\t/// @notice Maps the timestamp of last pull to the gauge addresses then keeps the data if particular gauge paid in the last pull.\\n\\tmapping(uint256 => mapping(address => bool)) public isGaugePaid;\\n\\n\\t/// @notice Incentive for caller.\\n\\tuint256 public claimerFee;\\n\\n\\t/// @notice Number of days to go through for past distributing.\\n\\tuint256 public lookPastDays;\\n\\n\\t////////////////////////////////////////////////////////////////\\n\\t/// --- INITIALIZATION LOGIC\\n\\t///////////////////////////////////////////////////////////////\\n\\n\\t/// @notice Initialize function\\n\\t/// @param _controller gauge controller to manage votes\\n\\t/// @param _governor governor address\\n\\t/// @param _guardian guardian address\\n\\t/// @param _delegateGauge delegate gauge address\\n\\tfunction initialize(\\n\\t\\taddress _controller,\\n\\t\\taddress _governor,\\n\\t\\taddress _guardian,\\n\\t\\taddress _delegateGauge\\n\\t) external initializer {\\n\\t\\trequire(_controller != address(0) && _guardian != address(0) && _governor != address(0), \\\"0\\\");\\n\\n\\t\\tcontroller = IGaugeController(_controller);\\n\\t\\tdelegateGauge = _delegateGauge;\\n\\n\\t\\tmasterchefToken = IERC20(address(new MasterchefMasterToken()));\\n\\t\\tdistributionsOn = false;\\n\\n\\t\\ttimePeriod = 3600 * 24; // One day in seconds\\n\\t\\tlookPastDays = 45; // for past 45 days check\\n\\n\\t\\t_setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\\n\\t\\t_setRoleAdmin(GUARDIAN_ROLE, GOVERNOR_ROLE);\\n\\n\\t\\t_setupRole(GUARDIAN_ROLE, _guardian);\\n\\t\\t_setupRole(GOVERNOR_ROLE, _governor);\\n\\t\\t_setupRole(GUARDIAN_ROLE, _governor);\\n\\t}\\n\\n\\t/// @custom:oz-upgrades-unsafe-allow constructor\\n\\tconstructor() initializer {}\\n\\n\\t/// @notice Initialize the masterchef depositing the master token\\n\\t/// @param _pid pool id to deposit the token\\n\\tfunction initializeMasterchef(uint256 _pid) external onlyRole(GOVERNOR_ROLE) {\\n\\t\\tmasterchefPID = _pid;\\n\\t\\tmasterchefToken.approve(address(masterchef), 1e18);\\n\\t\\tmasterchef.deposit(_pid, 1e18);\\n\\t}\\n\\n\\t////////////////////////////////////////////////////////////////\\n\\t/// --- DISTRIBUTION LOGIC\\n\\t///////////////////////////////////////////////////////////////\\n\\n\\t/// @notice Distribute SDT to Gauges\\n\\t/// @param gaugeAddr Address of the gauge to distribute.\\n\\tfunction distribute(address gaugeAddr) external nonReentrant {\\n\\t\\t_distribute(gaugeAddr);\\n\\t}\\n\\n\\t/// @notice Distribute SDT to Multiple Gauges\\n\\t/// @param gaugeAddr Array of addresses of the gauge to distribute.\\n\\tfunction distributeMulti(address[] calldata gaugeAddr) public nonReentrant {\\n\\t\\tuint256 length = gaugeAddr.length;\\n\\t\\tfor (uint256 i; i < length; i++) {\\n\\t\\t\\t_distribute(gaugeAddr[i]);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Internal implementation of distribute logic.\\n\\t/// @param gaugeAddr Address of the gauge to distribute rewards to\\n\\tfunction _distribute(address gaugeAddr) internal {\\n\\t\\trequire(distributionsOn, \\\"not allowed\\\");\\n\\t\\t(bool success, bytes memory result) = address(controller).call(\\n\\t\\t\\tabi.encodeWithSignature(\\\"gauge_types(address)\\\", gaugeAddr)\\n\\t\\t);\\n\\t\\tif (!success || killedGauges[gaugeAddr]) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint128 gaugeType = abi.decode(result, (int128));\\n\\n\\t\\t// Rounded to beginning of the day -> 00:00 UTC\\n\\t\\tuint256 roundedTimestamp = (block.timestamp / 1 days) * 1 days;\\n\\n\\t\\tuint256 totalDistribute;\\n\\n\\t\\tif (block.timestamp > lastMasterchefPull + timePeriod) {\\n\\t\\t\\tuint256 sdtBefore = rewardToken.balanceOf(address(this));\\n\\t\\t\\t_pullSDT();\\n\\t\\t\\tpulls[roundedTimestamp] = rewardToken.balanceOf(address(this)) - sdtBefore;\\n\\t\\t\\tlastMasterchefPull = roundedTimestamp;\\n\\t\\t}\\n\\t\\t// check past n days\\n\\t\\tfor (uint256 i; i < lookPastDays; i++) {\\n\\t\\t\\tuint256 currentTimestamp = roundedTimestamp - (i * 86_400);\\n\\n\\t\\t\\tif (pulls[currentTimestamp] > 0) {\\n\\t\\t\\t\\tbool isPaid = isGaugePaid[currentTimestamp][gaugeAddr];\\n\\t\\t\\t\\tif (isPaid) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Retrieve the amount pulled from Masterchef at the given timestamp.\\n\\t\\t\\t\\tuint256 sdtBalance = pulls[currentTimestamp];\\n\\t\\t\\t\\tuint256 gaugeRelativeWeight;\\n\\n\\t\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\t\\t// Makes sure the weight is checkpointed. Also returns the weight.\\n\\t\\t\\t\\t\\tgaugeRelativeWeight = controller.gauge_relative_weight_write(gaugeAddr, currentTimestamp);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tgaugeRelativeWeight = controller.gauge_relative_weight(gaugeAddr, currentTimestamp);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuint256 sdtDistributed = (sdtBalance * gaugeRelativeWeight) / 1e18;\\n\\t\\t\\t\\ttotalDistribute += sdtDistributed;\\n\\t\\t\\t\\tisGaugePaid[currentTimestamp][gaugeAddr] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (totalDistribute > 0) {\\n\\t\\t\\tif (gaugeType == 1) {\\n\\t\\t\\t\\trewardToken.safeTransfer(gaugeAddr, totalDistribute);\\n\\t\\t\\t\\tIStakingRewards(gaugeAddr).notifyRewardAmount(totalDistribute);\\n\\t\\t\\t} else if (gaugeType >= 2) {\\n\\t\\t\\t\\t// If it is defined, we use the specific delegate attached to the gauge\\n\\t\\t\\t\\taddress delegate = delegateGauges[gaugeAddr];\\n\\t\\t\\t\\tif (delegate == address(0)) {\\n\\t\\t\\t\\t\\t// If not, we check if a delegate common to all gauges with type >= 2 can be used\\n\\t\\t\\t\\t\\tdelegate = delegateGauge;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (delegate != address(0)) {\\n\\t\\t\\t\\t\\t// In the case where the gauge has a delegate (specific or not), then rewards are transferred to this gauge\\n\\t\\t\\t\\t\\trewardToken.safeTransfer(delegate, totalDistribute);\\n\\t\\t\\t\\t\\t// If this delegate supports a specific interface, then rewards sent are notified through this\\n\\t\\t\\t\\t\\t// interface\\n\\t\\t\\t\\t\\tif (isInterfaceKnown[delegate]) {\\n\\t\\t\\t\\t\\t\\tISdtMiddlemanGauge(delegate).notifyReward(gaugeAddr, totalDistribute);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\trewardToken.safeTransfer(gaugeAddr, totalDistribute);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tILiquidityGauge(gaugeAddr).deposit_reward_token(address(rewardToken), totalDistribute);\\n\\t\\t\\t}\\n\\n\\t\\t\\temit RewardDistributed(gaugeAddr, totalDistribute, lastMasterchefPull);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Internal function to pull SDT from the MasterChef\\n\\tfunction _pullSDT() internal {\\n\\t\\tmasterchef.withdraw(masterchefPID, 0);\\n\\t}\\n\\n\\t////////////////////////////////////////////////////////////////\\n\\t/// --- RESTRICTIVE FUNCTIONS\\n\\t///////////////////////////////////////////////////////////////\\n\\n\\t/// @notice Sets the distribution state (on/off)\\n\\t/// @param _state new distribution state\\n\\tfunction setDistribution(bool _state) external onlyRole(GOVERNOR_ROLE) {\\n\\t\\tdistributionsOn = _state;\\n\\t}\\n\\n\\t/// @notice Sets a new gauge controller\\n\\t/// @param _controller Address of the new gauge controller\\n\\tfunction setGaugeController(address _controller) external onlyRole(GOVERNOR_ROLE) {\\n\\t\\trequire(_controller != address(0), \\\"0\\\");\\n\\t\\tcontroller = IGaugeController(_controller);\\n\\t\\temit GaugeControllerUpdated(_controller);\\n\\t}\\n\\n\\t/// @notice Sets a new delegate gauge for pulling rewards of a type >= 2 gauges or of all type >= 2 gauges\\n\\t/// @param gaugeAddr Gauge to change the delegate of\\n\\t/// @param _delegateGauge Address of the new gauge delegate related to `gaugeAddr`\\n\\t/// @param toggleInterface Whether we should toggle the fact that the `_delegateGauge` is built for automation or not\\n\\t/// @dev This function can be used to remove delegating or introduce the pulling of rewards to a given address\\n\\t/// @dev If `gaugeAddr` is the zero address, this function updates the delegate gauge common to all gauges with type >= 2\\n\\t/// @dev The `toggleInterface` parameter has been added for convenience to save one transaction when adding a gauge delegate\\n\\t/// which supports the `notifyReward` interface\\n\\tfunction setDelegateGauge(\\n\\t\\taddress gaugeAddr,\\n\\t\\taddress _delegateGauge,\\n\\t\\tbool toggleInterface\\n\\t) external onlyRole(GOVERNOR_ROLE) {\\n\\t\\tif (gaugeAddr != address(0)) {\\n\\t\\t\\tdelegateGauges[gaugeAddr] = _delegateGauge;\\n\\t\\t} else {\\n\\t\\t\\tdelegateGauge = _delegateGauge;\\n\\t\\t}\\n\\t\\temit DelegateGaugeUpdated(gaugeAddr, _delegateGauge);\\n\\n\\t\\tif (toggleInterface) {\\n\\t\\t\\t_toggleInterfaceKnown(_delegateGauge);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Toggles the status of a gauge to either killed or unkilled\\n\\t/// @param gaugeAddr Gauge to toggle the status of\\n\\t/// @dev It is impossible to kill a gauge in the `GaugeController` contract, for this reason killing of gauges\\n\\t/// takes place in the `SdtDistributor` contract\\n\\t/// @dev This means that people could vote for a gauge in the gauge controller contract but that rewards are not going\\n\\t/// to be distributed to it in the end: people would need to remove their weights on the gauge killed to end the diminution\\n\\t/// in rewards\\n\\t/// @dev In the case of a gauge being killed, this function resets the timestamps at which this gauge has been approved and\\n\\t/// disapproves the gauge to spend the token\\n\\t/// @dev It should be cautiously called by governance as it could result in less SDT overall rewards than initially planned\\n\\t/// if people do not remove their voting weights to the killed gauge\\n\\tfunction toggleGauge(address gaugeAddr) external onlyRole(GOVERNOR_ROLE) {\\n\\t\\tbool gaugeKilledMem = killedGauges[gaugeAddr];\\n\\t\\tif (!gaugeKilledMem) {\\n\\t\\t\\trewardToken.safeApprove(gaugeAddr, 0);\\n\\t\\t}\\n\\t\\tkilledGauges[gaugeAddr] = !gaugeKilledMem;\\n\\t\\temit GaugeToggled(gaugeAddr, !gaugeKilledMem);\\n\\t}\\n\\n\\t/// @notice Notifies that the interface of a gauge delegate is known or has changed\\n\\t/// @param _delegateGauge Address of the gauge to change\\n\\t/// @dev Gauge delegates that are built for automation should be toggled\\n\\tfunction toggleInterfaceKnown(address _delegateGauge) external onlyRole(GUARDIAN_ROLE) {\\n\\t\\t_toggleInterfaceKnown(_delegateGauge);\\n\\t}\\n\\n\\t/// @notice Toggles the fact that a gauge delegate can be used for automation or not and therefore supports\\n\\t/// the `notifyReward` interface\\n\\t/// @param _delegateGauge Address of the gauge to change\\n\\tfunction _toggleInterfaceKnown(address _delegateGauge) internal {\\n\\t\\tbool isInterfaceKnownMem = isInterfaceKnown[_delegateGauge];\\n\\t\\tisInterfaceKnown[_delegateGauge] = !isInterfaceKnownMem;\\n\\t\\temit InterfaceKnownToggled(_delegateGauge, !isInterfaceKnownMem);\\n\\t}\\n\\n\\t/// @notice Gives max approvement to the gauge\\n\\t/// @param gaugeAddr Address of the gauge\\n\\tfunction approveGauge(address gaugeAddr) external onlyRole(GOVERNOR_ROLE) {\\n\\t\\trewardToken.safeApprove(gaugeAddr, type(uint256).max);\\n\\t}\\n\\n\\t/// @notice Set the time period to pull SDT from Masterchef\\n\\t/// @param _timePeriod new timePeriod value in seconds\\n\\tfunction setTimePeriod(uint256 _timePeriod) external onlyRole(GOVERNOR_ROLE) {\\n\\t\\trequire(_timePeriod >= 1 days, \\\"TOO_LOW\\\");\\n\\t\\ttimePeriod = _timePeriod;\\n\\t}\\n\\n\\tfunction setClaimerFee(uint256 _newFee) external onlyRole(GOVERNOR_ROLE) {\\n\\t\\trequire(_newFee <= BASE_UNIT, \\\"TOO_HIGH\\\");\\n\\t\\tclaimerFee = _newFee;\\n\\t}\\n\\n\\t/// @notice Set the how many days we should look back for reward distribution\\n\\t/// @param _newLookPastDays new value for how many days we should look back\\n\\tfunction setLookPastDays(uint256 _newLookPastDays) external onlyRole(GOVERNOR_ROLE) {\\n\\t\\tlookPastDays = _newLookPastDays;\\n\\t}\\n\\n\\t/// @notice Withdraws ERC20 tokens that could accrue on this contract\\n\\t/// @param tokenAddress Address of the ERC20 token to withdraw\\n\\t/// @param to Address to transfer to\\n\\t/// @param amount Amount to transfer\\n\\t/// @dev Added to support recovering LP Rewards and other mistaken tokens\\n\\t/// from other systems to be distributed to holders\\n\\t/// @dev This function could also be used to recover SDT tokens in case the rate got smaller\\n\\tfunction recoverERC20(\\n\\t\\taddress tokenAddress,\\n\\t\\taddress to,\\n\\t\\tuint256 amount\\n\\t) external onlyRole(GOVERNOR_ROLE) {\\n\\t\\tIERC20(tokenAddress).safeTransfer(to, amount);\\n\\t\\temit Recovered(tokenAddress, to, amount);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILocker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\ninterface ILocker {\\n\\tfunction createLock(uint256, uint256) external;\\n\\n\\tfunction claimAllRewards(address[] calldata _tokens, address _recipient) external;\\n\\n\\tfunction increaseAmount(uint256) external;\\n\\n\\tfunction increaseUnlockTime(uint256) external;\\n\\n\\tfunction release() external;\\n\\n\\tfunction claimRewards(address,address) external;\\n\\n\\tfunction claimFXSRewards(address) external;\\n\\n\\tfunction execute(\\n\\t\\taddress,\\n\\t\\tuint256,\\n\\t\\tbytes calldata\\n\\t) external returns (bool, bytes memory);\\n\\n\\tfunction setGovernance(address) external;\\n\\n\\tfunction voteGaugeWeight(address, uint256) external;\\n\\n\\tfunction setAngleDepositor(address) external;\\n\\n\\tfunction setFxsDepositor(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/accumulator/BaseAccumulator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"../interfaces/ILocker.sol\\\";\\nimport \\\"../interfaces/ILiquidityGauge.sol\\\";\\nimport { ISDTDistributor } from \\\"../interfaces/ISDTDistributor.sol\\\";\\n\\n/// @title BaseAccumulator\\n/// @notice A contract that defines the functions shared by all accumulators\\n/// @author StakeDAO\\ncontract BaseAccumulator {\\n\\tusing SafeERC20 for IERC20;\\n\\t/* ========== STATE VARIABLES ========== */\\n\\taddress public governance;\\n\\taddress public locker;\\n\\taddress public tokenReward;\\n\\taddress public gauge;\\n\\taddress public sdtDistributor;\\n\\tuint256 public claimerFee;\\n\\n\\t/* ========== EVENTS ========== */\\n\\n\\tevent SdtDistributorUpdated(address oldDistributor, address newDistributor);\\n\\tevent GaugeSet(address oldGauge, address newGauge);\\n\\tevent RewardNotified(address gauge, address tokenReward, uint256 amount);\\n\\tevent LockerSet(address oldLocker, address newLocker);\\n\\tevent GovernanceSet(address oldGov, address newGov);\\n\\tevent TokenRewardSet(address oldTr, address newTr);\\n\\tevent TokenDeposited(address token, uint256 amount);\\n\\tevent ERC20Rescued(address token, uint256 amount);\\n\\n\\t/* ========== CONSTRUCTOR ========== */\\n\\tconstructor(address _tokenReward, address _gauge) {\\n\\t\\ttokenReward = _tokenReward;\\n\\t\\tgauge = _gauge;\\n\\t\\tgovernance = msg.sender;\\n\\t}\\n\\n\\t/* ========== MUTATIVE FUNCTIONS ========== */\\n\\n\\t/// @notice Notify the reward using an extra token\\n\\t/// @param _tokenReward token address to notify\\n\\t/// @param _amount amount to notify\\n\\tfunction notifyExtraReward(address _tokenReward, uint256 _amount) external {\\n\\t\\trequire(msg.sender == governance, \\\"!gov\\\");\\n\\t\\t_notifyReward(_tokenReward, _amount);\\n\\t\\t_distributeSDT();\\n\\t}\\n\\n\\t/// @notice Notify the reward using all balance of extra token\\n\\t/// @param _tokenReward token address to notify\\n\\tfunction notifyAllExtraReward(address _tokenReward) external {\\n\\t\\trequire(msg.sender == governance, \\\"!gov\\\");\\n\\t\\tuint256 amount = IERC20(_tokenReward).balanceOf(address(this));\\n\\t\\t_notifyReward(_tokenReward, amount);\\n\\t\\t_distributeSDT();\\n\\t}\\n\\n\\tfunction notifyExtraReward(address[] calldata _tokens, uint256[] calldata amounts) external {\\n\\t\\trequire(msg.sender == governance, \\\"!gov\\\");\\n\\t\\t_notifyExtraReward(_tokens, amounts);\\n\\t\\t_distributeSDT();\\n\\t}\\n\\n\\tfunction _notifyExtraReward(address[] memory _tokens, uint256[] memory amounts) internal {\\n\\t\\tuint256 length = _tokens.length;\\n\\t\\tfor (uint256 i; i < length; ++i) {\\n\\t\\t\\t_notifyReward(_tokens[i], amounts[i]);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction notifyAllExtraReward(address[] calldata _tokens) external {\\n\\t\\trequire(msg.sender == governance, \\\"!gov\\\");\\n\\t\\t_notifyAllExtraReward(_tokens);\\n\\t\\t_distributeSDT();\\n\\t}\\n\\n\\tfunction _notifyAllExtraReward(address[] memory _tokens) internal {\\n\\t\\tuint256 amount;\\n\\t\\tuint256 length = _tokens.length;\\n\\t\\tfor (uint256 i; i < length; ++i) {\\n\\t\\t\\tamount = IERC20(_tokens[i]).balanceOf(address(this));\\n\\t\\t\\t_notifyReward(_tokens[i], amount);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _distributeSDT() internal {\\n\\t\\tif (sdtDistributor != address(0)) {\\n\\t\\t\\tISDTDistributor(sdtDistributor).distribute(gauge);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Notify the new reward to the LGV4\\n\\t/// @param _tokenReward token to notify\\n\\t/// @param _amount amount to notify\\n\\tfunction _notifyReward(address _tokenReward, uint256 _amount) internal {\\n\\t\\trequire(gauge != address(0), \\\"gauge not set\\\");\\n\\t\\tif (_amount == 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tuint256 balanceBefore = IERC20(_tokenReward).balanceOf(address(this));\\n\\t\\trequire(balanceBefore >= _amount, \\\"amount not enough\\\");\\n\\t\\tif (ILiquidityGauge(gauge).reward_data(_tokenReward).distributor != address(0)) {\\n\\t\\t\\tuint256 claimerReward = (_amount * claimerFee) / 10000;\\n\\t\\t\\tIERC20(_tokenReward).transfer(msg.sender, claimerReward);\\n\\t\\t\\t_amount -= claimerReward;\\n\\t\\t\\tIERC20(_tokenReward).approve(gauge, _amount);\\n\\t\\t\\tILiquidityGauge(gauge).deposit_reward_token(_tokenReward, _amount);\\n\\n\\t\\t\\tuint256 balanceAfter = IERC20(_tokenReward).balanceOf(address(this));\\n\\n\\t\\t\\trequire(balanceBefore - balanceAfter == _amount, \\\"wrong amount notified\\\");\\n\\n\\t\\t\\temit RewardNotified(gauge, _tokenReward, _amount);\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Deposit token into the accumulator\\n\\t/// @param _token token to deposit\\n\\t/// @param _amount amount to deposit\\n\\tfunction depositToken(address _token, uint256 _amount) external {\\n\\t\\trequire(_amount > 0, \\\"set an amount > 0\\\");\\n\\t\\tIERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\\n\\t\\temit TokenDeposited(_token, _amount);\\n\\t}\\n\\n\\t/// @notice Sets gauge for the accumulator which will receive and distribute the rewards\\n\\t/// @dev Can be called only by the governance\\n\\t/// @param _gauge gauge address\\n\\tfunction setGauge(address _gauge) external {\\n\\t\\trequire(msg.sender == governance, \\\"!gov\\\");\\n\\t\\trequire(_gauge != address(0), \\\"can't be zero address\\\");\\n\\t\\temit GaugeSet(gauge, _gauge);\\n\\t\\tgauge = _gauge;\\n\\t}\\n\\n\\t/// @notice Sets SdtDistributor to distribute from the Accumulator SDT Rewards to Gauge.\\n\\t/// @dev Can be called only by the governance\\n\\t/// @param _sdtDistributor gauge address\\n\\tfunction setSdtDistributor(address _sdtDistributor) external {\\n\\t\\trequire(msg.sender == governance, \\\"!gov\\\");\\n\\t\\trequire(_sdtDistributor != address(0), \\\"can't be zero address\\\");\\n\\n\\t\\temit SdtDistributorUpdated(sdtDistributor, _sdtDistributor);\\n\\t\\tsdtDistributor = _sdtDistributor;\\n\\t}\\n\\n\\t/// @notice Allows the governance to set the new governance\\n\\t/// @dev Can be called only by the governance\\n\\t/// @param _governance governance address\\n\\tfunction setGovernance(address _governance) external {\\n\\t\\trequire(msg.sender == governance, \\\"!gov\\\");\\n\\t\\trequire(_governance != address(0), \\\"can't be zero address\\\");\\n\\t\\temit GovernanceSet(governance, _governance);\\n\\t\\tgovernance = _governance;\\n\\t}\\n\\n\\t/// @notice Allows the governance to set the locker\\n\\t/// @dev Can be called only by the governance\\n\\t/// @param _locker locker address\\n\\tfunction setLocker(address _locker) external {\\n\\t\\trequire(msg.sender == governance, \\\"!gov\\\");\\n\\t\\trequire(_locker != address(0), \\\"can't be zero address\\\");\\n\\t\\temit LockerSet(locker, _locker);\\n\\t\\tlocker = _locker;\\n\\t}\\n\\n\\t/// @notice Allows the governance to set the token reward\\n\\t/// @dev Can be called only by the governance\\n\\t/// @param _tokenReward token reward address\\n\\tfunction setTokenReward(address _tokenReward) external {\\n\\t\\trequire(msg.sender == governance, \\\"!gov\\\");\\n\\t\\trequire(_tokenReward != address(0), \\\"can't be zero address\\\");\\n\\t\\temit TokenRewardSet(tokenReward, _tokenReward);\\n\\t\\ttokenReward = _tokenReward;\\n\\t}\\n\\n\\tfunction setClaimerFee(uint256 _claimerFee) external {\\n\\t\\trequire(msg.sender == governance, \\\"!gov\\\");\\n\\t\\tclaimerFee = _claimerFee;\\n\\t}\\n\\n\\t/// @notice A function that rescue any ERC20 token\\n\\t/// @param _token token address\\n\\t/// @param _amount amount to rescue\\n\\t/// @param _recipient address to send token rescued\\n\\tfunction rescueERC20(\\n\\t\\taddress _token,\\n\\t\\tuint256 _amount,\\n\\t\\taddress _recipient\\n\\t) external {\\n\\t\\trequire(msg.sender == governance, \\\"!gov\\\");\\n\\t\\trequire(_amount > 0, \\\"set an amount > 0\\\");\\n\\t\\trequire(_recipient != address(0), \\\"can't be zero address\\\");\\n\\t\\tIERC20(_token).safeTransfer(_recipient, _amount);\\n\\t\\temit ERC20Rescued(_token, _amount);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISDTDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.7;\\n\\ninterface ISDTDistributor {\\n    function distribute(address gaugeAddr) external;\\n}\\n\"\r\n    },\r\n    \"contracts/staking/SdtDistributorEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\nimport \\\"../interfaces/IGaugeController.sol\\\";\\nimport \\\"../interfaces/ILiquidityGauge.sol\\\";\\nimport \\\"../interfaces/ISdtMiddlemanGauge.sol\\\";\\nimport \\\"../interfaces/IStakingRewards.sol\\\";\\n\\nimport \\\"../interfaces/IMasterchef.sol\\\";\\nimport \\\"./MasterchefMasterToken.sol\\\";\\n\\nimport \\\"../external/AccessControlUpgradeable.sol\\\";\\n\\n/// @title SdtDistributorEvents\\n/// @author StakeDAO Core Team\\n/// @notice All the events used in `SdtDistributor` contract\\n abstract contract SdtDistributorEvents {\\n\\tevent DelegateGaugeUpdated(address indexed _gaugeAddr, address indexed _delegateGauge);\\n\\tevent DistributionsToggled(bool _distributionsOn);\\n\\tevent GaugeControllerUpdated(address indexed _controller);\\n\\tevent GaugeToggled(address indexed gaugeAddr, bool newStatus);\\n\\tevent InterfaceKnownToggled(address indexed _delegateGauge, bool _isInterfaceKnown);\\n\\tevent RateUpdated(uint256 _newRate);\\n\\tevent Recovered(address indexed tokenAddress, address indexed to, uint256 amount);\\n\\tevent RewardDistributed(address indexed gaugeAddr, uint256 sdtDistributed, uint256 lastMasterchefPull);\\n\\tevent UpdateMiningParameters(uint256 time, uint256 rate, uint256 supply);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISdtMiddlemanGauge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.7;\\n\\ninterface ISdtMiddlemanGauge {\\n\\tfunction notifyReward(address gauge, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakingRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title IStakingRewardsFunctions\\n/// @author StakeDAO Core Team\\n/// @notice Interface for the staking rewards contract that interact with the `RewardsDistributor` contract\\ninterface IStakingRewardsFunctions {\\n    function notifyRewardAmount(uint256 reward) external;\\n\\n    function recoverERC20(\\n        address tokenAddress,\\n        address to,\\n        uint256 tokenAmount\\n    ) external;\\n\\n    function setNewRewardsDistribution(address newRewardsDistribution) external;\\n}\\n\\n/// @title IStakingRewards\\n/// @author StakeDAO Core Team\\n/// @notice Previous interface with additionnal getters for public variables\\ninterface IStakingRewards is IStakingRewardsFunctions {\\n    function rewardToken() external view returns (IERC20);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IMasterchef.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\ninterface IMasterchef {\\n\\tfunction deposit(uint256, uint256) external;\\n\\n\\tfunction withdraw(uint256, uint256) external;\\n\\n\\tfunction userInfo(uint256, address) external view returns (uint256, uint256);\\n\\n\\tfunction poolInfo(uint256)\\n\\t\\texternal\\n\\t\\treturns (\\n\\t\\t\\taddress,\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256\\n\\t\\t);\\n\\n\\tfunction totalAllocPoint() external view returns (uint256);\\n\\n\\tfunction sdtPerBlock() external view returns (uint256);\\n\\n\\tfunction pendingSdt(uint256, address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/MasterchefMasterToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract MasterchefMasterToken is ERC20, Ownable {\\n\\tconstructor() ERC20(\\\"Masterchef Master Token\\\", \\\"MMT\\\") {\\n\\t\\t_mint(msg.sender, 1e18);\\n\\t}\\n}\"\r\n    },\r\n    \"contracts/external/AccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport \\\"../interfaces/IAccessControl.sol\\\";\\n\\n/**\\n * @dev This contract is fully forked from OpenZeppelin `AccessControlUpgradeable`.\\n * The only difference is the removal of the ERC165 implementation as it's not\\n * needed in Angle.\\n *\\n * Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControlUpgradeable is Initializable, IAccessControl {\\n    function __AccessControl_init() internal initializer {\\n        __AccessControl_init_unchained();\\n    }\\n\\n    function __AccessControl_init_unchained() internal initializer {}\\n\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, msg.sender);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        StringsUpgradeable.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        StringsUpgradeable.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external override {\\n        require(account == msg.sender, \\\"71\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) internal {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, msg.sender);\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) internal {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, msg.sender);\\n        }\\n    }\\n\\n    uint256[49] private __gap;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.7;\\n\\n/// @title IAccessControl\\n/// @author Forked from OpenZeppelin\\n/// @notice Interface for `AccessControl` contracts\\ninterface IAccessControl {\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    function grantRole(bytes32 role, address account) external;\\n\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    function renounceRole(bytes32 role, address account) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/BalancerVault/IAsset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.7;\\n\\n/**\\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\\n * types.\\n *\\n * This concept is unrelated to a Pool's Asset Managers.\\n */\\ninterface IAsset {\\n\\t// solhint-disable-previous-line no-empty-blocks\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/BalancerVault/IAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.7;\\n\\ninterface IAuthorizer {\\n\\t/**\\n\\t * @dev Returns true if `account` can perform the action described by `actionId` in the contract `where`.\\n\\t */\\n\\tfunction canPerform(\\n\\t\\tbytes32 actionId,\\n\\t\\taddress account,\\n\\t\\taddress where\\n\\t) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/BalancerVault/IFlashLoanRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.7;\\n\\n// Inspired by Aave Protocol's IFlashLoanReceiver.\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IFlashLoanRecipient {\\n\\t/**\\n\\t * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.\\n\\t *\\n\\t * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this\\n\\t * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the\\n\\t * Vault, or else the entire flash loan will revert.\\n\\t *\\n\\t * `userData` is the same value passed in the `IVault.flashLoan` call.\\n\\t */\\n\\tfunction receiveFlashLoan(\\n\\t\\tIERC20[] memory tokens,\\n\\t\\tuint256[] memory amounts,\\n\\t\\tuint256[] memory feeAmounts,\\n\\t\\tbytes memory userData\\n\\t) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"name\":\"GaugeDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"name\":\"VaultDeployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BAL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BALANCER_STRATEGY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CLAIM_REWARDS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAUGE_CONTROLLER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAUGE_IMPL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOVERNANCE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SDT_DISTRIBUTOR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VEBOOST\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VESDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_balGaugeAddress\",\"type\":\"address\"}],\"name\":\"cloneAndInit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_paramsHash\",\"type\":\"bytes32\"}],\"name\":\"predictAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultImpl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BalancerVaultFactory", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}