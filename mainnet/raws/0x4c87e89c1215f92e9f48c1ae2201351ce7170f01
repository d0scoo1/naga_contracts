{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"AbiDecoder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\nimport \\\"./Strings.sol\\\";\\n\\n/**\\n * @title Decode raw calldata and params\\n * @author yearn.finance\\n */\\n\\nlibrary AbiDecoder {\\n  /**\\n   * @notice Extract all params from calldata given a list of param types and raw calldata bytes\\n   * @param paramTypes An array of param types (ie. [\\\"address\\\", \\\"bytes[]\\\", \\\"uint256\\\"])\\n   * @param data Raw calldata (including 4byte method selector)\\n   * @return Returns an array of input param data\\n   */\\n  function getParamsFromCalldata(\\n    string[] memory paramTypes,\\n    bytes calldata data\\n  ) public pure returns (bytes[] memory) {\\n    uint256 numberOfParams = paramTypes.length;\\n    bytes[] memory results = new bytes[](numberOfParams);\\n    for (uint256 paramIdx = 0; paramIdx \\u003c numberOfParams; paramIdx++) {\\n      string memory paramType = paramTypes[paramIdx];\\n      bytes memory param = getParamFromCalldata(data, paramType, paramIdx);\\n      results[paramIdx] = param;\\n    }\\n    return results;\\n  }\\n\\n  /**\\n   * @notice Extract param bytes given calldata, param type and param index\\n   * @param data Raw calldata (including 4byte method selector)\\n   * @param paramIdx The position of the param data to fetch (0 will fetch the first param)\\n   * @return Returns the raw data of the param at paramIdx index\\n   * @dev If the type is \\\"bytes\\\", \\\"bytes[]\\\", \\\"string\\\" or \\\"string[]\\\" the offset byte\\n   *      will be set to 0x20. The param is isolated in such a way that it can be passed as an\\n   *      input to another method selector using call or staticcall.\\n   */\\n  function getParamFromCalldata(\\n    bytes calldata data,\\n    string memory paramType,\\n    uint256 paramIdx\\n  ) public pure returns (bytes memory) {\\n    uint256 paramsStartIdx = 0x04; // Start after method selector\\n    uint256 paramOffset = 0x20 * paramIdx;\\n    bytes memory paramDescriptorValue = bytes(\\n      data[paramsStartIdx + paramOffset:paramsStartIdx + paramOffset + 0x20]\\n    );\\n\\n    bool paramTypeIsStringOrBytes = Strings.stringsEqual(paramType, \\\"bytes\\\") ||\\n      Strings.stringsEqual(paramType, \\\"string\\\");\\n    bool paramTypeIsStringArrayOrBytesArray = Strings.stringsEqual(\\n      paramType,\\n      \\\"bytes[]\\\"\\n    ) || Strings.stringsEqual(paramType, \\\"string[]\\\");\\n    bool _paramTypeIsArray = paramTypeIsArray(paramType);\\n\\n    uint256 paramStartIdx = uint256(bytes32(paramDescriptorValue)) + 0x04;\\n    if (paramTypeIsStringOrBytes) {\\n      return extractParamForBytesType(data, paramStartIdx);\\n    } else if (paramTypeIsStringArrayOrBytesArray) {\\n      return extractParamForBytesArrayType(data, paramStartIdx);\\n    } else if (_paramTypeIsArray) {\\n      return extractParamForSimpleArray(data, paramStartIdx);\\n    } else {\\n      return paramDescriptorValue;\\n    }\\n  }\\n\\n  /**\\n   * @notice Extract param for \\\"bytes\\\" and \\\"string\\\" types given calldata and a param start index\\n   * @param data Raw calldata (including 4byte method selector)\\n   * @param paramStartIdx The offset the param starts at\\n   * @return Returns the raw data of the param at paramIdx index\\n   */\\n  function extractParamForBytesType(bytes calldata data, uint256 paramStartIdx)\\n    public\\n    pure\\n    returns (bytes memory)\\n  {\\n    uint256 paramEndIdx = paramStartIdx + 0x20;\\n    bytes32 bytesLengthBytes = bytes32(data[paramStartIdx:paramEndIdx]);\\n    uint256 bytesLength = uint256(bytesLengthBytes);\\n    bytes memory dataToAdd = abi.encodePacked(\\n      uint256(0x20),\\n      bytes32(bytesLengthBytes)\\n    );\\n    uint256 numberOfRowsOfBytes = (bytesLength / 32) + 1;\\n    for (uint256 rowIdx; rowIdx \\u003c numberOfRowsOfBytes; rowIdx++) {\\n      uint256 rowStartIdx = paramEndIdx + (0x20 * rowIdx);\\n      dataToAdd = abi.encodePacked(\\n        dataToAdd,\\n        data[rowStartIdx:rowStartIdx + 0x20]\\n      );\\n    }\\n    return dataToAdd;\\n  }\\n\\n  /**\\n   * @notice Extract param for \\\"bytes[]\\\" and \\\"string[]\\\" types given calldata and a param start index\\n   * @param data Raw calldata (including 4byte method selector)\\n   * @param paramStartIdx The offset the param starts at\\n   * @return Returns the raw data of the param at paramIdx index\\n   */\\n  function extractParamForBytesArrayType(\\n    bytes calldata data,\\n    uint256 paramStartIdx\\n  ) public pure returns (bytes memory) {\\n    uint256 paramEndIdx = paramStartIdx + 0x20;\\n    bytes32 arrayLengthBytes = bytes32(data[paramStartIdx:paramEndIdx]);\\n    uint256 arrayLength = uint256(arrayLengthBytes);\\n    bytes memory dataToAdd = abi.encodePacked(\\n      uint256(0x20),\\n      bytes32(arrayLengthBytes)\\n    );\\n    uint256 lastOffsetStartIdx = paramEndIdx + (0x20 * arrayLength) - 0x20;\\n    uint256 lastOffset = uint256(\\n      bytes32(data[lastOffsetStartIdx:lastOffsetStartIdx + 0x20])\\n    );\\n    bytes32 lastElementBytesLengthBytes = bytes32(\\n      data[paramEndIdx + lastOffset:paramEndIdx + lastOffset + 0x20]\\n    );\\n    uint256 lastElementBytesLength = uint256(lastElementBytesLengthBytes);\\n    uint256 numberOfRowsOfBytesForLastElement = (lastElementBytesLength / 32) +\\n      1;\\n    uint256 dataEndIdx = paramEndIdx +\\n      lastOffset +\\n      0x20 +\\n      (0x20 * numberOfRowsOfBytesForLastElement);\\n    dataToAdd = abi.encodePacked(dataToAdd, data[paramEndIdx:dataEndIdx]);\\n    return dataToAdd;\\n  }\\n\\n  /**\\n   * @notice Extract param for \\\"*[]\\\" types given calldata and a param start index, assuming each element is 32 bytes\\n   * @param data Raw calldata (including 4byte method selector)\\n   * @param paramStartIdx The offset the param starts at\\n   * @return Returns the raw data of the param at paramIdx index\\n   */\\n  function extractParamForSimpleArray(\\n    bytes calldata data,\\n    uint256 paramStartIdx\\n  ) public pure returns (bytes memory) {\\n    uint256 paramEndIdx = paramStartIdx + 0x20;\\n    bytes32 arrayLengthBytes = bytes32(data[paramStartIdx:paramEndIdx]);\\n    uint256 arrayLength = uint256(arrayLengthBytes);\\n    bytes memory dataToAdd = abi.encodePacked(\\n      uint256(0x20),\\n      bytes32(arrayLengthBytes)\\n    );\\n    for (uint256 rowIdx; rowIdx \\u003c arrayLength; rowIdx++) {\\n      uint256 rowStartIdx = paramEndIdx + (0x20 * rowIdx);\\n      dataToAdd = abi.encodePacked(\\n        dataToAdd,\\n        data[rowStartIdx:rowStartIdx + 0x20]\\n      );\\n    }\\n    return dataToAdd;\\n  }\\n\\n  /**\\n   * @notice Check to see if the last two characters of a string are \\\"[]\\\"\\n   * @param paramType Param type as a string (ie. \\\"uint256\\\", \\\"uint256[]\\\")\\n   * @return Returns true if the paramType ends with \\\"[]\\\", false if not\\n   */\\n  function paramTypeIsArray(string memory paramType)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    bytes32 lastTwoCharacters;\\n    assembly {\\n      let len := mload(paramType)\\n      lastTwoCharacters := mload(add(add(paramType, 0x20), sub(len, 2)))\\n    }\\n    return lastTwoCharacters == bytes32(bytes(\\\"[]\\\"));\\n  }\\n}\\n\"},\"Allowlist.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./Introspection.sol\\\";\\nimport \\\"./JsonWriter.sol\\\";\\nimport \\\"./CalldataValidation.sol\\\";\\n\\n/*******************************************************\\n *                   Main Contract Logic\\n *******************************************************/\\ncontract Allowlist is IAllowlist, Ownable {\\n  using JsonWriter for JsonWriter.Json; // Initialize JSON writer\\n  string[] public conditionsIds; // Array of condition IDs\\n  mapping(string =\\u003e Condition) public conditionById; // Condition ID to condition mapping\\n  string public name; // Domain name of protocol (ie. \\\"yearn.finance\\\")\\n  address public allowlistFactoryAddress; // Address of root allowlist (parent/factory)\\n  mapping(string =\\u003e address) public implementationById; // Implementation ID to implementation address mapping\\n  string[] public implementationsIds; // Array of implementation IDs\\n\\n  /**\\n   * @notice Initialize the contract (this will only be called by proxy)\\n   * @param _name The allowlist name (for the protocols this is domain name: ie. \\\"yearn.finance\\\")\\n   */\\n  function initialize(string memory _name, address _ownerAddress) public {\\n    require(\\n      allowlistFactoryAddress == address(0),\\n      \\\"Contract is already initialized\\\"\\n    );\\n    allowlistFactoryAddress = msg.sender;\\n    name = _name;\\n    ownerAddress = _ownerAddress;\\n  }\\n\\n  /*******************************************************\\n   *                   Implementation Logic\\n   *******************************************************/\\n\\n  /**\\n   * @notice Set implementation address for an ID (ie. \\\"VAULT_VALIDATIONS\\\" =\\u003e 0x...)\\n   * @param implementationId The unique id of the implementation\\n   * @param implementationAddress The address of the new implementation\\n   */\\n  function setImplementation(\\n    string memory implementationId,\\n    address implementationAddress\\n  ) public onlyOwner {\\n    // Add implementation ID to the implementationsIds list if it doesn\\u0027t exist\\n    bool implementationExists = implementationById[implementationId] !=\\n      address(0);\\n    if (!implementationExists) {\\n      implementationsIds.push(implementationId);\\n    }\\n\\n    // Set implementation\\n    implementationById[implementationId] = implementationAddress;\\n\\n    // Validate implementation against existing conditions\\n    validateConditions();\\n  }\\n\\n  /**\\n   * @notice Set multiple implementations\\n   * @param implementations An array of implementation tuples\\n   */\\n  function setImplementations(Implementation[] memory implementations)\\n    public\\n    onlyOwner\\n  {\\n    for (\\n      uint256 implementationIdx;\\n      implementationIdx \\u003c implementations.length;\\n      implementationIdx++\\n    ) {\\n      Implementation memory implementation = implementations[implementationIdx];\\n      setImplementation(implementation.id, implementation.addr);\\n    }\\n  }\\n\\n  function implementationsIdsList() public view returns (string[] memory) {\\n    return implementationsIds;\\n  }\\n\\n  function implementationsList() public view returns (Implementation[] memory) {\\n    string[] memory _implementationsIdsList = implementationsIdsList();\\n    Implementation[] memory implementations = new Implementation[](\\n      _implementationsIdsList.length\\n    );\\n    for (\\n      uint256 implementationIdx;\\n      implementationIdx \\u003c _implementationsIdsList.length;\\n      implementationIdx++\\n    ) {\\n      string memory implementationId = _implementationsIdsList[\\n        implementationIdx\\n      ];\\n      address implementationAddress = implementationById[implementationId];\\n      implementations[implementationIdx] = Implementation({\\n        id: implementationId,\\n        addr: implementationAddress\\n      });\\n    }\\n    return implementations;\\n  }\\n\\n  /*******************************************************\\n   *                   Condition CRUD Logic\\n   *******************************************************/\\n\\n  /**\\n   * @dev Internal method for adding a condition\\n   * @dev Condition ID validation happens here (IDs must be unqiue and not have spaces)\\n   * @dev Actual condition validation does not happen here (it happens in \\\"validateCondition(condition)\\\")\\n   */\\n  function _addCondition(Condition memory condition) internal {\\n    // Condition ID must be unique\\n    require(\\n      conditionExists(condition.id) == false,\\n      \\\"Condition with this ID already exists\\\"\\n    );\\n\\n    // Condition ID cannot have spaces\\n    bool idHasSpaces = Strings.indexOfStringInString(\\\" \\\", condition.id) != -1;\\n    require(idHasSpaces == false, \\\"Condition IDs cannot have spaces\\\");\\n\\n    // Add condition\\n    conditionById[condition.id] = condition;\\n    conditionsIds.push(condition.id);\\n  }\\n\\n  /**\\n   * @notice Add a condition with validation\\n   * @param condition The condition to add\\n   */\\n  function addCondition(Condition memory condition) public onlyOwner {\\n    validateCondition(condition);\\n    _addCondition(condition);\\n  }\\n\\n  /**\\n   * @notice Add multiple conditions with validation\\n   * @param _conditions The conditions to add\\n   */\\n  function addConditions(Condition[] memory _conditions) public onlyOwner {\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx \\u003c _conditions.length;\\n      conditionIdx++\\n    ) {\\n      Condition memory condition = _conditions[conditionIdx];\\n      addCondition(condition);\\n    }\\n  }\\n\\n  /**\\n   * @notice Add a condition without validation\\n   * @param condition The condition to add\\n   */\\n  function addConditionWithoutValidation(Condition memory condition)\\n    public\\n    onlyOwner\\n  {\\n    _addCondition(condition);\\n  }\\n\\n  /**\\n   * @notice Add multiple conditions without validation\\n   * @param _conditions The conditions to add\\n   */\\n  function addConditionsWithoutValidation(Condition[] memory _conditions)\\n    public\\n    onlyOwner\\n  {\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx \\u003c _conditions.length;\\n      conditionIdx++\\n    ) {\\n      Condition memory condition = _conditions[conditionIdx];\\n      addConditionWithoutValidation(condition);\\n    }\\n  }\\n\\n  /**\\n   * @notice Delete a condition given an ID\\n   * @param conditionId The ID of the condition to delete\\n   */\\n  function deleteCondition(string memory conditionId) public onlyOwner {\\n    string memory lastConditionId = conditionsIds[conditionsIds.length - 1];\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx \\u003c conditionsIds.length;\\n      conditionIdx++\\n    ) {\\n      string memory currentConditionId = conditionsIds[conditionIdx];\\n      if (Strings.stringsEqual(currentConditionId, conditionId)) {\\n        conditionsIds[conditionIdx] = lastConditionId;\\n        conditionsIds.pop();\\n        delete conditionById[conditionId];\\n        return;\\n      }\\n    }\\n    revert(\\\"Cannot find condition with that ID\\\");\\n  }\\n\\n  /**\\n   * @notice Delete multiple conditions given a list of IDs\\n   * @param _conditionsIds A list of condition IDs to delete\\n   */\\n  function deleteConditions(string[] memory _conditionsIds) public onlyOwner {\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx \\u003c _conditionsIds.length;\\n      conditionIdx++\\n    ) {\\n      string memory conditionId = _conditionsIds[conditionIdx];\\n      deleteCondition(conditionId);\\n    }\\n  }\\n\\n  /**\\n   * @notice Delete every condition\\n   */\\n  function deleteAllConditions() public onlyOwner {\\n    uint256 _conditionsLength = conditionsIds.length;\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx \\u003c _conditionsLength;\\n      conditionIdx++\\n    ) {\\n      string memory conditionId = conditionsIds[0];\\n      deleteCondition(conditionId);\\n    }\\n  }\\n\\n  /**\\n   * @notice Update an existing condition\\n   * @dev Reads condition.id to determine which condition to update\\n   * @param condition The new condition\\n   */\\n  function updateCondition(Condition memory condition) public onlyOwner {\\n    require(\\n      conditionExists(condition.id),\\n      \\\"Condition with this ID does not exist\\\"\\n    );\\n    deleteCondition(condition.id);\\n    addCondition(condition);\\n  }\\n\\n  /**\\n   * @notice Fetch a list of conditions\\n   * @return Returns all conditions\\n   */\\n  function conditionsList() public view returns (Condition[] memory) {\\n    Condition[] memory _conditions = new Condition[](conditionsIds.length);\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx \\u003c conditionsIds.length;\\n      conditionIdx++\\n    ) {\\n      _conditions[conditionIdx] = conditionById[conditionsIds[conditionIdx]];\\n    }\\n    return _conditions;\\n  }\\n\\n  /**\\n   * @notice Fetch current conditions list as JSON\\n   * @return Returns JSON representation of conditions list\\n   */\\n  function conditionsJson() public view returns (string memory) {\\n    Condition[] memory conditions = conditionsList();\\n\\n    // Start array\\n    JsonWriter.Json memory writer;\\n    writer = writer.writeStartArray();\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx \\u003c conditions.length;\\n      conditionIdx++\\n    ) {\\n      // Load condition\\n      Condition memory condition = conditions[conditionIdx];\\n\\n      // Start object\\n      writer = writer.writeStartObject();\\n\\n      // ID\\n      writer = writer.writeStringProperty(\\\"id\\\", condition.id);\\n\\n      // Implementation ID\\n      writer = writer.writeStringProperty(\\n        \\\"implementationId\\\",\\n        condition.implementationId\\n      );\\n\\n      // Method name\\n      writer = writer.writeStringProperty(\\\"methodName\\\", condition.methodName);\\n\\n      // Param types\\n      writer = writer.writeStartArray(\\\"paramTypes\\\");\\n      for (\\n        uint256 paramTypeIdx;\\n        paramTypeIdx \\u003c condition.paramTypes.length;\\n        paramTypeIdx++\\n      ) {\\n        writer = writer.writeStringValue(condition.paramTypes[paramTypeIdx]);\\n      }\\n      writer = writer.writeEndArray();\\n\\n      // Requirements\\n      writer = writer.writeStartArray(\\\"requirements\\\");\\n      for (\\n        uint256 requirementIdx;\\n        requirementIdx \\u003c condition.requirements.length;\\n        requirementIdx++\\n      ) {\\n        string[] memory requirement = condition.requirements[requirementIdx];\\n        writer = writer.writeStartArray();\\n        for (\\n          uint256 requirementItemIdx;\\n          requirementItemIdx \\u003c requirement.length;\\n          requirementItemIdx++\\n        ) {\\n          writer = writer.writeStringValue(requirement[requirementItemIdx]);\\n        }\\n        writer = writer.writeEndArray();\\n      }\\n      writer = writer.writeEndArray();\\n\\n      // End object\\n      writer = writer.writeEndObject();\\n    }\\n    // End array\\n    writer = writer.writeEndArray();\\n    return writer.value;\\n  }\\n\\n  /**\\n   * @notice Fetch a list of all condition IDs\\n   * @return An array of condition IDs\\n   */\\n  function conditionsIdsList() public view returns (string[] memory) {\\n    return conditionsIds;\\n  }\\n\\n  /**\\n   * @notice Fetch the total number of conditions in this contract\\n   * @return Returns length of conditionIds\\n   */\\n  function conditionsLength() public view returns (uint256) {\\n    return conditionsIds.length;\\n  }\\n\\n  /**\\n   * @notice Check whether or not a condition exists\\n   * @param conditionId The ID of the condition\\n   * @return exists Returns true if the condition exists, false if not\\n   */\\n  function conditionExists(string memory conditionId)\\n    public\\n    returns (bool exists)\\n  {\\n    return !Strings.stringsEqual(conditionById[conditionId].id, \\\"\\\");\\n  }\\n\\n  /*******************************************************\\n   *                Condition Validation Logic\\n   *******************************************************/\\n  /**\\n   * @notice Validate the integrity of a condition\\n   * @dev For example: are the arguments of the condition valid, and do they point to a valid implementation?\\n   * @param condition The condition to validate\\n   */\\n  function validateCondition(Condition memory condition) public view {\\n    string[][] memory requirements = condition.requirements;\\n\\n    for (\\n      uint256 requirementIdx;\\n      requirementIdx \\u003c requirements.length;\\n      requirementIdx++\\n    ) {\\n      string[] memory requirement = requirements[requirementIdx];\\n      string memory requirementType = requirement[0];\\n      string memory requirementValidationMethod = requirement[1];\\n      string memory methodSignature;\\n      string memory paramType;\\n      bool requirementTypeIsTarget = Strings.stringsEqual(\\n        requirementType,\\n        \\\"target\\\"\\n      );\\n      bool requirementTypeIsParam = Strings.stringsEqual(\\n        requirementType,\\n        \\\"param\\\"\\n      );\\n      if (requirementTypeIsTarget) {\\n        require(\\n          requirement.length == 2,\\n          \\\"Requirement length must be equal to 2\\\"\\n        );\\n        methodSignature = string(\\n          abi.encodePacked(requirementValidationMethod, \\\"(address)\\\")\\n        );\\n      } else if (requirementTypeIsParam) {\\n        require(\\n          requirement.length == 3,\\n          \\\"Requirement length must be equal to 3\\\"\\n        );\\n        uint256 paramIdx = Strings.atoi(requirement[2], 10);\\n        require(\\n          paramIdx \\u003c= condition.paramTypes.length - 1,\\n          \\\"Requirement parameter index is out of range\\\"\\n        );\\n        paramType = condition.paramTypes[paramIdx];\\n        methodSignature = string(\\n          abi.encodePacked(requirementValidationMethod, \\\"(\\\", paramType, \\\")\\\")\\n        );\\n      } else {\\n        revert(\\\"Unsupported requirement type\\\");\\n      }\\n\\n      address implementationAddress = implementationById[\\n        condition.implementationId\\n      ];\\n      require(\\n        implementationAddress != address(0),\\n        \\\"Implementation address is not set\\\"\\n      );\\n\\n      bool implementsInterface = Introspection.implementsMethodSignature(\\n        implementationAddress,\\n        methodSignature\\n      );\\n      require(\\n        implementsInterface == true,\\n        \\\"Implementation does not implement method selector\\\"\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @notice Validate all conditions\\n   * @dev Reverts if some conditions are invalid\\n   */\\n  function validateConditions() public view {\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx \\u003c conditionsIds.length;\\n      conditionIdx++\\n    ) {\\n      string memory conditionId = conditionsIds[conditionIdx];\\n      Condition memory condition = conditionById[conditionId];\\n      validateCondition(condition);\\n    }\\n  }\\n\\n  /**\\n   * @notice Determine whether or not all conditions are valid\\n   * @return Return true if all conditions are valid, false if not\\n   */\\n  function conditionsValid() public view returns (bool) {\\n    (bool success, ) = address(this).staticcall(\\n      abi.encodeWithSignature(\\\"validateConditions()\\\")\\n    );\\n    return success;\\n  }\\n\\n  /**\\n   * @notice Determine whether or not a given target and calldata is valid\\n   * @dev In order to be valid, target and calldata must pass the allowlist conditions tests\\n   * @param targetAddress The target address of the method call\\n   * @param data The raw calldata of the call\\n   * @return isValid True if valid, false if not\\n   */\\n  function validateCalldata(address targetAddress, bytes calldata data)\\n    public\\n    view\\n    returns (bool isValid)\\n  {\\n    isValid = CalldataValidation.validateCalldataByAllowlist(\\n      address(this),\\n      targetAddress,\\n      data\\n    );\\n  }\\n}\\n\"},\"CalldataValidation.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./AbiDecoder.sol\\\";\\nimport \\\"./IAllowlist.sol\\\";\\n\\n/**\\n * @title Validate raw calldata against an allowlist\\n * @author yearn.finance\\n */\\n\\n/*******************************************************\\n *                   Main Contract Logic\\n *******************************************************/\\nlibrary CalldataValidation {\\n  /**\\n   * @notice Calculate a method signature given a condition\\n   * @param condition The condition from which to generate the signature\\n   * @return signature The method signature in string format (ie. \\\"approve(address,uint256)\\\")\\n   */\\n  function methodSignatureByCondition(IAllowlist.Condition memory condition)\\n    public\\n    pure\\n    returns (string memory signature)\\n  {\\n    bytes memory signatureBytes = abi.encodePacked(condition.methodName, \\\"(\\\");\\n    for (uint256 paramIdx; paramIdx \\u003c condition.paramTypes.length; paramIdx++) {\\n      signatureBytes = abi.encodePacked(\\n        signatureBytes,\\n        condition.paramTypes[paramIdx]\\n      );\\n      if (paramIdx + 1 \\u003c condition.paramTypes.length) {\\n        signatureBytes = abi.encodePacked(signatureBytes, \\\",\\\");\\n      }\\n    }\\n    signatureBytes = abi.encodePacked(signatureBytes, \\\")\\\");\\n    signature = string(signatureBytes);\\n  }\\n\\n  /**\\n   * @notice Check target validity\\n   * @param implementationAddress The address the validation method will be executed against\\n   * @param targetAddress The target address to validate\\n   * @param requirementValidationMethod The method to execute\\n   * @return targetValid Returns true if the target is valid and false otherwise\\n   * @dev If \\\"requirementValidationMethod\\\" is \\\"isValidVaultToken\\\" and target address is usdc\\n   *      the validation check will look like this: usdc.isValidVaultToken(targetAddress),\\n   *      where the result of the validation method is expected to return a bool\\n   */\\n  function checkTarget(\\n    address implementationAddress,\\n    address targetAddress,\\n    string memory requirementValidationMethod\\n  ) public view returns (bool targetValid) {\\n    string memory methodSignature = string(\\n      abi.encodePacked(requirementValidationMethod, \\\"(address)\\\")\\n    );\\n    (, bytes memory data) = address(implementationAddress).staticcall(\\n      abi.encodeWithSignature(methodSignature, targetAddress)\\n    );\\n    targetValid = abi.decode(data, (bool));\\n  }\\n\\n  /**\\n   * @notice Check method selector validity\\n   * @param data Raw input calldata (we will extract the 4-byte selector\\n   *             from the beginning of the calldata)\\n   * @param condition The condition struct to check (we generate the complete\\n   *        method selector using condition.methodName and condition.paramTypes)\\n   * @return methodSelectorValid Returns true if the method selector is valid and false otherwise\\n   */\\n  function checkMethodSelector(\\n    bytes calldata data,\\n    IAllowlist.Condition memory condition\\n  ) public pure returns (bool methodSelectorValid) {\\n    string memory methodSignature = methodSignatureByCondition(condition);\\n    bytes4 methodSelectorBySignature = bytes4(\\n      keccak256(bytes(methodSignature))\\n    );\\n    bytes4 methodSelectorByCalldata = bytes4(data[0:4]);\\n    methodSelectorValid = methodSelectorBySignature == methodSelectorByCalldata;\\n  }\\n\\n  /**\\n   * @notice Check an individual method param\\u0027s validity\\n   * @param implementationAddress The address the validation method will be executed against\\n   * @param requirement The specific requirement (of type \\\"param\\\") to check (ie. [\\\"param\\\", \\\"isVault\\\", \\\"0\\\"])\\n   * @dev A condition may have multiple requirements, all of which must be true\\n   * @dev The middle element of a requirement is the requirement validation method\\n   * @dev The last element of a requirement is the parameter index to validate against\\n   * @param condition The entire condition struct to check the param against\\n   * @param data Raw input calldata for the original method call\\n   * @return Returns true if the param is valid, false if not\\n   */\\n  function checkParam(\\n    address implementationAddress,\\n    string[] memory requirement,\\n    IAllowlist.Condition memory condition,\\n    bytes calldata data\\n  ) public view returns (bool) {\\n    uint256 paramIdx = Strings.atoi(requirement[2], 10);\\n    string memory paramType = condition.paramTypes[paramIdx];\\n    bytes memory paramCalldata = AbiDecoder.getParamFromCalldata(\\n      data,\\n      paramType,\\n      paramIdx\\n    );\\n    string memory methodSignature = string(\\n      abi.encodePacked(requirement[1], \\\"(\\\", paramType, \\\")\\\")\\n    );\\n    bytes memory encodedCalldata = abi.encodePacked(\\n      bytes4(keccak256(bytes(methodSignature))),\\n      paramCalldata\\n    );\\n    bool success;\\n    bytes memory resultData;\\n    (success, resultData) = address(implementationAddress).staticcall(\\n      encodedCalldata\\n    );\\n    if (success) {\\n      return abi.decode(resultData, (bool));\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * @notice Test a target address and calldata against a specific condition and implementation\\n   * @param condition The condition to test\\n   * @param targetAddress Target address of the original method call\\n   * @param data Calldata of the original methodcall\\n   * @return Returns true if the condition passes and false if not\\n   * @dev The condition check is comprised of 3 parts:\\n          - Method selector check (to make sure the calldata method selector matches the condition method selector)\\n          - Target check (to make sure the target is valid)\\n          - Param check (to make sure the specified param is valid)\\n   */\\n  function testCondition(\\n    address allowlistAddress,\\n    IAllowlist.Condition memory condition,\\n    address targetAddress,\\n    bytes calldata data\\n  ) public view returns (bool) {\\n    string[][] memory requirements = condition.requirements;\\n    address implementationAddress = IAllowlist(allowlistAddress)\\n      .implementationById(condition.implementationId);\\n    for (\\n      uint256 requirementIdx;\\n      requirementIdx \\u003c requirements.length;\\n      requirementIdx++\\n    ) {\\n      string[] memory requirement = requirements[requirementIdx];\\n      string memory requirementType = requirement[0];\\n      string memory requirementValidationMethod = requirement[1];\\n      if (!checkMethodSelector(data, condition)) {\\n        return false;\\n      }\\n      if (Strings.stringsEqual(requirementType, \\\"target\\\")) {\\n        bool targetValid = checkTarget(\\n          implementationAddress,\\n          targetAddress,\\n          requirementValidationMethod\\n        );\\n        if (!targetValid) {\\n          return false;\\n        }\\n      } else if (Strings.stringsEqual(requirementType, \\\"param\\\")) {\\n        bool paramValid = checkParam(\\n          implementationAddress,\\n          requirement,\\n          condition,\\n          data\\n        );\\n        if (!paramValid) {\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Test target address and calldata against all stored protocol conditions\\n   * @dev This is done to determine whether or not the target address and calldata are valid and whitelisted\\n   * @dev This is the primary method that should be called by integrators\\n   * @param allowlistAddress The address of the allowlist to check calldata against\\n   * @param targetAddress The target address of the call\\n   * @param data The raw calldata to test\\n   * @return Returns true if the calldata/target test is successful and false if not\\n   */\\n  function validateCalldataByAllowlist(\\n    address allowlistAddress,\\n    address targetAddress,\\n    bytes calldata data\\n  ) public view returns (bool) {\\n    IAllowlist.Condition[] memory _conditions = IAllowlist(allowlistAddress)\\n      .conditionsList();\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx \\u003c _conditions.length;\\n      conditionIdx++\\n    ) {\\n      IAllowlist.Condition memory condition = _conditions[conditionIdx];\\n      bool conditionPassed = testCondition(\\n        allowlistAddress,\\n        condition,\\n        targetAddress,\\n        data\\n      );\\n      if (conditionPassed) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n}\\n\"},\"IAllowlist.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\nimport \\\"./IOwnable.sol\\\";\\n\\ninterface IAllowlist is IOwnable {\\n  struct Condition {\\n    string id;\\n    string implementationId;\\n    string methodName;\\n    string[] paramTypes;\\n    string[][] requirements;\\n  }\\n\\n  struct Implementation {\\n    string id;\\n    address addr;\\n  }\\n\\n  function conditionsList() external view returns (Condition[] memory);\\n\\n  function addConditions(Condition[] memory) external;\\n\\n  function setImplementations(Implementation[] memory) external;\\n\\n  function implementationById(string memory) external view returns (address);\\n}\\n\"},\"Introspection.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\n/**\\n * @title Detect whether or not a contract implements a specific method signature\\n * @dev Works by scanning bytecode for PUSH4 operations\\n * @author yearn.finance\\n */\\n\\nlibrary Introspection {\\n  function implementsMethodSignature(address _address, string memory _signature)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    bytes4 _selector = bytes4(keccak256(bytes(_signature)));\\n    uint256 contractSize;\\n    assembly {\\n      contractSize := extcodesize(_address)\\n    }\\n    bytes memory code = new bytes(contractSize);\\n    assembly {\\n      extcodecopy(_address, add(code, 0x20), 0, contractSize)\\n    }\\n    uint256 ptr = 0;\\n    while (ptr \\u003c contractSize) {\\n      // PUSH4 0x000000 (selector)\\n      if (code[ptr] == 0x63) {\\n        bytes memory selectorBytes = new bytes(64);\\n        selectorBytes[0] = code[ptr + 1];\\n        selectorBytes[1] = code[ptr + 2];\\n        selectorBytes[2] = code[ptr + 3];\\n        selectorBytes[3] = code[ptr + 4];\\n        bytes4 selector = abi.decode(selectorBytes, (bytes4));\\n        if (selector == _selector) {\\n          return true;\\n        }\\n      }\\n      ptr++;\\n    }\\n    return false;\\n  }\\n\\n  function implementsInterface(address _address, string[] memory _interface)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    for (uint256 methodIdx = 0; methodIdx \\u003c _interface.length; methodIdx++) {\\n      string memory method = _interface[methodIdx];\\n      bool methodIsImplemented = implementsMethodSignature(_address, method);\\n      if (!methodIsImplemented) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n\"},\"IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\ninterface IOwnable {\\n  function setOwnerAddress(address _ownerAddress) external;\\n}\\n\"},\"JsonWriter.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\n/**\\n * @title Write nested JSON using solidity\\n * @author Ben Meredith\\n * @dev https://github.com/bmeredith/solidity-json-writer\\n */\\n\\nlibrary JsonWriter {\\n  using JsonWriter for string;\\n\\n  struct Json {\\n    int256 depthBitTracker;\\n    string value;\\n  }\\n\\n  bytes1 constant BACKSLASH = bytes1(uint8(92));\\n  bytes1 constant BACKSPACE = bytes1(uint8(8));\\n  bytes1 constant CARRIAGE_RETURN = bytes1(uint8(13));\\n  bytes1 constant DOUBLE_QUOTE = bytes1(uint8(34));\\n  bytes1 constant FORM_FEED = bytes1(uint8(12));\\n  bytes1 constant FRONTSLASH = bytes1(uint8(47));\\n  bytes1 constant HORIZONTAL_TAB = bytes1(uint8(9));\\n  bytes1 constant NEWLINE = bytes1(uint8(10));\\n\\n  string constant TRUE = \\\"true\\\";\\n  string constant FALSE = \\\"false\\\";\\n  bytes1 constant OPEN_BRACE = \\\"{\\\";\\n  bytes1 constant CLOSED_BRACE = \\\"}\\\";\\n  bytes1 constant OPEN_BRACKET = \\\"[\\\";\\n  bytes1 constant CLOSED_BRACKET = \\\"]\\\";\\n  bytes1 constant LIST_SEPARATOR = \\\",\\\";\\n\\n  int256 constant MAX_INT256 = type(int256).max;\\n\\n  /**\\n   * @dev Writes the beginning of a JSON array.\\n   */\\n  function writeStartArray(Json memory json) public pure returns (Json memory) {\\n    return writeStart(json, OPEN_BRACKET);\\n  }\\n\\n  /**\\n   * @dev Writes the beginning of a JSON array with a property name as the key.\\n   */\\n  function writeStartArray(Json memory json, string memory propertyName)\\n    public\\n    pure\\n    returns (Json memory)\\n  {\\n    return writeStart(json, propertyName, OPEN_BRACKET);\\n  }\\n\\n  /**\\n   * @dev Writes the beginning of a JSON object.\\n   */\\n  function writeStartObject(Json memory json)\\n    public\\n    pure\\n    returns (Json memory)\\n  {\\n    return writeStart(json, OPEN_BRACE);\\n  }\\n\\n  /**\\n   * @dev Writes the beginning of a JSON object with a property name as the key.\\n   */\\n  function writeStartObject(Json memory json, string memory propertyName)\\n    public\\n    pure\\n    returns (Json memory)\\n  {\\n    return writeStart(json, propertyName, OPEN_BRACE);\\n  }\\n\\n  /**\\n   * @dev Writes the end of a JSON array.\\n   */\\n  function writeEndArray(Json memory json) public pure returns (Json memory) {\\n    return writeEnd(json, CLOSED_BRACKET);\\n  }\\n\\n  /**\\n   * @dev Writes the end of a JSON object.\\n   */\\n  function writeEndObject(Json memory json) public pure returns (Json memory) {\\n    return writeEnd(json, CLOSED_BRACE);\\n  }\\n\\n  /**\\n   * @dev Writes the property name and address value (as a JSON string) as part of a name/value pair of a JSON object.\\n   */\\n  function writeAddressProperty(\\n    Json memory json,\\n    string memory propertyName,\\n    address value\\n  ) public pure returns (Json memory) {\\n    if (json.depthBitTracker \\u003c 0) {\\n      json.value = string(\\n        abi.encodePacked(\\n          json.value,\\n          LIST_SEPARATOR,\\n          \\u0027\\\"\\u0027,\\n          propertyName,\\n          \\u0027\\\": \\\"\\u0027,\\n          addressToString(value),\\n          \\u0027\\\"\\u0027\\n        )\\n      );\\n    } else {\\n      json.value = string(\\n        abi.encodePacked(\\n          json.value,\\n          \\u0027\\\"\\u0027,\\n          propertyName,\\n          \\u0027\\\": \\\"\\u0027,\\n          addressToString(value),\\n          \\u0027\\\"\\u0027\\n        )\\n      );\\n    }\\n\\n    json.depthBitTracker = setListSeparatorFlag(json);\\n\\n    return json;\\n  }\\n\\n  /**\\n   * @dev Writes the address value (as a JSON string) as an element of a JSON array.\\n   */\\n  function writeAddressValue(Json memory json, address value)\\n    public\\n    pure\\n    returns (Json memory)\\n  {\\n    if (json.depthBitTracker \\u003c 0) {\\n      json.value = string(\\n        abi.encodePacked(\\n          json.value,\\n          LIST_SEPARATOR,\\n          \\u0027\\\"\\u0027,\\n          addressToString(value),\\n          \\u0027\\\"\\u0027\\n        )\\n      );\\n    } else {\\n      json.value = string(\\n        abi.encodePacked(json.value, \\u0027\\\"\\u0027, addressToString(value), \\u0027\\\"\\u0027)\\n      );\\n    }\\n\\n    json.depthBitTracker = setListSeparatorFlag(json);\\n\\n    return json;\\n  }\\n\\n  /**\\n   * @dev Writes the property name and boolean value (as a JSON literal \\\"true\\\" or \\\"false\\\") as part of a name/value pair of a JSON object.\\n   */\\n  function writeBooleanProperty(\\n    Json memory json,\\n    string memory propertyName,\\n    bool value\\n  ) public pure returns (Json memory) {\\n    string memory strValue;\\n    if (value) {\\n      strValue = TRUE;\\n    } else {\\n      strValue = FALSE;\\n    }\\n\\n    if (json.depthBitTracker \\u003c 0) {\\n      json.value = string(\\n        abi.encodePacked(\\n          json.value,\\n          LIST_SEPARATOR,\\n          \\u0027\\\"\\u0027,\\n          propertyName,\\n          \\u0027\\\": \\u0027,\\n          strValue\\n        )\\n      );\\n    } else {\\n      json.value = string(\\n        abi.encodePacked(json.value, \\u0027\\\"\\u0027, propertyName, \\u0027\\\": \\u0027, strValue)\\n      );\\n    }\\n\\n    json.depthBitTracker = setListSeparatorFlag(json);\\n\\n    return json;\\n  }\\n\\n  /**\\n   * @dev Writes the boolean value (as a JSON literal \\\"true\\\" or \\\"false\\\") as an element of a JSON array.\\n   */\\n  function writeBooleanValue(Json memory json, bool value)\\n    public\\n    pure\\n    returns (Json memory)\\n  {\\n    string memory strValue;\\n    if (value) {\\n      strValue = TRUE;\\n    } else {\\n      strValue = FALSE;\\n    }\\n\\n    if (json.depthBitTracker \\u003c 0) {\\n      json.value = string(\\n        abi.encodePacked(json.value, LIST_SEPARATOR, strValue)\\n      );\\n    } else {\\n      json.value = string(abi.encodePacked(json.value, strValue));\\n    }\\n\\n    json.depthBitTracker = setListSeparatorFlag(json);\\n\\n    return json;\\n  }\\n\\n  /**\\n   * @dev Writes the property name and int value (as a JSON number) as part of a name/value pair of a JSON object.\\n   */\\n  function writeIntProperty(\\n    Json memory json,\\n    string memory propertyName,\\n    int256 value\\n  ) public pure returns (Json memory) {\\n    if (json.depthBitTracker \\u003c 0) {\\n      json.value = string(\\n        abi.encodePacked(\\n          json.value,\\n          LIST_SEPARATOR,\\n          \\u0027\\\"\\u0027,\\n          propertyName,\\n          \\u0027\\\": \\u0027,\\n          intToString(value)\\n        )\\n      );\\n    } else {\\n      json.value = string(\\n        abi.encodePacked(\\n          json.value,\\n          \\u0027\\\"\\u0027,\\n          propertyName,\\n          \\u0027\\\": \\u0027,\\n          intToString(value)\\n        )\\n      );\\n    }\\n\\n    json.depthBitTracker = setListSeparatorFlag(json);\\n\\n    return json;\\n  }\\n\\n  /**\\n   * @dev Writes the int value (as a JSON number) as an element of a JSON array.\\n   */\\n  function writeIntValue(Json memory json, int256 value)\\n    public\\n    pure\\n    returns (Json memory)\\n  {\\n    if (json.depthBitTracker \\u003c 0) {\\n      json.value = string(\\n        abi.encodePacked(json.value, LIST_SEPARATOR, intToString(value))\\n      );\\n    } else {\\n      json.value = string(abi.encodePacked(json.value, intToString(value)));\\n    }\\n\\n    json.depthBitTracker = setListSeparatorFlag(json);\\n\\n    return json;\\n  }\\n\\n  /**\\n   * @dev Writes the property name and value of null as part of a name/value pair of a JSON object.\\n   */\\n  function writeNullProperty(Json memory json, string memory propertyName)\\n    public\\n    pure\\n    returns (Json memory)\\n  {\\n    if (json.depthBitTracker \\u003c 0) {\\n      json.value = string(\\n        abi.encodePacked(\\n          json.value,\\n          LIST_SEPARATOR,\\n          \\u0027\\\"\\u0027,\\n          propertyName,\\n          \\u0027\\\": null\\u0027\\n        )\\n      );\\n    } else {\\n      json.value = string(\\n        abi.encodePacked(json.value, \\u0027\\\"\\u0027, propertyName, \\u0027\\\": null\\u0027)\\n      );\\n    }\\n\\n    json.depthBitTracker = setListSeparatorFlag(json);\\n\\n    return json;\\n  }\\n\\n  /**\\n   * @dev Writes the value of null as an element of a JSON array.\\n   */\\n  function writeNullValue(Json memory json) public pure returns (Json memory) {\\n    if (json.depthBitTracker \\u003c 0) {\\n      json.value = string(abi.encodePacked(json.value, LIST_SEPARATOR, \\\"null\\\"));\\n    } else {\\n      json.value = string(abi.encodePacked(json.value, \\\"null\\\"));\\n    }\\n\\n    json.depthBitTracker = setListSeparatorFlag(json);\\n\\n    return json;\\n  }\\n\\n  /**\\n   * @dev Writes the string text value (as a JSON string) as an element of a JSON array.\\n   */\\n  function writeStringProperty(\\n    Json memory json,\\n    string memory propertyName,\\n    string memory value\\n  ) public pure returns (Json memory) {\\n    string memory jsonEscapedString = escapeJsonString(value);\\n    if (json.depthBitTracker \\u003c 0) {\\n      json.value = string(\\n        abi.encodePacked(\\n          json.value,\\n          LIST_SEPARATOR,\\n          \\u0027\\\"\\u0027,\\n          propertyName,\\n          \\u0027\\\": \\\"\\u0027,\\n          jsonEscapedString,\\n          \\u0027\\\"\\u0027\\n        )\\n      );\\n    } else {\\n      json.value = string(\\n        abi.encodePacked(\\n          json.value,\\n          \\u0027\\\"\\u0027,\\n          propertyName,\\n          \\u0027\\\": \\\"\\u0027,\\n          jsonEscapedString,\\n          \\u0027\\\"\\u0027\\n        )\\n      );\\n    }\\n\\n    json.depthBitTracker = setListSeparatorFlag(json);\\n\\n    return json;\\n  }\\n\\n  /**\\n   * @dev Writes the property name and string text value (as a JSON string) as part of a name/value pair of a JSON object.\\n   */\\n  function writeStringValue(Json memory json, string memory value)\\n    public\\n    pure\\n    returns (Json memory)\\n  {\\n    string memory jsonEscapedString = escapeJsonString(value);\\n    if (json.depthBitTracker \\u003c 0) {\\n      json.value = string(\\n        abi.encodePacked(\\n          json.value,\\n          LIST_SEPARATOR,\\n          \\u0027\\\"\\u0027,\\n          jsonEscapedString,\\n          \\u0027\\\"\\u0027\\n        )\\n      );\\n    } else {\\n      json.value = string(\\n        abi.encodePacked(json.value, \\u0027\\\"\\u0027, jsonEscapedString, \\u0027\\\"\\u0027)\\n      );\\n    }\\n\\n    json.depthBitTracker = setListSeparatorFlag(json);\\n\\n    return json;\\n  }\\n\\n  /**\\n   * @dev Writes the property name and uint value (as a JSON number) as part of a name/value pair of a JSON object.\\n   */\\n  function writeUintProperty(\\n    Json memory json,\\n    string memory propertyName,\\n    uint256 value\\n  ) public pure returns (Json memory) {\\n    if (json.depthBitTracker \\u003c 0) {\\n      json.value = string(\\n        abi.encodePacked(\\n          json.value,\\n          LIST_SEPARATOR,\\n          \\u0027\\\"\\u0027,\\n          propertyName,\\n          \\u0027\\\": \\u0027,\\n          uintToString(value)\\n        )\\n      );\\n    } else {\\n      json.value = string(\\n        abi.encodePacked(\\n          json.value,\\n          \\u0027\\\"\\u0027,\\n          propertyName,\\n          \\u0027\\\": \\u0027,\\n          uintToString(value)\\n        )\\n      );\\n    }\\n\\n    json.depthBitTracker = setListSeparatorFlag(json);\\n\\n    return json;\\n  }\\n\\n  /**\\n   * @dev Writes the uint value (as a JSON number) as an element of a JSON array.\\n   */\\n  function writeUintValue(Json memory json, uint256 value)\\n    public\\n    pure\\n    returns (Json memory)\\n  {\\n    if (json.depthBitTracker \\u003c 0) {\\n      json.value = string(\\n        abi.encodePacked(json.value, LIST_SEPARATOR, uintToString(value))\\n      );\\n    } else {\\n      json.value = string(abi.encodePacked(json.value, uintToString(value)));\\n    }\\n\\n    json.depthBitTracker = setListSeparatorFlag(json);\\n\\n    return json;\\n  }\\n\\n  /**\\n   * @dev Writes the beginning of a JSON array or object based on the token parameter.\\n   */\\n  function writeStart(Json memory json, bytes1 token)\\n    public\\n    pure\\n    returns (Json memory)\\n  {\\n    if (json.depthBitTracker \\u003c 0) {\\n      json.value = string(abi.encodePacked(json.value, LIST_SEPARATOR, token));\\n    } else {\\n      json.value = string(abi.encodePacked(json.value, token));\\n    }\\n\\n    json.depthBitTracker \\u0026= MAX_INT256;\\n    json.depthBitTracker++;\\n\\n    return json;\\n  }\\n\\n  /**\\n   * @dev Writes the beginning of a JSON array or object based on the token parameter with a property name as the key.\\n   */\\n  function writeStart(\\n    Json memory json,\\n    string memory propertyName,\\n    bytes1 token\\n  ) public pure returns (Json memory) {\\n    if (json.depthBitTracker \\u003c 0) {\\n      json.value = string(\\n        abi.encodePacked(\\n          json.value,\\n          LIST_SEPARATOR,\\n          \\u0027\\\"\\u0027,\\n          propertyName,\\n          \\u0027\\\": \\u0027,\\n          token\\n        )\\n      );\\n    } else {\\n      json.value = string(\\n        abi.encodePacked(json.value, \\u0027\\\"\\u0027, propertyName, \\u0027\\\": \\u0027, token)\\n      );\\n    }\\n\\n    json.depthBitTracker \\u0026= MAX_INT256;\\n    json.depthBitTracker++;\\n\\n    return json;\\n  }\\n\\n  /**\\n   * @dev Writes the end of a JSON array or object based on the token parameter.\\n   */\\n  function writeEnd(Json memory json, bytes1 token)\\n    public\\n    pure\\n    returns (Json memory)\\n  {\\n    json.value = string(abi.encodePacked(json.value, token));\\n    json.depthBitTracker = setListSeparatorFlag(json);\\n\\n    if (getCurrentDepth(json) != 0) {\\n      json.depthBitTracker--;\\n    }\\n\\n    return json;\\n  }\\n\\n  /**\\n   * @dev Escapes any characters that required by JSON to be escaped.\\n   */\\n  function escapeJsonString(string memory value)\\n    public\\n    pure\\n    returns (string memory str)\\n  {\\n    bytes memory b = bytes(value);\\n    bool foundEscapeChars;\\n\\n    for (uint256 i; i \\u003c b.length; i++) {\\n      if (b[i] == BACKSLASH) {\\n        foundEscapeChars = true;\\n        break;\\n      } else if (b[i] == DOUBLE_QUOTE) {\\n        foundEscapeChars = true;\\n        break;\\n      } else if (b[i] == FRONTSLASH) {\\n        foundEscapeChars = true;\\n        break;\\n      } else if (b[i] == HORIZONTAL_TAB) {\\n        foundEscapeChars = true;\\n        break;\\n      } else if (b[i] == FORM_FEED) {\\n        foundEscapeChars = true;\\n        break;\\n      } else if (b[i] == NEWLINE) {\\n        foundEscapeChars = true;\\n        break;\\n      } else if (b[i] == CARRIAGE_RETURN) {\\n        foundEscapeChars = true;\\n        break;\\n      } else if (b[i] == BACKSPACE) {\\n        foundEscapeChars = true;\\n        break;\\n      }\\n    }\\n\\n    if (!foundEscapeChars) {\\n      return value;\\n    }\\n\\n    for (uint256 i; i \\u003c b.length; i++) {\\n      if (b[i] == BACKSLASH) {\\n        str = string(abi.encodePacked(str, \\\"\\\\\\\\\\\\\\\\\\\"));\\n      } else if (b[i] == DOUBLE_QUOTE) {\\n        str = string(abi.encodePacked(str, \\u0027\\\\\\\\\\\"\\u0027));\\n      } else if (b[i] == FRONTSLASH) {\\n        str = string(abi.encodePacked(str, \\\"\\\\\\\\/\\\"));\\n      } else if (b[i] == HORIZONTAL_TAB) {\\n        str = string(abi.encodePacked(str, \\\"\\\\\\\\t\\\"));\\n      } else if (b[i] == FORM_FEED) {\\n        str = string(abi.encodePacked(str, \\\"\\\\\\\\f\\\"));\\n      } else if (b[i] == NEWLINE) {\\n        str = string(abi.encodePacked(str, \\\"\\\\\\\\n\\\"));\\n      } else if (b[i] == CARRIAGE_RETURN) {\\n        str = string(abi.encodePacked(str, \\\"\\\\\\\\r\\\"));\\n      } else if (b[i] == BACKSPACE) {\\n        str = string(abi.encodePacked(str, \\\"\\\\\\\\b\\\"));\\n      } else {\\n        str = string(abi.encodePacked(str, b[i]));\\n      }\\n    }\\n\\n    return str;\\n  }\\n\\n  /**\\n   * @dev Tracks the recursive depth of the nested objects / arrays within the JSON text\\n   * written so far. This provides the depth of the current token.\\n   */\\n  function getCurrentDepth(Json memory json) public pure returns (int256) {\\n    return json.depthBitTracker \\u0026 MAX_INT256;\\n  }\\n\\n  /**\\n   * @dev The highest order bit of json.depthBitTracker is used to discern whether we are writing the first item in a list or not.\\n   * if (json.depthBitTracker \\u003e\\u003e 255) == 1, add a list separator before writing the item\\n   * else, no list separator is needed since we are writing the first item.\\n   */\\n  function setListSeparatorFlag(Json memory json)\\n    private\\n    pure\\n    returns (int256)\\n  {\\n    return json.depthBitTracker | (int256(1) \\u003c\\u003c 255);\\n  }\\n\\n  /**\\n   * @dev Converts an address to a string.\\n   */\\n  function addressToString(address _address)\\n    internal\\n    pure\\n    returns (string memory)\\n  {\\n    bytes32 value = bytes32(uint256(uint160(_address)));\\n    bytes16 alphabet = \\\"0123456789abcdef\\\";\\n\\n    bytes memory str = new bytes(42);\\n    str[0] = \\\"0\\\";\\n    str[1] = \\\"x\\\";\\n    for (uint256 i; i \\u003c 20; i++) {\\n      str[2 + i * 2] = alphabet[uint8(value[i + 12] \\u003e\\u003e 4)];\\n      str[3 + i * 2] = alphabet[uint8(value[i + 12] \\u0026 0x0f)];\\n    }\\n\\n    return string(str);\\n  }\\n\\n  /**\\n   * @dev Converts an int to a string.\\n   */\\n  function intToString(int256 i) internal pure returns (string memory) {\\n    if (i == 0) {\\n      return \\\"0\\\";\\n    }\\n\\n    if (i == type(int256).min) {\\n      // hard-coded since int256 min value can\\u0027t be converted to unsigned\\n      return\\n        \\\"-57896044618658097711785492504343953926634992332820282019728792003956564819968\\\";\\n    }\\n\\n    bool negative = i \\u003c 0;\\n    uint256 len;\\n    uint256 j;\\n    if (!negative) {\\n      j = uint256(i);\\n    } else {\\n      j = uint256(-i);\\n      ++len; // make room for \\u0027-\\u0027 sign\\n    }\\n\\n    uint256 l = j;\\n    while (j != 0) {\\n      len++;\\n      j /= 10;\\n    }\\n\\n    bytes memory bstr = new bytes(len);\\n    uint256 k = len;\\n    while (l != 0) {\\n      bstr[--k] = bytes1((48 + uint8(l - (l / 10) * 10)));\\n      l /= 10;\\n    }\\n\\n    if (negative) {\\n      bstr[0] = \\\"-\\\"; // prepend \\u0027-\\u0027\\n    }\\n\\n    return string(bstr);\\n  }\\n\\n  /**\\n   * @dev Converts a uint to a string.\\n   */\\n  function uintToString(uint256 _i) internal pure returns (string memory) {\\n    if (_i == 0) {\\n      return \\\"0\\\";\\n    }\\n\\n    uint256 j = _i;\\n    uint256 len;\\n    while (j != 0) {\\n      len++;\\n      j /= 10;\\n    }\\n\\n    bytes memory bstr = new bytes(len);\\n    uint256 k = len;\\n    while (_i != 0) {\\n      bstr[--k] = bytes1((48 + uint8(_i - (_i / 10) * 10)));\\n      _i /= 10;\\n    }\\n\\n    return string(bstr);\\n  }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\nimport \\\"./IOwnable.sol\\\";\\n\\ncontract Ownable is IOwnable {\\n  address public ownerAddress;\\n\\n  constructor() {\\n    ownerAddress = msg.sender;\\n  }\\n\\n  modifier onlyOwner() {\\n    require(msg.sender == ownerAddress, \\\"Ownable: caller is not the owner\\\");\\n    _;\\n  }\\n\\n  function setOwnerAddress(address _ownerAddress) public onlyOwner {\\n    ownerAddress = _ownerAddress;\\n  }\\n}\\n\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\n/**\\n * @title Small library for working with strings\\n * @author yearn.finance\\n */\\n\\nlibrary Strings {\\n  /**\\n   * @notice Search for a needle in a haystack\\n   * @param haystack The string to search\\n   * @param needle The string to search for\\n   */\\n  function stringStartsWith(string memory haystack, string memory needle)\\n    public\\n    pure\\n    returns (bool)\\n  {\\n    return indexOfStringInString(needle, haystack) == 0;\\n  }\\n\\n  /**\\n   * @notice Find the index of a string in another string\\n   * @param needle The string to search for\\n   * @param haystack The string to search\\n   * @return Returns -1 if no match is found, otherwise returns the index of the match\\n   */\\n  function indexOfStringInString(string memory needle, string memory haystack)\\n    public\\n    pure\\n    returns (int256)\\n  {\\n    bytes memory _needle = bytes(needle);\\n    bytes memory _haystack = bytes(haystack);\\n    if (_haystack.length \\u003c _needle.length) {\\n      return -1;\\n    }\\n    bool _match;\\n    for (uint256 haystackIdx; haystackIdx \\u003c _haystack.length; haystackIdx++) {\\n      for (uint256 needleIdx; needleIdx \\u003c _needle.length; needleIdx++) {\\n        uint8 needleChar = uint8(_needle[needleIdx]);\\n        if (haystackIdx + needleIdx \\u003e= _haystack.length) {\\n          return -1;\\n        }\\n        uint8 haystackChar = uint8(_haystack[haystackIdx + needleIdx]);\\n        if (needleChar == haystackChar) {\\n          _match = true;\\n          if (needleIdx == _needle.length - 1) {\\n            return int256(haystackIdx);\\n          }\\n        } else {\\n          _match = false;\\n          break;\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n\\n  /**\\n   * @notice Check to see if two strings are exactly equal\\n   * @dev Supports strings of arbitrary length\\n   * @param input0 First string to compare\\n   * @param input1 Second string to compare\\n   * @return Returns true if strings are exactly equal, false if not\\n   */\\n  function stringsEqual(string memory input0, string memory input1)\\n    public\\n    pure\\n    returns (bool)\\n  {\\n    uint256 input0Length = bytes(input0).length;\\n    uint256 input1Length = bytes(input1).length;\\n    uint256 maxLength;\\n    if (input0Length \\u003e input1Length) {\\n      maxLength = input0Length;\\n    } else {\\n      maxLength = input1Length;\\n    }\\n    uint256 numberOfRowsToCompare = (maxLength / 32) + 1;\\n    bytes32 input0Bytes32;\\n    bytes32 input1Bytes32;\\n    for (uint256 rowIdx; rowIdx \\u003c numberOfRowsToCompare; rowIdx++) {\\n      uint256 offset = 0x20 * (rowIdx + 1);\\n      assembly {\\n        input0Bytes32 := mload(add(input0, offset))\\n        input1Bytes32 := mload(add(input1, offset))\\n      }\\n      if (input0Bytes32 != input1Bytes32) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Convert ASCII to integer\\n   * @param input Integer as a string (ie. \\\"345\\\")\\n   * @param base Base to use for the conversion (10 for decimal)\\n   * @return output Returns uint256 representation of input string\\n   * @dev Based on GemERC721 utility but includes a fix\\n   */\\n  function atoi(string memory input, uint8 base)\\n    public\\n    pure\\n    returns (uint256 output)\\n  {\\n    require(base == 2 || base == 8 || base == 10 || base == 16);\\n    bytes memory buf = bytes(input);\\n    for (uint256 idx = 0; idx \\u003c buf.length; idx++) {\\n      uint8 digit = uint8(buf[idx]) - 0x30;\\n      if (digit \\u003e 10) {\\n        digit -= 7;\\n      }\\n      require(digit \\u003c base);\\n      output *= base;\\n      output += digit;\\n    }\\n    return output;\\n  }\\n\\n  /**\\n   * @notice Convert integer to ASCII\\n   * @param input Integer as a string (ie. \\\"345\\\")\\n   * @param base Base to use for the conversion (10 for decimal)\\n   * @return output Returns string representation of input integer\\n   * @dev Based on GemERC721 utility but includes a fix\\n   */\\n  function itoa(uint256 input, uint8 base)\\n    public\\n    pure\\n    returns (string memory output)\\n  {\\n    require(base == 2 || base == 8 || base == 10 || base == 16);\\n    if (input == 0) {\\n      return \\\"0\\\";\\n    }\\n    bytes memory buf = new bytes(256);\\n    uint256 idx = 0;\\n    while (input \\u003e 0) {\\n      uint8 digit = uint8(input % base);\\n      uint8 ascii = digit + 0x30;\\n      if (digit \\u003e 9) {\\n        ascii += 7;\\n      }\\n      buf[idx++] = bytes1(ascii);\\n      input /= base;\\n    }\\n    uint256 length = idx;\\n    for (idx = 0; idx \\u003c length / 2; idx++) {\\n      buf[idx] ^= buf[length - 1 - idx];\\n      buf[length - 1 - idx] ^= buf[idx];\\n      buf[idx] ^= buf[length - 1 - idx];\\n    }\\n    output = string(buf);\\n  }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"implementationId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"paramTypes\",\"type\":\"string[]\"},{\"internalType\":\"string[][]\",\"name\":\"requirements\",\"type\":\"string[][]\"}],\"internalType\":\"struct IAllowlist.Condition\",\"name\":\"condition\",\"type\":\"tuple\"}],\"name\":\"addCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"implementationId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"paramTypes\",\"type\":\"string[]\"},{\"internalType\":\"string[][]\",\"name\":\"requirements\",\"type\":\"string[][]\"}],\"internalType\":\"struct IAllowlist.Condition\",\"name\":\"condition\",\"type\":\"tuple\"}],\"name\":\"addConditionWithoutValidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"implementationId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"paramTypes\",\"type\":\"string[]\"},{\"internalType\":\"string[][]\",\"name\":\"requirements\",\"type\":\"string[][]\"}],\"internalType\":\"struct IAllowlist.Condition[]\",\"name\":\"_conditions\",\"type\":\"tuple[]\"}],\"name\":\"addConditions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"implementationId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"paramTypes\",\"type\":\"string[]\"},{\"internalType\":\"string[][]\",\"name\":\"requirements\",\"type\":\"string[][]\"}],\"internalType\":\"struct IAllowlist.Condition[]\",\"name\":\"_conditions\",\"type\":\"tuple[]\"}],\"name\":\"addConditionsWithoutValidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowlistFactoryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"conditionById\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"implementationId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"conditionId\",\"type\":\"string\"}],\"name\":\"conditionExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"conditionsIds\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"conditionsIdsList\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"conditionsJson\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"conditionsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"conditionsList\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"implementationId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"paramTypes\",\"type\":\"string[]\"},{\"internalType\":\"string[][]\",\"name\":\"requirements\",\"type\":\"string[][]\"}],\"internalType\":\"struct IAllowlist.Condition[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"conditionsValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deleteAllConditions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"conditionId\",\"type\":\"string\"}],\"name\":\"deleteCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_conditionsIds\",\"type\":\"string[]\"}],\"name\":\"deleteConditions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"implementationById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"implementationsIds\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementationsIdsList\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementationsList\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"internalType\":\"struct IAllowlist.Implementation[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"implementationId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"implementationAddress\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"internalType\":\"struct IAllowlist.Implementation[]\",\"name\":\"implementations\",\"type\":\"tuple[]\"}],\"name\":\"setImplementations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ownerAddress\",\"type\":\"address\"}],\"name\":\"setOwnerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"implementationId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"paramTypes\",\"type\":\"string[]\"},{\"internalType\":\"string[][]\",\"name\":\"requirements\",\"type\":\"string[][]\"}],\"internalType\":\"struct IAllowlist.Condition\",\"name\":\"condition\",\"type\":\"tuple\"}],\"name\":\"updateCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"validateCalldata\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"implementationId\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"paramTypes\",\"type\":\"string[]\"},{\"internalType\":\"string[][]\",\"name\":\"requirements\",\"type\":\"string[][]\"}],\"internalType\":\"struct IAllowlist.Condition\",\"name\":\"condition\",\"type\":\"tuple\"}],\"name\":\"validateCondition\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validateConditions\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Allowlist", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "Strings:af69afdc6b6bc0d61abd47b3ff8999b0e0e23a27;CalldataValidation:a7e44772ae8280698ce309f6e428de1ec3988e51;Introspection:df3d8ff6e3f18a756e83ac23f5f8b3c8219793e8;JsonWriter:9d032763693d4ef989b630de2eca8750bde88219", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4aad4007f71e30da71199169cb428f54f50b8887e91d18a83ddb97127bcf30d3"}]}