{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/callManagers/RebalanceManagerV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity 0.7.5;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"../interfaces/IExperiPie.sol\\\";\\nimport \\\"../interfaces/IRebalanceManagerV3.sol\\\";\\n\\ncontract RebalanceManagerV3 is IRebalanceManagerV3 {\\n    IExperiPie public immutable basket;\\n    uint256 public immutable lockTime;\\n    mapping(address => bool) public exchanges;\\n\\n    address public rebalanceManager;\\n\\n    event Rebalanced(address indexed basket);\\n    event Swaped(\\n        address indexed basket,\\n        address indexed tokenIn,\\n        address indexed tokenOut,\\n        uint256 quantity,\\n        uint256 returnedQuantity\\n    );\\n    event RebalanceManagerSet(address indexed rebalanceManager);\\n\\n    constructor(\\n        address _basket,\\n        address _uniswapV2Like,\\n        uint256 _lockTime\\n    ) {\\n        require(_basket != address(0), \\\"INVALID_BASKET\\\");\\n        require(_uniswapV2Like != address(0), \\\"INVALID_UNISWAP_V2\\\");\\n\\n        basket = IExperiPie(_basket);\\n        rebalanceManager = msg.sender;\\n        exchanges[_uniswapV2Like] = true;\\n        lockTime = _lockTime;\\n    }\\n\\n    modifier onlyRebalanceManager() {\\n        require(msg.sender == rebalanceManager, \\\"NOT_REBALANCE_MANAGER\\\");\\n        _;\\n    }\\n\\n    function setRebalanceManager(address _rebalanceManager)\\n        external\\n        onlyRebalanceManager\\n    {\\n        rebalanceManager = _rebalanceManager;\\n        emit RebalanceManagerSet(_rebalanceManager);\\n    }\\n\\n    function setExchange(address _exchange, bool _activated)\\n        external\\n        onlyRebalanceManager\\n    {\\n        exchanges[_exchange] = _activated;\\n    }\\n\\n    function _swapUniswapV2(\\n        address exchange,\\n        uint256 quantity,\\n        uint256 minReturn,\\n        address[] calldata path,\\n        address recipient,\\n        uint256 deadline\\n    ) internal {\\n        if (IERC20(path[0]).allowance(address(basket), exchange) < quantity) {\\n            basket.singleCall(\\n                path[0],\\n                abi.encodeWithSelector(\\n                    IERC20(path[0]).approve.selector,\\n                    address(exchange),\\n                    0\\n                ),\\n                0\\n            );\\n            basket.singleCall(\\n                path[0],\\n                abi.encodeWithSelector(\\n                    IERC20(path[0]).approve.selector,\\n                    address(exchange),\\n                    uint256(-1)\\n                ),\\n                0\\n            );\\n        }\\n\\n        // Swap on exchange\\n        basket.singleCall(\\n            exchange,\\n            abi.encodeWithSelector(\\n                IUniswapV2Router02(exchange)\\n                    .swapExactTokensForTokensSupportingFeeOnTransferTokens\\n                    .selector,\\n                quantity,\\n                minReturn,\\n                path,\\n                recipient,\\n                deadline\\n            ),\\n            0\\n        );\\n\\n        emit Swaped(\\n            address(basket),\\n            path[0],\\n            path[path.length - 1],\\n            quantity,\\n            minReturn\\n        );\\n    }\\n\\n    function removeToken(address _token) internal {\\n        uint256 balance = basket.balance(_token);\\n        bool inPool = basket.getTokenInPool(_token);\\n        //if there is a token balance of the token is not in the pool, skip\\n        if (balance != 0 || !inPool) {\\n            return;\\n        }\\n\\n        // remove token\\n        basket.singleCall(\\n            address(basket),\\n            abi.encodeWithSelector(basket.removeToken.selector, _token),\\n            0\\n        );\\n    }\\n\\n    function addToken(address _token) internal {\\n        uint256 balance = basket.balance(_token);\\n        bool inPool = basket.getTokenInPool(_token);\\n        // If token has no balance or is already in the pool, skip\\n        if (balance == 0 || inPool) {\\n            return;\\n        }\\n\\n        // add token\\n        basket.singleCall(\\n            address(basket),\\n            abi.encodeWithSelector(basket.addToken.selector, _token),\\n            0\\n        );\\n    }\\n\\n    function lockBasketData(uint256 _block) internal {\\n        basket.singleCall(\\n            address(basket),\\n            abi.encodeWithSelector(basket.setLock.selector, _block),\\n            0\\n        );\\n    }\\n\\n    /**\\n        @notice Lock before Rebalance\\n    */\\n    function lock() external onlyRebalanceManager {\\n        lockBasketData(block.number + lockTime);\\n    }\\n\\n    /**\\n        @notice Rebalance underling token\\n        @param _swapsV2 Swaps to perform\\n        @param _deadline Unix timestamp after which the transaction will revert.\\n    */\\n    function rebalance(UnderlyingTrade[] calldata _swapsV2, uint256 _deadline)\\n        external\\n        override\\n        onlyRebalanceManager\\n    {\\n        require(basket.getLock(), \\\"REQUIRE_LOCK\\\");\\n        lockBasketData(block.number + 30);\\n\\n        uint256 swapLength = _swapsV2.length;\\n        for (uint256 i; i < swapLength; ++i) {\\n            UnderlyingTrade calldata trade = _swapsV2[i];\\n            uint256 input = trade.quantity;\\n            address targetToken = trade.swaps[0].path[0];\\n            //internal trades\\n            for (uint256 j; j < trade.swaps.length; ++j) {\\n                UniswapV2SwapStruct calldata swap = trade.swaps[j];\\n                require(exchanges[swap.exchange], \\\"INVALID_EXCHANGE\\\");\\n                require(targetToken == swap.path[0], \\\"INVALID_INPUT_TOKEN\\\");\\n                targetToken = swap.path[swap.path.length - 1];\\n\\n                uint256 oldBalance = IERC20(targetToken).balanceOf(\\n                    address(basket)\\n                );\\n                //swap token\\n                _swapUniswapV2(\\n                    swap.exchange,\\n                    input,\\n                    0,\\n                    swap.path,\\n                    address(basket),\\n                    _deadline\\n                );\\n                //The output of this trade is the input for the next trade\\n                input =\\n                    IERC20(targetToken).balanceOf(address(basket)) -\\n                    oldBalance;\\n            }\\n            require(trade.minimumReturn <= input, \\\"INSUFFICIENT_OUTPUT_AMOUNT\\\");\\n            //add to token if missing\\n            UniswapV2SwapStruct calldata toAdd = trade.swaps[\\n                trade.swaps.length - 1\\n            ];\\n            addToken(toAdd.path[toAdd.path.length - 1]);\\n\\n            //remove from token if resulting quantity is 0\\n            removeToken(trade.swaps[0].path[0]);\\n        }\\n\\n        emit Rebalanced(address(basket));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity 0.7.5;\\n\\nimport \\\"./IUniswapV2Router01.sol\\\";\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IExperiPie.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@pie-dao/diamond/contracts/interfaces/IERC173.sol\\\";\\nimport \\\"@pie-dao/diamond/contracts/interfaces/IDiamondLoupe.sol\\\";\\nimport \\\"@pie-dao/diamond/contracts/interfaces/IDiamondCut.sol\\\";\\nimport \\\"./IBasketFacet.sol\\\";\\nimport \\\"./IERC20Facet.sol\\\";\\nimport \\\"./ICallFacet.sol\\\";\\n\\n/**\\n    @title ExperiPie Interface\\n    @dev Combines all ExperiPie facet interfaces into one\\n*/\\ninterface IExperiPie is\\n    IERC20,\\n    IBasketFacet,\\n    IERC20Facet,\\n    IERC173,\\n    ICallFacet,\\n    IDiamondLoupe,\\n    IDiamondCut\\n{\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRebalanceManagerV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity 0.7.5;\\n\\ninterface IRebalanceManagerV3 {\\n    struct UnderlyingTrade {\\n        UniswapV2SwapStruct[] swaps;\\n        uint256 quantity;\\n        uint256 minimumReturn;\\n    }\\n\\n    struct UniswapV2SwapStruct {\\n        address exchange;\\n        address[] path;\\n    }\\n\\n    /**\\n        @notice Rebalance underling token\\n        @param _swapsV2 Swaps to perform\\n        @param _deadline Unix timestamp after which the transaction will revert.\\n    */\\n    function rebalance(UnderlyingTrade[] calldata _swapsV2, uint256 _deadline)\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity 0.7.5;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@pie-dao/diamond/contracts/interfaces/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.1;\\r\\n\\r\\n/// @title ERC-173 Contract Ownership Standard\\r\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\r\\n/* is ERC165 */\\r\\ninterface IERC173 {\\r\\n    /// @dev This emits when ownership of a contract changes.\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /// @notice Get the address of the owner\\r\\n    /// @return owner_ The address of the owner.\\r\\n    function owner() external view returns (address owner_);\\r\\n\\r\\n    /// @notice Set the address of the new owner of the contract\\r\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\r\\n    /// @param _newOwner The address of the new owner of the contract\\r\\n    function transferOwnership(address _newOwner) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@pie-dao/diamond/contracts/interfaces/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.1;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n// A loupe is a small magnifying glass used to look at diamonds.\\r\\n// These functions look at diamonds\\r\\ninterface IDiamondLoupe {\\r\\n    /// These functions are expected to be called frequently\\r\\n    /// by tools.\\r\\n\\r\\n    struct Facet {\\r\\n        address facetAddress;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\r\\n    /// @return facets_ Facet\\r\\n    function facets() external view returns (Facet[] memory facets_);\\r\\n\\r\\n    /// @notice Gets all the function selectors supported by a specific facet.\\r\\n    /// @param _facet The facet address.\\r\\n    /// @return facetFunctionSelectors_\\r\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\r\\n\\r\\n    /// @notice Get all the facet addresses used by a diamond.\\r\\n    /// @return facetAddresses_\\r\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\r\\n\\r\\n    /// @notice Gets the facet that supports the given selector.\\r\\n    /// @dev If facet is not found return address(0).\\r\\n    /// @param _functionSelector The function selector.\\r\\n    /// @return facetAddress_ The facet address.\\r\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@pie-dao/diamond/contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.7.1;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n/******************************************************************************/\\r\\n\\r\\ninterface IDiamondCut {\\r\\n    enum FacetCutAction {Add, Replace, Remove}\\r\\n\\r\\n    struct FacetCut {\\r\\n        address facetAddress;\\r\\n        FacetCutAction action;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\r\\n    ///         a function with delegatecall\\r\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\r\\n    /// @param _init The address of the contract or facet to execute _calldata\\r\\n    /// @param _calldata A function call, including function selector and arguments\\r\\n    ///                  _calldata is executed with delegatecall on _init\\r\\n    function diamondCut(\\r\\n        FacetCut[] calldata _diamondCut,\\r\\n        address _init,\\r\\n        bytes calldata _calldata\\r\\n    ) external;\\r\\n\\r\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IBasketFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity 0.7.5;\\n\\ninterface IBasketFacet {\\n    event TokenAdded(address indexed _token);\\n    event TokenRemoved(address indexed _token);\\n    event EntryFeeSet(uint256 fee);\\n    event ExitFeeSet(uint256 fee);\\n    event AnnualizedFeeSet(uint256 fee);\\n    event FeeBeneficiarySet(address indexed beneficiary);\\n    event EntryFeeBeneficiaryShareSet(uint256 share);\\n    event ExitFeeBeneficiaryShareSet(uint256 share);\\n\\n    event PoolJoined(address indexed who, uint256 amount, uint16 _referral);\\n    event PoolExited(address indexed who, uint256 amount, uint16 _referral);\\n    event FeeCharged(uint256 amount);\\n    event LockSet(uint256 lockBlock);\\n    event CapSet(uint256 cap);\\n\\n    /**\\n        @notice Sets entry fee paid when minting\\n        @param _fee Amount of fee. 1e18 == 100%, capped at 10%\\n    */\\n    function setEntryFee(uint256 _fee) external;\\n\\n    /**\\n        @notice Get the entry fee\\n        @return Current entry fee\\n    */\\n    function getEntryFee() external view returns (uint256);\\n\\n    /**\\n        @notice Set the exit fee paid when exiting\\n        @param _fee Amount of fee. 1e18 == 100%, capped at 10%\\n    */\\n    function setExitFee(uint256 _fee) external;\\n\\n    /**\\n        @notice Get the exit fee\\n        @return Current exit fee\\n    */\\n    function getExitFee() external view returns (uint256);\\n\\n    /**\\n        @notice Set the annualized fee. Often referred to as streaming fee\\n        @param _fee Amount of fee. 1e18 == 100%, capped at 10%\\n    */\\n    function setAnnualizedFee(uint256 _fee) external;\\n\\n    /**\\n        @notice Get the annualized fee.\\n        @return Current annualized fee.\\n    */\\n    function getAnnualizedFee() external view returns (uint256);\\n\\n    /**\\n        @notice Set the address receiving the fees.\\n    */\\n    function setFeeBeneficiary(address _beneficiary) external;\\n\\n    /**\\n        @notice Get the fee benificiary\\n        @return The current fee beneficiary\\n    */\\n    function getFeeBeneficiary() external view returns (address);\\n\\n    /**\\n        @notice Set the fee beneficiaries share of the entry fee\\n        @notice _share Share of the fee. 1e18 == 100%. Capped at 100%\\n    */\\n    function setEntryFeeBeneficiaryShare(uint256 _share) external;\\n\\n    /**\\n        @notice Get the entry fee beneficiary share\\n        @return Feeshare amount\\n    */\\n    function getEntryFeeBeneficiaryShare() external view returns (uint256);\\n\\n    /**\\n        @notice Set the fee beneficiaries share of the exit fee\\n        @notice _share Share of the fee. 1e18 == 100%. Capped at 100%\\n    */\\n    function setExitFeeBeneficiaryShare(uint256 _share) external;\\n\\n    /**\\n        @notice Get the exit fee beneficiary share\\n        @return Feeshare amount\\n    */\\n    function getExitFeeBeneficiaryShare() external view returns (uint256);\\n\\n    /**\\n        @notice Calculate the oustanding annualized fee\\n        @return Amount of pool tokens to be minted to charge the annualized fee\\n    */\\n    function calcOutStandingAnnualizedFee() external view returns (uint256);\\n\\n    /**\\n        @notice Charges the annualized fee\\n    */\\n    function chargeOutstandingAnnualizedFee() external;\\n\\n    /**\\n        @notice Pulls underlying from caller and mints the pool token\\n        @param _amount Amount of pool tokens to mint\\n        @param _referral Partners may receive rewards with their referral code\\n    */\\n    function joinPool(uint256 _amount, uint16 _referral) external;\\n\\n    /**\\n        @notice Burns pool tokens from the caller and returns underlying assets\\n    */\\n    function exitPool(uint256 _amount, uint16 _referral) external;\\n\\n    /**\\n        @notice Get if the pool is locked or not. (not accepting exit and entry)\\n        @return Boolean indicating if the pool is locked\\n    */\\n    function getLock() external view returns (bool);\\n\\n    /**\\n        @notice Get the block until which the pool is locked\\n        @return The lock block\\n    */\\n    function getLockBlock() external view returns (uint256);\\n\\n    /**\\n        @notice Set the lock block\\n        @param _lock Block height of the lock\\n    */\\n    function setLock(uint256 _lock) external;\\n\\n    /**\\n        @notice Get the maximum of pool tokens that can be minted\\n        @return Cap\\n    */\\n    function getCap() external view returns (uint256);\\n\\n    /**\\n        @notice Set the maximum of pool tokens that can be minted\\n        @param _maxCap Max cap\\n    */\\n    function setCap(uint256 _maxCap) external;\\n\\n    /**\\n        @notice Get the amount of tokens owned by the pool\\n        @param _token Addres of the token\\n        @return Amount owned by the contract\\n    */\\n    function balance(address _token) external view returns (uint256);\\n\\n    /**\\n        @notice Get the tokens in the pool\\n        @return Array of tokens in the pool\\n    */\\n    function getTokens() external view returns (address[] memory);\\n\\n    /**\\n        @notice Add a token to the pool. Should have at least a balance of 10**6\\n        @param _token Address of the token to add\\n    */\\n    function addToken(address _token) external;\\n\\n    /**\\n        @notice Removes a token from the pool\\n        @param _token Address of the token to remove\\n    */\\n    function removeToken(address _token) external;\\n\\n    /**\\n        @notice Checks if a token was added to the pool\\n        @param _token address of the token\\n        @return If token is in the pool or not\\n    */\\n    function getTokenInPool(address _token) external view returns (bool);\\n\\n    /**\\n        @notice Calculate the amounts of underlying needed to mint that pool amount.\\n        @param _amount Amount of pool tokens to mint\\n        @return tokens Tokens needed\\n        @return amounts Amounts of underlying needed\\n    */\\n    function calcTokensForAmount(uint256 _amount)\\n        external\\n        view\\n        returns (address[] memory tokens, uint256[] memory amounts);\\n\\n    /**\\n        @notice Calculate the amounts of underlying to receive when burning that pool amount\\n        @param _amount Amount of pool tokens to burn\\n        @return tokens Tokens returned\\n        @return amounts Amounts of underlying returned\\n    */\\n    function calcTokensForAmountExit(uint256 _amount)\\n        external\\n        view\\n        returns (address[] memory tokens, uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Facet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\ninterface IERC20Facet {\\n    /**\\n        @notice Get the token name\\n        @return The token name\\n    */\\n    function name() external view returns (string memory);\\n\\n    /**\\n        @notice Get the token symbol\\n        @return The token symbol \\n    */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n        @notice Get the amount of decimals\\n        @return Amount of decimals\\n    */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n        @notice Mints tokens. Can only be called by the contract owner or the contract itself\\n        @param _receiver Address receiving the tokens\\n        @param _amount Amount to mint\\n    */\\n    function mint(address _receiver, uint256 _amount) external;\\n\\n    /**\\n        @notice Burns tokens. Can only be called by the contract owner or the contract itself\\n        @param _from Address to burn from\\n        @param _amount Amount to burn\\n    */\\n    function burn(address _from, uint256 _amount) external;\\n\\n    /**\\n        @notice Sets up the metadata and initial supply. Can be called by the contract owner\\n        @param _initialSupply Initial supply of the token\\n        @param _name Name of the token\\n        @param _symbol Symbol of the token\\n    */\\n    function initialize(\\n        uint256 _initialSupply,\\n        string memory _name,\\n        string memory _symbol\\n    ) external;\\n\\n    /**\\n        @notice Set the token name of the contract. Can only be called by the contract owner or the contract itself\\n        @param _name New token name\\n    */\\n    function setName(string calldata _name) external;\\n\\n    /**\\n        @notice Set the token symbol of the contract. Can only be called by the contract owner or the contract itself\\n        @param _symbol New token symbol\\n    */\\n    function setSymbol(string calldata _symbol) external;\\n\\n    /**\\n        @notice Increase the amount of tokens another address can spend\\n        @param _spender Spender\\n        @param _amount Amount to increase by\\n    */\\n    function increaseApproval(address _spender, uint256 _amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n        @notice Decrease the amount of tokens another address can spend\\n        @param _spender Spender\\n        @param _amount Amount to decrease by\\n    */\\n    function decreaseApproval(address _spender, uint256 _amount)\\n        external\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICallFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\npragma experimental ABIEncoderV2;\\n\\ninterface ICallFacet {\\n    event CallerAdded(address indexed caller);\\n    event CallerRemoved(address indexed caller);\\n    event Call(\\n        address indexed caller,\\n        address indexed target,\\n        bytes data,\\n        uint256 value\\n    );\\n\\n    /**\\n        @notice Lets whitelisted callers execute a batch of arbitrary calls from the pool. Reverts if one of the calls fails\\n        @param _targets Array of addresses of targets to call\\n        @param _calldata Array of calldata for each call\\n        @param _values Array of amounts of ETH to send with the call\\n    */\\n    function call(\\n        address[] memory _targets,\\n        bytes[] memory _calldata,\\n        uint256[] memory _values\\n    ) external;\\n\\n    /**\\n        @notice Lets whitelisted callers execute a batch of arbitrary calls from the pool without sending any Ether. Reverts if one of the calls fail\\n        @param _targets Array of addresses of targets to call\\n        @param _calldata Array of calldata for each call\\n    */\\n    function callNoValue(address[] memory _targets, bytes[] memory _calldata)\\n        external;\\n\\n    /**\\n        @notice Lets whitelisted callers execute a single arbitrary call from the pool. Reverts if the call fails\\n        @param _target Address of the target to call\\n        @param _calldata Calldata of the call\\n        @param _value Amount of ETH to send with the call\\n    */\\n    function singleCall(\\n        address _target,\\n        bytes calldata _calldata,\\n        uint256 _value\\n    ) external;\\n\\n    /**\\n        @notice Add a whitelisted caller. Can only be called by the contract owner\\n        @param _caller Caller to add\\n    */\\n    function addCaller(address _caller) external;\\n\\n    /**\\n        @notice Remove a whitelisted caller. Can only be called by the contract owner\\n    */\\n    function removeCaller(address _caller) external;\\n\\n    /**\\n        @notice Checks if an address is a whitelisted caller\\n        @param _caller Address to check\\n        @return If the address is whitelisted\\n    */\\n    function canCall(address _caller) external view returns (bool);\\n\\n    /**\\n        @notice Get all whitelisted callers\\n        @return Array of whitelisted callers\\n    */\\n    function getCallers() external view returns (address[] memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_basket\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapV2Like\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rebalanceManager\",\"type\":\"address\"}],\"name\":\"RebalanceManagerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"basket\",\"type\":\"address\"}],\"name\":\"Rebalanced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"basket\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnedQuantity\",\"type\":\"uint256\"}],\"name\":\"Swaped\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"basket\",\"outputs\":[{\"internalType\":\"contract IExperiPie\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exchanges\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"internalType\":\"struct IRebalanceManagerV3.UniswapV2SwapStruct[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumReturn\",\"type\":\"uint256\"}],\"internalType\":\"struct IRebalanceManagerV3.UnderlyingTrade[]\",\"name\":\"_swapsV2\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"rebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebalanceManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_exchange\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_activated\",\"type\":\"bool\"}],\"name\":\"setExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rebalanceManager\",\"type\":\"address\"}],\"name\":\"setRebalanceManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RebalanceManagerV3", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a9536b9c75a9e0fae3b56a96ac8edf76abc919780000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000000000000000000000000000000000000000003c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}