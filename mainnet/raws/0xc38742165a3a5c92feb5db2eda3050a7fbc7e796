{"status": "1", "message": "OK", "result": [{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2022-06-16\r\n*/\r\n\r\n//SPDX-License-Identifier:NOLICENSE\r\npragma solidity 0.8.14;\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20Metadata {\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface IERC20 is IERC20Metadata {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract Escrow is Ownable {\r\n    using SafeERC20 for IERC20;\r\n    \r\n    struct EscrowInfo {\r\n        uint totalBlings;\r\n        uint issuance;\r\n        uint8 cliff;\r\n    }\r\n\r\n    struct WalletInfo {\r\n        uint allocated;\r\n        uint issued;\r\n        uint lastClaimBlock;\r\n        uint index;\r\n        bool isActive;\r\n    }\r\n\r\n    address[] founders;\r\n    address[] wallets;\r\n    address public launchPad;\r\n    address public bling;\r\n    uint public startBlock;\r\n    uint public blockInMnth;\r\n    bool initializer;\r\n\r\n    EscrowInfo public launchpadInfo;\r\n    EscrowInfo public foundersInfo;\r\n    EscrowInfo public walletsInfo;\r\n\r\n    mapping(address => WalletInfo) public founderInfo;\r\n    mapping(address => WalletInfo) public walletInfo;\r\n\r\n    event Claim(\r\n        address indexed account,\r\n        uint issued,\r\n        string indexed claimType\r\n    );\r\n\r\n    /**\r\n    * @dev initialize the setting.\r\n    */\r\n    function initialize(\r\n        address blingToken, //bling token address\r\n        uint launchpadAllocation, //launch pad lockup token amount\r\n        uint blockNo, //start block number - cliff starts from this block number\r\n        uint8 launchPadCliff, //launch pad cliff\r\n        uint8 founderCliff, //founder cliff\r\n        uint8 walletsCliff, // wallet cliff\r\n        uint issuanceOf //founder montly release - 2500 equals to 25%\r\n    ) external onlyOwner {\r\n        require(!initializer, \"Escrow:: initialize: already initialized\");\r\n        require(blingToken != address(0), \"Escrow:: initialize: bling != 0\");\r\n        require(launchpadAllocation != 0, \"Escrow:: initialize: launchpad allocation != 0\");\r\n        require(blockNo > block.number, \"Escrow:: initialize: should higher than current block\");\r\n        require(launchPadCliff != 0, \"Escrow:: initialize: launchpad cliff != 0\");\r\n        require(founderCliff != 0, \"Escrow:: initialize: escrow cliff != 0\");\r\n        require(walletsCliff != 0, \"Escrow:: initialize: wallet cliff != 0\");\r\n        require(issuanceOf != 0, \"Escrow:: initialize: issuanceOf != 0\");\r\n\r\n        initializer = true;\r\n        bling = blingToken;\r\n        startBlock = blockNo;\r\n        blockInMnth = 30 days / 15;\r\n\r\n        launchpadInfo = EscrowInfo({\r\n            totalBlings : launchpadAllocation*(10**IERC20Metadata(bling).decimals()),\r\n            issuance : 0,\r\n            cliff : launchPadCliff\r\n        });\r\n\r\n        foundersInfo.cliff = founderCliff;\r\n        foundersInfo.issuance = issuanceOf;\r\n\r\n        walletsInfo.cliff = walletsCliff;\r\n    }\r\n    /**\r\n    * @dev setting bling address.\r\n    */\r\n    function setbling(address blingToken) external onlyOwner {\r\n        require(blingToken != address(0),\"Escrow:: setbling: bling != 0\");\r\n        bling = blingToken;\r\n    }\r\n\r\n    /**\r\n    * @dev setting start block.\r\n    */\r\n    function setStartBlock(uint blockNumber) external onlyOwner {\r\n        require(startBlock < block.number,\"Escrow:: setStartBlock: start block should lesser than block\");\r\n        require(blockNumber > 0,\"Escrow:: setStartBlock: block number should higher than block\");        \r\n        startBlock = blockNumber;\r\n    }\r\n\r\n    /**\r\n    * @dev setting escrow cliff.\r\n    */\r\n    function setFounderCliff(uint8 cliff) external onlyOwner {\r\n        require((startBlock > 0) && (startBlock > block.number),\"Escrow:: setFounderCliff: block has started\");\r\n        require(cliff > 0,\"Escrow:: setFounderCliff: cliff should higher than zero\");\r\n        foundersInfo.cliff = cliff;\r\n    }\r\n\r\n    /**\r\n    * @dev setting launch pad cliff.\r\n    */\r\n    function setLaunchPadCliff(uint8 cliff) external onlyOwner {\r\n        require((startBlock > 0) && (startBlock > block.number),\"Escrow:: setLaunchPadCliff: block has started\");\r\n        require(cliff > 0,\"Escrow:: setLaunchPadCliff: cliff should higher than zero\");\r\n        launchpadInfo.cliff = cliff;\r\n    }\r\n\r\n    /**\r\n    * @dev setting wallets cliff.\r\n    */\r\n    function setWalletsCliff(uint8 cliff) external onlyOwner {\r\n        require((startBlock > 0) && (startBlock > block.number),\"Escrow:: setWalletsCliff: block has started\");\r\n        require(cliff > 0,\"Escrow:: setWalletsCliff: cliff should higher than zero\");\r\n        walletsInfo.cliff = cliff;\r\n    }\r\n\r\n    /**\r\n    * @dev setting launch pad address.\r\n    */\r\n    function setLaunchPad(address launchpad) external onlyOwner {\r\n        require((startBlock > 0) && (startBlock > block.number),\"Escrow:: setLaunchPad: block has started\");\r\n        launchPad = launchpad;\r\n    }\r\n\r\n    /**\r\n    * @dev adding founder to the founders list and setting allocation to the founder.\r\n    */\r\n    function addFounder(address[] calldata accounts, uint[] calldata allocations) external onlyOwner {\r\n        require((startBlock > 0) && (startBlock > block.number),\"Escrow:: addFounder: block hasn't started\");\r\n        require(accounts.length > 0, \"Escrow:: addFounder: accounts length should be higher than zero\");\r\n        require(accounts.length == allocations.length, \"Escrow:: addFounder: accounts and allocations length should be same\");\r\n\r\n        for(uint i=0;i<accounts.length;i++) {\r\n            require(accounts[i] != address(0),\"Escrow:: addFounder: account != 0\");\r\n\r\n            if(!founderInfo[accounts[i]].isActive) {\r\n                founderInfo[accounts[i]].isActive = true;\r\n                founderInfo[accounts[i]].index = founders.length;\r\n                founders.push(accounts[i]);\r\n            }\r\n\r\n            founderInfo[accounts[i]].allocated += allocations[i];\r\n            foundersInfo.totalBlings += allocations[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev remove founder from the list.\r\n    */\r\n    function removeFounder(address[] calldata accounts) external onlyOwner {\r\n        require(accounts.length > 0, \"Escrow:: removeFounder: account length > 0\");\r\n\r\n        for(uint i=0;i<accounts.length;i++) {\r\n            if(founderInfo[accounts[i]].isActive) {\r\n                founderInfo[accounts[i]].isActive = false;\r\n                foundersInfo.totalBlings -= founderInfo[accounts[i]].allocated;\r\n                founderInfo[accounts[i]].allocated = 0;\r\n                //remove founder\r\n                address last = founders[founders.length-1];\r\n                founders[founderInfo[accounts[i]].index] = last;\r\n                founders.pop();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev adding wallet to the wallet list and setting allocation to the accounts.\r\n    */\r\n    function addWallets(address[] calldata accounts, uint[] calldata allocations) external onlyOwner {\r\n        require((startBlock > 0) && (startBlock > block.number),\"Escrow:: addWallets: block hasn't started\");\r\n        require(accounts.length > 0, \"Escrow:: addWallets: accounts length should be higher than zero\");\r\n        require(accounts.length == allocations.length, \"Escrow:: addWallets: accounts and allocations length should be same\");\r\n\r\n        for(uint i=0;i<accounts.length;i++) {\r\n            require(accounts[i] != address(0),\"Escrow:: addWallets: account != 0\");\r\n\r\n            if(!walletInfo[accounts[i]].isActive) {\r\n                walletInfo[accounts[i]].isActive = true;\r\n                walletInfo[accounts[i]].index = wallets.length;\r\n                wallets.push(accounts[i]);\r\n            }\r\n\r\n            walletInfo[accounts[i]].allocated += allocations[i];\r\n            walletsInfo.totalBlings += allocations[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev remove wallet from the list.\r\n    */\r\n    function removeWallet(address[] calldata accounts) external onlyOwner {\r\n        require(accounts.length > 0, \"Escrow:: removeFounder: account length > 0\");\r\n\r\n        for(uint i=0;i<accounts.length;i++) {\r\n            if(walletInfo[accounts[i]].isActive) {\r\n                walletInfo[accounts[i]].isActive = false;\r\n                walletsInfo.totalBlings -= walletInfo[accounts[i]].allocated;\r\n                walletInfo[accounts[i]].allocated = 0;\r\n                //remove wallet\r\n                address last = wallets[wallets.length-1];\r\n                wallets[walletInfo[accounts[i]].index] = last;\r\n                wallets.pop();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev to claim founder and launch pad tokens.\r\n    */\r\n    function claim() external {\r\n        require(startBlock < block.number,\"Escrow:: claim: block hasn't started\");\r\n        address account = _msgSender();\r\n        if(account == launchPad) {\r\n            _launchPad(launchPad);\r\n        } else if(founderInfo[account].isActive) {\r\n            _founder(account);\r\n        } else if(walletInfo[account].isActive) {\r\n            _wallets(account);\r\n        } else {\r\n            revert(\"invalid account\");\r\n        }\r\n    }\r\n\r\n    function failsafe( address _token, address _to, uint amount) public onlyOwner {\r\n        address _contractAdd = address(this);\r\n        if(_token == address(0)){\r\n            require(_contractAdd.balance >= amount,\"insufficient bnb\");\r\n            payable(_to).transfer(amount);\r\n        }\r\n        else{\r\n            require( IERC20(_token).balanceOf(_contractAdd) >= amount,\"insufficient Token balance\");\r\n            IERC20(_token).transfer(_to, amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev show all the founder addresses.\r\n    */\r\n    function showFounders() public view returns (address[] memory) {\r\n        return founders;\r\n    }\r\n\r\n    /**\r\n    * @dev show all the wallet addresses.\r\n    */\r\n    function showWallets() public view returns (address[] memory) {\r\n        return wallets;\r\n    }\r\n\r\n    /**\r\n    * @dev show pending token for the given founder address.\r\n    */\r\n    function pendingClaim(address account) public view returns (uint claimable, uint lastClaim) {\r\n        WalletInfo memory founder = founderInfo[account];\r\n\r\n        if(founder.lastClaimBlock == 0) {            \r\n            founder.lastClaimBlock = _cliff(foundersInfo.cliff);\r\n        }\r\n\r\n        if((!founder.isActive) ||\r\n         (founder.issued >= founder.allocated) ||\r\n         (founder.lastClaimBlock + blockInMnth > block.number) ) {\r\n            return (0,0);\r\n        }\r\n\r\n        uint currBlock = block.number;\r\n        uint pendingBlocks = (currBlock - founder.lastClaimBlock) / blockInMnth;\r\n        uint blockClaimable = ((founder.allocated * foundersInfo.issuance) / 10000) * pendingBlocks;        \r\n        \r\n        if(founder.issued + blockClaimable > founder.allocated) {\r\n            blockClaimable = founder.allocated - founder.issued;\r\n        }\r\n        \r\n        founder.lastClaimBlock += blockInMnth * pendingBlocks;\r\n        return (blockClaimable,founder.lastClaimBlock);\r\n    }\r\n\r\n    /**\r\n    * @dev execute founder claim.\r\n    */\r\n    function _founder(address account) private {\r\n        WalletInfo storage info = founderInfo[account];\r\n        require(info.isActive,\"Escrow:: _founder: account is not a founder\");\r\n        require(_cliff(foundersInfo.cliff) < block.number,\"Escrow:: _founder: cliff isn't over\");\r\n        require(info.issued < info.allocated,\"Escrow:: _founder: has claimed all issuance\" );\r\n       \r\n        (uint claimable, uint time)  = pendingClaim(account);\r\n\r\n        if(claimable > 0){\r\n            info.lastClaimBlock = time;\r\n            info.issued += claimable;\r\n            _sendBling(account, claimable,\"founders\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev execute launch pad claim.\r\n    */\r\n    function _launchPad(address account) private {\r\n        require(_cliff(launchpadInfo.cliff) <= block.number,\"Escrow:: _launchPad: cliff isn't over\");\r\n        require(launchpadInfo.totalBlings > 0,\"Escrow:: _launchPad: has claimed all issuance\");\r\n        \r\n        uint amount = launchpadInfo.totalBlings;\r\n        launchpadInfo.totalBlings = 0;\r\n        _sendBling(account, amount,\"launchpad\");\r\n    }\r\n\r\n    /**\r\n    * @dev execute wallets claim.\r\n    */\r\n    function _wallets(address account) private {\r\n        WalletInfo storage info = walletInfo[account];\r\n        require(info.isActive,\"Escrow:: _wallets: account is not in wallet list\");\r\n        require(_cliff(walletsInfo.cliff) < block.number,\"Escrow:: claim: cliff isn't over\");\r\n        require(info.allocated > 0,\"Escrow:: _wallets: has claimed all issuance\");\r\n        \r\n        uint amount = info.allocated;\r\n        info.allocated = 0;\r\n        _sendBling(account, amount,\"wallets\");\r\n    }\r\n\r\n    /**\r\n    * @dev send tokens to founder and launch pad.\r\n    */\r\n    function _sendBling(address account, uint amount, string memory claimType) private {\r\n        require(IERC20(bling).balanceOf(address(this)) >= amount,\"Escrow:: _sendbling: insufficient balance\");\r\n        IERC20(bling).safeTransfer(account,amount);\r\n\r\n         emit Claim(\r\n            account,\r\n            amount,\r\n            claimType\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev returns cliff blocks.\r\n    */\r\n    function _cliff(uint cliff) private view returns (uint) {\r\n        return startBlock + (blockInMnth * cliff);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"issued\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"claimType\",\"type\":\"string\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"allocations\",\"type\":\"uint256[]\"}],\"name\":\"addFounder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"allocations\",\"type\":\"uint256[]\"}],\"name\":\"addWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bling\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockInMnth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"failsafe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"founderInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"allocated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issued\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foundersInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalBlings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issuance\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"cliff\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"blingToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"launchpadAllocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNo\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"launchPadCliff\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"founderCliff\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"walletsCliff\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"issuanceOf\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchPad\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchpadInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalBlings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issuance\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"cliff\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaim\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removeFounder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"cliff\",\"type\":\"uint8\"}],\"name\":\"setFounderCliff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"launchpad\",\"type\":\"address\"}],\"name\":\"setLaunchPad\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"cliff\",\"type\":\"uint8\"}],\"name\":\"setLaunchPadCliff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"setStartBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"cliff\",\"type\":\"uint8\"}],\"name\":\"setWalletsCliff\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"blingToken\",\"type\":\"address\"}],\"name\":\"setbling\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showFounders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showWallets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"walletInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"allocated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issued\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaimBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletsInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalBlings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"issuance\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"cliff\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Escrow", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a24334779346a58accf1b121ab734380b6b84ea793d4d3f62d8e0e3b32f8bb43"}]}