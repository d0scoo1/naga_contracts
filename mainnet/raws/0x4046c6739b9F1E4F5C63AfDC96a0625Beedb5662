{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libs/NFTDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\n/// @title A library used to construct ERC721 token URIs and SVG images\\r\\n\\r\\n/*********************************\\r\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\r\\n *********************************/\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\nimport { Base64 } from 'base64-sol/base64.sol';\\r\\nimport { MultiPartRLEToSVG } from './MultiPartRLEToSVG.sol';\\r\\n\\r\\nlibrary NFTDescriptor {\\r\\n    struct TokenURIParams {\\r\\n        string artist;\\r\\n        string title;\\r\\n        string name;\\r\\n        string description;\\r\\n        bytes art;\\r\\n        uint8 paletteIndex;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Construct an ERC721 token URI.\\r\\n     */\\r\\n    function constructTokenURI(TokenURIParams memory params, mapping(uint8 => string[]) storage palettes)\\r\\n        public\\r\\n        view\\r\\n        returns (string memory)\\r\\n    {\\r\\n        string memory image = generateSVGImage(\\r\\n            MultiPartRLEToSVG.SVGParams({ art: params.art, paletteIndex: params.paletteIndex }),\\r\\n            palettes\\r\\n        );\\r\\n\\r\\n        // prettier-ignore\\r\\n        return string(\\r\\n            abi.encodePacked(\\r\\n                'data:application/json;base64,',\\r\\n                Base64.encode(\\r\\n                    bytes(\\r\\n                        abi.encodePacked(\\r\\n                            '{\\\"name\\\":\\\"', \\r\\n                            params.title, \\r\\n                            '\\\", \\\"description\\\":\\\"', \\r\\n                            params.description, \\r\\n                            '\\\", \\\"attributes\\\":[',\\r\\n                                '{\\\"trait_type\\\": \\\"Artist\\\", \\\"value\\\": \\\"', params.artist, '\\\"}',\\r\\n                            '], \\\"image\\\": \\\"', \\r\\n                            'data:image/svg+xml;base64,', \\r\\n                            image, \\r\\n                            '\\\"}'\\r\\n                        )\\r\\n                    )\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Generate an SVG image for use in the ERC721 token URI.\\r\\n     */\\r\\n    function generateSVGImage(MultiPartRLEToSVG.SVGParams memory params, mapping(uint8 => string[]) storage palettes)\\r\\n        public\\r\\n        view\\r\\n        returns (string memory svg)\\r\\n    {\\r\\n        return Base64.encode(bytes(MultiPartRLEToSVG.generateSVG(params, palettes)));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n                    decodedLen := sub(decodedLen, 1)\\n                }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               // read 4 characters\\n               dataPtr := add(dataPtr, 4)\\n               let input := mload(dataPtr)\\n\\n               // write 3 bytes\\n               let output := add(\\n                   add(\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\n                   add(\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\n                    )\\n                )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/MultiPartRLEToSVG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\n/// @title A library used to convert multi-part RLE compressed images to SVG\\r\\n\\r\\n/*********************************\\r\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\r\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\r\\n *********************************/\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\nlibrary MultiPartRLEToSVG {\\r\\n    struct SVGParams {\\r\\n        bytes art;\\r\\n        uint8 paletteIndex;\\r\\n    }\\r\\n\\r\\n    struct ContentBounds {\\r\\n        uint8 top;\\r\\n        uint8 right;\\r\\n        uint8 bottom;\\r\\n        uint8 left;\\r\\n    }\\r\\n\\r\\n    struct Rect {\\r\\n        uint8 length;\\r\\n        uint8 colorIndex;\\r\\n    }\\r\\n\\r\\n    struct DecodedImage {\\r\\n        uint8 paletteIndex;\\r\\n        ContentBounds bounds;\\r\\n        Rect[] rects;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Given RLE image parts and color palettes, merge to generate a single SVG image.\\r\\n     */\\r\\n    function generateSVG(SVGParams memory params, mapping(uint8 => string[]) storage palettes)\\r\\n        internal\\r\\n        view\\r\\n        returns (string memory svg)\\r\\n    {\\r\\n        // prettier-ignore\\r\\n        return string(\\r\\n            abi.encodePacked(\\r\\n                '<svg width=\\\"320\\\" height=\\\"320\\\" viewBox=\\\"0 0 320 320\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" shape-rendering=\\\"crispEdges\\\">',\\r\\n                _generateSVGRects(params, palettes),\\r\\n                '</svg>'\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Given RLE image parts and color palettes, generate SVG rects.\\r\\n     */\\r\\n    // prettier-ignore\\r\\n    function _generateSVGRects(SVGParams memory params, mapping(uint8 => string[]) storage palettes)\\r\\n        private\\r\\n        view\\r\\n        returns (string memory svg)\\r\\n    {\\r\\n        string[33] memory lookup = [\\r\\n            '0', '10', '20', '30', '40', '50', '60', '70', \\r\\n            '80', '90', '100', '110', '120', '130', '140', '150', \\r\\n            '160', '170', '180', '190', '200', '210', '220', '230', \\r\\n            '240', '250', '260', '270', '280', '290', '300', '310',\\r\\n            '320' \\r\\n        ];\\r\\n        string memory rects;\\r\\n        DecodedImage memory image = _decodeRLEImage(params.art);\\r\\n        string[] storage palette = palettes[params.paletteIndex];\\r\\n        uint256 currentX = image.bounds.left;\\r\\n        uint256 currentY = image.bounds.top;\\r\\n        uint256 cursor;\\r\\n        string[16] memory buffer;\\r\\n\\r\\n        string memory part;\\r\\n        for (uint256 i = 0; i < image.rects.length; i++) {\\r\\n            Rect memory rect = image.rects[i];\\r\\n            if (rect.colorIndex != 0) {\\r\\n                buffer[cursor] = lookup[rect.length];          // width\\r\\n                buffer[cursor + 1] = lookup[currentX];         // x\\r\\n                buffer[cursor + 2] = lookup[currentY];         // y\\r\\n                buffer[cursor + 3] = palette[rect.colorIndex]; // color\\r\\n\\r\\n                cursor += 4;\\r\\n\\r\\n                if (cursor >= 16) {\\r\\n                    part = string(abi.encodePacked(part, _getChunk(cursor, buffer)));\\r\\n                    cursor = 0;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            currentX += rect.length;\\r\\n            if (currentX == image.bounds.right) {\\r\\n                currentX = image.bounds.left;\\r\\n                currentY++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (cursor != 0) {\\r\\n            part = string(abi.encodePacked(part, _getChunk(cursor, buffer)));\\r\\n        }\\r\\n        rects = string(abi.encodePacked(rects, part));\\r\\n        return rects;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return a string that consists of all rects in the provided `buffer`.\\r\\n     */\\r\\n    // prettier-ignore\\r\\n    function _getChunk(uint256 cursor, string[16] memory buffer) private pure returns (string memory) {\\r\\n        string memory chunk;\\r\\n        for (uint256 i = 0; i < cursor; i += 4) {\\r\\n            chunk = string(\\r\\n                abi.encodePacked(\\r\\n                    chunk,\\r\\n                    '<rect width=\\\"', buffer[i], '\\\" height=\\\"10\\\" x=\\\"', buffer[i + 1], '\\\" y=\\\"', buffer[i + 2], '\\\" fill=\\\"#', buffer[i + 3], '\\\" />'\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n        return chunk;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Decode a single RLE compressed image into a `DecodedImage`.\\r\\n     */\\r\\n    function _decodeRLEImage(bytes memory image) private pure returns (DecodedImage memory) {\\r\\n        uint8 paletteIndex = uint8(image[0]);\\r\\n        ContentBounds memory bounds = ContentBounds({\\r\\n            top: uint8(image[1]),\\r\\n            right: uint8(image[2]),\\r\\n            bottom: uint8(image[3]),\\r\\n            left: uint8(image[4])\\r\\n        });\\r\\n\\r\\n        uint256 cursor;\\r\\n        Rect[] memory rects = new Rect[]((image.length - 5) / 2);\\r\\n        for (uint256 i = 5; i < image.length; i += 2) {\\r\\n            rects[cursor] = Rect({ length: uint8(image[i]), colorIndex: uint8(image[i + 1]) });\\r\\n            // rects[cursor] = Rect({ length: uint8(image[i]), colorIndex: uint16(uint8(image[i + 1])*256 + uint8(image[i])) });\\r\\n            cursor++;\\r\\n        }\\r\\n        return DecodedImage({ paletteIndex: paletteIndex, bounds: bounds, rects: rects });\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[]", "ContractName": "NFTDescriptor", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}