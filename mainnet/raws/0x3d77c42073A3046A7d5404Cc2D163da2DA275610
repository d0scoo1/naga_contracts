{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"},\"ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature \\u0027s\\u0027 value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature \\u0027v\\u0027 value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs \\u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) \\u003e\\u003e 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 \\u003c s \\u003c secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) \\u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 \\u0026\\u0026 v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"},\"GLVTSaleUpgradeableToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Pausable.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"./IMintableUpgradeable.sol\\\";\\n\\n\\n/**\\n * @dev Developed to facilitate the sales of GLVT NFT tokens.\\n *\\n * The contract components should be pretty straightforward, with the exception\\n * of `authorizedMint`, which is the primary feature supporting any form of pre-public\\n * sale of the NFTs. Essentially, an address will be designated as the `mintAuthority`\\n * and will be used to sign authorisations for minting ahead of the public sales\\n * period.\\n */\\ncontract GLVTSaleUpgradeableToken is Ownable, Pausable, ReentrancyGuard {\\n    IMintableUpgradeable internal _tokenContract;\\n    address public mintAuthority;\\n    uint256 public whitelistSaleTimestamp;\\n    uint256 public publicSaleTimestamp;\\n    uint256 public publicSalePrice;\\n    uint256 public totalMinted = 0;\\n    uint256 public totalSupply;\\n    bool public ended = false;\\n    uint256 public constant maxTokensPerMint = 3;\\n\\n    /// @dev Tracking attributes for authorized minting\\n    mapping (bytes32 =\\u003e uint256) internal _nonces;\\n    bytes32 internal _hashedContractName;\\n    bytes32 internal _hashedContractVersion;\\n    bytes32 internal constant _typeHash = keccak256(\\n        \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n    );\\n\\n    /**\\n     * @dev Typehash for generating authorized mint signatures\\n     *\\n     * The components of the typehash and their definitions is given as follows:\\n     * @custom:param to Address authorized to mint (i.e. the caller of the mint operation).\\n     * @custom:param quantity Total quantity that `to` is allowed to mint using this signature.\\n     * @custom:param timestamp Earliest timestamp minting is permitted.\\n     * @custom:param price Price-per-token in ETH.\\n     * @custom:param nonce Nonce word used to add uniqueness to the signature.\\n     * @custom:param type Mint type, emitted with the {Mint} event for downstream use.\\n     */\\n    bytes32 internal constant authorizedMintTypehash = keccak256(\\n        \\\"AuthorizedMint(address to,uint256 quantity,uint256 timestamp,uint256 price,bytes32 nonce,uint256 type)\\\"\\n    );\\n\\n    /// @dev Event for downstream use\\n    event Mint(address to, uint256 mintType, uint256 tokenId);\\n\\n    /**\\n     * Throws if the caller is not an externally owned address.\\n     */\\n    modifier onlyEOA() {\\n        require(tx.origin == msg.sender, \\\"Caller cannot be another contract\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @param tokenContract GLVT token address.\\n     * @param mintAuthority_ Address of authorized mint authority.\\n     * @param whitelistSaleTimestamp_ Minimum timestamp for commencement of whitelist sales.\\n     * @param publicSaleTimestamp_ Minimum timestamp for commencement of public sale.\\n     * @param publicSalePrice_ Price for public sale minting in ETH.\\n     * @param totalSupply_ Total number of tokens up for sale.\\n     * @param contractName Contract name (used for authorized mint validation).\\n     * @param contractVersion Contract version (used for authorized mint validation).\\n     */\\n    constructor(\\n        address tokenContract,\\n        address mintAuthority_,\\n        uint256 whitelistSaleTimestamp_,\\n        uint256 publicSaleTimestamp_,\\n        uint256 publicSalePrice_,\\n        uint256 totalSupply_,\\n        string memory contractName,\\n        string memory contractVersion\\n    ) {\\n        _tokenContract = IMintableUpgradeable(tokenContract);\\n        mintAuthority = mintAuthority_;\\n        whitelistSaleTimestamp = whitelistSaleTimestamp_;\\n        publicSaleTimestamp = publicSaleTimestamp_;\\n        publicSalePrice = publicSalePrice_;\\n        totalSupply = totalSupply_;\\n\\n        // setting up for authorized minting\\n        _hashedContractName = keccak256(bytes(contractName));\\n        _hashedContractVersion = keccak256(bytes(contractVersion));\\n    }\\n\\n    /**\\n     * Authorized mint (i.e. non-public channel for minting).\\n     *\\n     * @param quantity Number of tokens to mint.\\n     * @param mintableQuantity Total number of tokens mintable with this authorization.\\n     * @param mintTimestamp Minimum timestamp for minting with this authorization.\\n     * @param mintPrice Authorized per-token price in ETH.\\n     * @param nonceWord Unique authorization qualifier.\\n     * @param mintType Mint type (used to emit {Mint} event for downstream use).\\n     * @param signature Authorization signature.\\n     *\\n     * Requirements:\\n     * - Contract must not be paused.\\n     * - Mint `quantity` must not exceed `mintableQuantity`.\\n     * - Block timestamp must be equal or greater than `mintTimestamp`.\\n     * - Total number of tokens minted (including the current attempt) for the specified\\n     *   `nonceWord` must not exceed `mintableQuantity`.\\n     * - Amount of ETH sent must be equal to or more than `quantity` * `mintPrice`.\\n     * - The number of tokens minted so far plus `quantity` must not exceed the total sale supply.\\n     */\\n    function authorizedMint(\\n        uint256 quantity,\\n        uint256 mintableQuantity,\\n        uint256 mintTimestamp,\\n        uint256 mintPrice,\\n        bytes32 nonceWord,\\n        uint256 mintType,\\n        bytes memory signature\\n    ) external payable virtual whenNotPaused nonReentrant returns (uint256) {\\n        require(quantity \\u003c= mintableQuantity, \\\"GLVT: Exceeds authorized quantity.\\\");\\n        require(block.timestamp \\u003e= mintTimestamp, \\\"GLVT: Authorized mint timestamp not reached.\\\");\\n        // writing ```_nonces[nonceWord] + quantity \\u003c= mintableQuantity``` may be more readable,\\n        // but we risk an overflow if the nonce has been invalidated (i.e. set to the max value)\\n        uint256 noncesUsed = _nonces[nonceWord];\\n        require(\\n            mintableQuantity \\u003e noncesUsed \\u0026\\u0026 mintableQuantity - noncesUsed \\u003e= quantity,\\n            \\\"GLVT: Authorized mint quantity exceeded.\\\"\\n        );\\n\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                authorizedMintTypehash,\\n                msg.sender,\\n                mintableQuantity,\\n                mintTimestamp,\\n                mintPrice,\\n                nonceWord,\\n                mintType\\n            )\\n        );\\n        bytes32 domainSeparatorV4 = keccak256(\\n            abi.encode(\\n                _typeHash,\\n                _hashedContractName,\\n                _hashedContractVersion,\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n        bytes32 digest = ECDSA.toTypedDataHash(domainSeparatorV4, structHash);\\n        _validateSignature(signature, digest, mintAuthority);\\n\\n        _nonces[nonceWord] += quantity;\\n        return _mint(msg.sender, quantity, mintPrice, mintType);\\n    }\\n\\n    /**\\n     * Flip the end state of the sale.\\n     *\\n     * If sale is ongoing, it will be set to ended. If sale has ended, it will\\n     * be set to ongoing.\\n     *\\n     * Requirements:\\n     * - Caller must be the contract owner.\\n     */\\n    function flipEndState() external virtual onlyOwner {\\n        ended = !ended;\\n    }\\n\\n    /**\\n     * Invalidates the specified nonce, rendering it unusable for authorized minting.\\n     *\\n     * @param nonceWord Nonce to invalidate.\\n     */\\n    function invalidateAuthorizedMintNonce(bytes32 nonceWord) external virtual onlyOwner {\\n        _nonces[nonceWord] = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n    }\\n\\n    /**\\n     * Public sale.\\n     *\\n     * @param quantity Number of tokens to mint.\\n     *\\n     * Requirements:\\n     * - Contract must not be paused.\\n     * - Public sale must have commenced.\\n     * - Amount of ETH sent must be equal to or more than `quantity` * public sale price.\\n     * - The number of tokens minted so far plus `quantity` must not exceed the total sale supply.\\n     * - Value for `quantity` must not exceed `maxTokensPerMint`.\\n     */\\n    function mint(uint256 quantity) external payable virtual whenNotPaused nonReentrant onlyEOA returns (uint256) {\\n        require(isPublicSale(), \\\"GLVT: Public sale has not begun.\\\");\\n        require(quantity \\u003e 0, \\\"GLVT: Quantity must be greater than zero.\\\");\\n        require(quantity \\u003c= maxTokensPerMint, \\\"GLVT: Exceeds max tokens per mint\\\");\\n        // type 2 for public sale\\n        return _mint(msg.sender, quantity, publicSalePrice, 2);\\n    }\\n\\n    /**\\n     * Pause the contract.\\n     *\\n     * Requirements:\\n     * - Caller must be the contract owner.\\n     */\\n    function pause() external virtual onlyOwner {\\n        _pause();\\n    }\\n\\n    /**\\n     * Set the address of the authorized mint authority.\\n     *\\n     * @param authority Address of the new authority.\\n     *\\n     * Requirements:\\n     * - Caller must be the contract owner.\\n     */\\n    function setMintAuthority(address authority) external onlyOwner {\\n        require(authority != address(0), \\\"GLVT: Mint authority cannot be zero address.\\\");\\n        mintAuthority = authority;\\n    }\\n\\n    /**\\n     * Set the public sale price.\\n     *\\n     * @param price Public sale price in ETH.\\n     *\\n     * Requirements:\\n     * - Caller must be the contract owner.\\n     */\\n    function setPublicSalePrice(uint256 price) external virtual onlyOwner {\\n        publicSalePrice = price;\\n    }\\n\\n    /**\\n     * Set the timestamp for commencement of public sale.\\n     *\\n     * @param timestamp Timestamp for commencement of public sale.\\n     *\\n     * Requirements:\\n     * - Caller must be the contract owner.\\n     */\\n    function setPublicSaleTimestamp(uint256 timestamp) external virtual onlyOwner {\\n        publicSaleTimestamp = timestamp;\\n    }\\n\\n    /**\\n     * Set the timestamp for commencement of whitelist sale.\\n     *\\n     * @param timestamp Timestamp for commencement of whitelist sale.\\n     *\\n     * Requirements:\\n     * - Caller must be the contract owner.\\n     */\\n    function setWhitelistSaleTimestamp(uint256 timestamp) external virtual onlyOwner {\\n        whitelistSaleTimestamp = timestamp;\\n    }\\n\\n    /**\\n     * Pause the contract.\\n     *\\n     * Requirements:\\n     * - Caller must be the contract owner.\\n     */\\n    function unpause() external virtual onlyOwner {\\n        _unpause();\\n    }\\n\\n    /**\\n     * Withdraw all available ETH held by this contract.\\n     *\\n     * Requirements:\\n     * - Caller must be the contract owner.\\n     */\\n    function withdraw() external virtual onlyOwner nonReentrant {\\n        // send and transfer both have a hard dependency of 2300 on gas costs, so\\n        // there\\u0027s a risk of future failure\\n        (bool success, ) = msg.sender.call{ value: address(this).balance }(\\\"\\\");\\n        require(success, \\\"GLVT: Transfer failed.\\\");\\n    }\\n\\n    /**\\n     * Returns the number of tokens an authorized mint nonce has been used for.\\n     *\\n     * @return uses Quantity of tokens nonce has been used for.\\n     */\\n    function nonceUses(bytes32 nonceWord) external view virtual returns (uint256) {\\n        return _nonces[nonceWord];\\n    }\\n\\n    /**\\n     * Returns the address of the NFT smart contract.\\n     *\\n     * @return tokenContractAddress Address of the NFT smart contract.\\n     */\\n    function tokenContractAddress() external view virtual returns (address) {\\n        return address(_tokenContract);\\n    }\\n\\n    /**\\n     * Checks if public sale has commenced.\\n     *\\n     * @return commenced True if public sale has commenced.\\n     */\\n    function isPublicSale() public view virtual returns (bool) {\\n        return block.timestamp \\u003e= publicSaleTimestamp;\\n    }\\n\\n    /**\\n     * Checks if whitelist sale has commenced.\\n     *\\n     * @return commenced True if whitelist sale has commenced.\\n     */\\n    function isWhitelistSale() public view virtual returns (bool) {\\n        return block.timestamp \\u003e= whitelistSaleTimestamp;\\n    }\\n\\n    /**\\n     * Mint tokens by calling upon the GLVT token contract.\\n     *\\n     * Any excess ETH is refunded to the caller.\\n     *\\n     * @param to Recipient address.\\n     * @param quantity Number of tokens to mint.\\n     * @param price Per-token price in ETH.\\n     * @param mintType Mint type.\\n     *\\n     * Emits a {Mint} event.\\n     */\\n    function _mint(address to, uint256 quantity, uint256 price, uint256 mintType) internal virtual returns (uint256) {\\n        require(!ended, \\\"GLVT: Sale ended\\\");\\n        uint256 requiredEth = price * quantity;\\n        require(msg.value \\u003e= requiredEth, \\\"GLVT: Insufficient ETH for minting.\\\");\\n        require(totalMinted + quantity \\u003c= totalSupply, \\\"GLVT: Total supply exceeded.\\\");\\n\\n        totalMinted += quantity;\\n        uint256 startTokenId = _tokenContract.safeMint(to, quantity);\\n        for (uint i = 0; i \\u003c quantity; i++) {\\n            emit Mint(to, mintType, startTokenId + i);\\n        }\\n\\n        if (msg.value \\u003e requiredEth) {\\n            payable(msg.sender).transfer(msg.value - requiredEth);\\n        }\\n\\n        return startTokenId;\\n    }\\n\\n    /**\\n     * Disassembles a signature into its (v, r, s) components.\\n     *\\n     * @param signature Signature.\\n     * @return (v, r, s) components of the signature.\\n     */\\n    function _disassembleSignature(bytes memory signature) internal view virtual returns (uint8, bytes32, bytes32) {\\n        require(signature.length == 65, \\\"GLVT: Invalid signature length.\\\");\\n        // taken from OpenZeppelin {ECDSA-tryRecover}\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n        return (v, r, s);\\n    }\\n\\n    /**\\n     * @dev Validates a signature.\\n     *\\n     * Given a signature and the original message digest, this function disassembles\\n     * the signature and recovers the address of the original signatory. The address\\n     * of the original signatory is compared against the given signatory to ensure\\n     * its validity.\\n     *\\n     * @param signature Signature.\\n     * @param digest Message body.\\n     * @param signatory Expected address of signatory.\\n     */\\n    function _validateSignature(bytes memory signature, bytes32 digest, address signatory) internal view virtual {\\n        (uint8 v, bytes32 r, bytes32 s) = _disassembleSignature(signature);\\n        address recovered = ECDSA.recover(digest, v, r, s);\\n        require(recovered != address(0), \\\"GLVT: Invalid signature.\\\");\\n        require(recovered == signatory, \\\"GLVT: Unauthorized.\\\");\\n    }\\n}\\n\"},\"IMintableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IMintableUpgradeable {\\n    function safeMint(address to, uint256 quantity) external returns (uint256);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"},\"Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp \\u003e\\u003e= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value \\u0026 0xf];\\n            value \\u003e\\u003e= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mintAuthority_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"whitelistSaleTimestamp_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publicSaleTimestamp_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publicSalePrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractVersion\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintableQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonceWord\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"mintType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"authorizedMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ended\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flipEndState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nonceWord\",\"type\":\"bytes32\"}],\"name\":\"invalidateAuthorizedMintNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPublicSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWhitelistSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokensPerMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintAuthority\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nonceWord\",\"type\":\"bytes32\"}],\"name\":\"nonceUses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSalePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSaleTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"setMintAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setPublicSalePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"setPublicSaleTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"setWhitelistSaleTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistSaleTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GLVTSaleUpgradeableToken", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000aab1eee8d67b335f37736effa8b50f4b5ff96208000000000000000000000000c0249d412819089157061e2f72263d80498d7aab0000000000000000000000000000000000000000000000000000000062ac6cc0000000000000000000000000000000000000000000000000000000006336da40000000000000000000000000000000000000000000000000011c37937e08000000000000000000000000000000000000000000000000000000000000000022b8000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000017476f72696c6c612047616c6176616e74204d696e74657200000000000000000000000000000000000000000000000000000000000000000000000000000000013100000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4594b56f1c2c16842cd27f5acb8b934d92d61c3b3f413716a7e5c4fbd03a61ce"}]}