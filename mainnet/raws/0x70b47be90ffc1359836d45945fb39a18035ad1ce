{"status": "1", "message": "OK", "result": [{"SourceCode": "/*\r\n\r\nToken Name: TURNAROUND\r\nSymbol: R3TRN\r\nTotal Supply: 100 Billion\r\nDecimals: 18\r\nChain: Ethereum\r\n\r\nTokenomics\r\nBuy Tax: 10%\r\n2% Reflection in R3TRN | 3% Liquidity pool | 5% Buyback wallet\r\n\r\nBuy Tax: 40%\r\n5% Reflection in R3TRN | 10% Liquidity pool | 5% Marketing wallet | 20% Buyback wallet\r\n\r\nAnti Whale System\r\nMaximum Wallet Limit 0.1% \r\n\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nlibrary Address {\r\n  function isContract(address account) internal view returns (bool) {\r\n\r\n    uint256 size;\r\n    assembly {\r\n      size := extcodesize(account)\r\n    }\r\n    return size > 0;\r\n  }\r\n\r\n  function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, 'Address: insufficient balance');\r\n\r\n    (bool success, ) = recipient.call{ value: amount }('');\r\n    require(\r\n      success,\r\n      'Address: unable to send value, recipient may have reverted'\r\n    );\r\n  }\r\n\r\n  function functionCall(address target, bytes memory data)\r\n    internal\r\n    returns (bytes memory)\r\n  {\r\n    return functionCall(target, data, 'Address: low-level call failed');\r\n  }\r\n\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, 0, errorMessage);\r\n  }\r\n\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value\r\n  ) internal returns (bytes memory) {\r\n    return\r\n      functionCallWithValue(\r\n        target,\r\n        data,\r\n        value,\r\n        'Address: low-level call with value failed'\r\n      );\r\n  }\r\n\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(\r\n      address(this).balance >= value,\r\n      'Address: insufficient balance for call'\r\n    );\r\n    require(isContract(target), 'Address: call to non-contract');\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n    return _verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  function functionStaticCall(address target, bytes memory data)\r\n    internal\r\n    view\r\n    returns (bytes memory)\r\n  {\r\n    return\r\n      functionStaticCall(target, data, 'Address: low-level static call failed');\r\n  }\r\n\r\n  function functionStaticCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal view returns (bytes memory) {\r\n    require(isContract(target), 'Address: static call to non-contract');\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, bytes memory returndata) = target.staticcall(data);\r\n    return _verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  function functionDelegateCall(address target, bytes memory data)\r\n    internal\r\n    returns (bytes memory)\r\n  {\r\n    return\r\n      functionDelegateCall(\r\n        target,\r\n        data,\r\n        'Address: low-level delegate call failed'\r\n      );\r\n  }\r\n\r\n  function functionDelegateCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(isContract(target), 'Address: delegate call to non-contract');\r\n\r\n    (bool success, bytes memory returndata) = target.delegatecall(data);\r\n    return _verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  function _verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) private pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      if (returndata.length > 0) {\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath: addition overflow');\r\n\r\n    return c;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, 'SafeMath: subtraction overflow');\r\n  }\r\n\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, 'SafeMath: division by zero');\r\n  }\r\n\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n\r\n    return c;\r\n  }\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, 'SafeMath: modulo by zero');\r\n  }\r\n\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address payable) {\r\n    return payable(msg.sender);\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes memory) {\r\n    this; \r\n    return msg.data;\r\n  }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n  address private _owner;\r\n  address private _multiSig;\r\n  address private _previousOwner;\r\n  uint256 private _lockTime;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  constructor() {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(\r\n      _owner == _msgSender() || _multiSig == _msgSender(),\r\n      'Ownable: caller is not the owner'\r\n    );\r\n    _;\r\n  }\r\n\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n\r\n  function setMultisigOwnership(address newMultisig) public virtual onlyOwner {\r\n    require(\r\n      newMultisig != address(0),\r\n      \"Ownable: can't add the 0 address as a multisig component!\"\r\n    );\r\n    _multiSig = newMultisig;\r\n  }\r\n\r\n  function geUnlockTime() public view returns (uint256) {\r\n    return _lockTime;\r\n  }\r\n\r\n  function lock(uint256 time) public virtual onlyOwner {\r\n    _previousOwner = _owner;\r\n    _owner = address(0);\r\n    _lockTime = block.timestamp + time;\r\n    emit OwnershipTransferred(_owner, address(0));\r\n  }\r\n\r\n  function unlock() public virtual {\r\n    require(\r\n      _previousOwner == msg.sender,\r\n      \"You don't have permission to unlock\"\r\n    );\r\n    require(block.timestamp > _lockTime, 'Contract is locked until 7 days');\r\n    emit OwnershipTransferred(_owner, _previousOwner);\r\n    _owner = _previousOwner;\r\n  }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n  event PairCreated(\r\n    address indexed token0,\r\n    address indexed token1,\r\n    address pair,\r\n    uint256\r\n  );\r\n\r\n  function feeTo() external view returns (address);\r\n\r\n  function feeToSetter() external view returns (address);\r\n\r\n  function getPair(address tokenA, address tokenB)\r\n    external\r\n    view\r\n    returns (address pair);\r\n\r\n  function allPairs(uint256) external view returns (address pair);\r\n\r\n  function allPairsLength() external view returns (uint256);\r\n\r\n  function createPair(address tokenA, address tokenB)\r\n    external\r\n    returns (address pair);\r\n\r\n  function setFeeTo(address) external;\r\n\r\n  function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  function name() external pure returns (string memory);\r\n\r\n  function symbol() external pure returns (string memory);\r\n\r\n  function decimals() external pure returns (uint8);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address owner) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) external returns (bool);\r\n\r\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n  function nonces(address owner) external view returns (uint256);\r\n\r\n  function permit(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    uint256 deadline,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n\r\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n  event Burn(\r\n    address indexed sender,\r\n    uint256 amount0,\r\n    uint256 amount1,\r\n    address indexed to\r\n  );\r\n  event Swap(\r\n    address indexed sender,\r\n    uint256 amount0In,\r\n    uint256 amount1In,\r\n    uint256 amount0Out,\r\n    uint256 amount1Out,\r\n    address indexed to\r\n  );\r\n  event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n  function factory() external view returns (address);\r\n\r\n  function token0() external view returns (address);\r\n\r\n  function token1() external view returns (address);\r\n\r\n  function getReserves()\r\n    external\r\n    view\r\n    returns (\r\n      uint112 reserve0,\r\n      uint112 reserve1,\r\n      uint32 blockTimestampLast\r\n    );\r\n\r\n  function price0CumulativeLast() external view returns (uint256);\r\n\r\n  function price1CumulativeLast() external view returns (uint256);\r\n\r\n  function kLast() external view returns (uint256);\r\n\r\n  function mint(address to) external returns (uint256 liquidity);\r\n\r\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\r\n\r\n  function swap(\r\n    uint256 amount0Out,\r\n    uint256 amount1Out,\r\n    address to,\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  function skim(address to) external;\r\n\r\n  function sync() external;\r\n\r\n  function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n  function factory() external pure returns (address);\r\n\r\n  function WETH() external pure returns (address);\r\n\r\n  function addLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 amountADesired,\r\n    uint256 amountBDesired,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  )\r\n    external\r\n    returns (\r\n      uint256 amountA,\r\n      uint256 amountB,\r\n      uint256 liquidity\r\n    );\r\n\r\n  function addLiquidityETH(\r\n    address token,\r\n    uint256 amountTokenDesired,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  )\r\n    external\r\n    payable\r\n    returns (\r\n      uint256 amountToken,\r\n      uint256 amountETH,\r\n      uint256 liquidity\r\n    );\r\n\r\n  function removeLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 liquidity,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n  function removeLiquidityETH(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n  function removeLiquidityWithPermit(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 liquidity,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline,\r\n    bool approveMax,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n  function removeLiquidityETHWithPermit(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline,\r\n    bool approveMax,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n  function swapExactTokensForTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapTokensForExactTokens(\r\n    uint256 amountOut,\r\n    uint256 amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapExactETHForTokens(\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256[] memory amounts);\r\n\r\n  function swapTokensForExactETH(\r\n    uint256 amountOut,\r\n    uint256 amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapExactTokensForETH(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapETHForExactTokens(\r\n    uint256 amountOut,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256[] memory amounts);\r\n\r\n  function quote(\r\n    uint256 amountA,\r\n    uint256 reserveA,\r\n    uint256 reserveB\r\n  ) external pure returns (uint256 amountB);\r\n\r\n  function getAmountOut(\r\n    uint256 amountIn,\r\n    uint256 reserveIn,\r\n    uint256 reserveOut\r\n  ) external pure returns (uint256 amountOut);\r\n\r\n  function getAmountIn(\r\n    uint256 amountOut,\r\n    uint256 reserveIn,\r\n    uint256 reserveOut\r\n  ) external pure returns (uint256 amountIn);\r\n\r\n  function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n    external\r\n    view\r\n    returns (uint256[] memory amounts);\r\n\r\n  function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n    external\r\n    view\r\n    returns (uint256[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountETH);\r\n\r\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline,\r\n    bool approveMax,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external returns (uint256 amountETH);\r\n\r\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external;\r\n\r\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable;\r\n\r\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external;\r\n}\r\n\r\ncontract TURNAROUND is Context, IERC20, Ownable {\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n\r\n  mapping(address => uint256) private _rOwned;\r\n  mapping(address => uint256) private _tOwned;\r\n  mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n  mapping(address => bool) private _isExcludedFromFee;\r\n  mapping(address => bool) private _isExcluded; //from reflections\r\n  address[] private _excluded;\r\n\r\n  mapping(address => bool) private _isExcludedFromTxLimit; //Adding this for the dxsale/unicrypt presale, the router needs to be exempt from max tx amount limit.\r\n\r\n  uint256 private constant MAX = ~uint256(0);\r\n  uint256 private _tTotal = 100 * 10**9 * 10**18; // 100 Billion Tokens\r\n  uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n  uint256 private _tFeeTotal;\r\n  uint256 public maxWalletAmount = 100000000 * 10**18; // 0.1%\r\n  string private _name = 'TURNAROUND';\r\n  string private _symbol = 'R3TRN';\r\n  uint8 private _decimals = 18;\r\n  bool public antiwhaleEnabled = false;\r\n\r\n  uint256 public _taxFee = 0;\r\n  uint256 private _previousTaxFee = _taxFee;\r\n  bool private antiSniping_failsafe = true;\r\n\r\n  uint256 public _liquidityFee = 0;\r\n  uint256 private _previousLiquidityFee = _liquidityFee;\r\n\r\n  uint256 public _marketingFee = 0;\r\n  uint256 private _previousMarketingFee = _marketingFee;\r\n\r\n  uint256 public _buybackFee = 0;\r\n  uint256 private _previousBuybackFee = _buybackFee;\r\n\r\n  uint256 public buybackFeeBuy = 5;\r\n  uint256 public buybackFeeSell = 20;\r\n\r\n  uint256 public marketingFeeBuy = 0;\r\n  uint256 public marketingFeeSell = 5;\r\n\r\n  uint256 public liquidityFeeBuy = 3;\r\n  uint256 public liquidityFeeSell = 10;\r\n\r\n  uint256 public reflectFeeBuy = 2;\r\n  uint256 public reflectFeeSell = 5;\r\n\r\n  // 10% BUY TAX\r\n  // 40% SELL TAX\r\n\r\n  address private _marketingWalletAddress = 0x105f24d575792e58b11c659bd90d4061bF87B690; \r\n  address public _buybackWallet = 0xeA0E151b09a3E0021e748A392f968037ACB5d042;\r\n\r\n  uint256 private launchedAt; \r\n  bool private manualLaunch = false;\r\n\r\n  IUniswapV2Router02 public immutable uniswapV2Router;\r\n  address public immutable TURNAROUNDUniswapV2Pair;\r\n  mapping(address => bool) _isExcludedFromMaxWalletLimit;\r\n\r\n  bool inSwapAndLiquify;\r\n  bool public swapAndLiquifyEnabled = true;\r\n\r\n  uint256 public _maxTxAmount = 100 * 10**9 * 10**18; // 1%\r\n  uint256 private numTokensSellToAddToLiquidity = 5000 * 10**18;\r\n\r\n  event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\r\n  event SwapAndLiquifyEnabledUpdated(bool enabled);\r\n  event SwapAndLiquify(\r\n    uint256 tokensSwapped,\r\n    uint256 ethReceived,\r\n    uint256 tokensIntoLiqudity\r\n  );\r\n  event AntiSnipingFailsafeSetTo(bool toggle);\r\n\r\n  modifier lockTheSwap() {\r\n    inSwapAndLiquify = true;\r\n    _;\r\n    inSwapAndLiquify = false;\r\n  }\r\n\r\n  constructor() {\r\n      address _newOwner = 0x0c759Ed756c8577eEC75ADfa34E52a7B0b4d6Dc1; // must change this before deployment\r\n    _rOwned[_newOwner] = _rTotal;\r\n\r\n    IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\r\n      0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n    ); //Uniswap Router.\r\n    //Create a new uniswap pair for this new token and set the local pair pointer\r\n    TURNAROUNDUniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n      .createPair(address(this), _uniswapV2Router.WETH());\r\n\r\n    uniswapV2Router = _uniswapV2Router;\r\n\r\n    _isExcludedFromFee[_newOwner] = true;\r\n    _isExcludedFromFee[address(this)] = true;\r\n    _isExcludedFromMaxWalletLimit[_newOwner] = true;\r\n    _isExcludedFromMaxWalletLimit[address(this)] = true;\r\n    _isExcludedFromTxLimit[_newOwner] = true;\r\n    _isExcludedFromTxLimit[address(this)] = true;\r\n\r\n    emit Transfer(address(0), _newOwner, _tTotal);\r\n  }\r\n\r\n  function name() public view returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  function symbol() public view returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  function decimals() public view returns (uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  function totalSupply() public view override returns (uint256) {\r\n    return _tTotal;\r\n  }\r\n\r\n  function setMaxWalletAmount(uint val) public onlyOwner {\r\n      require(val > 100000 * 10**18, \"Min wallet reached\");\r\n      maxWalletAmount = val;\r\n  }\r\n\r\n  function launch() internal {\r\n    launchedAt = block.number;\r\n  }\r\n\r\n  function launched() internal view returns (bool) {\r\n    return launchedAt != 0;\r\n  }\r\n\r\n  function manualLaunchOverride(bool toggle) public onlyOwner {\r\n    manualLaunch = toggle;\r\n  }\r\n\r\n  function setAntiSnipeFailsafe(bool failsafe) public {\r\n    antiSniping_failsafe = failsafe;\r\n    emit AntiSnipingFailsafeSetTo(failsafe);\r\n  }\r\n\r\n  function balanceOf(address account) public view override returns (uint256) {\r\n    if (_isExcluded[account]) return _tOwned[account];\r\n    return tokenFromReflection(_rOwned[account]);\r\n  }\r\n\r\n  function transfer(address recipient, uint256 amount)\r\n    public\r\n    override\r\n    returns (bool)\r\n  {\r\n    _transfer(_msgSender(), recipient, amount);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address owner, address spender)\r\n    public\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _allowances[owner][spender];\r\n  }\r\n\r\n  function approve(address spender, uint256 amount)\r\n    public\r\n    override\r\n    returns (bool)\r\n  {\r\n    _approve(_msgSender(), spender, amount);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) public override returns (bool) {\r\n    _transfer(sender, recipient, amount);\r\n    _approve(\r\n      sender,\r\n      _msgSender(),\r\n      _allowances[sender][_msgSender()].sub(\r\n        amount,\r\n        'ERC20: transfer amount exceeds allowance'\r\n      )\r\n    );\r\n    return true;\r\n  }\r\n\r\n \r\n  function increaseAllowance(address spender, uint256 addedValue)\r\n    public\r\n    virtual\r\n    returns (bool)\r\n  {\r\n    _approve(\r\n      _msgSender(),\r\n      spender,\r\n      _allowances[_msgSender()][spender].add(addedValue)\r\n    );\r\n    return true;\r\n  }\r\n\r\n  function decreaseAllowance(address spender, uint256 subtractedValue)\r\n    public\r\n    virtual\r\n    returns (bool)\r\n  {\r\n    _approve(\r\n      _msgSender(),\r\n      spender,\r\n      _allowances[_msgSender()][spender].sub(\r\n        subtractedValue,\r\n        'ERC20: decreased allowance below zero'\r\n      )\r\n    );\r\n    return true;\r\n  }\r\n\r\n  function isExcludedFromReward(address account) public view returns (bool) {\r\n    return _isExcluded[account];\r\n  }\r\n\r\n  function totalFees() public view returns (uint256) {\r\n    return _tFeeTotal;\r\n  }\r\n\r\n  function deliver(uint256 tAmount) public {\r\n    address sender = _msgSender();\r\n    require(\r\n      !_isExcluded[sender],\r\n      'Excluded addresses cannot call this function'\r\n    );\r\n    //Deprecated\r\n    (uint256 rAmount, , , , , ) = _getValues(tAmount); \r\n\r\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n    _rTotal = _rTotal.sub(rAmount);\r\n    _tFeeTotal = _tFeeTotal.add(tAmount);\r\n  }\r\n\r\n  function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(tAmount <= _tTotal, 'Amount must be less than supply');\r\n    if (!deductTransferFee) {\r\n      //Deprecated\r\n      (uint256 rAmount, , , , , ) = _getValues(tAmount); \r\n\r\n      return rAmount;\r\n    } else {\r\n      //Deprecated\r\n      (, uint256 rTransferAmount, , , , ) = _getValues(tAmount); \r\n\r\n      return rTransferAmount;\r\n    }\r\n  }\r\n\r\n  function tokenFromReflection(uint256 rAmount) public view returns (uint256) {\r\n    require(rAmount <= _rTotal, 'Amount must be less than total reflections');\r\n    uint256 currentRate = _getRate();\r\n    return rAmount.div(currentRate);\r\n  }\r\n\r\n  function excludeFromReward(address account) public onlyOwner {\r\n    require(!_isExcluded[account], 'Account already excluded');\r\n    if (_rOwned[account] > 0) {\r\n      _tOwned[account] = tokenFromReflection(_rOwned[account]);\r\n    }\r\n    _isExcluded[account] = true;\r\n    _excluded.push(account);\r\n  }\r\n\r\n  function includeInReward(address account) external onlyOwner {\r\n    require(_isExcluded[account], 'Account is already included');\r\n    for (uint256 i = 0; i < _excluded.length; i++) {\r\n      if (_excluded[i] == account) {\r\n        _excluded[i] = _excluded[_excluded.length - 1];\r\n        _tOwned[account] = 0;\r\n        _isExcluded[account] = false;\r\n        _excluded.pop();\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  function _transferBothExcluded(\r\n    address sender,\r\n    address recipient,\r\n    uint256 tAmount\r\n  ) private {\r\n    //Deprecated\r\n    (\r\n      uint256 rAmount,\r\n      uint256 rTransferAmount,\r\n      uint256 rFee,\r\n      uint256 tTransferAmount,\r\n      uint256 tFee,\r\n      uint256 tLiquidity\r\n    ) = _getValues(tAmount); \r\n\r\n    _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n    _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n    _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n    _takeLiquidity(tLiquidity);\r\n    _reflectFee(rFee, tFee);\r\n    emit Transfer(sender, recipient, tTransferAmount);\r\n  }\r\n\r\n  function setIsExcludedFromTXLimit(address account, bool isExcluded)\r\n    public\r\n    onlyOwner\r\n  {\r\n    _isExcludedFromTxLimit[account] = isExcluded;\r\n  }\r\n\r\n  function isExcludedFromTXLimit(address account) public view returns (bool) {\r\n    return _isExcludedFromTxLimit[account];\r\n  }\r\n\r\n  function excludeFromFee(address account) public onlyOwner {\r\n    _isExcludedFromFee[account] = true;\r\n  }\r\n\r\n  function includeInFee(address account) public onlyOwner {\r\n    _isExcludedFromFee[account] = false;\r\n  }\r\n  function setBuyFees() private {\r\n\r\n      _previousBuybackFee = _buybackFee;\r\n      _buybackFee = buybackFeeBuy;\r\n      _previousLiquidityFee = _liquidityFee;\r\n      _liquidityFee = liquidityFeeBuy;\r\n      _previousMarketingFee = _marketingFee;\r\n      _marketingFee = marketingFeeBuy;\r\n      _previousTaxFee = _taxFee;\r\n      _taxFee = reflectFeeBuy;\r\n\r\n  }\r\n\r\n function setSellFees() private {\r\n\r\n      _previousBuybackFee = _buybackFee;\r\n      _buybackFee = buybackFeeSell;\r\n      _previousLiquidityFee = _liquidityFee;\r\n      _liquidityFee = liquidityFeeSell;\r\n      _previousMarketingFee = _marketingFee;\r\n      _marketingFee = marketingFeeSell;\r\n      _previousTaxFee = _taxFee;\r\n      _taxFee = reflectFeeSell;\r\n\r\n  }\r\n  function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner {\r\n      require(maxTxPercent > 0, \"min 0 invalid\");\r\n    _maxTxAmount = _tTotal.mul(maxTxPercent).div(100 * 10**2);\r\n  }\r\n\r\n  function setMaxTxAmount(uint256 newAmount) external onlyOwner {\r\n    _maxTxAmount = newAmount * 10**18;\r\n  }\r\n\r\n  function setnumTokensSellToAddToLiquidity(uint256 newValue) external onlyOwner {\r\n    numTokensSellToAddToLiquidity = newValue * 10**18;\r\n  }\r\n\r\n  function setSwapAndLiquifyEnabled(bool toggle) public onlyOwner {\r\n    swapAndLiquifyEnabled = toggle;\r\n    emit SwapAndLiquifyEnabledUpdated(toggle);\r\n  }\r\n\r\n  //to recieve ETH from uniswapV2Router when swaping\r\n  receive() external payable {}\r\n\r\n  function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n    _rTotal = _rTotal.sub(rFee);\r\n    _tFeeTotal = _tFeeTotal.add(tFee);\r\n  }\r\n\r\n  struct tVector {\r\n    uint256 tTransferAmount;\r\n    uint256 tFee;\r\n    uint256 tLiquidity;\r\n    uint256 tMarketing;\r\n  }\r\n\r\n  struct rVector {\r\n    uint256 rAmount;\r\n    uint256 rTransferAmount;\r\n    uint256 rFee;\r\n  }\r\n\r\n  function _getValues(uint256 tAmount)\r\n    private\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    )\r\n  {\r\n    tVector memory my_tVector;\r\n    rVector memory my_rVector;\r\n    {\r\n      (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getTValues(\r\n        tAmount\r\n      );\r\n      my_tVector.tTransferAmount = tTransferAmount;\r\n      my_tVector.tFee = tFee;\r\n      my_tVector.tLiquidity = tLiquidity;\r\n    }\r\n    {\r\n      (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\r\n        tAmount,\r\n        my_tVector.tFee,\r\n        my_tVector.tLiquidity,\r\n        _getRate()\r\n      );\r\n      my_rVector.rAmount = rAmount;\r\n      my_rVector.rTransferAmount = rTransferAmount;\r\n      my_rVector.rFee = rFee;\r\n    }\r\n    return (\r\n      my_rVector.rAmount,\r\n      my_rVector.rTransferAmount,\r\n      my_rVector.rFee,\r\n      my_tVector.tTransferAmount,\r\n      my_tVector.tFee,\r\n      my_tVector.tLiquidity\r\n    );\r\n  }\r\n\r\n  function _getTValues(uint256 tAmount)\r\n    private\r\n    view\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    )\r\n  {\r\n    uint256 tFee = calculateTaxFee(tAmount);\r\n    uint256 tLiquidity = calculateLiquidityFee(tAmount);\r\n    uint256 tTransferAmount = tAmount.sub(tFee);\r\n    tTransferAmount = tTransferAmount.sub(tLiquidity);\r\n    return (tTransferAmount, tFee, tLiquidity);\r\n  }\r\n\r\n  function _getRValues(\r\n    uint256 tAmount,\r\n    uint256 tFee,\r\n    uint256 tLiquidity,\r\n    uint256 currentRate\r\n  )\r\n    private\r\n    pure\r\n    returns (\r\n      uint256,\r\n      uint256,\r\n      uint256\r\n    )\r\n  {\r\n    uint256 rAmount = tAmount.mul(currentRate);\r\n    uint256 rTransferAmount;\r\n    uint256 rFee;\r\n    {\r\n      rFee = tFee.mul(currentRate);\r\n      uint256 rLiquidity = tLiquidity.mul(currentRate);\r\n      rTransferAmount = rAmount.sub(rFee);\r\n      rTransferAmount = rTransferAmount.sub(rLiquidity);\r\n    }\r\n    return (rAmount, rTransferAmount, rFee);\r\n  }\r\n\r\n  function _getRate() private view returns (uint256) {\r\n    (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n    return rSupply.div(tSupply);\r\n  }\r\n\r\n  function _getCurrentSupply() private view returns (uint256, uint256) {\r\n    uint256 rSupply = _rTotal;\r\n    uint256 tSupply = _tTotal;\r\n    for (uint256 i = 0; i < _excluded.length; i++) {\r\n      if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply)\r\n        return (_rTotal, _tTotal);\r\n      rSupply = rSupply.sub(_rOwned[_excluded[i]]);\r\n      tSupply = tSupply.sub(_tOwned[_excluded[i]]);\r\n    }\r\n    if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r\n    return (rSupply, tSupply);\r\n  }\r\n\r\n  function _takeLiquidity(uint256 tLiquidity) private {\r\n    uint256 currentRate = _getRate();\r\n    uint256 rLiquidity = tLiquidity.mul(currentRate);\r\n    _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);\r\n    if (_isExcluded[address(this)])\r\n      _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);\r\n  }\r\n\r\n  function calculateTaxFee(uint256 _amount) private view returns (uint256) {\r\n    uint256 this_taxFee = _taxFee;\r\n    return _amount.mul(this_taxFee).div(100);\r\n  }\r\n\r\n  function calculateLiquidityFee(uint256 _amount)\r\n    private\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return _amount.mul(_liquidityFee.add(_marketingFee).add(_buybackFee)).div(100);\r\n  }\r\n\r\n  function setMarketingAddr(address account) external onlyOwner {\r\n    _marketingWalletAddress = account;\r\n  }\r\n  function setBuybackWallet(address acc) public onlyOwner {\r\n      _buybackWallet = acc;\r\n  }\r\n\r\n\r\n  function getMarketingAddr() public view returns (address) {\r\n    return _marketingWalletAddress;\r\n  }\r\n\r\n  function removeAllFee() private {\r\n    if (_taxFee == 0 && _liquidityFee == 0 && _buybackFee == 0) return;\r\n\r\n    _previousTaxFee = _taxFee;\r\n    _previousMarketingFee = _marketingFee;\r\n    _previousLiquidityFee = _liquidityFee;\r\n    _previousBuybackFee = _buybackFee;\r\n    _taxFee = 0;\r\n    _buybackFee = 0;\r\n    _marketingFee = 0;\r\n    _liquidityFee = 0;\r\n  }\r\n\r\n  function restoreAllFee() private {\r\n    _taxFee = _previousTaxFee;\r\n    _marketingFee = _previousMarketingFee;\r\n    _liquidityFee = _previousLiquidityFee;\r\n    _buybackFee = _previousBuybackFee;\r\n  }\r\n\r\n  function isExcludedFromFee(address account) public view returns (bool) {\r\n    return _isExcludedFromFee[account];\r\n  }\r\n\r\n  function _approve(\r\n    address owner,\r\n    address spender,\r\n    uint256 amount\r\n  ) private {\r\n    require(owner != address(0), 'ERC20: approve from the zero address');\r\n    require(spender != address(0), 'ERC20: approve to the zero address');\r\n\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  function enableAntiwhale(bool value) public onlyOwner {\r\n      antiwhaleEnabled = value;\r\n  }\r\n\r\n  //MARKER: This is our bread and butter.\r\n  function _transfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) private {\r\n    require(from != address(0), 'ERC20: transfer from the zero address');\r\n    require(to != address(0), 'ERC20: transfer to the zero address');\r\n    require(amount > 0, 'Transfer amount must be greater than zero');\r\n\r\n    if ((!launched() && to == TURNAROUNDUniswapV2Pair) || manualLaunch) {\r\n      require(\r\n        balanceOf(from) > 0,\r\n        'Are you trying to launch without actually having tokens? WTF?'\r\n      );\r\n      launch();\r\n    }\r\n\r\n    if (antiwhaleEnabled && ((from != owner() && to != owner()) || !(_isExcludedFromTxLimit[from]))) {\r\n      require(\r\n        amount <= _maxTxAmount,\r\n        'TURNAROUND: Transfer amount exceeds the maxTxAmount.'\r\n      );\r\n    }\r\n    if(!_isExcludedFromMaxWalletLimit[from] && !_isExcludedFromMaxWalletLimit[to] && to != TURNAROUNDUniswapV2Pair) {\r\n        uint balance = balanceOf(to);\r\n        require(balance + amount <= maxWalletAmount,\" max wallet reached\");\r\n    }\r\n    uint256 contractTokenBalance = balanceOf(address(this));\r\n\r\n    if (contractTokenBalance >= _maxTxAmount) {\r\n      contractTokenBalance = _maxTxAmount;\r\n    }\r\n\r\n    bool overMinTokenBalance = (contractTokenBalance >=\r\n      numTokensSellToAddToLiquidity);\r\n    if (\r\n      overMinTokenBalance &&\r\n      !inSwapAndLiquify &&\r\n      from != TURNAROUNDUniswapV2Pair &&\r\n      swapAndLiquifyEnabled\r\n    ) {\r\n        setSellFees();\r\n        inSwapAndLiquify = true;\r\n      contractTokenBalance = numTokensSellToAddToLiquidity;\r\n      //add liquidity\r\n      swapAndLiquify(contractTokenBalance);\r\n      restoreAllFee();\r\n      inSwapAndLiquify = false;\r\n    }\r\n\r\n    bool takeFee = true;\r\n    if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\r\n      takeFee = false;\r\n    }\r\n\r\n    bool isSniper = false;\r\n    if (antiSniping_failsafe && launchedAt + 3 >= block.number) {\r\n      isSniper = true;\r\n    }\r\n\r\n    bool purchaseOrSale = false;\r\n    if (to == TURNAROUNDUniswapV2Pair) {\r\n      purchaseOrSale = true;\r\n    }\r\n\r\n    _tokenTransfer(from, to, amount, takeFee);\r\n  }\r\n\r\n  function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\r\n    uint256 marketingBalance = contractTokenBalance.mul(_marketingFee).div(\r\n      _marketingFee.add(_liquidityFee).add(_buybackFee)\r\n    );\r\n    uint buybackBal = contractTokenBalance.mul(_buybackFee).div(_marketingFee.add(_liquidityFee).add(_buybackFee));\r\n    uint256 liquidityBalance = contractTokenBalance.sub(marketingBalance).sub(buybackBal);\r\n\r\n    uint256 half = liquidityBalance.div(2);\r\n    uint256 otherHalf = liquidityBalance.sub(half);\r\n    uint256 tokensToSwapForETH = half.add(marketingBalance).add(buybackBal);\r\n\r\n    uint256 initialBalance = address(this).balance;\r\n\r\n    // swap tokens for ETH\r\n    swapTokensForEth(tokensToSwapForETH); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\r\n\r\n    // how much ETH did we just swap into?\r\n    uint256 newBalance = address(this).balance.sub(initialBalance);\r\n\r\n    uint256 marketingETHBalance = newBalance.mul(marketingBalance).div(\r\n      tokensToSwapForETH\r\n    );\r\n        uint buybackBalanceETH = newBalance.mul(buybackBal).div(tokensToSwapForETH);\r\n    uint256 liquidityETHBalance = newBalance.sub(marketingETHBalance).sub(buybackBalanceETH);\r\n\r\n\r\n\r\n    // add liquidity to uniswap\r\n    addLiquidity(otherHalf, liquidityETHBalance);\r\n\r\n    // send ETH to marketing wallet\r\n    sendETHToMarketing(marketingETHBalance);\r\n    sendETHToBuyback(buybackBalanceETH);\r\n\r\n    emit SwapAndLiquify(half, newBalance, otherHalf);\r\n  }\r\n\r\n  function swapTokensForEth(uint256 tokenAmount) private {\r\n    // generate the uniswap pair path of token -> weth\r\n    address[] memory path = new address[](2);\r\n    path[0] = address(this);\r\n    path[1] = uniswapV2Router.WETH();\r\n\r\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n    // make the swap\r\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n      tokenAmount,\r\n      0, // accept any amount of ETH\r\n      path,\r\n      address(this),\r\n      block.timestamp\r\n    );\r\n  }\r\n\r\n  function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\r\n    // approve token transfer to cover all possible scenarios\r\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n    // add the liquidity\r\n    uniswapV2Router.addLiquidityETH{ value: ethAmount }(\r\n      address(this),\r\n      tokenAmount,\r\n      0, // slippage is unavoidable\r\n      0, // slippage is unavoidable\r\n      address(0),\r\n      block.timestamp\r\n    );\r\n  }\r\n\r\n  function sendETHToMarketing(uint256 amount) private {\r\n    payable( _marketingWalletAddress).transfer(amount);\r\n  }\r\n\r\n  \r\n  function sendETHToBuyback(uint256 amount) private {\r\n    payable( _buybackWallet).transfer(amount);\r\n  }\r\n  function setSellFee(uint buyback, uint marketing, uint liquidity, uint reflect) public onlyOwner {\r\n      buybackFeeSell = buyback;\r\n      marketingFeeSell = marketing;\r\n      liquidityFeeSell = liquidity;\r\n      reflectFeeSell = reflect;\r\n      require(buyback + marketing + liquidity + reflect <= 25, \"max 25%\");\r\n  }\r\n\r\n    function setBuyFees(uint buyback, uint marketing, uint liquidity, uint reflect) public onlyOwner {\r\n      buybackFeeBuy = buyback;\r\n      marketingFeeBuy = marketing;\r\n      liquidityFeeBuy = liquidity;\r\n      reflectFeeBuy = reflect;\r\n      require(buyback + marketing + liquidity + reflect <= 25, \"max 25%\");\r\n  }\r\n  function setExcludedMaxWallet(address acc, bool value) public onlyOwner {\r\n      _isExcludedFromMaxWalletLimit[acc] = value;\r\n  }\r\n  function isExcludedFromMaxWallet(address ac) public view returns(bool) {\r\n      return _isExcludedFromMaxWalletLimit[ac];\r\n  }\r\n  //this method is responsible for taking all fee, if takeFee is true\r\n  function _tokenTransfer(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount,\r\n    bool takeFee\r\n  ) private {\r\n    if (!takeFee) removeAllFee();\r\n    if(takeFee && sender == TURNAROUNDUniswapV2Pair) {\r\n        // buy\r\n        setBuyFees();\r\n    } else if(takeFee && recipient == TURNAROUNDUniswapV2Pair) {\r\n        // sell\r\n        setSellFees();\r\n    }\r\n    if (_isExcluded[sender] && !_isExcluded[recipient]) {\r\n      _transferFromExcluded(sender, recipient, amount);\r\n    } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\r\n      _transferToExcluded(sender, recipient, amount);\r\n    } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\r\n      _transferStandard(sender, recipient, amount);\r\n    } else if (_isExcluded[sender] && _isExcluded[recipient]) {\r\n      _transferBothExcluded(sender, recipient, amount);\r\n    } else {\r\n      _transferStandard(sender, recipient, amount);\r\n    }\r\n\r\n    if(takeFee && (sender == TURNAROUNDUniswapV2Pair || recipient == TURNAROUNDUniswapV2Pair)) {\r\n        restoreAllFee();\r\n    }\r\n\r\n    if (!takeFee) restoreAllFee();\r\n  }\r\n\r\n  function setNumTokensell(uint value ) public onlyOwner \r\n{\r\nnumTokensSellToAddToLiquidity = value;\r\n}\r\n\r\n  function _transferStandard(\r\n    address sender,\r\n    address recipient,\r\n    uint256 tAmount\r\n  ) private {\r\n    //Deprecated\r\n    (\r\n      uint256 rAmount,\r\n      uint256 rTransferAmount,\r\n      uint256 rFee,\r\n      uint256 tTransferAmount,\r\n      uint256 tFee,\r\n      uint256 tLiquidity\r\n    ) = _getValues(tAmount); \r\n\r\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n    _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n    _takeLiquidity(tLiquidity);\r\n    _reflectFee(rFee, tFee);\r\n    emit Transfer(sender, recipient, tTransferAmount);\r\n  }\r\n\r\n  function _transferToExcluded(\r\n    address sender,\r\n    address recipient,\r\n    uint256 tAmount\r\n  ) private {\r\n    //Deprecated\r\n    (\r\n      uint256 rAmount,\r\n      uint256 rTransferAmount,\r\n      uint256 rFee,\r\n      uint256 tTransferAmount,\r\n      uint256 tFee,\r\n      uint256 tLiquidity\r\n    ) = _getValues(tAmount); \r\n\r\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n    _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n    _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n    _takeLiquidity(tLiquidity);\r\n    _reflectFee(rFee, tFee);\r\n    emit Transfer(sender, recipient, tTransferAmount);\r\n  }\r\n\r\n  function _transferFromExcluded(\r\n    address sender,\r\n    address recipient,\r\n    uint256 tAmount\r\n  ) private {\r\n\r\n    (\r\n      uint256 rAmount,\r\n      uint256 rTransferAmount,\r\n      uint256 rFee,\r\n      uint256 tTransferAmount,\r\n      uint256 tFee,\r\n      uint256 tLiquidity\r\n    ) = _getValues(tAmount); \r\n\r\n    _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n    _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n    _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n    _takeLiquidity(tLiquidity);\r\n    _reflectFee(rFee, tFee);\r\n    emit Transfer(sender, recipient, tTransferAmount);\r\n  }\r\n\r\n  function emergencyWithdraw() external onlyOwner {\r\n    payable(owner()).transfer(address(this).balance);\r\n  }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"toggle\",\"type\":\"bool\"}],\"name\":\"AntiSnipingFailsafeSetTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minTokensBeforeSwap\",\"type\":\"uint256\"}],\"name\":\"MinTokensBeforeSwapUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TURNAROUNDUniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buybackFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buybackWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_taxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"antiwhaleEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buybackFeeBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buybackFeeSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"deliver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"enableAntiwhale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"geUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarketingAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ac\",\"type\":\"address\"}],\"name\":\"isExcludedFromMaxWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromTXLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFeeBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFeeSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"toggle\",\"type\":\"bool\"}],\"name\":\"manualLaunchOverride\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reflectFeeBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reflectFeeSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"failsafe\",\"type\":\"bool\"}],\"name\":\"setAntiSnipeFailsafe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buyback\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reflect\",\"type\":\"uint256\"}],\"name\":\"setBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"}],\"name\":\"setBuybackWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"acc\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setExcludedMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"setIsExcludedFromTXLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setMarketingAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxPercent\",\"type\":\"uint256\"}],\"name\":\"setMaxTxPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMultisig\",\"type\":\"address\"}],\"name\":\"setMultisigOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setNumTokensell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buyback\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reflect\",\"type\":\"uint256\"}],\"name\":\"setSellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"toggle\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setnumTokensSellToAddToLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TURNAROUND", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ecd3e077943bbd7664a0bdd7ff7f70d1aa4ecbc0b0af01df3f3a6b173bf65b2e"}]}