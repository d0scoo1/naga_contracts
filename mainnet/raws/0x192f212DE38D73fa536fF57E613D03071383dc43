{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AGStake.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\\\";\\r\\n\\r\\ninterface IAlphaGang {\\r\\n    function balanceOf(address account, uint256 id)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] memory ids,\\r\\n        uint256[] memory amounts,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ninterface IGangToken {\\r\\n    function mint(address to, uint256 amount) external;\\r\\n}\\r\\n\\r\\ncontract AGStake is Ownable, ERC1155Holder {\\r\\n    event Stake(address owner, uint256 tokenId, uint256 count);\\r\\n    event Unstake(address owner, uint256 tokenId, uint256 count);\\r\\n    event StakeAll(address owner, uint256[] tokenIds, uint256[] counts);\\r\\n    event UnstakeAll(address owner, uint256[] tokenIds, uint256[] counts);\\r\\n\\r\\n    /**\\r\\n     * Event called when a stake is claimed by user\\r\\n     * Args:\\r\\n     * owner: address for which it was claimed\\r\\n     * amount: amount of $GANG tokens claimed\\r\\n     * count: count of staked(hard or soft) tokens\\r\\n     * multiplier: flag indicating wheat the applied multiplier is\\r\\n     */\\r\\n    event Claim(\\r\\n        address owner,\\r\\n        uint256 amount,\\r\\n        uint256 count,\\r\\n        uint256 multiplier\\r\\n    );\\r\\n\\r\\n    // references to the AG contracts\\r\\n    IAlphaGang alphaGang;\\r\\n    IGangToken gangToken;\\r\\n\\r\\n    uint256 public ogStakeRate = 496031746031746;\\r\\n    uint256 public softStakeRate = 124007936507936;\\r\\n\\r\\n    // maps tokenId to stake\\r\\n    mapping(uint256 => mapping(address => uint256)) private vault;\\r\\n    // records block timestamp when last claim occured\\r\\n    mapping(address => uint256) lastClaim;\\r\\n    mapping(address => uint256) lastSoftClaim;\\r\\n    // default start time for claiming rewards\\r\\n    uint256 public immutable START;\\r\\n\\r\\n    constructor(IAlphaGang _nft, IGangToken _token) {\\r\\n        alphaGang = _nft;\\r\\n        gangToken = _token;\\r\\n        START = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function stakeSingle(uint256 tokenId, uint256 tokenCount) external {\\r\\n        address _owner = msg.sender;\\r\\n\\r\\n        alphaGang.safeTransferFrom(\\r\\n            _owner,\\r\\n            address(this),\\r\\n            tokenId,\\r\\n            tokenCount,\\r\\n            \\\"\\\"\\r\\n        );\\r\\n\\r\\n        // claim unstaked tokens, since count/rate will change\\r\\n        // claiming after transfer, not to waste too much gas in case user doesn't have any tokens\\r\\n        claimForAddress(_owner, true);\\r\\n        claimForAddress(_owner, false);\\r\\n        unchecked {\\r\\n            vault[tokenId][_owner] += tokenCount;\\r\\n        }\\r\\n\\r\\n        emit Stake(_owner, tokenId, tokenCount);\\r\\n    }\\r\\n\\r\\n    function unstakeSingle(uint256 tokenId, uint256 tokenCount) external {\\r\\n        address _owner = msg.sender;\\r\\n        uint256 totalStaked = vault[tokenId][_owner];\\r\\n\\r\\n        require(\\r\\n            totalStaked >= 0,\\r\\n            \\\"You do have any tokens available for unstaking\\\"\\r\\n        );\\r\\n        require(\\r\\n            totalStaked >= tokenCount,\\r\\n            \\\"You do not have requested token amount available for unstaking\\\"\\r\\n        );\\r\\n\\r\\n        // claim rewards before unstaking\\r\\n        claimForAddress(_owner, true);\\r\\n        claimForAddress(_owner, false);\\r\\n        unchecked {\\r\\n            vault[tokenId][_owner] -= tokenCount;\\r\\n        }\\r\\n\\r\\n        alphaGang.safeTransferFrom(\\r\\n            address(this),\\r\\n            _owner,\\r\\n            tokenId,\\r\\n            tokenCount,\\r\\n            \\\"\\\"\\r\\n        );\\r\\n\\r\\n        emit Unstake(msg.sender, tokenId, tokenCount);\\r\\n    }\\r\\n\\r\\n    function _stakeAll() internal {\\r\\n        address _owner = msg.sender;\\r\\n        uint256[] memory totalAvailable = unstakedBalanceOf(_owner);\\r\\n\\r\\n        uint256[] memory tokens = new uint256[](3);\\r\\n        tokens[0] = 1;\\r\\n        tokens[1] = 2;\\r\\n        tokens[2] = 3;\\r\\n\\r\\n        alphaGang.safeBatchTransferFrom(\\r\\n            _owner,\\r\\n            address(this),\\r\\n            tokens,\\r\\n            totalAvailable,\\r\\n            \\\"\\\"\\r\\n        );\\r\\n\\r\\n        // loop over and update the vault\\r\\n        unchecked {\\r\\n            for (uint32 i = 1; i < 4; i++) {\\r\\n                vault[i][_owner] += totalAvailable[i - 1];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit StakeAll(msg.sender, tokens, totalAvailable);\\r\\n    }\\r\\n\\r\\n    function _unstakeAll() internal {\\r\\n        address _owner = msg.sender;\\r\\n        uint256[] memory totalStaked = stakedBalanceOf(_owner);\\r\\n\\r\\n        uint256[] memory tokens = new uint256[](3);\\r\\n        tokens[0] = 1;\\r\\n        tokens[1] = 2;\\r\\n        tokens[2] = 3;\\r\\n\\r\\n        // loop over and update the vault\\r\\n        unchecked {\\r\\n            for (uint32 i = 1; i < 4; i++) {\\r\\n                vault[i][_owner] -= totalStaked[i - 1];\\r\\n            }\\r\\n        }\\r\\n\\r\\n        alphaGang.safeBatchTransferFrom(\\r\\n            address(this),\\r\\n            _owner,\\r\\n            tokens,\\r\\n            totalStaked,\\r\\n            \\\"\\\"\\r\\n        );\\r\\n\\r\\n        emit UnstakeAll(_owner, tokens, totalStaked);\\r\\n    }\\r\\n\\r\\n    /** Views */\\r\\n    function stakedBalanceOf(address account)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256[] memory _tokenBalance)\\r\\n    {\\r\\n        uint256[] memory tokenBalance = new uint256[](3);\\r\\n\\r\\n        unchecked {\\r\\n            for (uint32 i = 1; i < 4; i++) {\\r\\n                uint256 stakedCount = vault[i][account];\\r\\n                if (stakedCount > 0) {\\r\\n                    tokenBalance[i - 1] += stakedCount;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return tokenBalance;\\r\\n    }\\r\\n\\r\\n    function unstakedBalanceOf(address account)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256[] memory _tokenBalance)\\r\\n    {\\r\\n        // This consumes ~4k gas less than batchBalanceOf with address array\\r\\n        uint256[] memory totalTokenBalance = new uint256[](3);\\r\\n        totalTokenBalance[0] = alphaGang.balanceOf(account, 1);\\r\\n        totalTokenBalance[1] = alphaGang.balanceOf(account, 2);\\r\\n        totalTokenBalance[2] = alphaGang.balanceOf(account, 3);\\r\\n\\r\\n        return totalTokenBalance;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Contract addresses referencing functions in case we make a mistake in constructor setting\\r\\n     */\\r\\n    function setAlphaGang(address _alphaGang) external onlyOwner {\\r\\n        alphaGang = IAlphaGang(_alphaGang);\\r\\n    }\\r\\n\\r\\n    function setGangToken(address _gangToken) external onlyOwner {\\r\\n        gangToken = IGangToken(_gangToken);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * FE Call fns\\r\\n     */\\r\\n    function claim() external {\\r\\n        _claim(msg.sender);\\r\\n    }\\r\\n\\r\\n    function claimSoft() external {\\r\\n        _claimSoft(msg.sender);\\r\\n    }\\r\\n\\r\\n    function claimForAddress(address account, bool hardStake) public {\\r\\n        if (hardStake) {\\r\\n            _claim(account);\\r\\n        } else {\\r\\n            _claimSoft(account);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function stakeAll() external {\\r\\n        _claim(msg.sender);\\r\\n        _claimSoft(msg.sender);\\r\\n        _stakeAll();\\r\\n    }\\r\\n\\r\\n    function unstakeAll() external {\\r\\n        _claim(msg.sender);\\r\\n        _claimSoft(msg.sender);\\r\\n        _unstakeAll();\\r\\n    }\\r\\n\\r\\n    function _claim(address account) internal {\\r\\n        uint256 stakedAt = lastClaim[account] >= START\\r\\n            ? lastClaim[account]\\r\\n            : START;\\r\\n\\r\\n        uint256 tokenCount = 0;\\r\\n\\r\\n        // bonus of 6.25% is applied for holding all 3 assets(can only be applied once)\\r\\n        uint256 triBonusCount = 0;\\r\\n\\r\\n        // 300 per week for hard, 75 for soft staked\\r\\n        uint256 stakeRate = 496031746031746;\\r\\n\\r\\n        uint256[] memory stakedCount = stakedBalanceOf(account);\\r\\n\\r\\n        unchecked {\\r\\n            for (uint32 i; i < 3; i++) {\\r\\n                if (stakedCount[i] > 0) {\\r\\n                    tokenCount += stakedCount[i];\\r\\n                    triBonusCount++;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (tokenCount > 0) {\\r\\n            // 35%, 52.5%, 61.25% | Order: 50, Mac, Riri\\r\\n            uint256 bonusBase = 350_000;\\r\\n            uint256 bonus = 1_000_000; // multiplier of 1\\r\\n\\r\\n            unchecked {\\r\\n                // calculate total bonus to be applied, start adding bonus for more hodls\\r\\n                for (uint32 j = 1; j < tokenCount; j++) {\\r\\n                    bonus += bonusBase;\\r\\n                    bonusBase /= 2;\\r\\n                }\\r\\n\\r\\n                // triBonus for holding all 3 OGs\\r\\n                if (triBonusCount == 3) {\\r\\n                    bonus += 87_500;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            uint256 timestamp = block.timestamp;\\r\\n\\r\\n            // by default we will have 10*18 decimal points for $GANG, take away factor of 1000 we added to the bonus to get 10**15\\r\\n            uint256 earned = ((timestamp - stakedAt) * bonus * stakeRate) /\\r\\n                1_000_000;\\r\\n\\r\\n            lastClaim[account] = timestamp;\\r\\n\\r\\n            gangToken.mint(account, earned);\\r\\n\\r\\n            emit Claim(account, earned, tokenCount, bonus);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _claimSoft(address account) internal {\\r\\n        uint256 stakedAt = lastSoftClaim[account] >= START\\r\\n            ? lastSoftClaim[account]\\r\\n            : START;\\r\\n\\r\\n        uint256 tokenCount = 0;\\r\\n\\r\\n        uint256 stakeRate = 124007936507936;\\r\\n\\r\\n        uint256[] memory stakedCount = unstakedBalanceOf(account);\\r\\n\\r\\n        unchecked {\\r\\n            for (uint32 i; i < 3; i++) {\\r\\n                if (stakedCount[i] > 0) {\\r\\n                    tokenCount += stakedCount[i];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (tokenCount > 0) {\\r\\n            uint256 timestamp = block.timestamp;\\r\\n\\r\\n            uint256 earned = ((timestamp - stakedAt) * stakeRate);\\r\\n\\r\\n            lastSoftClaim[account] = timestamp;\\r\\n\\r\\n            gangToken.mint(account, earned);\\r\\n\\r\\n            emit Claim(account, earned, tokenCount, block.timestamp);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getSoftPendingRewards(address account)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 rewards)\\r\\n    {\\r\\n        uint256 stakedAt = lastSoftClaim[account] >= START\\r\\n            ? lastSoftClaim[account]\\r\\n            : START;\\r\\n\\r\\n        uint256 tokenCount = 0;\\r\\n\\r\\n        uint256 stakeRate = 124007936507936;\\r\\n\\r\\n        uint256[] memory stakedCount = unstakedBalanceOf(account);\\r\\n\\r\\n        unchecked {\\r\\n            for (uint32 i; i < 3; i++) {\\r\\n                if (stakedCount[i] > 0) {\\r\\n                    tokenCount += stakedCount[i];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (tokenCount == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        uint256 timestamp = block.timestamp;\\r\\n\\r\\n        uint256 earned = ((timestamp - stakedAt) * stakeRate);\\r\\n        return earned;\\r\\n    }\\r\\n\\r\\n    function getPendingRewards(address account)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 rewards)\\r\\n    {\\r\\n        uint256 stakedAt = lastClaim[account] >= START\\r\\n            ? lastClaim[account]\\r\\n            : START;\\r\\n\\r\\n        uint256 tokenCount = 0;\\r\\n\\r\\n        // bonus of 6.25% is applied for holding all 3 assets(can only be applied once)\\r\\n        uint256 triBonusCount = 0;\\r\\n\\r\\n        uint256 stakeRate = 496031746031746;\\r\\n\\r\\n        uint256[] memory stakedCount = stakedBalanceOf(account);\\r\\n\\r\\n        unchecked {\\r\\n            for (uint32 i; i < 3; i++) {\\r\\n                if (stakedCount[i] > 0) {\\r\\n                    tokenCount += stakedCount[i];\\r\\n                    triBonusCount++;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (tokenCount == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        // 35%, 52.5%, 61.25% | Order: 50, Mac, Riri\\r\\n        uint256 bonusBase = 350_000;\\r\\n        uint256 bonus = 1_000_000; // multiplier of 1\\r\\n\\r\\n        unchecked {\\r\\n            // calculate total bonus to be applied, start adding bonus for more hodls\\r\\n            for (uint32 j = 1; j < tokenCount; j++) {\\r\\n                bonus += bonusBase;\\r\\n                bonusBase /= 2;\\r\\n            }\\r\\n\\r\\n            // triBonus for holding all 3 OGs\\r\\n            if (triBonusCount == 3) {\\r\\n                bonus += 87_500;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 timestamp = block.timestamp;\\r\\n\\r\\n        // by default we will have 10*18 decimal points for $GANG, take away factor of 1000 we added to the bonus to get 10**15\\r\\n        uint256 earned = ((timestamp - stakedAt) * bonus * stakeRate) /\\r\\n            1_000_000;\\r\\n\\r\\n        return earned;\\r\\n    }\\r\\n\\r\\n    function setStakeRate(uint256 _newRate, bool isOGRate) external onlyOwner {\\r\\n        if (isOGRate) {\\r\\n            ogStakeRate = _newRate;\\r\\n        } else {\\r\\n            softStakeRate = _newRate;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\\n *\\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\\n * stuck.\\n *\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IAlphaGang\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"contract IGangToken\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"counts\",\"type\":\"uint256[]\"}],\"name\":\"StakeAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"counts\",\"type\":\"uint256[]\"}],\"name\":\"UnstakeAll\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"START\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hardStake\",\"type\":\"bool\"}],\"name\":\"claimForAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimSoft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getSoftPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ogStakeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_alphaGang\",\"type\":\"address\"}],\"name\":\"setAlphaGang\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gangToken\",\"type\":\"address\"}],\"name\":\"setGangToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOGRate\",\"type\":\"bool\"}],\"name\":\"setStakeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"softStakeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenCount\",\"type\":\"uint256\"}],\"name\":\"stakeSingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"stakedBalanceOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenBalance\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenCount\",\"type\":\"uint256\"}],\"name\":\"unstakeSingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unstakedBalanceOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenBalance\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AGStake", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000595a70409711f20523bd99b83d088cea9d3f92e10000000000000000000000003321551494954f2bd682d2614495e365e9dffb2f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}