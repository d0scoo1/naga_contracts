{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/external/Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./actions/nTokenAction.sol\\\";\\r\\nimport \\\"./actions/nTokenMintAction.sol\\\";\\r\\nimport \\\"./actions/nTokenRedeemAction.sol\\\";\\r\\nimport \\\"../global/StorageLayoutV1.sol\\\";\\r\\nimport \\\"../global/Types.sol\\\";\\r\\nimport \\\"interfaces/notional/NotionalProxy.sol\\\";\\r\\nimport \\\"interfaces/notional/nERC1155Interface.sol\\\";\\r\\nimport \\\"interfaces/notional/NotionalGovernance.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice Sits behind an upgradeable proxy and routes methods to an appropriate implementation contract. All storage\\r\\n * will sit inside the upgradeable proxy and this router will authorize the call and re-route the calls to implementing\\r\\n * contracts.\\r\\n *\\r\\n * This pattern adds an additional hop between the proxy and the ultimate implementation contract, however, it also\\r\\n * allows for atomic upgrades of the entire system. Individual implementation contracts will be deployed and then a\\r\\n * new Router with the new hardcoded addresses will then be deployed and upgraded into place.\\r\\n */\\r\\ncontract Router is StorageLayoutV1 {\\r\\n    // These contract addresses cannot be changed once set by the constructor\\r\\n    address public immutable GOVERNANCE;\\r\\n    address public immutable VIEWS;\\r\\n    address public immutable INITIALIZE_MARKET;\\r\\n    address public immutable NTOKEN_ACTIONS;\\r\\n    address public immutable NTOKEN_REDEEM;\\r\\n    address public immutable BATCH_ACTION;\\r\\n    address public immutable ACCOUNT_ACTION;\\r\\n    address public immutable ERC1155;\\r\\n    address public immutable LIQUIDATE_CURRENCY;\\r\\n    address public immutable LIQUIDATE_FCASH;\\r\\n    address public immutable cETH;\\r\\n    address private immutable DEPLOYER;\\r\\n\\r\\n    constructor(\\r\\n        address governance_,\\r\\n        address views_,\\r\\n        address initializeMarket_,\\r\\n        address nTokenActions_,\\r\\n        address nTokenRedeem_,\\r\\n        address batchAction_,\\r\\n        address accountAction_,\\r\\n        address erc1155_,\\r\\n        address liquidateCurrency_,\\r\\n        address liquidatefCash_,\\r\\n        address cETH_\\r\\n    ) {\\r\\n        GOVERNANCE = governance_;\\r\\n        VIEWS = views_;\\r\\n        INITIALIZE_MARKET = initializeMarket_;\\r\\n        NTOKEN_ACTIONS = nTokenActions_;\\r\\n        NTOKEN_REDEEM = nTokenRedeem_;\\r\\n        BATCH_ACTION = batchAction_;\\r\\n        ACCOUNT_ACTION = accountAction_;\\r\\n        ERC1155 = erc1155_;\\r\\n        LIQUIDATE_CURRENCY = liquidateCurrency_;\\r\\n        LIQUIDATE_FCASH = liquidatefCash_;\\r\\n        cETH = cETH_;\\r\\n        DEPLOYER = msg.sender;\\r\\n\\r\\n        // This will lock everyone from calling initialize on the implementation contract\\r\\n        hasInitialized = true;\\r\\n    }\\r\\n\\r\\n    function initialize(address owner_, address pauseRouter_, address pauseGuardian_) public {\\r\\n        // Check that only the deployer can initialize\\r\\n        require(msg.sender == DEPLOYER && !hasInitialized);\\r\\n\\r\\n        // Allow list currency to be called by this contract for the purposes of\\r\\n        // initializing ETH as a currency\\r\\n        owner = msg.sender;\\r\\n        // List ETH as currency id == 1, NOTE: return value is ignored here\\r\\n        (bool status, ) =\\r\\n            address(GOVERNANCE).delegatecall(\\r\\n                abi.encodeWithSelector(\\r\\n                    NotionalGovernance.listCurrency.selector,\\r\\n                    TokenStorage(cETH, false, TokenType.cETH, Constants.CETH_DECIMAL_PLACES, 0),\\r\\n                    // No underlying set for cETH\\r\\n                    TokenStorage(address(0), false, TokenType.Ether, Constants.ETH_DECIMAL_PLACES, 0),\\r\\n                    address(0),\\r\\n                    false,\\r\\n                    133, // Initial settings of 133% buffer\\r\\n                    75,  // 75% haircut\\r\\n                    108  // 8% liquidation discount\\r\\n                )\\r\\n            );\\r\\n        require(status);\\r\\n\\r\\n        owner = owner_;\\r\\n        // The pause guardian may downgrade the router to the pauseRouter\\r\\n        pauseRouter = pauseRouter_;\\r\\n        pauseGuardian = pauseGuardian_;\\r\\n\\r\\n        hasInitialized == true;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the implementation contract for the method signature\\r\\n    /// @param sig method signature to call\\r\\n    /// @return implementation address\\r\\n    function getRouterImplementation(bytes4 sig) public view returns (address) {\\r\\n        if (\\r\\n            sig == NotionalProxy.batchBalanceAction.selector ||\\r\\n            sig == NotionalProxy.batchBalanceAndTradeAction.selector ||\\r\\n            sig == NotionalProxy.batchBalanceAndTradeActionWithCallback.selector\\r\\n        ) {\\r\\n            return BATCH_ACTION;\\r\\n        } else if (\\r\\n            sig == nTokenAction.nTokenTotalSupply.selector ||\\r\\n            sig == nTokenAction.nTokenBalanceOf.selector ||\\r\\n            sig == nTokenAction.nTokenTransferAllowance.selector ||\\r\\n            sig == nTokenAction.nTokenTransferApprove.selector ||\\r\\n            sig == nTokenAction.nTokenTransfer.selector ||\\r\\n            sig == nTokenAction.nTokenTransferFrom.selector ||\\r\\n            sig == nTokenAction.nTokenClaimIncentives.selector ||\\r\\n            sig == nTokenAction.nTokenTransferApproveAll.selector ||\\r\\n            sig == nTokenAction.nTokenPresentValueAssetDenominated.selector ||\\r\\n            sig == nTokenAction.nTokenPresentValueUnderlyingDenominated.selector\\r\\n        ) {\\r\\n            return NTOKEN_ACTIONS;\\r\\n        } else if (\\r\\n            sig == NotionalProxy.depositUnderlyingToken.selector ||\\r\\n            sig == NotionalProxy.depositAssetToken.selector ||\\r\\n            sig == NotionalProxy.withdraw.selector ||\\r\\n            sig == NotionalProxy.settleAccount.selector ||\\r\\n            sig == NotionalProxy.enableBitmapCurrency.selector\\r\\n        ) {\\r\\n            return ACCOUNT_ACTION;\\r\\n        } else if (\\r\\n            sig == nTokenRedeemAction.nTokenRedeem.selector ||\\r\\n            sig == nTokenRedeemAction.nTokenRedeemViaBatch.selector\\r\\n        ) {\\r\\n            return NTOKEN_REDEEM;\\r\\n        } else if (\\r\\n            sig == nERC1155Interface.supportsInterface.selector ||\\r\\n            sig == nERC1155Interface.balanceOf.selector ||\\r\\n            sig == nERC1155Interface.balanceOfBatch.selector ||\\r\\n            sig == nERC1155Interface.signedBalanceOf.selector ||\\r\\n            sig == nERC1155Interface.signedBalanceOfBatch.selector ||\\r\\n            sig == nERC1155Interface.safeTransferFrom.selector ||\\r\\n            sig == nERC1155Interface.safeBatchTransferFrom.selector ||\\r\\n            sig == nERC1155Interface.decodeToAssets.selector ||\\r\\n            sig == nERC1155Interface.encodeToId.selector ||\\r\\n            sig == nERC1155Interface.setApprovalForAll.selector ||\\r\\n            sig == nERC1155Interface.isApprovedForAll.selector\\r\\n        ) {\\r\\n            return ERC1155;\\r\\n        } else if (\\r\\n            sig == NotionalProxy.liquidateLocalCurrency.selector ||\\r\\n            sig == NotionalProxy.liquidateCollateralCurrency.selector ||\\r\\n            sig == NotionalProxy.calculateLocalCurrencyLiquidation.selector ||\\r\\n            sig == NotionalProxy.calculateCollateralCurrencyLiquidation.selector\\r\\n        ) {\\r\\n            return LIQUIDATE_CURRENCY;\\r\\n        } else if (\\r\\n            sig == NotionalProxy.liquidatefCashLocal.selector ||\\r\\n            sig == NotionalProxy.liquidatefCashCrossCurrency.selector ||\\r\\n            sig == NotionalProxy.calculatefCashLocalLiquidation.selector ||\\r\\n            sig == NotionalProxy.calculatefCashCrossCurrencyLiquidation.selector\\r\\n        ) {\\r\\n            return LIQUIDATE_FCASH;\\r\\n        } else if (\\r\\n            sig == NotionalProxy.initializeMarkets.selector ||\\r\\n            sig == NotionalProxy.sweepCashIntoMarkets.selector\\r\\n        ) {\\r\\n            return INITIALIZE_MARKET;\\r\\n        } else if (\\r\\n            sig == NotionalGovernance.listCurrency.selector ||\\r\\n            sig == NotionalGovernance.enableCashGroup.selector ||\\r\\n            sig == NotionalGovernance.updateCashGroup.selector ||\\r\\n            sig == NotionalGovernance.updateAssetRate.selector ||\\r\\n            sig == NotionalGovernance.updateETHRate.selector ||\\r\\n            sig == NotionalGovernance.transferOwnership.selector ||\\r\\n            sig == NotionalGovernance.claimOwnership.selector ||\\r\\n            sig == NotionalGovernance.updateIncentiveEmissionRate.selector ||\\r\\n            sig == NotionalGovernance.updateMaxCollateralBalance.selector ||\\r\\n            sig == NotionalGovernance.updateDepositParameters.selector ||\\r\\n            sig == NotionalGovernance.updateInitializationParameters.selector ||\\r\\n            sig == NotionalGovernance.updateTokenCollateralParameters.selector ||\\r\\n            sig == NotionalGovernance.updateGlobalTransferOperator.selector ||\\r\\n            sig == NotionalGovernance.updateAuthorizedCallbackContract.selector ||\\r\\n            sig == NotionalProxy.upgradeTo.selector ||\\r\\n            sig == NotionalProxy.upgradeToAndCall.selector\\r\\n        ) {\\r\\n            return GOVERNANCE;\\r\\n        } else {\\r\\n            // If not found then delegate to views. This will revert if there is no method on\\r\\n            // the view contract\\r\\n            return VIEWS;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Delegates the current call to `implementation`.\\r\\n    /// This function does not return to its internal call site, it will return directly to the external caller.\\r\\n    function _delegate(address implementation) private {\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            // Copy msg.data. We take full control of memory in this inline assembly\\r\\n            // block because it will not return to Solidity code. We overwrite the\\r\\n            // Solidity scratch pad at memory position 0.\\r\\n            calldatacopy(0, 0, calldatasize())\\r\\n\\r\\n            // Call the implementation.\\r\\n            // out and outsize are 0 because we don't know the size yet.\\r\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\r\\n\\r\\n            // Copy the returned data.\\r\\n            returndatacopy(0, 0, returndatasize())\\r\\n\\r\\n            switch result\\r\\n                // delegatecall returns 0 on error.\\r\\n                case 0 {\\r\\n                    revert(0, returndatasize())\\r\\n                }\\r\\n                default {\\r\\n                    return(0, returndatasize())\\r\\n                }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    fallback() external payable {\\r\\n        _delegate(getRouterImplementation(msg.sig));\\r\\n    }\\r\\n\\r\\n    // NOTE: receive() is overridden in \\\"nProxy\\\" to allow for eth transfers to succeed\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/external/actions/nTokenAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./ActionGuards.sol\\\";\\r\\nimport \\\"../../internal/nTokenHandler.sol\\\";\\r\\nimport \\\"../../internal/markets/AssetRate.sol\\\";\\r\\nimport \\\"../../internal/balances/BalanceHandler.sol\\\";\\r\\nimport \\\"../../internal/balances/Incentives.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../global/StorageLayoutV1.sol\\\";\\r\\nimport \\\"../../external/FreeCollateralExternal.sol\\\";\\r\\nimport \\\"interfaces/notional/nTokenERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/SafeCast.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\ncontract nTokenAction is StorageLayoutV1, nTokenERC20, ActionGuards {\\r\\n    using BalanceHandler for BalanceState;\\r\\n    using AssetRate for AssetRateParameters;\\r\\n    using AccountContextHandler for AccountContext;\\r\\n    using nTokenHandler for nTokenPortfolio;\\r\\n    using SafeInt256 for int256;\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /// @notice Total number of tokens in circulation\\r\\n    /// @param nTokenAddress The address of the nToken\\r\\n    /// @return totalSupply number of tokens held\\r\\n    function nTokenTotalSupply(address nTokenAddress)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256 totalSupply)\\r\\n    {\\r\\n        // prettier-ignore\\r\\n        (\\r\\n            totalSupply,\\r\\n            /* integralTotalSupply */,\\r\\n            /* lastSupplyChangeTime */\\r\\n        ) = nTokenHandler.getStoredNTokenSupplyFactors(nTokenAddress);\\r\\n    }\\r\\n\\r\\n    /// @notice Get the number of tokens held by the `account`\\r\\n    /// @param account The address of the account to get the balance of\\r\\n    /// @return The number of tokens held\\r\\n    function nTokenBalanceOf(uint16 currencyId, address account)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        // prettier-ignore\\r\\n        (\\r\\n            /* int cashBalance */,\\r\\n            int256 nTokenBalance,\\r\\n            /* uint lastClaimTime */,\\r\\n            /* uint lastClaimIntegralSupply */\\r\\n        ) = BalanceHandler.getBalanceStorage(account, currencyId);\\r\\n\\r\\n        require(nTokenBalance >= 0); // dev: negative nToken balance\\r\\n        return uint256(nTokenBalance);\\r\\n    }\\r\\n\\r\\n    /// @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\\r\\n    /// @param currencyId Currency id of the nToken account\\r\\n    /// @param tokenHolder The address of the account holding the funds\\r\\n    /// @param spender The address of the account spending the funds\\r\\n    /// @return The number of tokens approved\\r\\n    function nTokenTransferAllowance(\\r\\n        uint16 currencyId,\\r\\n        address tokenHolder,\\r\\n        address spender\\r\\n    ) external view override returns (uint256) {\\r\\n        // The specific allowance overrides the blanket whitelist\\r\\n        uint256 allowance = nTokenAllowance[tokenHolder][spender][currencyId];\\r\\n        if (allowance > 0) {\\r\\n            return allowance;\\r\\n        } else {\\r\\n            return nTokenWhitelist[tokenHolder][spender];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Approve `spender` to transfer up to `amount` from `src`\\r\\n    /// @dev auth:nTokenProxy\\r\\n    /// @param currencyId Currency id of the nToken account\\r\\n    /// @param tokenHolder The address of the account holding the funds\\r\\n    /// @param spender The address of the account which may transfer tokens\\r\\n    /// @param amount The number of tokens that are approved (2^256-1 means infinite)\\r\\n    /// @return Whether or not the approval succeeded\\r\\n    function nTokenTransferApprove(\\r\\n        uint16 currencyId,\\r\\n        address tokenHolder,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) external override returns (bool) {\\r\\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\\r\\n        require(msg.sender == nTokenAddress, \\\"Unauthorized caller\\\");\\r\\n        require(tokenHolder != address(0));\\r\\n\\r\\n        nTokenAllowance[tokenHolder][spender][currencyId] = amount;\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`\\r\\n    /// @dev auth:nTokenProxy\\r\\n    /// @param from The address of the destination account\\r\\n    /// @param to The address of the destination account\\r\\n    /// @param amount The number of tokens to transfer\\r\\n    /// @return Whether or not the transfer succeeded\\r\\n    function nTokenTransfer(\\r\\n        uint16 currencyId,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external override returns (bool) {\\r\\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\\r\\n        require(msg.sender == nTokenAddress, \\\"Unauthorized caller\\\");\\r\\n        require(from != to, \\\"Cannot transfer to self\\\");\\r\\n        requireValidAccount(to);\\r\\n\\r\\n        return _transfer(currencyId, from, to, amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Transfer `amount` tokens from `src` to `dst`\\r\\n    /// @dev auth:nTokenProxy\\r\\n    /// @param currencyId Currency id of the nToken\\r\\n    /// @param spender The address of the original caller\\r\\n    /// @param from The address of the source account\\r\\n    /// @param to The address of the destination account\\r\\n    /// @param amount The number of tokens to transfer\\r\\n    /// @return Whether or not the transfer succeeded\\r\\n    function nTokenTransferFrom(\\r\\n        uint16 currencyId,\\r\\n        address spender,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external override returns (bool) {\\r\\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\\r\\n        require(msg.sender == nTokenAddress, \\\"Unauthorized caller\\\");\\r\\n        require(from != to, \\\"Cannot transfer to self\\\");\\r\\n        requireValidAccount(to);\\r\\n\\r\\n        uint256 allowance = nTokenAllowance[from][spender][currencyId];\\r\\n\\r\\n        if (allowance > 0) {\\r\\n            // This is the specific allowance for the nToken.\\r\\n            require(allowance >= amount, \\\"Insufficient allowance\\\");\\r\\n            // Overflow checked above\\r\\n            nTokenAllowance[from][spender][currencyId] = allowance - amount;\\r\\n        } else {\\r\\n            // This whitelist allowance works across all nTokens\\r\\n            allowance = nTokenWhitelist[from][spender];\\r\\n            require(allowance >= amount, \\\"Insufficient allowance\\\");\\r\\n            // Overflow checked above\\r\\n            nTokenWhitelist[from][spender] = allowance - amount;\\r\\n        }\\r\\n\\r\\n        return _transfer(currencyId, from, to, amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Will approve all nToken transfers to the specific sender. This is used for simplifying UX, a user can approve\\r\\n    /// all token transfers to an external exchange or protocol in a single txn. This must be called directly\\r\\n    /// on the Notional contract, not available via the ERC20 proxy.\\r\\n    /// @dev emit:Approval\\r\\n    /// @dev auth:msg.sender\\r\\n    /// @param spender The address of the account which may transfer tokens\\r\\n    /// @param amount The number of tokens that are approved\\r\\n    /// @return Whether or not the approval succeeded\\r\\n    function nTokenTransferApproveAll(address spender, uint256 amount)\\r\\n        external\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        nTokenWhitelist[msg.sender][spender] = amount;\\r\\n        emit Approval(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice Claims incentives accrued on all nToken balances and transfers them to the msg.sender\\r\\n    /// @dev auth:msg.sender\\r\\n    /// @return Total amount of incentives claimed\\r\\n    function nTokenClaimIncentives() external override returns (uint256) {\\r\\n        address account = msg.sender;\\r\\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\\r\\n        uint256 totalIncentivesClaimed = 0;\\r\\n        BalanceState memory balanceState;\\r\\n\\r\\n        if (accountContext.isBitmapEnabled()) {\\r\\n            balanceState.loadBalanceState(account, accountContext.bitmapCurrencyId, accountContext);\\r\\n            if (balanceState.storedNTokenBalance > 0) {\\r\\n                // balance state is updated inside claim incentives manual\\r\\n                totalIncentivesClaimed = balanceState.claimIncentivesManual(account);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        bytes18 currencies = accountContext.activeCurrencies;\\r\\n        while (currencies != 0) {\\r\\n            uint16 currencyId = uint16(bytes2(currencies) & Constants.UNMASK_FLAGS);\\r\\n\\r\\n            balanceState.loadBalanceState(account, currencyId, accountContext);\\r\\n            if (balanceState.storedNTokenBalance > 0) {\\r\\n                // balance state is updated inside claim incentives manual\\r\\n                totalIncentivesClaimed = totalIncentivesClaimed\\r\\n                    .add(balanceState.claimIncentivesManual(account));\\r\\n            }\\r\\n\\r\\n            currencies = currencies << 16;\\r\\n        }\\r\\n\\r\\n        // NOTE: no need to set account context after claiming incentives. No currencies\\r\\n        // or fCash assets have been added or changed.\\r\\n        return totalIncentivesClaimed;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the present value of the nToken's assets denominated in asset tokens\\r\\n    function nTokenPresentValueAssetDenominated(uint16 currencyId)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (int256)\\r\\n    {\\r\\n        // prettier-ignore\\r\\n        (\\r\\n            int256 totalAssetPV,\\r\\n            /* portfolio */\\r\\n        ) = _getNTokenPV(currencyId);\\r\\n\\r\\n        return totalAssetPV;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the present value of the nToken's assets denominated in underlying\\r\\n    function nTokenPresentValueUnderlyingDenominated(uint16 currencyId)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (int256)\\r\\n    {\\r\\n        (int256 totalAssetPV, nTokenPortfolio memory nToken) = _getNTokenPV(currencyId);\\r\\n\\r\\n        return nToken.cashGroup.assetRate.convertToUnderlying(totalAssetPV);\\r\\n    }\\r\\n\\r\\n    function _getNTokenPV(uint16 currencyId)\\r\\n        private\\r\\n        view\\r\\n        returns (int256, nTokenPortfolio memory)\\r\\n    {\\r\\n        uint256 blockTime = block.timestamp;\\r\\n        nTokenPortfolio memory nToken;\\r\\n        nToken.loadNTokenPortfolioView(currencyId);\\r\\n\\r\\n        int256 totalAssetPV = nToken.getNTokenAssetPV(blockTime);\\r\\n\\r\\n        return (totalAssetPV, nToken);\\r\\n    }\\r\\n\\r\\n    /// @notice Transferring tokens will also claim incentives at the same time\\r\\n    function _transfer(\\r\\n        uint16 currencyId,\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal returns (bool) {\\r\\n        // This prevents amountInt from being negative\\r\\n        int256 amountInt = SafeCast.toInt256(amount);\\r\\n\\r\\n        AccountContext memory senderContext = AccountContextHandler.getAccountContext(sender);\\r\\n        // If sender has debt then we will check free collateral which will revert if we have not\\r\\n        // settled assets first. To prevent this we settle sender context if required.\\r\\n        if (senderContext.mustSettleAssets()) {\\r\\n            senderContext = SettleAssetsExternal.settleAccount(sender, senderContext);\\r\\n        }\\r\\n\\r\\n        BalanceState memory senderBalance;\\r\\n        senderBalance.loadBalanceState(sender, currencyId, senderContext);\\r\\n        senderBalance.netNTokenTransfer = amountInt.neg();\\r\\n        senderBalance.finalize(sender, senderContext, false);\\r\\n        senderContext.setAccountContext(sender);\\r\\n\\r\\n        AccountContext memory recipientContext = AccountContextHandler.getAccountContext(recipient);\\r\\n        BalanceState memory recipientBalance;\\r\\n        recipientBalance.loadBalanceState(recipient, currencyId, recipientContext);\\r\\n        recipientBalance.netNTokenTransfer = amountInt;\\r\\n        recipientBalance.finalize(recipient, recipientContext, false);\\r\\n        recipientContext.setAccountContext(recipient);\\r\\n\\r\\n        // nTokens are used as collateral so we have to check the free collateral when we transfer. Only the\\r\\n        // sender needs a free collateral check, the receiver's net free collateral position will only increase\\r\\n        if (senderContext.hasDebt != 0x00) {\\r\\n            FreeCollateralExternal.checkFreeCollateralAndRevert(sender);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/external/actions/nTokenMintAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"../../internal/nTokenHandler.sol\\\";\\r\\nimport \\\"../../internal/markets/Market.sol\\\";\\r\\nimport \\\"../../internal/markets/CashGroup.sol\\\";\\r\\nimport \\\"../../internal/markets/AssetRate.sol\\\";\\r\\nimport \\\"../../internal/balances/BalanceHandler.sol\\\";\\r\\nimport \\\"../../internal/portfolio/PortfolioHandler.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary nTokenMintAction {\\r\\n    using SafeInt256 for int256;\\r\\n    using BalanceHandler for BalanceState;\\r\\n    using CashGroup for CashGroupParameters;\\r\\n    using Market for MarketParameters;\\r\\n    using nTokenHandler for nTokenPortfolio;\\r\\n    using PortfolioHandler for PortfolioState;\\r\\n    using AssetRate for AssetRateParameters;\\r\\n    using SafeMath for uint256;\\r\\n    using nTokenHandler for nTokenPortfolio;\\r\\n\\r\\n    /// @notice Converts the given amount of cash to nTokens in the same currency.\\r\\n    /// @param currencyId the currency associated the nToken\\r\\n    /// @param amountToDepositInternal the amount of asset tokens to deposit denominated in internal decimals\\r\\n    /// @return nTokens minted by this action\\r\\n    function nTokenMint(uint16 currencyId, int256 amountToDepositInternal)\\r\\n        external\\r\\n        returns (int256)\\r\\n    {\\r\\n        uint256 blockTime = block.timestamp;\\r\\n        nTokenPortfolio memory nToken;\\r\\n        nToken.loadNTokenPortfolioStateful(currencyId);\\r\\n\\r\\n        int256 tokensToMint = calculateTokensToMint(nToken, amountToDepositInternal, blockTime);\\r\\n        require(tokensToMint >= 0, \\\"Invalid token amount\\\");\\r\\n\\r\\n        if (nToken.portfolioState.storedAssets.length == 0) {\\r\\n            // If the token does not have any assets, then the markets must be initialized first.\\r\\n            nToken.cashBalance = nToken.cashBalance.add(amountToDepositInternal);\\r\\n            BalanceHandler.setBalanceStorageForNToken(\\r\\n                nToken.tokenAddress,\\r\\n                currencyId,\\r\\n                nToken.cashBalance\\r\\n            );\\r\\n        } else {\\r\\n            _depositIntoPortfolio(nToken, amountToDepositInternal, blockTime);\\r\\n        }\\r\\n\\r\\n        // NOTE: token supply does not change here, it will change after incentives have been claimed\\r\\n        // during BalanceHandler.finalize\\r\\n        return tokensToMint;\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates the tokens to mint to the account as a ratio of the nToken\\r\\n    /// present value denominated in asset cash terms.\\r\\n    /// @return the amount of tokens to mint, the ifCash bitmap\\r\\n    function calculateTokensToMint(\\r\\n        nTokenPortfolio memory nToken,\\r\\n        int256 amountToDepositInternal,\\r\\n        uint256 blockTime\\r\\n    ) internal view returns (int256) {\\r\\n        require(amountToDepositInternal >= 0); // dev: deposit amount negative\\r\\n        if (amountToDepositInternal == 0) return 0;\\r\\n\\r\\n        if (nToken.lastInitializedTime != 0) {\\r\\n            // For the sake of simplicity, nTokens cannot be minted if they have assets\\r\\n            // that need to be settled. This is only done during market initialization.\\r\\n            uint256 nextSettleTime = nToken.getNextSettleTime();\\r\\n            // If next settle time <= blockTime then the token can be settled\\r\\n            require(nextSettleTime > blockTime, \\\"Requires settlement\\\");\\r\\n        }\\r\\n\\r\\n        int256 assetCashPV = nToken.getNTokenAssetPV(blockTime);\\r\\n        // Defensive check to ensure PV remains positive\\r\\n        require(assetCashPV >= 0);\\r\\n\\r\\n        // Allow for the first deposit\\r\\n        if (nToken.totalSupply == 0) {\\r\\n            return amountToDepositInternal;\\r\\n        } else {\\r\\n            // assetCashPVPost = assetCashPV + amountToDeposit\\r\\n            // (tokenSupply + tokensToMint) / tokenSupply == (assetCashPV + amountToDeposit) / assetCashPV\\r\\n            // (tokenSupply + tokensToMint) == (assetCashPV + amountToDeposit) * tokenSupply / assetCashPV\\r\\n            // (tokenSupply + tokensToMint) == tokenSupply + (amountToDeposit * tokenSupply) / assetCashPV\\r\\n            // tokensToMint == (amountToDeposit * tokenSupply) / assetCashPV\\r\\n            return amountToDepositInternal.mul(nToken.totalSupply).div(assetCashPV);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Portions out assetCashDeposit into amounts to deposit into individual markets. When\\r\\n    /// entering this method we know that assetCashDeposit is positive and the nToken has been\\r\\n    /// initialized to have liquidity tokens.\\r\\n    function _depositIntoPortfolio(\\r\\n        nTokenPortfolio memory nToken,\\r\\n        int256 assetCashDeposit,\\r\\n        uint256 blockTime\\r\\n    ) private {\\r\\n        (int256[] memory depositShares, int256[] memory leverageThresholds) =\\r\\n            nTokenHandler.getDepositParameters(\\r\\n                nToken.cashGroup.currencyId,\\r\\n                nToken.cashGroup.maxMarketIndex\\r\\n            );\\r\\n\\r\\n        // Loop backwards from the last market to the first market, the reasoning is a little complicated:\\r\\n        // If we have to deleverage the markets (i.e. lend instead of provide liquidity) it's quite gas inefficient\\r\\n        // to calculate the cash amount to lend. We do know that longer term maturities will have more\\r\\n        // slippage and therefore the residual from the perMarketDeposit will be lower as the maturities get\\r\\n        // closer to the current block time. Any residual cash from lending will be rolled into shorter\\r\\n        // markets as this loop progresses.\\r\\n        int256 residualCash;\\r\\n        MarketParameters memory market;\\r\\n        for (uint256 marketIndex = nToken.cashGroup.maxMarketIndex; marketIndex > 0; marketIndex--) {\\r\\n            int256 fCashAmount;\\r\\n            // Loads values into the market memory slot\\r\\n            nToken.cashGroup.loadMarket(\\r\\n                market,\\r\\n                marketIndex,\\r\\n                true, // Needs liquidity to true\\r\\n                blockTime\\r\\n            );\\r\\n            // If market has not been initialized, continue. This can occur when cash groups extend maxMarketIndex\\r\\n            // before initializing\\r\\n            if (market.totalLiquidity == 0) continue;\\r\\n\\r\\n            // Checked that assetCashDeposit must be positive before entering\\r\\n            int256 perMarketDeposit =\\r\\n                assetCashDeposit\\r\\n                    .mul(depositShares[marketIndex - 1])\\r\\n                    .div(Constants.DEPOSIT_PERCENT_BASIS)\\r\\n                    .add(residualCash);\\r\\n\\r\\n            (fCashAmount, residualCash) = _lendOrAddLiquidity(\\r\\n                nToken,\\r\\n                market,\\r\\n                perMarketDeposit,\\r\\n                leverageThresholds[marketIndex - 1],\\r\\n                marketIndex,\\r\\n                blockTime\\r\\n            );\\r\\n\\r\\n            if (fCashAmount != 0) {\\r\\n                BitmapAssetsHandler.addifCashAsset(\\r\\n                    nToken.tokenAddress,\\r\\n                    nToken.cashGroup.currencyId,\\r\\n                    market.maturity,\\r\\n                    nToken.lastInitializedTime,\\r\\n                    fCashAmount\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // nToken is allowed to store assets directly without updating account context.\\r\\n        nToken.portfolioState.storeAssets(nToken.tokenAddress);\\r\\n\\r\\n        // Defensive check to ensure that we do not somehow accrue negative residual cash.\\r\\n        require(residualCash >= 0, \\\"Negative residual cash\\\");\\r\\n        // This will occur if the three month market is over levered and we cannot lend into it\\r\\n        if (residualCash > 0) {\\r\\n            // Any remaining residual cash will be put into the nToken balance and added as liquidity on the\\r\\n            // next market initialization\\r\\n            nToken.cashBalance = nToken.cashBalance.add(residualCash);\\r\\n            BalanceHandler.setBalanceStorageForNToken(\\r\\n                nToken.tokenAddress,\\r\\n                nToken.cashGroup.currencyId,\\r\\n                nToken.cashBalance\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice For a given amount of cash to deposit, decides how much to lend or provide\\r\\n    /// given the market conditions.\\r\\n    function _lendOrAddLiquidity(\\r\\n        nTokenPortfolio memory nToken,\\r\\n        MarketParameters memory market,\\r\\n        int256 perMarketDeposit,\\r\\n        int256 leverageThreshold,\\r\\n        uint256 marketIndex,\\r\\n        uint256 blockTime\\r\\n    ) private returns (int256 fCashAmount, int256 residualCash) {\\r\\n        // We start off with the entire per market deposit as residuals\\r\\n        residualCash = perMarketDeposit;\\r\\n\\r\\n        // If the market is over leveraged then we will lend to it instead of providing liquidity\\r\\n        if (_isMarketOverLeveraged(nToken.cashGroup, market, leverageThreshold)) {\\r\\n            (residualCash, fCashAmount) = _deleverageMarket(\\r\\n                nToken.cashGroup,\\r\\n                market,\\r\\n                perMarketDeposit,\\r\\n                blockTime,\\r\\n                marketIndex\\r\\n            );\\r\\n\\r\\n            // Recalculate this after lending into the market, if it is still over leveraged then\\r\\n            // we will not add liquidity and just exit.\\r\\n            if (_isMarketOverLeveraged(nToken.cashGroup, market, leverageThreshold)) {\\r\\n                // Returns the residual cash amount\\r\\n                return (fCashAmount, residualCash);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Add liquidity to the market only if we have successfully delevered.\\r\\n        // (marketIndex - 1) is the index of the nToken portfolio array where the asset is stored\\r\\n        // If deleveraged, residualCash is what remains\\r\\n        // If not deleveraged, residual cash is per market deposit\\r\\n        fCashAmount = fCashAmount.add(\\r\\n            _addLiquidityToMarket(nToken, market, marketIndex - 1, residualCash)\\r\\n        );\\r\\n        // No residual cash if we're adding liquidity\\r\\n        return (fCashAmount, 0);\\r\\n    }\\r\\n\\r\\n    /// @notice Markets are over levered when their proportion is greater than a governance set\\r\\n    /// threshold. At this point, providing liquidity will incur too much negative fCash on the nToken\\r\\n    /// account for the given amount of cash deposited, putting the nToken account at risk of liquidation.\\r\\n    /// If the market is over leveraged, we call `deleverageMarket` to lend to the market instead.\\r\\n    function _isMarketOverLeveraged(\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        MarketParameters memory market,\\r\\n        int256 leverageThreshold\\r\\n    ) private pure returns (bool) {\\r\\n        int256 totalCashUnderlying = cashGroup.assetRate.convertToUnderlying(market.totalAssetCash);\\r\\n        // Comparison we want to do:\\r\\n        // (totalfCash) / (totalfCash + totalCashUnderlying) > leverageThreshold\\r\\n        // However, the division will introduce rounding errors so we change this to:\\r\\n        // totalfCash * RATE_PRECISION > leverageThreshold * (totalfCash + totalCashUnderlying)\\r\\n        // Leverage threshold is denominated in rate precision.\\r\\n        return (\\r\\n            market.totalfCash.mul(Constants.RATE_PRECISION) >\\r\\n            leverageThreshold.mul(market.totalfCash.add(totalCashUnderlying))\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _addLiquidityToMarket(\\r\\n        nTokenPortfolio memory nToken,\\r\\n        MarketParameters memory market,\\r\\n        uint256 index,\\r\\n        int256 perMarketDeposit\\r\\n    ) private returns (int256) {\\r\\n        // Add liquidity to the market\\r\\n        PortfolioAsset memory asset = nToken.portfolioState.storedAssets[index];\\r\\n        // We expect that all the liquidity tokens are in the portfolio in order.\\r\\n        require(\\r\\n            asset.maturity == market.maturity &&\\r\\n            // Ensures that the asset type references the proper liquidity token\\r\\n            asset.assetType == index + Constants.MIN_LIQUIDITY_TOKEN_INDEX &&\\r\\n            // Ensures that the storage state will not be overwritten\\r\\n            asset.storageState == AssetStorageState.NoChange,\\r\\n            \\\"PT: invalid liquidity token\\\"\\r\\n        );\\r\\n\\r\\n        // This will update the market state as well, fCashAmount returned here is negative\\r\\n        (int256 liquidityTokens, int256 fCashAmount) = market.addLiquidity(perMarketDeposit);\\r\\n        asset.notional = asset.notional.add(liquidityTokens);\\r\\n        asset.storageState = AssetStorageState.Update;\\r\\n\\r\\n        return fCashAmount;\\r\\n    }\\r\\n\\r\\n    /// @notice Lends into the market to reduce the leverage that the nToken will add liquidity at. May fail due\\r\\n    /// to slippage or result in some amount of residual cash.\\r\\n    function _deleverageMarket(\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        MarketParameters memory market,\\r\\n        int256 perMarketDeposit,\\r\\n        uint256 blockTime,\\r\\n        uint256 marketIndex\\r\\n    ) private returns (int256, int256) {\\r\\n        uint256 timeToMaturity = market.maturity.sub(blockTime);\\r\\n\\r\\n        // Shift the last implied rate by some buffer and calculate the exchange rate to fCash. Hope that this\\r\\n        // is sufficient to cover all potential slippage. We don't use the `getfCashGivenCashAmount` method here\\r\\n        // because it is very gas inefficient.\\r\\n        int256 assumedExchangeRate;\\r\\n        if (market.lastImpliedRate < Constants.DELEVERAGE_BUFFER) {\\r\\n            // Floor the exchange rate at zero interest rate\\r\\n            assumedExchangeRate = Constants.RATE_PRECISION;\\r\\n        } else {\\r\\n            assumedExchangeRate = Market.getExchangeRateFromImpliedRate(\\r\\n                market.lastImpliedRate.sub(Constants.DELEVERAGE_BUFFER),\\r\\n                timeToMaturity\\r\\n            );\\r\\n        }\\r\\n\\r\\n        int256 fCashAmount;\\r\\n        {\\r\\n            int256 perMarketDepositUnderlying =\\r\\n                cashGroup.assetRate.convertToUnderlying(perMarketDeposit);\\r\\n            // NOTE: cash * exchangeRate = fCash\\r\\n            fCashAmount = perMarketDepositUnderlying.mulInRatePrecision(assumedExchangeRate);\\r\\n        }\\r\\n        int256 netAssetCash = market.executeTrade(cashGroup, fCashAmount, timeToMaturity, marketIndex);\\r\\n\\r\\n        // This means that the trade failed\\r\\n        if (netAssetCash == 0) {\\r\\n            return (perMarketDeposit, 0);\\r\\n        } else {\\r\\n            // Ensure that net the per market deposit figure does not drop below zero, this should not be possible\\r\\n            // given how we've calculated the exchange rate but extra caution here\\r\\n            int256 residual = perMarketDeposit.add(netAssetCash);\\r\\n            require(residual >= 0); // dev: insufficient cash\\r\\n            return (residual, fCashAmount);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/external/actions/nTokenRedeemAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../internal/markets/Market.sol\\\";\\r\\nimport \\\"../../internal/nTokenHandler.sol\\\";\\r\\nimport \\\"../../internal/portfolio/PortfolioHandler.sol\\\";\\r\\nimport \\\"../../internal/portfolio/TransferAssets.sol\\\";\\r\\nimport \\\"../../internal/balances/BalanceHandler.sol\\\";\\r\\nimport \\\"../../external/FreeCollateralExternal.sol\\\";\\r\\nimport \\\"../../external/SettleAssetsExternal.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"./ActionGuards.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\ncontract nTokenRedeemAction is ActionGuards {\\r\\n    using SafeInt256 for int256;\\r\\n    using SafeMath for uint256;\\r\\n    using BalanceHandler for BalanceState;\\r\\n    using Market for MarketParameters;\\r\\n    using CashGroup for CashGroupParameters;\\r\\n    using PortfolioHandler for PortfolioState;\\r\\n    using AccountContextHandler for AccountContext;\\r\\n    using nTokenHandler for nTokenPortfolio;\\r\\n\\r\\n    event nTokenSupplyChange(address indexed account, uint16 indexed currencyId, int256 tokenSupplyChange);\\r\\n\\r\\n    /// @notice When redeeming nTokens via the batch they must all be sold to cash and this\\r\\n    /// method will return the amount of asset cash sold. This method can only be invoked via delegatecall.\\r\\n    /// @param currencyId the currency associated the nToken\\r\\n    /// @param tokensToRedeem the amount of nTokens to convert to cash\\r\\n    /// @dev auth:only internal\\r\\n    /// @return amount of asset cash to return to the account, denominated in internal token decimals\\r\\n    function nTokenRedeemViaBatch(uint16 currencyId, int256 tokensToRedeem)\\r\\n        external\\r\\n        returns (int256)\\r\\n    {\\r\\n        // Only self call allowed\\r\\n        require(msg.sender == address(this), \\\"Unauthorized caller\\\");\\r\\n        uint256 blockTime = block.timestamp;\\r\\n        // prettier-ignore\\r\\n        (\\r\\n            int256 totalAssetCash,\\r\\n            bool hasResidual,\\r\\n            /* PortfolioAssets[] memory newfCashAssets */\\r\\n        ) = _redeem(currencyId, tokensToRedeem, true, blockTime);\\r\\n\\r\\n        require(!hasResidual, \\\"Cannot redeem via batch, residual\\\");\\r\\n        return totalAssetCash;\\r\\n    }\\r\\n\\r\\n    /// @notice Allows accounts to redeem nTokens into constituent assets and then absorb the assets\\r\\n    /// into their portfolio. Due to the complexity here, it is not allowed to be called during a batch trading\\r\\n    /// operation and must be done separately.\\r\\n    /// @param redeemer the address that holds the nTokens to redeem\\r\\n    /// @param currencyId the currency associated the nToken\\r\\n    /// @param tokensToRedeem_ the amount of nTokens to convert to cash\\r\\n    /// @param sellTokenAssets attempt to sell residual fCash and convert to cash, if unsuccessful then\\r\\n    /// residual fCash assets will be placed into the portfolio\\r\\n    /// @dev auth:msg.sender auth:ERC1155\\r\\n    /// @return total amount of asset cash redeemed\\r\\n    function nTokenRedeem(\\r\\n        address redeemer,\\r\\n        uint16 currencyId,\\r\\n        uint96 tokensToRedeem_,\\r\\n        bool sellTokenAssets\\r\\n    ) external nonReentrant returns (int256) {\\r\\n        // ERC1155 can call this method during a post transfer event\\r\\n        require(msg.sender == redeemer || msg.sender == address(this), \\\"Unauthorized caller\\\");\\r\\n\\r\\n        uint256 blockTime = block.timestamp;\\r\\n        int256 tokensToRedeem = int256(tokensToRedeem_);\\r\\n\\r\\n        AccountContext memory context = AccountContextHandler.getAccountContext(redeemer);\\r\\n        if (context.mustSettleAssets()) {\\r\\n            context = SettleAssetsExternal.settleAccount(redeemer, context);\\r\\n        }\\r\\n\\r\\n        BalanceState memory balance;\\r\\n        balance.loadBalanceState(redeemer, currencyId, context);\\r\\n\\r\\n        require(balance.storedNTokenBalance >= tokensToRedeem, \\\"Insufficient tokens\\\");\\r\\n        balance.netNTokenSupplyChange = tokensToRedeem.neg();\\r\\n\\r\\n        (int256 totalAssetCash, bool hasResidual, PortfolioAsset[] memory assets) =\\r\\n            _redeem(currencyId, tokensToRedeem, sellTokenAssets, blockTime);\\r\\n\\r\\n        // Set balances before transferring assets\\r\\n        balance.netCashChange = totalAssetCash;\\r\\n        balance.finalize(redeemer, context, false);\\r\\n\\r\\n        if (hasResidual) {\\r\\n            // This method will store assets and update the account context in memory\\r\\n            context = TransferAssets.placeAssetsInAccount(redeemer, context, assets);\\r\\n        }\\r\\n\\r\\n        context.setAccountContext(redeemer);\\r\\n        if (context.hasDebt != 0x00) {\\r\\n            FreeCollateralExternal.checkFreeCollateralAndRevert(redeemer);\\r\\n        }\\r\\n\\r\\n        emit nTokenSupplyChange(redeemer, currencyId, balance.netNTokenSupplyChange);\\r\\n        return totalAssetCash;\\r\\n    }\\r\\n\\r\\n    /// @notice Redeems nTokens for asset cash and fCash\\r\\n    /// @return assetCash: positive amount of asset cash to the account\\r\\n    /// @return hasResidual: true if there are fCash residuals left\\r\\n    /// @return assets: an array of fCash asset residuals to place into the account\\r\\n    function _redeem(\\r\\n        uint16 currencyId,\\r\\n        int256 tokensToRedeem,\\r\\n        bool sellTokenAssets,\\r\\n        uint256 blockTime\\r\\n    )\\r\\n        private\\r\\n        returns (\\r\\n            int256,\\r\\n            bool,\\r\\n            PortfolioAsset[] memory\\r\\n        )\\r\\n    {\\r\\n        require(tokensToRedeem > 0);\\r\\n        nTokenPortfolio memory nToken;\\r\\n        nToken.loadNTokenPortfolioStateful(currencyId);\\r\\n        // nTokens cannot be redeemed during the period of time where they require settlement.\\r\\n        require(nToken.getNextSettleTime() > blockTime, \\\"PT: requires settlement\\\");\\r\\n\\r\\n        // Get the assetCash and fCash assets as a result of redeeming tokens\\r\\n        (PortfolioAsset[] memory newfCashAssets, int256 totalAssetCash) =\\r\\n            _reduceTokenAssets(nToken, tokensToRedeem, blockTime);\\r\\n\\r\\n        // hasResidual is set to true if fCash assets need to be put back into the redeemer's portfolio\\r\\n        bool hasResidual = true;\\r\\n        if (sellTokenAssets) {\\r\\n            int256 assetCash;\\r\\n            // NOTE: newfCashAssets is modified in place during this method\\r\\n            (assetCash, hasResidual) = _sellfCashAssets(\\r\\n                nToken.cashGroup,\\r\\n                newfCashAssets,\\r\\n                blockTime\\r\\n            );\\r\\n\\r\\n            totalAssetCash = totalAssetCash.add(assetCash);\\r\\n        }\\r\\n\\r\\n        return (totalAssetCash, hasResidual, newfCashAssets);\\r\\n    }\\r\\n\\r\\n    /// @notice Removes nToken assets\\r\\n    /// @return newifCashAssets: an array of fCash assets the redeemer will take\\r\\n    /// @return assetCash: amount of cash the redeemer will take\\r\\n    function _reduceTokenAssets(\\r\\n        nTokenPortfolio memory nToken,\\r\\n        int256 tokensToRedeem,\\r\\n        uint256 blockTime\\r\\n    ) private returns (PortfolioAsset[] memory, int256) {\\r\\n        // Get share of ifCash assets to remove\\r\\n        PortfolioAsset[] memory newifCashAssets =\\r\\n            BitmapAssetsHandler.reduceifCashAssetsProportional(\\r\\n                nToken.tokenAddress,\\r\\n                nToken.cashGroup.currencyId,\\r\\n                nToken.lastInitializedTime,\\r\\n                tokensToRedeem,\\r\\n                nToken.totalSupply\\r\\n            );\\r\\n\\r\\n        // Get asset cash share for the nToken, if it exists. It is required in balance handler that the\\r\\n        // nToken can never have a negative cash asset cash balance so what we get here is always positive.\\r\\n        int256 assetCashShare = nToken.cashBalance.mul(tokensToRedeem).div(nToken.totalSupply);\\r\\n        if (assetCashShare > 0) {\\r\\n            nToken.cashBalance = nToken.cashBalance.subNoNeg(assetCashShare);\\r\\n            BalanceHandler.setBalanceStorageForNToken(\\r\\n                nToken.tokenAddress,\\r\\n                nToken.cashGroup.currencyId,\\r\\n                nToken.cashBalance\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // Get share of liquidity tokens to remove, newifCashAssets is modified in memory\\r\\n        // during this method.\\r\\n        assetCashShare = assetCashShare.add(\\r\\n            _removeLiquidityTokens(\\r\\n                nToken,\\r\\n                newifCashAssets,\\r\\n                tokensToRedeem,\\r\\n                nToken.totalSupply,\\r\\n                blockTime\\r\\n            )\\r\\n        );\\r\\n\\r\\n        {\\r\\n            // prettier-ignore\\r\\n            (\\r\\n                /* hasDebt */,\\r\\n                /* currencies */,\\r\\n                uint8 newStorageLength,\\r\\n                /* nextSettleTime */\\r\\n            ) = nToken.portfolioState.storeAssets(nToken.tokenAddress);\\r\\n\\r\\n            // This can happen if a liquidity token is redeemed down to zero. It's possible that due to dust amounts\\r\\n            // one token is reduced down to a zero balance while the others still have some amount remaining. In this case\\r\\n            // the mint nToken will fail in `addLiquidityToMarket`, an account must accept redeeming part of their\\r\\n            // nTokens and leaving some dust amount behind.\\r\\n            require(\\r\\n                nToken.portfolioState.storedAssets.length == uint256(newStorageLength),\\r\\n                \\\"Cannot redeem to zero\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // NOTE: Token supply change will happen when we finalize balances and after minting of incentives\\r\\n        return (newifCashAssets, assetCashShare);\\r\\n    }\\r\\n\\r\\n    /// @notice Removes nToken liquidity tokens and updates the netfCash figures.\\r\\n    function _removeLiquidityTokens(\\r\\n        nTokenPortfolio memory nToken,\\r\\n        PortfolioAsset[] memory newifCashAssets,\\r\\n        int256 tokensToRedeem,\\r\\n        int256 totalSupply,\\r\\n        uint256 blockTime\\r\\n    ) private returns (int256 totalAssetCash) {\\r\\n        MarketParameters memory market;\\r\\n\\r\\n        for (uint256 i = 0; i < nToken.portfolioState.storedAssets.length; i++) {\\r\\n            PortfolioAsset memory asset = nToken.portfolioState.storedAssets[i];\\r\\n            int256 tokensToRemove = asset.notional.mul(tokensToRedeem).div(totalSupply);\\r\\n            asset.notional = asset.notional.sub(tokensToRemove);\\r\\n            // Cannot redeem liquidity tokens down to zero or this will cause many issues with\\r\\n            // market initialization.\\r\\n            require(asset.notional > 0, \\\"Cannot redeem to zero\\\");\\r\\n            require(asset.storageState == AssetStorageState.NoChange);\\r\\n            asset.storageState = AssetStorageState.Update;\\r\\n\\r\\n            // This will load a market object in memory\\r\\n            nToken.cashGroup.loadMarket(market, i + 1, true, blockTime);\\r\\n            // Remove liquidity from the market\\r\\n            (int256 assetCash, int256 fCash) = market.removeLiquidity(tokensToRemove);\\r\\n            totalAssetCash = totalAssetCash.add(assetCash);\\r\\n\\r\\n            // It is improbable but possible that an fcash asset does not exist if the fCash position for an active liquidity token\\r\\n            // is zero. This would occur when the nToken has done a lot of lending instead of providing liquidity to the point\\r\\n            // where the fCash position is exactly zero. This is highly unlikely so instead of adding more logic to handle it we will just\\r\\n            // fail here. Minting some amount of nTokens will cause the fCash position to be reinstated.\\r\\n            {\\r\\n                uint256 ifCashIndex;\\r\\n                while (newifCashAssets[ifCashIndex].maturity != asset.maturity) {\\r\\n                    ifCashIndex += 1;\\r\\n                    require(ifCashIndex < newifCashAssets.length, \\\"Error removing tokens\\\");\\r\\n                }\\r\\n                newifCashAssets[ifCashIndex].notional = newifCashAssets[ifCashIndex].notional.add(\\r\\n                    fCash\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return totalAssetCash;\\r\\n    }\\r\\n\\r\\n    /// @notice Sells fCash assets back into the market for cash. Negative fCash assets will decrease netAssetCash\\r\\n    /// as a result. The aim here is to ensure that accounts can redeem nTokens without having to take on\\r\\n    /// fCash assets.\\r\\n    function _sellfCashAssets(\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        PortfolioAsset[] memory fCashAssets,\\r\\n        uint256 blockTime\\r\\n    ) private returns (int256 totalAssetCash, bool hasResidual) {\\r\\n        MarketParameters memory market;\\r\\n\\r\\n        for (uint256 i = 0; i < fCashAssets.length; i++) {\\r\\n            PortfolioAsset memory asset = fCashAssets[i];\\r\\n            if (asset.notional == 0) continue;\\r\\n\\r\\n            (uint256 marketIndex, bool isIdiosyncratic) = DateTime.getMarketIndex(\\r\\n                cashGroup.maxMarketIndex,\\r\\n                asset.maturity,\\r\\n                blockTime\\r\\n            );\\r\\n\\r\\n            if (isIdiosyncratic) {\\r\\n                hasResidual = true;\\r\\n            } else {\\r\\n                cashGroup.loadMarket(market, marketIndex, false, blockTime);\\r\\n                int256 netAssetCash = market.executeTrade(\\r\\n                    cashGroup,\\r\\n                    // Use the negative of fCash notional here since we want to net it out\\r\\n                    asset.notional.neg(),\\r\\n                    asset.maturity.sub(blockTime),\\r\\n                    marketIndex\\r\\n                );\\r\\n\\r\\n                if (netAssetCash == 0) {\\r\\n                    // This means that the trade failed\\r\\n                    hasResidual = true;\\r\\n                } else {\\r\\n                    totalAssetCash = totalAssetCash.add(netAssetCash);\\r\\n                    asset.notional = 0;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/global/StorageLayoutV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./Types.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice Storage layout for the system. Do not change this file once deployed, future storage\\r\\n * layouts must inherit this and increment the version number.\\r\\n */\\r\\ncontract StorageLayoutV1 {\\r\\n    // The current maximum currency id\\r\\n    uint16 internal maxCurrencyId;\\r\\n    // Sets the state of liquidations being enabled during a paused state. Each of the four lower\\r\\n    // bits can be turned on to represent one of the liquidation types being enabled.\\r\\n    bytes1 internal liquidationEnabledState;\\r\\n    // Set to true once the system has been initialized\\r\\n    bool internal hasInitialized;\\r\\n\\r\\n    /* Authentication Mappings */\\r\\n    // This is set to the timelock contract to execute governance functions\\r\\n    address public owner;\\r\\n    // This is set to an address of a router that can only call governance actions\\r\\n    address public pauseRouter;\\r\\n    // This is set to an address of a router that can only call governance actions\\r\\n    address public pauseGuardian;\\r\\n    // On upgrades this is set in the case that the pause router is used to pass the rollback check\\r\\n    address internal rollbackRouterImplementation;\\r\\n\\r\\n    // A blanket allowance for a spender to transfer any of an account's nTokens. This would allow a user\\r\\n    // to set an allowance on all nTokens for a particular integrating contract system.\\r\\n    // owner => spender => transferAllowance\\r\\n    mapping(address => mapping(address => uint256)) internal nTokenWhitelist;\\r\\n    // Individual transfer allowances for nTokens used for ERC20\\r\\n    // owner => spender => currencyId => transferAllowance\\r\\n    mapping(address => mapping(address => mapping(uint16 => uint256))) internal nTokenAllowance;\\r\\n\\r\\n    // Transfer operators\\r\\n    // Mapping from a global ERC1155 transfer operator contract to an approval value for it\\r\\n    mapping(address => bool) internal globalTransferOperator;\\r\\n    // Mapping from an account => operator => approval status for that operator. This is a specific\\r\\n    // approval between two addresses for ERC1155 transfers.\\r\\n    mapping(address => mapping(address => bool)) internal accountAuthorizedTransferOperator;\\r\\n    // Approval for a specific contract to use the `batchBalanceAndTradeActionWithCallback` method in\\r\\n    // BatchAction.sol, can only be set by governance\\r\\n    mapping(address => bool) internal authorizedCallbackContract;\\r\\n\\r\\n    // Reverse mapping from token addresses to currency ids, only used for referencing in views\\r\\n    // and checking for duplicate token listings.\\r\\n    mapping(address => uint16) internal tokenAddressToCurrencyId;\\r\\n\\r\\n    // Reentrancy guard\\r\\n    uint256 internal reentrancyStatus;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/global/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"interfaces/chainlink/AggregatorV2V3Interface.sol\\\";\\r\\nimport \\\"interfaces/notional/AssetRateAdapter.sol\\\";\\r\\n\\r\\n/// @notice Different types of internal tokens\\r\\n///  - UnderlyingToken: underlying asset for a cToken (except for Ether)\\r\\n///  - cToken: Compound interest bearing token\\r\\n///  - cETH: Special handling for cETH tokens\\r\\n///  - Ether: the one and only\\r\\n///  - NonMintable: tokens that do not have an underlying (therefore not cTokens)\\r\\nenum TokenType {UnderlyingToken, cToken, cETH, Ether, NonMintable}\\r\\n\\r\\n/// @notice Specifies the different trade action types in the system. Each trade action type is\\r\\n/// encoded in a tightly packed bytes32 object. Trade action type is the first big endian byte of the\\r\\n/// 32 byte trade action object. The schemas for each trade action type are defined below.\\r\\nenum TradeActionType {\\r\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 minImpliedRate, uint120 unused)\\r\\n    Lend,\\r\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 maxImpliedRate, uint128 unused)\\r\\n    Borrow,\\r\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 assetCashAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\\r\\n    AddLiquidity,\\r\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 tokenAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\\r\\n    RemoveLiquidity,\\r\\n    // (uint8 TradeActionType, uint32 Maturity, int88 fCashResidualAmount, uint128 unused)\\r\\n    PurchaseNTokenResidual,\\r\\n    // (uint8 TradeActionType, address CounterpartyAddress, int88 fCashAmountToSettle)\\r\\n    SettleCashDebt\\r\\n}\\r\\n\\r\\n/// @notice Specifies different deposit actions that can occur during BalanceAction or BalanceActionWithTrades\\r\\nenum DepositActionType {\\r\\n    // No deposit action\\r\\n    None,\\r\\n    // Deposit asset cash, depositActionAmount is specified in asset cash external precision\\r\\n    DepositAsset,\\r\\n    // Deposit underlying tokens that are mintable to asset cash, depositActionAmount is specified in underlying token\\r\\n    // external precision\\r\\n    DepositUnderlying,\\r\\n    // Deposits specified asset cash external precision amount into an nToken and mints the corresponding amount of\\r\\n    // nTokens into the account\\r\\n    DepositAssetAndMintNToken,\\r\\n    // Deposits specified underlying in external precision, mints asset cash, and uses that asset cash to mint nTokens\\r\\n    DepositUnderlyingAndMintNToken,\\r\\n    // Redeems an nToken balance to asset cash. depositActionAmount is specified in nToken precision. Considered a deposit action\\r\\n    // because it deposits asset cash into an account. If there are fCash residuals that cannot be sold off, will revert.\\r\\n    RedeemNToken,\\r\\n    // Converts specified amount of asset cash balance already in Notional to nTokens. depositActionAmount is specified in\\r\\n    // Notional internal 8 decimal precision.\\r\\n    ConvertCashToNToken\\r\\n}\\r\\n\\r\\n/// @notice Used internally for PortfolioHandler state\\r\\nenum AssetStorageState {NoChange, Update, Delete, RevertIfStored}\\r\\n\\r\\n/****** Calldata objects ******/\\r\\n\\r\\n/// @notice Defines a balance action for batchAction\\r\\nstruct BalanceAction {\\r\\n    // Deposit action to take (if any)\\r\\n    DepositActionType actionType;\\r\\n    uint16 currencyId;\\r\\n    // Deposit action amount must correspond to the depositActionType, see documentation above.\\r\\n    uint256 depositActionAmount;\\r\\n    // Withdraw an amount of asset cash specified in Notional internal 8 decimal precision\\r\\n    uint256 withdrawAmountInternalPrecision;\\r\\n    // If set to true, will withdraw entire cash balance. Useful if there may be an unknown amount of asset cash\\r\\n    // residual left from trading.\\r\\n    bool withdrawEntireCashBalance;\\r\\n    // If set to true, will redeem asset cash to the underlying token on withdraw.\\r\\n    bool redeemToUnderlying;\\r\\n}\\r\\n\\r\\n/// @notice Defines a balance action with a set of trades to do as well\\r\\nstruct BalanceActionWithTrades {\\r\\n    DepositActionType actionType;\\r\\n    uint16 currencyId;\\r\\n    uint256 depositActionAmount;\\r\\n    uint256 withdrawAmountInternalPrecision;\\r\\n    bool withdrawEntireCashBalance;\\r\\n    bool redeemToUnderlying;\\r\\n    // Array of tightly packed 32 byte objects that represent trades. See TradeActionType documentation\\r\\n    bytes32[] trades;\\r\\n}\\r\\n\\r\\n/****** In memory objects ******/\\r\\n/// @notice Internal object that represents settled cash balances\\r\\nstruct SettleAmount {\\r\\n    uint256 currencyId;\\r\\n    int256 netCashChange;\\r\\n}\\r\\n\\r\\n/// @notice Internal object that represents a token\\r\\nstruct Token {\\r\\n    address tokenAddress;\\r\\n    bool hasTransferFee;\\r\\n    int256 decimals;\\r\\n    TokenType tokenType;\\r\\n    uint256 maxCollateralBalance;\\r\\n}\\r\\n\\r\\n/// @notice Internal object that represents an nToken portfolio\\r\\nstruct nTokenPortfolio {\\r\\n    CashGroupParameters cashGroup;\\r\\n    PortfolioState portfolioState;\\r\\n    int256 totalSupply;\\r\\n    int256 cashBalance;\\r\\n    uint256 lastInitializedTime;\\r\\n    bytes6 parameters;\\r\\n    address tokenAddress;\\r\\n}\\r\\n\\r\\n/// @notice Internal object used during liquidation\\r\\nstruct LiquidationFactors {\\r\\n    address account;\\r\\n    // Aggregate free collateral of the account denominated in ETH underlying, 8 decimal precision\\r\\n    int256 netETHValue;\\r\\n    // Amount of net local currency asset cash before haircuts and buffers available\\r\\n    int256 localAssetAvailable;\\r\\n    // Amount of net collateral currency asset cash before haircuts and buffers available\\r\\n    int256 collateralAssetAvailable;\\r\\n    // Haircut value of nToken holdings denominated in asset cash, will be local or collateral nTokens based\\r\\n    // on liquidation type\\r\\n    int256 nTokenHaircutAssetValue;\\r\\n    // nToken parameters for calculating liquidation amount\\r\\n    bytes6 nTokenParameters;\\r\\n    // ETH exchange rate from local currency to ETH\\r\\n    ETHRate localETHRate;\\r\\n    // ETH exchange rate from collateral currency to ETH\\r\\n    ETHRate collateralETHRate;\\r\\n    // Asset rate for the local currency, used in cross currency calculations to calculate local asset cash required\\r\\n    AssetRateParameters localAssetRate;\\r\\n    // Used during currency liquidations if the account has liquidity tokens\\r\\n    CashGroupParameters collateralCashGroup;\\r\\n    // Used during currency liquidations if it is only a calculation, defaults to false\\r\\n    bool isCalculation;\\r\\n}\\r\\n\\r\\n/// @notice Internal asset array portfolio state\\r\\nstruct PortfolioState {\\r\\n    // Array of currently stored assets\\r\\n    PortfolioAsset[] storedAssets;\\r\\n    // Array of new assets to add\\r\\n    PortfolioAsset[] newAssets;\\r\\n    uint256 lastNewAssetIndex;\\r\\n    // Holds the length of stored assets after accounting for deleted assets\\r\\n    uint256 storedAssetLength;\\r\\n}\\r\\n\\r\\n/// @notice In memory ETH exchange rate used during free collateral calculation.\\r\\nstruct ETHRate {\\r\\n    // The decimals (i.e. 10^rateDecimalPlaces) of the exchange rate, defined by the rate oracle\\r\\n    int256 rateDecimals;\\r\\n    // The exchange rate from base to ETH (if rate invert is required it is already done)\\r\\n    int256 rate;\\r\\n    // Amount of buffer as a multiple with a basis of 100 applied to negative balances.\\r\\n    int256 buffer;\\r\\n    // Amount of haircut as a multiple with a basis of 100 applied to positive balances\\r\\n    int256 haircut;\\r\\n    // Liquidation discount as a multiple with a basis of 100 applied to the exchange rate\\r\\n    // as an incentive given to liquidators.\\r\\n    int256 liquidationDiscount;\\r\\n}\\r\\n\\r\\n/// @notice Internal object used to handle balance state during a transaction\\r\\nstruct BalanceState {\\r\\n    uint16 currencyId;\\r\\n    // Cash balance stored in balance state at the beginning of the transaction\\r\\n    int256 storedCashBalance;\\r\\n    // nToken balance stored at the beginning of the transaction\\r\\n    int256 storedNTokenBalance;\\r\\n    // The net cash change as a result of asset settlement or trading\\r\\n    int256 netCashChange;\\r\\n    // Net asset transfers into or out of the account\\r\\n    int256 netAssetTransferInternalPrecision;\\r\\n    // Net token transfers into or out of the account\\r\\n    int256 netNTokenTransfer;\\r\\n    // Net token supply change from minting or redeeming\\r\\n    int256 netNTokenSupplyChange;\\r\\n    // The last time incentives were claimed for this currency\\r\\n    uint256 lastClaimTime;\\r\\n    // The last integral supply amount when tokens were claimed\\r\\n    uint256 lastClaimIntegralSupply;\\r\\n}\\r\\n\\r\\n/// @dev Asset rate used to convert between underlying cash and asset cash\\r\\nstruct AssetRateParameters {\\r\\n    // Address of the asset rate oracle\\r\\n    AssetRateAdapter rateOracle;\\r\\n    // The exchange rate from base to quote (if invert is required it is already done)\\r\\n    int256 rate;\\r\\n    // The decimals of the underlying, the rate converts to the underlying decimals\\r\\n    int256 underlyingDecimals;\\r\\n}\\r\\n\\r\\n/// @dev Cash group when loaded into memory\\r\\nstruct CashGroupParameters {\\r\\n    uint16 currencyId;\\r\\n    uint256 maxMarketIndex;\\r\\n    AssetRateParameters assetRate;\\r\\n    bytes32 data;\\r\\n}\\r\\n\\r\\n/// @dev A portfolio asset when loaded in memory\\r\\nstruct PortfolioAsset {\\r\\n    // Asset currency id\\r\\n    uint256 currencyId;\\r\\n    uint256 maturity;\\r\\n    // Asset type, fCash or liquidity token.\\r\\n    uint256 assetType;\\r\\n    // fCash amount or liquidity token amount\\r\\n    int256 notional;\\r\\n    // Used for managing portfolio asset state\\r\\n    uint256 storageSlot;\\r\\n    // The state of the asset for when it is written to storage\\r\\n    AssetStorageState storageState;\\r\\n}\\r\\n\\r\\n/// @dev Market object as represented in memory\\r\\nstruct MarketParameters {\\r\\n    bytes32 storageSlot;\\r\\n    uint256 maturity;\\r\\n    // Total amount of fCash available for purchase in the market.\\r\\n    int256 totalfCash;\\r\\n    // Total amount of cash available for purchase in the market.\\r\\n    int256 totalAssetCash;\\r\\n    // Total amount of liquidity tokens (representing a claim on liquidity) in the market.\\r\\n    int256 totalLiquidity;\\r\\n    // This is the previous annualized interest rate in RATE_PRECISION that the market traded\\r\\n    // at. This is used to calculate the rate anchor to smooth interest rates over time.\\r\\n    uint256 lastImpliedRate;\\r\\n    // Time lagged version of lastImpliedRate, used to value fCash assets at market rates while\\r\\n    // remaining resistent to flash loan attacks.\\r\\n    uint256 oracleRate;\\r\\n    // This is the timestamp of the previous trade\\r\\n    uint256 previousTradeTime;\\r\\n}\\r\\n\\r\\n/****** Storage objects ******/\\r\\n\\r\\n/// @dev Token object in storage:\\r\\n///  20 bytes for token address\\r\\n///  1 byte for hasTransferFee\\r\\n///  1 byte for tokenType\\r\\n///  1 byte for tokenDecimals\\r\\n///  9 bytes for maxCollateralBalance (may not always be set)\\r\\nstruct TokenStorage {\\r\\n    // Address of the token\\r\\n    address tokenAddress;\\r\\n    // Transfer fees will change token deposit behavior\\r\\n    bool hasTransferFee;\\r\\n    TokenType tokenType;\\r\\n    uint8 decimalPlaces;\\r\\n    // Upper limit on how much of this token the contract can hold at any time\\r\\n    uint72 maxCollateralBalance;\\r\\n}\\r\\n\\r\\n/// @dev Exchange rate object as it is represented in storage, total storage is 25 bytes.\\r\\nstruct ETHRateStorage {\\r\\n    // Address of the rate oracle\\r\\n    AggregatorV2V3Interface rateOracle;\\r\\n    // The decimal places of precision that the rate oracle uses\\r\\n    uint8 rateDecimalPlaces;\\r\\n    // True of the exchange rate must be inverted\\r\\n    bool mustInvert;\\r\\n    // NOTE: both of these governance values are set with BUFFER_DECIMALS precision\\r\\n    // Amount of buffer to apply to the exchange rate for negative balances.\\r\\n    uint8 buffer;\\r\\n    // Amount of haircut to apply to the exchange rate for positive balances\\r\\n    uint8 haircut;\\r\\n    // Liquidation discount in percentage point terms, 106 means a 6% discount\\r\\n    uint8 liquidationDiscount;\\r\\n}\\r\\n\\r\\n/// @dev Asset rate oracle object as it is represented in storage, total storage is 21 bytes.\\r\\nstruct AssetRateStorage {\\r\\n    // Address of the rate oracle\\r\\n    AssetRateAdapter rateOracle;\\r\\n    // The decimal places of the underlying asset\\r\\n    uint8 underlyingDecimalPlaces;\\r\\n}\\r\\n\\r\\n/// @dev Governance parameters for a cash group, total storage is 9 bytes + 7 bytes for liquidity token haircuts\\r\\n/// and 7 bytes for rate scalars, total of 23 bytes. Note that this is stored packed in the storage slot so there\\r\\n/// are no indexes stored for liquidityTokenHaircuts or rateScalars, maxMarketIndex is used instead to determine the\\r\\n/// length.\\r\\nstruct CashGroupSettings {\\r\\n    // Index of the AMMs on chain that will be made available. Idiosyncratic fCash\\r\\n    // that is dated less than the longest AMM will be tradable.\\r\\n    uint8 maxMarketIndex;\\r\\n    // Time window in 5 minute increments that the rate oracle will be averaged over\\r\\n    uint8 rateOracleTimeWindow5Min;\\r\\n    // Total fees per trade, specified in BPS\\r\\n    uint8 totalFeeBPS;\\r\\n    // Share of the fees given to the protocol, denominated in percentage\\r\\n    uint8 reserveFeeShare;\\r\\n    // Debt buffer specified in 5 BPS increments\\r\\n    uint8 debtBuffer5BPS;\\r\\n    // fCash haircut specified in 5 BPS increments\\r\\n    uint8 fCashHaircut5BPS;\\r\\n    // If an account has a negative cash balance, it can be settled by incurring debt at the 3 month market. This\\r\\n    // is the basis points for the penalty rate that will be added the current 3 month oracle rate.\\r\\n    uint8 settlementPenaltyRate5BPS;\\r\\n    // If an account has fCash that is being liquidated, this is the discount that the liquidator can purchase it for\\r\\n    uint8 liquidationfCashHaircut5BPS;\\r\\n    // If an account has fCash that is being liquidated, this is the discount that the liquidator can purchase it for\\r\\n    uint8 liquidationDebtBuffer5BPS;\\r\\n    // Liquidity token haircut applied to cash claims, specified as a percentage between 0 and 100\\r\\n    uint8[] liquidityTokenHaircuts;\\r\\n    // Rate scalar used to determine the slippage of the market\\r\\n    uint8[] rateScalars;\\r\\n}\\r\\n\\r\\n/// @dev Holds account level context information used to determine settlement and\\r\\n/// free collateral actions. Total storage is 28 bytes\\r\\nstruct AccountContext {\\r\\n    // Used to check when settlement must be triggered on an account\\r\\n    uint40 nextSettleTime;\\r\\n    // For lenders that never incur debt, we use this flag to skip the free collateral check.\\r\\n    bytes1 hasDebt;\\r\\n    // Length of the account's asset array\\r\\n    uint8 assetArrayLength;\\r\\n    // If this account has bitmaps set, this is the corresponding currency id\\r\\n    uint16 bitmapCurrencyId;\\r\\n    // 9 total active currencies possible (2 bytes each)\\r\\n    bytes18 activeCurrencies;\\r\\n}\\r\\n\\r\\n/// @dev Holds nToken context information mapped via the nToken address, total storage is\\r\\n/// 16 bytes\\r\\nstruct nTokenContext {\\r\\n    // Currency id that the nToken represents\\r\\n    uint16 currencyId;\\r\\n    // Annual incentive emission rate denominated in WHOLE TOKENS (multiply by \\r\\n    // INTERNAL_TOKEN_PRECISION to get the actual rate)\\r\\n    uint32 incentiveAnnualEmissionRate;\\r\\n    // The last block time at utc0 that the nToken was initialized at, zero if it\\r\\n    // has never been initialized\\r\\n    uint32 lastInitializedTime;\\r\\n    // Length of the asset array, refers to the number of liquidity tokens an nToken\\r\\n    // currently holds\\r\\n    uint8 assetArrayLength;\\r\\n    // Each byte is a specific nToken parameter\\r\\n    bytes5 nTokenParameters;\\r\\n}\\r\\n\\r\\n/// @dev Holds account balance information, total storage 32 bytes\\r\\nstruct BalanceStorage {\\r\\n    // Number of nTokens held by the account\\r\\n    uint80 nTokenBalance;\\r\\n    // Last time the account claimed their nTokens\\r\\n    uint32 lastClaimTime;\\r\\n    // The total integral supply of the nToken at the last claim time packed into\\r\\n    // 56 bits. There is some loss of precision here but it is acceptable\\r\\n    uint56 packedLastClaimIntegralSupply;\\r\\n    // Cash balance of the account\\r\\n    int88 cashBalance;\\r\\n}\\r\\n\\r\\n/// @dev Holds information about a settlement rate, total storage 25 bytes\\r\\nstruct SettlementRateStorage {\\r\\n    uint40 blockTime;\\r\\n    uint128 settlementRate;\\r\\n    uint8 underlyingDecimalPlaces;\\r\\n}\\r\\n\\r\\n/// @dev Holds information about a market, total storage is 42 bytes so this spans\\r\\n/// two storage words\\r\\nstruct MarketStorage {\\r\\n    // Total fCash in the market\\r\\n    uint80 totalfCash;\\r\\n    // Total asset cash in the market\\r\\n    uint80 totalAssetCash;\\r\\n    // Last annualized interest rate the market traded at\\r\\n    uint32 lastImpliedRate;\\r\\n    // Last recorded oracle rate for the market\\r\\n    uint32 oracleRate;\\r\\n    // Last time a trade was made\\r\\n    uint32 previousTradeTime;\\r\\n    // This is stored in slot + 1\\r\\n    uint80 totalLiquidity;\\r\\n}\\r\\n\\r\\nstruct ifCashStorage {\\r\\n    // Notional amount of fCash at the slot, limited to int128 to allow for\\r\\n    // future expansion\\r\\n    int128 notional;\\r\\n}\\r\\n\\r\\n/// @dev A single portfolio asset in storage, total storage of 19 bytes\\r\\nstruct PortfolioAssetStorage {\\r\\n    // Currency Id for the asset\\r\\n    uint16 currencyId;\\r\\n    // Maturity of the asset\\r\\n    uint40 maturity;\\r\\n    // Asset type (fCash or Liquidity Token marker)\\r\\n    uint8 assetType;\\r\\n    // Notional\\r\\n    int88 notional;\\r\\n}\\r\\n\\r\\n/// @dev nToken total supply factors for the nToken, includes factors related\\r\\n/// to claiming incentives, total storage 32 bytes\\r\\nstruct nTokenTotalSupplyStorage {\\r\\n    // Total supply of the nToken\\r\\n    uint96 totalSupply;\\r\\n    // Integral of the total supply used for calculating the average total supply\\r\\n    uint128 integralTotalSupply;\\r\\n    // Last timestamp the supply value changed, used for calculating the integralTotalSupply\\r\\n    uint32 lastSupplyChangeTime;\\r\\n}\\r\\n\\r\\n/// @dev Used in view methods to return account balances in a developer friendly manner\\r\\nstruct AccountBalance {\\r\\n    uint16 currencyId;\\r\\n    int256 cashBalance;\\r\\n    int256 nTokenBalance;\\r\\n    uint256 lastClaimTime;\\r\\n    uint256 lastClaimIntegralSupply;\\r\\n}\\r\\n\"\r\n    },\r\n    \"interfaces/notional/NotionalProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../contracts/global/Types.sol\\\";\\r\\nimport \\\"./nTokenERC20.sol\\\";\\r\\nimport \\\"./nERC1155Interface.sol\\\";\\r\\nimport \\\"./NotionalGovernance.sol\\\";\\r\\nimport \\\"./NotionalViews.sol\\\";\\r\\n\\r\\ninterface NotionalProxy is nTokenERC20, nERC1155Interface, NotionalGovernance, NotionalViews {\\r\\n    /** User trading events */\\r\\n    event CashBalanceChange(address indexed account, uint16 indexed currencyId, int256 netCashChange);\\r\\n    event nTokenSupplyChange(address indexed account, uint16 indexed currencyId, int256 tokenSupplyChange);\\r\\n    event MarketsInitialized(uint16 currencyId);\\r\\n    event SweepCashIntoMarkets(uint16 currencyId, int256 cashIntoMarkets);\\r\\n    event SettledCashDebt(\\r\\n        address indexed settledAccount,\\r\\n        uint16 indexed currencyId,\\r\\n        address indexed settler,\\r\\n        int256 amountToSettleAsset,\\r\\n        int256 fCashAmount\\r\\n    );\\r\\n    event nTokenResidualPurchase(\\r\\n        uint16 indexed currencyId,\\r\\n        uint40 indexed maturity,\\r\\n        address indexed purchaser,\\r\\n        int256 fCashAmountToPurchase,\\r\\n        int256 netAssetCashNToken\\r\\n    );\\r\\n    event LendBorrowTrade(\\r\\n        address indexed account,\\r\\n        uint16 indexed currencyId,\\r\\n        uint40 maturity,\\r\\n        int256 netAssetCash,\\r\\n        int256 netfCash\\r\\n    );\\r\\n    event AddRemoveLiquidity(\\r\\n        address indexed account,\\r\\n        uint16 indexed currencyId,\\r\\n        uint40 maturity,\\r\\n        int256 netAssetCash,\\r\\n        int256 netfCash,\\r\\n        int256 netLiquidityTokens\\r\\n    );\\r\\n\\r\\n    /// @notice Emitted when reserve fees are accrued\\r\\n    event ReserveFeeAccrued(uint16 indexed currencyId, int256 fee);\\r\\n    /// @notice Emitted whenever an account context has updated\\r\\n    event AccountContextUpdate(address indexed account);\\r\\n    /// @notice Emitted when an account has assets that are settled\\r\\n    event AccountSettled(address indexed account);\\r\\n    /// @notice Emitted when an asset rate is settled\\r\\n    event SetSettlementRate(uint256 indexed currencyId, uint256 indexed maturity, uint128 rate);\\r\\n\\r\\n    /* Liquidation Events */\\r\\n    event LiquidateLocalCurrency(\\r\\n        address indexed liquidated,\\r\\n        address indexed liquidator,\\r\\n        uint16 localCurrencyId,\\r\\n        int256 netLocalFromLiquidator\\r\\n    );\\r\\n\\r\\n    event LiquidateCollateralCurrency(\\r\\n        address indexed liquidated,\\r\\n        address indexed liquidator,\\r\\n        uint16 localCurrencyId,\\r\\n        uint16 collateralCurrencyId,\\r\\n        int256 netLocalFromLiquidator,\\r\\n        int256 netCollateralTransfer,\\r\\n        int256 netNTokenTransfer\\r\\n    );\\r\\n\\r\\n    event LiquidatefCashEvent(\\r\\n        address indexed liquidated,\\r\\n        address indexed liquidator,\\r\\n        uint16 localCurrencyId,\\r\\n        uint16 fCashCurrency,\\r\\n        int256 netLocalFromLiquidator,\\r\\n        uint256[] fCashMaturities,\\r\\n        int256[] fCashNotionalTransfer\\r\\n    );\\r\\n\\r\\n    /** UUPS Upgradeable contract calls */\\r\\n    function upgradeTo(address newImplementation) external;\\r\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;\\r\\n    function getImplementation() external view returns (address);\\r\\n    function owner() external view returns (address);\\r\\n    function pauseRouter() external view returns (address);\\r\\n    function pauseGuardian() external view returns (address);\\r\\n\\r\\n    /** Initialize Markets Action */\\r\\n    function initializeMarkets(uint16 currencyId, bool isFirstInit) external;\\r\\n\\r\\n    function sweepCashIntoMarkets(uint16 currencyId) external;\\r\\n\\r\\n    /** Redeem nToken Action */\\r\\n    function nTokenRedeem(\\r\\n        address redeemer,\\r\\n        uint16 currencyId,\\r\\n        uint96 tokensToRedeem_,\\r\\n        bool sellTokenAssets\\r\\n    ) external returns (int256);\\r\\n\\r\\n    /** Account Action */\\r\\n    function enableBitmapCurrency(uint16 currencyId) external;\\r\\n\\r\\n    function settleAccount(address account) external;\\r\\n\\r\\n    function depositUnderlyingToken(\\r\\n        address account,\\r\\n        uint16 currencyId,\\r\\n        uint256 amountExternalPrecision\\r\\n    ) external payable returns (uint256);\\r\\n\\r\\n    function depositAssetToken(\\r\\n        address account,\\r\\n        uint16 currencyId,\\r\\n        uint256 amountExternalPrecision\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function withdraw(\\r\\n        uint16 currencyId,\\r\\n        uint88 amountInternalPrecision,\\r\\n        bool redeemToUnderlying\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    /** Batch Action */\\r\\n    function batchBalanceAction(address account, BalanceAction[] calldata actions) external payable;\\r\\n\\r\\n    function batchBalanceAndTradeAction(address account, BalanceActionWithTrades[] calldata actions)\\r\\n        external\\r\\n        payable;\\r\\n\\r\\n    function batchBalanceAndTradeActionWithCallback(\\r\\n        address account,\\r\\n        BalanceActionWithTrades[] calldata actions,\\r\\n        bytes calldata callbackData\\r\\n    ) external payable;\\r\\n\\r\\n    /** Liquidation Action */\\r\\n    function calculateLocalCurrencyLiquidation(\\r\\n        address liquidateAccount,\\r\\n        uint16 localCurrency,\\r\\n        uint96 maxNTokenLiquidation\\r\\n    ) external returns (int256, int256);\\r\\n\\r\\n    function liquidateLocalCurrency(\\r\\n        address liquidateAccount,\\r\\n        uint16 localCurrency,\\r\\n        uint96 maxNTokenLiquidation\\r\\n    ) external returns (int256, int256);\\r\\n\\r\\n    function calculateCollateralCurrencyLiquidation(\\r\\n        address liquidateAccount,\\r\\n        uint16 localCurrency,\\r\\n        uint16 collateralCurrency,\\r\\n        uint128 maxCollateralLiquidation,\\r\\n        uint96 maxNTokenLiquidation\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            int256,\\r\\n            int256,\\r\\n            int256\\r\\n        );\\r\\n\\r\\n    function liquidateCollateralCurrency(\\r\\n        address liquidateAccount,\\r\\n        uint16 localCurrency,\\r\\n        uint16 collateralCurrency,\\r\\n        uint128 maxCollateralLiquidation,\\r\\n        uint96 maxNTokenLiquidation,\\r\\n        bool withdrawCollateral,\\r\\n        bool redeemToUnderlying\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            int256,\\r\\n            int256,\\r\\n            int256\\r\\n        );\\r\\n\\r\\n    function calculatefCashLocalLiquidation(\\r\\n        address liquidateAccount,\\r\\n        uint16 localCurrency,\\r\\n        uint256[] calldata fCashMaturities,\\r\\n        uint256[] calldata maxfCashLiquidateAmounts\\r\\n    ) external returns (int256[] memory, int256);\\r\\n\\r\\n    function liquidatefCashLocal(\\r\\n        address liquidateAccount,\\r\\n        uint16 localCurrency,\\r\\n        uint256[] calldata fCashMaturities,\\r\\n        uint256[] calldata maxfCashLiquidateAmounts\\r\\n    ) external returns (int256[] memory, int256);\\r\\n\\r\\n    function calculatefCashCrossCurrencyLiquidation(\\r\\n        address liquidateAccount,\\r\\n        uint16 localCurrency,\\r\\n        uint16 fCashCurrency,\\r\\n        uint256[] calldata fCashMaturities,\\r\\n        uint256[] calldata maxfCashLiquidateAmounts\\r\\n    ) external returns (int256[] memory, int256);\\r\\n\\r\\n    function liquidatefCashCrossCurrency(\\r\\n        address liquidateAccount,\\r\\n        uint16 localCurrency,\\r\\n        uint16 fCashCurrency,\\r\\n        uint256[] calldata fCashMaturities,\\r\\n        uint256[] calldata maxfCashLiquidateAmounts\\r\\n    ) external returns (int256[] memory, int256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"interfaces/notional/nERC1155Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../contracts/global/Types.sol\\\";\\r\\n\\r\\ninterface nERC1155Interface {\\r\\n    event TransferSingle(\\r\\n        address indexed operator,\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 id,\\r\\n        uint256 value\\r\\n    );\\r\\n    event TransferBatch(\\r\\n        address indexed operator,\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256[] ids,\\r\\n        uint256[] values\\r\\n    );\\r\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\r\\n    event URI(string value, uint256 indexed id);\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool);\\r\\n\\r\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\r\\n\\r\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256[] memory);\\r\\n\\r\\n    function signedBalanceOf(address account, uint256 id) external view returns (int256);\\r\\n\\r\\n    function signedBalanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\r\\n        external\\r\\n        view\\r\\n        returns (int256[] memory);\\r\\n\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint256 amount,\\r\\n        bytes calldata data\\r\\n    ) external payable;\\r\\n\\r\\n    function safeBatchTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] calldata ids,\\r\\n        uint256[] calldata amounts,\\r\\n        bytes calldata data\\r\\n    ) external payable;\\r\\n\\r\\n    function decodeToAssets(uint256[] calldata ids, uint256[] calldata amounts)\\r\\n        external\\r\\n        view\\r\\n        returns (PortfolioAsset[] memory);\\r\\n\\r\\n    function encodeToId(\\r\\n        uint16 currencyId,\\r\\n        uint40 maturity,\\r\\n        uint8 assetType\\r\\n    ) external pure returns (uint256 id);\\r\\n}\\r\\n\"\r\n    },\r\n    \"interfaces/notional/NotionalGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../contracts/global/Types.sol\\\";\\r\\nimport \\\"interfaces/chainlink/AggregatorV2V3Interface.sol\\\";\\r\\nimport \\\"interfaces/notional/NotionalGovernance.sol\\\";\\r\\n\\r\\ninterface NotionalGovernance {\\r\\n    event ListCurrency(uint16 newCurrencyId);\\r\\n    event UpdateETHRate(uint16 currencyId);\\r\\n    event UpdateAssetRate(uint16 currencyId);\\r\\n    event UpdateCashGroup(uint16 currencyId);\\r\\n    event DeployNToken(uint16 currencyId, address nTokenAddress);\\r\\n    event UpdateDepositParameters(uint16 currencyId);\\r\\n    event UpdateInitializationParameters(uint16 currencyId);\\r\\n    event UpdateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate);\\r\\n    event UpdateTokenCollateralParameters(uint16 currencyId);\\r\\n    event UpdateGlobalTransferOperator(address operator, bool approved);\\r\\n    event UpdateAuthorizedCallbackContract(address operator, bool approved);\\r\\n    event UpdateMaxCollateralBalance(uint16 currencyId, uint72 maxCollateralBalance);\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    event PauseRouterAndGuardianUpdated(address indexed pauseRouter, address indexed pauseGuardian);\\r\\n\\r\\n    function transferOwnership(address newOwner, bool direct) external;\\r\\n\\r\\n    function claimOwnership() external;\\r\\n\\r\\n    function setPauseRouterAndGuardian(address pauseRouter_, address pauseGuardian_) external;\\r\\n\\r\\n    function listCurrency(\\r\\n        TokenStorage calldata assetToken,\\r\\n        TokenStorage calldata underlyingToken,\\r\\n        AggregatorV2V3Interface rateOracle,\\r\\n        bool mustInvert,\\r\\n        uint8 buffer,\\r\\n        uint8 haircut,\\r\\n        uint8 liquidationDiscount\\r\\n    ) external returns (uint16 currencyId);\\r\\n\\r\\n    function updateMaxCollateralBalance(\\r\\n        uint16 currencyId,\\r\\n        uint72 maxCollateralBalanceInternalPrecision\\r\\n    ) external;\\r\\n\\r\\n    function enableCashGroup(\\r\\n        uint16 currencyId,\\r\\n        AssetRateAdapter assetRateOracle,\\r\\n        CashGroupSettings calldata cashGroup,\\r\\n        string calldata underlyingName,\\r\\n        string calldata underlyingSymbol\\r\\n    ) external;\\r\\n\\r\\n    function updateDepositParameters(\\r\\n        uint16 currencyId,\\r\\n        uint32[] calldata depositShares,\\r\\n        uint32[] calldata leverageThresholds\\r\\n    ) external;\\r\\n\\r\\n    function updateInitializationParameters(\\r\\n        uint16 currencyId,\\r\\n        uint32[] calldata annualizedAnchorRates,\\r\\n        uint32[] calldata proportions\\r\\n    ) external;\\r\\n\\r\\n    function updateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate) external;\\r\\n\\r\\n    function updateTokenCollateralParameters(\\r\\n        uint16 currencyId,\\r\\n        uint8 residualPurchaseIncentive10BPS,\\r\\n        uint8 pvHaircutPercentage,\\r\\n        uint8 residualPurchaseTimeBufferHours,\\r\\n        uint8 cashWithholdingBuffer10BPS,\\r\\n        uint8 liquidationHaircutPercentage\\r\\n    ) external;\\r\\n\\r\\n    function updateCashGroup(uint16 currencyId, CashGroupSettings calldata cashGroup) external;\\r\\n\\r\\n    function updateAssetRate(uint16 currencyId, AssetRateAdapter rateOracle) external;\\r\\n\\r\\n    function updateETHRate(\\r\\n        uint16 currencyId,\\r\\n        AggregatorV2V3Interface rateOracle,\\r\\n        bool mustInvert,\\r\\n        uint8 buffer,\\r\\n        uint8 haircut,\\r\\n        uint8 liquidationDiscount\\r\\n    ) external;\\r\\n\\r\\n    function updateGlobalTransferOperator(address operator, bool approved) external;\\r\\n\\r\\n    function updateAuthorizedCallbackContract(address operator, bool approved) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/external/actions/ActionGuards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../global/StorageLayoutV1.sol\\\";\\r\\nimport \\\"../../internal/nTokenHandler.sol\\\";\\r\\n\\r\\nabstract contract ActionGuards is StorageLayoutV1 {\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    function initializeReentrancyGuard() internal {\\r\\n        require(reentrancyStatus == 0);\\r\\n\\r\\n        // Initialize the guard to a non-zero value, see the OZ reentrancy guard\\r\\n        // description for why this is more gas efficient:\\r\\n        // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol\\r\\n        reentrancyStatus = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    modifier nonReentrant() {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(reentrancyStatus != _ENTERED, \\\"Reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        reentrancyStatus = _ENTERED;\\r\\n\\r\\n        _;\\r\\n\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        reentrancyStatus = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    // These accounts cannot receive deposits, transfers, fCash or any other\\r\\n    // types of value transfers.\\r\\n    function requireValidAccount(address account) internal view {\\r\\n        require(account != Constants.RESERVE); // Reserve address is address(0)\\r\\n        require(account != address(this));\\r\\n        (\\r\\n            uint256 isNToken,\\r\\n            /* incentiveAnnualEmissionRate */,\\r\\n            /* lastInitializedTime */,\\r\\n            /* assetArrayLength */,\\r\\n            /* parameters */\\r\\n        ) = nTokenHandler.getNTokenContext(account);\\r\\n        require(isNToken == 0);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/internal/nTokenHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../global/LibStorage.sol\\\";\\r\\nimport \\\"./markets/CashGroup.sol\\\";\\r\\nimport \\\"./markets/AssetRate.sol\\\";\\r\\nimport \\\"./valuation/AssetHandler.sol\\\";\\r\\nimport \\\"./portfolio/BitmapAssetsHandler.sol\\\";\\r\\nimport \\\"./portfolio/PortfolioHandler.sol\\\";\\r\\nimport \\\"./balances/BalanceHandler.sol\\\";\\r\\nimport \\\"../math/SafeInt256.sol\\\";\\r\\n\\r\\nlibrary nTokenHandler {\\r\\n    using AssetRate for AssetRateParameters;\\r\\n    using SafeInt256 for int256;\\r\\n\\r\\n    /// @dev Mirror of the value in LibStorage\\r\\n    uint256 private constant NUM_NTOKEN_MARKET_FACTORS = 14;\\r\\n\\r\\n    /// @notice Returns an account context object that is specific to nTokens.\\r\\n    function getNTokenContext(address tokenAddress)\\r\\n        internal\\r\\n        view\\r\\n        returns (\\r\\n            uint16 currencyId,\\r\\n            uint256 incentiveAnnualEmissionRate,\\r\\n            uint256 lastInitializedTime,\\r\\n            uint8 assetArrayLength,\\r\\n            bytes5 parameters\\r\\n        )\\r\\n    {\\r\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\r\\n        nTokenContext storage context = store[tokenAddress];\\r\\n\\r\\n        // TODO: how many storage reads is this?\\r\\n        currencyId = context.currencyId;\\r\\n        incentiveAnnualEmissionRate = context.incentiveAnnualEmissionRate;\\r\\n        lastInitializedTime = context.lastInitializedTime;\\r\\n        assetArrayLength = context.assetArrayLength;\\r\\n        parameters = context.nTokenParameters;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the nToken token address for a given currency\\r\\n    function nTokenAddress(uint256 currencyId) internal view returns (address tokenAddress) {\\r\\n        mapping(uint256 => address) storage store = LibStorage.getNTokenAddressStorage();\\r\\n        return store[currencyId];\\r\\n    }\\r\\n\\r\\n    /// @notice Called by governance to set the nToken token address and its reverse lookup. Cannot be\\r\\n    /// reset once this is set.\\r\\n    function setNTokenAddress(uint16 currencyId, address tokenAddress) internal {\\r\\n        mapping(uint256 => address) storage addressStore = LibStorage.getNTokenAddressStorage();\\r\\n        require(addressStore[currencyId] == address(0), \\\"PT: token address exists\\\");\\r\\n\\r\\n        mapping(address => nTokenContext) storage contextStore = LibStorage.getNTokenContextStorage();\\r\\n        nTokenContext storage context = contextStore[tokenAddress];\\r\\n        require(context.currencyId == 0, \\\"PT: currency exists\\\");\\r\\n\\r\\n        // This will initialize all other context slots to zero\\r\\n        context.currencyId = currencyId;\\r\\n        addressStore[currencyId] = tokenAddress;\\r\\n    }\\r\\n\\r\\n    /// @notice Set nToken token collateral parameters\\r\\n    function setNTokenCollateralParameters(\\r\\n        address tokenAddress,\\r\\n        uint8 residualPurchaseIncentive10BPS,\\r\\n        uint8 pvHaircutPercentage,\\r\\n        uint8 residualPurchaseTimeBufferHours,\\r\\n        uint8 cashWithholdingBuffer10BPS,\\r\\n        uint8 liquidationHaircutPercentage\\r\\n    ) internal {\\r\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\r\\n        nTokenContext storage context = store[tokenAddress];\\r\\n\\r\\n        require(liquidationHaircutPercentage <= Constants.PERCENTAGE_DECIMALS, \\\"Invalid haircut\\\");\\r\\n        // The pv haircut percentage must be less than the liquidation percentage or else liquidators will not\\r\\n        // get profit for liquidating nToken.\\r\\n        require(pvHaircutPercentage < liquidationHaircutPercentage, \\\"Invalid pv haircut\\\");\\r\\n        // Ensure that the cash withholding buffer is greater than the residual purchase incentive or\\r\\n        // the nToken may not have enough cash to pay accounts to buy its negative ifCash\\r\\n        require(residualPurchaseIncentive10BPS <= cashWithholdingBuffer10BPS, \\\"Invalid discounts\\\");\\r\\n\\r\\n        bytes5 parameters =\\r\\n            (bytes5(uint40(residualPurchaseIncentive10BPS)) |\\r\\n            (bytes5(uint40(pvHaircutPercentage)) << 8) |\\r\\n            (bytes5(uint40(residualPurchaseTimeBufferHours)) << 16) |\\r\\n            (bytes5(uint40(cashWithholdingBuffer10BPS)) << 24) |\\r\\n            (bytes5(uint40(liquidationHaircutPercentage)) << 32));\\r\\n\\r\\n        // Set the parameters\\r\\n        context.nTokenParameters = parameters;\\r\\n    }\\r\\n\\r\\n    /// @notice Retrieves the nToken supply factors without any updates or calculations\\r\\n    function getStoredNTokenSupplyFactors(address tokenAddress)\\r\\n        internal\\r\\n        view\\r\\n        returns (\\r\\n            uint256 totalSupply,\\r\\n            uint256 integralTotalSupply,\\r\\n            uint256 lastSupplyChangeTime\\r\\n        )\\r\\n    {\\r\\n        mapping(address => nTokenTotalSupplyStorage) storage store = LibStorage.getNTokenTotalSupplyStorage();\\r\\n        nTokenTotalSupplyStorage storage nTokenStorage = store[tokenAddress];\\r\\n        totalSupply = nTokenStorage.totalSupply;\\r\\n        // NOTE: DO NOT USE THIS RETURNED VALUE FOR CALCULATING INCENTIVES. The integral total supply\\r\\n        // must be updated given the block time. Use `calculateIntegralTotalSupply` instead\\r\\n        integralTotalSupply = nTokenStorage.integralTotalSupply;\\r\\n        lastSupplyChangeTime = nTokenStorage.lastSupplyChangeTime;\\r\\n    }\\r\\n\\r\\n    /// @notice Retrieves stored total supply factors and \\r\\n    function calculateIntegralTotalSupply(address tokenAddress, uint256 blockTime) \\r\\n        internal\\r\\n        view \\r\\n        returns (\\r\\n            uint256 totalSupply,\\r\\n            uint256 integralTotalSupply,\\r\\n            uint256 lastSupplyChangeTime\\r\\n        )\\r\\n    {\\r\\n        (\\r\\n            totalSupply,\\r\\n            integralTotalSupply,\\r\\n            lastSupplyChangeTime\\r\\n        ) = getStoredNTokenSupplyFactors(tokenAddress);\\r\\n\\r\\n        // Initialize last supply change time if it has not been set.\\r\\n        if (lastSupplyChangeTime == 0) lastSupplyChangeTime = blockTime;\\r\\n\\r\\n        require(blockTime >= lastSupplyChangeTime); // dev: invalid block time\\r\\n\\r\\n        // Add to the integral total supply the total supply of tokens multiplied by the time that the total supply\\r\\n        // has been the value. This will part of the numerator for the average total supply calculation during\\r\\n        // minting incentives.\\r\\n        integralTotalSupply = uint256(int256(integralTotalSupply).add(\\r\\n            int256(totalSupply).mul(int256(blockTime - lastSupplyChangeTime))\\r\\n        ));\\r\\n\\r\\n        require(integralTotalSupply >= 0 && integralTotalSupply < type(uint128).max); // dev: integral total supply overflow\\r\\n        require(blockTime < type(uint32).max); // dev: last supply change supply overflow\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @notice Updates the nToken token supply amount when minting or redeeming.\\r\\n    function changeNTokenSupply(\\r\\n        address tokenAddress,\\r\\n        int256 netChange,\\r\\n        uint256 blockTime\\r\\n    ) internal returns (uint256) {\\r\\n        (\\r\\n            uint256 totalSupply,\\r\\n            uint256 integralTotalSupply,\\r\\n            /* uint256 lastSupplyChangeTime */\\r\\n        ) = calculateIntegralTotalSupply(tokenAddress, blockTime);\\r\\n\\r\\n        if (netChange != 0) {\\r\\n            // If the totalSupply will change then we store the new total supply, the integral total supply and the\\r\\n            // current block time. We know that this int256 conversion will not overflow because totalSupply is stored\\r\\n            // as a uint96 and checked in the next line.\\r\\n            int256 newTotalSupply = int256(totalSupply).add(netChange);\\r\\n            require(newTotalSupply >= 0 && uint256(newTotalSupply) < type(uint96).max); // dev: nToken supply overflow\\r\\n\\r\\n            mapping(address => nTokenTotalSupplyStorage) storage store = LibStorage.getNTokenTotalSupplyStorage();\\r\\n            nTokenTotalSupplyStorage storage nTokenStorage = store[tokenAddress];\\r\\n\\r\\n            nTokenStorage.totalSupply = uint96(newTotalSupply);\\r\\n            // NOTE: overflows checked in calculateIntegralTotalSupply\\r\\n            nTokenStorage.integralTotalSupply = uint128(integralTotalSupply);\\r\\n            nTokenStorage.lastSupplyChangeTime = uint32(blockTime);\\r\\n        }\\r\\n\\r\\n        return integralTotalSupply;\\r\\n    }\\r\\n\\r\\n    function setIncentiveEmissionRate(address tokenAddress, uint32 newEmissionsRate) internal {\\r\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\r\\n        nTokenContext storage context = store[tokenAddress];\\r\\n        context.incentiveAnnualEmissionRate = newEmissionsRate;\\r\\n    }\\r\\n\\r\\n    function setArrayLengthAndInitializedTime(\\r\\n        address tokenAddress,\\r\\n        uint8 arrayLength,\\r\\n        uint256 lastInitializedTime\\r\\n    ) internal {\\r\\n        require(lastInitializedTime >= 0 && uint256(lastInitializedTime) < type(uint32).max); // dev: next settle time overflow\\r\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\r\\n        nTokenContext storage context = store[tokenAddress];\\r\\n        context.lastInitializedTime = uint32(lastInitializedTime);\\r\\n        context.assetArrayLength = arrayLength;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the array of deposit shares and leverage thresholds for nTokens\\r\\n    function getDepositParameters(uint256 currencyId, uint256 maxMarketIndex)\\r\\n        internal\\r\\n        view\\r\\n        returns (int256[] memory depositShares, int256[] memory leverageThresholds)\\r\\n    {\\r\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenDepositStorage();\\r\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage depositParameters = store[currencyId];\\r\\n        (depositShares, leverageThresholds) = _getParameters(depositParameters, maxMarketIndex, false);\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the deposit parameters\\r\\n    /// @dev We pack the values in alternating between the two parameters into either one or two\\r\\n    // storage slots depending on the number of markets. This is to save storage reads when we use the parameters.\\r\\n    function setDepositParameters(\\r\\n        uint256 currencyId,\\r\\n        uint32[] calldata depositShares,\\r\\n        uint32[] calldata leverageThresholds\\r\\n    ) internal {\\r\\n        require(\\r\\n            depositShares.length <= Constants.MAX_TRADED_MARKET_INDEX,\\r\\n            \\\"PT: deposit share length\\\"\\r\\n        );\\r\\n        require(depositShares.length == leverageThresholds.length, \\\"PT: leverage share length\\\");\\r\\n\\r\\n        uint256 shareSum;\\r\\n        for (uint256 i; i < depositShares.length; i++) {\\r\\n            // This cannot overflow in uint 256 with 9 max slots\\r\\n            shareSum = shareSum + depositShares[i];\\r\\n            require(\\r\\n                leverageThresholds[i] > 0 && leverageThresholds[i] < Constants.RATE_PRECISION,\\r\\n                \\\"PT: leverage threshold\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // Total deposit share must add up to 100%\\r\\n        require(shareSum == uint256(Constants.DEPOSIT_PERCENT_BASIS), \\\"PT: deposit shares sum\\\");\\r\\n\\r\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenDepositStorage();\\r\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage depositParameters = store[currencyId];\\r\\n        _setParameters(depositParameters, depositShares, leverageThresholds);\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the initialization parameters for the markets, these are read only when markets\\r\\n    /// are initialized\\r\\n    function setInitializationParameters(\\r\\n        uint256 currencyId,\\r\\n        uint32[] calldata annualizedAnchorRates,\\r\\n        uint32[] calldata proportions\\r\\n    ) internal {\\r\\n        require(annualizedAnchorRates.length <= Constants.MAX_TRADED_MARKET_INDEX, \\\"PT: annualized anchor rates length\\\");\\r\\n        require(proportions.length == annualizedAnchorRates.length, \\\"PT: proportions length\\\");\\r\\n\\r\\n        for (uint256 i; i < proportions.length; i++) {\\r\\n            // Proportions must be between zero and the rate precision\\r\\n            require(annualizedAnchorRates[i] > 0, \\\"NT: anchor rate zero\\\");\\r\\n            require(\\r\\n                proportions[i] > 0 && proportions[i] < Constants.RATE_PRECISION,\\r\\n                \\\"PT: invalid proportion\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenInitStorage();\\r\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage initParameters = store[currencyId];\\r\\n        _setParameters(initParameters, annualizedAnchorRates, proportions);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the array of initialization parameters for a given currency.\\r\\n    function getInitializationParameters(uint256 currencyId, uint256 maxMarketIndex)\\r\\n        internal\\r\\n        view\\r\\n        returns (int256[] memory annualizedAnchorRates, int256[] memory proportions)\\r\\n    {\\r\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenInitStorage();\\r\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage initParameters = store[currencyId];\\r\\n        (annualizedAnchorRates, proportions) = _getParameters(initParameters, maxMarketIndex, true);\\r\\n    }\\r\\n\\r\\n    function _getParameters(\\r\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage slot,\\r\\n        uint256 maxMarketIndex,\\r\\n        bool noUnset\\r\\n    ) private view returns (int256[] memory, int256[] memory) {\\r\\n        uint256 index = 0;\\r\\n        int256[] memory array1 = new int256[](maxMarketIndex);\\r\\n        int256[] memory array2 = new int256[](maxMarketIndex);\\r\\n        for (uint256 i; i < maxMarketIndex; i++) {\\r\\n            array1[i] = slot[index];\\r\\n            index++;\\r\\n            array2[i] = slot[index];\\r\\n            index++;\\r\\n\\r\\n            if (noUnset) {\\r\\n                require(array1[i] > 0 && array2[i] > 0, \\\"PT: init value zero\\\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return (array1, array2);\\r\\n    }\\r\\n\\r\\n    function _setParameters(\\r\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage slot,\\r\\n        uint32[] calldata array1,\\r\\n        uint32[] calldata array2\\r\\n    ) private {\\r\\n        uint256 index = 0;\\r\\n        for (uint256 i = 0; i < array1.length; i++) {\\r\\n            slot[index] = array1[i];\\r\\n            index++;\\r\\n\\r\\n            slot[index] = array2[i];\\r\\n            index++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function loadNTokenPortfolioNoCashGroup(nTokenPortfolio memory nToken, uint16 currencyId)\\r\\n        internal\\r\\n        view\\r\\n    {\\r\\n        nToken.tokenAddress = nTokenAddress(currencyId);\\r\\n        // prettier-ignore\\r\\n        (\\r\\n            /* currencyId */,\\r\\n            /* incentiveRate */,\\r\\n            uint256 lastInitializedTime,\\r\\n            uint8 assetArrayLength,\\r\\n            bytes5 parameters\\r\\n        ) = getNTokenContext(nToken.tokenAddress);\\r\\n\\r\\n        // prettier-ignore\\r\\n        (\\r\\n            uint256 totalSupply,\\r\\n            /* integralTotalSupply */,\\r\\n            /* lastSupplyChangeTime */\\r\\n        ) = getStoredNTokenSupplyFactors(nToken.tokenAddress);\\r\\n\\r\\n        nToken.lastInitializedTime = lastInitializedTime;\\r\\n        nToken.totalSupply = int256(totalSupply);\\r\\n        nToken.parameters = parameters;\\r\\n\\r\\n        nToken.portfolioState = PortfolioHandler.buildPortfolioState(\\r\\n            nToken.tokenAddress,\\r\\n            assetArrayLength,\\r\\n            0\\r\\n        );\\r\\n\\r\\n        // prettier-ignore\\r\\n        (\\r\\n            nToken.cashBalance,\\r\\n            /* nTokenBalance */,\\r\\n            /* lastClaimTime */,\\r\\n            /* lastClaimIntegralSupply */\\r\\n        ) = BalanceHandler.getBalanceStorage(nToken.tokenAddress, currencyId);\\r\\n    }\\r\\n\\r\\n    /// @notice Uses buildCashGroupStateful\\r\\n    function loadNTokenPortfolioStateful(nTokenPortfolio memory nToken, uint16 currencyId)\\r\\n        internal\\r\\n    {\\r\\n        loadNTokenPortfolioNoCashGroup(nToken, currencyId);\\r\\n        nToken.cashGroup = CashGroup.buildCashGroupStateful(currencyId);\\r\\n    }\\r\\n\\r\\n    /// @notice Uses buildCashGroupView\\r\\n    function loadNTokenPortfolioView(nTokenPortfolio memory nToken, uint16 currencyId)\\r\\n        internal\\r\\n        view\\r\\n    {\\r\\n        loadNTokenPortfolioNoCashGroup(nToken, currencyId);\\r\\n        nToken.cashGroup = CashGroup.buildCashGroupView(currencyId);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the next settle time for the nToken which is 1 quarter away\\r\\n    function getNextSettleTime(nTokenPortfolio memory nToken) internal pure returns (uint256) {\\r\\n        if (nToken.lastInitializedTime == 0) return 0;\\r\\n        return DateTime.getReferenceTime(nToken.lastInitializedTime) + Constants.QUARTER;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the nToken present value denominated in asset terms.\\r\\n    function getNTokenAssetPV(nTokenPortfolio memory nToken, uint256 blockTime)\\r\\n        internal\\r\\n        view\\r\\n        returns (int256)\\r\\n    {\\r\\n        int256 totalAssetPV;\\r\\n        int256 totalUnderlyingPV;\\r\\n\\r\\n        {\\r\\n            uint256 nextSettleTime = getNextSettleTime(nToken);\\r\\n            // If the first asset maturity has passed (the 3 month), this means that all the LTs must\\r\\n            // be settled except the 6 month (which is now the 3 month). We don't settle LTs except in\\r\\n            // initialize markets so we calculate the cash value of the portfolio here.\\r\\n            if (nextSettleTime <= blockTime) {\\r\\n                // NOTE: this condition should only be present for a very short amount of time, which is the window between\\r\\n                // when the markets are no longer tradable at quarter end and when the new markets have been initialized.\\r\\n                // We time travel back to one second before maturity to value the liquidity tokens. Although this value is\\r\\n                // not strictly correct the different should be quite slight. We do this to ensure that free collateral checks\\r\\n                // for withdraws and liquidations can still be processed. If this condition persists for a long period of time then\\r\\n                // the entire protocol will have serious problems as markets will not be tradable.\\r\\n                blockTime = nextSettleTime - 1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Since we are not doing a risk adjusted valuation here we do not need to net off residual fCash\\r\\n        // balances in the future before discounting to present. If we did, then the ifCash assets would\\r\\n        // have to be in the portfolio array first. PV here is denominated in asset cash terms, not in\\r\\n        // underlying terms.\\r\\n        {\\r\\n            MarketParameters memory market;\\r\\n            for (uint256 i; i < nToken.portfolioState.storedAssets.length; i++) {\\r\\n                // NOTE: getLiquidityTokenValue can rewrite fCash values in memory, however, that does not\\r\\n                // happen in this call because there are no fCash values in the nToken portfolio.\\r\\n                (int256 assetCashClaim, int256 pv) =\\r\\n                    AssetHandler.getLiquidityTokenValue(\\r\\n                        i,\\r\\n                        nToken.cashGroup,\\r\\n                        market,\\r\\n                        nToken.portfolioState.storedAssets,\\r\\n                        blockTime,\\r\\n                        false\\r\\n                    );\\r\\n\\r\\n                totalAssetPV = totalAssetPV.add(assetCashClaim);\\r\\n                totalUnderlyingPV = totalUnderlyingPV.add(pv);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Then iterate over bitmapped assets and get present value\\r\\n        // prettier-ignore\\r\\n        (\\r\\n            int256 bitmapPv, \\r\\n            /* hasDebt */\\r\\n        ) = BitmapAssetsHandler.getifCashNetPresentValue(\\r\\n            nToken.tokenAddress,\\r\\n            nToken.cashGroup.currencyId,\\r\\n            nToken.lastInitializedTime,\\r\\n            blockTime,\\r\\n            nToken.cashGroup,\\r\\n            false\\r\\n        );\\r\\n        totalUnderlyingPV = totalUnderlyingPV.add(bitmapPv);\\r\\n\\r\\n        // Return the total present value denominated in asset terms\\r\\n        totalAssetPV = totalAssetPV\\r\\n            .add(nToken.cashGroup.assetRate.convertFromUnderlying(totalUnderlyingPV))\\r\\n            .add(nToken.cashBalance);\\r\\n\\r\\n        return totalAssetPV;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/markets/AssetRate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\nimport \\\"../../global/LibStorage.sol\\\";\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"interfaces/notional/AssetRateAdapter.sol\\\";\\r\\n\\r\\nlibrary AssetRate {\\r\\n    using SafeInt256 for int256;\\r\\n    event SetSettlementRate(uint256 indexed currencyId, uint256 indexed maturity, uint128 rate);\\r\\n\\r\\n    // Asset rates are in 1e18 decimals (cToken exchange rates), internal balances\\r\\n    // are in 1e8 decimals. Therefore we leave this as 1e18 / 1e8 = 1e10\\r\\n    int256 private constant ASSET_RATE_DECIMAL_DIFFERENCE = 1e10;\\r\\n\\r\\n    /// @notice Converts an internal asset cash value to its underlying token value.\\r\\n    /// @param ar exchange rate object between asset and underlying\\r\\n    /// @param assetBalance amount to convert to underlying\\r\\n    function convertToUnderlying(AssetRateParameters memory ar, int256 assetBalance)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int256)\\r\\n    {\\r\\n        // Calculation here represents:\\r\\n        // rate * balance * internalPrecision / rateDecimals * underlyingPrecision\\r\\n        int256 underlyingBalance = ar.rate\\r\\n            .mul(assetBalance)\\r\\n            .div(ASSET_RATE_DECIMAL_DIFFERENCE)\\r\\n            .div(ar.underlyingDecimals);\\r\\n\\r\\n        return underlyingBalance;\\r\\n    }\\r\\n\\r\\n    /// @notice Converts an internal underlying cash value to its asset cash value\\r\\n    /// @param ar exchange rate object between asset and underlying\\r\\n    /// @param underlyingBalance amount to convert to asset cash, denominated in internal token precision\\r\\n    function convertFromUnderlying(AssetRateParameters memory ar, int256 underlyingBalance)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int256)\\r\\n    {\\r\\n        // Calculation here represents:\\r\\n        // rateDecimals * balance * underlyingPrecision / rate * internalPrecision\\r\\n        int256 assetBalance = underlyingBalance\\r\\n            .mul(ASSET_RATE_DECIMAL_DIFFERENCE)\\r\\n            .mul(ar.underlyingDecimals)\\r\\n            .div(ar.rate);\\r\\n\\r\\n        return assetBalance;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the current per block supply rate, is used when calculating oracle rates\\r\\n    /// for idiosyncratic fCash with a shorter duration than the 3 month maturity.\\r\\n    function getSupplyRate(AssetRateParameters memory ar) internal view returns (uint256) {\\r\\n        // If the rate oracle is not set, the asset is not interest bearing and has an oracle rate of zero.\\r\\n        if (address(ar.rateOracle) == address(0)) return 0;\\r\\n\\r\\n        uint256 rate = ar.rateOracle.getAnnualizedSupplyRate();\\r\\n        // Zero supply rate is valid since this is an interest rate, we do not divide by\\r\\n        // the supply rate so we do not get div by zero errors.\\r\\n        require(rate >= 0); // dev: invalid supply rate\\r\\n\\r\\n        return rate;\\r\\n    }\\r\\n\\r\\n    function _getAssetRateStorage(uint256 currencyId)\\r\\n        private\\r\\n        view\\r\\n        returns (AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces)\\r\\n    {\\r\\n        mapping(uint256 => AssetRateStorage) storage store = LibStorage.getAssetRateStorage();\\r\\n        AssetRateStorage storage ar = store[currencyId];\\r\\n        rateOracle = AssetRateAdapter(ar.rateOracle);\\r\\n        underlyingDecimalPlaces = ar.underlyingDecimalPlaces;\\r\\n    }\\r\\n\\r\\n    /// @notice Gets an asset rate using a view function, does not accrue interest so the\\r\\n    /// exchange rate will not be up to date. Should only be used for non-stateful methods\\r\\n    function _getAssetRateView(uint256 currencyId)\\r\\n        private\\r\\n        view\\r\\n        returns (\\r\\n            int256,\\r\\n            AssetRateAdapter,\\r\\n            uint8\\r\\n        )\\r\\n    {\\r\\n        (AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces) = _getAssetRateStorage(currencyId);\\r\\n\\r\\n        int256 rate;\\r\\n        if (address(rateOracle) == address(0)) {\\r\\n            // If no rate oracle is set, then set this to the identity\\r\\n            rate = ASSET_RATE_DECIMAL_DIFFERENCE;\\r\\n            // This will get raised to 10^x and return 1, will not end up with div by zero\\r\\n            underlyingDecimalPlaces = 0;\\r\\n        } else {\\r\\n            rate = rateOracle.getExchangeRateView();\\r\\n            require(rate > 0); // dev: invalid exchange rate\\r\\n        }\\r\\n\\r\\n        return (rate, rateOracle, underlyingDecimalPlaces);\\r\\n    }\\r\\n\\r\\n    /// @notice Gets an asset rate using a stateful function, accrues interest so the\\r\\n    /// exchange rate will be up to date for the current block.\\r\\n    function _getAssetRateStateful(uint256 currencyId)\\r\\n        private\\r\\n        returns (\\r\\n            int256,\\r\\n            AssetRateAdapter,\\r\\n            uint8\\r\\n        )\\r\\n    {\\r\\n        (AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces) = _getAssetRateStorage(currencyId);\\r\\n\\r\\n        int256 rate;\\r\\n        if (address(rateOracle) == address(0)) {\\r\\n            // If no rate oracle is set, then set this to the identity\\r\\n            rate = ASSET_RATE_DECIMAL_DIFFERENCE;\\r\\n            // This will get raised to 10^x and return 1, will not end up with div by zero\\r\\n            underlyingDecimalPlaces = 0;\\r\\n        } else {\\r\\n            rate = rateOracle.getExchangeRateStateful();\\r\\n            require(rate > 0); // dev: invalid exchange rate\\r\\n        }\\r\\n\\r\\n        return (rate, rateOracle, underlyingDecimalPlaces);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns an asset rate object using the view method\\r\\n    function buildAssetRateView(uint256 currencyId)\\r\\n        internal\\r\\n        view\\r\\n        returns (AssetRateParameters memory)\\r\\n    {\\r\\n        (int256 rate, AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces) =\\r\\n            _getAssetRateView(currencyId);\\r\\n\\r\\n        return\\r\\n            AssetRateParameters({\\r\\n                rateOracle: rateOracle,\\r\\n                rate: rate,\\r\\n                // No overflow, restricted on storage\\r\\n                underlyingDecimals: int256(10**underlyingDecimalPlaces)\\r\\n            });\\r\\n    }\\r\\n\\r\\n    /// @notice Returns an asset rate object using the stateful method\\r\\n    function buildAssetRateStateful(uint256 currencyId)\\r\\n        internal\\r\\n        returns (AssetRateParameters memory)\\r\\n    {\\r\\n        (int256 rate, AssetRateAdapter rateOracle, uint8 underlyingDecimalPlaces) =\\r\\n            _getAssetRateStateful(currencyId);\\r\\n\\r\\n        return\\r\\n            AssetRateParameters({\\r\\n                rateOracle: rateOracle,\\r\\n                rate: rate,\\r\\n                // No overflow, restricted on storage\\r\\n                underlyingDecimals: int256(10**underlyingDecimalPlaces)\\r\\n            });\\r\\n    }\\r\\n\\r\\n    /// @dev Gets a settlement rate object\\r\\n    function _getSettlementRateStorage(uint256 currencyId, uint256 maturity)\\r\\n        private\\r\\n        view\\r\\n        returns (\\r\\n            int256 settlementRate,\\r\\n            uint8 underlyingDecimalPlaces\\r\\n        )\\r\\n    {\\r\\n        mapping(uint256 => mapping(uint256 => SettlementRateStorage)) storage store = LibStorage.getSettlementRateStorage();\\r\\n        SettlementRateStorage storage rateStorage = store[currencyId][maturity];\\r\\n        settlementRate = rateStorage.settlementRate;\\r\\n        underlyingDecimalPlaces = rateStorage.underlyingDecimalPlaces;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns a settlement rate object using the view method\\r\\n    function buildSettlementRateView(uint256 currencyId, uint256 maturity)\\r\\n        internal\\r\\n        view\\r\\n        returns (AssetRateParameters memory)\\r\\n    {\\r\\n        // prettier-ignore\\r\\n        (\\r\\n            int256 settlementRate,\\r\\n            uint8 underlyingDecimalPlaces\\r\\n        ) = _getSettlementRateStorage(currencyId, maturity);\\r\\n\\r\\n        // Asset exchange rates cannot be zero\\r\\n        if (settlementRate == 0) {\\r\\n            // If settlement rate has not been set then we need to fetch it\\r\\n            // prettier-ignore\\r\\n            (\\r\\n                settlementRate,\\r\\n                /* address */,\\r\\n                underlyingDecimalPlaces\\r\\n            ) = _getAssetRateView(currencyId);\\r\\n        }\\r\\n\\r\\n        return AssetRateParameters(\\r\\n            AssetRateAdapter(address(0)),\\r\\n            settlementRate,\\r\\n            // No overflow, restricted on storage\\r\\n            int256(10**underlyingDecimalPlaces)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Returns a settlement rate object and sets the rate if it has not been set yet\\r\\n    function buildSettlementRateStateful(\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime\\r\\n    ) internal returns (AssetRateParameters memory) {\\r\\n        (int256 settlementRate, uint8 underlyingDecimalPlaces) =\\r\\n            _getSettlementRateStorage(currencyId, maturity);\\r\\n\\r\\n        if (settlementRate == 0) {\\r\\n            // Settlement rate has not yet been set, set it in this branch\\r\\n            AssetRateAdapter rateOracle;\\r\\n            // If rate oracle == 0 then this will return the identity settlement rate\\r\\n            // prettier-ignore\\r\\n            (\\r\\n                settlementRate,\\r\\n                rateOracle,\\r\\n                underlyingDecimalPlaces\\r\\n            ) = _getAssetRateStateful(currencyId);\\r\\n\\r\\n            if (address(rateOracle) != address(0)) {\\r\\n                mapping(uint256 => mapping(uint256 => SettlementRateStorage)) storage store = LibStorage.getSettlementRateStorage();\\r\\n                // Only need to set settlement rates when the rate oracle is set (meaning the asset token has\\r\\n                // a conversion rate to an underlying). If not set then the asset cash always settles to underlying at a 1-1\\r\\n                // rate since they are the same.\\r\\n                require(blockTime != 0 && blockTime <= type(uint40).max); // dev: settlement rate timestamp overflow\\r\\n                require(0 < settlementRate && settlementRate <= type(uint128).max); // dev: settlement rate overflow\\r\\n\\r\\n                SettlementRateStorage storage rateStorage = store[currencyId][maturity];\\r\\n                rateStorage.blockTime = uint40(blockTime);\\r\\n                rateStorage.settlementRate = uint128(settlementRate);\\r\\n                rateStorage.underlyingDecimalPlaces = underlyingDecimalPlaces;\\r\\n                emit SetSettlementRate(currencyId, maturity, uint128(settlementRate));\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return AssetRateParameters(\\r\\n            AssetRateAdapter(address(0)),\\r\\n            settlementRate,\\r\\n            // No overflow, restricted on storage\\r\\n            int256(10**underlyingDecimalPlaces)\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/balances/BalanceHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./Incentives.sol\\\";\\r\\nimport \\\"./TokenHandler.sol\\\";\\r\\nimport \\\"../AccountContextHandler.sol\\\";\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../math/FloatingPoint56.sol\\\";\\r\\n\\r\\nlibrary BalanceHandler {\\r\\n    using SafeInt256 for int256;\\r\\n    using TokenHandler for Token;\\r\\n    using AssetRate for AssetRateParameters;\\r\\n    using AccountContextHandler for AccountContext;\\r\\n\\r\\n    /// @notice Emitted when a cash balance changes\\r\\n    event CashBalanceChange(address indexed account, uint16 indexed currencyId, int256 netCashChange);\\r\\n    /// @notice Emitted when nToken supply changes (not the same as transfers)\\r\\n    event nTokenSupplyChange(address indexed account, uint16 indexed currencyId, int256 tokenSupplyChange);\\r\\n    /// @notice Emitted when reserve fees are accrued\\r\\n    event ReserveFeeAccrued(uint16 indexed currencyId, int256 fee);\\r\\n\\r\\n    /// @notice Deposits asset tokens into an account\\r\\n    /// @dev Handles two special cases when depositing tokens into an account.\\r\\n    ///  - If a token has transfer fees then the amount specified does not equal the amount that the contract\\r\\n    ///    will receive. Complete the deposit here rather than in finalize so that the contract has the correct\\r\\n    ///    balance to work with.\\r\\n    ///  - Force a transfer before finalize to allow a different account to deposit into an account\\r\\n    /// @return Returns two values:\\r\\n    ///  - assetAmountInternal which is the converted asset amount accounting for transfer fees\\r\\n    ///  - assetAmountTransferred which is the internal precision amount transferred into the account\\r\\n    function depositAssetToken(\\r\\n        BalanceState memory balanceState,\\r\\n        address account,\\r\\n        int256 assetAmountExternal,\\r\\n        bool forceTransfer\\r\\n    ) internal returns (int256) {\\r\\n        if (assetAmountExternal == 0) return 0;\\r\\n        require(assetAmountExternal > 0); // dev: deposit asset token amount negative\\r\\n        Token memory token = TokenHandler.getAssetToken(balanceState.currencyId);\\r\\n        int256 assetAmountInternal = token.convertToInternal(assetAmountExternal);\\r\\n\\r\\n        // Force transfer is used to complete the transfer before going to finalize\\r\\n        if (token.hasTransferFee || forceTransfer) {\\r\\n            // If the token has a transfer fee the deposit amount may not equal the actual amount\\r\\n            // that the contract will receive. We handle the deposit here and then update the netCashChange\\r\\n            // accordingly which is denominated in internal precision.\\r\\n            int256 assetAmountExternalPrecisionFinal = token.transfer(account, assetAmountExternal);\\r\\n            // Convert the external precision to internal, it's possible that we lose dust amounts here but\\r\\n            // this is unavoidable because we do not know how transfer fees are calculated.\\r\\n            assetAmountInternal = token.convertToInternal(assetAmountExternalPrecisionFinal);\\r\\n            // Transfer has been called\\r\\n            balanceState.netCashChange = balanceState.netCashChange.add(assetAmountInternal);\\r\\n\\r\\n            return assetAmountInternal;\\r\\n        } else {\\r\\n            // Otherwise add the asset amount here. It may be net off later and we want to only do\\r\\n            // a single transfer during the finalize method. Use internal precision to ensure that internal accounting\\r\\n            // and external account remain in sync.\\r\\n            // Transfer will be deferred\\r\\n            balanceState.netAssetTransferInternalPrecision = balanceState\\r\\n                .netAssetTransferInternalPrecision\\r\\n                .add(assetAmountInternal);\\r\\n\\r\\n            // Returns the converted assetAmountExternal to the internal amount\\r\\n            return assetAmountInternal;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Handle deposits of the underlying token\\r\\n    /// @dev In this case we must wrap the underlying token into an asset token, ensuring that we do not end up\\r\\n    /// with any underlying tokens left as dust on the contract.\\r\\n    function depositUnderlyingToken(\\r\\n        BalanceState memory balanceState,\\r\\n        address account,\\r\\n        int256 underlyingAmountExternal\\r\\n    ) internal returns (int256) {\\r\\n        if (underlyingAmountExternal == 0) return 0;\\r\\n        require(underlyingAmountExternal > 0); // dev: deposit underlying token negative\\r\\n\\r\\n        Token memory underlyingToken = TokenHandler.getUnderlyingToken(balanceState.currencyId);\\r\\n        // This is the exact amount of underlying tokens the account has in external precision.\\r\\n        if (underlyingToken.tokenType == TokenType.Ether) {\\r\\n            // Underflow checked above\\r\\n            require(uint256(underlyingAmountExternal) == msg.value, \\\"ETH Balance\\\");\\r\\n        } else {\\r\\n            underlyingAmountExternal = underlyingToken.transfer(account, underlyingAmountExternal);\\r\\n        }\\r\\n\\r\\n        Token memory assetToken = TokenHandler.getAssetToken(balanceState.currencyId);\\r\\n        // Tokens that are not mintable like cTokens will be deposited as assetTokens\\r\\n        require(assetToken.tokenType == TokenType.cToken || assetToken.tokenType == TokenType.cETH); // dev: deposit underlying token invalid token type\\r\\n        int256 assetTokensReceivedExternalPrecision =\\r\\n            assetToken.mint(SafeInt256.toUint(underlyingAmountExternal));\\r\\n\\r\\n        // cTokens match INTERNAL_TOKEN_PRECISION so this will short circuit but we leave this here in case a different\\r\\n        // type of asset token is listed in the future. It's possible if those tokens have a different precision dust may\\r\\n        // accrue but that is not relevant now.\\r\\n        int256 assetTokensReceivedInternal =\\r\\n            assetToken.convertToInternal(assetTokensReceivedExternalPrecision);\\r\\n        // Transfer / mint has taken effect\\r\\n        balanceState.netCashChange = balanceState.netCashChange.add(assetTokensReceivedInternal);\\r\\n\\r\\n        return assetTokensReceivedInternal;\\r\\n    }\\r\\n\\r\\n    /// @notice Finalizes an account's balances, handling any transfer logic required\\r\\n    /// @dev This method SHOULD NOT be used for nToken accounts, for that use setBalanceStorageForNToken\\r\\n    /// as the nToken is limited in what types of balances it can hold.\\r\\n    function finalize(\\r\\n        BalanceState memory balanceState,\\r\\n        address account,\\r\\n        AccountContext memory accountContext,\\r\\n        bool redeemToUnderlying\\r\\n    ) internal returns (int256 transferAmountExternal) {\\r\\n        bool mustUpdate;\\r\\n        if (balanceState.netNTokenTransfer < 0) {\\r\\n            require(\\r\\n                balanceState.storedNTokenBalance\\r\\n                    .add(balanceState.netNTokenSupplyChange)\\r\\n                    .add(balanceState.netNTokenTransfer) >= 0,\\r\\n                \\\"Neg nToken\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (balanceState.netAssetTransferInternalPrecision < 0) {\\r\\n            require(\\r\\n                balanceState.storedCashBalance\\r\\n                    .add(balanceState.netCashChange)\\r\\n                    .add(balanceState.netAssetTransferInternalPrecision) >= 0,\\r\\n                \\\"Neg Cash\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // Transfer amount is checked inside finalize transfers in case when converting to external we\\r\\n        // round down to zero. This returns the actual net transfer in internal precision as well.\\r\\n        (\\r\\n            transferAmountExternal,\\r\\n            balanceState.netAssetTransferInternalPrecision\\r\\n        ) = _finalizeTransfers(balanceState, account, redeemToUnderlying);\\r\\n        // No changes to total cash after this point\\r\\n        int256 totalCashChange = balanceState.netCashChange.add(balanceState.netAssetTransferInternalPrecision);\\r\\n\\r\\n        if (totalCashChange != 0) {\\r\\n            balanceState.storedCashBalance = balanceState.storedCashBalance.add(totalCashChange);\\r\\n            mustUpdate = true;\\r\\n\\r\\n            emit CashBalanceChange(\\r\\n                account,\\r\\n                uint16(balanceState.currencyId),\\r\\n                totalCashChange\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (balanceState.netNTokenTransfer != 0 || balanceState.netNTokenSupplyChange != 0) {\\r\\n            // It's crucial that incentives are claimed before we do any sort of nToken transfer to prevent gaming\\r\\n            // of the system. This method will update the lastClaimTime time and lastIntegralTotalSupply in balance\\r\\n            // state in place.\\r\\n            Incentives.claimIncentives(balanceState, account);\\r\\n\\r\\n            // nTokens are within the notional system so we can update balances directly.\\r\\n            balanceState.storedNTokenBalance = balanceState\\r\\n                .storedNTokenBalance\\r\\n                .add(balanceState.netNTokenTransfer)\\r\\n                .add(balanceState.netNTokenSupplyChange);\\r\\n\\r\\n            if (balanceState.netNTokenSupplyChange != 0) {\\r\\n                emit nTokenSupplyChange(\\r\\n                    account,\\r\\n                    uint16(balanceState.currencyId),\\r\\n                    balanceState.netNTokenSupplyChange\\r\\n                );\\r\\n            }\\r\\n\\r\\n            mustUpdate = true;\\r\\n        }\\r\\n\\r\\n        if (mustUpdate) {\\r\\n            _setBalanceStorage(\\r\\n                account,\\r\\n                balanceState.currencyId,\\r\\n                balanceState.storedCashBalance,\\r\\n                balanceState.storedNTokenBalance,\\r\\n                balanceState.lastClaimTime,\\r\\n                balanceState.lastClaimIntegralSupply\\r\\n            );\\r\\n        }\\r\\n\\r\\n        accountContext.setActiveCurrency(\\r\\n            balanceState.currencyId,\\r\\n            // Set active currency to true if either balance is non-zero\\r\\n            balanceState.storedCashBalance != 0 || balanceState.storedNTokenBalance != 0,\\r\\n            Constants.ACTIVE_IN_BALANCES\\r\\n        );\\r\\n\\r\\n        if (balanceState.storedCashBalance < 0) {\\r\\n            // NOTE: HAS_CASH_DEBT cannot be extinguished except by a free collateral check where all balances\\r\\n            // are examined\\r\\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the amount transferred in underlying or asset terms depending on how redeem to underlying\\r\\n    /// is specified.\\r\\n    function _finalizeTransfers(\\r\\n        BalanceState memory balanceState,\\r\\n        address account,\\r\\n        bool redeemToUnderlying\\r\\n    ) private returns (int256 actualTransferAmountExternal, int256 assetTransferAmountInternal) {\\r\\n        Token memory assetToken = TokenHandler.getAssetToken(balanceState.currencyId);\\r\\n        // Dust accrual to the protocol is possible if the token decimals is less than internal token precision.\\r\\n        // See the comments in TokenHandler.convertToExternal and TokenHandler.convertToInternal\\r\\n        int256 assetTransferAmountExternal =\\r\\n            assetToken.convertToExternal(balanceState.netAssetTransferInternalPrecision);\\r\\n\\r\\n        if (assetTransferAmountExternal == 0) {\\r\\n            return (0, 0);\\r\\n        } else if (redeemToUnderlying && assetTransferAmountExternal < 0) {\\r\\n            // We only do the redeem to underlying if the asset transfer amount is less than zero. If it is greater than\\r\\n            // zero then we will do a normal transfer instead.\\r\\n\\r\\n            // We use the internal amount here and then scale it to the external amount so that there is\\r\\n            // no loss of precision between our internal accounting and the external account. In this case\\r\\n            // there will be no dust accrual in underlying tokens since we will transfer the exact amount\\r\\n            // of underlying that was received.\\r\\n            Token memory underlyingToken = TokenHandler.getUnderlyingToken(balanceState.currencyId);\\r\\n            // underlyingAmountExternal is converted from uint to int inside redeem, must be positive\\r\\n            int256 underlyingAmountExternal = assetToken.redeem(\\r\\n                underlyingToken,\\r\\n                uint256(assetTransferAmountExternal.neg())\\r\\n            );\\r\\n\\r\\n            // Withdraws the underlying amount out to the destination account\\r\\n            actualTransferAmountExternal = underlyingToken.transfer(\\r\\n                account,\\r\\n                underlyingAmountExternal.neg()\\r\\n            );\\r\\n            // In this case we're transferring underlying tokens, we want to convert the internal\\r\\n            // asset transfer amount to store in cash balances\\r\\n            assetTransferAmountInternal = assetToken.convertToInternal(assetTransferAmountExternal);\\r\\n        } else {\\r\\n            actualTransferAmountExternal = assetToken.transfer(account, assetTransferAmountExternal);\\r\\n            // Convert the actual transferred amount\\r\\n            assetTransferAmountInternal = assetToken.convertToInternal(actualTransferAmountExternal);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Special method for settling negative current cash debts. This occurs when an account\\r\\n    /// has a negative fCash balance settle to cash. A settler may come and force the account to borrow\\r\\n    /// at the prevailing 3 month rate\\r\\n    /// @dev Use this method to avoid any nToken and transfer logic in finalize which is unnecessary.\\r\\n    function setBalanceStorageForSettleCashDebt(\\r\\n        address account,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        int256 amountToSettleAsset,\\r\\n        AccountContext memory accountContext\\r\\n    ) internal returns (int256) {\\r\\n        require(amountToSettleAsset >= 0); // dev: amount to settle negative\\r\\n        (int256 cashBalance, int256 nTokenBalance, uint256 lastClaimTime, uint256 lastClaimIntegralSupply) =\\r\\n            getBalanceStorage(account, cashGroup.currencyId);\\r\\n\\r\\n        // Prevents settlement of positive balances\\r\\n        require(cashBalance < 0, \\\"Invalid settle balance\\\");\\r\\n        if (amountToSettleAsset == 0) {\\r\\n            // Symbolizes that the entire debt should be settled\\r\\n            amountToSettleAsset = cashBalance.neg();\\r\\n            cashBalance = 0;\\r\\n        } else {\\r\\n            // A partial settlement of the debt\\r\\n            require(amountToSettleAsset <= cashBalance.neg(), \\\"Invalid amount to settle\\\");\\r\\n            cashBalance = cashBalance.add(amountToSettleAsset);\\r\\n        }\\r\\n\\r\\n        // NOTE: we do not update HAS_CASH_DEBT here because it is possible that the other balances\\r\\n        // also have cash debts\\r\\n        if (cashBalance == 0 && nTokenBalance == 0) {\\r\\n            accountContext.setActiveCurrency(\\r\\n                cashGroup.currencyId,\\r\\n                false,\\r\\n                Constants.ACTIVE_IN_BALANCES\\r\\n            );\\r\\n        }\\r\\n\\r\\n        _setBalanceStorage(\\r\\n            account,\\r\\n            cashGroup.currencyId,\\r\\n            cashBalance,\\r\\n            nTokenBalance,\\r\\n            lastClaimTime,\\r\\n            lastClaimIntegralSupply\\r\\n        );\\r\\n\\r\\n        // Emit the event here, we do not call finalize\\r\\n        emit CashBalanceChange(account, cashGroup.currencyId, amountToSettleAsset);\\r\\n\\r\\n        return amountToSettleAsset;\\r\\n    }\\r\\n\\r\\n    /// @notice Helper method for settling the output of the SettleAssets method\\r\\n    function finalizeSettleAmounts(\\r\\n        address account,\\r\\n        AccountContext memory accountContext,\\r\\n        SettleAmount[] memory settleAmounts\\r\\n    ) internal {\\r\\n        for (uint256 i = 0; i < settleAmounts.length; i++) {\\r\\n            SettleAmount memory amt = settleAmounts[i];\\r\\n            if (amt.netCashChange == 0) continue;\\r\\n\\r\\n            (\\r\\n                int256 cashBalance,\\r\\n                int256 nTokenBalance,\\r\\n                uint256 lastClaimTime,\\r\\n                uint256 lastClaimIntegralSupply\\r\\n            ) = getBalanceStorage(account, amt.currencyId);\\r\\n\\r\\n            cashBalance = cashBalance.add(amt.netCashChange);\\r\\n            accountContext.setActiveCurrency(\\r\\n                amt.currencyId,\\r\\n                cashBalance != 0 || nTokenBalance != 0,\\r\\n                Constants.ACTIVE_IN_BALANCES\\r\\n            );\\r\\n\\r\\n            if (cashBalance < 0) {\\r\\n                accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\\r\\n            }\\r\\n\\r\\n            emit CashBalanceChange(\\r\\n                account,\\r\\n                uint16(amt.currencyId),\\r\\n                amt.netCashChange\\r\\n            );\\r\\n\\r\\n            _setBalanceStorage(\\r\\n                account,\\r\\n                amt.currencyId,\\r\\n                cashBalance,\\r\\n                nTokenBalance,\\r\\n                lastClaimTime,\\r\\n                lastClaimIntegralSupply\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Special method for setting balance storage for nToken\\r\\n    function setBalanceStorageForNToken(\\r\\n        address nTokenAddress,\\r\\n        uint256 currencyId,\\r\\n        int256 cashBalance\\r\\n    ) internal {\\r\\n        require(cashBalance >= 0); // dev: invalid nToken cash balance\\r\\n        _setBalanceStorage(nTokenAddress, currencyId, cashBalance, 0, 0, 0);\\r\\n    }\\r\\n\\r\\n    /// @notice increments fees to the reserve\\r\\n    function incrementFeeToReserve(uint256 currencyId, int256 fee) internal {\\r\\n        require(fee >= 0); // dev: invalid fee\\r\\n        // prettier-ignore\\r\\n        (int256 totalReserve, /* */, /* */, /* */) = getBalanceStorage(Constants.RESERVE, currencyId);\\r\\n        totalReserve = totalReserve.add(fee);\\r\\n        _setBalanceStorage(Constants.RESERVE, currencyId, totalReserve, 0, 0, 0);\\r\\n        emit ReserveFeeAccrued(uint16(currencyId), fee);\\r\\n    }\\r\\n\\r\\n    /// @notice Sets internal balance storage.\\r\\n    function _setBalanceStorage(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        int256 cashBalance,\\r\\n        int256 nTokenBalance,\\r\\n        uint256 lastClaimTime,\\r\\n        uint256 lastClaimIntegralSupply\\r\\n    ) private {\\r\\n        mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage();\\r\\n        BalanceStorage storage balanceStorage = store[account][currencyId];\\r\\n\\r\\n        require(cashBalance >= type(int88).min && cashBalance <= type(int88).max); // dev: stored cash balance overflow\\r\\n        // Allows for 12 quadrillion nToken balance in 1e8 decimals before overflow\\r\\n        require(nTokenBalance >= 0 && nTokenBalance <= type(uint80).max); // dev: stored nToken balance overflow\\r\\n        require(lastClaimTime <= type(uint32).max); // dev: last claim time overflow\\r\\n\\r\\n        balanceStorage.nTokenBalance = uint80(nTokenBalance);\\r\\n        balanceStorage.lastClaimTime = uint32(lastClaimTime);\\r\\n        balanceStorage.cashBalance = int88(cashBalance);\\r\\n\\r\\n        // Last claim supply is stored in a \\\"floating point\\\" storage slot that does not maintain exact precision but\\r\\n        // is also not limited by storage overflows. `packTo56Bits` will ensure that the the returned value will fit\\r\\n        // in 56 bits (7 bytes)\\r\\n        balanceStorage.packedLastClaimIntegralSupply = FloatingPoint56.packTo56Bits(lastClaimIntegralSupply);\\r\\n    }\\r\\n\\r\\n    /// @notice Gets internal balance storage, nTokens are stored alongside cash balances\\r\\n    function getBalanceStorage(address account, uint256 currencyId)\\r\\n        internal\\r\\n        view\\r\\n        returns (\\r\\n            int256 cashBalance,\\r\\n            int256 nTokenBalance,\\r\\n            uint256 lastClaimTime,\\r\\n            uint256 lastClaimIntegralSupply\\r\\n        )\\r\\n    {\\r\\n        mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage();\\r\\n        BalanceStorage storage balanceStorage = store[account][currencyId];\\r\\n\\r\\n        nTokenBalance = balanceStorage.nTokenBalance;\\r\\n        lastClaimTime = balanceStorage.lastClaimTime;\\r\\n        lastClaimIntegralSupply = FloatingPoint56.unpackFrom56Bits(balanceStorage.packedLastClaimIntegralSupply);\\r\\n        cashBalance = balanceStorage.cashBalance;\\r\\n    }\\r\\n\\r\\n    /// @notice Loads a balance state memory object\\r\\n    /// @dev Balance state objects occupy a lot of memory slots, so this method allows\\r\\n    /// us to reuse them if possible\\r\\n    function loadBalanceState(\\r\\n        BalanceState memory balanceState,\\r\\n        address account,\\r\\n        uint16 currencyId,\\r\\n        AccountContext memory accountContext\\r\\n    ) internal view {\\r\\n        require(0 < currencyId && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id\\r\\n        balanceState.currencyId = currencyId;\\r\\n\\r\\n        if (accountContext.isActiveInBalances(currencyId)) {\\r\\n            (\\r\\n                balanceState.storedCashBalance,\\r\\n                balanceState.storedNTokenBalance,\\r\\n                balanceState.lastClaimTime,\\r\\n                balanceState.lastClaimIntegralSupply\\r\\n            ) = getBalanceStorage(account, currencyId);\\r\\n        } else {\\r\\n            balanceState.storedCashBalance = 0;\\r\\n            balanceState.storedNTokenBalance = 0;\\r\\n            balanceState.lastClaimTime = 0;\\r\\n            balanceState.lastClaimIntegralSupply = 0;\\r\\n        }\\r\\n\\r\\n        balanceState.netCashChange = 0;\\r\\n        balanceState.netAssetTransferInternalPrecision = 0;\\r\\n        balanceState.netNTokenTransfer = 0;\\r\\n        balanceState.netNTokenSupplyChange = 0;\\r\\n    }\\r\\n\\r\\n    /// @notice Used when manually claiming incentives in nTokenAction. Also sets the balance state\\r\\n    /// to storage to update the lastClaimTime and lastClaimIntegralSupply\\r\\n    function claimIncentivesManual(BalanceState memory balanceState, address account)\\r\\n        internal\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 incentivesClaimed = Incentives.claimIncentives(balanceState, account);\\r\\n        _setBalanceStorage(\\r\\n            account,\\r\\n            balanceState.currencyId,\\r\\n            balanceState.storedCashBalance,\\r\\n            balanceState.storedNTokenBalance,\\r\\n            balanceState.lastClaimTime,\\r\\n            balanceState.lastClaimIntegralSupply\\r\\n        );\\r\\n\\r\\n        return incentivesClaimed;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/balances/Incentives.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./TokenHandler.sol\\\";\\r\\nimport \\\"../nTokenHandler.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary Incentives {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeInt256 for int256;\\r\\n\\r\\n    /// @dev Notional incentivizes nTokens using the formula:\\r\\n    ///     incentivesToClaim = (tokenBalance / totalSupply) * emissionRatePerYear * proRataYears\\r\\n    ///     where proRataYears is:\\r\\n    ///         (timeSinceLastClaim / YEAR) * INTERNAL_TOKEN_PRECISION\\r\\n    /// @return (emissionRatePerYear * proRataYears), decimal basis is (1e8 * 1e8 = 1e16)\\r\\n    function _getIncentiveRate(uint256 timeSinceLastClaim, uint256 emissionRatePerYear)\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        // (timeSinceLastClaim * INTERNAL_TOKEN_PRECISION) / YEAR\\r\\n        uint256 proRataYears =\\r\\n            timeSinceLastClaim.mul(uint256(Constants.INTERNAL_TOKEN_PRECISION)).div(Constants.YEAR);\\r\\n\\r\\n        return proRataYears.mul(emissionRatePerYear);\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates the claimable incentives for a particular nToken and account\\r\\n    function calculateIncentivesToClaim(\\r\\n        address tokenAddress,\\r\\n        uint256 nTokenBalance,\\r\\n        uint256 lastClaimTime,\\r\\n        uint256 lastClaimIntegralSupply,\\r\\n        uint256 blockTime,\\r\\n        uint256 integralTotalSupply\\r\\n    ) internal view returns (uint256) {\\r\\n        if (lastClaimTime == 0 || lastClaimTime >= blockTime) return 0;\\r\\n\\r\\n        // prettier-ignore\\r\\n        (\\r\\n            /* currencyId */,\\r\\n            uint256 emissionRatePerYear,\\r\\n            /* initializedTime */,\\r\\n            /* assetArrayLength */,\\r\\n            /* parameters */\\r\\n        ) = nTokenHandler.getNTokenContext(tokenAddress);\\r\\n\\r\\n        // No overflow here, checked above\\r\\n        uint256 timeSinceLastClaim = blockTime - lastClaimTime;\\r\\n        uint256 incentiveRate =\\r\\n            _getIncentiveRate(\\r\\n                timeSinceLastClaim,\\r\\n                // Convert this to the appropriate denomination, emissionRatePerYear is denominated\\r\\n                // in whole tokens\\r\\n                emissionRatePerYear.mul(uint256(Constants.INTERNAL_TOKEN_PRECISION))\\r\\n            );\\r\\n\\r\\n        // Returns the average supply between now and the previous mint time using the integral of the total\\r\\n        // supply.\\r\\n        uint256 avgTotalSupply = integralTotalSupply.sub(lastClaimIntegralSupply).div(timeSinceLastClaim);\\r\\n        if (avgTotalSupply == 0) return 0;\\r\\n\\r\\n        uint256 incentivesToClaim = nTokenBalance.mul(incentiveRate).div(avgTotalSupply);\\r\\n        // incentiveRate has a decimal basis of 1e16 so divide by token precision to reduce to 1e8\\r\\n        incentivesToClaim = incentivesToClaim.div(uint256(Constants.INTERNAL_TOKEN_PRECISION));\\r\\n\\r\\n        return incentivesToClaim;\\r\\n    }\\r\\n\\r\\n    /// @notice Incentives must be claimed every time nToken balance changes\\r\\n    function claimIncentives(BalanceState memory balanceState, address account)\\r\\n        internal\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 blockTime = block.timestamp;\\r\\n        address tokenAddress = nTokenHandler.nTokenAddress(balanceState.currencyId);\\r\\n        // This will set the new supply and return the previous integral total supply\\r\\n        uint256 integralTotalSupply = nTokenHandler.changeNTokenSupply(\\r\\n            tokenAddress,\\r\\n            balanceState.netNTokenSupplyChange,\\r\\n            blockTime\\r\\n        );\\r\\n\\r\\n        uint256 incentivesToClaim = calculateIncentivesToClaim(\\r\\n            tokenAddress,\\r\\n            balanceState.storedNTokenBalance.toUint(),\\r\\n            balanceState.lastClaimTime,\\r\\n            balanceState.lastClaimIntegralSupply,\\r\\n            blockTime,\\r\\n            integralTotalSupply\\r\\n        );\\r\\n\\r\\n        balanceState.lastClaimTime = blockTime;\\r\\n        balanceState.lastClaimIntegralSupply = integralTotalSupply;\\r\\n\\r\\n        if (incentivesToClaim > 0) TokenHandler.transferIncentive(account, incentivesToClaim);\\r\\n\\r\\n        return incentivesToClaim;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/math/SafeInt256.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"../global/Constants.sol\\\";\\r\\n\\r\\nlibrary SafeInt256 {\\r\\n    int256 private constant _INT256_MIN = type(int256).min;\\r\\n\\r\\n    /// @dev Returns the multiplication of two signed integers, reverting on\\r\\n    /// overflow.\\r\\n\\r\\n    /// Counterpart to Solidity's `*` operator.\\r\\n\\r\\n    /// Requirements:\\r\\n\\r\\n    /// - Multiplication cannot overflow.\\r\\n\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256 c) {\\r\\n        c = a * b;\\r\\n        if (a == -1) require (b == 0 || c / b == a);\\r\\n        else require (a == 0 || c / a == b);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the integer division of two signed integers. Reverts on\\r\\n    /// division by zero. The result is rounded towards zero.\\r\\n\\r\\n    /// Counterpart to Solidity's `/` operator. Note: this function uses a\\r\\n    /// `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n    /// uses an invalid opcode to revert (consuming all remaining gas).\\r\\n\\r\\n    /// Requirements:\\r\\n\\r\\n    /// - The divisor cannot be zero.\\r\\n\\r\\n    function div(int256 a, int256 b) internal pure returns (int256 c) {\\r\\n        require(!(b == -1 && a == _INT256_MIN)); // dev: int256 div overflow\\r\\n        // NOTE: solidity will automatically revert on divide by zero\\r\\n        c = a / b;\\r\\n    }\\r\\n\\r\\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\\r\\n        //  taken from uniswap v3\\r\\n        require((z = x - y) <= x == (y >= 0));\\r\\n    }\\r\\n\\r\\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\\r\\n        require((z = x + y) >= x == (y >= 0));\\r\\n    }\\r\\n\\r\\n    function neg(int256 x) internal pure returns (int256 y) {\\r\\n        return mul(-1, x);\\r\\n    }\\r\\n\\r\\n    function abs(int256 x) internal pure returns (int256) {\\r\\n        if (x < 0) return neg(x);\\r\\n        else return x;\\r\\n    }\\r\\n\\r\\n    function subNoNeg(int256 x, int256 y) internal pure returns (int256 z) {\\r\\n        z = sub(x, y);\\r\\n        require(z >= 0); // dev: int256 sub to negative\\r\\n\\r\\n        return z;\\r\\n    }\\r\\n\\r\\n    /// @dev Calculates x * RATE_PRECISION / y while checking overflows\\r\\n    function divInRatePrecision(int256 x, int256 y) internal pure returns (int256) {\\r\\n        return div(mul(x, Constants.RATE_PRECISION), y);\\r\\n    }\\r\\n\\r\\n    /// @dev Calculates x * y / RATE_PRECISION while checking overflows\\r\\n    function mulInRatePrecision(int256 x, int256 y) internal pure returns (int256) {\\r\\n        return div(mul(x, y), Constants.RATE_PRECISION);\\r\\n    }\\r\\n\\r\\n    function toUint(int256 x) internal pure returns (uint256) {\\r\\n        require(x >= 0);\\r\\n        return uint256(x);\\r\\n    }\\r\\n\\r\\n    function toInt(uint256 x) internal pure returns (int256) {\\r\\n        require (x <= uint256(type(int256).max)); // dev: toInt overflow\\r\\n        return int256(x);\\r\\n    }\\r\\n\\r\\n    function max(int256 x, int256 y) internal pure returns (int256) {\\r\\n        return x > y ? x : y;\\r\\n    }\\r\\n\\r\\n    function min(int256 x, int256 y) internal pure returns (int256) {\\r\\n        return x < y ? x : y;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/external/FreeCollateralExternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../internal/AccountContextHandler.sol\\\";\\r\\nimport \\\"../internal/valuation/FreeCollateral.sol\\\";\\r\\n\\r\\n/// @title Externally deployed library for free collateral calculations\\r\\nlibrary FreeCollateralExternal {\\r\\n    using AccountContextHandler for AccountContext;\\r\\n\\r\\n    /// @notice Returns the ETH denominated free collateral of an account, represents the amount of\\r\\n    /// debt that the account can incur before liquidation. If an account's assets need to be settled this\\r\\n    /// will revert, either settle the account or use the off chain SDK to calculate free collateral.\\r\\n    /// @dev Called via the Views.sol method to return an account's free collateral. Does not work\\r\\n    /// for the nToken, the nToken does not have an account context.\\r\\n    /// @param account account to calculate free collateral for\\r\\n    /// @return total free collateral in ETH w/ 8 decimal places\\r\\n    /// @return array of net local values in asset values ordered by currency id\\r\\n    function getFreeCollateralView(address account)\\r\\n        external\\r\\n        view\\r\\n        returns (int256, int256[] memory)\\r\\n    {\\r\\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\\r\\n        // The internal free collateral function does not account for settled assets. The Notional SDK\\r\\n        // can calculate the free collateral off chain if required at this point.\\r\\n        require(!accountContext.mustSettleAssets(), \\\"Assets not settled\\\");\\r\\n        return FreeCollateral.getFreeCollateralView(account, accountContext, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates free collateral and will revert if it falls below zero. If the account context\\r\\n    /// must be updated due to changes in debt settings, will update. Cannot check free collateral if assets\\r\\n    /// need to be settled first.\\r\\n    /// @dev Cannot be called directly by users, used during various actions that require an FC check. Must be\\r\\n    /// called before the end of any transaction for accounts where FC can decrease.\\r\\n    /// @param account account to calculate free collateral for\\r\\n    function checkFreeCollateralAndRevert(address account) external {\\r\\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\\r\\n        require(!accountContext.mustSettleAssets(), \\\"Assets not settled\\\");\\r\\n\\r\\n        (int256 ethDenominatedFC, bool updateContext) =\\r\\n            FreeCollateral.getFreeCollateralStateful(account, accountContext, block.timestamp);\\r\\n\\r\\n        if (updateContext) {\\r\\n            accountContext.setAccountContext(account);\\r\\n        }\\r\\n\\r\\n        require(ethDenominatedFC >= 0, \\\"Insufficient free collateral\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates liquidation factors for an account\\r\\n    /// @dev Only called internally by liquidation actions, does some initial validation of currencies. If a currency is\\r\\n    /// specified that the account does not have, a asset available figure of zero will be returned. If this is the case then\\r\\n    /// liquidation actions will revert.\\r\\n    /// @dev an ntoken account will return 0 FC and revert if called\\r\\n    /// @param account account to liquidate\\r\\n    /// @param localCurrencyId currency that the debts are denominated in\\r\\n    /// @param collateralCurrencyId collateral currency to liquidate against, set to zero in the case of local currency liquidation\\r\\n    /// @return accountContext the accountContext of the liquidated account\\r\\n    /// @return factors struct of relevant factors for liquidation\\r\\n    /// @return portfolio the portfolio array of the account (bitmap accounts will return an empty array)\\r\\n    function getLiquidationFactors(\\r\\n        address account,\\r\\n        uint256 localCurrencyId,\\r\\n        uint256 collateralCurrencyId\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            AccountContext memory accountContext,\\r\\n            LiquidationFactors memory factors,\\r\\n            PortfolioAsset[] memory portfolio\\r\\n        )\\r\\n    {\\r\\n        accountContext = AccountContextHandler.getAccountContext(account);\\r\\n        if (accountContext.mustSettleAssets()) {\\r\\n            accountContext = SettleAssetsExternal.settleAccount(account, accountContext);\\r\\n        }\\r\\n\\r\\n        if (accountContext.isBitmapEnabled()) {\\r\\n            // A bitmap currency can only ever hold debt in this currency\\r\\n            require(localCurrencyId == accountContext.bitmapCurrencyId);\\r\\n        }\\r\\n\\r\\n        (factors, portfolio) = FreeCollateral.getLiquidationFactors(\\r\\n            account,\\r\\n            accountContext,\\r\\n            block.timestamp,\\r\\n            localCurrencyId,\\r\\n            collateralCurrencyId\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"interfaces/notional/nTokenERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\ninterface nTokenERC20 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\r\\n\\r\\n    function nTokenTotalSupply(address nTokenAddress) external view returns (uint256);\\r\\n\\r\\n    function nTokenTransferAllowance(\\r\\n        uint16 currencyId,\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function nTokenBalanceOf(uint16 currencyId, address account) external view returns (uint256);\\r\\n\\r\\n    function nTokenTransferApprove(\\r\\n        uint16 currencyId,\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function nTokenTransfer(\\r\\n        uint16 currencyId,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function nTokenTransferFrom(\\r\\n        uint16 currencyId,\\r\\n        address spender,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function nTokenTransferApproveAll(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function nTokenClaimIncentives() external returns (uint256);\\r\\n\\r\\n    function nTokenPresentValueAssetDenominated(uint16 currencyId) external view returns (int256);\\r\\n\\r\\n    function nTokenPresentValueUnderlyingDenominated(uint16 currencyId)\\r\\n        external\\r\\n        view\\r\\n        returns (int256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value < 2**128, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value < 2**64, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value < 2**32, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value < 2**16, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value < 2**8, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= -2**127 && value < 2**127, \\\"SafeCast: value doesn\\\\'t fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= -2**63 && value < 2**63, \\\"SafeCast: value doesn\\\\'t fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= -2**31 && value < 2**31, \\\"SafeCast: value doesn\\\\'t fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= -2**15 && value < 2**15, \\\"SafeCast: value doesn\\\\'t fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= -2**7 && value < 2**7, \\\"SafeCast: value doesn\\\\'t fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value < 2**255, \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.0;\\r\\n\\r\\nimport \\\"./AggregatorInterface.sol\\\";\\r\\nimport \\\"./AggregatorV3Interface.sol\\\";\\r\\n\\r\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\\r\\n{\\r\\n}\"\r\n    },\r\n    \"interfaces/notional/AssetRateAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-v3\\r\\npragma solidity >=0.7.0;\\r\\n\\r\\n/// @notice Used as a wrapper for tokens that are interest bearing for an\\r\\n/// underlying token. Follows the cToken interface, however, can be adapted\\r\\n/// for other interest bearing tokens.\\r\\ninterface AssetRateAdapter {\\r\\n    function token() external view returns (address);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function description() external view returns (string memory);\\r\\n\\r\\n    function version() external view returns (uint256);\\r\\n\\r\\n    function underlying() external view returns (address);\\r\\n\\r\\n    function getExchangeRateStateful() external returns (int256);\\r\\n\\r\\n    function getExchangeRateView() external view returns (int256);\\r\\n\\r\\n    function getAnnualizedSupplyRate() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.0;\\r\\n\\r\\ninterface AggregatorInterface {\\r\\n  function latestAnswer() external view returns (int256);\\r\\n  function latestTimestamp() external view returns (uint256);\\r\\n  function latestRound() external view returns (uint256);\\r\\n  function getAnswer(uint256 roundId) external view returns (int256);\\r\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\r\\n\\r\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\r\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\r\\n}\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.6.0;\\r\\n\\r\\ninterface AggregatorV3Interface {\\r\\n\\r\\n  function decimals() external view returns (uint8);\\r\\n  function description() external view returns (string memory);\\r\\n  function version() external view returns (uint256);\\r\\n\\r\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\r\\n  // if they do not have data to report, instead of returning unset values\\r\\n  // which could be misinterpreted as actual reported values.\\r\\n  function getRoundData(uint80 _roundId)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n\\r\\n  function latestRoundData()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint80 roundId,\\r\\n      int256 answer,\\r\\n      uint256 startedAt,\\r\\n      uint256 updatedAt,\\r\\n      uint80 answeredInRound\\r\\n    );\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/global/LibStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./Types.sol\\\";\\r\\nimport \\\"./Constants.sol\\\";\\r\\n\\r\\nlibrary LibStorage {\\r\\n\\r\\n    /// @dev Offset for the initial slot in lib storage, gives us this number of storage slots\\r\\n    /// available in StorageLayoutV1 and all subsequent storage layouts that inherit from it.\\r\\n    uint256 private constant STORAGE_SLOT_BASE = 1000000;\\r\\n    /// @dev Set to MAX_TRADED_MARKET_INDEX * 2, Solidity does not allow assigning constants from imported values\\r\\n    uint256 private constant NUM_NTOKEN_MARKET_FACTORS = 14;\\r\\n    /// @dev Theoretical maximum for MAX_PORTFOLIO_ASSETS, however, we limit this to MAX_TRADED_MARKET_INDEX\\r\\n    /// in practice. It is possible to exceed that value during liquidation up to 14 potential assets.\\r\\n    uint256 private constant MAX_PORTFOLIO_ASSETS = 16;\\r\\n\\r\\n    /// @dev Storage IDs for storage buckets. Each id maps to an internal storage\\r\\n    /// slot used for a particular mapping\\r\\n    ///     WARNING: APPEND ONLY\\r\\n    enum StorageId {\\r\\n        Unused,\\r\\n        AccountStorage,\\r\\n        nTokenContext,\\r\\n        nTokenAddress,\\r\\n        nTokenDeposit,\\r\\n        nTokenInitialization,\\r\\n        Balance,\\r\\n        Token,\\r\\n        SettlementRate,\\r\\n        CashGroup,\\r\\n        Market,\\r\\n        AssetsBitmap,\\r\\n        ifCashBitmap,\\r\\n        PortfolioArray,\\r\\n        nTokenTotalSupply,\\r\\n        AssetRate,\\r\\n        ExchangeRate\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from an account address to account context\\r\\n    function getAccountStorage() internal pure \\r\\n        returns (mapping(address => AccountContext) storage store) \\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.AccountStorage);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from an nToken address to nTokenContext\\r\\n    function getNTokenContextStorage() internal pure\\r\\n        returns (mapping(address => nTokenContext) storage store) \\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.nTokenContext);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from currency id to nTokenAddress\\r\\n    function getNTokenAddressStorage() internal pure\\r\\n        returns (mapping(uint256 => address) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.nTokenAddress);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from currency id to uint32 fixed length array of\\r\\n    /// deposit factors. Deposit shares and leverage thresholds are stored striped to\\r\\n    /// reduce the number of storage reads.\\r\\n    function getNTokenDepositStorage() internal pure\\r\\n        returns (mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.nTokenDeposit);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from currency id to fixed length array of initialization factors,\\r\\n    /// stored striped like deposit shares.\\r\\n    function getNTokenInitStorage() internal pure\\r\\n        returns (mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.nTokenInitialization);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from account to currencyId to it's balance storage for that currency\\r\\n    function getBalanceStorage() internal pure\\r\\n        returns (mapping(address => mapping(uint256 => BalanceStorage)) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.Balance);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from currency id to a boolean for underlying or asset token to\\r\\n    /// the TokenStorage\\r\\n    function getTokenStorage() internal pure\\r\\n        returns (mapping(uint256 => mapping(bool => TokenStorage)) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.Token);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from currency id to maturity to its corresponding SettlementRate\\r\\n    function getSettlementRateStorage() internal pure\\r\\n        returns (mapping(uint256 => mapping(uint256 => SettlementRateStorage)) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.SettlementRate);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from currency id to maturity to its tightly packed cash group parameters\\r\\n    function getCashGroupStorage() internal pure\\r\\n        returns (mapping(uint256 => bytes32) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.CashGroup);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from currency id to maturity to settlement date for a market\\r\\n    function getMarketStorage() internal pure\\r\\n        returns (mapping(uint256 => mapping(uint256 => mapping(uint256 => MarketStorage))) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.Market);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from account to currency id to its assets bitmap\\r\\n    function getAssetsBitmapStorage() internal pure\\r\\n        returns (mapping(address => mapping(uint256 => bytes32)) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.AssetsBitmap);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from account to currency id to its maturity to its corresponding ifCash balance\\r\\n    function getifCashBitmapStorage() internal pure\\r\\n        returns (mapping(address => mapping(uint256 => mapping(uint256 => ifCashStorage))) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.ifCashBitmap);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from account to its fixed length array of portfolio assets\\r\\n    function getPortfolioArrayStorage() internal pure\\r\\n        returns (mapping(address => PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS]) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.PortfolioArray);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Mapping from nToken address to its total supply values\\r\\n    function getNTokenTotalSupplyStorage() internal pure\\r\\n        returns (mapping(address => nTokenTotalSupplyStorage) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.nTokenTotalSupply);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the exchange rate between an underlying currency and asset for trading\\r\\n    /// and free collateral. Mapping is from currency id to rate storage object.\\r\\n    function getAssetRateStorage() internal pure\\r\\n        returns (mapping(uint256 => AssetRateStorage) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.AssetRate);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the exchange rate between an underlying currency and ETH for free\\r\\n    /// collateral purposes. Mapping is from currency id to rate storage object.\\r\\n    function getExchangeRateStorage() internal pure\\r\\n        returns (mapping(uint256 => ETHRateStorage) storage store)\\r\\n    {\\r\\n        uint256 slot = _getStorageSlot(StorageId.ExchangeRate);\\r\\n        assembly { store.slot := slot }\\r\\n    }\\r\\n\\r\\n    /// @dev Get the storage slot given a storage ID.\\r\\n    /// @param storageId An entry in `StorageId`\\r\\n    /// @return slot The storage slot.\\r\\n    function _getStorageSlot(StorageId storageId)\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256 slot)\\r\\n    {\\r\\n        // This should never overflow with a reasonable `STORAGE_SLOT_EXP`\\r\\n        // because Solidity will do a range check on `storageId` during the cast.\\r\\n        return uint256(storageId) + STORAGE_SLOT_BASE;\\r\\n    }\\r\\n\\r\\n\\r\\n} \"\r\n    },\r\n    \"contracts/internal/markets/CashGroup.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./Market.sol\\\";\\r\\nimport \\\"./AssetRate.sol\\\";\\r\\nimport \\\"./DateTime.sol\\\";\\r\\nimport \\\"../../global/LibStorage.sol\\\";\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary CashGroup {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeInt256 for int256;\\r\\n    using AssetRate for AssetRateParameters;\\r\\n    using Market for MarketParameters;\\r\\n\\r\\n    // Bit number references for each parameter in the 32 byte word (0-indexed)\\r\\n    uint256 private constant MARKET_INDEX_BIT = 31;\\r\\n    uint256 private constant RATE_ORACLE_TIME_WINDOW_BIT = 30;\\r\\n    uint256 private constant TOTAL_FEE_BIT = 29;\\r\\n    uint256 private constant RESERVE_FEE_SHARE_BIT = 28;\\r\\n    uint256 private constant DEBT_BUFFER_BIT = 27;\\r\\n    uint256 private constant FCASH_HAIRCUT_BIT = 26;\\r\\n    uint256 private constant SETTLEMENT_PENALTY_BIT = 25;\\r\\n    uint256 private constant LIQUIDATION_FCASH_HAIRCUT_BIT = 24;\\r\\n    uint256 private constant LIQUIDATION_DEBT_BUFFER_BIT = 23;\\r\\n    // 7 bytes allocated, one byte per market for the liquidity token haircut\\r\\n    uint256 private constant LIQUIDITY_TOKEN_HAIRCUT_FIRST_BIT = 22;\\r\\n    // 7 bytes allocated, one byte per market for the rate scalar\\r\\n    uint256 private constant RATE_SCALAR_FIRST_BIT = 15;\\r\\n\\r\\n    // Offsets for the bytes of the different parameters\\r\\n    uint256 private constant MARKET_INDEX = (31 - MARKET_INDEX_BIT) * 8;\\r\\n    uint256 private constant RATE_ORACLE_TIME_WINDOW = (31 - RATE_ORACLE_TIME_WINDOW_BIT) * 8;\\r\\n    uint256 private constant TOTAL_FEE = (31 - TOTAL_FEE_BIT) * 8;\\r\\n    uint256 private constant RESERVE_FEE_SHARE = (31 - RESERVE_FEE_SHARE_BIT) * 8;\\r\\n    uint256 private constant DEBT_BUFFER = (31 - DEBT_BUFFER_BIT) * 8;\\r\\n    uint256 private constant FCASH_HAIRCUT = (31 - FCASH_HAIRCUT_BIT) * 8;\\r\\n    uint256 private constant SETTLEMENT_PENALTY = (31 - SETTLEMENT_PENALTY_BIT) * 8;\\r\\n    uint256 private constant LIQUIDATION_FCASH_HAIRCUT = (31 - LIQUIDATION_FCASH_HAIRCUT_BIT) * 8;\\r\\n    uint256 private constant LIQUIDATION_DEBT_BUFFER = (31 - LIQUIDATION_DEBT_BUFFER_BIT) * 8;\\r\\n    uint256 private constant LIQUIDITY_TOKEN_HAIRCUT = (31 - LIQUIDITY_TOKEN_HAIRCUT_FIRST_BIT) * 8;\\r\\n    uint256 private constant RATE_SCALAR = (31 - RATE_SCALAR_FIRST_BIT) * 8;\\r\\n\\r\\n    /// @notice Returns the rate scalar scaled by time to maturity. The rate scalar multiplies\\r\\n    /// the ln() portion of the liquidity curve as an inverse so it increases with time to\\r\\n    /// maturity. The effect of the rate scalar on slippage must decrease with time to maturity.\\r\\n    function getRateScalar(\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        uint256 marketIndex,\\r\\n        uint256 timeToMaturity\\r\\n    ) internal pure returns (int256) {\\r\\n        require(1 <= marketIndex && marketIndex <= cashGroup.maxMarketIndex); // dev: invalid market index\\r\\n\\r\\n        uint256 offset = RATE_SCALAR + 8 * (marketIndex - 1);\\r\\n        int256 scalar = int256(uint8(uint256(cashGroup.data >> offset))) * Constants.RATE_PRECISION;\\r\\n        int256 rateScalar =\\r\\n            scalar.mul(int256(Constants.IMPLIED_RATE_TIME)).div(SafeInt256.toInt(timeToMaturity));\\r\\n\\r\\n        // Rate scalar is denominated in RATE_PRECISION, it is unlikely to underflow in the\\r\\n        // division above.\\r\\n        require(rateScalar > 0); // dev: rate scalar underflow\\r\\n        return rateScalar;\\r\\n    }\\r\\n\\r\\n    /// @notice Haircut on liquidity tokens to account for the risk associated with changes in the\\r\\n    /// proportion of cash to fCash within the pool. This is set as a percentage less than or equal to 100.\\r\\n    function getLiquidityHaircut(CashGroupParameters memory cashGroup, uint256 assetType)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint8)\\r\\n    {\\r\\n        require(\\r\\n            Constants.MIN_LIQUIDITY_TOKEN_INDEX <= assetType &&\\r\\n            assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX\\r\\n        ); // dev: liquidity haircut invalid asset type\\r\\n        uint256 offset =\\r\\n            LIQUIDITY_TOKEN_HAIRCUT + 8 * (assetType - Constants.MIN_LIQUIDITY_TOKEN_INDEX);\\r\\n        return uint8(uint256(cashGroup.data >> offset));\\r\\n    }\\r\\n\\r\\n    /// @notice Total trading fee denominated in RATE_PRECISION with basis point increments\\r\\n    function getTotalFee(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\r\\n        return uint256(uint8(uint256(cashGroup.data >> TOTAL_FEE))) * Constants.BASIS_POINT;\\r\\n    }\\r\\n\\r\\n    /// @notice Percentage of the total trading fee that goes to the reserve\\r\\n    function getReserveFeeShare(CashGroupParameters memory cashGroup)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int256)\\r\\n    {\\r\\n        return uint8(uint256(cashGroup.data >> RESERVE_FEE_SHARE));\\r\\n    }\\r\\n\\r\\n    /// @notice fCash haircut for valuation denominated in rate precision with five basis point increments\\r\\n    function getfCashHaircut(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\r\\n        return\\r\\n            uint256(uint8(uint256(cashGroup.data >> FCASH_HAIRCUT))) * Constants.FIVE_BASIS_POINTS;\\r\\n    }\\r\\n\\r\\n    /// @notice fCash debt buffer for valuation denominated in rate precision with five basis point increments\\r\\n    function getDebtBuffer(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\r\\n        return uint256(uint8(uint256(cashGroup.data >> DEBT_BUFFER))) * Constants.FIVE_BASIS_POINTS;\\r\\n    }\\r\\n\\r\\n    /// @notice Time window factor for the rate oracle denominated in seconds with five minute increments.\\r\\n    function getRateOracleTimeWindow(CashGroupParameters memory cashGroup)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        // This is denominated in 5 minute increments in storage\\r\\n        return uint256(uint8(uint256(cashGroup.data >> RATE_ORACLE_TIME_WINDOW))) * Constants.FIVE_MINUTES;\\r\\n    }\\r\\n\\r\\n    /// @notice Penalty rate for settling cash debts denominated in basis points\\r\\n    function getSettlementPenalty(CashGroupParameters memory cashGroup)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            uint256(uint8(uint256(cashGroup.data >> SETTLEMENT_PENALTY))) * Constants.FIVE_BASIS_POINTS;\\r\\n    }\\r\\n\\r\\n    /// @notice Haircut for positive fCash during liquidation denominated rate precision\\r\\n    /// with five basis point increments\\r\\n    function getLiquidationfCashHaircut(CashGroupParameters memory cashGroup)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            uint256(uint8(uint256(cashGroup.data >> LIQUIDATION_FCASH_HAIRCUT))) * Constants.FIVE_BASIS_POINTS;\\r\\n    }\\r\\n\\r\\n    /// @notice Haircut for negative fCash during liquidation denominated rate precision\\r\\n    /// with five basis point increments\\r\\n    function getLiquidationDebtBuffer(CashGroupParameters memory cashGroup)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            uint256(uint8(uint256(cashGroup.data >> LIQUIDATION_DEBT_BUFFER))) * Constants.FIVE_BASIS_POINTS;\\r\\n    }\\r\\n\\r\\n    function loadMarket(\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        MarketParameters memory market,\\r\\n        uint256 marketIndex,\\r\\n        bool needsLiquidity,\\r\\n        uint256 blockTime\\r\\n    ) internal view {\\r\\n        require(1 <= marketIndex && marketIndex <= cashGroup.maxMarketIndex, \\\"Invalid market\\\");\\r\\n        uint256 maturity =\\r\\n            DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));\\r\\n\\r\\n        market.loadMarket(\\r\\n            cashGroup.currencyId,\\r\\n            maturity,\\r\\n            blockTime,\\r\\n            needsLiquidity,\\r\\n            getRateOracleTimeWindow(cashGroup)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the linear interpolation between two market rates. The formula is\\r\\n    /// slope = (longMarket.oracleRate - shortMarket.oracleRate) / (longMarket.maturity - shortMarket.maturity)\\r\\n    /// interpolatedRate = slope * (assetMaturity - shortMarket.maturity) + shortMarket.oracleRate\\r\\n    function interpolateOracleRate(\\r\\n        uint256 shortMaturity,\\r\\n        uint256 longMaturity,\\r\\n        uint256 shortRate,\\r\\n        uint256 longRate,\\r\\n        uint256 assetMaturity\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(shortMaturity < assetMaturity); // dev: cash group interpolation error, short maturity\\r\\n        require(assetMaturity < longMaturity); // dev: cash group interpolation error, long maturity\\r\\n\\r\\n        // It's possible that the rates are inverted where the short market rate > long market rate and\\r\\n        // we will get an underflow here so we check for that\\r\\n        if (longRate >= shortRate) {\\r\\n            return\\r\\n                (longRate - shortRate)\\r\\n                    .mul(assetMaturity - shortMaturity)\\r\\n                // No underflow here, checked above\\r\\n                    .div(longMaturity - shortMaturity)\\r\\n                    .add(shortRate);\\r\\n        } else {\\r\\n            // In this case the slope is negative so:\\r\\n            // interpolatedRate = shortMarket.oracleRate - slope * (assetMaturity - shortMarket.maturity)\\r\\n            // NOTE: this subtraction should never overflow, the linear interpolation between two points above zero\\r\\n            // cannot go below zero\\r\\n            return\\r\\n                shortRate.sub(\\r\\n                    // This is reversed to keep it it positive\\r\\n                    (shortRate - longRate)\\r\\n                        .mul(assetMaturity - shortMaturity)\\r\\n                    // No underflow here, checked above\\r\\n                        .div(longMaturity - shortMaturity)\\r\\n                );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Gets an oracle rate given any valid maturity.\\r\\n    function calculateOracleRate(\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime\\r\\n    ) internal view returns (uint256) {\\r\\n        (uint256 marketIndex, bool idiosyncratic) =\\r\\n            DateTime.getMarketIndex(cashGroup.maxMarketIndex, maturity, blockTime);\\r\\n        uint256 timeWindow = getRateOracleTimeWindow(cashGroup);\\r\\n\\r\\n        if (!idiosyncratic) {\\r\\n            return Market.getOracleRate(cashGroup.currencyId, maturity, timeWindow, blockTime);\\r\\n        } else {\\r\\n            uint256 referenceTime = DateTime.getReferenceTime(blockTime);\\r\\n            // DateTime.getMarketIndex returns the market that is past the maturity if idiosyncratic\\r\\n            uint256 longMaturity = referenceTime.add(DateTime.getTradedMarket(marketIndex));\\r\\n            uint256 longRate =\\r\\n                Market.getOracleRate(cashGroup.currencyId, longMaturity, timeWindow, blockTime);\\r\\n\\r\\n            uint256 shortMaturity;\\r\\n            uint256 shortRate;\\r\\n            if (marketIndex == 1) {\\r\\n                // In this case the short market is the annualized asset supply rate\\r\\n                shortMaturity = blockTime;\\r\\n                shortRate = cashGroup.assetRate.getSupplyRate();\\r\\n            } else {\\r\\n                // Minimum value for marketIndex here is 2\\r\\n                shortMaturity = referenceTime.add(DateTime.getTradedMarket(marketIndex - 1));\\r\\n\\r\\n                shortRate = Market.getOracleRate(\\r\\n                    cashGroup.currencyId,\\r\\n                    shortMaturity,\\r\\n                    timeWindow,\\r\\n                    blockTime\\r\\n                );\\r\\n            }\\r\\n\\r\\n            return interpolateOracleRate(shortMaturity, longMaturity, shortRate, longRate, maturity);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getCashGroupStorageBytes(uint256 currencyId) private view returns (bytes32 data) {\\r\\n        mapping(uint256 => bytes32) storage store = LibStorage.getCashGroupStorage();\\r\\n        return store[currencyId];\\r\\n    }\\r\\n\\r\\n    /// @dev Helper method for validating maturities in ERC1155Action\\r\\n    function getMaxMarketIndex(uint256 currencyId) internal view returns (uint8) {\\r\\n        bytes32 data = _getCashGroupStorageBytes(currencyId);\\r\\n        return uint8(data[MARKET_INDEX_BIT]);\\r\\n    }\\r\\n\\r\\n    /// @notice Checks all cash group settings for invalid values and sets them into storage\\r\\n    function setCashGroupStorage(uint256 currencyId, CashGroupSettings calldata cashGroup)\\r\\n        internal\\r\\n    {\\r\\n        // Due to the requirements of the yield curve we do not allow a cash group to have solely a 3 month market.\\r\\n        // The reason is that borrowers will not have a further maturity to roll from their 3 month fixed to a 6 month\\r\\n        // fixed. It also complicates the logic in the nToken initialization method. Additionally, we cannot have cash\\r\\n        // groups with 0 market index, it has no effect.\\r\\n        require(2 <= cashGroup.maxMarketIndex && cashGroup.maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX,\\r\\n            \\\"CG: invalid market index\\\"\\r\\n        );\\r\\n        require(\\r\\n            cashGroup.reserveFeeShare <= Constants.PERCENTAGE_DECIMALS,\\r\\n            \\\"CG: invalid reserve share\\\"\\r\\n        );\\r\\n        require(cashGroup.liquidityTokenHaircuts.length == cashGroup.maxMarketIndex);\\r\\n        require(cashGroup.rateScalars.length == cashGroup.maxMarketIndex);\\r\\n        // This is required so that fCash liquidation can proceed correctly\\r\\n        require(cashGroup.liquidationfCashHaircut5BPS < cashGroup.fCashHaircut5BPS);\\r\\n        require(cashGroup.liquidationDebtBuffer5BPS < cashGroup.debtBuffer5BPS);\\r\\n\\r\\n        // Market indexes cannot decrease or they will leave fCash assets stranded in the future with no valuation curve\\r\\n        uint8 previousMaxMarketIndex = getMaxMarketIndex(currencyId);\\r\\n        require(\\r\\n            previousMaxMarketIndex <= cashGroup.maxMarketIndex,\\r\\n            \\\"CG: market index cannot decrease\\\"\\r\\n        );\\r\\n\\r\\n        // Per cash group settings\\r\\n        bytes32 data =\\r\\n            (bytes32(uint256(cashGroup.maxMarketIndex)) |\\r\\n                (bytes32(uint256(cashGroup.rateOracleTimeWindow5Min)) << RATE_ORACLE_TIME_WINDOW) |\\r\\n                (bytes32(uint256(cashGroup.totalFeeBPS)) << TOTAL_FEE) |\\r\\n                (bytes32(uint256(cashGroup.reserveFeeShare)) << RESERVE_FEE_SHARE) |\\r\\n                (bytes32(uint256(cashGroup.debtBuffer5BPS)) << DEBT_BUFFER) |\\r\\n                (bytes32(uint256(cashGroup.fCashHaircut5BPS)) << FCASH_HAIRCUT) |\\r\\n                (bytes32(uint256(cashGroup.settlementPenaltyRate5BPS)) << SETTLEMENT_PENALTY) |\\r\\n                (bytes32(uint256(cashGroup.liquidationfCashHaircut5BPS)) <<\\r\\n                    LIQUIDATION_FCASH_HAIRCUT) |\\r\\n                (bytes32(uint256(cashGroup.liquidationDebtBuffer5BPS)) << LIQUIDATION_DEBT_BUFFER));\\r\\n\\r\\n        // Per market group settings\\r\\n        for (uint256 i = 0; i < cashGroup.liquidityTokenHaircuts.length; i++) {\\r\\n            require(\\r\\n                cashGroup.liquidityTokenHaircuts[i] <= Constants.PERCENTAGE_DECIMALS,\\r\\n                \\\"CG: invalid token haircut\\\"\\r\\n            );\\r\\n\\r\\n            data =\\r\\n                data |\\r\\n                (bytes32(uint256(cashGroup.liquidityTokenHaircuts[i])) <<\\r\\n                    (LIQUIDITY_TOKEN_HAIRCUT + i * 8));\\r\\n        }\\r\\n\\r\\n        for (uint256 i = 0; i < cashGroup.rateScalars.length; i++) {\\r\\n            // Causes a divide by zero error\\r\\n            require(cashGroup.rateScalars[i] != 0, \\\"CG: invalid rate scalar\\\");\\r\\n            data = data | (bytes32(uint256(cashGroup.rateScalars[i])) << (RATE_SCALAR + i * 8));\\r\\n        }\\r\\n\\r\\n        mapping(uint256 => bytes32) storage store = LibStorage.getCashGroupStorage();\\r\\n        store[currencyId] = data;\\r\\n    }\\r\\n\\r\\n    /// @notice Deserialize the cash group storage bytes into a user friendly object\\r\\n    function deserializeCashGroupStorage(uint256 currencyId)\\r\\n        internal\\r\\n        view\\r\\n        returns (CashGroupSettings memory)\\r\\n    {\\r\\n        bytes32 data = _getCashGroupStorageBytes(currencyId);\\r\\n        uint8 maxMarketIndex = uint8(data[MARKET_INDEX_BIT]);\\r\\n        uint8[] memory tokenHaircuts = new uint8[](uint256(maxMarketIndex));\\r\\n        uint8[] memory rateScalars = new uint8[](uint256(maxMarketIndex));\\r\\n\\r\\n        for (uint8 i = 0; i < maxMarketIndex; i++) {\\r\\n            tokenHaircuts[i] = uint8(data[LIQUIDITY_TOKEN_HAIRCUT_FIRST_BIT - i]);\\r\\n            rateScalars[i] = uint8(data[RATE_SCALAR_FIRST_BIT - i]);\\r\\n        }\\r\\n\\r\\n        return\\r\\n            CashGroupSettings({\\r\\n                maxMarketIndex: maxMarketIndex,\\r\\n                rateOracleTimeWindow5Min: uint8(data[RATE_ORACLE_TIME_WINDOW_BIT]),\\r\\n                totalFeeBPS: uint8(data[TOTAL_FEE_BIT]),\\r\\n                reserveFeeShare: uint8(data[RESERVE_FEE_SHARE_BIT]),\\r\\n                debtBuffer5BPS: uint8(data[DEBT_BUFFER_BIT]),\\r\\n                fCashHaircut5BPS: uint8(data[FCASH_HAIRCUT_BIT]),\\r\\n                settlementPenaltyRate5BPS: uint8(data[SETTLEMENT_PENALTY_BIT]),\\r\\n                liquidationfCashHaircut5BPS: uint8(data[LIQUIDATION_FCASH_HAIRCUT_BIT]),\\r\\n                liquidationDebtBuffer5BPS: uint8(data[LIQUIDATION_DEBT_BUFFER_BIT]),\\r\\n                liquidityTokenHaircuts: tokenHaircuts,\\r\\n                rateScalars: rateScalars\\r\\n            });\\r\\n    }\\r\\n\\r\\n    function _buildCashGroup(uint16 currencyId, AssetRateParameters memory assetRate)\\r\\n        private\\r\\n        view\\r\\n        returns (CashGroupParameters memory)\\r\\n    {\\r\\n        bytes32 data = _getCashGroupStorageBytes(currencyId);\\r\\n        uint256 maxMarketIndex = uint8(data[MARKET_INDEX_BIT]);\\r\\n\\r\\n        return\\r\\n            CashGroupParameters({\\r\\n                currencyId: currencyId,\\r\\n                maxMarketIndex: maxMarketIndex,\\r\\n                assetRate: assetRate,\\r\\n                data: data\\r\\n            });\\r\\n    }\\r\\n\\r\\n    /// @notice Builds a cash group using a view version of the asset rate\\r\\n    function buildCashGroupView(uint16 currencyId)\\r\\n        internal\\r\\n        view\\r\\n        returns (CashGroupParameters memory)\\r\\n    {\\r\\n        AssetRateParameters memory assetRate = AssetRate.buildAssetRateView(currencyId);\\r\\n        return _buildCashGroup(currencyId, assetRate);\\r\\n    }\\r\\n\\r\\n    /// @notice Builds a cash group using a stateful version of the asset rate\\r\\n    function buildCashGroupStateful(uint16 currencyId)\\r\\n        internal\\r\\n        returns (CashGroupParameters memory)\\r\\n    {\\r\\n        AssetRateParameters memory assetRate = AssetRate.buildAssetRateStateful(currencyId);\\r\\n        return _buildCashGroup(currencyId, assetRate);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/valuation/AssetHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"../markets/CashGroup.sol\\\";\\r\\nimport \\\"../markets/AssetRate.sol\\\";\\r\\nimport \\\"../portfolio/PortfolioHandler.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../math/ABDKMath64x64.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary AssetHandler {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeInt256 for int256;\\r\\n    using CashGroup for CashGroupParameters;\\r\\n    using AssetRate for AssetRateParameters;\\r\\n\\r\\n    function isLiquidityToken(uint256 assetType) internal pure returns (bool) {\\r\\n        return\\r\\n            assetType >= Constants.MIN_LIQUIDITY_TOKEN_INDEX &&\\r\\n            assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX;\\r\\n    }\\r\\n\\r\\n    /// @notice Liquidity tokens settle every 90 days (not at the designated maturity). This method\\r\\n    /// calculates the settlement date for any PortfolioAsset.\\r\\n    function getSettlementDate(PortfolioAsset memory asset) internal pure returns (uint256) {\\r\\n        require(asset.assetType > 0 && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); // dev: settlement date invalid asset type\\r\\n        // 3 month tokens and fCash tokens settle at maturity\\r\\n        if (asset.assetType <= Constants.MIN_LIQUIDITY_TOKEN_INDEX) return asset.maturity;\\r\\n\\r\\n        uint256 marketLength = DateTime.getTradedMarket(asset.assetType - 1);\\r\\n        // Liquidity tokens settle at tRef + 90 days. The formula to get a maturity is:\\r\\n        // maturity = tRef + marketLength\\r\\n        // Here we calculate:\\r\\n        // tRef = (maturity - marketLength) + 90 days\\r\\n        return asset.maturity.sub(marketLength).add(Constants.QUARTER);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the continuously compounded discount rate given an oracle rate and a time to maturity.\\r\\n    /// The formula is: e^(-rate * timeToMaturity).\\r\\n    function getDiscountFactor(uint256 timeToMaturity, uint256 oracleRate)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int256)\\r\\n    {\\r\\n        int128 expValue =\\r\\n            ABDKMath64x64.fromUInt(oracleRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME));\\r\\n        expValue = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\\r\\n        expValue = ABDKMath64x64.exp(ABDKMath64x64.neg(expValue));\\r\\n        expValue = ABDKMath64x64.mul(expValue, Constants.RATE_PRECISION_64x64);\\r\\n        int256 discountFactor = ABDKMath64x64.toInt(expValue);\\r\\n\\r\\n        return discountFactor;\\r\\n    }\\r\\n\\r\\n    /// @notice Present value of an fCash asset without any risk adjustments.\\r\\n    function getPresentfCashValue(\\r\\n        int256 notional,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime,\\r\\n        uint256 oracleRate\\r\\n    ) internal pure returns (int256) {\\r\\n        if (notional == 0) return 0;\\r\\n\\r\\n        // NOTE: this will revert if maturity < blockTime. That is the correct behavior because we cannot\\r\\n        // discount matured assets.\\r\\n        uint256 timeToMaturity = maturity.sub(blockTime);\\r\\n        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);\\r\\n\\r\\n        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor\\r\\n        return notional.mulInRatePrecision(discountFactor);\\r\\n    }\\r\\n\\r\\n    /// @notice Present value of an fCash asset with risk adjustments. Positive fCash value will be discounted more\\r\\n    /// heavily than the oracle rate given and vice versa for negative fCash.\\r\\n    function getRiskAdjustedPresentfCashValue(\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        int256 notional,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime,\\r\\n        uint256 oracleRate\\r\\n    ) internal pure returns (int256) {\\r\\n        if (notional == 0) return 0;\\r\\n        // NOTE: this will revert if maturity < blockTime. That is the correct behavior because we cannot\\r\\n        // discount matured assets.\\r\\n        uint256 timeToMaturity = maturity.sub(blockTime);\\r\\n\\r\\n        int256 discountFactor;\\r\\n        if (notional > 0) {\\r\\n            // If fCash is positive then discounting by a higher rate will result in a smaller\\r\\n            // discount factor (e ^ -x), meaning a lower positive fCash value.\\r\\n            discountFactor = getDiscountFactor(\\r\\n                timeToMaturity,\\r\\n                oracleRate.add(cashGroup.getfCashHaircut())\\r\\n            );\\r\\n        } else {\\r\\n            uint256 debtBuffer = cashGroup.getDebtBuffer();\\r\\n            // If the adjustment exceeds the oracle rate we floor the value of the fCash\\r\\n            // at the notional value. We don't want to require the account to hold more than\\r\\n            // absolutely required.\\r\\n            if (debtBuffer >= oracleRate) return notional;\\r\\n\\r\\n            discountFactor = getDiscountFactor(timeToMaturity, oracleRate - debtBuffer);\\r\\n        }\\r\\n\\r\\n        require(discountFactor <= Constants.RATE_PRECISION); // dev: get risk adjusted pv, invalid discount factor\\r\\n        return notional.mulInRatePrecision(discountFactor);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the non haircut claims on cash and fCash by the liquidity token.\\r\\n    function getCashClaims(PortfolioAsset memory token, MarketParameters memory market)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int256 assetCash, int256 fCash)\\r\\n    {\\r\\n        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset, get cash claims\\r\\n\\r\\n        assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);\\r\\n        fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the haircut claims on cash and fCash\\r\\n    function getHaircutCashClaims(\\r\\n        PortfolioAsset memory token,\\r\\n        MarketParameters memory market,\\r\\n        CashGroupParameters memory cashGroup\\r\\n    ) internal pure returns (int256 assetCash, int256 fCash) {\\r\\n        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset get haircut cash claims\\r\\n\\r\\n        require(token.currencyId == cashGroup.currencyId); // dev: haircut cash claims, currency id mismatch\\r\\n        // This won't overflow, the liquidity token haircut is stored as an uint8\\r\\n        int256 haircut = int256(cashGroup.getLiquidityHaircut(token.assetType));\\r\\n\\r\\n        assetCash =\\r\\n            _calcToken(market.totalAssetCash, token.notional, haircut, market.totalLiquidity);\\r\\n\\r\\n        fCash =\\r\\n            _calcToken(market.totalfCash, token.notional, haircut, market.totalLiquidity);\\r\\n\\r\\n        return (assetCash, fCash);\\r\\n    }\\r\\n\\r\\n    /// @dev This is here to clean up the stack in getHaircutCashClaims\\r\\n    function _calcToken(\\r\\n        int256 numerator,\\r\\n        int256 tokens,\\r\\n        int256 haircut,\\r\\n        int256 liquidity\\r\\n    ) private pure returns (int256) {\\r\\n        return numerator.mul(tokens).mul(haircut).div(Constants.PERCENTAGE_DECIMALS).div(liquidity);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the asset cash claim and the present value of the fCash asset (if it exists)\\r\\n    function getLiquidityTokenValue(\\r\\n        uint256 index,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        MarketParameters memory market,\\r\\n        PortfolioAsset[] memory assets,\\r\\n        uint256 blockTime,\\r\\n        bool riskAdjusted\\r\\n    ) internal view returns (int256, int256) {\\r\\n        PortfolioAsset memory liquidityToken = assets[index];\\r\\n\\r\\n        {\\r\\n            (uint256 marketIndex, bool idiosyncratic) =\\r\\n                DateTime.getMarketIndex(\\r\\n                    cashGroup.maxMarketIndex,\\r\\n                    liquidityToken.maturity,\\r\\n                    blockTime\\r\\n                );\\r\\n            // Liquidity tokens can never be idiosyncratic\\r\\n            require(!idiosyncratic); // dev: idiosyncratic liquidity token\\r\\n\\r\\n            // This market will always be initialized, if a liquidity token exists that means the\\r\\n            // market has some liquidity in it.\\r\\n            cashGroup.loadMarket(market, marketIndex, true, blockTime);\\r\\n        }\\r\\n\\r\\n        int256 assetCashClaim;\\r\\n        int256 fCashClaim;\\r\\n        if (riskAdjusted) {\\r\\n            (assetCashClaim, fCashClaim) = getHaircutCashClaims(liquidityToken, market, cashGroup);\\r\\n        } else {\\r\\n            (assetCashClaim, fCashClaim) = getCashClaims(liquidityToken, market);\\r\\n        }\\r\\n\\r\\n        // Find the matching fCash asset and net off the value, assumes that the portfolio is sorted and\\r\\n        // in that case we know the previous asset will be the matching fCash asset\\r\\n        if (index > 0) {\\r\\n            PortfolioAsset memory maybefCash = assets[index - 1];\\r\\n            if (\\r\\n                maybefCash.assetType == Constants.FCASH_ASSET_TYPE &&\\r\\n                maybefCash.currencyId == liquidityToken.currencyId &&\\r\\n                maybefCash.maturity == liquidityToken.maturity\\r\\n            ) {\\r\\n                // Net off the fCashClaim here and we will discount it to present value in the second pass.\\r\\n                // WARNING: this modifies the portfolio in memory and therefore we cannot store this portfolio!\\r\\n                maybefCash.notional = maybefCash.notional.add(fCashClaim);\\r\\n                // This state will prevent the fCash asset from being stored.\\r\\n                maybefCash.storageState = AssetStorageState.RevertIfStored;\\r\\n                return (assetCashClaim, 0);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // If not matching fCash asset found then get the pv directly\\r\\n        if (riskAdjusted) {\\r\\n            int256 pv =\\r\\n                getRiskAdjustedPresentfCashValue(\\r\\n                    cashGroup,\\r\\n                    fCashClaim,\\r\\n                    liquidityToken.maturity,\\r\\n                    blockTime,\\r\\n                    market.oracleRate\\r\\n                );\\r\\n\\r\\n            return (assetCashClaim, pv);\\r\\n        } else {\\r\\n            int256 pv =\\r\\n                getPresentfCashValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);\\r\\n\\r\\n            return (assetCashClaim, pv);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns present value of all assets in the cash group as asset cash and the updated\\r\\n    /// portfolio index where the function has ended.\\r\\n    /// @return the value of the cash group in asset cash\\r\\n    function getNetCashGroupValue(\\r\\n        PortfolioAsset[] memory assets,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        MarketParameters memory market,\\r\\n        uint256 blockTime,\\r\\n        uint256 portfolioIndex\\r\\n    ) internal view returns (int256, uint256) {\\r\\n        int256 presentValueAsset;\\r\\n        int256 presentValueUnderlying;\\r\\n\\r\\n        // First calculate value of liquidity tokens because we need to net off fCash value\\r\\n        // before discounting to present value\\r\\n        for (uint256 i = portfolioIndex; i < assets.length; i++) {\\r\\n            if (!isLiquidityToken(assets[i].assetType)) continue;\\r\\n            if (assets[i].currencyId != cashGroup.currencyId) break;\\r\\n\\r\\n            (int256 assetCashClaim, int256 pv) =\\r\\n                getLiquidityTokenValue(\\r\\n                    i,\\r\\n                    cashGroup,\\r\\n                    market,\\r\\n                    assets,\\r\\n                    blockTime,\\r\\n                    true // risk adjusted\\r\\n                );\\r\\n\\r\\n            presentValueAsset = presentValueAsset.add(assetCashClaim);\\r\\n            presentValueUnderlying = presentValueUnderlying.add(pv);\\r\\n        }\\r\\n\\r\\n        uint256 j = portfolioIndex;\\r\\n        for (; j < assets.length; j++) {\\r\\n            PortfolioAsset memory a = assets[j];\\r\\n            if (a.assetType != Constants.FCASH_ASSET_TYPE) continue;\\r\\n            // If we hit a different currency id then we've accounted for all assets in this currency\\r\\n            // j will mark the index where we don't have this currency anymore\\r\\n            if (a.currencyId != cashGroup.currencyId) break;\\r\\n\\r\\n            uint256 oracleRate = cashGroup.calculateOracleRate(a.maturity, blockTime);\\r\\n\\r\\n            int256 pv =\\r\\n                getRiskAdjustedPresentfCashValue(\\r\\n                    cashGroup,\\r\\n                    a.notional,\\r\\n                    a.maturity,\\r\\n                    blockTime,\\r\\n                    oracleRate\\r\\n                );\\r\\n            presentValueUnderlying = presentValueUnderlying.add(pv);\\r\\n        }\\r\\n\\r\\n        presentValueAsset = presentValueAsset.add(\\r\\n            cashGroup.assetRate.convertFromUnderlying(presentValueUnderlying)\\r\\n        );\\r\\n\\r\\n        return (presentValueAsset, j);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/portfolio/BitmapAssetsHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../AccountContextHandler.sol\\\";\\r\\nimport \\\"../markets/CashGroup.sol\\\";\\r\\nimport \\\"../valuation/AssetHandler.sol\\\";\\r\\nimport \\\"../../math/Bitmap.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../global/LibStorage.sol\\\";\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary BitmapAssetsHandler {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeInt256 for int256;\\r\\n    using Bitmap for bytes32;\\r\\n    using CashGroup for CashGroupParameters;\\r\\n    using AccountContextHandler for AccountContext;\\r\\n\\r\\n    function getAssetsBitmap(address account, uint256 currencyId) internal view returns (bytes32 assetsBitmap) {\\r\\n        mapping(address => mapping(uint256 => bytes32)) storage store = LibStorage.getAssetsBitmapStorage();\\r\\n        return store[account][currencyId];\\r\\n    }\\r\\n\\r\\n    function setAssetsBitmap(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        bytes32 assetsBitmap\\r\\n    ) internal {\\r\\n        require(assetsBitmap.totalBitsSet() <= Constants.MAX_BITMAP_ASSETS, \\\"Over max assets\\\");\\r\\n        mapping(address => mapping(uint256 => bytes32)) storage store = LibStorage.getAssetsBitmapStorage();\\r\\n        store[account][currencyId] = assetsBitmap;\\r\\n    }\\r\\n\\r\\n    function getifCashNotional(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity\\r\\n    ) internal view returns (int256 notional) {\\r\\n        mapping(address => mapping(uint256 =>\\r\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\r\\n        return store[account][currencyId][maturity].notional;\\r\\n    }\\r\\n\\r\\n    /// @notice Adds multiple assets to a bitmap portfolio\\r\\n    function addMultipleifCashAssets(\\r\\n        address account,\\r\\n        AccountContext memory accountContext,\\r\\n        PortfolioAsset[] memory assets\\r\\n    ) internal {\\r\\n        require(accountContext.isBitmapEnabled()); // dev: bitmap currency not set\\r\\n        uint256 currencyId = accountContext.bitmapCurrencyId;\\r\\n\\r\\n        for (uint256 i; i < assets.length; i++) {\\r\\n            PortfolioAsset memory asset = assets[i];\\r\\n            if (asset.notional == 0) continue;\\r\\n\\r\\n            require(asset.currencyId == currencyId); // dev: invalid asset in set ifcash assets\\r\\n            require(asset.assetType == Constants.FCASH_ASSET_TYPE); // dev: invalid asset in set ifcash assets\\r\\n            int256 finalNotional;\\r\\n\\r\\n            finalNotional = addifCashAsset(\\r\\n                account,\\r\\n                currencyId,\\r\\n                asset.maturity,\\r\\n                accountContext.nextSettleTime,\\r\\n                asset.notional\\r\\n            );\\r\\n\\r\\n            if (finalNotional < 0)\\r\\n                accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Add an ifCash asset in the bitmap and mapping. Updates the bitmap in memory\\r\\n    /// but not in storage.\\r\\n    /// @return the updated assets bitmap and the final notional amount\\r\\n    function addifCashAsset(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 nextSettleTime,\\r\\n        int256 notional\\r\\n    ) internal returns (int256) {\\r\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\r\\n        mapping(address => mapping(uint256 =>\\r\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\r\\n        ifCashStorage storage fCashSlot = store[account][currencyId][maturity];\\r\\n        (uint256 bitNum, bool isExact) = DateTime.getBitNumFromMaturity(nextSettleTime, maturity);\\r\\n        require(isExact); // dev: invalid maturity in set ifcash asset\\r\\n\\r\\n        if (assetsBitmap.isBitSet(bitNum)) {\\r\\n            // Bit is set so we read and update the notional amount\\r\\n            int256 finalNotional = notional.add(fCashSlot.notional);\\r\\n            require(type(int128).min <= finalNotional && finalNotional <= type(int128).max); // dev: bitmap notional overflow\\r\\n            fCashSlot.notional = int128(finalNotional);\\r\\n\\r\\n            // If the new notional is zero then turn off the bit\\r\\n            if (finalNotional == 0) {\\r\\n                assetsBitmap = assetsBitmap.setBit(bitNum, false);\\r\\n            }\\r\\n\\r\\n            setAssetsBitmap(account, currencyId, assetsBitmap);\\r\\n            return finalNotional;\\r\\n        }\\r\\n\\r\\n        if (notional != 0) {\\r\\n            // Bit is not set so we turn it on and update the mapping directly, no read required.\\r\\n            require(type(int128).min <= notional && notional <= type(int128).max); // dev: bitmap notional overflow\\r\\n            fCashSlot.notional = int128(notional);\\r\\n\\r\\n            assetsBitmap = assetsBitmap.setBit(bitNum, true);\\r\\n            setAssetsBitmap(account, currencyId, assetsBitmap);\\r\\n        }\\r\\n\\r\\n        return notional;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the present value of an asset\\r\\n    function _getPresentValue(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        bool riskAdjusted\\r\\n    ) private view returns (int256) {\\r\\n        int256 notional = getifCashNotional(account, currencyId, maturity);\\r\\n\\r\\n        // In this case the asset has matured and the total value is just the notional amount\\r\\n        if (maturity <= blockTime) {\\r\\n            return notional;\\r\\n        } else {\\r\\n            uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);\\r\\n            if (riskAdjusted) {\\r\\n                return AssetHandler.getRiskAdjustedPresentfCashValue(\\r\\n                    cashGroup,\\r\\n                    notional,\\r\\n                    maturity,\\r\\n                    blockTime,\\r\\n                    oracleRate\\r\\n                );\\r\\n            } else {\\r\\n                return AssetHandler.getPresentfCashValue(\\r\\n                    notional,\\r\\n                    maturity,\\r\\n                    blockTime,\\r\\n                    oracleRate\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Get the net present value of all the ifCash assets\\r\\n    function getifCashNetPresentValue(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        uint256 nextSettleTime,\\r\\n        uint256 blockTime,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        bool riskAdjusted\\r\\n    ) internal view returns (int256 totalValueUnderlying, bool hasDebt) {\\r\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\r\\n        uint256 bitNum = assetsBitmap.getNextBitNum();\\r\\n\\r\\n        while (bitNum != 0) {\\r\\n            uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);\\r\\n            int256 pv = _getPresentValue(\\r\\n                account,\\r\\n                currencyId,\\r\\n                maturity,\\r\\n                blockTime,\\r\\n                cashGroup,\\r\\n                riskAdjusted\\r\\n            );\\r\\n            totalValueUnderlying = totalValueUnderlying.add(pv);\\r\\n\\r\\n            if (pv < 0) hasDebt = true;\\r\\n\\r\\n            // Turn off the bit and look for the next one\\r\\n            assetsBitmap = assetsBitmap.setBit(bitNum, false);\\r\\n            bitNum = assetsBitmap.getNextBitNum();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the ifCash assets as an array\\r\\n    function getifCashArray(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        uint256 nextSettleTime\\r\\n    ) internal view returns (PortfolioAsset[] memory) {\\r\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\r\\n        uint256 index = assetsBitmap.totalBitsSet();\\r\\n        PortfolioAsset[] memory assets = new PortfolioAsset[](index);\\r\\n        index = 0;\\r\\n\\r\\n        uint256 bitNum = assetsBitmap.getNextBitNum();\\r\\n        while (bitNum != 0) {\\r\\n            uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);\\r\\n            int256 notional = getifCashNotional(account, currencyId, maturity);\\r\\n\\r\\n            PortfolioAsset memory asset = assets[index];\\r\\n            asset.currencyId = currencyId;\\r\\n            asset.maturity = maturity;\\r\\n            asset.assetType = Constants.FCASH_ASSET_TYPE;\\r\\n            asset.notional = notional;\\r\\n            index += 1;\\r\\n\\r\\n            // Turn off the bit and look for the next one\\r\\n            assetsBitmap = assetsBitmap.setBit(bitNum, false);\\r\\n            bitNum = assetsBitmap.getNextBitNum();\\r\\n        }\\r\\n\\r\\n        return assets;\\r\\n    }\\r\\n\\r\\n    /// @notice Used to reduce an nToken ifCash assets portfolio proportionately when redeeming\\r\\n    /// nTokens to its underlying assets.\\r\\n    function reduceifCashAssetsProportional(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        uint256 nextSettleTime,\\r\\n        int256 tokensToRedeem,\\r\\n        int256 totalSupply\\r\\n    ) internal returns (PortfolioAsset[] memory) {\\r\\n        // It is not possible to redeem the entire token supply because some liquidity tokens must remain\\r\\n        // in the liquidity token portfolio in order to re-initialize markets.\\r\\n        require(tokensToRedeem < totalSupply, \\\"Cannot redeem\\\");\\r\\n\\r\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\r\\n        uint256 index = assetsBitmap.totalBitsSet();\\r\\n        mapping(address => mapping(uint256 =>\\r\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\r\\n\\r\\n        PortfolioAsset[] memory assets = new PortfolioAsset[](index);\\r\\n        index = 0;\\r\\n\\r\\n        uint256 bitNum = assetsBitmap.getNextBitNum();\\r\\n        while (bitNum != 0) {\\r\\n            uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);\\r\\n            ifCashStorage storage fCashSlot = store[account][currencyId][maturity];\\r\\n            int256 notional = fCashSlot.notional;\\r\\n\\r\\n            int256 notionalToTransfer = notional.mul(tokensToRedeem).div(totalSupply);\\r\\n            int256 finalNotional = notional.sub(notionalToTransfer);\\r\\n\\r\\n            require(type(int128).min <= finalNotional && finalNotional <= type(int128).max); // dev: bitmap notional overflow\\r\\n            fCashSlot.notional = int128(finalNotional);\\r\\n\\r\\n            PortfolioAsset memory asset = assets[index];\\r\\n            asset.currencyId = currencyId;\\r\\n            asset.maturity = maturity;\\r\\n            asset.assetType = Constants.FCASH_ASSET_TYPE;\\r\\n            asset.notional = notionalToTransfer;\\r\\n            index += 1;\\r\\n\\r\\n            // Turn off the bit and look for the next one\\r\\n            assetsBitmap = assetsBitmap.setBit(bitNum, false);\\r\\n            bitNum = assetsBitmap.getNextBitNum();\\r\\n        }\\r\\n\\r\\n        return assets;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/portfolio/PortfolioHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./TransferAssets.sol\\\";\\r\\nimport \\\"../valuation/AssetHandler.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\n\\r\\n/// @notice Handles the management of an array of assets including reading from storage, inserting\\r\\n/// updating, deleting and writing back to storage.\\r\\nlibrary PortfolioHandler {\\r\\n    using SafeInt256 for int256;\\r\\n    using AssetHandler for PortfolioAsset;\\r\\n\\r\\n    // Mirror of LibStorage.MAX_PORTFOLIO_ASSETS\\r\\n    uint256 private constant MAX_PORTFOLIO_ASSETS = 16;\\r\\n\\r\\n    /// @notice Primarily used by the TransferAssets library\\r\\n    function addMultipleAssets(PortfolioState memory portfolioState, PortfolioAsset[] memory assets)\\r\\n        internal\\r\\n        pure\\r\\n    {\\r\\n        for (uint256 i = 0; i < assets.length; i++) {\\r\\n            PortfolioAsset memory asset = assets[i];\\r\\n            if (asset.notional == 0) continue;\\r\\n\\r\\n            addAsset(\\r\\n                portfolioState,\\r\\n                asset.currencyId,\\r\\n                asset.maturity,\\r\\n                asset.assetType,\\r\\n                asset.notional\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _mergeAssetIntoArray(\\r\\n        PortfolioAsset[] memory assetArray,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 assetType,\\r\\n        int256 notional\\r\\n    ) private pure returns (bool) {\\r\\n        for (uint256 i = 0; i < assetArray.length; i++) {\\r\\n            PortfolioAsset memory asset = assetArray[i];\\r\\n            if (\\r\\n                asset.assetType != assetType ||\\r\\n                asset.currencyId != currencyId ||\\r\\n                asset.maturity != maturity\\r\\n            ) continue;\\r\\n\\r\\n            // Either of these storage states mean that some error in logic has occurred, we cannot\\r\\n            // store this portfolio\\r\\n            require(\\r\\n                asset.storageState != AssetStorageState.Delete &&\\r\\n                asset.storageState != AssetStorageState.RevertIfStored\\r\\n            ); // dev: portfolio handler deleted storage\\r\\n\\r\\n            int256 newNotional = asset.notional.add(notional);\\r\\n            // Liquidity tokens cannot be reduced below zero.\\r\\n            if (AssetHandler.isLiquidityToken(assetType)) {\\r\\n                require(newNotional >= 0); // dev: portfolio handler negative liquidity token balance\\r\\n            }\\r\\n\\r\\n            require(newNotional >= type(int88).min && newNotional <= type(int88).max); // dev: portfolio handler notional overflow\\r\\n\\r\\n            asset.notional = newNotional;\\r\\n            asset.storageState = AssetStorageState.Update;\\r\\n\\r\\n            return true;\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /// @notice Adds an asset to a portfolio state in memory (does not write to storage)\\r\\n    /// @dev Ensures that only one version of an asset exists in a portfolio (i.e. does not allow two fCash assets of the same maturity\\r\\n    /// to exist in a single portfolio). Also ensures that liquidity tokens do not have a negative notional.\\r\\n    function addAsset(\\r\\n        PortfolioState memory portfolioState,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 assetType,\\r\\n        int256 notional\\r\\n    ) internal pure {\\r\\n        if (\\r\\n            // Will return true if merged\\r\\n            _mergeAssetIntoArray(\\r\\n                portfolioState.storedAssets,\\r\\n                currencyId,\\r\\n                maturity,\\r\\n                assetType,\\r\\n                notional\\r\\n            )\\r\\n        ) return;\\r\\n\\r\\n        if (portfolioState.lastNewAssetIndex > 0) {\\r\\n            bool merged = _mergeAssetIntoArray(\\r\\n                portfolioState.newAssets,\\r\\n                currencyId,\\r\\n                maturity,\\r\\n                assetType,\\r\\n                notional\\r\\n            );\\r\\n            if (merged) return;\\r\\n        }\\r\\n\\r\\n        // At this point if we have not merged the asset then append to the array\\r\\n        // Cannot remove liquidity that the portfolio does not have\\r\\n        if (AssetHandler.isLiquidityToken(assetType)) {\\r\\n            require(notional >= 0); // dev: portfolio handler negative liquidity token balance\\r\\n        }\\r\\n        require(notional >= type(int88).min && notional <= type(int88).max); // dev: portfolio handler notional overflow\\r\\n\\r\\n        // Need to provision a new array at this point\\r\\n        if (portfolioState.lastNewAssetIndex == portfolioState.newAssets.length) {\\r\\n            portfolioState.newAssets = _extendNewAssetArray(portfolioState.newAssets);\\r\\n        }\\r\\n\\r\\n        // Otherwise add to the new assets array. It should not be possible to add matching assets in a single transaction, we will\\r\\n        // check this again when we write to storage. Assigning to memory directly here, do not allocate new memory via struct.\\r\\n        PortfolioAsset memory newAsset = portfolioState.newAssets[portfolioState.lastNewAssetIndex];\\r\\n        newAsset.currencyId = currencyId;\\r\\n        newAsset.maturity = maturity;\\r\\n        newAsset.assetType = assetType;\\r\\n        newAsset.notional = notional;\\r\\n        newAsset.storageState = AssetStorageState.NoChange;\\r\\n        portfolioState.lastNewAssetIndex += 1;\\r\\n    }\\r\\n\\r\\n    /// @dev Extends the new asset array if it is not large enough, this is likely to get a bit expensive if we do\\r\\n    /// it too much\\r\\n    function _extendNewAssetArray(PortfolioAsset[] memory newAssets)\\r\\n        private\\r\\n        pure\\r\\n        returns (PortfolioAsset[] memory)\\r\\n    {\\r\\n        // Double the size of the new asset array every time we have to extend to reduce the number of times\\r\\n        // that we have to extend it. This will go: 0, 1, 2, 4, 8 (probably stops there).\\r\\n        uint256 newLength = newAssets.length == 0 ? 1 : newAssets.length * 2;\\r\\n        PortfolioAsset[] memory extendedArray = new PortfolioAsset[](newLength);\\r\\n        for (uint256 i = 0; i < newAssets.length; i++) {\\r\\n            extendedArray[i] = newAssets[i];\\r\\n        }\\r\\n\\r\\n        return extendedArray;\\r\\n    }\\r\\n\\r\\n    /// @notice Takes a portfolio state and writes it to storage.\\r\\n    /// @dev This method should only be called directly by the nToken. Account updates to portfolios should happen via\\r\\n    /// the storeAssetsAndUpdateContext call in the AccountContextHandler.sol library.\\r\\n    /// @return updated variables to update the account context with\\r\\n    ///     hasDebt: whether or not the portfolio has negative fCash assets\\r\\n    ///     portfolioActiveCurrencies: a byte32 word with all the currencies in the portfolio\\r\\n    ///     uint8: the length of the storage array\\r\\n    ///     uint40: the new nextSettleTime for the portfolio\\r\\n    function storeAssets(PortfolioState memory portfolioState, address account)\\r\\n        internal\\r\\n        returns (\\r\\n            bool,\\r\\n            bytes32,\\r\\n            uint8,\\r\\n            uint40\\r\\n        )\\r\\n    {\\r\\n        bool hasDebt;\\r\\n        // NOTE: cannot have more than 16 assets or this byte object will overflow. Max assets is\\r\\n        // set to 7 and the worst case during liquidation would be 7 liquidity tokens that generate\\r\\n        // 7 additional fCash assets for a total of 14 assets. Although even in this case all assets\\r\\n        // would be of the same currency so it would not change the end result of the active currency\\r\\n        // calculation.\\r\\n        bytes32 portfolioActiveCurrencies;\\r\\n        uint256 nextSettleTime;\\r\\n\\r\\n        for (uint256 i = 0; i < portfolioState.storedAssets.length; i++) {\\r\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\r\\n            // NOTE: this is to prevent the storage of assets that have been modified in the AssetHandler\\r\\n            // during valuation.\\r\\n            require(asset.storageState != AssetStorageState.RevertIfStored);\\r\\n\\r\\n            // Mark any zero notional assets as deleted\\r\\n            if (asset.storageState != AssetStorageState.Delete && asset.notional == 0) {\\r\\n                deleteAsset(portfolioState, i);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // First delete assets from asset storage to maintain asset storage indexes\\r\\n        for (uint256 i = 0; i < portfolioState.storedAssets.length; i++) {\\r\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\r\\n\\r\\n            if (asset.storageState == AssetStorageState.Delete) {\\r\\n                // Delete asset from storage\\r\\n                uint256 currentSlot = asset.storageSlot;\\r\\n                assembly {\\r\\n                    sstore(currentSlot, 0x00)\\r\\n                }\\r\\n            } else {\\r\\n                if (asset.storageState == AssetStorageState.Update) {\\r\\n                    PortfolioAssetStorage storage assetStorage;\\r\\n                    uint256 currentSlot = asset.storageSlot;\\r\\n                    assembly {\\r\\n                        assetStorage.slot := currentSlot\\r\\n                    }\\r\\n\\r\\n                    _storeAsset(asset, assetStorage);\\r\\n                }\\r\\n\\r\\n                // Update portfolio context for every asset that is in storage, whether it is\\r\\n                // updated in storage or not.\\r\\n                (hasDebt, portfolioActiveCurrencies, nextSettleTime) = _updatePortfolioContext(\\r\\n                    asset,\\r\\n                    hasDebt,\\r\\n                    portfolioActiveCurrencies,\\r\\n                    nextSettleTime\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Add new assets\\r\\n        uint256 assetStorageLength = portfolioState.storedAssetLength;\\r\\n        mapping(address => \\r\\n            PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS]) storage store = LibStorage.getPortfolioArrayStorage();\\r\\n        PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS] storage storageArray = store[account];\\r\\n        for (uint256 i = 0; i < portfolioState.newAssets.length; i++) {\\r\\n            PortfolioAsset memory asset = portfolioState.newAssets[i];\\r\\n            if (asset.notional == 0) continue;\\r\\n            require(\\r\\n                asset.storageState != AssetStorageState.Delete &&\\r\\n                asset.storageState != AssetStorageState.RevertIfStored\\r\\n            ); // dev: store assets deleted storage\\r\\n\\r\\n            (hasDebt, portfolioActiveCurrencies, nextSettleTime) = _updatePortfolioContext(\\r\\n                asset,\\r\\n                hasDebt,\\r\\n                portfolioActiveCurrencies,\\r\\n                nextSettleTime\\r\\n            );\\r\\n\\r\\n            _storeAsset(asset, storageArray[assetStorageLength]);\\r\\n            assetStorageLength += 1;\\r\\n        }\\r\\n\\r\\n        // 16 is the maximum number of assets or portfolio active currencies will overflow at 32 bytes with\\r\\n        // 2 bytes per currency\\r\\n        require(assetStorageLength <= 16 && nextSettleTime <= type(uint40).max); // dev: portfolio return value overflow\\r\\n        return (\\r\\n            hasDebt,\\r\\n            portfolioActiveCurrencies,\\r\\n            uint8(assetStorageLength),\\r\\n            uint40(nextSettleTime)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Updates context information during the store assets method\\r\\n    function _updatePortfolioContext(\\r\\n        PortfolioAsset memory asset,\\r\\n        bool hasDebt,\\r\\n        bytes32 portfolioActiveCurrencies,\\r\\n        uint256 nextSettleTime\\r\\n    )\\r\\n        private\\r\\n        pure\\r\\n        returns (\\r\\n            bool,\\r\\n            bytes32,\\r\\n            uint256\\r\\n        )\\r\\n    {\\r\\n        uint256 settlementDate = asset.getSettlementDate();\\r\\n        // Tis will set it to the minimum settlement date\\r\\n        if (nextSettleTime == 0 || nextSettleTime > settlementDate) {\\r\\n            nextSettleTime = settlementDate;\\r\\n        }\\r\\n        hasDebt = hasDebt || asset.notional < 0;\\r\\n\\r\\n        require(uint16(uint256(portfolioActiveCurrencies)) == 0); // dev: portfolio active currencies overflow\\r\\n        portfolioActiveCurrencies = (portfolioActiveCurrencies >> 16) | (bytes32(asset.currencyId) << 240);\\r\\n\\r\\n        return (hasDebt, portfolioActiveCurrencies, nextSettleTime);\\r\\n    }\\r\\n\\r\\n    /// @dev Encodes assets for storage\\r\\n    function _storeAsset(\\r\\n        PortfolioAsset memory asset,\\r\\n        PortfolioAssetStorage storage assetStorage\\r\\n    ) internal {\\r\\n        require(0 < asset.currencyId && asset.currencyId <= Constants.MAX_CURRENCIES); // dev: encode asset currency id overflow\\r\\n        require(0 < asset.maturity && asset.maturity <= type(uint40).max); // dev: encode asset maturity overflow\\r\\n        require(0 < asset.assetType && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); // dev: encode asset type invalid\\r\\n        require(type(int88).min <= asset.notional && asset.notional <= type(int88).max); // dev: encode asset notional overflow\\r\\n\\r\\n        assetStorage.currencyId = uint16(asset.currencyId);\\r\\n        assetStorage.maturity = uint40(asset.maturity);\\r\\n        assetStorage.assetType = uint8(asset.assetType);\\r\\n        assetStorage.notional = int88(asset.notional);\\r\\n    }\\r\\n\\r\\n    /// @notice Deletes an asset from a portfolio\\r\\n    /// @dev This method should only be called during settlement, assets can only be removed from a portfolio before settlement\\r\\n    /// by adding the offsetting negative position\\r\\n    function deleteAsset(PortfolioState memory portfolioState, uint256 index) internal pure {\\r\\n        require(index < portfolioState.storedAssets.length); // dev: stored assets bounds\\r\\n        require(portfolioState.storedAssetLength > 0); // dev: stored assets length is zero\\r\\n        PortfolioAsset memory assetToDelete = portfolioState.storedAssets[index];\\r\\n        require(\\r\\n            assetToDelete.storageState != AssetStorageState.Delete &&\\r\\n            assetToDelete.storageState != AssetStorageState.RevertIfStored\\r\\n        ); // dev: cannot delete asset\\r\\n\\r\\n        portfolioState.storedAssetLength -= 1;\\r\\n\\r\\n        uint256 maxActiveSlotIndex;\\r\\n        uint256 maxActiveSlot;\\r\\n        // The max active slot is the last storage slot where an asset exists, it's not clear where this will be in the\\r\\n        // array so we search for it here.\\r\\n        for (uint256 i; i < portfolioState.storedAssets.length; i++) {\\r\\n            PortfolioAsset memory a = portfolioState.storedAssets[i];\\r\\n            if (a.storageSlot > maxActiveSlot && a.storageState != AssetStorageState.Delete) {\\r\\n                maxActiveSlot = a.storageSlot;\\r\\n                maxActiveSlotIndex = i;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (index == maxActiveSlotIndex) {\\r\\n            // In this case we are deleting the asset with the max storage slot so no swap is necessary.\\r\\n            assetToDelete.storageState = AssetStorageState.Delete;\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // Swap the storage slots of the deleted asset with the last non-deleted asset in the array. Mark them accordingly\\r\\n        // so that when we call store assets they will be updated appropriately\\r\\n        PortfolioAsset memory assetToSwap = portfolioState.storedAssets[maxActiveSlotIndex];\\r\\n        (\\r\\n            assetToSwap.storageSlot,\\r\\n            assetToDelete.storageSlot\\r\\n        ) = (\\r\\n            assetToDelete.storageSlot,\\r\\n            assetToSwap.storageSlot\\r\\n        );\\r\\n        assetToSwap.storageState = AssetStorageState.Update;\\r\\n        assetToDelete.storageState = AssetStorageState.Delete;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns a portfolio array, will be sorted\\r\\n    function getSortedPortfolio(address account, uint8 assetArrayLength)\\r\\n        internal\\r\\n        view\\r\\n        returns (PortfolioAsset[] memory)\\r\\n    {\\r\\n        PortfolioAsset[] memory assets = _loadAssetArray(account, assetArrayLength);\\r\\n        // No sorting required for length of 1\\r\\n        if (assets.length <= 1) return assets;\\r\\n\\r\\n        _sortInPlace(assets);\\r\\n        return assets;\\r\\n    }\\r\\n\\r\\n    /// @notice Builds a portfolio array from storage. The new assets hint parameter will\\r\\n    /// be used to provision a new array for the new assets. This will increase gas efficiency\\r\\n    /// so that we don't have to make copies when we extend the array.\\r\\n    function buildPortfolioState(\\r\\n        address account,\\r\\n        uint8 assetArrayLength,\\r\\n        uint256 newAssetsHint\\r\\n    ) internal view returns (PortfolioState memory) {\\r\\n        PortfolioState memory state;\\r\\n        if (assetArrayLength == 0) return state;\\r\\n\\r\\n        state.storedAssets = getSortedPortfolio(account, assetArrayLength);\\r\\n        state.storedAssetLength = assetArrayLength;\\r\\n        state.newAssets = new PortfolioAsset[](newAssetsHint);\\r\\n\\r\\n        return state;\\r\\n    }\\r\\n\\r\\n    function _sortInPlace(PortfolioAsset[] memory assets) private pure {\\r\\n        uint256 length = assets.length;\\r\\n        uint256[] memory ids = new uint256[](length);\\r\\n        for (uint256 k; k < length; k++) {\\r\\n            PortfolioAsset memory asset = assets[k];\\r\\n            // Prepopulate the ids to calculate just once\\r\\n            ids[k] = TransferAssets.encodeAssetId(asset.currencyId, asset.maturity, asset.assetType);\\r\\n        }\\r\\n\\r\\n        // Uses insertion sort \\r\\n        uint256 i = 1;\\r\\n        while (i < length) {\\r\\n            uint256 j = i;\\r\\n            while (j > 0 && ids[j - 1] > ids[j]) {\\r\\n                // Swap j - 1 and j\\r\\n                (ids[j - 1], ids[j]) = (ids[j], ids[j - 1]);\\r\\n                (assets[j - 1], assets[j]) = (assets[j], assets[j - 1]);\\r\\n                j--;\\r\\n            }\\r\\n            i++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _loadAssetArray(address account, uint8 length)\\r\\n        private\\r\\n        view\\r\\n        returns (PortfolioAsset[] memory)\\r\\n    {\\r\\n        // This will overflow the storage pointer\\r\\n        require(length <= MAX_PORTFOLIO_ASSETS);\\r\\n\\r\\n        mapping(address => \\r\\n            PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS]) storage store = LibStorage.getPortfolioArrayStorage();\\r\\n        PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS] storage storageArray = store[account];\\r\\n        PortfolioAsset[] memory assets = new PortfolioAsset[](length);\\r\\n\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            PortfolioAssetStorage storage assetStorage = storageArray[i];\\r\\n            PortfolioAsset memory asset = assets[i];\\r\\n            uint256 slot;\\r\\n            assembly {\\r\\n                slot := assetStorage.slot\\r\\n            }\\r\\n\\r\\n            asset.currencyId = assetStorage.currencyId;\\r\\n            asset.maturity = assetStorage.maturity;\\r\\n            asset.assetType = assetStorage.assetType;\\r\\n            asset.notional = assetStorage.notional;\\r\\n            asset.storageSlot = slot;\\r\\n        }\\r\\n\\r\\n        return assets;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/global/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/// @title All shared constants for the Notional system should be declared here.\\r\\nlibrary Constants {\\r\\n    // Return code for cTokens that represents no error\\r\\n    uint256 internal constant COMPOUND_RETURN_CODE_NO_ERROR = 0;\\r\\n    uint8 internal constant CETH_DECIMAL_PLACES = 8;\\r\\n\\r\\n    // Token precision used for all internal balances, TokenHandler library ensures that we\\r\\n    // limit the dust amount caused by precision mismatches\\r\\n    int256 internal constant INTERNAL_TOKEN_PRECISION = 1e8;\\r\\n\\r\\n    // ETH will be initialized as the first currency\\r\\n    uint256 internal constant ETH_CURRENCY_ID = 1;\\r\\n    uint8 internal constant ETH_DECIMAL_PLACES = 18;\\r\\n    int256 internal constant ETH_DECIMALS = 1e18;\\r\\n    // Used to prevent overflow when converting decimal places to decimal precision values via\\r\\n    // 10**decimalPlaces. This is a safe value for int256 and uint256 variables. We apply this\\r\\n    // constraint when storing decimal places in governance.\\r\\n    uint256 internal constant MAX_DECIMAL_PLACES = 36;\\r\\n\\r\\n    // Address of the reserve account\\r\\n    address internal constant RESERVE = address(0);\\r\\n    // NOTE: this address is hardcoded in the library, must update this on deployment\\r\\n    address constant NOTE_TOKEN_ADDRESS = 0xCFEAead4947f0705A14ec42aC3D44129E1Ef3eD5;\\r\\n\\r\\n    // Most significant bit\\r\\n    bytes32 internal constant MSB =\\r\\n        0x8000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\r\\n    // Basis for percentages\\r\\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\\r\\n    // Max number of traded markets, also used as the maximum number of assets in a portfolio array\\r\\n    uint256 internal constant MAX_TRADED_MARKET_INDEX = 7;\\r\\n    // Max number of fCash assets in a bitmap, this is based on the gas costs of calculating free collateral\\r\\n    // for a bitmap portfolio\\r\\n    uint256 internal constant MAX_BITMAP_ASSETS = 20;\\r\\n    uint256 internal constant FIVE_MINUTES = 300;\\r\\n\\r\\n    // Internal date representations, note we use a 6/30/360 week/month/year convention here\\r\\n    uint256 internal constant DAY = 86400;\\r\\n    // We use six day weeks to ensure that all time references divide evenly\\r\\n    uint256 internal constant WEEK = DAY * 6;\\r\\n    uint256 internal constant MONTH = WEEK * 5;\\r\\n    uint256 internal constant QUARTER = MONTH * 3;\\r\\n    uint256 internal constant YEAR = QUARTER * 4;\\r\\n    \\r\\n    // These constants are used in DateTime.sol\\r\\n    uint256 internal constant DAYS_IN_WEEK = 6;\\r\\n    uint256 internal constant DAYS_IN_MONTH = 30;\\r\\n    uint256 internal constant DAYS_IN_QUARTER = 90;\\r\\n\\r\\n    // Offsets for each time chunk denominated in days\\r\\n    uint256 internal constant MAX_DAY_OFFSET = 90;\\r\\n    uint256 internal constant MAX_WEEK_OFFSET = 360;\\r\\n    uint256 internal constant MAX_MONTH_OFFSET = 2160;\\r\\n    uint256 internal constant MAX_QUARTER_OFFSET = 7650;\\r\\n\\r\\n    // Offsets for each time chunk denominated in bits\\r\\n    uint256 internal constant WEEK_BIT_OFFSET = 90;\\r\\n    uint256 internal constant MONTH_BIT_OFFSET = 135;\\r\\n    uint256 internal constant QUARTER_BIT_OFFSET = 195;\\r\\n\\r\\n    // This is a constant that represents the time period that all rates are normalized by, 360 days\\r\\n    uint256 internal constant IMPLIED_RATE_TIME = 360 * DAY;\\r\\n    // Number of decimal places that rates are stored in, equals 100%\\r\\n    int256 internal constant RATE_PRECISION = 1e9;\\r\\n    // One basis point in RATE_PRECISION terms\\r\\n    uint256 internal constant BASIS_POINT = uint256(RATE_PRECISION / 10000);\\r\\n    // Used to when calculating the amount to deleverage of a market when minting nTokens\\r\\n    uint256 internal constant DELEVERAGE_BUFFER = 300 * BASIS_POINT;\\r\\n    // Used for scaling cash group factors\\r\\n    uint256 internal constant FIVE_BASIS_POINTS = 5 * BASIS_POINT;\\r\\n    // Used for residual purchase incentive and cash withholding buffer\\r\\n    uint256 internal constant TEN_BASIS_POINTS = 10 * BASIS_POINT;\\r\\n\\r\\n    // This is the ABDK64x64 representation of RATE_PRECISION\\r\\n    // RATE_PRECISION_64x64 = ABDKMath64x64.fromUint(RATE_PRECISION)\\r\\n    int128 internal constant RATE_PRECISION_64x64 = 0x3b9aca000000000000000000;\\r\\n    int128 internal constant LOG_RATE_PRECISION_64x64 = 382276781265598821176;\\r\\n    // Limit the market proportion so that borrowing cannot hit extremely high interest rates\\r\\n    int256 internal constant MAX_MARKET_PROPORTION = RATE_PRECISION * 96 / 100;\\r\\n\\r\\n    uint8 internal constant FCASH_ASSET_TYPE = 1;\\r\\n    // Liquidity token asset types are 1 + marketIndex (where marketIndex is 1-indexed)\\r\\n    uint8 internal constant MIN_LIQUIDITY_TOKEN_INDEX = 2;\\r\\n    uint8 internal constant MAX_LIQUIDITY_TOKEN_INDEX = 8;\\r\\n\\r\\n    // Used for converting bool to bytes1, solidity does not have a native conversion\\r\\n    // method for this\\r\\n    bytes1 internal constant BOOL_FALSE = 0x00;\\r\\n    bytes1 internal constant BOOL_TRUE = 0x01;\\r\\n\\r\\n    // Account context flags\\r\\n    bytes1 internal constant HAS_ASSET_DEBT = 0x01;\\r\\n    bytes1 internal constant HAS_CASH_DEBT = 0x02;\\r\\n    bytes2 internal constant ACTIVE_IN_PORTFOLIO = 0x8000;\\r\\n    bytes2 internal constant ACTIVE_IN_BALANCES = 0x4000;\\r\\n    bytes2 internal constant UNMASK_FLAGS = 0x3FFF;\\r\\n    uint16 internal constant MAX_CURRENCIES = uint16(UNMASK_FLAGS);\\r\\n\\r\\n    // Equal to 100% of all deposit amounts for nToken liquidity across fCash markets.\\r\\n    int256 internal constant DEPOSIT_PERCENT_BASIS = 1e8;\\r\\n\\r\\n    // nToken Parameters: there are offsets in the nTokenParameters bytes6 variable returned\\r\\n    // in nTokenHandler. Each constant represents a position in the byte array.\\r\\n    uint8 internal constant LIQUIDATION_HAIRCUT_PERCENTAGE = 0;\\r\\n    uint8 internal constant CASH_WITHHOLDING_BUFFER = 1;\\r\\n    uint8 internal constant RESIDUAL_PURCHASE_TIME_BUFFER = 2;\\r\\n    uint8 internal constant PV_HAIRCUT_PERCENTAGE = 3;\\r\\n    uint8 internal constant RESIDUAL_PURCHASE_INCENTIVE = 4;\\r\\n\\r\\n    // Liquidation parameters\\r\\n    // Default percentage of collateral that a liquidator is allowed to liquidate, will be higher if the account\\r\\n    // requires more collateral to be liquidated\\r\\n    int256 internal constant DEFAULT_LIQUIDATION_PORTION = 40;\\r\\n    // Percentage of local liquidity token cash claim delivered to the liquidator for liquidating liquidity tokens\\r\\n    int256 internal constant TOKEN_REPO_INCENTIVE_PERCENT = 30;\\r\\n\\r\\n    // Pause Router liquidation enabled states\\r\\n    bytes1 internal constant LOCAL_CURRENCY_ENABLED = 0x01;\\r\\n    bytes1 internal constant COLLATERAL_CURRENCY_ENABLED = 0x02;\\r\\n    bytes1 internal constant LOCAL_FCASH_ENABLED = 0x04;\\r\\n    bytes1 internal constant CROSS_CURRENCY_FCASH_ENABLED = 0x08;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/markets/Market.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./AssetRate.sol\\\";\\r\\nimport \\\"./CashGroup.sol\\\";\\r\\nimport \\\"./DateTime.sol\\\";\\r\\nimport \\\"../balances/BalanceHandler.sol\\\";\\r\\nimport \\\"../../global/LibStorage.sol\\\";\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../math/ABDKMath64x64.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary Market {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeInt256 for int256;\\r\\n    using CashGroup for CashGroupParameters;\\r\\n    using AssetRate for AssetRateParameters;\\r\\n\\r\\n    // Max positive value for a ABDK64x64 integer\\r\\n    int256 private constant MAX64 = 0x7FFFFFFFFFFFFFFF;\\r\\n\\r\\n    /// @notice Add liquidity to a market, assuming that it is initialized. If not then\\r\\n    /// this method will revert and the market must be initialized first.\\r\\n    /// Return liquidityTokens and negative fCash to the portfolio\\r\\n    function addLiquidity(MarketParameters memory market, int256 assetCash)\\r\\n        internal\\r\\n        returns (int256 liquidityTokens, int256 fCash)\\r\\n    {\\r\\n        require(market.totalLiquidity > 0, \\\"M: zero liquidity\\\");\\r\\n        if (assetCash == 0) return (0, 0);\\r\\n        require(assetCash > 0); // dev: negative asset cash\\r\\n\\r\\n        liquidityTokens = market.totalLiquidity.mul(assetCash).div(market.totalAssetCash);\\r\\n        // No need to convert this to underlying, assetCash / totalAssetCash is a unitless proportion.\\r\\n        fCash = market.totalfCash.mul(assetCash).div(market.totalAssetCash);\\r\\n\\r\\n        market.totalLiquidity = market.totalLiquidity.add(liquidityTokens);\\r\\n        market.totalfCash = market.totalfCash.add(fCash);\\r\\n        market.totalAssetCash = market.totalAssetCash.add(assetCash);\\r\\n        _setMarketStorageForLiquidity(market);\\r\\n        // Flip the sign to represent the LP's net position\\r\\n        fCash = fCash.neg();\\r\\n    }\\r\\n\\r\\n    /// @notice Remove liquidity from a market, assuming that it is initialized.\\r\\n    /// Return assetCash and positive fCash to the portfolio\\r\\n    function removeLiquidity(MarketParameters memory market, int256 tokensToRemove)\\r\\n        internal\\r\\n        returns (int256 assetCash, int256 fCash)\\r\\n    {\\r\\n        if (tokensToRemove == 0) return (0, 0);\\r\\n        require(tokensToRemove > 0); // dev: negative tokens to remove\\r\\n\\r\\n        assetCash = market.totalAssetCash.mul(tokensToRemove).div(market.totalLiquidity);\\r\\n        fCash = market.totalfCash.mul(tokensToRemove).div(market.totalLiquidity);\\r\\n\\r\\n        market.totalLiquidity = market.totalLiquidity.subNoNeg(tokensToRemove);\\r\\n        market.totalfCash = market.totalfCash.subNoNeg(fCash);\\r\\n        market.totalAssetCash = market.totalAssetCash.subNoNeg(assetCash);\\r\\n\\r\\n        _setMarketStorageForLiquidity(market);\\r\\n    }\\r\\n\\r\\n    function executeTrade(\\r\\n        MarketParameters memory market,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        int256 fCashToAccount,\\r\\n        uint256 timeToMaturity,\\r\\n        uint256 marketIndex\\r\\n    ) internal returns (int256 netAssetCash) {\\r\\n        int256 netAssetCashToReserve;\\r\\n        (netAssetCash, netAssetCashToReserve) = calculateTrade(\\r\\n            market,\\r\\n            cashGroup,\\r\\n            fCashToAccount,\\r\\n            timeToMaturity,\\r\\n            marketIndex\\r\\n        );\\r\\n\\r\\n        MarketStorage storage marketStorage = _getMarketStoragePointer(market);\\r\\n        _setMarketStorage(\\r\\n            marketStorage,\\r\\n            market.totalfCash,\\r\\n            market.totalAssetCash,\\r\\n            market.lastImpliedRate,\\r\\n            market.oracleRate,\\r\\n            market.previousTradeTime\\r\\n        );\\r\\n        BalanceHandler.incrementFeeToReserve(cashGroup.currencyId, netAssetCashToReserve);\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates the asset cash amount the results from trading fCashToAccount with the market. A positive\\r\\n    /// fCashToAccount is equivalent of lending, a negative is borrowing. Updates the market state in memory.\\r\\n    /// @param market the current market state\\r\\n    /// @param cashGroup cash group configuration parameters\\r\\n    /// @param fCashToAccount the fCash amount that will be deposited into the user's portfolio. The net change\\r\\n    /// to the market is in the opposite direction.\\r\\n    /// @param timeToMaturity number of seconds until maturity\\r\\n    /// @return netAssetCash, netAssetCashToReserve\\r\\n    function calculateTrade(\\r\\n        MarketParameters memory market,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        int256 fCashToAccount,\\r\\n        uint256 timeToMaturity,\\r\\n        uint256 marketIndex\\r\\n    ) internal view returns (int256, int256) {\\r\\n        // We return false if there is not enough fCash to support this trade.\\r\\n        // if fCashToAccount > 0 and totalfCash - fCashToAccount <= 0 then the trade will fail\\r\\n        // if fCashToAccount < 0 and totalfCash > 0 then this will always pass\\r\\n        if (market.totalfCash <= fCashToAccount) return (0, 0);\\r\\n\\r\\n        // Calculates initial rate factors for the trade\\r\\n        (int256 rateScalar, int256 totalCashUnderlying, int256 rateAnchor) =\\r\\n            getExchangeRateFactors(market, cashGroup, timeToMaturity, marketIndex);\\r\\n\\r\\n        // Calculates the exchange rate from cash to fCash before any liquidity fees\\r\\n        // are applied\\r\\n        int256 preFeeExchangeRate;\\r\\n        {\\r\\n            bool success;\\r\\n            (preFeeExchangeRate, success) = _getExchangeRate(\\r\\n                market.totalfCash,\\r\\n                totalCashUnderlying,\\r\\n                rateScalar,\\r\\n                rateAnchor,\\r\\n                fCashToAccount\\r\\n            );\\r\\n            if (!success) return (0, 0);\\r\\n        }\\r\\n\\r\\n        // Given the exchange rate, returns the net cash amounts to apply to each of the\\r\\n        // three relevant balances.\\r\\n        (int256 netCashToAccount, int256 netCashToMarket, int256 netCashToReserve) =\\r\\n            _getNetCashAmountsUnderlying(\\r\\n                cashGroup,\\r\\n                preFeeExchangeRate,\\r\\n                fCashToAccount,\\r\\n                timeToMaturity\\r\\n            );\\r\\n        // Signifies a failed net cash amount calculation\\r\\n        if (netCashToAccount == 0) return (0, 0);\\r\\n\\r\\n        {\\r\\n            // Set the new implied interest rate after the trade has taken effect, this\\r\\n            // will be used to calculate the next trader's interest rate.\\r\\n            market.totalfCash = market.totalfCash.subNoNeg(fCashToAccount);\\r\\n            market.lastImpliedRate = getImpliedRate(\\r\\n                market.totalfCash,\\r\\n                totalCashUnderlying.add(netCashToMarket),\\r\\n                rateScalar,\\r\\n                rateAnchor,\\r\\n                timeToMaturity\\r\\n            );\\r\\n\\r\\n            // It's technically possible that the implied rate is actually exactly zero (or\\r\\n            // more accurately the natural log rounds down to zero) but we will still fail\\r\\n            // in this case. If this does happen we may assume that markets are not initialized.\\r\\n            if (market.lastImpliedRate == 0) return (0, 0);\\r\\n        }\\r\\n\\r\\n        return\\r\\n            _setNewMarketState(\\r\\n                market,\\r\\n                cashGroup.assetRate,\\r\\n                netCashToAccount,\\r\\n                netCashToMarket,\\r\\n                netCashToReserve\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @notice Returns factors for calculating exchange rates\\r\\n    /// @return\\r\\n    ///    rateScalar: a scalar value in rate precision that defines the slope of the line\\r\\n    ///    totalCashUnderlying: the converted asset cash to underlying cash for calculating\\r\\n    ///    the exchange rates for the trade\\r\\n    ///    rateAnchor: an offset from the x axis to maintain interest rate continuity over time\\r\\n    function getExchangeRateFactors(\\r\\n        MarketParameters memory market,\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        uint256 timeToMaturity,\\r\\n        uint256 marketIndex\\r\\n    )\\r\\n        internal\\r\\n        pure\\r\\n        returns (\\r\\n            int256,\\r\\n            int256,\\r\\n            int256\\r\\n        )\\r\\n    {\\r\\n        int256 rateScalar = cashGroup.getRateScalar(marketIndex, timeToMaturity);\\r\\n        int256 totalCashUnderlying = cashGroup.assetRate.convertToUnderlying(market.totalAssetCash);\\r\\n\\r\\n        // This would result in a divide by zero\\r\\n        if (market.totalfCash == 0 || totalCashUnderlying == 0) return (0, 0, 0);\\r\\n\\r\\n        // Get the rate anchor given the market state, this will establish the baseline for where\\r\\n        // the exchange rate is set.\\r\\n        int256 rateAnchor;\\r\\n        {\\r\\n            bool success;\\r\\n            (rateAnchor, success) = _getRateAnchor(\\r\\n                market.totalfCash,\\r\\n                market.lastImpliedRate,\\r\\n                totalCashUnderlying,\\r\\n                rateScalar,\\r\\n                timeToMaturity\\r\\n            );\\r\\n            if (!success) return (0, 0, 0);\\r\\n        }\\r\\n\\r\\n        return (rateScalar, totalCashUnderlying, rateAnchor);\\r\\n    }\\r\\n\\r\\n    /// @dev Returns net asset cash amounts to the account, the market and the reserve\\r\\n    /// @return\\r\\n    ///     netCashToAccount: this is a positive or negative amount of cash change to the account\\r\\n    ///     netCashToMarket: this is a positive or negative amount of cash change in the market\\r\\n    //      netCashToReserve: this is always a positive amount of cash accrued to the reserve\\r\\n    function _getNetCashAmountsUnderlying(\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        int256 preFeeExchangeRate,\\r\\n        int256 fCashToAccount,\\r\\n        uint256 timeToMaturity\\r\\n    )\\r\\n        private\\r\\n        pure\\r\\n        returns (\\r\\n            int256,\\r\\n            int256,\\r\\n            int256\\r\\n        )\\r\\n    {\\r\\n        // Fees are specified in basis points which is an rate precision denomination. We convert this to\\r\\n        // an exchange rate denomination for the given time to maturity. (i.e. get e^(fee * t) and multiply\\r\\n        // or divide depending on the side of the trade).\\r\\n        // tradeExchangeRate = exp((tradeInterestRateNoFee +/- fee) * timeToMaturity)\\r\\n        // tradeExchangeRate = tradeExchangeRateNoFee (* or /) exp(fee * timeToMaturity)\\r\\n        // cash = fCash / exchangeRate, exchangeRate > 1\\r\\n        int256 preFeeCashToAccount =\\r\\n            fCashToAccount.divInRatePrecision(preFeeExchangeRate).neg();\\r\\n        int256 fee = getExchangeRateFromImpliedRate(cashGroup.getTotalFee(), timeToMaturity);\\r\\n\\r\\n        if (fCashToAccount > 0) {\\r\\n            // Lending\\r\\n            // Dividing reduces exchange rate, lending should receive less fCash for cash\\r\\n            int256 postFeeExchangeRate = preFeeExchangeRate.divInRatePrecision(fee);\\r\\n            // It's possible that the fee pushes exchange rates into negative territory. This is not possible\\r\\n            // when borrowing. If this happens then the trade has failed.\\r\\n            if (postFeeExchangeRate < Constants.RATE_PRECISION) return (0, 0, 0);\\r\\n\\r\\n            // cashToAccount = -(fCashToAccount / exchangeRate)\\r\\n            // postFeeExchangeRate = preFeeExchangeRate / feeExchangeRate\\r\\n            // preFeeCashToAccount = -(fCashToAccount / preFeeExchangeRate)\\r\\n            // postFeeCashToAccount = -(fCashToAccount / postFeeExchangeRate)\\r\\n            // netFee = preFeeCashToAccount - postFeeCashToAccount\\r\\n            // netFee = (fCashToAccount / postFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\\r\\n            // netFee = ((fCashToAccount * feeExchangeRate) / preFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\\r\\n            // netFee = (fCashToAccount / preFeeExchangeRate) * (feeExchangeRate - 1)\\r\\n            // netFee = -(preFeeCashToAccount) * (feeExchangeRate - 1)\\r\\n            // netFee = preFeeCashToAccount * (1 - feeExchangeRate)\\r\\n            // RATE_PRECISION - fee will be negative here, preFeeCashToAccount < 0, fee > 0\\r\\n            fee = preFeeCashToAccount.mulInRatePrecision(Constants.RATE_PRECISION.sub(fee));\\r\\n        } else {\\r\\n            // Borrowing\\r\\n            // cashToAccount = -(fCashToAccount / exchangeRate)\\r\\n            // postFeeExchangeRate = preFeeExchangeRate * feeExchangeRate\\r\\n\\r\\n            // netFee = preFeeCashToAccount - postFeeCashToAccount\\r\\n            // netFee = (fCashToAccount / postFeeExchangeRate) - (fCashToAccount / preFeeExchangeRate)\\r\\n            // netFee = ((fCashToAccount / (feeExchangeRate * preFeeExchangeRate)) - (fCashToAccount / preFeeExchangeRate)\\r\\n            // netFee = (fCashToAccount / preFeeExchangeRate) * (1 / feeExchangeRate - 1)\\r\\n            // netFee = preFeeCashToAccount * ((1 - feeExchangeRate) / feeExchangeRate)\\r\\n            // NOTE: preFeeCashToAccount is negative in this branch so we negate it to ensure that fee is a positive number\\r\\n            // preFee * (1 - fee) / fee will be negative, use neg() to flip to positive\\r\\n            // RATE_PRECISION - fee will be negative\\r\\n            fee = preFeeCashToAccount.mul(Constants.RATE_PRECISION.sub(fee)).div(fee).neg();\\r\\n        }\\r\\n\\r\\n        int256 cashToReserve =\\r\\n            fee.mul(cashGroup.getReserveFeeShare()).div(Constants.PERCENTAGE_DECIMALS);\\r\\n\\r\\n        return (\\r\\n            // postFeeCashToAccount = preFeeCashToAccount - fee\\r\\n            preFeeCashToAccount.sub(fee),\\r\\n            // netCashToMarket = -(preFeeCashToAccount - fee + cashToReserve)\\r\\n            (preFeeCashToAccount.sub(fee).add(cashToReserve)).neg(),\\r\\n            cashToReserve\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the new market state\\r\\n    /// @return\\r\\n    ///     netAssetCashToAccount: the positive or negative change in asset cash to the account\\r\\n    ///     assetCashToReserve: the positive amount of cash that accrues to the reserve\\r\\n    function _setNewMarketState(\\r\\n        MarketParameters memory market,\\r\\n        AssetRateParameters memory assetRate,\\r\\n        int256 netCashToAccount,\\r\\n        int256 netCashToMarket,\\r\\n        int256 netCashToReserve\\r\\n    ) private view returns (int256, int256) {\\r\\n        int256 netAssetCashToMarket = assetRate.convertFromUnderlying(netCashToMarket);\\r\\n        // Set storage checks that total asset cash is above zero\\r\\n        market.totalAssetCash = market.totalAssetCash.add(netAssetCashToMarket);\\r\\n\\r\\n        // Sets the trade time for the next oracle update\\r\\n        market.previousTradeTime = block.timestamp;\\r\\n        int256 assetCashToReserve = assetRate.convertFromUnderlying(netCashToReserve);\\r\\n        int256 netAssetCashToAccount = assetRate.convertFromUnderlying(netCashToAccount);\\r\\n        return (netAssetCashToAccount, assetCashToReserve);\\r\\n    }\\r\\n\\r\\n    /// @notice Rate anchors update as the market gets closer to maturity. Rate anchors are not comparable\\r\\n    /// across time or markets but implied rates are. The goal here is to ensure that the implied rate\\r\\n    /// before and after the rate anchor update is the same. Therefore, the market will trade at the same implied\\r\\n    /// rate that it last traded at. If these anchors do not update then it opens up the opportunity for arbitrage\\r\\n    /// which will hurt the liquidity providers.\\r\\n    ///\\r\\n    /// The rate anchor will update as the market rolls down to maturity. The calculation is:\\r\\n    /// newExchangeRate = e^(lastImpliedRate * timeToMaturity / Constants.IMPLIED_RATE_TIME)\\r\\n    /// newAnchor = newExchangeRate - ln((proportion / (1 - proportion)) / rateScalar\\r\\n    ///\\r\\n    /// where:\\r\\n    /// lastImpliedRate = ln(exchangeRate') * (Constants.IMPLIED_RATE_TIME / timeToMaturity')\\r\\n    ///      (calculated when the last trade in the market was made)\\r\\n    /// @return the new rate anchor and a boolean that signifies success\\r\\n    function _getRateAnchor(\\r\\n        int256 totalfCash,\\r\\n        uint256 lastImpliedRate,\\r\\n        int256 totalCashUnderlying,\\r\\n        int256 rateScalar,\\r\\n        uint256 timeToMaturity\\r\\n    ) internal pure returns (int256, bool) {\\r\\n        // This is the exchange rate at the new time to maturity\\r\\n        int256 newExchangeRate = getExchangeRateFromImpliedRate(lastImpliedRate, timeToMaturity);\\r\\n        if (newExchangeRate < Constants.RATE_PRECISION) return (0, false);\\r\\n\\r\\n        int256 rateAnchor;\\r\\n        {\\r\\n            // totalfCash / (totalfCash + totalCashUnderlying)\\r\\n            int256 proportion =\\r\\n                totalfCash.divInRatePrecision(totalfCash.add(totalCashUnderlying));\\r\\n\\r\\n            (int256 lnProportion, bool success) = _logProportion(proportion);\\r\\n            if (!success) return (0, false);\\r\\n\\r\\n            // newExchangeRate - ln(proportion / (1 - proportion)) / rateScalar\\r\\n            rateAnchor = newExchangeRate.sub(lnProportion.divInRatePrecision(rateScalar));\\r\\n        }\\r\\n\\r\\n        return (rateAnchor, true);\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates the current market implied rate.\\r\\n    /// @return the implied rate and a bool that is true on success\\r\\n    function getImpliedRate(\\r\\n        int256 totalfCash,\\r\\n        int256 totalCashUnderlying,\\r\\n        int256 rateScalar,\\r\\n        int256 rateAnchor,\\r\\n        uint256 timeToMaturity\\r\\n    ) internal pure returns (uint256) {\\r\\n        // This will check for exchange rates < Constants.RATE_PRECISION\\r\\n        (int256 exchangeRate, bool success) =\\r\\n            _getExchangeRate(totalfCash, totalCashUnderlying, rateScalar, rateAnchor, 0);\\r\\n        if (!success) return 0;\\r\\n\\r\\n        // Uses continuous compounding to calculate the implied rate:\\r\\n        // ln(exchangeRate) * Constants.IMPLIED_RATE_TIME / timeToMaturity\\r\\n        int128 rate = ABDKMath64x64.fromInt(exchangeRate);\\r\\n        // Scales down to a floating point for LN\\r\\n        int128 rateScaled = ABDKMath64x64.div(rate, Constants.RATE_PRECISION_64x64);\\r\\n        // We will not have a negative log here because we check that exchangeRate > Constants.RATE_PRECISION\\r\\n        // inside getExchangeRate\\r\\n        int128 lnRateScaled = ABDKMath64x64.ln(rateScaled);\\r\\n        // Scales up to a fixed point\\r\\n        uint256 lnRate =\\r\\n            ABDKMath64x64.toUInt(ABDKMath64x64.mul(lnRateScaled, Constants.RATE_PRECISION_64x64));\\r\\n\\r\\n        // lnRate * IMPLIED_RATE_TIME / ttm\\r\\n        uint256 impliedRate = lnRate.mul(Constants.IMPLIED_RATE_TIME).div(timeToMaturity);\\r\\n\\r\\n        // Implied rates over 429% will overflow, this seems like a safe assumption\\r\\n        if (impliedRate > type(uint32).max) return 0;\\r\\n\\r\\n        return impliedRate;\\r\\n    }\\r\\n\\r\\n    /// @notice Converts an implied rate to an exchange rate given a time to maturity. The\\r\\n    /// formula is E = e^rt\\r\\n    function getExchangeRateFromImpliedRate(uint256 impliedRate, uint256 timeToMaturity)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int256)\\r\\n    {\\r\\n        int128 expValue =\\r\\n            ABDKMath64x64.fromUInt(\\r\\n                impliedRate.mul(timeToMaturity).div(Constants.IMPLIED_RATE_TIME)\\r\\n            );\\r\\n        int128 expValueScaled = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\\r\\n        int128 expResult = ABDKMath64x64.exp(expValueScaled);\\r\\n        int128 expResultScaled = ABDKMath64x64.mul(expResult, Constants.RATE_PRECISION_64x64);\\r\\n\\r\\n        return ABDKMath64x64.toInt(expResultScaled);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the exchange rate between fCash and cash for the given market\\r\\n    /// Calculates the following exchange rate:\\r\\n    ///     (1 / rateScalar) * ln(proportion / (1 - proportion)) + rateAnchor\\r\\n    /// where:\\r\\n    ///     proportion = totalfCash / (totalfCash + totalUnderlyingCash)\\r\\n    /// @dev has an underscore to denote as private but is marked internal for the mock\\r\\n    function _getExchangeRate(\\r\\n        int256 totalfCash,\\r\\n        int256 totalCashUnderlying,\\r\\n        int256 rateScalar,\\r\\n        int256 rateAnchor,\\r\\n        int256 fCashToAccount\\r\\n    ) internal pure returns (int256, bool) {\\r\\n        int256 numerator = totalfCash.subNoNeg(fCashToAccount);\\r\\n\\r\\n        // This is the proportion scaled by Constants.RATE_PRECISION\\r\\n        // (totalfCash + fCash) / (totalfCash + totalCashUnderlying)\\r\\n        int256 proportion =\\r\\n            numerator.divInRatePrecision(totalfCash.add(totalCashUnderlying));\\r\\n\\r\\n        // This limit is here to prevent the market from reaching extremely high interest rates via an\\r\\n        // excessively large proportion (high amounts of fCash relative to cash).\\r\\n        // Market proportion can only increase via borrowing (fCash is added to the market and cash is\\r\\n        // removed). Over time, the returns from asset cash will slightly decrease the proportion (the\\r\\n        // value of cash underlying in the market must be monotonically increasing). Therefore it is not\\r\\n        // possible for the proportion to go over max market proportion unless borrowing occurs.\\r\\n        if (proportion > Constants.MAX_MARKET_PROPORTION) return (0, false);\\r\\n\\r\\n        (int256 lnProportion, bool success) = _logProportion(proportion);\\r\\n        if (!success) return (0, false);\\r\\n\\r\\n        // lnProportion / rateScalar + rateAnchor\\r\\n        int256 rate = lnProportion.divInRatePrecision(rateScalar).add(rateAnchor);\\r\\n        // Do not succeed if interest rates fall below 1\\r\\n        if (rate < Constants.RATE_PRECISION) {\\r\\n            return (0, false);\\r\\n        } else {\\r\\n            return (rate, true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev This method calculates the log of the proportion inside the logit function which is\\r\\n    /// defined as ln(proportion / (1 - proportion)). Special handling here is required to deal with\\r\\n    /// fixed point precision and the ABDK library.\\r\\n    function _logProportion(int256 proportion) internal pure returns (int256, bool) {\\r\\n        // This will result in divide by zero, short circuit\\r\\n        if (proportion == Constants.RATE_PRECISION) return (0, false);\\r\\n\\r\\n        // Convert proportion to what is used inside the logit function (p / (1-p))\\r\\n        int256 logitP = proportion.divInRatePrecision(Constants.RATE_PRECISION.sub(proportion));\\r\\n\\r\\n        // ABDK does not handle log of numbers that are less than 1, in order to get the right value\\r\\n        // scaled by RATE_PRECISION we use the log identity:\\r\\n        // (ln(logitP / RATE_PRECISION)) * RATE_PRECISION = (ln(logitP) - ln(RATE_PRECISION)) * RATE_PRECISION\\r\\n        int128 abdkProportion = ABDKMath64x64.fromInt(logitP);\\r\\n        // Here, abdk will revert due to negative log so abort\\r\\n        if (abdkProportion <= 0) return (0, false);\\r\\n        int256 result =\\r\\n            ABDKMath64x64.toInt(\\r\\n                ABDKMath64x64.mul(\\r\\n                    ABDKMath64x64.sub(\\r\\n                        ABDKMath64x64.ln(abdkProportion),\\r\\n                        Constants.LOG_RATE_PRECISION_64x64\\r\\n                    ),\\r\\n                    Constants.RATE_PRECISION_64x64\\r\\n                )\\r\\n            );\\r\\n\\r\\n        return (result, true);\\r\\n    }\\r\\n\\r\\n    /// @notice Oracle rate protects against short term price manipulation. Time window will be set to a value\\r\\n    /// on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example,\\r\\n    /// a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates.\\r\\n    /// Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then\\r\\n    /// be liquidated.\\r\\n    ///\\r\\n    /// Oracle rates are calculated when the market is loaded from storage.\\r\\n    ///\\r\\n    /// The oracle rate is a lagged weighted average over a short term price window. If we are past\\r\\n    /// the short term window then we just set the rate to the lastImpliedRate, otherwise we take the\\r\\n    /// weighted average:\\r\\n    ///     lastImpliedRatePreTrade * (currentTs - previousTs) / timeWindow +\\r\\n    ///         oracleRatePrevious * (1 - (currentTs - previousTs) / timeWindow)\\r\\n    function _updateRateOracle(\\r\\n        uint256 previousTradeTime,\\r\\n        uint256 lastImpliedRate,\\r\\n        uint256 oracleRate,\\r\\n        uint256 rateOracleTimeWindow,\\r\\n        uint256 blockTime\\r\\n    ) private pure returns (uint256) {\\r\\n        require(rateOracleTimeWindow > 0); // dev: update rate oracle, time window zero\\r\\n\\r\\n        // This can occur when using a view function get to a market state in the past\\r\\n        if (previousTradeTime > blockTime) return lastImpliedRate;\\r\\n\\r\\n        uint256 timeDiff = blockTime.sub(previousTradeTime);\\r\\n        if (timeDiff > rateOracleTimeWindow) {\\r\\n            // If past the time window just return the lastImpliedRate\\r\\n            return lastImpliedRate;\\r\\n        }\\r\\n\\r\\n        // (currentTs - previousTs) / timeWindow\\r\\n        uint256 lastTradeWeight =\\r\\n            timeDiff.mul(uint256(Constants.RATE_PRECISION)).div(rateOracleTimeWindow);\\r\\n\\r\\n        // 1 - (currentTs - previousTs) / timeWindow\\r\\n        uint256 oracleWeight = uint256(Constants.RATE_PRECISION).sub(lastTradeWeight);\\r\\n\\r\\n        uint256 newOracleRate =\\r\\n            (lastImpliedRate.mul(lastTradeWeight).add(oracleRate.mul(oracleWeight))).div(\\r\\n                uint256(Constants.RATE_PRECISION)\\r\\n            );\\r\\n\\r\\n        return newOracleRate;\\r\\n    }\\r\\n\\r\\n    function getOracleRate(\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 rateOracleTimeWindow,\\r\\n        uint256 blockTime\\r\\n    ) internal view returns (uint256) {\\r\\n        mapping(uint256 => mapping(uint256 => \\r\\n            mapping(uint256 => MarketStorage))) storage store = LibStorage.getMarketStorage();\\r\\n        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;\\r\\n        MarketStorage storage marketStorage = store[currencyId][maturity][settlementDate];\\r\\n\\r\\n        uint256 lastImpliedRate = marketStorage.lastImpliedRate;\\r\\n        uint256 oracleRate = marketStorage.oracleRate;\\r\\n        uint256 previousTradeTime = marketStorage.previousTradeTime;\\r\\n\\r\\n        // If the oracle rate is set to zero this can only be because the markets have past their settlement\\r\\n        // date but the new set of markets has not yet been initialized. This means that accounts cannot be liquidated\\r\\n        // during this time, but market initialization can be called by anyone so the actual time that this condition\\r\\n        // exists for should be quite short.\\r\\n        require(oracleRate > 0, \\\"Market not initialized\\\");\\r\\n\\r\\n        return\\r\\n            _updateRateOracle(\\r\\n                previousTradeTime,\\r\\n                lastImpliedRate,\\r\\n                oracleRate,\\r\\n                rateOracleTimeWindow,\\r\\n                blockTime\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @notice Reads a market object directly from storage. `loadMarket` should be called instead of this method\\r\\n    /// which ensures that the rate oracle is set properly.\\r\\n    function _loadMarketStorage(\\r\\n        MarketParameters memory market,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        bool needsLiquidity,\\r\\n        uint256 settlementDate\\r\\n    ) private view {\\r\\n        // Market object always uses the most current reference time as the settlement date\\r\\n        mapping(uint256 => mapping(uint256 => \\r\\n            mapping(uint256 => MarketStorage))) storage store = LibStorage.getMarketStorage();\\r\\n        MarketStorage storage marketStorage = store[currencyId][maturity][settlementDate];\\r\\n        bytes32 slot;\\r\\n        assembly {\\r\\n            slot := marketStorage.slot\\r\\n        }\\r\\n\\r\\n        market.storageSlot = slot;\\r\\n        market.maturity = maturity;\\r\\n        market.totalfCash = marketStorage.totalfCash;\\r\\n        market.totalAssetCash = marketStorage.totalAssetCash;\\r\\n        market.lastImpliedRate = marketStorage.lastImpliedRate;\\r\\n        market.oracleRate = marketStorage.oracleRate;\\r\\n        market.previousTradeTime = marketStorage.previousTradeTime;\\r\\n\\r\\n        if (needsLiquidity) {\\r\\n            market.totalLiquidity = marketStorage.totalLiquidity;\\r\\n        } else {\\r\\n            market.totalLiquidity = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getMarketStoragePointer(\\r\\n        MarketParameters memory market\\r\\n    ) private pure returns (MarketStorage storage marketStorage) {\\r\\n        bytes32 slot = market.storageSlot;\\r\\n        assembly {\\r\\n            marketStorage.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _setMarketStorageForLiquidity(MarketParameters memory market) internal {\\r\\n        MarketStorage storage marketStorage = _getMarketStoragePointer(market);\\r\\n        // Oracle rate does not change on liquidity\\r\\n        uint32 storedOracleRate = marketStorage.oracleRate;\\r\\n\\r\\n        _setMarketStorage(\\r\\n            marketStorage,\\r\\n            market.totalfCash,\\r\\n            market.totalAssetCash,\\r\\n            market.lastImpliedRate,\\r\\n            storedOracleRate,\\r\\n            market.previousTradeTime\\r\\n        );\\r\\n\\r\\n        _setTotalLiquidity(marketStorage, market.totalLiquidity);\\r\\n    }\\r\\n\\r\\n    function setMarketStorageForInitialize(\\r\\n        MarketParameters memory market,\\r\\n        uint256 currencyId,\\r\\n        uint256 settlementDate\\r\\n    ) internal {\\r\\n        // On initialization we have not yet calculated the storage slot so we get it here.\\r\\n        mapping(uint256 => mapping(uint256 => \\r\\n            mapping(uint256 => MarketStorage))) storage store = LibStorage.getMarketStorage();\\r\\n        MarketStorage storage marketStorage = store[currencyId][market.maturity][settlementDate];\\r\\n\\r\\n        _setMarketStorage(\\r\\n            marketStorage,\\r\\n            market.totalfCash,\\r\\n            market.totalAssetCash,\\r\\n            market.lastImpliedRate,\\r\\n            market.oracleRate,\\r\\n            market.previousTradeTime\\r\\n        );\\r\\n\\r\\n        _setTotalLiquidity(marketStorage, market.totalLiquidity);\\r\\n    }\\r\\n\\r\\n    function _setTotalLiquidity(\\r\\n        MarketStorage storage marketStorage,\\r\\n        int256 totalLiquidity\\r\\n    ) internal {\\r\\n        require(totalLiquidity >= 0 && totalLiquidity <= type(uint80).max); // dev: market storage totalLiquidity overflow\\r\\n        marketStorage.totalLiquidity = uint80(totalLiquidity);\\r\\n    }\\r\\n\\r\\n    function _setMarketStorage(\\r\\n        MarketStorage storage marketStorage,\\r\\n        int256 totalfCash,\\r\\n        int256 totalAssetCash,\\r\\n        uint256 lastImpliedRate,\\r\\n        uint256 oracleRate,\\r\\n        uint256 previousTradeTime\\r\\n    ) private {\\r\\n        require(totalfCash >= 0 && totalfCash <= type(uint80).max); // dev: storage totalfCash overflow\\r\\n        require(totalAssetCash >= 0 && totalAssetCash <= type(uint80).max); // dev: storage totalAssetCash overflow\\r\\n        require(0 < lastImpliedRate && lastImpliedRate <= type(uint32).max); // dev: storage lastImpliedRate overflow\\r\\n        require(0 < oracleRate && oracleRate <= type(uint32).max); // dev: storage oracleRate overflow\\r\\n        require(0 <= previousTradeTime && previousTradeTime <= type(uint32).max); // dev: storage previous trade time overflow\\r\\n\\r\\n        marketStorage.totalfCash = uint80(totalfCash);\\r\\n        marketStorage.totalAssetCash = uint80(totalAssetCash);\\r\\n        marketStorage.lastImpliedRate = uint32(lastImpliedRate);\\r\\n        marketStorage.oracleRate = uint32(oracleRate);\\r\\n        marketStorage.previousTradeTime = uint32(previousTradeTime);\\r\\n    }\\r\\n\\r\\n    /// @notice Creates a market object and ensures that the rate oracle time window is updated appropriately.\\r\\n    function loadMarket(\\r\\n        MarketParameters memory market,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime,\\r\\n        bool needsLiquidity,\\r\\n        uint256 rateOracleTimeWindow\\r\\n    ) internal view {\\r\\n        // Always reference the current settlement date\\r\\n        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;\\r\\n        loadMarketWithSettlementDate(\\r\\n            market,\\r\\n            currencyId,\\r\\n            maturity,\\r\\n            blockTime,\\r\\n            needsLiquidity,\\r\\n            rateOracleTimeWindow,\\r\\n            settlementDate\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Creates a market object and ensures that the rate oracle time window is updated appropriately, this\\r\\n    /// is mainly used in the InitializeMarketAction contract.\\r\\n    function loadMarketWithSettlementDate(\\r\\n        MarketParameters memory market,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime,\\r\\n        bool needsLiquidity,\\r\\n        uint256 rateOracleTimeWindow,\\r\\n        uint256 settlementDate\\r\\n    ) internal view {\\r\\n        _loadMarketStorage(market, currencyId, maturity, needsLiquidity, settlementDate);\\r\\n\\r\\n        market.oracleRate = _updateRateOracle(\\r\\n            market.previousTradeTime,\\r\\n            market.lastImpliedRate,\\r\\n            market.oracleRate,\\r\\n            rateOracleTimeWindow,\\r\\n            blockTime\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function loadSettlementMarket(\\r\\n        MarketParameters memory market,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 settlementDate\\r\\n    ) internal view {\\r\\n        _loadMarketStorage(market, currencyId, maturity, true, settlementDate);\\r\\n    }\\r\\n\\r\\n    /// Uses Newton's method to converge on an fCash amount given the amount of\\r\\n    /// cash. The relation between cash and fcash is:\\r\\n    /// cashAmount * exchangeRate * fee + fCash = 0\\r\\n    /// where exchangeRate(fCash) = (rateScalar ^ -1) * ln(p / (1 - p)) + rateAnchor\\r\\n    ///       p = (totalfCash - fCash) / (totalfCash + totalCash)\\r\\n    ///       if cashAmount < 0: fee = feeRate ^ -1\\r\\n    ///       if cashAmount > 0: fee = feeRate\\r\\n    ///\\r\\n    /// Newton's method is:\\r\\n    /// fCash_(n+1) = fCash_n - f(fCash) / f'(fCash)\\r\\n    ///\\r\\n    /// f(fCash) = cashAmount * exchangeRate(fCash) * fee + fCash\\r\\n    ///\\r\\n    ///                                    (totalfCash + totalCash)\\r\\n    /// exchangeRate'(fCash) = -  ------------------------------------------\\r\\n    ///                           (totalfCash - fCash) * (totalCash + fCash)\\r\\n    ///\\r\\n    /// https://www.wolframalpha.com/input/?i=ln%28%28%28a-x%29%2F%28a%2Bb%29%29%2F%281-%28a-x%29%2F%28a%2Bb%29%29%29\\r\\n    ///\\r\\n    ///                     (cashAmount * fee) * (totalfCash + totalCash)\\r\\n    /// f'(fCash) = 1 - ------------------------------------------------------\\r\\n    ///                 rateScalar * (totalfCash - fCash) * (totalCash + fCash)\\r\\n    ///\\r\\n    /// NOTE: each iteration costs about 11.3k so this is only done via a view function.\\r\\n    function getfCashGivenCashAmount(\\r\\n        int256 totalfCash,\\r\\n        int256 netCashToAccount,\\r\\n        int256 totalCashUnderlying,\\r\\n        int256 rateScalar,\\r\\n        int256 rateAnchor,\\r\\n        int256 feeRate,\\r\\n        int256 maxDelta\\r\\n    ) internal pure returns (int256) {\\r\\n        require(maxDelta >= 0);\\r\\n        int256 fCashChangeToAccountGuess = netCashToAccount.mulInRatePrecision(rateAnchor).neg();\\r\\n        for (uint8 i = 0; i < 250; i++) {\\r\\n            (int256 exchangeRate, bool success) =\\r\\n                _getExchangeRate(\\r\\n                    totalfCash,\\r\\n                    totalCashUnderlying,\\r\\n                    rateScalar,\\r\\n                    rateAnchor,\\r\\n                    fCashChangeToAccountGuess\\r\\n                );\\r\\n\\r\\n            require(success); // dev: invalid exchange rate\\r\\n            int256 delta =\\r\\n                _calculateDelta(\\r\\n                    netCashToAccount,\\r\\n                    totalfCash,\\r\\n                    totalCashUnderlying,\\r\\n                    rateScalar,\\r\\n                    fCashChangeToAccountGuess,\\r\\n                    exchangeRate,\\r\\n                    feeRate\\r\\n                );\\r\\n\\r\\n            if (delta.abs() <= maxDelta) return fCashChangeToAccountGuess;\\r\\n            fCashChangeToAccountGuess = fCashChangeToAccountGuess.sub(delta);\\r\\n        }\\r\\n\\r\\n        revert(\\\"No convergence\\\");\\r\\n    }\\r\\n\\r\\n    /// @dev Calculates: f(fCash) / f'(fCash)\\r\\n    /// f(fCash) = cashAmount * exchangeRate * fee + fCash\\r\\n    ///                     (cashAmount * fee) * (totalfCash + totalCash)\\r\\n    /// f'(fCash) = 1 - ------------------------------------------------------\\r\\n    ///                 rateScalar * (totalfCash - fCash) * (totalCash + fCash)\\r\\n    function _calculateDelta(\\r\\n        int256 cashAmount,\\r\\n        int256 totalfCash,\\r\\n        int256 totalCashUnderlying,\\r\\n        int256 rateScalar,\\r\\n        int256 fCashGuess,\\r\\n        int256 exchangeRate,\\r\\n        int256 feeRate\\r\\n    ) private pure returns (int256) {\\r\\n        int256 derivative;\\r\\n        // rateScalar * (totalfCash - fCash) * (totalCash + fCash)\\r\\n        // Precision: TOKEN_PRECISION ^ 2\\r\\n        int256 denominator =\\r\\n            rateScalar.mulInRatePrecision(\\r\\n                (totalfCash.sub(fCashGuess)).mul(totalCashUnderlying.add(fCashGuess))\\r\\n            );\\r\\n\\r\\n        if (fCashGuess > 0) {\\r\\n            // Lending\\r\\n            exchangeRate = exchangeRate.divInRatePrecision(feeRate);\\r\\n            require(exchangeRate >= Constants.RATE_PRECISION); // dev: rate underflow\\r\\n\\r\\n            // (cashAmount / fee) * (totalfCash + totalCash)\\r\\n            // Precision: TOKEN_PRECISION ^ 2\\r\\n            derivative = cashAmount\\r\\n                .mul(totalfCash.add(totalCashUnderlying))\\r\\n                .divInRatePrecision(feeRate);\\r\\n        } else {\\r\\n            // Borrowing\\r\\n            exchangeRate = exchangeRate.mulInRatePrecision(feeRate);\\r\\n            require(exchangeRate >= Constants.RATE_PRECISION); // dev: rate underflow\\r\\n\\r\\n            // (cashAmount * fee) * (totalfCash + totalCash)\\r\\n            // Precision: TOKEN_PRECISION ^ 2\\r\\n            derivative = cashAmount.mulInRatePrecision(\\r\\n                feeRate.mul(totalfCash.add(totalCashUnderlying))\\r\\n            );\\r\\n        }\\r\\n        // 1 - numerator / denominator\\r\\n        // Precision: TOKEN_PRECISION\\r\\n        derivative = Constants.INTERNAL_TOKEN_PRECISION.sub(derivative.div(denominator));\\r\\n\\r\\n        // f(fCash) = cashAmount * exchangeRate * fee + fCash\\r\\n        // NOTE: exchangeRate at this point already has the fee taken into account\\r\\n        int256 numerator = cashAmount.mulInRatePrecision(exchangeRate);\\r\\n        numerator = numerator.add(fCashGuess);\\r\\n\\r\\n        // f(fCash) / f'(fCash), note that they are both denominated as cashAmount so use TOKEN_PRECISION\\r\\n        // here instead of RATE_PRECISION\\r\\n        return numerator.mul(Constants.INTERNAL_TOKEN_PRECISION).div(derivative);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/markets/DateTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\n\\r\\nlibrary DateTime {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    /// @notice Returns the current reference time which is how all the AMM dates are calculated.\\r\\n    function getReferenceTime(uint256 blockTime) internal pure returns (uint256) {\\r\\n        require(blockTime >= Constants.QUARTER);\\r\\n        return blockTime - (blockTime % Constants.QUARTER);\\r\\n    }\\r\\n\\r\\n    /// @notice Truncates a date to midnight UTC time\\r\\n    function getTimeUTC0(uint256 time) internal pure returns (uint256) {\\r\\n        require(time >= Constants.DAY);\\r\\n        return time - (time % Constants.DAY);\\r\\n    }\\r\\n\\r\\n    /// @notice These are the predetermined market offsets for trading\\r\\n    /// @dev Markets are 1-indexed because the 0 index means that no markets are listed for the cash group.\\r\\n    function getTradedMarket(uint256 index) internal pure returns (uint256) {\\r\\n        if (index == 1) return Constants.QUARTER;\\r\\n        if (index == 2) return 2 * Constants.QUARTER;\\r\\n        if (index == 3) return Constants.YEAR;\\r\\n        if (index == 4) return 2 * Constants.YEAR;\\r\\n        if (index == 5) return 5 * Constants.YEAR;\\r\\n        if (index == 6) return 10 * Constants.YEAR;\\r\\n        if (index == 7) return 20 * Constants.YEAR;\\r\\n\\r\\n        revert(\\\"Invalid index\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Determines if the maturity falls on one of the valid on chain market dates.\\r\\n    function isValidMarketMaturity(\\r\\n        uint256 maxMarketIndex,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime\\r\\n    ) internal pure returns (bool) {\\r\\n        require(maxMarketIndex > 0, \\\"CG: no markets listed\\\");\\r\\n        require(maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX, \\\"CG: market index bound\\\");\\r\\n\\r\\n        if (maturity % Constants.QUARTER != 0) return false;\\r\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\r\\n\\r\\n        for (uint256 i = 1; i <= maxMarketIndex; i++) {\\r\\n            if (maturity == tRef.add(DateTime.getTradedMarket(i))) return true;\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /// @notice Determines if an idiosyncratic maturity is valid and returns the bit reference that is the case.\\r\\n    function isValidMaturity(\\r\\n        uint256 maxMarketIndex,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime\\r\\n    ) internal pure returns (bool) {\\r\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\r\\n        uint256 maxMaturity = tRef.add(DateTime.getTradedMarket(maxMarketIndex));\\r\\n        // Cannot trade past max maturity\\r\\n        if (maturity > maxMaturity) return false;\\r\\n\\r\\n        // prettier-ignore\\r\\n        (/* */, bool isValid) = DateTime.getBitNumFromMaturity(blockTime, maturity);\\r\\n        return isValid;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the market index for a given maturity, if the maturity is idiosyncratic\\r\\n    /// will return the nearest market index that is larger than the maturity.\\r\\n    /// @return uint marketIndex, bool isIdiosyncratic\\r\\n    function getMarketIndex(\\r\\n        uint256 maxMarketIndex,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime\\r\\n    ) internal pure returns (uint256, bool) {\\r\\n        require(maxMarketIndex > 0, \\\"CG: no markets listed\\\");\\r\\n        require(maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX, \\\"CG: market index bound\\\");\\r\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\r\\n\\r\\n        for (uint256 i = 1; i <= maxMarketIndex; i++) {\\r\\n            uint256 marketMaturity = tRef.add(DateTime.getTradedMarket(i));\\r\\n            // If market matches then is not idiosyncratic\\r\\n            if (marketMaturity == maturity) return (i, false);\\r\\n            // Returns the market that is immediately greater than the maturity\\r\\n            if (marketMaturity > maturity) return (i, true);\\r\\n        }\\r\\n\\r\\n        revert(\\\"CG: no market found\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Given a bit number and the reference time of the first bit, returns the bit number\\r\\n    /// of a given maturity.\\r\\n    /// @return bitNum and a true or false if the maturity falls on the exact bit\\r\\n    function getBitNumFromMaturity(uint256 blockTime, uint256 maturity)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256, bool)\\r\\n    {\\r\\n        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);\\r\\n\\r\\n        // Maturities must always divide days evenly\\r\\n        if (maturity % Constants.DAY != 0) return (0, false);\\r\\n        // Maturity cannot be in the past\\r\\n        if (blockTimeUTC0 >= maturity) return (0, false);\\r\\n\\r\\n        // Overflow check done above\\r\\n        // daysOffset has no remainders, checked above\\r\\n        uint256 daysOffset = (maturity - blockTimeUTC0) / Constants.DAY;\\r\\n\\r\\n        // These if statements need to fall through to the next one\\r\\n        if (daysOffset <= Constants.MAX_DAY_OFFSET) {\\r\\n            return (daysOffset, true);\\r\\n        } else if (daysOffset <= Constants.MAX_WEEK_OFFSET) {\\r\\n            // (daysOffset - MAX_DAY_OFFSET) is the days overflow into the week portion, must be > 0\\r\\n            // (blockTimeUTC0 % WEEK) / DAY is the offset into the week portion\\r\\n            // This returns the offset from the previous max offset in days\\r\\n            uint256 offsetInDays =\\r\\n                daysOffset -\\r\\n                    Constants.MAX_DAY_OFFSET +\\r\\n                    (blockTimeUTC0 % Constants.WEEK) /\\r\\n                    Constants.DAY;\\r\\n            \\r\\n            return (\\r\\n                // This converts the offset in days to its corresponding bit position, truncating down\\r\\n                // if it does not divide evenly into DAYS_IN_WEEK\\r\\n                Constants.WEEK_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_WEEK,\\r\\n                (offsetInDays % Constants.DAYS_IN_WEEK) == 0\\r\\n            );\\r\\n        } else if (daysOffset <= Constants.MAX_MONTH_OFFSET) {\\r\\n            uint256 offsetInDays =\\r\\n                daysOffset -\\r\\n                    Constants.MAX_WEEK_OFFSET +\\r\\n                    (blockTimeUTC0 % Constants.MONTH) /\\r\\n                    Constants.DAY;\\r\\n\\r\\n            return (\\r\\n                Constants.MONTH_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_MONTH,\\r\\n                (offsetInDays % Constants.DAYS_IN_MONTH) == 0\\r\\n            );\\r\\n        } else if (daysOffset <= Constants.MAX_QUARTER_OFFSET) {\\r\\n            uint256 offsetInDays =\\r\\n                daysOffset -\\r\\n                    Constants.MAX_MONTH_OFFSET +\\r\\n                    (blockTimeUTC0 % Constants.QUARTER) /\\r\\n                    Constants.DAY;\\r\\n\\r\\n            return (\\r\\n                Constants.QUARTER_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_QUARTER,\\r\\n                (offsetInDays % Constants.DAYS_IN_QUARTER) == 0\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // This is the maximum 1-indexed bit num, it is never valid because it is beyond the 20\\r\\n        // year max maturity\\r\\n        return (256, false);\\r\\n    }\\r\\n\\r\\n    /// @notice Given a bit number and a block time returns the maturity that the bit number\\r\\n    /// should reference. Bit numbers are one indexed.\\r\\n    function getMaturityFromBitNum(uint256 blockTime, uint256 bitNum)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        require(bitNum != 0); // dev: cash group get maturity from bit num is zero\\r\\n        require(bitNum <= 256); // dev: cash group get maturity from bit num overflow\\r\\n        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);\\r\\n        uint256 firstBit;\\r\\n\\r\\n        if (bitNum <= Constants.WEEK_BIT_OFFSET) {\\r\\n            return blockTimeUTC0 + bitNum * Constants.DAY;\\r\\n        } else if (bitNum <= Constants.MONTH_BIT_OFFSET) {\\r\\n            firstBit =\\r\\n                blockTimeUTC0 +\\r\\n                Constants.MAX_DAY_OFFSET * Constants.DAY -\\r\\n                // This backs up to the day that is divisible by a week\\r\\n                (blockTimeUTC0 % Constants.WEEK);\\r\\n            return firstBit + (bitNum - Constants.WEEK_BIT_OFFSET) * Constants.WEEK;\\r\\n        } else if (bitNum <= Constants.QUARTER_BIT_OFFSET) {\\r\\n            firstBit =\\r\\n                blockTimeUTC0 +\\r\\n                Constants.MAX_WEEK_OFFSET * Constants.DAY -\\r\\n                (blockTimeUTC0 % Constants.MONTH);\\r\\n            return firstBit + (bitNum - Constants.MONTH_BIT_OFFSET) * Constants.MONTH;\\r\\n        } else {\\r\\n            firstBit =\\r\\n                blockTimeUTC0 +\\r\\n                Constants.MAX_MONTH_OFFSET * Constants.DAY -\\r\\n                (blockTimeUTC0 % Constants.QUARTER);\\r\\n            return firstBit + (bitNum - Constants.QUARTER_BIT_OFFSET) * Constants.QUARTER;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/math/ABDKMath64x64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-4-Clause\\r\\n/*\\r\\n * ABDK Math 64.64 Smart Contract Library.  Copyright \u00a9 2019 by ABDK Consulting.\\r\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\r\\n */\\r\\npragma solidity ^0.5.0 || ^0.6.0 || ^0.7.0;\\r\\n\\r\\n/**\\r\\n * Smart contract library of mathematical functions operating with signed\\r\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\r\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\r\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\r\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\r\\n * represented by int128 type holding only the numerator.\\r\\n */\\r\\nlibrary ABDKMath64x64 {\\r\\n  /*\\r\\n   * Minimum value signed 64.64-bit fixed point number may have. \\r\\n   */\\r\\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\r\\n\\r\\n  /*\\r\\n   * Maximum value signed 64.64-bit fixed point number may have. \\r\\n   */\\r\\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\r\\n\\r\\n  /**\\r\\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\r\\n   * number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 256-bit integer number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function fromInt (int256 x) internal pure returns (int128) {\\r\\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\r\\n    return int128 (x << 64);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\\r\\n   * rounding down.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64-bit integer number\\r\\n   */\\r\\n  function toInt (int128 x) internal pure returns (int64) {\\r\\n    return int64 (x >> 64);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\r\\n   * number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x unsigned 256-bit integer number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function fromUInt (uint256 x) internal pure returns (int128) {\\r\\n    require (x <= 0x7FFFFFFFFFFFFFFF);\\r\\n    return int128 (x << 64);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\r\\n   * number rounding down.  Revert on underflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return unsigned 64-bit integer number\\r\\n   */\\r\\n  function toUInt (int128 x) internal pure returns (uint64) {\\r\\n    require (x >= 0);\\r\\n    return uint64 (x >> 64);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\r\\n   * number rounding down.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 128.128-bin fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function from128x128 (int256 x) internal pure returns (int128) {\\r\\n    int256 result = x >> 64;\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\r\\n   * number.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 128.128 fixed point number\\r\\n   */\\r\\n  function to128x128 (int128 x) internal pure returns (int256) {\\r\\n    return int256 (x) << 64;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x + y.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function add (int128 x, int128 y) internal pure returns (int128) {\\r\\n    int256 result = int256(x) + y;\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x - y.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function sub (int128 x, int128 y) internal pure returns (int128) {\\r\\n    int256 result = int256(x) - y;\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x * y rounding down.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function mul (int128 x, int128 y) internal pure returns (int128) {\\r\\n    int256 result = int256(x) * y >> 64;\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\r\\n   * number and y is signed 256-bit integer number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64 fixed point number\\r\\n   * @param y signed 256-bit integer number\\r\\n   * @return signed 256-bit integer number\\r\\n   */\\r\\n  function muli (int128 x, int256 y) internal pure returns (int256) {\\r\\n    if (x == MIN_64x64) {\\r\\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\r\\n        y <= 0x1000000000000000000000000000000000000000000000000);\\r\\n      return -y << 63;\\r\\n    } else {\\r\\n      bool negativeResult = false;\\r\\n      if (x < 0) {\\r\\n        x = -x;\\r\\n        negativeResult = true;\\r\\n      }\\r\\n      if (y < 0) {\\r\\n        y = -y; // We rely on overflow behavior here\\r\\n        negativeResult = !negativeResult;\\r\\n      }\\r\\n      uint256 absoluteResult = mulu (x, uint256 (y));\\r\\n      if (negativeResult) {\\r\\n        require (absoluteResult <=\\r\\n          0x8000000000000000000000000000000000000000000000000000000000000000);\\r\\n        return -int256 (absoluteResult); // We rely on overflow behavior here\\r\\n      } else {\\r\\n        require (absoluteResult <=\\r\\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n        return int256 (absoluteResult);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\r\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64 fixed point number\\r\\n   * @param y unsigned 256-bit integer number\\r\\n   * @return unsigned 256-bit integer number\\r\\n   */\\r\\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\\r\\n    if (y == 0) return 0;\\r\\n\\r\\n    require (x >= 0);\\r\\n\\r\\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\r\\n    uint256 hi = uint256 (x) * (y >> 128);\\r\\n\\r\\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n    hi <<= 64;\\r\\n\\r\\n    require (hi <=\\r\\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\\r\\n    return hi + lo;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\r\\n   * zero.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function div (int128 x, int128 y) internal pure returns (int128) {\\r\\n    require (y != 0);\\r\\n    int256 result = (int256 (x) << 64) / y;\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\r\\n   * integer numbers.  Revert on overflow or when y is zero.\\r\\n   *\\r\\n   * @param x signed 256-bit integer number\\r\\n   * @param y signed 256-bit integer number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function divi (int256 x, int256 y) internal pure returns (int128) {\\r\\n    require (y != 0);\\r\\n\\r\\n    bool negativeResult = false;\\r\\n    if (x < 0) {\\r\\n      x = -x; // We rely on overflow behavior here\\r\\n      negativeResult = true;\\r\\n    }\\r\\n    if (y < 0) {\\r\\n      y = -y; // We rely on overflow behavior here\\r\\n      negativeResult = !negativeResult;\\r\\n    }\\r\\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\\r\\n    if (negativeResult) {\\r\\n      require (absoluteResult <= 0x80000000000000000000000000000000);\\r\\n      return -int128 (absoluteResult); // We rely on overflow behavior here\\r\\n    } else {\\r\\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n      return int128 (absoluteResult); // We rely on overflow behavior here\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\r\\n   * integer numbers.  Revert on overflow or when y is zero.\\r\\n   *\\r\\n   * @param x unsigned 256-bit integer number\\r\\n   * @param y unsigned 256-bit integer number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\\r\\n    require (y != 0);\\r\\n    uint128 result = divuu (x, y);\\r\\n    require (result <= uint128 (MAX_64x64));\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate -x.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function neg (int128 x) internal pure returns (int128) {\\r\\n    require (x != MIN_64x64);\\r\\n    return -x;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate |x|.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function abs (int128 x) internal pure returns (int128) {\\r\\n    require (x != MIN_64x64);\\r\\n    return x < 0 ? -x : x;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\r\\n   * zero.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function inv (int128 x) internal pure returns (int128) {\\r\\n    require (x != 0);\\r\\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function avg (int128 x, int128 y) internal pure returns (int128) {\\r\\n    return int128 ((int256 (x) + int256 (y)) >> 1);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\r\\n   * Revert on overflow or in case x * y is negative.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\\r\\n    int256 m = int256 (x) * int256 (y);\\r\\n    require (m >= 0);\\r\\n    require (m <\\r\\n        0x4000000000000000000000000000000000000000000000000000000000000000);\\r\\n    return int128 (sqrtu (uint256 (m)));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\r\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @param y uint256 value\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\\r\\n    bool negative = x < 0 && y & 1 == 1;\\r\\n\\r\\n    uint256 absX = uint128 (x < 0 ? -x : x);\\r\\n    uint256 absResult;\\r\\n    absResult = 0x100000000000000000000000000000000;\\r\\n\\r\\n    if (absX <= 0x10000000000000000) {\\r\\n      absX <<= 63;\\r\\n      while (y != 0) {\\r\\n        if (y & 0x1 != 0) {\\r\\n          absResult = absResult * absX >> 127;\\r\\n        }\\r\\n        absX = absX * absX >> 127;\\r\\n\\r\\n        if (y & 0x2 != 0) {\\r\\n          absResult = absResult * absX >> 127;\\r\\n        }\\r\\n        absX = absX * absX >> 127;\\r\\n\\r\\n        if (y & 0x4 != 0) {\\r\\n          absResult = absResult * absX >> 127;\\r\\n        }\\r\\n        absX = absX * absX >> 127;\\r\\n\\r\\n        if (y & 0x8 != 0) {\\r\\n          absResult = absResult * absX >> 127;\\r\\n        }\\r\\n        absX = absX * absX >> 127;\\r\\n\\r\\n        y >>= 4;\\r\\n      }\\r\\n\\r\\n      absResult >>= 64;\\r\\n    } else {\\r\\n      uint256 absXShift = 63;\\r\\n      if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\\r\\n      if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\\r\\n      if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\\r\\n      if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\\r\\n      if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\\r\\n      if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\\r\\n\\r\\n      uint256 resultShift = 0;\\r\\n      while (y != 0) {\\r\\n        require (absXShift < 64);\\r\\n\\r\\n        if (y & 0x1 != 0) {\\r\\n          absResult = absResult * absX >> 127;\\r\\n          resultShift += absXShift;\\r\\n          if (absResult > 0x100000000000000000000000000000000) {\\r\\n            absResult >>= 1;\\r\\n            resultShift += 1;\\r\\n          }\\r\\n        }\\r\\n        absX = absX * absX >> 127;\\r\\n        absXShift <<= 1;\\r\\n        if (absX >= 0x100000000000000000000000000000000) {\\r\\n            absX >>= 1;\\r\\n            absXShift += 1;\\r\\n        }\\r\\n\\r\\n        y >>= 1;\\r\\n      }\\r\\n\\r\\n      require (resultShift < 64);\\r\\n      absResult >>= 64 - resultShift;\\r\\n    }\\r\\n    int256 result = negative ? -int256 (absResult) : int256 (absResult);\\r\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function sqrt (int128 x) internal pure returns (int128) {\\r\\n    require (x >= 0);\\r\\n    return int128 (sqrtu (uint256 (x) << 64));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate binary logarithm of x.  Revert if x <= 0.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function log_2 (int128 x) internal pure returns (int128) {\\r\\n    require (x > 0);\\r\\n\\r\\n    int256 msb = 0;\\r\\n    int256 xc = x;\\r\\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\r\\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\r\\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\r\\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\\r\\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\\r\\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\\r\\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\r\\n\\r\\n    int256 result = msb - 64 << 64;\\r\\n    uint256 ux = uint256 (x) << uint256 (127 - msb);\\r\\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\r\\n      ux *= ux;\\r\\n      uint256 b = ux >> 255;\\r\\n      ux >>= 127 + b;\\r\\n      result += bit * int256 (b);\\r\\n    }\\r\\n\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate natural logarithm of x.  Revert if x <= 0.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function ln (int128 x) internal pure returns (int128) {\\r\\n    require (x > 0);\\r\\n\\r\\n    return int128 (\\r\\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate binary exponent of x.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function exp_2 (int128 x) internal pure returns (int128) {\\r\\n    require (x < 0x400000000000000000); // Overflow\\r\\n\\r\\n    if (x < -0x400000000000000000) return 0; // Underflow\\r\\n\\r\\n    uint256 result = 0x80000000000000000000000000000000;\\r\\n\\r\\n    if (x & 0x8000000000000000 > 0)\\r\\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\r\\n    if (x & 0x4000000000000000 > 0)\\r\\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\r\\n    if (x & 0x2000000000000000 > 0)\\r\\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\r\\n    if (x & 0x1000000000000000 > 0)\\r\\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\r\\n    if (x & 0x800000000000000 > 0)\\r\\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\r\\n    if (x & 0x400000000000000 > 0)\\r\\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\r\\n    if (x & 0x200000000000000 > 0)\\r\\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\r\\n    if (x & 0x100000000000000 > 0)\\r\\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\r\\n    if (x & 0x80000000000000 > 0)\\r\\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\r\\n    if (x & 0x40000000000000 > 0)\\r\\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\r\\n    if (x & 0x20000000000000 > 0)\\r\\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\r\\n    if (x & 0x10000000000000 > 0)\\r\\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\r\\n    if (x & 0x8000000000000 > 0)\\r\\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\r\\n    if (x & 0x4000000000000 > 0)\\r\\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\r\\n    if (x & 0x2000000000000 > 0)\\r\\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\\r\\n    if (x & 0x1000000000000 > 0)\\r\\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\r\\n    if (x & 0x800000000000 > 0)\\r\\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\r\\n    if (x & 0x400000000000 > 0)\\r\\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\r\\n    if (x & 0x200000000000 > 0)\\r\\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\r\\n    if (x & 0x100000000000 > 0)\\r\\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\r\\n    if (x & 0x80000000000 > 0)\\r\\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\r\\n    if (x & 0x40000000000 > 0)\\r\\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\r\\n    if (x & 0x20000000000 > 0)\\r\\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\r\\n    if (x & 0x10000000000 > 0)\\r\\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\r\\n    if (x & 0x8000000000 > 0)\\r\\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\r\\n    if (x & 0x4000000000 > 0)\\r\\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\r\\n    if (x & 0x2000000000 > 0)\\r\\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\r\\n    if (x & 0x1000000000 > 0)\\r\\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\r\\n    if (x & 0x800000000 > 0)\\r\\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\r\\n    if (x & 0x400000000 > 0)\\r\\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\r\\n    if (x & 0x200000000 > 0)\\r\\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\r\\n    if (x & 0x100000000 > 0)\\r\\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\r\\n    if (x & 0x80000000 > 0)\\r\\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\r\\n    if (x & 0x40000000 > 0)\\r\\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\r\\n    if (x & 0x20000000 > 0)\\r\\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\r\\n    if (x & 0x10000000 > 0)\\r\\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\r\\n    if (x & 0x8000000 > 0)\\r\\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\r\\n    if (x & 0x4000000 > 0)\\r\\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\r\\n    if (x & 0x2000000 > 0)\\r\\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\r\\n    if (x & 0x1000000 > 0)\\r\\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\r\\n    if (x & 0x800000 > 0)\\r\\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\r\\n    if (x & 0x400000 > 0)\\r\\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\\r\\n    if (x & 0x200000 > 0)\\r\\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\\r\\n    if (x & 0x100000 > 0)\\r\\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\\r\\n    if (x & 0x80000 > 0)\\r\\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\r\\n    if (x & 0x40000 > 0)\\r\\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\r\\n    if (x & 0x20000 > 0)\\r\\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\r\\n    if (x & 0x10000 > 0)\\r\\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\r\\n    if (x & 0x8000 > 0)\\r\\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\r\\n    if (x & 0x4000 > 0)\\r\\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\r\\n    if (x & 0x2000 > 0)\\r\\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\\r\\n    if (x & 0x1000 > 0)\\r\\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\r\\n    if (x & 0x800 > 0)\\r\\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\r\\n    if (x & 0x400 > 0)\\r\\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\\r\\n    if (x & 0x200 > 0)\\r\\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\r\\n    if (x & 0x100 > 0)\\r\\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\\r\\n    if (x & 0x80 > 0)\\r\\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\r\\n    if (x & 0x40 > 0)\\r\\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\r\\n    if (x & 0x20 > 0)\\r\\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\\r\\n    if (x & 0x10 > 0)\\r\\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\r\\n    if (x & 0x8 > 0)\\r\\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\r\\n    if (x & 0x4 > 0)\\r\\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\r\\n    if (x & 0x2 > 0)\\r\\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\\r\\n    if (x & 0x1 > 0)\\r\\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\\r\\n\\r\\n    result >>= uint256 (63 - (x >> 64));\\r\\n    require (result <= uint256 (MAX_64x64));\\r\\n\\r\\n    return int128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate natural exponent of x.  Revert on overflow.\\r\\n   *\\r\\n   * @param x signed 64.64-bit fixed point number\\r\\n   * @return signed 64.64-bit fixed point number\\r\\n   */\\r\\n  function exp (int128 x) internal pure returns (int128) {\\r\\n    require (x < 0x400000000000000000); // Overflow\\r\\n\\r\\n    if (x < -0x400000000000000000) return 0; // Underflow\\r\\n\\r\\n    return exp_2 (\\r\\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\r\\n   * integer numbers.  Revert on overflow or when y is zero.\\r\\n   *\\r\\n   * @param x unsigned 256-bit integer number\\r\\n   * @param y unsigned 256-bit integer number\\r\\n   * @return unsigned 64.64-bit fixed point number\\r\\n   */\\r\\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\\r\\n    require (y != 0);\\r\\n\\r\\n    uint256 result;\\r\\n\\r\\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\r\\n      result = (x << 64) / y;\\r\\n    else {\\r\\n      uint256 msb = 192;\\r\\n      uint256 xc = x >> 192;\\r\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\r\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\r\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\r\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\r\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\r\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\r\\n\\r\\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\\r\\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n\\r\\n      uint256 hi = result * (y >> 128);\\r\\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n\\r\\n      uint256 xh = x >> 192;\\r\\n      uint256 xl = x << 64;\\r\\n\\r\\n      if (xl < lo) xh -= 1;\\r\\n      xl -= lo; // We rely on overflow behavior here\\r\\n      lo = hi << 128;\\r\\n      if (xl < lo) xh -= 1;\\r\\n      xl -= lo; // We rely on overflow behavior here\\r\\n\\r\\n      assert (xh == hi >> 128);\\r\\n\\r\\n      result += xl / y;\\r\\n    }\\r\\n\\r\\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\r\\n    return uint128 (result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\r\\n   * number.\\r\\n   *\\r\\n   * @param x unsigned 256-bit integer number\\r\\n   * @return unsigned 128-bit integer number\\r\\n   */\\r\\n  function sqrtu (uint256 x) private pure returns (uint128) {\\r\\n    if (x == 0) return 0;\\r\\n    else {\\r\\n      uint256 xx = x;\\r\\n      uint256 r = 1;\\r\\n      if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\\r\\n      if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\\r\\n      if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\\r\\n      if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\\r\\n      if (xx >= 0x100) { xx >>= 8; r <<= 4; }\\r\\n      if (xx >= 0x10) { xx >>= 4; r <<= 2; }\\r\\n      if (xx >= 0x8) { r <<= 1; }\\r\\n      r = (r + x / r) >> 1;\\r\\n      r = (r + x / r) >> 1;\\r\\n      r = (r + x / r) >> 1;\\r\\n      r = (r + x / r) >> 1;\\r\\n      r = (r + x / r) >> 1;\\r\\n      r = (r + x / r) >> 1;\\r\\n      r = (r + x / r) >> 1; // Seven iterations should be enough\\r\\n      uint256 r1 = x / r;\\r\\n      return uint128 (r < r1 ? r : r1);\\r\\n    }\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"contracts/internal/balances/TokenHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../global/LibStorage.sol\\\";\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"interfaces/compound/CErc20Interface.sol\\\";\\r\\nimport \\\"interfaces/compound/CEtherInterface.sol\\\";\\r\\nimport \\\"interfaces/IEIP20NonStandard.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\n\\r\\n/// @notice Handles all external token transfers and events\\r\\nlibrary TokenHandler {\\r\\n    using SafeInt256 for int256;\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    function setMaxCollateralBalance(uint256 currencyId, uint72 maxCollateralBalance) internal {\\r\\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\\r\\n        TokenStorage storage tokenStorage = store[currencyId][false];\\r\\n        tokenStorage.maxCollateralBalance = maxCollateralBalance;\\r\\n    } \\r\\n\\r\\n    function getAssetToken(uint256 currencyId) internal view returns (Token memory) {\\r\\n        return _getToken(currencyId, false);\\r\\n    }\\r\\n\\r\\n    function getUnderlyingToken(uint256 currencyId) internal view returns (Token memory) {\\r\\n        return _getToken(currencyId, true);\\r\\n    }\\r\\n\\r\\n    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns\\r\\n    /// the underlying token. (These may not always exist)\\r\\n    function _getToken(uint256 currencyId, bool underlying) private view returns (Token memory) {\\r\\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\\r\\n        TokenStorage storage tokenStorage = store[currencyId][underlying];\\r\\n\\r\\n        return\\r\\n            Token({\\r\\n                tokenAddress: tokenStorage.tokenAddress,\\r\\n                hasTransferFee: tokenStorage.hasTransferFee,\\r\\n                // No overflow, restricted on storage\\r\\n                decimals: int256(10**tokenStorage.decimalPlaces),\\r\\n                tokenType: tokenStorage.tokenType,\\r\\n                maxCollateralBalance: tokenStorage.maxCollateralBalance\\r\\n            });\\r\\n    }\\r\\n\\r\\n    /// @notice Sets a token for a currency id.\\r\\n    function setToken(\\r\\n        uint256 currencyId,\\r\\n        bool underlying,\\r\\n        TokenStorage memory tokenStorage\\r\\n    ) internal {\\r\\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\\r\\n\\r\\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\\r\\n            // Hardcoded parameters for ETH just to make sure we don't get it wrong.\\r\\n            TokenStorage storage ts = store[currencyId][true];\\r\\n            ts.tokenAddress = address(0);\\r\\n            ts.hasTransferFee = false;\\r\\n            ts.tokenType = TokenType.Ether;\\r\\n            ts.decimalPlaces = Constants.ETH_DECIMAL_PLACES;\\r\\n            ts.maxCollateralBalance = 0;\\r\\n\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // Check token address\\r\\n        require(tokenStorage.tokenAddress != address(0), \\\"TH: address is zero\\\");\\r\\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\\r\\n        // then we should explicitly upgrade this method to allow for a token to be changed.\\r\\n        Token memory token = _getToken(currencyId, underlying);\\r\\n        require(\\r\\n            token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0),\\r\\n            \\\"TH: token cannot be reset\\\"\\r\\n        );\\r\\n\\r\\n        require(0 < tokenStorage.decimalPlaces \\r\\n            && tokenStorage.decimalPlaces <= Constants.MAX_DECIMAL_PLACES, \\\"TH: invalid decimals\\\");\\r\\n\\r\\n        // Validate token type\\r\\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\\r\\n        if (underlying) {\\r\\n            // Underlying tokens cannot have max collateral balances, the contract only has a balance temporarily\\r\\n            // during mint and redeem actions.\\r\\n            require(tokenStorage.maxCollateralBalance == 0); // dev: underlying cannot have max collateral balance\\r\\n            require(tokenStorage.tokenType == TokenType.UnderlyingToken); // dev: underlying token inconsistent\\r\\n        } else {\\r\\n            require(tokenStorage.tokenType != TokenType.UnderlyingToken); // dev: underlying token inconsistent\\r\\n        }\\r\\n\\r\\n        if (tokenStorage.tokenType == TokenType.cToken) {\\r\\n            // Set the approval for the underlying so that we can mint cTokens\\r\\n            Token memory underlyingToken = getUnderlyingToken(currencyId);\\r\\n            // ERC20 tokens should return true on success for an approval, but Tether\\r\\n            // does not return a value here so we use the NonStandard interface here to\\r\\n            // check that the approval was successful.\\r\\n            IEIP20NonStandard(underlyingToken.tokenAddress).approve(\\r\\n                tokenStorage.tokenAddress,\\r\\n                type(uint256).max\\r\\n            );\\r\\n            checkReturnCode();\\r\\n        }\\r\\n\\r\\n        store[currencyId][underlying] = tokenStorage;\\r\\n    }\\r\\n\\r\\n    /// @notice This method only works with cTokens, it's unclear how we can make this more generic\\r\\n    function mint(Token memory token, uint256 underlyingAmountExternal) internal returns (int256) {\\r\\n        uint256 startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\\r\\n\\r\\n        uint256 success;\\r\\n        if (token.tokenType == TokenType.cToken) {\\r\\n            success = CErc20Interface(token.tokenAddress).mint(underlyingAmountExternal);\\r\\n        } else if (token.tokenType == TokenType.cETH) {\\r\\n            // Reverts on error\\r\\n            CEtherInterface(token.tokenAddress).mint{value: msg.value}();\\r\\n        } else {\\r\\n            revert(); // dev: non mintable token\\r\\n        }\\r\\n\\r\\n        require(success == Constants.COMPOUND_RETURN_CODE_NO_ERROR, \\\"Mint\\\");\\r\\n        uint256 endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\\r\\n\\r\\n        // This is the starting and ending balance in external precision\\r\\n        return SafeInt256.toInt(endingBalance.sub(startingBalance));\\r\\n    }\\r\\n\\r\\n    function redeem(\\r\\n        Token memory assetToken,\\r\\n        Token memory underlyingToken,\\r\\n        uint256 assetAmountExternal\\r\\n    ) internal returns (int256) {\\r\\n        uint256 startingBalance;\\r\\n        if (assetToken.tokenType == TokenType.cETH) {\\r\\n            startingBalance = address(this).balance;\\r\\n        } else if (assetToken.tokenType == TokenType.cToken) {\\r\\n            startingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\\r\\n        } else {\\r\\n            revert(); // dev: non redeemable failure\\r\\n        }\\r\\n\\r\\n        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);\\r\\n        require(success == Constants.COMPOUND_RETURN_CODE_NO_ERROR, \\\"Redeem\\\");\\r\\n\\r\\n        uint256 endingBalance;\\r\\n        if (assetToken.tokenType == TokenType.cETH) {\\r\\n            endingBalance = address(this).balance;\\r\\n        } else {\\r\\n            endingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\\r\\n        }\\r\\n\\r\\n        // Underlying token external precision\\r\\n        return SafeInt256.toInt(endingBalance.sub(startingBalance));\\r\\n    }\\r\\n\\r\\n    /// @notice Handles transfers into and out of the system denominated in the external token decimal\\r\\n    /// precision.\\r\\n    function transfer(\\r\\n        Token memory token,\\r\\n        address account,\\r\\n        int256 netTransferExternal\\r\\n    ) internal returns (int256) {\\r\\n        if (netTransferExternal > 0) {\\r\\n            // Deposits must account for transfer fees.\\r\\n            netTransferExternal = _deposit(token, account, uint256(netTransferExternal));\\r\\n        } else if (token.tokenType == TokenType.Ether) {\\r\\n            require(netTransferExternal <= 0); // dev: cannot deposit ether\\r\\n            address payable accountPayable = payable(account);\\r\\n            // This does not work with contracts, but is reentrancy safe. If contracts want to withdraw underlying\\r\\n            // ETH they will have to withdraw the cETH token and then redeem it manually.\\r\\n            accountPayable.transfer(uint256(netTransferExternal.neg()));\\r\\n        } else {\\r\\n            safeTransferOut(\\r\\n                token.tokenAddress,\\r\\n                account,\\r\\n                // netTransferExternal is zero or negative here\\r\\n                uint256(netTransferExternal.neg())\\r\\n            );\\r\\n        }\\r\\n\\r\\n        return netTransferExternal;\\r\\n    }\\r\\n\\r\\n    /// @notice Handles token deposits into Notional. If there is a transfer fee then we must\\r\\n    /// calculate the net balance after transfer. Amounts are denominated in the destination token's\\r\\n    /// precision.\\r\\n    function _deposit(\\r\\n        Token memory token,\\r\\n        address account,\\r\\n        uint256 amount\\r\\n    ) private returns (int256) {\\r\\n        uint256 startingBalance;\\r\\n        uint256 endingBalance;\\r\\n\\r\\n        if (token.hasTransferFee) {\\r\\n            startingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\\r\\n        }\\r\\n\\r\\n        safeTransferIn(token.tokenAddress, account, amount);\\r\\n\\r\\n        if (token.hasTransferFee || token.maxCollateralBalance > 0) {\\r\\n            endingBalance = IERC20(token.tokenAddress).balanceOf(address(this));\\r\\n        }\\r\\n\\r\\n        if (token.maxCollateralBalance > 0) {\\r\\n            int256 internalPrecisionBalance = convertToInternal(token, SafeInt256.toInt(endingBalance));\\r\\n            // Max collateral balance is stored as uint72, no overflow\\r\\n            require(internalPrecisionBalance <= SafeInt256.toInt(token.maxCollateralBalance)); // dev: over max collateral balance\\r\\n        }\\r\\n\\r\\n        // Math is done in uint inside these statements and will revert on negative\\r\\n        if (token.hasTransferFee) {\\r\\n            return SafeInt256.toInt(endingBalance.sub(startingBalance));\\r\\n        } else {\\r\\n            return SafeInt256.toInt(amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {\\r\\n        // If token decimals > INTERNAL_TOKEN_PRECISION:\\r\\n        //  on deposit: resulting dust will accumulate to protocol\\r\\n        //  on withdraw: protocol may lose dust amount. However, withdraws are only calculated based\\r\\n        //    on a conversion from internal token precision to external token precision so therefore dust\\r\\n        //    amounts cannot be specified for withdraws.\\r\\n        // If token decimals < INTERNAL_TOKEN_PRECISION then this will add zeros to the\\r\\n        // end of amount and will not result in dust.\\r\\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\\r\\n        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);\\r\\n    }\\r\\n\\r\\n    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {\\r\\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\\r\\n        // If token decimals > INTERNAL_TOKEN_PRECISION then this will increase amount\\r\\n        // by adding a number of zeros to the end and will not result in dust.\\r\\n        // If token decimals < INTERNAL_TOKEN_PRECISION:\\r\\n        //  on deposit: Deposits are specified in external token precision and there is no loss of precision when\\r\\n        //      tokens are converted from external to internal precision\\r\\n        //  on withdraw: this calculation will round down such that the protocol retains the residual cash balance\\r\\n        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);\\r\\n    }\\r\\n\\r\\n    function transferIncentive(address account, uint256 tokensToTransfer) internal {\\r\\n        safeTransferOut(Constants.NOTE_TOKEN_ADDRESS, account, tokensToTransfer);\\r\\n    }\\r\\n\\r\\n    function safeTransferOut(\\r\\n        address token,\\r\\n        address account,\\r\\n        uint256 amount\\r\\n    ) private {\\r\\n        IEIP20NonStandard(token).transfer(account, amount);\\r\\n        checkReturnCode();\\r\\n    }\\r\\n\\r\\n    function safeTransferIn(\\r\\n        address token,\\r\\n        address account,\\r\\n        uint256 amount\\r\\n    ) private {\\r\\n        IEIP20NonStandard(token).transferFrom(account, address(this), amount);\\r\\n        checkReturnCode();\\r\\n    }\\r\\n\\r\\n    function checkReturnCode() private pure {\\r\\n        bool success;\\r\\n        uint256[1] memory result;\\r\\n        assembly {\\r\\n            switch returndatasize()\\r\\n                case 0 {\\r\\n                    // This is a non-standard ERC-20\\r\\n                    success := 1 // set success to true\\r\\n                }\\r\\n                case 32 {\\r\\n                    // This is a compliant ERC-20\\r\\n                    returndatacopy(result, 0, 32)\\r\\n                    success := mload(result) // Set `success = returndata` of external call\\r\\n                }\\r\\n                default {\\r\\n                    // This is an excessively non-compliant ERC-20, revert.\\r\\n                    revert(0, 0)\\r\\n                }\\r\\n        }\\r\\n\\r\\n        require(success, \\\"ERC20\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/AccountContextHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../global/LibStorage.sol\\\";\\r\\nimport \\\"./balances/BalanceHandler.sol\\\";\\r\\nimport \\\"./portfolio/BitmapAssetsHandler.sol\\\";\\r\\nimport \\\"./portfolio/PortfolioHandler.sol\\\";\\r\\n\\r\\nlibrary AccountContextHandler {\\r\\n    using PortfolioHandler for PortfolioState;\\r\\n\\r\\n    bytes18 private constant TURN_OFF_PORTFOLIO_FLAGS = 0x7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF;\\r\\n    event AccountContextUpdate(address indexed account);\\r\\n\\r\\n    /// @notice Returns the account context of a given account\\r\\n    function getAccountContext(address account) internal view returns (AccountContext memory) {\\r\\n        mapping(address => AccountContext) storage store = LibStorage.getAccountStorage();\\r\\n        return store[account];\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the account context of a given account\\r\\n    function setAccountContext(AccountContext memory accountContext, address account) internal {\\r\\n        mapping(address => AccountContext) storage store = LibStorage.getAccountStorage();\\r\\n        store[account] = accountContext;\\r\\n        emit AccountContextUpdate(account);\\r\\n    }\\r\\n\\r\\n    function isBitmapEnabled(AccountContext memory accountContext) internal pure returns (bool) {\\r\\n        return accountContext.bitmapCurrencyId != 0;\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the account context of a given account\\r\\n    function enableBitmapForAccount(\\r\\n        AccountContext memory accountContext,\\r\\n        address account,\\r\\n        uint16 currencyId,\\r\\n        uint256 blockTime\\r\\n    ) internal view {\\r\\n        // Allow setting the currency id to zero to turn off bitmap\\r\\n        require(currencyId <= Constants.MAX_CURRENCIES, \\\"AC: invalid currency id\\\");\\r\\n\\r\\n        if (isBitmapEnabled(accountContext)) {\\r\\n            // Account cannot change their bitmap if they have assets set\\r\\n            bytes32 ifCashBitmap =\\r\\n                BitmapAssetsHandler.getAssetsBitmap(account, accountContext.bitmapCurrencyId);\\r\\n            require(ifCashBitmap == 0, \\\"AC: cannot have assets\\\");\\r\\n        } else {\\r\\n            require(accountContext.assetArrayLength == 0, \\\"AC: cannot have assets\\\");\\r\\n            // Account context also cannot have negative cash debts\\r\\n            require(accountContext.hasDebt == 0x00, \\\"AC: cannot have debt\\\");\\r\\n\\r\\n            // Ensure that the active currency is set to false in the array so that there is no double\\r\\n            // counting during FreeCollateral\\r\\n            setActiveCurrency(accountContext, currencyId, false, Constants.ACTIVE_IN_BALANCES);\\r\\n        }\\r\\n\\r\\n        accountContext.bitmapCurrencyId = currencyId;\\r\\n\\r\\n        // Setting this is required to initialize the assets bitmap\\r\\n        uint256 nextSettleTime = DateTime.getTimeUTC0(blockTime);\\r\\n        require(nextSettleTime < type(uint40).max); // dev: blockTime overflow\\r\\n        accountContext.nextSettleTime = uint40(nextSettleTime);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns true if the context needs to settle\\r\\n    function mustSettleAssets(AccountContext memory accountContext) internal view returns (bool) {\\r\\n        uint256 blockTime = block.timestamp;\\r\\n\\r\\n        if (isBitmapEnabled(accountContext)) {\\r\\n            // nextSettleTime will be set to utc0 after settlement so we\\r\\n            // settle if this is strictly less than utc0\\r\\n            return accountContext.nextSettleTime < DateTime.getTimeUTC0(blockTime);\\r\\n        } else {\\r\\n            // 0 value occurs on an uninitialized account\\r\\n            // Assets mature exactly on the blockTime (not one second past) so in this\\r\\n            // case we settle on the block timestamp\\r\\n            return 0 < accountContext.nextSettleTime && accountContext.nextSettleTime <= blockTime;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Checks if a currency id (uint16 max) is in the 9 slots in the account\\r\\n    /// context active currencies list.\\r\\n    /// @dev NOTE: this may be more efficient as a binary search since we know that the array\\r\\n    /// is sorted\\r\\n    function isActiveInBalances(AccountContext memory accountContext, uint256 currencyId)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool)\\r\\n    {\\r\\n        require(currencyId != 0 && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id\\r\\n        bytes18 currencies = accountContext.activeCurrencies;\\r\\n\\r\\n        if (accountContext.bitmapCurrencyId == currencyId) return true;\\r\\n\\r\\n        while (currencies != 0x00) {\\r\\n            uint256 cid = uint16(bytes2(currencies) & Constants.UNMASK_FLAGS);\\r\\n            if (cid == currencyId) {\\r\\n                // Currency found, return if it is active in balances or not\\r\\n                return bytes2(currencies) & Constants.ACTIVE_IN_BALANCES == Constants.ACTIVE_IN_BALANCES;\\r\\n            }\\r\\n\\r\\n            currencies = currencies << 16;\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /// @notice Iterates through the active currency list and removes, inserts or does nothing\\r\\n    /// to ensure that the active currency list is an ordered byte array of uint16 currency ids\\r\\n    /// that refer to the currencies that an account is active in.\\r\\n    ///\\r\\n    /// This is called to ensure that currencies are active when the account has a non zero cash balance,\\r\\n    /// a non zero nToken balance or a portfolio asset.\\r\\n    function setActiveCurrency(\\r\\n        AccountContext memory accountContext,\\r\\n        uint256 currencyId,\\r\\n        bool isActive,\\r\\n        bytes2 flags\\r\\n    ) internal pure {\\r\\n        require(0 < currencyId && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id\\r\\n\\r\\n        // If the bitmapped currency is already set then return here. Turning off the bitmap currency\\r\\n        // id requires other logical handling so we will do it elsewhere.\\r\\n        if (isActive && accountContext.bitmapCurrencyId == currencyId) return;\\r\\n\\r\\n        bytes18 prefix;\\r\\n        bytes18 suffix = accountContext.activeCurrencies;\\r\\n        uint256 shifts;\\r\\n\\r\\n        /// There are six possible outcomes from this search:\\r\\n        /// 1. The currency id is in the list\\r\\n        ///      - it must be set to active, do nothing\\r\\n        ///      - it must be set to inactive, shift suffix and concatenate\\r\\n        /// 2. The current id is greater than the one in the search:\\r\\n        ///      - it must be set to active, append to prefix and then concatenate the suffix,\\r\\n        ///        ensure that we do not lose the last 2 bytes if set.\\r\\n        ///      - it must be set to inactive, it is not in the list, do nothing\\r\\n        /// 3. Reached the end of the list:\\r\\n        ///      - it must be set to active, check that the last two bytes are not set and then\\r\\n        ///        append to the prefix\\r\\n        ///      - it must be set to inactive, do nothing\\r\\n        while (suffix != 0x00) {\\r\\n            uint256 cid = uint256(uint16(bytes2(suffix) & Constants.UNMASK_FLAGS));\\r\\n            // if matches and isActive then return, already in list\\r\\n            if (cid == currencyId && isActive) {\\r\\n                // set flag and return\\r\\n                accountContext.activeCurrencies =\\r\\n                    accountContext.activeCurrencies |\\r\\n                    (bytes18(flags) >> (shifts * 16));\\r\\n                return;\\r\\n            }\\r\\n\\r\\n            // if matches and not active then shift suffix to remove\\r\\n            if (cid == currencyId && !isActive) {\\r\\n                // turn off flag, if both flags are off then remove\\r\\n                suffix = suffix & ~bytes18(flags);\\r\\n                if (bytes2(suffix) & ~Constants.UNMASK_FLAGS == 0x0000) suffix = suffix << 16;\\r\\n                accountContext.activeCurrencies = prefix | (suffix >> (shifts * 16));\\r\\n                return;\\r\\n            }\\r\\n\\r\\n            // if greater than and isActive then insert into prefix\\r\\n            if (cid > currencyId && isActive) {\\r\\n                prefix = prefix | (bytes18(bytes2(uint16(currencyId)) | flags) >> (shifts * 16));\\r\\n                // check that the total length is not greater than 9, meaning that the last\\r\\n                // two bytes of the active currencies array should be zero\\r\\n                require((accountContext.activeCurrencies << 128) == 0x00); // dev: AC: too many currencies\\r\\n\\r\\n                // append the suffix\\r\\n                accountContext.activeCurrencies = prefix | (suffix >> ((shifts + 1) * 16));\\r\\n                return;\\r\\n            }\\r\\n\\r\\n            // if past the point of the currency id and not active, not in list\\r\\n            if (cid > currencyId && !isActive) return;\\r\\n\\r\\n            prefix = prefix | (bytes18(bytes2(suffix)) >> (shifts * 16));\\r\\n            suffix = suffix << 16;\\r\\n            shifts += 1;\\r\\n        }\\r\\n\\r\\n        // If reached this point and not active then return\\r\\n        if (!isActive) return;\\r\\n\\r\\n        // if end and isActive then insert into suffix, check max length\\r\\n        require(shifts < 9); // dev: AC: too many currencies\\r\\n        accountContext.activeCurrencies =\\r\\n            prefix |\\r\\n            (bytes18(bytes2(uint16(currencyId)) | flags) >> (shifts * 16));\\r\\n    }\\r\\n\\r\\n    function _clearPortfolioActiveFlags(bytes18 activeCurrencies) internal pure returns (bytes18) {\\r\\n        bytes18 result;\\r\\n        // This is required to clear the suffix as we append below\\r\\n        bytes18 suffix = activeCurrencies & TURN_OFF_PORTFOLIO_FLAGS;\\r\\n        uint256 shifts;\\r\\n\\r\\n        // This loop will append all currencies that are active in balances into the result.\\r\\n        while (suffix != 0x00) {\\r\\n            if (bytes2(suffix) & Constants.ACTIVE_IN_BALANCES == Constants.ACTIVE_IN_BALANCES) {\\r\\n                // If any flags are active, then append.\\r\\n                result = result | (bytes18(bytes2(suffix)) >> shifts);\\r\\n                shifts += 16;\\r\\n            }\\r\\n            suffix = suffix << 16;\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /// @notice Stores a portfolio array and updates the account context information, this method should\\r\\n    /// be used whenever updating a portfolio array except in the case of nTokens\\r\\n    function storeAssetsAndUpdateContext(\\r\\n        AccountContext memory accountContext,\\r\\n        address account,\\r\\n        PortfolioState memory portfolioState,\\r\\n        bool isLiquidation\\r\\n    ) internal {\\r\\n        // Each of these parameters is recalculated based on the entire array of assets in store assets,\\r\\n        // regardless of whether or not they have been updated.\\r\\n        (bool hasDebt, bytes32 portfolioCurrencies, uint8 assetArrayLength, uint40 nextSettleTime) =\\r\\n            portfolioState.storeAssets(account);\\r\\n        accountContext.nextSettleTime = nextSettleTime;\\r\\n        require(mustSettleAssets(accountContext) == false); // dev: cannot store matured assets\\r\\n        accountContext.assetArrayLength = assetArrayLength;\\r\\n\\r\\n        // During liquidation it is possible for an array to go over the max amount of assets allowed due to\\r\\n        // liquidity tokens being withdrawn into fCash.\\r\\n        if (!isLiquidation) {\\r\\n            require(assetArrayLength <= uint8(Constants.MAX_TRADED_MARKET_INDEX)); // dev: max assets allowed\\r\\n        }\\r\\n\\r\\n        // Sets the hasDebt flag properly based on whether or not portfolio has asset debt, meaning\\r\\n        // a negative fCash balance.\\r\\n        if (hasDebt) {\\r\\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;\\r\\n        } else {\\r\\n            // Turns off the ASSET_DEBT flag\\r\\n            accountContext.hasDebt = accountContext.hasDebt & ~Constants.HAS_ASSET_DEBT;\\r\\n        }\\r\\n\\r\\n        // Clear the active portfolio active flags and they will be recalculated in the next step\\r\\n        accountContext.activeCurrencies = _clearPortfolioActiveFlags(accountContext.activeCurrencies);\\r\\n\\r\\n        uint256 lastCurrency;\\r\\n        while (portfolioCurrencies != 0) {\\r\\n            // Portfolio currencies will not have flags, it is just an byte array of all the currencies found\\r\\n            // in a portfolio. They are appended in a sorted order so we can compare to the previous currency\\r\\n            // and only set it if they are different.\\r\\n            uint256 currencyId = uint16(bytes2(portfolioCurrencies));\\r\\n            if (currencyId != lastCurrency) {\\r\\n                setActiveCurrency(accountContext, currencyId, true, Constants.ACTIVE_IN_PORTFOLIO);\\r\\n            }\\r\\n            lastCurrency = currencyId;\\r\\n\\r\\n            portfolioCurrencies = portfolioCurrencies << 16;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/math/FloatingPoint56.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./Bitmap.sol\\\";\\r\\n\\r\\n/**\\r\\n * Packs an uint value into a \\\"floating point\\\" storage slot. Used for storing\\r\\n * lastClaimIntegralSupply values in balance storage. For these values, we don't need\\r\\n * to maintain exact precision but we don't want to be limited by storage size overflows.\\r\\n *\\r\\n * A floating point value is defined by the 48 most significant bits and an 8 bit number\\r\\n * of bit shifts required to restore its precision. The unpacked value will always be less\\r\\n * than the packed value with a maximum absolute loss of precision of (2 ** bitShift) - 1.\\r\\n */\\r\\nlibrary FloatingPoint56 {\\r\\n\\r\\n    function packTo56Bits(uint256 value) internal pure returns (uint56) {\\r\\n        uint256 bitShift;\\r\\n        // If the value is over the uint48 max value then we will shift it down\\r\\n        // given the index of the most significant bit. We store this bit shift \\r\\n        // in the least significant byte of the 56 bit slot available.\\r\\n        if (value > type(uint48).max) bitShift = (Bitmap.getMSB(value) - 47);\\r\\n\\r\\n        uint256 shiftedValue = value >> bitShift;\\r\\n        return uint56((shiftedValue << 8) | bitShift);\\r\\n    }\\r\\n\\r\\n    function unpackFrom56Bits(uint256 value) internal pure returns (uint256) {\\r\\n        // The least significant 8 bits will be the amount to bit shift\\r\\n        uint256 bitShift = uint256(uint8(value));\\r\\n        return ((value >> 8) << bitShift);\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"interfaces/compound/CErc20Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport \\\"./CTokenInterface.sol\\\";\\r\\n\\r\\ninterface CErc20Interface {\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function mint(uint mintAmount) external returns (uint);\\r\\n    function redeem(uint redeemTokens) external returns (uint);\\r\\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\\r\\n    function borrow(uint borrowAmount) external returns (uint);\\r\\n    function repayBorrow(uint repayAmount) external returns (uint);\\r\\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\\r\\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"interfaces/compound/CEtherInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface CEtherInterface {\\r\\n    function mint() external payable;\\r\\n}\"\r\n    },\r\n    \"interfaces/IEIP20NonStandard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @title EIP20NonStandardInterface\\r\\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\r\\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\r\\n */\\r\\ninterface IEIP20NonStandard {\\r\\n\\r\\n    /**\\r\\n     * @notice Get the total number of tokens in circulation\\r\\n     * @return The supply of tokens\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the balance of the specified address\\r\\n     * @param owner The address from which the balance will be retrieved\\r\\n     * @return balance\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    ///\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    ///\\r\\n\\r\\n    /**\\r\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\r\\n      * @param dst The address of the destination account\\r\\n      * @param amount The number of tokens to transfer\\r\\n      */\\r\\n    function transfer(address dst, uint256 amount) external;\\r\\n\\r\\n    ///\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    ///\\r\\n\\r\\n    /**\\r\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\r\\n      * @param src The address of the source account\\r\\n      * @param dst The address of the destination account\\r\\n      * @param amount The number of tokens to transfer\\r\\n      */\\r\\n    function transferFrom(address src, address dst, uint256 amount) external;\\r\\n\\r\\n    ///\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    /// !!! NOTICE !!! `approve` does not return a value, in violation of the ERC-20 specification\\r\\n    /// !!!!!!!!!!!!!!\\r\\n    ///\\r\\n\\r\\n    /**\\r\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\r\\n      * @dev This will overwrite the approval amount for `spender`\\r\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\r\\n      * @param spender The address of the account which may transfer tokens\\r\\n      * @param amount The number of tokens that are approved\\r\\n      */\\r\\n    function approve(address spender, uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n      * @notice Get the current allowance from `owner` for `spender`\\r\\n      * @param owner The address of the account which owns the tokens to be spent\\r\\n      * @param spender The address of the account which may transfer tokens\\r\\n      * @return remaining The number of tokens allowed to be spent\\r\\n      */\\r\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"interfaces/compound/CTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface CTokenInterface {\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function underlying() external view returns (address);\\r\\n    function transfer(address dst, uint amount) external returns (bool);\\r\\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\\r\\n    function approve(address spender, uint amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function balanceOfUnderlying(address owner) external returns (uint);\\r\\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\\r\\n    function borrowRatePerBlock() external view returns (uint);\\r\\n    function supplyRatePerBlock() external view returns (uint);\\r\\n    function totalBorrowsCurrent() external returns (uint);\\r\\n    function borrowBalanceCurrent(address account) external returns (uint);\\r\\n    function borrowBalanceStored(address account) external view returns (uint);\\r\\n    function exchangeRateCurrent() external returns (uint);\\r\\n    function exchangeRateStored() external view returns (uint);\\r\\n    function getCash() external view returns (uint);\\r\\n    function accrueInterest() external returns (uint);\\r\\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/internal/portfolio/TransferAssets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./PortfolioHandler.sol\\\";\\r\\nimport \\\"./BitmapAssetsHandler.sol\\\";\\r\\nimport \\\"../AccountContextHandler.sol\\\";\\r\\nimport \\\"../../external/SettleAssetsExternal.sol\\\";\\r\\n\\r\\n/// @notice Helper library for transferring assets from one portfolio to another\\r\\nlibrary TransferAssets {\\r\\n    using AccountContextHandler for AccountContext;\\r\\n    using PortfolioHandler for PortfolioState;\\r\\n    using SafeInt256 for int256;\\r\\n\\r\\n    /// @notice Decodes asset ids\\r\\n    function decodeAssetId(uint256 id)\\r\\n        internal\\r\\n        pure\\r\\n        returns (\\r\\n            uint256 currencyId,\\r\\n            uint256 maturity,\\r\\n            uint256 assetType\\r\\n        )\\r\\n    {\\r\\n        assetType = uint8(id);\\r\\n        maturity = uint40(id >> 8);\\r\\n        currencyId = uint16(id >> 48);\\r\\n    }\\r\\n\\r\\n    /// @notice Encodes asset ids\\r\\n    function encodeAssetId(\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 assetType\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(currencyId <= Constants.MAX_CURRENCIES);\\r\\n        require(maturity <= type(uint40).max);\\r\\n        require(assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX);\\r\\n\\r\\n        return\\r\\n            uint256(\\r\\n                (bytes32(uint256(uint16(currencyId))) << 48) |\\r\\n                    (bytes32(uint256(uint40(maturity))) << 8) |\\r\\n                    bytes32(uint256(uint8(assetType)))\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /// @dev Used to flip the sign of assets to decrement the `from` account that is sending assets\\r\\n    function invertNotionalAmountsInPlace(PortfolioAsset[] memory assets) internal pure {\\r\\n        for (uint256 i; i < assets.length; i++) {\\r\\n            assets[i].notional = assets[i].notional.neg();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Useful method for hiding the logic of updating an account. WARNING: the account\\r\\n    /// context returned from this method may not be the same memory location as the account\\r\\n    /// context provided if the account is settled.\\r\\n    function placeAssetsInAccount(\\r\\n        address account,\\r\\n        AccountContext memory accountContext,\\r\\n        PortfolioAsset[] memory assets\\r\\n    ) internal returns (AccountContext memory) {\\r\\n        // If an account has assets that require settlement then placing assets inside it\\r\\n        // may cause issues.\\r\\n        require(!accountContext.mustSettleAssets(), \\\"Account must settle\\\");\\r\\n\\r\\n        if (accountContext.isBitmapEnabled()) {\\r\\n            // Adds fCash assets into the account and finalized storage\\r\\n            BitmapAssetsHandler.addMultipleifCashAssets(account, accountContext, assets);\\r\\n        } else {\\r\\n            PortfolioState memory portfolioState = PortfolioHandler.buildPortfolioState(\\r\\n                account,\\r\\n                accountContext.assetArrayLength,\\r\\n                assets.length\\r\\n            );\\r\\n            // This will add assets in memory\\r\\n            portfolioState.addMultipleAssets(assets);\\r\\n            // This will store assets and update the account context in memory\\r\\n            accountContext.storeAssetsAndUpdateContext(account, portfolioState, false);\\r\\n        }\\r\\n\\r\\n        return accountContext;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/external/SettleAssetsExternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../internal/portfolio/PortfolioHandler.sol\\\";\\r\\nimport \\\"../internal/balances/BalanceHandler.sol\\\";\\r\\nimport \\\"../internal/settlement/SettlePortfolioAssets.sol\\\";\\r\\nimport \\\"../internal/settlement/SettleBitmapAssets.sol\\\";\\r\\nimport \\\"../internal/AccountContextHandler.sol\\\";\\r\\n\\r\\n/// @notice External library for settling assets\\r\\nlibrary SettleAssetsExternal {\\r\\n    using PortfolioHandler for PortfolioState;\\r\\n    using AccountContextHandler for AccountContext;\\r\\n    event AccountSettled(address indexed account);\\r\\n\\r\\n    /// @notice Settles an account, returns the new account context object after settlement.\\r\\n    /// @dev The memory location of the account context object is not the same as the one returned.\\r\\n    function settleAccount(\\r\\n        address account,\\r\\n        AccountContext memory accountContext\\r\\n    ) external returns (AccountContext memory) {\\r\\n        // Defensive check to ensure that this is a valid settlement\\r\\n        require(accountContext.mustSettleAssets());\\r\\n        SettleAmount[] memory settleAmounts;\\r\\n        PortfolioState memory portfolioState;\\r\\n\\r\\n        if (accountContext.isBitmapEnabled()) {\\r\\n            (int256 settledCash, uint256 blockTimeUTC0) =\\r\\n                SettleBitmapAssets.settleBitmappedCashGroup(\\r\\n                    account,\\r\\n                    accountContext.bitmapCurrencyId,\\r\\n                    accountContext.nextSettleTime,\\r\\n                    block.timestamp\\r\\n                );\\r\\n            require(blockTimeUTC0 < type(uint40).max); // dev: block time utc0 overflow\\r\\n            accountContext.nextSettleTime = uint40(blockTimeUTC0);\\r\\n\\r\\n            settleAmounts = new SettleAmount[](1);\\r\\n            settleAmounts[0] = SettleAmount(accountContext.bitmapCurrencyId, settledCash);\\r\\n        } else {\\r\\n            portfolioState = PortfolioHandler.buildPortfolioState(\\r\\n                account,\\r\\n                accountContext.assetArrayLength,\\r\\n                0\\r\\n            );\\r\\n            settleAmounts = SettlePortfolioAssets.settlePortfolio(portfolioState, block.timestamp);\\r\\n            accountContext.storeAssetsAndUpdateContext(account, portfolioState, false);\\r\\n        }\\r\\n\\r\\n        BalanceHandler.finalizeSettleAmounts(account, accountContext, settleAmounts);\\r\\n\\r\\n        emit AccountSettled(account);\\r\\n\\r\\n        return accountContext;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/math/Bitmap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../global/Types.sol\\\";\\r\\nimport \\\"../global/Constants.sol\\\";\\r\\n\\r\\n/// @notice Helper methods for bitmaps, they are big-endian and 1-indexed.\\r\\nlibrary Bitmap {\\r\\n\\r\\n    /// @notice Set a bit on or off in a bitmap, index is 1-indexed\\r\\n    function setBit(\\r\\n        bytes32 bitmap,\\r\\n        uint256 index,\\r\\n        bool setOn\\r\\n    ) internal pure returns (bytes32) {\\r\\n        require(index >= 1 && index <= 256); // dev: set bit index bounds\\r\\n\\r\\n        if (setOn) {\\r\\n            return bitmap | (Constants.MSB >> (index - 1));\\r\\n        } else {\\r\\n            return bitmap & ~(Constants.MSB >> (index - 1));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Check if a bit is set\\r\\n    function isBitSet(bytes32 bitmap, uint256 index) internal pure returns (bool) {\\r\\n        require(index >= 1 && index <= 256); // dev: set bit index bounds\\r\\n        return ((bitmap << (index - 1)) & Constants.MSB) == Constants.MSB;\\r\\n    }\\r\\n\\r\\n    /// @notice Count the total bits set\\r\\n    function totalBitsSet(bytes32 bitmap) internal pure returns (uint256) {\\r\\n        uint256 x = uint256(bitmap);\\r\\n        x = (x & 0x5555555555555555555555555555555555555555555555555555555555555555) + (x >> 1 & 0x5555555555555555555555555555555555555555555555555555555555555555);\\r\\n        x = (x & 0x3333333333333333333333333333333333333333333333333333333333333333) + (x >> 2 & 0x3333333333333333333333333333333333333333333333333333333333333333);\\r\\n        x = (x & 0x0707070707070707070707070707070707070707070707070707070707070707) + (x >> 4);\\r\\n        x = (x & 0x000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F) + (x >> 8 & 0x000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F);\\r\\n        x = x + (x >> 16);\\r\\n        x = x + (x >> 32);\\r\\n        x = x  + (x >> 64);\\r\\n        return (x & 0xFF) + (x >> 128 & 0xFF);\\r\\n    }\\r\\n\\r\\n    // Does a binary search over x to get the position of the most significant bit\\r\\n    function getMSB(uint256 x) internal pure returns (uint256 msb) {\\r\\n        // If x == 0 then there is no MSB and this method will return zero. That would\\r\\n        // be the same as the return value when x == 1 (MSB is zero indexed), so instead\\r\\n        // we have this require here to ensure that the values don't get mixed up.\\r\\n        require(x != 0); // dev: get msb zero value\\r\\n        if (x >= 0x100000000000000000000000000000000) {\\r\\n            x >>= 128;\\r\\n            msb += 128;\\r\\n        }\\r\\n        if (x >= 0x10000000000000000) {\\r\\n            x >>= 64;\\r\\n            msb += 64;\\r\\n        }\\r\\n        if (x >= 0x100000000) {\\r\\n            x >>= 32;\\r\\n            msb += 32;\\r\\n        }\\r\\n        if (x >= 0x10000) {\\r\\n            x >>= 16;\\r\\n            msb += 16;\\r\\n        }\\r\\n        if (x >= 0x100) {\\r\\n            x >>= 8;\\r\\n            msb += 8;\\r\\n        }\\r\\n        if (x >= 0x10) {\\r\\n            x >>= 4;\\r\\n            msb += 4;\\r\\n        }\\r\\n        if (x >= 0x4) {\\r\\n            x >>= 2;\\r\\n            msb += 2;\\r\\n        }\\r\\n        if (x >= 0x2) msb += 1; // No need to shift xc anymore\\r\\n    }\\r\\n\\r\\n    /// @dev getMSB returns a zero indexed bit number where zero is the first bit counting\\r\\n    /// from the right (little endian). Asset Bitmaps are counted from the left (big endian)\\r\\n    /// and one indexed.\\r\\n    function getNextBitNum(bytes32 bitmap) internal pure returns (uint256 bitNum) {\\r\\n        // Short circuit the search if bitmap is all zeros\\r\\n        if (bitmap == 0x00) return 0;\\r\\n\\r\\n        return 255 - getMSB(uint256(bitmap)) + 1;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/settlement/SettlePortfolioAssets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../valuation/AssetHandler.sol\\\";\\r\\nimport \\\"../markets/Market.sol\\\";\\r\\nimport \\\"../markets/AssetRate.sol\\\";\\r\\nimport \\\"../portfolio/PortfolioHandler.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\n\\r\\nlibrary SettlePortfolioAssets {\\r\\n    using SafeInt256 for int256;\\r\\n    using AssetRate for AssetRateParameters;\\r\\n    using Market for MarketParameters;\\r\\n    using PortfolioHandler for PortfolioState;\\r\\n    using AssetHandler for PortfolioAsset;\\r\\n\\r\\n    /// @dev Returns a SettleAmount array for the assets that will be settled\\r\\n    function _getSettleAmountArray(PortfolioState memory portfolioState, uint256 blockTime)\\r\\n        private\\r\\n        pure\\r\\n        returns (SettleAmount[] memory)\\r\\n    {\\r\\n        uint256 currenciesSettled;\\r\\n        uint256 lastCurrencyId = 0;\\r\\n        if (portfolioState.storedAssets.length == 0) return new SettleAmount[](0);\\r\\n\\r\\n        // Loop backwards so \\\"lastCurrencyId\\\" will be set to the first currency in the portfolio\\r\\n        // NOTE: if this contract is ever upgraded to Solidity 0.8+ then this i-- will underflow and cause\\r\\n        // a revert, must wrap in an unchecked.\\r\\n        for (uint256 i = portfolioState.storedAssets.length; (i--) > 0;) {\\r\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\r\\n            // Assets settle on exactly blockTime\\r\\n            if (asset.getSettlementDate() > blockTime) continue;\\r\\n\\r\\n            // Assume that this is sorted by cash group and maturity, currencyId = 0 is unused so this\\r\\n            // will work for the first asset\\r\\n            if (lastCurrencyId != asset.currencyId) {\\r\\n                lastCurrencyId = asset.currencyId;\\r\\n                currenciesSettled++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Actual currency ids will be set as we loop through the portfolio and settle assets\\r\\n        SettleAmount[] memory settleAmounts = new SettleAmount[](currenciesSettled);\\r\\n        if (currenciesSettled > 0) settleAmounts[0].currencyId = lastCurrencyId;\\r\\n        return settleAmounts;\\r\\n    }\\r\\n\\r\\n    /// @notice Settles a portfolio array\\r\\n    function settlePortfolio(PortfolioState memory portfolioState, uint256 blockTime)\\r\\n        internal\\r\\n        returns (SettleAmount[] memory)\\r\\n    {\\r\\n        AssetRateParameters memory settlementRate;\\r\\n        SettleAmount[] memory settleAmounts = _getSettleAmountArray(portfolioState, blockTime);\\r\\n        MarketParameters memory market;\\r\\n        if (settleAmounts.length == 0) return settleAmounts;\\r\\n        uint256 settleAmountIndex;\\r\\n\\r\\n        for (uint256 i; i < portfolioState.storedAssets.length; i++) {\\r\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\r\\n            uint256 settleDate = asset.getSettlementDate();\\r\\n            // Settlement date is on block time exactly\\r\\n            if (settleDate > blockTime) continue;\\r\\n\\r\\n            // On the first loop the lastCurrencyId is already set.\\r\\n            if (settleAmounts[settleAmountIndex].currencyId != asset.currencyId) {\\r\\n                // New currency in the portfolio\\r\\n                settleAmountIndex += 1;\\r\\n                settleAmounts[settleAmountIndex].currencyId = asset.currencyId;\\r\\n            }\\r\\n\\r\\n            settlementRate = AssetRate.buildSettlementRateStateful(\\r\\n                asset.currencyId,\\r\\n                asset.maturity,\\r\\n                blockTime\\r\\n            );\\r\\n\\r\\n            int256 assetCash;\\r\\n            if (asset.assetType == Constants.FCASH_ASSET_TYPE) {\\r\\n                assetCash = settlementRate.convertFromUnderlying(asset.notional);\\r\\n                portfolioState.deleteAsset(i);\\r\\n            } else if (AssetHandler.isLiquidityToken(asset.assetType)) {\\r\\n                Market.loadSettlementMarket(market, asset.currencyId, asset.maturity, settleDate);\\r\\n                int256 fCash;\\r\\n                (assetCash, fCash) = market.removeLiquidity(asset.notional);\\r\\n\\r\\n                // Assets mature exactly on block time\\r\\n                if (asset.maturity > blockTime) {\\r\\n                    // If fCash has not yet matured then add it to the portfolio\\r\\n                    _settleLiquidityTokenTofCash(portfolioState, i, fCash);\\r\\n                } else {\\r\\n                    // If asset has matured then settle fCash to asset cash\\r\\n                    assetCash = assetCash.add(settlementRate.convertFromUnderlying(fCash));\\r\\n                    portfolioState.deleteAsset(i);\\r\\n                }\\r\\n            }\\r\\n            settleAmounts[settleAmountIndex].netCashChange = settleAmounts[settleAmountIndex]\\r\\n                .netCashChange\\r\\n                .add(assetCash);\\r\\n        }\\r\\n\\r\\n        return settleAmounts;\\r\\n    }\\r\\n\\r\\n    /// @notice Settles a liquidity token to idiosyncratic fCash, this occurs when the maturity is still in the future\\r\\n    function _settleLiquidityTokenTofCash(\\r\\n        PortfolioState memory portfolioState,\\r\\n        uint256 index,\\r\\n        int256 fCash\\r\\n    ) private pure {\\r\\n        PortfolioAsset memory liquidityToken = portfolioState.storedAssets[index];\\r\\n        // If the liquidity token's maturity is still in the future then we change the entry to be\\r\\n        // an idiosyncratic fCash entry with the net fCash amount.\\r\\n        if (index != 0) {\\r\\n            // Check to see if the previous index is the matching fCash asset, this will be the case when the\\r\\n            // portfolio is sorted\\r\\n            PortfolioAsset memory fCashAsset = portfolioState.storedAssets[index - 1];\\r\\n\\r\\n            if (\\r\\n                fCashAsset.currencyId == liquidityToken.currencyId &&\\r\\n                fCashAsset.maturity == liquidityToken.maturity &&\\r\\n                fCashAsset.assetType == Constants.FCASH_ASSET_TYPE\\r\\n            ) {\\r\\n                // This fCash asset has not matured if we are settling to fCash\\r\\n                fCashAsset.notional = fCashAsset.notional.add(fCash);\\r\\n                fCashAsset.storageState = AssetStorageState.Update;\\r\\n                portfolioState.deleteAsset(index);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // We are going to delete this asset anyway, convert to an fCash position\\r\\n        liquidityToken.assetType = Constants.FCASH_ASSET_TYPE;\\r\\n        liquidityToken.notional = fCash;\\r\\n        liquidityToken.storageState = AssetStorageState.Update;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/settlement/SettleBitmapAssets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../markets/AssetRate.sol\\\";\\r\\nimport \\\"../../global/LibStorage.sol\\\";\\r\\nimport \\\"../portfolio/BitmapAssetsHandler.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"../../math/Bitmap.sol\\\";\\r\\nimport \\\"../../global/Constants.sol\\\";\\r\\nimport \\\"../../global/Types.sol\\\";\\r\\n\\r\\n/**\\r\\n * Settles a bitmap portfolio by checking for all matured fCash assets and turning them into cash\\r\\n * at the prevailing settlement rate. It will also update the asset bitmap to ensure that it continues\\r\\n * to correctly reference all actual maturities. fCash asset notional values are stored in *absolute* \\r\\n * time terms and bitmap bits are *relative* time terms based on the bitNumber and the stored oldSettleTime.\\r\\n * Remapping bits requires converting the old relative bit numbers to new relative bit numbers based on\\r\\n * newSettleTime and the absolute times (maturities) that the previous bitmap references.\\r\\n */\\r\\nlibrary SettleBitmapAssets {\\r\\n    using SafeInt256 for int256;\\r\\n    using AssetRate for AssetRateParameters;\\r\\n    using Bitmap for bytes32;\\r\\n\\r\\n    /// @notice Given a bitmap for a cash group and timestamps, will settle all assets\\r\\n    /// that have matured and remap the bitmap to correspond to the current time.\\r\\n    function settleBitmappedCashGroup(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        uint256 oldSettleTime,\\r\\n        uint256 blockTime\\r\\n    ) internal returns (int256 totalAssetCash, uint256 newSettleTime) {\\r\\n        bytes32 bitmap = BitmapAssetsHandler.getAssetsBitmap(account, currencyId);\\r\\n\\r\\n        // This newSettleTime will be set to the new `oldSettleTime`. The bits between 1 and\\r\\n        // `lastSettleBit` (inclusive) will be shifted out of the bitmap and settled. The reason\\r\\n        // that lastSettleBit is inclusive is that it refers to newSettleTime which always less\\r\\n        // than the current block time.\\r\\n        newSettleTime = DateTime.getTimeUTC0(blockTime);\\r\\n        // If newSettleTime == oldSettleTime lastSettleBit will be zero\\r\\n        require(newSettleTime >= oldSettleTime); // dev: new settle time before previous\\r\\n\\r\\n        // Do not need to worry about validity, if newSettleTime is not on an exact bit we will settle up until\\r\\n        // the closest maturity that is less than newSettleTime.\\r\\n        (uint256 lastSettleBit, /* isValid */) = DateTime.getBitNumFromMaturity(oldSettleTime, newSettleTime);\\r\\n        if (lastSettleBit == 0) return (totalAssetCash, newSettleTime);\\r\\n\\r\\n        // Returns the next bit that is set in the bitmap\\r\\n        uint256 nextBitNum = bitmap.getNextBitNum();\\r\\n        while (nextBitNum != 0 && nextBitNum <= lastSettleBit) {\\r\\n            uint256 maturity = DateTime.getMaturityFromBitNum(oldSettleTime, nextBitNum);\\r\\n            totalAssetCash = totalAssetCash.add(\\r\\n                _settlefCashAsset(account, currencyId, maturity, blockTime)\\r\\n            );\\r\\n\\r\\n            // Turn the bit off now that it is settled\\r\\n            bitmap = bitmap.setBit(nextBitNum, false);\\r\\n            nextBitNum = bitmap.getNextBitNum();\\r\\n        }\\r\\n\\r\\n        bytes32 newBitmap;\\r\\n        while (nextBitNum != 0) {\\r\\n            uint256 maturity = DateTime.getMaturityFromBitNum(oldSettleTime, nextBitNum);\\r\\n            (uint256 newBitNum, bool isValid) = DateTime.getBitNumFromMaturity(newSettleTime, maturity);\\r\\n            require(isValid); // dev: invalid new bit num\\r\\n\\r\\n            newBitmap = newBitmap.setBit(newBitNum, true);\\r\\n\\r\\n            // Turn the bit off now that it is remapped\\r\\n            bitmap = bitmap.setBit(nextBitNum, false);\\r\\n            nextBitNum = bitmap.getNextBitNum();\\r\\n        }\\r\\n\\r\\n        BitmapAssetsHandler.setAssetsBitmap(account, currencyId, newBitmap);\\r\\n    }\\r\\n\\r\\n    /// @dev Stateful settlement function to settle a bitmapped asset. Deletes the\\r\\n    /// asset from storage after calculating it.\\r\\n    function _settlefCashAsset(\\r\\n        address account,\\r\\n        uint256 currencyId,\\r\\n        uint256 maturity,\\r\\n        uint256 blockTime\\r\\n    ) private returns (int256 assetCash) {\\r\\n        mapping(address => mapping(uint256 =>\\r\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\r\\n        int256 notional = store[account][currencyId][maturity].notional;\\r\\n        \\r\\n        // Gets the current settlement rate or will store a new settlement rate if it does not\\r\\n        // yet exist.\\r\\n        AssetRateParameters memory rate =\\r\\n            AssetRate.buildSettlementRateStateful(currencyId, maturity, blockTime);\\r\\n        assetCash = rate.convertFromUnderlying(notional);\\r\\n\\r\\n        delete store[account][currencyId][maturity];\\r\\n\\r\\n        return assetCash;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/valuation/FreeCollateral.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"./AssetHandler.sol\\\";\\r\\nimport \\\"./ExchangeRate.sol\\\";\\r\\nimport \\\"../markets/CashGroup.sol\\\";\\r\\nimport \\\"../AccountContextHandler.sol\\\";\\r\\nimport \\\"../balances/BalanceHandler.sol\\\";\\r\\nimport \\\"../portfolio/PortfolioHandler.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\n\\r\\nlibrary FreeCollateral {\\r\\n    using SafeInt256 for int256;\\r\\n    using Bitmap for bytes;\\r\\n    using ExchangeRate for ETHRate;\\r\\n    using AssetRate for AssetRateParameters;\\r\\n    using AccountContextHandler for AccountContext;\\r\\n    using nTokenHandler for nTokenPortfolio;\\r\\n\\r\\n    /// @dev This is only used within the library to clean up the stack\\r\\n    struct FreeCollateralFactors {\\r\\n        int256 netETHValue;\\r\\n        bool updateContext;\\r\\n        uint256 portfolioIndex;\\r\\n        CashGroupParameters cashGroup;\\r\\n        MarketParameters market;\\r\\n        PortfolioAsset[] portfolio;\\r\\n        AssetRateParameters assetRate;\\r\\n        nTokenPortfolio nToken;\\r\\n    }\\r\\n\\r\\n    /// @notice Checks if an asset is active in the portfolio\\r\\n    function _isActiveInPortfolio(bytes2 currencyBytes) private pure returns (bool) {\\r\\n        return currencyBytes & Constants.ACTIVE_IN_PORTFOLIO == Constants.ACTIVE_IN_PORTFOLIO;\\r\\n    }\\r\\n\\r\\n    /// @notice Checks if currency balances are active in the account returns them if true\\r\\n    /// @return cash balance, nTokenBalance\\r\\n    function _getCurrencyBalances(address account, bytes2 currencyBytes)\\r\\n        private\\r\\n        view\\r\\n        returns (int256, int256)\\r\\n    {\\r\\n        if (currencyBytes & Constants.ACTIVE_IN_BALANCES == Constants.ACTIVE_IN_BALANCES) {\\r\\n            uint256 currencyId = uint16(currencyBytes & Constants.UNMASK_FLAGS);\\r\\n            // prettier-ignore\\r\\n            (\\r\\n                int256 cashBalance,\\r\\n                int256 nTokenBalance,\\r\\n                /* lastClaimTime */,\\r\\n                /* lastClaimIntegralSupply */\\r\\n            ) = BalanceHandler.getBalanceStorage(account, currencyId);\\r\\n\\r\\n            return (cashBalance, nTokenBalance);\\r\\n        }\\r\\n\\r\\n        return (0, 0);\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates the nToken asset value with a haircut set by governance\\r\\n    /// @return the value of the account's nTokens after haircut, the nToken parameters\\r\\n    function _getNTokenHaircutAssetPV(\\r\\n        CashGroupParameters memory cashGroup,\\r\\n        nTokenPortfolio memory nToken,\\r\\n        int256 tokenBalance,\\r\\n        uint256 blockTime\\r\\n    ) internal view returns (int256, bytes6) {\\r\\n        nToken.loadNTokenPortfolioNoCashGroup(cashGroup.currencyId);\\r\\n        nToken.cashGroup = cashGroup;\\r\\n\\r\\n        int256 nTokenAssetPV = nToken.getNTokenAssetPV(blockTime);\\r\\n\\r\\n        // (tokenBalance * nTokenValue * haircut) / totalSupply\\r\\n        int256 nTokenHaircutAssetPV =\\r\\n            tokenBalance\\r\\n                .mul(nTokenAssetPV)\\r\\n                .mul(uint8(nToken.parameters[Constants.PV_HAIRCUT_PERCENTAGE]))\\r\\n                .div(Constants.PERCENTAGE_DECIMALS)\\r\\n                .div(nToken.totalSupply);\\r\\n\\r\\n        // nToken.parameters is returned for use in liquidation\\r\\n        return (nTokenHaircutAssetPV, nToken.parameters);\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates portfolio and/or nToken values while using the supplied cash groups and\\r\\n    /// markets. The reason these are grouped together is because they both require storage reads of the same\\r\\n    /// values.\\r\\n    function _getPortfolioAndNTokenAssetValue(\\r\\n        FreeCollateralFactors memory factors,\\r\\n        int256 nTokenBalance,\\r\\n        uint256 blockTime\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (\\r\\n            int256 netPortfolioValue,\\r\\n            int256 nTokenHaircutAssetValue,\\r\\n            bytes6 nTokenParameters\\r\\n        )\\r\\n    {\\r\\n        // If the next asset matches the currency id then we need to calculate the cash group value\\r\\n        if (\\r\\n            factors.portfolioIndex < factors.portfolio.length &&\\r\\n            factors.portfolio[factors.portfolioIndex].currencyId == factors.cashGroup.currencyId\\r\\n        ) {\\r\\n            // netPortfolioValue is in asset cash\\r\\n            (netPortfolioValue, factors.portfolioIndex) = AssetHandler.getNetCashGroupValue(\\r\\n                factors.portfolio,\\r\\n                factors.cashGroup,\\r\\n                factors.market,\\r\\n                blockTime,\\r\\n                factors.portfolioIndex\\r\\n            );\\r\\n        } else {\\r\\n            netPortfolioValue = 0;\\r\\n        }\\r\\n\\r\\n        if (nTokenBalance > 0) {\\r\\n            (nTokenHaircutAssetValue, nTokenParameters) = _getNTokenHaircutAssetPV(\\r\\n                factors.cashGroup,\\r\\n                factors.nToken,\\r\\n                nTokenBalance,\\r\\n                blockTime\\r\\n            );\\r\\n        } else {\\r\\n            nTokenHaircutAssetValue = 0;\\r\\n            nTokenParameters = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns balance values for the bitmapped currency\\r\\n    function _getBitmapBalanceValue(\\r\\n        address account,\\r\\n        uint256 blockTime,\\r\\n        AccountContext memory accountContext,\\r\\n        FreeCollateralFactors memory factors\\r\\n    )\\r\\n        private\\r\\n        view\\r\\n        returns (\\r\\n            int256 cashBalance,\\r\\n            int256 nTokenHaircutAssetValue,\\r\\n            bytes6 nTokenParameters\\r\\n        )\\r\\n    {\\r\\n        int256 nTokenBalance;\\r\\n        // prettier-ignore\\r\\n        (\\r\\n            cashBalance,\\r\\n            nTokenBalance, \\r\\n            /* lastClaimTime */,\\r\\n            /* lastClaimIntegralSupply */\\r\\n        ) = BalanceHandler.getBalanceStorage(account, accountContext.bitmapCurrencyId);\\r\\n\\r\\n        if (nTokenBalance > 0) {\\r\\n            (nTokenHaircutAssetValue, nTokenParameters) = _getNTokenHaircutAssetPV(\\r\\n                factors.cashGroup,\\r\\n                factors.nToken,\\r\\n                nTokenBalance,\\r\\n                blockTime\\r\\n            );\\r\\n        } else {\\r\\n            nTokenHaircutAssetValue = 0;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns portfolio value for the bitmapped currency\\r\\n    function _getBitmapPortfolioValue(\\r\\n        address account,\\r\\n        uint256 blockTime,\\r\\n        AccountContext memory accountContext,\\r\\n        FreeCollateralFactors memory factors\\r\\n    ) private view returns (int256) {\\r\\n        (int256 netPortfolioValueUnderlying, bool bitmapHasDebt) =\\r\\n            BitmapAssetsHandler.getifCashNetPresentValue(\\r\\n                account,\\r\\n                accountContext.bitmapCurrencyId,\\r\\n                accountContext.nextSettleTime,\\r\\n                blockTime,\\r\\n                factors.cashGroup,\\r\\n                true // risk adjusted\\r\\n            );\\r\\n\\r\\n        // Turns off has debt flag if it has changed\\r\\n        bool contextHasAssetDebt =\\r\\n            accountContext.hasDebt & Constants.HAS_ASSET_DEBT == Constants.HAS_ASSET_DEBT;\\r\\n        if (bitmapHasDebt && !contextHasAssetDebt) {\\r\\n            // Turn on has debt\\r\\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;\\r\\n            factors.updateContext = true;\\r\\n        } else if (!bitmapHasDebt && contextHasAssetDebt) {\\r\\n            // Turn off has debt\\r\\n            accountContext.hasDebt = accountContext.hasDebt & ~Constants.HAS_ASSET_DEBT;\\r\\n            factors.updateContext = true;\\r\\n        }\\r\\n\\r\\n        // Return asset cash value\\r\\n        return factors.cashGroup.assetRate.convertFromUnderlying(netPortfolioValueUnderlying);\\r\\n    }\\r\\n\\r\\n    function _updateNetETHValue(\\r\\n        uint256 currencyId,\\r\\n        int256 netLocalAssetValue,\\r\\n        FreeCollateralFactors memory factors\\r\\n    ) private view returns (ETHRate memory) {\\r\\n        ETHRate memory ethRate = ExchangeRate.buildExchangeRate(currencyId);\\r\\n        // Converts to underlying first, ETH exchange rates are in underlying\\r\\n        factors.netETHValue = factors.netETHValue.add(\\r\\n            ethRate.convertToETH(factors.assetRate.convertToUnderlying(netLocalAssetValue))\\r\\n        );\\r\\n\\r\\n        return ethRate;\\r\\n    }\\r\\n\\r\\n    /// @notice Stateful version of get free collateral, returns the total net ETH value and true or false if the account\\r\\n    /// context needs to be updated.\\r\\n    function getFreeCollateralStateful(\\r\\n        address account,\\r\\n        AccountContext memory accountContext,\\r\\n        uint256 blockTime\\r\\n    ) internal returns (int256, bool) {\\r\\n        FreeCollateralFactors memory factors;\\r\\n        bool hasCashDebt;\\r\\n\\r\\n        if (accountContext.isBitmapEnabled()) {\\r\\n            factors.cashGroup = CashGroup.buildCashGroupStateful(accountContext.bitmapCurrencyId);\\r\\n\\r\\n            // prettier-ignore\\r\\n            (\\r\\n                int256 netCashBalance,\\r\\n                int256 nTokenHaircutAssetValue,\\r\\n                /* nTokenParameters */\\r\\n            ) = _getBitmapBalanceValue(account, blockTime, accountContext, factors);\\r\\n            if (netCashBalance < 0) hasCashDebt = true;\\r\\n\\r\\n            int256 portfolioAssetValue =\\r\\n                _getBitmapPortfolioValue(account, blockTime, accountContext, factors);\\r\\n            int256 netLocalAssetValue =\\r\\n                netCashBalance.add(nTokenHaircutAssetValue).add(portfolioAssetValue);\\r\\n\\r\\n            factors.assetRate = factors.cashGroup.assetRate;\\r\\n            _updateNetETHValue(accountContext.bitmapCurrencyId, netLocalAssetValue, factors);\\r\\n        } else {\\r\\n            factors.portfolio = PortfolioHandler.getSortedPortfolio(\\r\\n                account,\\r\\n                accountContext.assetArrayLength\\r\\n            );\\r\\n        }\\r\\n\\r\\n        bytes18 currencies = accountContext.activeCurrencies;\\r\\n        while (currencies != 0) {\\r\\n            bytes2 currencyBytes = bytes2(currencies);\\r\\n            uint16 currencyId = uint16(currencyBytes & Constants.UNMASK_FLAGS);\\r\\n\\r\\n            (int256 netLocalAssetValue, int256 nTokenBalance) =\\r\\n                _getCurrencyBalances(account, currencyBytes);\\r\\n            if (netLocalAssetValue < 0) hasCashDebt = true;\\r\\n\\r\\n            if (_isActiveInPortfolio(currencyBytes) || nTokenBalance > 0) {\\r\\n                factors.cashGroup = CashGroup.buildCashGroupStateful(currencyId);\\r\\n\\r\\n                // prettier-ignore\\r\\n                (\\r\\n                    int256 netPortfolioAssetValue,\\r\\n                    int256 nTokenHaircutAssetValue,\\r\\n                    /* nTokenParameters */\\r\\n                ) = _getPortfolioAndNTokenAssetValue(factors, nTokenBalance, blockTime);\\r\\n                netLocalAssetValue = netLocalAssetValue\\r\\n                    .add(netPortfolioAssetValue)\\r\\n                    .add(nTokenHaircutAssetValue);\\r\\n                factors.assetRate = factors.cashGroup.assetRate;\\r\\n            } else {\\r\\n                // NOTE: we must set the proper assetRate when we updateNetETHValue\\r\\n                factors.assetRate = AssetRate.buildAssetRateStateful(currencyId);\\r\\n            }\\r\\n\\r\\n            _updateNetETHValue(currencyId, netLocalAssetValue, factors);\\r\\n            currencies = currencies << 16;\\r\\n        }\\r\\n\\r\\n        // Free collateral is the only method that examines all cash balances for an account at once. If there is no cash debt (i.e.\\r\\n        // they have been repaid or settled via more debt) then this will turn off the flag. It's possible that this flag is out of\\r\\n        // sync temporarily after a cash settlement and before the next free collateral check. The only downside for that is forcing\\r\\n        // an account to do an extra free collateral check to turn off this setting.\\r\\n        if (\\r\\n            accountContext.hasDebt & Constants.HAS_CASH_DEBT == Constants.HAS_CASH_DEBT &&\\r\\n            !hasCashDebt\\r\\n        ) {\\r\\n            accountContext.hasDebt = accountContext.hasDebt & ~Constants.HAS_CASH_DEBT;\\r\\n            factors.updateContext = true;\\r\\n        }\\r\\n\\r\\n        return (factors.netETHValue, factors.updateContext);\\r\\n    }\\r\\n\\r\\n    /// @notice View version of getFreeCollateral, does not use the stateful version of build cash group and skips\\r\\n    /// all the update context logic.\\r\\n    function getFreeCollateralView(\\r\\n        address account,\\r\\n        AccountContext memory accountContext,\\r\\n        uint256 blockTime\\r\\n    ) internal view returns (int256, int256[] memory) {\\r\\n        FreeCollateralFactors memory factors;\\r\\n        uint256 netLocalIndex;\\r\\n        int256[] memory netLocalAssetValues = new int256[](10);\\r\\n\\r\\n        if (accountContext.isBitmapEnabled()) {\\r\\n            factors.cashGroup = CashGroup.buildCashGroupView(accountContext.bitmapCurrencyId);\\r\\n\\r\\n            // prettier-ignore\\r\\n            (\\r\\n                int256 netCashBalance,\\r\\n                int256 nTokenHaircutAssetValue,\\r\\n                /* nTokenParameters */\\r\\n            ) = _getBitmapBalanceValue(account, blockTime, accountContext, factors);\\r\\n            int256 portfolioAssetValue =\\r\\n                _getBitmapPortfolioValue(account, blockTime, accountContext, factors);\\r\\n\\r\\n            netLocalAssetValues[netLocalIndex] = netCashBalance\\r\\n                .add(nTokenHaircutAssetValue)\\r\\n                .add(portfolioAssetValue);\\r\\n            factors.assetRate = factors.cashGroup.assetRate;\\r\\n            _updateNetETHValue(\\r\\n                accountContext.bitmapCurrencyId,\\r\\n                netLocalAssetValues[netLocalIndex],\\r\\n                factors\\r\\n            );\\r\\n\\r\\n            netLocalIndex++;\\r\\n        } else {\\r\\n            factors.portfolio = PortfolioHandler.getSortedPortfolio(\\r\\n                account,\\r\\n                accountContext.assetArrayLength\\r\\n            );\\r\\n        }\\r\\n\\r\\n        bytes18 currencies = accountContext.activeCurrencies;\\r\\n        while (currencies != 0) {\\r\\n            bytes2 currencyBytes = bytes2(currencies);\\r\\n            uint16 currencyId = uint16(currencyBytes & Constants.UNMASK_FLAGS);\\r\\n            int256 nTokenBalance;\\r\\n            (netLocalAssetValues[netLocalIndex], nTokenBalance) = _getCurrencyBalances(\\r\\n                account,\\r\\n                currencyBytes\\r\\n            );\\r\\n\\r\\n            if (_isActiveInPortfolio(currencyBytes) || nTokenBalance > 0) {\\r\\n                factors.cashGroup = CashGroup.buildCashGroupView(currencyId);\\r\\n                // prettier-ignore\\r\\n                (\\r\\n                    int256 netPortfolioValue,\\r\\n                    int256 nTokenHaircutAssetValue,\\r\\n                    /* nTokenParameters */\\r\\n                ) = _getPortfolioAndNTokenAssetValue(factors, nTokenBalance, blockTime);\\r\\n\\r\\n                netLocalAssetValues[netLocalIndex] = netLocalAssetValues[netLocalIndex]\\r\\n                    .add(netPortfolioValue)\\r\\n                    .add(nTokenHaircutAssetValue);\\r\\n                factors.assetRate = factors.cashGroup.assetRate;\\r\\n            } else {\\r\\n                factors.assetRate = AssetRate.buildAssetRateView(currencyId);\\r\\n            }\\r\\n\\r\\n            _updateNetETHValue(currencyId, netLocalAssetValues[netLocalIndex], factors);\\r\\n            netLocalIndex++;\\r\\n            currencies = currencies << 16;\\r\\n        }\\r\\n\\r\\n        return (factors.netETHValue, netLocalAssetValues);\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates the net value of a currency within a portfolio, this is a bit\\r\\n    /// convoluted to fit into the stack frame\\r\\n    function _calculateLiquidationAssetValue(\\r\\n        FreeCollateralFactors memory factors,\\r\\n        LiquidationFactors memory liquidationFactors,\\r\\n        bytes2 currencyBytes,\\r\\n        bool setLiquidationFactors,\\r\\n        uint256 blockTime\\r\\n    ) private returns (int256) {\\r\\n        uint16 currencyId = uint16(currencyBytes & Constants.UNMASK_FLAGS);\\r\\n        (int256 netLocalAssetValue, int256 nTokenBalance) =\\r\\n            _getCurrencyBalances(liquidationFactors.account, currencyBytes);\\r\\n\\r\\n        if (_isActiveInPortfolio(currencyBytes) || nTokenBalance > 0) {\\r\\n            factors.cashGroup = CashGroup.buildCashGroupStateful(currencyId);\\r\\n            (int256 netPortfolioValue, int256 nTokenHaircutAssetValue, bytes6 nTokenParameters) =\\r\\n                _getPortfolioAndNTokenAssetValue(factors, nTokenBalance, blockTime);\\r\\n\\r\\n            netLocalAssetValue = netLocalAssetValue\\r\\n                .add(netPortfolioValue)\\r\\n                .add(nTokenHaircutAssetValue);\\r\\n            factors.assetRate = factors.cashGroup.assetRate;\\r\\n\\r\\n            // If collateralCurrencyId is set to zero then this is a local currency liquidation\\r\\n            if (setLiquidationFactors) {\\r\\n                liquidationFactors.collateralCashGroup = factors.cashGroup;\\r\\n                liquidationFactors.nTokenParameters = nTokenParameters;\\r\\n                liquidationFactors.nTokenHaircutAssetValue = nTokenHaircutAssetValue;\\r\\n            }\\r\\n        } else {\\r\\n            factors.assetRate = AssetRate.buildAssetRateStateful(currencyId);\\r\\n        }\\r\\n\\r\\n        return netLocalAssetValue;\\r\\n    }\\r\\n\\r\\n    /// @notice A version of getFreeCollateral used during liquidation to save off necessary additional information.\\r\\n    function getLiquidationFactors(\\r\\n        address account,\\r\\n        AccountContext memory accountContext,\\r\\n        uint256 blockTime,\\r\\n        uint256 localCurrencyId,\\r\\n        uint256 collateralCurrencyId\\r\\n    ) internal returns (LiquidationFactors memory, PortfolioAsset[] memory) {\\r\\n        FreeCollateralFactors memory factors;\\r\\n        LiquidationFactors memory liquidationFactors;\\r\\n        // This is only set to reduce the stack size\\r\\n        liquidationFactors.account = account;\\r\\n\\r\\n        if (accountContext.isBitmapEnabled()) {\\r\\n            factors.cashGroup = CashGroup.buildCashGroupStateful(accountContext.bitmapCurrencyId);\\r\\n            (int256 netCashBalance, int256 nTokenHaircutAssetValue, bytes6 nTokenParameters) =\\r\\n                _getBitmapBalanceValue(account, blockTime, accountContext, factors);\\r\\n            int256 portfolioBalance =\\r\\n                _getBitmapPortfolioValue(account, blockTime, accountContext, factors);\\r\\n\\r\\n            int256 netLocalAssetValue =\\r\\n                netCashBalance.add(nTokenHaircutAssetValue).add(portfolioBalance);\\r\\n            factors.assetRate = factors.cashGroup.assetRate;\\r\\n            ETHRate memory ethRate =\\r\\n                _updateNetETHValue(accountContext.bitmapCurrencyId, netLocalAssetValue, factors);\\r\\n\\r\\n            // If the bitmap currency id can only ever be the local currency where debt is held.\\r\\n            // During enable bitmap we check that the account has no assets in their portfolio and\\r\\n            // no cash debts.\\r\\n            if (accountContext.bitmapCurrencyId == localCurrencyId) {\\r\\n                liquidationFactors.localAssetAvailable = netLocalAssetValue;\\r\\n                liquidationFactors.localETHRate = ethRate;\\r\\n                liquidationFactors.localAssetRate = factors.assetRate;\\r\\n\\r\\n                // This will be the case during local currency or local fCash liquidation\\r\\n                if (collateralCurrencyId == 0) {\\r\\n                    // If this is local fCash liquidation, the cash group information is required\\r\\n                    // to calculate fCash haircuts and buffers.\\r\\n                    liquidationFactors.collateralCashGroup = factors.cashGroup;\\r\\n                    liquidationFactors.nTokenHaircutAssetValue = nTokenHaircutAssetValue;\\r\\n                    liquidationFactors.nTokenParameters = nTokenParameters;\\r\\n                }\\r\\n            }\\r\\n        } else {\\r\\n            factors.portfolio = PortfolioHandler.getSortedPortfolio(\\r\\n                account,\\r\\n                accountContext.assetArrayLength\\r\\n            );\\r\\n        }\\r\\n\\r\\n        bytes18 currencies = accountContext.activeCurrencies;\\r\\n        while (currencies != 0) {\\r\\n            bytes2 currencyBytes = bytes2(currencies);\\r\\n\\r\\n            // This next bit of code here is annoyingly structured to get around stack size issues\\r\\n            bool setLiquidationFactors;\\r\\n            {\\r\\n                uint256 tempId = uint256(uint16(currencyBytes & Constants.UNMASK_FLAGS));\\r\\n                setLiquidationFactors =\\r\\n                    (tempId == localCurrencyId && collateralCurrencyId == 0) ||\\r\\n                    tempId == collateralCurrencyId;\\r\\n            }\\r\\n            int256 netLocalAssetValue =\\r\\n                _calculateLiquidationAssetValue(\\r\\n                    factors,\\r\\n                    liquidationFactors,\\r\\n                    currencyBytes,\\r\\n                    setLiquidationFactors,\\r\\n                    blockTime\\r\\n                );\\r\\n\\r\\n            uint256 currencyId = uint256(uint16(currencyBytes & Constants.UNMASK_FLAGS));\\r\\n            ETHRate memory ethRate = _updateNetETHValue(currencyId, netLocalAssetValue, factors);\\r\\n\\r\\n            if (currencyId == collateralCurrencyId) {\\r\\n                // Ensure that this is set even if the cash group is not loaded, it will not be\\r\\n                // loaded if the account only has a cash balance and no nTokens or assets\\r\\n                liquidationFactors.collateralCashGroup.assetRate = factors.assetRate;\\r\\n                liquidationFactors.collateralAssetAvailable = netLocalAssetValue;\\r\\n                liquidationFactors.collateralETHRate = ethRate;\\r\\n            } else if (currencyId == localCurrencyId) {\\r\\n                // This branch will not be entered if bitmap is enabled\\r\\n                liquidationFactors.localAssetAvailable = netLocalAssetValue;\\r\\n                liquidationFactors.localETHRate = ethRate;\\r\\n                liquidationFactors.localAssetRate = factors.assetRate;\\r\\n                // If this is local fCash liquidation, the cash group information is required\\r\\n                // to calculate fCash haircuts and buffers and it will have been set in\\r\\n                // _calculateLiquidationAssetValue above because the account must have fCash assets,\\r\\n                // there is no need to set cash group in this branch.\\r\\n            }\\r\\n\\r\\n            currencies = currencies << 16;\\r\\n        }\\r\\n\\r\\n        liquidationFactors.netETHValue = factors.netETHValue;\\r\\n        require(liquidationFactors.netETHValue < 0, \\\"Sufficient collateral\\\");\\r\\n\\r\\n        // Refetch the portfolio if it exists, AssetHandler.getNetCashValue updates values in memory to do fCash\\r\\n        // netting which will make further calculations incorrect.\\r\\n        if (accountContext.assetArrayLength > 0) {\\r\\n            factors.portfolio = PortfolioHandler.getSortedPortfolio(\\r\\n                account,\\r\\n                accountContext.assetArrayLength\\r\\n            );\\r\\n        }\\r\\n\\r\\n        return (liquidationFactors, factors.portfolio);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/internal/valuation/ExchangeRate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../balances/TokenHandler.sol\\\";\\r\\nimport \\\"../../math/SafeInt256.sol\\\";\\r\\nimport \\\"interfaces/chainlink/AggregatorV2V3Interface.sol\\\";\\r\\n\\r\\nlibrary ExchangeRate {\\r\\n    using SafeInt256 for int256;\\r\\n\\r\\n    /// @notice Converts a balance to ETH from a base currency. Buffers or haircuts are\\r\\n    /// always applied in this method.\\r\\n    /// @param er exchange rate object from base to ETH\\r\\n    /// @return the converted balance denominated in ETH with Constants.INTERNAL_TOKEN_PRECISION\\r\\n    function convertToETH(ETHRate memory er, int256 balance) internal pure returns (int256) {\\r\\n        int256 multiplier = balance > 0 ? er.haircut : er.buffer;\\r\\n\\r\\n        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals\\r\\n        // internalDecimals * rateDecimals * multiplier /  (rateDecimals * multiplierDecimals)\\r\\n        // Therefore the result is in ethDecimals\\r\\n        int256 result =\\r\\n            balance.mul(er.rate).mul(multiplier).div(Constants.PERCENTAGE_DECIMALS).div(\\r\\n                er.rateDecimals\\r\\n            );\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /// @notice Converts the balance denominated in ETH to the equivalent value in a base currency.\\r\\n    /// Buffers and haircuts ARE NOT applied in this method.\\r\\n    /// @param er exchange rate object from base to ETH\\r\\n    /// @param balance amount (denominated in ETH) to convert\\r\\n    function convertETHTo(ETHRate memory er, int256 balance) internal pure returns (int256) {\\r\\n        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals\\r\\n        // internalDecimals * rateDecimals / rateDecimals\\r\\n        int256 result = balance.mul(er.rateDecimals).div(er.rate);\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    /// @notice Calculates the exchange rate between two currencies via ETH. Returns the rate denominated in\\r\\n    /// base exchange rate decimals: (baseRateDecimals * quoteRateDecimals) / quoteRateDecimals\\r\\n    /// @param baseER base exchange rate struct\\r\\n    /// @param quoteER quote exchange rate struct\\r\\n    function exchangeRate(ETHRate memory baseER, ETHRate memory quoteER)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int256)\\r\\n    {\\r\\n        return baseER.rate.mul(quoteER.rateDecimals).div(quoteER.rate);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns an ETHRate object used to calculate free collateral\\r\\n    function buildExchangeRate(uint256 currencyId) internal view returns (ETHRate memory) {\\r\\n        mapping(uint256 => ETHRateStorage) storage store = LibStorage.getExchangeRateStorage();\\r\\n        ETHRateStorage storage ethStorage = store[currencyId];\\r\\n\\r\\n        int256 rateDecimals;\\r\\n        int256 rate;\\r\\n        if (currencyId == Constants.ETH_CURRENCY_ID) {\\r\\n            // ETH rates will just be 1e18, but will still have buffers, haircuts,\\r\\n            // and liquidation discounts\\r\\n            rateDecimals = Constants.ETH_DECIMALS;\\r\\n            rate = Constants.ETH_DECIMALS;\\r\\n        } else {\\r\\n            // prettier-ignore\\r\\n            (\\r\\n                /* roundId */,\\r\\n                rate,\\r\\n                /* uint256 startedAt */,\\r\\n                /* updatedAt */,\\r\\n                /* answeredInRound */\\r\\n            ) = ethStorage.rateOracle.latestRoundData();\\r\\n            require(rate > 0, \\\"Invalid rate\\\");\\r\\n\\r\\n            // No overflow, restricted on storage\\r\\n            rateDecimals = int256(10**ethStorage.rateDecimalPlaces);\\r\\n            if (ethStorage.mustInvert) {\\r\\n                rate = rateDecimals.mul(rateDecimals).div(rate);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return\\r\\n            ETHRate({\\r\\n                rateDecimals: rateDecimals,\\r\\n                rate: rate,\\r\\n                buffer: ethStorage.buffer,\\r\\n                haircut: ethStorage.haircut,\\r\\n                liquidationDiscount: ethStorage.liquidationDiscount\\r\\n            });\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"interfaces/notional/NotionalViews.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\r\\npragma solidity ^0.7.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport \\\"../../contracts/global/Types.sol\\\";\\r\\n\\r\\ninterface NotionalViews {\\r\\n    function getMaxCurrencyId() external view returns (uint16);\\r\\n\\r\\n    function getCurrencyId(address tokenAddress) external view returns (uint16 currencyId);\\r\\n\\r\\n    function getCurrency(uint16 currencyId)\\r\\n        external\\r\\n        view\\r\\n        returns (Token memory assetToken, Token memory underlyingToken);\\r\\n\\r\\n    function getRateStorage(uint16 currencyId)\\r\\n        external\\r\\n        view\\r\\n        returns (ETHRateStorage memory ethRate, AssetRateStorage memory assetRate);\\r\\n\\r\\n    function getCurrencyAndRates(uint16 currencyId)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            Token memory assetToken,\\r\\n            Token memory underlyingToken,\\r\\n            ETHRate memory ethRate,\\r\\n            AssetRateParameters memory assetRate\\r\\n        );\\r\\n\\r\\n    function getCashGroup(uint16 currencyId) external view returns (CashGroupSettings memory);\\r\\n\\r\\n    function getCashGroupAndAssetRate(uint16 currencyId)\\r\\n        external\\r\\n        view\\r\\n        returns (CashGroupSettings memory cashGroup, AssetRateParameters memory assetRate);\\r\\n\\r\\n    function getInitializationParameters(uint16 currencyId)\\r\\n        external\\r\\n        view\\r\\n        returns (int256[] memory annualizedAnchorRates, int256[] memory proportions);\\r\\n\\r\\n    function getDepositParameters(uint16 currencyId)\\r\\n        external\\r\\n        view\\r\\n        returns (int256[] memory depositShares, int256[] memory leverageThresholds);\\r\\n\\r\\n    function nTokenAddress(uint16 currencyId) external view returns (address);\\r\\n\\r\\n    function getNoteToken() external view returns (address);\\r\\n\\r\\n    function getSettlementRate(uint16 currencyId, uint40 maturity)\\r\\n        external\\r\\n        view\\r\\n        returns (AssetRateParameters memory);\\r\\n\\r\\n    function getMarket(uint16 currencyId, uint256 maturity, uint256 settlementDate)\\r\\n        external view returns (MarketParameters memory);\\r\\n\\r\\n    function getActiveMarkets(uint16 currencyId) external view returns (MarketParameters[] memory);\\r\\n\\r\\n    function getActiveMarketsAtBlockTime(uint16 currencyId, uint32 blockTime)\\r\\n        external\\r\\n        view\\r\\n        returns (MarketParameters[] memory);\\r\\n\\r\\n    function getReserveBalance(uint16 currencyId) external view returns (int256 reserveBalance);\\r\\n\\r\\n    function getNTokenPortfolio(address tokenAddress)\\r\\n        external\\r\\n        view\\r\\n        returns (PortfolioAsset[] memory liquidityTokens, PortfolioAsset[] memory netfCashAssets);\\r\\n\\r\\n    function getNTokenAccount(address tokenAddress)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint16 currencyId,\\r\\n            uint256 totalSupply,\\r\\n            uint256 incentiveAnnualEmissionRate,\\r\\n            uint256 lastInitializedTime,\\r\\n            bytes5 nTokenParameters,\\r\\n            int256 cashBalance,\\r\\n            uint256 integralTotalSupply,\\r\\n            uint256 lastSupplyChangeTime\\r\\n        );\\r\\n\\r\\n    function getAccount(address account)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            AccountContext memory accountContext,\\r\\n            AccountBalance[] memory accountBalances,\\r\\n            PortfolioAsset[] memory portfolio\\r\\n        );\\r\\n\\r\\n    function getAccountContext(address account) external view returns (AccountContext memory);\\r\\n\\r\\n    function getAccountBalance(uint16 currencyId, address account)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            int256 cashBalance,\\r\\n            int256 nTokenBalance,\\r\\n            uint256 lastClaimTime\\r\\n        );\\r\\n\\r\\n    function getAccountPortfolio(address account) external view returns (PortfolioAsset[] memory);\\r\\n\\r\\n    function getfCashNotional(\\r\\n        address account,\\r\\n        uint16 currencyId,\\r\\n        uint256 maturity\\r\\n    ) external view returns (int256);\\r\\n\\r\\n    function getAssetsBitmap(address account, uint16 currencyId) external view returns (bytes32);\\r\\n\\r\\n    function getFreeCollateral(address account) external view returns (int256, int256[] memory);\\r\\n\\r\\n    function calculateNTokensToMint(uint16 currencyId, uint88 amountToDepositExternalPrecision)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function getfCashAmountGivenCashAmount(\\r\\n        uint16 currencyId,\\r\\n        int88 netCashToAccount,\\r\\n        uint256 marketIndex,\\r\\n        uint256 blockTime\\r\\n    ) external view returns (int256);\\r\\n\\r\\n    function getCashAmountGivenfCashAmount(\\r\\n        uint16 currencyId,\\r\\n        int88 fCashAmount,\\r\\n        uint256 marketIndex,\\r\\n        uint256 blockTime\\r\\n    ) external view returns (int256, int256);\\r\\n\\r\\n    function nTokenGetClaimableIncentives(address account, uint256 blockTime)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"views_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initializeMarket_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nTokenActions_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nTokenRedeem_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"batchAction_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"accountAction_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"erc1155_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidateCurrency_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidatefCash_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cETH_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"ACCOUNT_ACTION\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BATCH_ACTION\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERC1155\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GOVERNANCE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INITIALIZE_MARKET\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDATE_CURRENCY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDATE_FCASH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NTOKEN_ACTIONS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NTOKEN_REDEEM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VIEWS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"}],\"name\":\"getRouterImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pauseRouter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pauseGuardian_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseGuardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Router", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000038a4dfc0ff6588fd0c2142d14d4963a97356a245000000000000000000000000de14d5f07456c86f070c108a04ae2fafdbd2a939000000000000000000000000280decd520da16e5571a6f2fb803a57e0c16f4230000000000000000000000001cd33f81420bfce8a3622dc56bbd617b7fa3c93a0000000000000000000000001c510763432c0e65d86f313612d4e1e2d26e433200000000000000000000000063757f772b8aab66f4de09617e8f257249efcb93000000000000000000000000f9fdb607d8b843cdf65898df4e08d1479b69002a000000000000000000000000ffd7531ed937f703b269815950cb75bdaaa341c9000000000000000000000000ccaae203256980f0b917166256152ab889450030000000000000000000000000bfe8c8fd568a8b4aa51c36974f2980d4d72aed7e0000000000000000000000004ddc2d193948926d02f9b1fe9e1daa0718270ed5", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}