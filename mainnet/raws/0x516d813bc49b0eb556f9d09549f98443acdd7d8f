{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/OKPCGold.sol\": {\r\n      \"content\": \"/*\\n\\n          \\n            .oooooo.   oooo    oooo ooooooooo.     .oooooo.     \\n           d8P'  `Y8b  `888   .8P'  `888   `Y88.  d8P'  `Y8b    \\n          888      888  888  d8'     888   .d88' 888            \\n          888      888  88888[       888ooo88P'  888            \\n          888      888  888`88b.     888         888            \\n          `88b    d88'  888  `88b.   888         `88b    ooo    \\n           `Y8bood8P'  o888o  o888o o888o         `Y8bood8P'    \\n          \\n          \\n            .oooooo.      .oooooo.   ooooo        oooooooooo.   \\n           d8P'  `Y8b    d8P'  `Y8b  `888'        `888'   `Y8b  \\n          888           888      888  888          888      888 \\n          888           888      888  888          888      888 \\n          888     ooooo 888      888  888          888      888 \\n          `88.    .88'  `88b    d88'  888       o  888     d88' \\n           `Y8bood8P'    `Y8bood8P'  o888ooooood8 o888bood8P'   \\n          \\n           \\n          \\n           \ud835\ude70\ud835\ude7d \ud835\ude74\ud835\ude87\ud835\ude83\ud835\ude74\ud835\ude7d\ud835\ude82\ud835\ude78\ud835\ude7e\ud835\ude7d \ud835\ude83\ud835\ude7e \ud835\ude7e\ud835\ude7a\ud835\ude7f\ud835\ude72 \ud835\ude76\ud835\ude70\ud835\ude7b\ud835\ude7b\ud835\ude74\ud835\ude81\ud835\ude88 \ud835\ude70\ud835\ude81\ud835\ude83\ud835\ude86\ud835\ude7e\ud835\ude81\ud835\ude7a #\ud835\udffc\ud835\udfff: \\\"\ud835\ude70\ud835\ude78\ud835\ude81\ud835\ude73\ud835\ude81\ud835\ude7e\ud835\ude7f\\\"\\n\\n*/\\n\\n// SPDX-License-Identifier: Unlicense\\n\\npragma solidity ^0.8.14;\\n\\nimport \\\"solmate/tokens/ERC20.sol\\\";\\nimport \\\"solmate/auth/Owned.sol\\\";\\nimport \\\"./interfaces/IOKPC.sol\\\";\\nimport \\\"./interfaces/IOKPCMarketplace.sol\\\";\\n\\n/** \\n@title OKPC Gold\\n@author shahruz.eth\\n*/\\n\\ncontract OKPCGold is Owned, ERC20 {\\n    // @dev Core OKPC contract\\n    IOKPC public immutable OKPC;\\n\\n    // @dev Claim config\\n    uint256 public constant OKPC_CLAIM_MAX = 1_024;\\n    uint256 public constant AIRDROP_CLAIM = 10_000;\\n\\n    // @dev Screen staking config\\n    uint256 public SCREEN_STAKING_INTERVAL = 64 days;\\n    uint256 public SCREEN_STAKING_REWARD = 256;\\n\\n    // @dev Claim registry\\n    bool public CLAIMABLE;\\n    struct OKPCClaim {\\n        bool okpcClaimed;\\n        bool artworkClaimed;\\n        uint128 stakingLastClaimed;\\n    }\\n    mapping(uint256 => OKPCClaim) public okpcClaims;\\n    error ClaimNotOpen();\\n    error NoOKGLDClaimable();\\n\\n    // @dev Modifiers\\n    modifier ifClaimable() {\\n        if (!CLAIMABLE) revert ClaimNotOpen();\\n        _;\\n    }\\n\\n    // @dev Constructor\\n    constructor(IOKPC okpcAddress)\\n        Owned(msg.sender)\\n        ERC20(\\\"OKPC GOLD\\\", \\\"OKGLD\\\", 18)\\n    {\\n        OKPC = okpcAddress;\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                  CLAIM ALL                                 */\\n    /* -------------------------------------------------------------------------- */\\n\\n    // @notice Claim all eligible OKGLD for an OKPC.\\n    // @param pcId An OKPC tokenId. Reverts if the token is not owned by the caller.\\n    function claim(uint256 pcId) external ifClaimable {\\n        if (OKPC.ownerOf(pcId) != msg.sender) revert NoOKGLDClaimable();\\n        uint256 amount;\\n        amount += _claimForOKPC(pcId);\\n        amount += _claimForArtwork(pcId);\\n        amount += _claimForScreenStaking(pcId);\\n        if (amount == 0) revert NoOKGLDClaimable();\\n        _mint(msg.sender, amount * 10**decimals);\\n    }\\n\\n    // @notice Claim all eligible OKGLD for a set of OKPCs.\\n    // @param pcIds An array of OKPC tokenIds. Tokens not owned by the caller are skipped.\\n    function claim(uint256[] calldata pcIds) external ifClaimable {\\n        uint256 amount;\\n        for (uint256 i; i < pcIds.length; i++)\\n            if (OKPC.ownerOf(pcIds[i]) == msg.sender) {\\n                amount += _claimForOKPC(pcIds[i]);\\n                amount += _claimForArtwork(pcIds[i]);\\n                amount += _claimForScreenStaking(pcIds[i]);\\n            }\\n        if (amount == 0) revert NoOKGLDClaimable();\\n        _mint(msg.sender, amount * 10**decimals);\\n    }\\n\\n    // @notice Calculate the total amount of OKGLD an OKPC is eligible to claim.\\n    // @param pcId An OKPC tokenId.\\n    function claimableAmount(uint256 pcId)\\n        public\\n        view\\n        returns (uint256 amount)\\n    {\\n        return\\n            claimableAmountForOKPC(pcId) +\\n            claimableAmountForArtwork(pcId) +\\n            claimableAmountForScreenStaking(pcId);\\n    }\\n\\n    // @notice Calculate the total amount of OKGLD a set of OKPCs are eligible to claim.\\n    // @param pcIds An array of OKPC tokenIds.\\n    function claimableAmount(uint256[] calldata pcIds)\\n        public\\n        view\\n        returns (uint256 amount)\\n    {\\n        for (uint256 i; i < pcIds.length; i++)\\n            amount += claimableAmount(pcIds[i]);\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                 OKPC CLAIM                                 */\\n    /* -------------------------------------------------------------------------- */\\n\\n    // @notice Claim OKGLD for an OKPC, based on its clock speed and amount of art collected.\\n    // @param pcId An OKPC tokenId. Reverts if the token is not owned by the caller.\\n    function claimForOKPC(uint256 pcId) external ifClaimable {\\n        if (OKPC.ownerOf(pcId) != msg.sender) revert NoOKGLDClaimable();\\n        uint256 amount = _claimForOKPC(pcId);\\n        if (amount == 0) revert NoOKGLDClaimable();\\n        _mint(msg.sender, amount * 10**decimals);\\n    }\\n\\n    // @notice Claim OKGLD for a set of OKPCs, based on their clock speeds and amounts of art collected.\\n    // @param pcIds An array of OKPC tokenIds. Tokens not owned by the caller are skipped.\\n    function claimForOKPC(uint256[] calldata pcIds) external ifClaimable {\\n        uint256 amount;\\n        for (uint256 i; i < pcIds.length; i++)\\n            if (OKPC.ownerOf(pcIds[i]) == msg.sender)\\n                amount += _claimForOKPC(pcIds[i]);\\n        if (amount == 0) revert NoOKGLDClaimable();\\n        _mint(msg.sender, amount * 10**decimals);\\n    }\\n\\n    // @dev Calculate the amount of OKGLD an OKPC is eligible to claim, based on its clock speed and amount of art collected.\\n    // @dev Register the claimed OKPC using its tokenId to lock future claims.\\n    function _claimForOKPC(uint256 pcId) private returns (uint256 amount) {\\n        amount = claimableAmountForOKPC(pcId);\\n        if (amount > 0) okpcClaims[pcId].okpcClaimed = true;\\n    }\\n\\n    // @notice Calculate the amount of OKGLD an OKPC is eligible to claim, based on its clock speed and amount of art collected.\\n    // @param pcId An OKPC tokenId.\\n    function claimableAmountForOKPC(uint256 pcId)\\n        public\\n        view\\n        returns (uint256 amount)\\n    {\\n        return claimableAmountForOKPC(pcId, 0);\\n    }\\n\\n    // @notice Calculate the amount of OKGLD a set of OKPCs is eligible to claim, based on its clock speed and amount of art collected.\\n    // @param pcIds An array of OKPC tokenIds.\\n    function claimableAmountForOKPC(uint256[] calldata pcIds)\\n        public\\n        view\\n        returns (uint256 amount)\\n    {\\n        for (uint256 i; i < pcIds.length; i++)\\n            amount += claimableAmountForOKPC(pcIds[i], 0);\\n    }\\n\\n    // @notice Calculate the projected amount of OKGLD a set of OKPCs will be eligible to claim after a specified number of blocks, based on their clock speeds and amount of art collected.\\n    // @param pcIds An array of OKPC tokenIds.\\n    // @param afterBlocks An optional number of blocks to skip ahead for projected clock speed scores.\\n    function claimableAmountForOKPC(\\n        uint256[] calldata pcIds,\\n        uint256 afterBlocks\\n    ) public view returns (uint256 amount) {\\n        for (uint256 i; i < pcIds.length; i++)\\n            amount += claimableAmountForOKPC(pcIds[i], afterBlocks);\\n    }\\n\\n    // @notice Calculate the projected amount of OKGLD an OKPC will be eligible to claim after a specified number of blocks, based on its clock speed and amount of art collected.\\n    // @param pcId An OKPC tokenId.\\n    // @param afterBlocks An optional number of blocks to skip ahead for projected clock speed scores.\\n    function claimableAmountForOKPC(uint256 pcId, uint256 afterBlocks)\\n        public\\n        view\\n        returns (uint256 amount)\\n    {\\n        if (okpcClaims[pcId].okpcClaimed == false) {\\n            uint256 artCount = OKPC.artCountForOKPC(pcId);\\n            uint256 total = (clockSpeedProjected(pcId, afterBlocks) / 2) *\\n                2**(artCount > 3 ? 3 : artCount);\\n            amount = total > OKPC_CLAIM_MAX ? OKPC_CLAIM_MAX : total;\\n        }\\n    }\\n\\n    // @notice Calculate the projected clock speed of an OKPC after a specified number of blocks.\\n    // @param pcId An OKPC tokenId.\\n    // @param afterBlocks A number of blocks to skip ahead.\\n    function clockSpeedProjected(uint256 pcId, uint256 afterBlocks)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        (uint256 savedSpeed, uint256 lastBlock, , ) = OKPC.clockSpeedData(pcId);\\n        if (lastBlock == 0) return 1;\\n        uint256 delta = block.number + afterBlocks - lastBlock;\\n        uint256 multiplier = delta / 200_000;\\n        uint256 clockSpeedMaxMultiplier = OKPC.clockSpeedMaxMultiplier();\\n        if (multiplier > clockSpeedMaxMultiplier)\\n            multiplier = clockSpeedMaxMultiplier;\\n        uint256 total = savedSpeed + ((delta * (multiplier + 1)) / 10_000);\\n        if (total < 1) total = 1;\\n        return total;\\n    }\\n\\n    // @notice Calculate the projected clock speed of a set of OKPCs after a specified number of blocks.\\n    // @param pcIds An array of OKPC tokenIds.\\n    // @param afterBlocks A number of blocks to skip ahead.\\n    function clockSpeedProjected(uint256[] calldata pcIds, uint256 afterBlocks)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory result = new uint256[](pcIds.length);\\n        for (uint256 i; i < pcIds.length; i++)\\n            result[i] = clockSpeedProjected(pcIds[i], afterBlocks);\\n        return result;\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                ARTWORK CLAIM                               */\\n    /* -------------------------------------------------------------------------- */\\n\\n    // @notice Claim OKGLD for an OKPC that has collected the AIRDROP artwork from the Gallery.\\n    // @param pcId An OKPC tokenId. Reverts if the token is not owned by the caller.\\n    function claimForArtwork(uint256 pcId) external ifClaimable {\\n        if (OKPC.ownerOf(pcId) != msg.sender) revert NoOKGLDClaimable();\\n        uint256 amount = _claimForArtwork(pcId);\\n        if (amount == 0) revert NoOKGLDClaimable();\\n        _mint(msg.sender, amount * 10**decimals);\\n    }\\n\\n    // @notice Claim OKGLD for a set of OKPCs that have collected the AIRDROP artwork from the Gallery.\\n    // @param pcIds An array of OKPC tokenIds. Tokens not owned by the caller are skipped.\\n    function claimForArtwork(uint256[] calldata pcIds) external ifClaimable {\\n        uint256 amount;\\n        for (uint256 i; i < pcIds.length; i++)\\n            if (OKPC.ownerOf(pcIds[i]) == msg.sender)\\n                amount += _claimForArtwork(pcIds[i]);\\n        if (amount == 0) revert NoOKGLDClaimable();\\n        _mint(msg.sender, amount * 10**decimals);\\n    }\\n\\n    // @dev Calculate the amount of OKGLD an OKPC is eligible to claim, based on collecting the AIRDROP artwork from the Gallery.\\n    // @dev Register the artwork claim using its tokenId to lock future claims.\\n    function _claimForArtwork(uint256 pcId) private returns (uint256 amount) {\\n        amount = claimableAmountForArtwork(pcId);\\n        if (amount > 0) okpcClaims[pcId].artworkClaimed = true;\\n    }\\n\\n    // @notice Calculate the amount of OKGLD an OKPC is eligible to claim, based on collecting the AIRDROP artwork from the Gallery.\\n    // @param pcId An OKPC tokenId.\\n    function claimableAmountForArtwork(uint256 pcId)\\n        public\\n        view\\n        returns (uint256 amount)\\n    {\\n        if (\\n            okpcClaims[pcId].artworkClaimed == false &&\\n            OKPC.artCollectedByOKPC(pcId, 69)\\n        ) {\\n            if (\\n                OKPC.marketplaceAddress() == address(0) ||\\n                IOKPCMarketplace(OKPC.marketplaceAddress()).didMint(pcId, 69)\\n            ) amount = AIRDROP_CLAIM;\\n        }\\n    }\\n\\n    // @notice Calculate the amount of OKGLD a set of OKPCs is eligible to claim, based on collecting the AIRDROP artwork from the Gallery.\\n    // @param pcId An array of OKPC tokenIds.\\n    function claimableAmountForArtwork(uint256[] calldata pcIds)\\n        public\\n        view\\n        returns (uint256 amount)\\n    {\\n        for (uint256 i; i < pcIds.length; i++)\\n            amount += claimableAmountForArtwork(pcIds[i]);\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                               SCREEN STAKING                               */\\n    /* -------------------------------------------------------------------------- */\\n\\n    // @notice Claim OKGLD for an OKPC that is continuously displaying the AIRDROP artwork from the Gallery.\\n    // @param pcId An OKPC tokenId. Reverts if the token is not owned by the caller.\\n    function claimForScreenStaking(uint256 pcId) external ifClaimable {\\n        if (OKPC.ownerOf(pcId) != msg.sender) revert NoOKGLDClaimable();\\n        uint256 amount = _claimForScreenStaking(pcId);\\n        if (amount == 0) revert NoOKGLDClaimable();\\n        _mint(msg.sender, amount * 10**decimals);\\n    }\\n\\n    // @notice Claim OKGLD for a set of OKPCs that are continuously displaying the AIRDROP artwork from the Gallery.\\n    // @param pcIds A set of OKPC tokenIds. Tokens not owned by the caller are skipped.\\n    function claimForScreenStaking(uint256[] calldata pcIds)\\n        external\\n        ifClaimable\\n    {\\n        uint256 amount;\\n        for (uint256 i; i < pcIds.length; i++)\\n            if (OKPC.ownerOf(pcIds[i]) == msg.sender)\\n                amount += _claimForScreenStaking(pcIds[i]);\\n        if (amount == 0) revert NoOKGLDClaimable();\\n        _mint(msg.sender, amount * 10**decimals);\\n    }\\n\\n    // @dev Calculate the amount of OKGLD an OKPC is eligible to claim, based on continuously displaying the AIRDROP artwork from the Gallery.\\n    // @dev Register the screen staking claim to reset the clock.\\n    function _claimForScreenStaking(uint256 pcId)\\n        private\\n        returns (uint256 amount)\\n    {\\n        amount = claimableAmountForScreenStaking(pcId);\\n        if (amount > 0)\\n            okpcClaims[pcId].stakingLastClaimed = uint128(block.timestamp);\\n    }\\n\\n    // @notice Calculate the amount of OKGLD an OKPC is eligible to claim, based on continuously displaying the AIRDROP artwork from the Gallery.\\n    // @param pcId An OKPC tokenId.\\n    function claimableAmountForScreenStaking(uint256 pcId)\\n        public\\n        view\\n        returns (uint256 amount)\\n    {\\n        return claimableAmountForScreenStaking(pcId, 0);\\n    }\\n\\n    // @notice Calculate the amount of OKGLD a set of OKPCs is eligible to claim, based on continuously displaying the AIRDROP artwork from the Gallery.\\n    // @param pcIds An array of OKPC tokenIds.\\n    function claimableAmountForScreenStaking(uint256[] calldata pcIds)\\n        public\\n        view\\n        returns (uint256 amount)\\n    {\\n        for (uint256 i; i < pcIds.length; i++)\\n            amount += claimableAmountForScreenStaking(pcIds[i]);\\n    }\\n\\n    // @notice Calculate the projected amount of OKGLD an OKPC will be eligible to claim after a specified number of seconds, based on continuously displaying the AIRDROP artwork from the Gallery.\\n    // @param pcId An OKPC tokenId.\\n    // @param afterTime An optional number of seconds to skip ahead for projected screen staking rewards.\\n    function claimableAmountForScreenStaking(uint256 pcId, uint256 afterTime)\\n        public\\n        view\\n        returns (uint256 amount)\\n    {\\n        if (OKPC.activeArtForOKPC(pcId) != 69) return 0;\\n        (, , , uint256 artLastChanged) = OKPC.clockSpeedData(pcId);\\n        uint256 previous = (\\n            okpcClaims[pcId].stakingLastClaimed > artLastChanged\\n                ? okpcClaims[pcId].stakingLastClaimed\\n                : artLastChanged\\n        );\\n        if (block.timestamp + afterTime >= previous + SCREEN_STAKING_INTERVAL)\\n            amount =\\n                SCREEN_STAKING_REWARD *\\n                ((block.timestamp + afterTime - previous) /\\n                    SCREEN_STAKING_INTERVAL);\\n    }\\n\\n    // @notice Calculate the projected amount of OKGLD a set of OKPCs will be eligible to claim after a specified number of seconds, based on continuously displaying the AIRDROP artwork from the Gallery.\\n    // @param pcIds An array of OKPC tokenIds.\\n    // @param afterTime An optional number of seconds to skip ahead for projected screen staking rewards.\\n    function claimableAmountForScreenStaking(\\n        uint256[] calldata pcIds,\\n        uint256 afterTime\\n    ) public view returns (uint256 amount) {\\n        for (uint256 i; i < pcIds.length; i++)\\n            amount += claimableAmountForScreenStaking(pcIds[i], afterTime);\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                               TOKEN FUNCTIONS                              */\\n    /* -------------------------------------------------------------------------- */\\n\\n    // @notice Burn tokens and decrease the totalSupply.\\n    // @param amount An amount of tokens to burn.\\n    function burn(uint256 amount) external {\\n        _burn(msg.sender, amount);\\n    }\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                                    OWNER                                   */\\n    /* -------------------------------------------------------------------------- */\\n\\n    // @notice Turn the ability to claim on or off. Owner only.\\n    function setClaimable(bool claimable) external onlyOwner {\\n        CLAIMABLE = claimable;\\n    }\\n\\n    // @notice Adjust the screen staking configuration. Owner only.\\n    function setScreenStakingConfig(\\n        uint256 screenStakingInterval,\\n        uint256 screenStakingReward\\n    ) external onlyOwner {\\n        SCREEN_STAKING_INTERVAL = screenStakingInterval;\\n        SCREEN_STAKING_REWARD = screenStakingReward;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnerUpdated(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setOwner(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOKPC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.14;\\n\\ninterface IOKPC {\\n    function marketplaceAddress() external view returns (address);\\n\\n    function owner() external view returns (address);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n\\n    function artCountForOKPC(uint256) external view returns (uint256);\\n\\n    function clockSpeed(uint256) external view returns (uint256);\\n\\n    function clockSpeedMaxMultiplier() external view returns (uint256);\\n\\n    function clockSpeedData(uint256 pcId)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function activeArtForOKPC(uint256 pcId) external view returns (uint256);\\n\\n    function artCollectedByOKPC(uint256 pcId, uint256 artId)\\n        external\\n        view\\n        returns (bool);\\n\\n    function setMarketplaceAddress(address marketplaceAddress) external;\\n\\n    function transferArt(\\n        uint256 fromOKPC,\\n        uint256 toOKPC,\\n        uint256 artId\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOKPCMarketplace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.14;\\n\\ninterface IOKPCMarketplace {\\n    function didMint(uint256 pcId, uint256 artId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\",\r\n      \"script/=script/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IOKPC\",\"name\":\"okpcAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ClaimNotOpen\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoOKGLDClaimable\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AIRDROP_CLAIM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CLAIMABLE\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OKPC\",\"outputs\":[{\"internalType\":\"contract IOKPC\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OKPC_CLAIM_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SCREEN_STAKING_INTERVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SCREEN_STAKING_REWARD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pcId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pcIds\",\"type\":\"uint256[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pcIds\",\"type\":\"uint256[]\"}],\"name\":\"claimForArtwork\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pcId\",\"type\":\"uint256\"}],\"name\":\"claimForArtwork\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pcId\",\"type\":\"uint256\"}],\"name\":\"claimForOKPC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pcIds\",\"type\":\"uint256[]\"}],\"name\":\"claimForOKPC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pcIds\",\"type\":\"uint256[]\"}],\"name\":\"claimForScreenStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pcId\",\"type\":\"uint256\"}],\"name\":\"claimForScreenStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pcIds\",\"type\":\"uint256[]\"}],\"name\":\"claimableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pcId\",\"type\":\"uint256\"}],\"name\":\"claimableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pcIds\",\"type\":\"uint256[]\"}],\"name\":\"claimableAmountForArtwork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pcId\",\"type\":\"uint256\"}],\"name\":\"claimableAmountForArtwork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pcIds\",\"type\":\"uint256[]\"}],\"name\":\"claimableAmountForOKPC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pcId\",\"type\":\"uint256\"}],\"name\":\"claimableAmountForOKPC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pcIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"afterBlocks\",\"type\":\"uint256\"}],\"name\":\"claimableAmountForOKPC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pcId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"afterBlocks\",\"type\":\"uint256\"}],\"name\":\"claimableAmountForOKPC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pcId\",\"type\":\"uint256\"}],\"name\":\"claimableAmountForScreenStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pcIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"afterTime\",\"type\":\"uint256\"}],\"name\":\"claimableAmountForScreenStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pcId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"afterTime\",\"type\":\"uint256\"}],\"name\":\"claimableAmountForScreenStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pcIds\",\"type\":\"uint256[]\"}],\"name\":\"claimableAmountForScreenStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pcIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"afterBlocks\",\"type\":\"uint256\"}],\"name\":\"clockSpeedProjected\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pcId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"afterBlocks\",\"type\":\"uint256\"}],\"name\":\"clockSpeedProjected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"okpcClaims\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"okpcClaimed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"artworkClaimed\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"stakingLastClaimed\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"claimable\",\"type\":\"bool\"}],\"name\":\"setClaimable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"screenStakingInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"screenStakingReward\",\"type\":\"uint256\"}],\"name\":\"setScreenStakingConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OKPCGold", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007183209867489e1047f3a7c23ea1aed9c4e236e8", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}