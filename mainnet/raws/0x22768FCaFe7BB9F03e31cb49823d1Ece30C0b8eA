{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@yield-protocol/vault-v2/contracts/other/ether/WrapEtherModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.6;\\nimport \\\"@yield-protocol/utils-v2/contracts/token/TransferHelper.sol\\\";\\nimport \\\"../../LadleStorage.sol\\\";\\n\\n\\n/// @dev Module to allow the Ladle to wrap Ether into WETH and transfer it to any destination\\ncontract WrapEtherModule is LadleStorage {\\n    using TransferHelper for IERC20;\\n\\n    constructor (ICauldron cauldron, IWETH9 weth) LadleStorage(cauldron, weth) { }\\n\\n    /// @dev Allow users to wrap Ether in the Ladle and send it to any destination.\\n    function wrap(address receiver, uint256 wad)\\n        external payable\\n    {\\n        weth.deposit{ value: wad }();\\n        IERC20(address(weth)).safeTransfer(receiver, wad);\\n    }\\n}\"\r\n    },\r\n    \"@yield-protocol/utils-v2/contracts/token/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Taken from https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../utils/RevertMsgExtractor.sol\\\";\\n\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with the underlying revert message if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) revert(RevertMsgExtractor.getRevertMsg(data));\\n    }\\n\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @dev Errors with the underlying revert message if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) revert(RevertMsgExtractor.getRevertMsg(data));\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Errors with the underlying revert message if transfer fails\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address payable to, uint256 value) internal {\\n        (bool success, bytes memory data) = to.call{value: value}(new bytes(0));\\n        if (!success) revert(RevertMsgExtractor.getRevertMsg(data));\\n    }\\n}\"\r\n    },\r\n    \"@yield-protocol/vault-v2/contracts/LadleStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.6;\\nimport \\\"@yield-protocol/vault-interfaces/ICauldron.sol\\\";\\nimport \\\"@yield-protocol/vault-interfaces/IJoin.sol\\\";\\nimport \\\"@yield-protocol/yieldspace-interfaces/IPool.sol\\\";\\nimport \\\"@yield-protocol/utils-v2/contracts/interfaces/IWETH9.sol\\\";\\nimport \\\"./Router.sol\\\";\\n\\n\\n/// @dev Ladle orchestrates contract calls throughout the Yield Protocol v2 into useful and efficient user oriented features.\\ncontract LadleStorage {\\n    event JoinAdded(bytes6 indexed assetId, address indexed join);\\n    event PoolAdded(bytes6 indexed seriesId, address indexed pool);\\n    event ModuleAdded(address indexed module, bool indexed set);\\n    event IntegrationAdded(address indexed integration, bool indexed set);\\n    event TokenAdded(address indexed token, bool indexed set);\\n    event FeeSet(uint256 fee);\\n\\n    ICauldron public immutable cauldron;\\n    Router public immutable router;\\n    IWETH9 public immutable weth;\\n    uint256 public borrowingFee;\\n    bytes12 cachedVaultId;\\n\\n    mapping (bytes6 => IJoin)                   public joins;            // Join contracts available to manage assets. The same Join can serve multiple assets (ETH-A, ETH-B, etc...)\\n    mapping (bytes6 => IPool)                   public pools;            // Pool contracts available to manage series. 12 bytes still free.\\n    mapping (address => bool)                   public modules;          // Trusted contracts to delegatecall anything on.\\n    mapping (address => bool)                   public integrations;     // Trusted contracts to call anything on.\\n    mapping (address => bool)                   public tokens;           // Trusted contracts to call `transfer` or `permit` on.\\n\\n    constructor (ICauldron cauldron_, IWETH9 weth_) {\\n        cauldron = cauldron_;\\n        router = new Router();\\n        weth = weth_;\\n    }\\n}\"\r\n    },\r\n    \"@yield-protocol/utils-v2/contracts/token/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"@yield-protocol/utils-v2/contracts/utils/RevertMsgExtractor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Taken from https://github.com/sushiswap/BoringSolidity/blob/441e51c0544cf2451e6116fe00515e71d7c42e2c/contracts/BoringBatchable.sol\\n\\npragma solidity >=0.6.0;\\n\\n\\nlibrary RevertMsgExtractor {\\n    /// @dev Helper function to extract a useful revert message from a failed call.\\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\\n    function getRevertMsg(bytes memory returnData)\\n        internal pure\\n        returns (string memory)\\n    {\\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\\n        if (returnData.length < 68) return \\\"Transaction reverted silently\\\";\\n\\n        assembly {\\n            // Slice the sighash.\\n            returnData := add(returnData, 0x04)\\n        }\\n        return abi.decode(returnData, (string)); // All that remains is the revert string\\n    }\\n}\"\r\n    },\r\n    \"@yield-protocol/vault-interfaces/ICauldron.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"./IFYToken.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\nimport \\\"./DataTypes.sol\\\";\\n\\ninterface ICauldron {\\n    /// @dev Variable rate lending oracle for an underlying\\n    function lendingOracles(bytes6 baseId) external view returns (IOracle);\\n\\n    /// @dev An user can own one or more Vaults, with each vault being able to borrow from a single series.\\n    function vaults(bytes12 vault)\\n        external\\n        view\\n        returns (DataTypes.Vault memory);\\n\\n    /// @dev Series available in Cauldron.\\n    function series(bytes6 seriesId)\\n        external\\n        view\\n        returns (DataTypes.Series memory);\\n\\n    /// @dev Assets available in Cauldron.\\n    function assets(bytes6 assetsId) external view returns (address);\\n\\n    /// @dev Each vault records debt and collateral balances_.\\n    function balances(bytes12 vault)\\n        external\\n        view\\n        returns (DataTypes.Balances memory);\\n\\n    /// @dev Max, min and sum of debt per underlying and collateral.\\n    function debt(bytes6 baseId, bytes6 ilkId)\\n        external\\n        view\\n        returns (DataTypes.Debt memory);\\n\\n    // @dev Spot price oracle addresses and collateralization ratios\\n    function spotOracles(bytes6 baseId, bytes6 ilkId)\\n        external\\n        returns (DataTypes.SpotOracle memory);\\n\\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and up to 5 collateral types\\n    function build(\\n        address owner,\\n        bytes12 vaultId,\\n        bytes6 seriesId,\\n        bytes6 ilkId\\n    ) external returns (DataTypes.Vault memory);\\n\\n    /// @dev Destroy an empty vault. Used to recover gas costs.\\n    function destroy(bytes12 vault) external;\\n\\n    /// @dev Change a vault series and/or collateral types.\\n    function tweak(\\n        bytes12 vaultId,\\n        bytes6 seriesId,\\n        bytes6 ilkId\\n    ) external returns (DataTypes.Vault memory);\\n\\n    /// @dev Give a vault to another user.\\n    function give(bytes12 vaultId, address receiver)\\n        external\\n        returns (DataTypes.Vault memory);\\n\\n    /// @dev Move collateral and debt between vaults.\\n    function stir(\\n        bytes12 from,\\n        bytes12 to,\\n        uint128 ink,\\n        uint128 art\\n    ) external returns (DataTypes.Balances memory, DataTypes.Balances memory);\\n\\n    /// @dev Manipulate a vault debt and collateral.\\n    function pour(\\n        bytes12 vaultId,\\n        int128 ink,\\n        int128 art\\n    ) external returns (DataTypes.Balances memory);\\n\\n    /// @dev Change series and debt of a vault.\\n    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.\\n    function roll(\\n        bytes12 vaultId,\\n        bytes6 seriesId,\\n        int128 art\\n    ) external returns (DataTypes.Vault memory, DataTypes.Balances memory);\\n\\n    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.\\n    function slurp(\\n        bytes12 vaultId,\\n        uint128 ink,\\n        uint128 art\\n    ) external returns (DataTypes.Balances memory);\\n\\n    // ==== Helpers ====\\n\\n    /// @dev Convert a debt amount for a series from base to fyToken terms.\\n    /// @notice Think about rounding if using, since we are dividing.\\n    function debtFromBase(bytes6 seriesId, uint128 base)\\n        external\\n        returns (uint128 art);\\n\\n    /// @dev Convert a debt amount for a series from fyToken to base terms\\n    function debtToBase(bytes6 seriesId, uint128 art)\\n        external\\n        returns (uint128 base);\\n\\n    // ==== Accounting ====\\n\\n    /// @dev Record the borrowing rate at maturity for a series\\n    function mature(bytes6 seriesId) external;\\n\\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\\n    function accrual(bytes6 seriesId) external returns (uint256);\\n\\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\\n    function level(bytes12 vaultId) external returns (int256);\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/vault-interfaces/IJoin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"@yield-protocol/utils-v2/contracts/token/IERC20.sol\\\";\\n\\ninterface IJoin {\\n    /// @dev asset managed by this contract\\n    function asset() external view returns (address);\\n\\n    /// @dev Add tokens to this contract.\\n    function join(address user, uint128 wad) external returns (uint128);\\n\\n    /// @dev Remove tokens to this contract.\\n    function exit(address user, uint128 wad) external returns (uint128);\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/yieldspace-interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.8.0;\\nimport \\\"@yield-protocol/utils-v2/contracts/token/IERC20.sol\\\";\\nimport \\\"@yield-protocol/utils-v2/contracts/token/IERC2612.sol\\\";\\nimport \\\"@yield-protocol/vault-interfaces/IFYToken.sol\\\";\\n\\n\\ninterface IPool is IERC20, IERC2612 {\\n    function ts() external view returns(int128);\\n    function g1() external view returns(int128);\\n    function g2() external view returns(int128);\\n    function maturity() external view returns(uint32);\\n    function scaleFactor() external view returns(uint96);\\n    function getCache() external view returns (uint112, uint112, uint32);\\n    function base() external view returns(IERC20);\\n    function fyToken() external view returns(IFYToken);\\n    function getBaseBalance() external view returns(uint112);\\n    function getFYTokenBalance() external view returns(uint112);\\n    function retrieveBase(address to) external returns(uint128 retrieved);\\n    function retrieveFYToken(address to) external returns(uint128 retrieved);\\n    function sellBase(address to, uint128 min) external returns(uint128);\\n    function buyBase(address to, uint128 baseOut, uint128 max) external returns(uint128);\\n    function sellFYToken(address to, uint128 min) external returns(uint128);\\n    function buyFYToken(address to, uint128 fyTokenOut, uint128 max) external returns(uint128);\\n    function sellBasePreview(uint128 baseIn) external view returns(uint128);\\n    function buyBasePreview(uint128 baseOut) external view returns(uint128);\\n    function sellFYTokenPreview(uint128 fyTokenIn) external view returns(uint128);\\n    function buyFYTokenPreview(uint128 fyTokenOut) external view returns(uint128);\\n    function mint(address to, address remainder, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256);\\n    function mintWithBase(address to, address remainder, uint256 fyTokenToBuy, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256);\\n    function burn(address baseTo, address fyTokenTo, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256);\\n    function burnForBase(address to, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256);\\n}\"\r\n    },\r\n    \"@yield-protocol/utils-v2/contracts/interfaces/IWETH9.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\nimport \\\"../token/IERC20.sol\\\";\\n\\npragma solidity ^0.8.0;\\n\\n\\ninterface IWETH9 is IERC20 {\\n    event  Deposit(address indexed dst, uint wad);\\n    event  Withdrawal(address indexed src, uint wad);\\n\\n    function deposit() external payable;\\n    function withdraw(uint wad) external;\\n}\"\r\n    },\r\n    \"@yield-protocol/vault-v2/contracts/Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.6;\\nimport \\\"@yield-protocol/utils-v2/contracts/utils/RevertMsgExtractor.sol\\\";\\nimport \\\"@yield-protocol/utils-v2/contracts/utils/IsContract.sol\\\";\\n\\n\\n/// @dev Router forwards calls between two contracts, so that any permissions\\n/// given to the original caller are stripped from the call.\\n/// This is useful when implementing generic call routing functions on contracts\\n/// that might have ERC20 approvals or AccessControl authorizations.\\ncontract Router {\\n    using IsContract for address;\\n\\n    address immutable public owner;\\n\\n    constructor () {\\n        owner = msg.sender;\\n    }\\n\\n    /// @dev Allow users to route calls to a pool, to be used with batch\\n    function route(address target, bytes calldata data)\\n        external payable\\n        returns (bytes memory result)\\n    {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        require(target.isContract(), \\\"Target is not a contract\\\");\\n        bool success;\\n        (success, result) = target.call(data);\\n        if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\\n    }\\n}\"\r\n    },\r\n    \"@yield-protocol/vault-interfaces/IFYToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"@yield-protocol/utils-v2/contracts/token/IERC20.sol\\\";\\n\\ninterface IFYToken is IERC20 {\\n    /// @dev Asset that is returned on redemption.\\n    function underlying() external view returns (address);\\n\\n    /// @dev Unix time at which redemption of fyToken for underlying are possible\\n    function maturity() external view returns (uint256);\\n\\n    /// @dev Record price data at maturity\\n    function mature() external;\\n\\n    /// @dev Mint fyToken providing an equal amount of underlying to the protocol\\n    function mintWithUnderlying(address to, uint256 amount) external;\\n\\n    /// @dev Burn fyToken after maturity for an amount of underlying.\\n    function redeem(address to, uint256 amount) external returns (uint256);\\n\\n    /// @dev Mint fyToken.\\n    /// This function can only be called by other Yield contracts, not users directly.\\n    /// @param to Wallet to mint the fyToken in.\\n    /// @param fyTokenAmount Amount of fyToken to mint.\\n    function mint(address to, uint256 fyTokenAmount) external;\\n\\n    /// @dev Burn fyToken.\\n    /// This function can only be called by other Yield contracts, not users directly.\\n    /// @param from Wallet to burn the fyToken from.\\n    /// @param fyTokenAmount Amount of fyToken to burn.\\n    function burn(address from, uint256 fyTokenAmount) external;\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/vault-interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOracle {\\n    /**\\n     * @notice Doesn't refresh the price, but returns the latest value available without doing any transactional operations:\\n     * @return value in wei\\n     */\\n    function peek(\\n        bytes32 base,\\n        bytes32 quote,\\n        uint256 amount\\n    ) external view returns (uint256 value, uint256 updateTime);\\n\\n    /**\\n     * @notice Does whatever work or queries will yield the most up-to-date price, and returns it.\\n     * @return value in wei\\n     */\\n    function get(\\n        bytes32 base,\\n        bytes32 quote,\\n        uint256 amount\\n    ) external returns (uint256 value, uint256 updateTime);\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/vault-interfaces/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"./IFYToken.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\n\\nlibrary DataTypes {\\n    struct Series {\\n        IFYToken fyToken; // Redeemable token for the series.\\n        bytes6 baseId; // Asset received on redemption.\\n        uint32 maturity; // Unix time at which redemption becomes possible.\\n        // bytes2 free\\n    }\\n\\n    struct Debt {\\n        uint96 max; // Maximum debt accepted for a given underlying, across all series\\n        uint24 min; // Minimum debt accepted for a given underlying, across all series\\n        uint8 dec; // Multiplying factor (10**dec) for max and min\\n        uint128 sum; // Current debt for a given underlying, across all series\\n    }\\n\\n    struct SpotOracle {\\n        IOracle oracle; // Address for the spot price oracle\\n        uint32 ratio; // Collateralization ratio to multiply the price for\\n        // bytes8 free\\n    }\\n\\n    struct Vault {\\n        address owner;\\n        bytes6 seriesId; // Each vault is related to only one series, which also determines the underlying.\\n        bytes6 ilkId; // Asset accepted as collateral\\n    }\\n\\n    struct Balances {\\n        uint128 art; // Debt amount\\n        uint128 ink; // Collateral amount\\n    }\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/utils-v2/contracts/token/IERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\n *\\n * Adds the {permit} method, which can be used to change one's\\n * {IERC20-allowance} without having to send a transaction, by signing a\\n * message. This allows users to spend tokens without having to hold Ether.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-2612.\\n */\\ninterface IERC2612 {\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /**\\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/utils-v2/contracts/utils/IsContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Taken from Address.sol from OpenZeppelin.\\npragma solidity ^0.8.0;\\n\\n\\nlibrary IsContract {\\n  /// @dev Returns true if `account` is a contract.\\n  function isContract(address account) internal view returns (bool) {\\n      // This method relies on extcodesize, which returns 0 for contracts in\\n      // construction, since the code is only stored at the end of the\\n      // constructor execution.\\n      return account.code.length > 0;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ICauldron\",\"name\":\"cauldron\",\"type\":\"address\"},{\"internalType\":\"contract IWETH9\",\"name\":\"weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"integration\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"}],\"name\":\"IntegrationAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes6\",\"name\":\"assetId\",\"type\":\"bytes6\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"join\",\"type\":\"address\"}],\"name\":\"JoinAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"}],\"name\":\"ModuleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes6\",\"name\":\"seriesId\",\"type\":\"bytes6\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"PoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"}],\"name\":\"TokenAdded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"borrowingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cauldron\",\"outputs\":[{\"internalType\":\"contract ICauldron\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"integrations\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes6\",\"name\":\"\",\"type\":\"bytes6\"}],\"name\":\"joins\",\"outputs\":[{\"internalType\":\"contract IJoin\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"modules\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes6\",\"name\":\"\",\"type\":\"bytes6\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"contract IPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract Router\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH9\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"wrap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "WrapEtherModule", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000c88191f8cb8e6d4a668b047c1c8503432c3ca867000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}