{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/protocols/YearnInegration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0\\npragma solidity ^0.8.9;\\n\\nimport \\\"./base/CoinStatsBaseV1.sol\\\";\\nimport \\\"../integrationInterface/IntegrationInterface.sol\\\";\\n\\ninterface IWETH {\\n  function deposit() external payable;\\n\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function withdraw(uint256) external;\\n}\\n\\ninterface IYVault {\\n  function deposit(uint256) external;\\n\\n  function deposit(uint256, address) external;\\n\\n  function withdraw(uint256) external;\\n\\n  function getPricePerFullShare() external view returns (uint256);\\n\\n  function token() external view returns (address);\\n\\n  function decimals() external view returns (uint256);\\n\\n  // V2\\n  function pricePerShare() external view returns (uint256);\\n}\\n\\ninterface IYVaultV1Registry {\\n  function getVaults() external view returns (address[] memory);\\n\\n  function getVaultsLength() external view returns (uint256);\\n}\\n\\ninterface ICurveRegistry {\\n  function getSwapAddress(address tokenAddress)\\n    external\\n    view\\n    returns (address poolAddress);\\n\\n  function getNumTokens(address poolAddress)\\n    external\\n    view\\n    returns (uint8 numTokens);\\n}\\n\\ncontract YearnIntegration is IntegrationInterface, CoinStatsBaseV1 {\\n  using SafeERC20 for IERC20;\\n\\n  ICurveRegistry public curveRegistry;\\n\\n  // solhint-disable-next-line var-name-mixedcase\\n  IYVaultV1Registry public V1Registry =\\n    IYVaultV1Registry(0x3eE41C098f9666ed2eA246f4D2558010e59d63A0);\\n\\n  address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n  event Deposit(\\n    address indexed from,\\n    address indexed pool,\\n    uint256 poolTokensReceived,\\n    address affiliate\\n  );\\n\\n  event Withdraw(\\n    address indexed from,\\n    address indexed pool,\\n    uint256 poolTokensReceived,\\n    address affiliate\\n  );\\n\\n  constructor(\\n    ICurveRegistry _curveRegistry,\\n    address curveIntegration,\\n    uint256 _goodwill,\\n    uint256 _affiliateSplit,\\n    address _vaultAddress\\n  ) CoinStatsBaseV1(_goodwill, _affiliateSplit, _vaultAddress) {\\n    // Curve Registry\\n    curveRegistry = _curveRegistry;\\n\\n    // Curve\\n    approvedTargets[curveIntegration] = true;\\n\\n    // 0x exchange\\n    approvedTargets[0xDef1C0ded9bec7F1a1670819833240f027b25EfF] = true;\\n    // 1inch exchange\\n    approvedTargets[0x1111111254fb6c44bAC0beD2854e76F90643097d] = true;\\n  }\\n\\n  /**\\n    @notice Returns pools total supply\\n    @param vaultAddress Yearn pool address from which to get supply\\n   */\\n  function getTotalSupply(address vaultAddress) public view returns (uint256) {\\n    return IERC20(vaultAddress).totalSupply();\\n  }\\n\\n  /**\\n    @notice Returns account balance from pool\\n    @param vaultAddress  Yearn pool address from which to get balance\\n    @param account The account\\n   */\\n  function getBalance(address vaultAddress, address account)\\n    public\\n    view\\n    override\\n    returns (uint256 balance)\\n  {\\n    return IERC20(vaultAddress).balanceOf(account);\\n  }\\n\\n  /**\\n    @notice Adds liquidity to any Yearn vaults with ETH or ERC20 tokens\\n    @param entryTokenAddress The token used for entry (address(0) if ETH).\\n    @param entryTokenAmount The depositTokenAmount of entryTokenAddress to invest\\n    @param vaultAddress Yearn vault address\\n    @param depositTokenAddress Token to be transfered to poolAddress\\n    @param minExitTokenAmount Min acceptable amount of liquidity/stake tokens to reeive\\n    @param underlyingTarget Underlying target which will execute swap\\n    @param targetDepositTokenAddress Token which will be used to deposit fund in target contract\\n    @param swapTarget Underlying target's swap target\\n    @param swapData Data for swap\\n    @param affiliate Affiliate address \\n  */\\n  function deposit(\\n    address entryTokenAddress,\\n    uint256 entryTokenAmount,\\n    address vaultAddress,\\n    address depositTokenAddress,\\n    uint256 minExitTokenAmount,\\n    address underlyingTarget,\\n    address targetDepositTokenAddress,\\n    address swapTarget,\\n    bytes calldata swapData,\\n    address affiliate\\n  ) external payable override whenNotPaused {\\n    // Transfer {entryTokens} to contract\\n    entryTokenAmount = _pullTokens(entryTokenAddress, entryTokenAmount);\\n\\n    // Subtract goodwill\\n    entryTokenAmount -= _subtractGoodwill(\\n      entryTokenAddress,\\n      entryTokenAmount,\\n      affiliate,\\n      true\\n    );\\n\\n    if (entryTokenAddress == address(0)) {\\n      entryTokenAddress = ETH_ADDRESS;\\n    }\\n\\n    // Swap {entryToken} to {depositToken}\\n    // Should return depositToken\\n    uint256 depositTokenAmount;\\n\\n    if (underlyingTarget == address(0)) {\\n      depositTokenAmount = _fillQuote(\\n        entryTokenAddress,\\n        entryTokenAmount,\\n        depositTokenAddress,\\n        swapTarget,\\n        swapData\\n      );\\n    } else {\\n      uint256 value;\\n      if (entryTokenAddress == ETH_ADDRESS) {\\n        value = entryTokenAmount;\\n      } else {\\n        _approveToken(entryTokenAddress, underlyingTarget, entryTokenAmount);\\n      }\\n\\n      address poolAddress = curveRegistry.getSwapAddress(depositTokenAddress);\\n\\n      // solhint-disable-next-line avoid-low-level-calls\\n      bytes memory callData = abi.encodeWithSignature(\\n        \\\"deposit(address,uint256,address,address,uint256,address,address,address,bytes,address)\\\",\\n        entryTokenAddress,\\n        entryTokenAmount,\\n        poolAddress,\\n        targetDepositTokenAddress,\\n        0,\\n        address(0),\\n        address(0),\\n        swapTarget,\\n        swapData,\\n        affiliate\\n      );\\n\\n      depositTokenAmount = _fillCurveDepositQuote(\\n        depositTokenAddress,\\n        underlyingTarget,\\n        value,\\n        callData\\n      );\\n    }\\n\\n    uint256 tokensReceived = _makeDeposit(\\n      depositTokenAddress,\\n      depositTokenAmount,\\n      vaultAddress,\\n      minExitTokenAmount\\n    );\\n\\n    emit Deposit(msg.sender, vaultAddress, tokensReceived, affiliate);\\n  }\\n\\n  function _makeDeposit(\\n    address depositTokenAddress,\\n    uint256 depositTokenAmount,\\n    address vaultAddress,\\n    uint256 minExitTokenAmount\\n  ) internal returns (uint256 tokensReceived) {\\n    // Deposit to Vault\\n\\n    _approveToken(depositTokenAddress, vaultAddress);\\n\\n    uint256 iniYVaultBal = IERC20(vaultAddress).balanceOf(msg.sender);\\n    IYVault(vaultAddress).deposit(depositTokenAmount, msg.sender);\\n    tokensReceived = IERC20(vaultAddress).balanceOf(msg.sender) - iniYVaultBal;\\n\\n    require(\\n      tokensReceived >= minExitTokenAmount,\\n      \\\"VaultDeposit: High Slippage\\\"\\n    );\\n  }\\n\\n  /**\\n    @notice Removes liquidity from Yarn vaults in ETH or ERC20 tokens\\n    @param vaultAddress Yearn vault address\\n    @param vaultTokenAmount Token amount to be transferes to integration contract\\n    @param exitTokenAddress Specifies the token which will be send to caller\\n    @param minExitTokenAmount Min acceptable amount of tokens to reeive\\n    @param underlyingTarget Underlying target which will execute swap\\n    @param targetWithdrawTokenAddress Token which will be used to withdraw funds in target contract\\n    @param swapTarget Excecution target for the first swap\\n    @param swapData DEX quote data\\n    @param affiliate Affiliate address to share fees\\n  */\\n  function withdraw(\\n    address vaultAddress,\\n    uint256 vaultTokenAmount,\\n    address exitTokenAddress,\\n    uint256 minExitTokenAmount,\\n    address underlyingTarget,\\n    address targetWithdrawTokenAddress,\\n    address swapTarget,\\n    bytes calldata swapData,\\n    address affiliate\\n  ) external payable override whenNotPaused {\\n    // Transfer {liquidityTokens} to contract\\n    vaultTokenAmount = _pullTokens(vaultAddress, vaultTokenAmount);\\n\\n    // Get underlying token from vault\\n    address underlyingToken = IYVault(vaultAddress).token();\\n    uint256 underlyingTokenReceived = _vaultWithdraw(\\n      vaultAddress,\\n      vaultTokenAmount,\\n      underlyingToken\\n    );\\n\\n    // Swap to {exitTokenAddress}\\n    uint256 exitTokenAmount;\\n    if (underlyingTarget == address(0)) {\\n      exitTokenAmount = _fillQuote(\\n        underlyingToken,\\n        underlyingTokenReceived,\\n        exitTokenAddress,\\n        swapTarget,\\n        swapData\\n      );\\n    } else {\\n      _approveToken(underlyingToken, underlyingTarget);\\n\\n      address poolAddress = curveRegistry.getSwapAddress(underlyingToken);\\n      // solhint-disable-next-line avoid-low-level-calls\\n      bytes memory callData = abi.encodeWithSignature(\\n        \\\"withdraw(address,uint256,address,uint256,address,address,address,bytes,address)\\\",\\n        poolAddress,\\n        underlyingTokenReceived,\\n        exitTokenAddress,\\n        0,\\n        address(0),\\n        targetWithdrawTokenAddress,\\n        swapTarget,\\n        swapData,\\n        affiliate\\n      );\\n\\n      exitTokenAmount = _fillCurveWithdrawQuote(\\n        exitTokenAddress,\\n        underlyingTarget,\\n        callData\\n      );\\n    }\\n    require(exitTokenAmount >= minExitTokenAmount, \\\"Withdraw: High Slippage\\\");\\n\\n    exitTokenAmount -= _subtractGoodwill(\\n      exitTokenAddress,\\n      exitTokenAmount,\\n      affiliate,\\n      true\\n    );\\n\\n    // Transfer tokens to caller\\n    if (exitTokenAddress == ETH_ADDRESS) {\\n      Address.sendValue(payable(msg.sender), exitTokenAmount);\\n    } else {\\n      IERC20(exitTokenAddress).safeTransfer(msg.sender, exitTokenAmount);\\n    }\\n\\n    emit Withdraw(msg.sender, vaultAddress, exitTokenAmount, affiliate);\\n  }\\n\\n  function _vaultWithdraw(\\n    address poolAddress,\\n    uint256 entryTokenAmount,\\n    address underlyingToken\\n  ) internal returns (uint256 underlyingReceived) {\\n    uint256 iniUnderlyingBal = _getBalance(underlyingToken);\\n\\n    IYVault(poolAddress).withdraw(entryTokenAmount);\\n\\n    underlyingReceived = _getBalance(underlyingToken) - iniUnderlyingBal;\\n  }\\n\\n  function _fillQuote(\\n    address inputTokenAddress,\\n    uint256 inputTokenAmount,\\n    address outputTokenAddress,\\n    address swapTarget,\\n    bytes memory swapData\\n  ) internal returns (uint256 outputTokensBought) {\\n    if (inputTokenAddress == outputTokenAddress) {\\n      return inputTokenAmount;\\n    }\\n\\n    if (swapTarget == WETH) {\\n      if (\\n        outputTokenAddress == address(0) || outputTokenAddress == ETH_ADDRESS\\n      ) {\\n        IWETH(WETH).withdraw(inputTokenAmount);\\n        return inputTokenAmount;\\n      } else {\\n        IWETH(WETH).deposit{value: inputTokenAmount}();\\n        return inputTokenAmount;\\n      }\\n    }\\n\\n    uint256 value;\\n    if (inputTokenAddress == ETH_ADDRESS) {\\n      value = inputTokenAmount;\\n    } else {\\n      _approveToken(inputTokenAddress, swapTarget);\\n    }\\n\\n    uint256 initialOutputTokenBalance = _getBalance(outputTokenAddress);\\n\\n    // solhint-disable-next-line reason-string\\n    require(approvedTargets[swapTarget], \\\"FillQuote: Target is not approved\\\");\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, ) = swapTarget.call{value: value}(swapData);\\n    require(success, \\\"FillQuote: Failed to swap tokens\\\");\\n\\n    outputTokensBought =\\n      _getBalance(outputTokenAddress) -\\n      initialOutputTokenBalance;\\n\\n    // solhint-disable-next-line reason-string\\n    require(outputTokensBought > 0, \\\"FillQuote: Swapped to invalid token\\\");\\n  }\\n\\n  function _fillCurveDepositQuote(\\n    address exitTokenAddress,\\n    address underlyingTarget,\\n    uint256 value,\\n    bytes memory callData\\n  ) internal returns (uint256 outputTokensBought) {\\n    uint256 initialOutputTokenBalance = _getBalance(exitTokenAddress);\\n\\n    // solhint-disable-next-line reason-string\\n    require(\\n      approvedTargets[underlyingTarget],\\n      \\\"FillQuote: Target is not approved\\\"\\n    );\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, ) = underlyingTarget.call{value: value}(callData);\\n    require(success, \\\"FillQuote: Failed to swap tokens\\\");\\n\\n    outputTokensBought =\\n      _getBalance(exitTokenAddress) -\\n      initialOutputTokenBalance;\\n\\n    // solhint-disable-next-line reason-string\\n    require(outputTokensBought > 0, \\\"FillQuote: Swapped to invalid token\\\");\\n  }\\n\\n  function _fillCurveWithdrawQuote(\\n    address exitTokenAddress,\\n    address underlyingTarget,\\n    bytes memory callData\\n  ) internal returns (uint256 outputTokensBought) {\\n    uint256 initialOutputTokenBalance = _getBalance(exitTokenAddress);\\n\\n    // solhint-disable-next-line reason-string\\n    require(\\n      approvedTargets[underlyingTarget],\\n      \\\"FillQuote: Target is not approved\\\"\\n    );\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, ) = underlyingTarget.call(callData);\\n\\n    require(success, \\\"FillQuote: Failed to swap tokens\\\");\\n\\n    outputTokensBought =\\n      _getBalance(exitTokenAddress) -\\n      initialOutputTokenBalance;\\n\\n    // solhint-disable-next-line reason-string\\n    require(outputTokensBought > 0, \\\"FillQuote: Swapped to invalid token\\\");\\n  }\\n\\n  /**\\n    @notice Utility function to determine the quantity of underlying tokens removed from vault\\n    @param poolAddress Yearn vault from which to remove liquidity\\n    @param liquidity Quantity of vault tokens to remove\\n    @return Quantity of underlying LP or token removed\\n  */\\n  function removeAssetReturn(\\n    address poolAddress,\\n    address,\\n    uint256 liquidity\\n  ) external view override returns (uint256) {\\n    require(liquidity > 0, \\\"RAR: Zero amount return\\\");\\n\\n    IYVault vault = IYVault(poolAddress);\\n\\n    address[] memory v1Vaults = V1Registry.getVaults();\\n\\n    for (uint256 i = 0; i < V1Registry.getVaultsLength(); i++) {\\n      if (v1Vaults[i] == poolAddress)\\n        return (liquidity * (vault.getPricePerFullShare())) / (1e18);\\n    }\\n    return (liquidity * (vault.pricePerShare())) / (10**vault.decimals());\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/protocols/base/CoinStatsBaseV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"./FeesV1.sol\\\";\\n\\ninterface IVault {\\n  function addAffiliateBalance(\\n    address affiliate,\\n    address token,\\n    uint256 affiliatePortion\\n  ) external;\\n}\\n\\nabstract contract CoinStatsBaseV1 is FeesV1 {\\n  using SafeERC20 for IERC20;\\n\\n  address public immutable VAULT;\\n\\n  constructor(\\n    uint256 _goodwill,\\n    uint256 _affiliateSplit,\\n    address _vaultAddress\\n  ) FeesV1(_goodwill, _affiliateSplit) {\\n    VAULT = _vaultAddress;\\n  }\\n\\n  /// @notice Sends provided token amount to the contract\\n  /// @param token represents token address to be transfered\\n  /// @param amount represents token amount to be transfered\\n  function _pullTokens(address token, uint256 amount)\\n    internal\\n    returns (uint256 balance)\\n  {\\n    if (token == address(0) || token == ETH_ADDRESS) {\\n      require(msg.value > 0, \\\"ETH was not sent\\\");\\n    } else {\\n      // solhint-disable reason-string\\n      require(msg.value == 0, \\\"Along with token, the ETH was also sent\\\");\\n      uint256 balanceBefore = _getBalance(token);\\n\\n      // Transfers all tokens to current contract\\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n\\n      return _getBalance(token) - balanceBefore;\\n    }\\n    return amount;\\n  }\\n\\n  /// @notice Subtracts goodwill portion from given amount\\n  /// @dev If 0x00... address was given, then it will be replaced with 0xEeeEE... address\\n  /// @param token represents token address\\n  /// @param amount represents token amount\\n  /// @param affiliate goodwill affiliate\\n  /// @param enableGoodwill boolean representation whether to charge fee or not\\n  /// @return totalGoodwillPortion the amount of goodwill\\n  function _subtractGoodwill(\\n    address token,\\n    uint256 amount,\\n    address affiliate,\\n    bool enableGoodwill\\n  ) internal returns (uint256 totalGoodwillPortion) {\\n    bool whitelisted = feeWhitelist[msg.sender];\\n\\n    if (enableGoodwill && !whitelisted && (goodwill > 0)) {\\n      totalGoodwillPortion = (amount * goodwill) / 10000;\\n\\n      if (token == address(0) || token == ETH_ADDRESS) {\\n        Address.sendValue(payable(VAULT), totalGoodwillPortion);\\n      } else {\\n        uint256 balanceBefore = IERC20(token).balanceOf(VAULT);\\n        IERC20(token).safeTransfer(VAULT, totalGoodwillPortion);\\n        totalGoodwillPortion = IERC20(token).balanceOf(VAULT) - balanceBefore;\\n      }\\n\\n      if (affiliates[affiliate]) {\\n        if (token == address(0)) {\\n          token = ETH_ADDRESS;\\n        }\\n\\n        uint256 affiliatePortion = (totalGoodwillPortion * affiliateSplit) /\\n          100;\\n\\n        IVault(VAULT).addAffiliateBalance(affiliate, token, affiliatePortion);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/integrationInterface/IntegrationInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.4;\\n\\n/// @title Protocol Integration Interface\\nabstract contract IntegrationInterface {\\n  /**\\n  @dev The function must deposit assets to the protocol.\\n  @param entryTokenAddress Token to be transfered to integration contract from caller\\n  @param entryTokenAmount Token amount to be transferes to integration contract from caller\\n  @param \\\\ Pool/Vault address to deposit funds\\n  @param depositTokenAddress Token to be transfered to poolAddress\\n  @param minExitTokenAmount Min acceptable amount of liquidity/stake tokens to reeive\\n  @param underlyingTarget Underlying target which will execute swap\\n  @param targetDepositTokenAddress Token which will be used to deposit fund in target contract\\n  @param swapTarget Underlying target's swap target\\n  @param swapData Data for swap\\n  @param affiliate Affiliate address \\n  */\\n\\n  function deposit(\\n    address entryTokenAddress,\\n    uint256 entryTokenAmount,\\n    address,\\n    address depositTokenAddress,\\n    uint256 minExitTokenAmount,\\n    address underlyingTarget,\\n    address targetDepositTokenAddress,\\n    address swapTarget,\\n    bytes calldata swapData,\\n    address affiliate\\n  ) external payable virtual;\\n\\n  /**\\n  @dev The function must withdraw assets from the protocol.\\n  @param \\\\ Pool/Vault address\\n  @param \\\\ Token amount to be transferes to integration contract\\n  @param exitTokenAddress Specifies the token which will be send to caller\\n  @param minExitTokenAmount Min acceptable amount of tokens to reeive\\n  @param underlyingTarget Underlying target which will execute swap\\n  @param targetWithdrawTokenAddress Token which will be used to withdraw funds from target contract\\n  @param swapTarget Underlying target's swap target\\n  @param swapData Data for swap\\n  @param affiliate Affiliate address \\n  */\\n  function withdraw(\\n    address,\\n    uint256,\\n    address exitTokenAddress,\\n    uint256 minExitTokenAmount,\\n    address underlyingTarget,\\n    address targetWithdrawTokenAddress,\\n    address swapTarget,\\n    bytes calldata swapData,\\n    address affiliate\\n  ) external payable virtual;\\n\\n  /**\\n    @dev Returns account balance\\n    @param \\\\ Pool/Vault address\\n    @param account User account address\\n    @return balance Returns user current balance\\n   */\\n  function getBalance(address, address account)\\n    public\\n    view\\n    virtual\\n    returns (uint256 balance);\\n\\n  /**\\n    @notice Utility function to determine the quantity and address of a token being removed\\n    @param \\\\ Pool/Vault address from which liquidity should be removed\\n    @param [Optional] Token address token to be removed\\n    @param amount Quantity of LP tokens to remove.\\n    @return The amount of token removed\\n  */\\n  function removeAssetReturn(\\n    address,\\n    address,\\n    uint256 amount\\n  ) external view virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/protocols/base/FeesV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nabstract contract FeesV1 is Ownable {\\n  using SafeERC20 for IERC20;\\n  bool public paused = false;\\n\\n  // If true, goodwill is not deducted\\n  mapping(address => bool) public feeWhitelist;\\n\\n  uint256 public goodwill;\\n  uint256 public affiliateSplit;\\n\\n  // Mapping from {affiliate} to {status}\\n  mapping(address => bool) public affiliates;\\n  // Mapping from {swapTarget} to {status}\\n  mapping(address => bool) public approvedTargets;\\n  // Mapping from {token} to {status}\\n  mapping(address => bool) public shouldResetAllowance;\\n\\n  address internal constant ETH_ADDRESS =\\n    0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n  event ContractPauseStatusChanged(bool status);\\n  event FeeWhitelistUpdate(address _address, bool status);\\n  event GoodwillChange(uint256 newGoodwill);\\n  event AffiliateSplitChange(uint256 newAffiliateSplit);\\n\\n  constructor(uint256 _goodwill, uint256 _affiliateSplit) {\\n    goodwill = _goodwill;\\n    affiliateSplit = _affiliateSplit;\\n  }\\n\\n  modifier whenNotPaused() {\\n    require(!paused, \\\"Contract is temporary paused\\\");\\n    _;\\n  }\\n\\n  /// @notice Returns address token balance\\n  /// @param token address\\n  /// @return balance\\n  function _getBalance(address token) internal view returns (uint256 balance) {\\n    if (token == address(ETH_ADDRESS)) {\\n      balance = address(this).balance;\\n    } else {\\n      balance = IERC20(token).balanceOf(address(this));\\n    }\\n  }\\n\\n  /// @dev Gives MAX allowance to token spender\\n  /// @param token address to apporve\\n  /// @param spender address\\n  function _approveToken(address token, address spender) internal {\\n    IERC20 _token = IERC20(token);\\n\\n    if (shouldResetAllowance[token]) {\\n      _token.safeApprove(spender, 0);\\n      _token.safeApprove(spender, type(uint256).max);\\n    } else if (_token.allowance(address(this), spender) > 0) return;\\n    else {\\n      _token.safeApprove(spender, type(uint256).max);\\n    }\\n  }\\n\\n  /// @dev Gives allowance to token spender\\n  ///     Resets initial allowance (USDC, USDT...)\\n  /// @param token address to apporve\\n  /// @param spender address\\n  /// @param amount of allowance\\n  function _approveToken(\\n    address token,\\n    address spender,\\n    uint256 amount\\n  ) internal {\\n    IERC20(token).safeIncreaseAllowance(address(spender), amount);\\n  }\\n\\n  /// @notice To pause/unpause contract\\n  function toggleContractActive() public onlyOwner {\\n    paused = !paused;\\n\\n    emit ContractPauseStatusChanged(paused);\\n  }\\n\\n  /// @notice Whitelists addresses from paying goodwill\\n  function setFeeWhitelist(address _address, bool status) external onlyOwner {\\n    feeWhitelist[_address] = status;\\n\\n    emit FeeWhitelistUpdate(_address, status);\\n  }\\n\\n  /// @notice Changes goodwill %\\n  function setNewGoodwill(uint256 _newGoodwill) public onlyOwner {\\n    require(_newGoodwill <= 100, \\\"Invalid goodwill value\\\");\\n    goodwill = _newGoodwill;\\n\\n    emit GoodwillChange(_newGoodwill);\\n  }\\n\\n  /// @notice Changes affiliate split %\\n  function setNewAffiliateSplit(uint256 _newAffiliateSplit) external onlyOwner {\\n    require(_newAffiliateSplit <= 100, \\\"Invalid affilatesplit percent\\\");\\n    affiliateSplit = _newAffiliateSplit;\\n\\n    emit AffiliateSplitChange(_newAffiliateSplit);\\n  }\\n\\n  /// @notice Sets affiliate status\\n  function setAffiliates(\\n    address[] calldata _affiliates,\\n    bool[] calldata _status\\n  ) external onlyOwner {\\n    require(\\n      _affiliates.length == _status.length,\\n      \\\"Affiliate: Invalid input length\\\"\\n    );\\n\\n    for (uint256 i = 0; i < _affiliates.length; i++) {\\n      affiliates[_affiliates[i]] = _status[i];\\n    }\\n  }\\n\\n  ///@notice Sets approved targets\\n  function setApprovedTargets(\\n    address[] calldata targets,\\n    bool[] calldata isApproved\\n  ) external onlyOwner {\\n    require(\\n      targets.length == isApproved.length,\\n      \\\"SetApprovedTargets: Invalid input length\\\"\\n    );\\n\\n    for (uint256 i = 0; i < targets.length; i++) {\\n      approvedTargets[targets[i]] = isApproved[i];\\n    }\\n  }\\n\\n  ///@notice Sets address allowance that should be reset first\\n  function setShouldResetAllowance(\\n    address[] calldata tokens,\\n    bool[] calldata statuses\\n  ) external onlyOwner {\\n    require(\\n      tokens.length == statuses.length,\\n      \\\"SetShouldResetAllowance: Invalid input length\\\"\\n    );\\n\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      shouldResetAllowance[tokens[i]] = statuses[i];\\n    }\\n  }\\n\\n  receive() external payable {\\n    // solhint-disable-next-line\\n    require(msg.sender != tx.origin, \\\"Do not send ETH directly\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ICurveRegistry\",\"name\":\"_curveRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curveIntegration\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_goodwill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_affiliateSplit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_vaultAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAffiliateSplit\",\"type\":\"uint256\"}],\"name\":\"AffiliateSplitChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"ContractPauseStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolTokensReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"FeeWhitelistUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newGoodwill\",\"type\":\"uint256\"}],\"name\":\"GoodwillChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolTokensReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"V1Registry\",\"outputs\":[{\"internalType\":\"contract IYVaultV1Registry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"affiliateSplit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"affiliates\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvedTargets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveRegistry\",\"outputs\":[{\"internalType\":\"contract ICurveRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"entryTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"entryTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"depositTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minExitTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlyingTarget\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetDepositTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"}],\"name\":\"getTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"goodwill\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"removeAssetReturn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_affiliates\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_status\",\"type\":\"bool[]\"}],\"name\":\"setAffiliates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"isApproved\",\"type\":\"bool[]\"}],\"name\":\"setApprovedTargets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setFeeWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newAffiliateSplit\",\"type\":\"uint256\"}],\"name\":\"setNewAffiliateSplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newGoodwill\",\"type\":\"uint256\"}],\"name\":\"setNewGoodwill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"statuses\",\"type\":\"bool[]\"}],\"name\":\"setShouldResetAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shouldResetAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleContractActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exitTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minExitTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlyingTarget\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetWithdrawTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapTarget\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "YearnIntegration", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004f5ae0a4b4d40fc0fef1a11c6df50e4b5d2ec8ef000000000000000000000000820f9421b22d735e87e2253064074d67e4b5efd1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002d8eaf12fe45476ca0ebf815d3f1d9979814cff0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}