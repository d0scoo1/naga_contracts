{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LosslessGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\\\";\\n\\nimport \\\"./Interfaces/ILosslessERC20.sol\\\";\\nimport \\\"./Interfaces/ILosslessController.sol\\\";\\nimport \\\"./Interfaces/ILosslessStaking.sol\\\";\\nimport \\\"./Interfaces/ILosslessReporting.sol\\\";\\nimport \\\"./Interfaces/ILosslessGovernance.sol\\\";\\n\\n/// @title Lossless Governance Contract\\n/// @notice The governance contract is in charge of handling the voting process over the reports and their resolution\\ncontract LosslessGovernance is ILssGovernance, Initializable, AccessControlUpgradeable, PausableUpgradeable {\\n\\n    uint256 override public constant LSS_TEAM_INDEX = 0;\\n    uint256 override public constant TOKEN_OWNER_INDEX = 1;\\n    uint256 override public constant COMMITEE_INDEX = 2;\\n\\n    bytes32 public constant COMMITTEE_ROLE = keccak256(\\\"COMMITTEE_ROLE\\\");\\n\\n    uint256 override public committeeMembersCount;\\n\\n    uint256 override public walletDisputePeriod;\\n\\n    uint256 public compensationPercentage;\\n\\n    uint256 public constant HUNDRED = 1e2;\\n\\n    ILssReporting override public losslessReporting;\\n    ILssController override public losslessController;\\n    ILssStaking override public losslessStaking;\\n\\n    struct Vote {\\n        mapping(address => bool) committeeMemberVoted;\\n        mapping(address => bool) committeeMemberClaimed;\\n        bool[] committeeVotes;\\n        bool[3] votes;\\n        bool[3] voted;\\n        bool resolved;\\n        bool resolution;\\n        bool losslessPayed;\\n        uint256 amountReported;\\n    }\\n    mapping(uint256 => Vote) public reportVotes;\\n\\n    struct ProposedWallet {\\n        uint16 proposal;\\n        uint16 committeeDisagree;\\n        uint256 retrievalAmount;\\n        uint256 timestamp;\\n        address wallet;\\n        bool status;\\n        bool losslessVote;\\n        bool losslessVoted;\\n        bool tokenOwnersVote;\\n        bool tokenOwnersVoted;\\n        bool walletAccepted;\\n        mapping (uint16 => MemberVotesOnProposal) memberVotesOnProposal;\\n    }\\n\\n    mapping(uint256 => ProposedWallet) public proposedWalletOnReport;\\n\\n    struct Compensation {\\n        uint256 amount;\\n        bool payed;\\n    }\\n\\n    struct MemberVotesOnProposal {\\n        mapping (address => bool) memberVoted;\\n    }\\n\\n    mapping(address => Compensation) private compensation;\\n\\n    address[] private reportedAddresses;\\n\\n\\n    uint256 public revsharePercent;\\n    address public revshareAdmin;\\n    mapping(uint256 => bool) public revsharePayed;\\n\\n    function initialize(ILssReporting _losslessReporting, ILssController _losslessController, ILssStaking _losslessStaking, uint256 _walletDisputePeriod) public initializer {\\n        losslessReporting = _losslessReporting;\\n        losslessController = _losslessController;\\n        losslessStaking = _losslessStaking;\\n        walletDisputePeriod = _walletDisputePeriod;\\n        committeeMembersCount = 0;\\n    }\\n\\n    modifier onlyLosslessAdmin() {\\n        require(msg.sender == losslessController.admin(), \\\"LSS: Must be admin\\\");\\n        _;\\n    }\\n\\n    modifier onlyLosslessPauseAdmin() {\\n        require(msg.sender == losslessController.pauseAdmin(), \\\"LSS: Must be pauseAdmin\\\");\\n        _;\\n    }\\n\\n    // --- ADMINISTRATION ---\\n\\n    function pause() public onlyLosslessPauseAdmin  {\\n        _pause();\\n    }    \\n    \\n    function unpause() public onlyLosslessPauseAdmin {\\n        _unpause();\\n    }\\n\\n    \\n    /// @notice This function gets the contract version\\n    /// @return Version of the contract\\n    function getVersion() external pure returns (uint256) {\\n        return 1;\\n    }\\n    \\n    /// @notice This function determines if an address belongs to the Committee\\n    /// @param _account Address to be verified\\n    /// @return True if the address is a committee member\\n    function isCommitteeMember(address _account) override public view returns(bool) {\\n        return hasRole(COMMITTEE_ROLE, _account);\\n    }\\n\\n    /// @notice This function returns if a report has been voted by one of the three fundamental parts\\n    /// @param _reportId Report number to be checked\\n    /// @param _voterIndex Voter Index to be checked\\n    /// @return True if it has been voted\\n    function getIsVoted(uint256 _reportId, uint256 _voterIndex) override public view returns(bool) {\\n        return reportVotes[_reportId].voted[_voterIndex];\\n    }\\n\\n    /// @notice This function returns the resolution on a report by a team \\n    /// @param _reportId Report number to be checked\\n    /// @param _voterIndex Voter Index to be checked\\n    /// @return True if it has voted\\n    function getVote(uint256 _reportId, uint256 _voterIndex) override public view returns(bool) {\\n        return reportVotes[_reportId].votes[_voterIndex];\\n    }\\n\\n    /// @notice This function returns if report has been resolved    \\n    /// @param _reportId Report number to be checked\\n    /// @return True if it has been solved\\n    function isReportSolved(uint256 _reportId) override public view returns(bool){\\n        return reportVotes[_reportId].resolved;\\n    }\\n\\n    /// @notice This function returns report resolution     \\n    /// @param _reportId Report number to be checked\\n    /// @return True if it has been resolved positively\\n    function reportResolution(uint256 _reportId) override public view returns(bool){\\n        return reportVotes[_reportId].resolution;\\n    }\\n\\n    /// @notice This function sets the wallet dispute period\\n    /// @param _timeFrame Time in seconds for the dispute period\\n    function setDisputePeriod(uint256 _timeFrame) override public onlyLosslessAdmin whenNotPaused {\\n        require(_timeFrame != walletDisputePeriod, \\\"LSS: Already set to that amount\\\");\\n        walletDisputePeriod = _timeFrame;\\n        emit NewDisputePeriod(walletDisputePeriod);\\n    }\\n\\n    /// @notice This function sets the amount of tokens given to the erroneously reported address\\n    /// @param _amount Percentage to return\\n    function setCompensationAmount(uint256 _amount) override public onlyLosslessAdmin {\\n        require(_amount <= 100, \\\"LSS: Invalid amount\\\");\\n        require(_amount != compensationPercentage, \\\"LSS: Already set to that amount\\\");\\n        compensationPercentage = _amount;\\n        emit NewCompensationPercentage(compensationPercentage);\\n    }\\n\\n    /// @notice This function sets revenue share Admin\\n    /// @param _address Address of the new admin\\n    function setRevshareAdmin(address _address) override public onlyLosslessAdmin {\\n        require(_address != revshareAdmin, \\\"LSS: Already set to that address\\\");\\n        revshareAdmin = _address;\\n        emit NewRevshareAdmin(revshareAdmin);\\n    }\\n    \\n    /// @notice This function sets the share percentage\\n    /// @param _amount Percentage to share\\n    function setRevsharePercentage(uint256 _amount) override public onlyLosslessAdmin {\\n        require(_amount <= 100, \\\"LSS: Invalid amount\\\");\\n        require(_amount != revsharePercent, \\\"LSS: Already set to that amount\\\");\\n        revsharePercent = _amount;\\n        emit NewRevsharePercentage(revsharePercent);\\n    }\\n\\n\\n    /// @notice This function returns if the majority of the commitee voted and the resolution of the votes\\n    /// @param _reportId Report number to be checked\\n    /// @return isMajorityReached result Returns True if the majority has voted and the true if the result is positive\\n    function _getCommitteeMajorityReachedResult(uint256 _reportId) private view returns(bool isMajorityReached, bool result) {        \\n        Vote storage reportVote = reportVotes[_reportId];\\n        uint256 committeeLength = reportVote.committeeVotes.length;\\n        uint256 committeeQuorum = (committeeMembersCount >> 1) + 1; \\n\\n        uint256 agreeCount;\\n        for(uint256 i = 0; i < committeeLength;) {\\n            if (reportVote.committeeVotes[i]) {\\n                agreeCount += 1;\\n            }\\n            unchecked{i++;}\\n        }\\n\\n        if (agreeCount >= committeeQuorum) {\\n            return (true, true);\\n        } else if ((committeeLength - agreeCount) >= committeeQuorum) {\\n            return (true, false);\\n        } else {\\n            return (false, false);\\n        }\\n    }\\n\\n    /// @notice This function returns the amount reported on a report    \\n    /// @param _reportId Report id to check\\n    function getAmountReported(uint256 _reportId) override external view returns(uint256) {\\n        return reportVotes[_reportId].amountReported;\\n    }\\n\\n    /// @notice This function adds committee members    \\n    /// @param _members Array of members to be added\\n    function addCommitteeMembers(address[] memory _members) override public onlyLosslessAdmin whenNotPaused {\\n        committeeMembersCount += _members.length;\\n\\n        for(uint256 i = 0; i < _members.length;) {\\n            address newMember = _members[i];\\n            require(!isCommitteeMember(newMember), \\\"LSS: duplicate members\\\");\\n            _grantRole(COMMITTEE_ROLE, newMember);\\n\\n            unchecked{i++;}\\n        }\\n\\n        emit NewCommitteeMembers(_members);\\n    } \\n\\n    /// @notice This function removes Committee members    \\n    /// @param _members Array of members to be added\\n    function removeCommitteeMembers(address[] memory _members) override public onlyLosslessAdmin whenNotPaused {  \\n        require(committeeMembersCount >= _members.length, \\\"LSS: Not enough members to remove\\\");\\n\\n        committeeMembersCount -= _members.length;\\n\\n        for(uint256 i = 0; i < _members.length;) {\\n            address newMember = _members[i];\\n            require(isCommitteeMember(newMember), \\\"LSS: An address is not member\\\");\\n            _revokeRole(COMMITTEE_ROLE, newMember);\\n            unchecked{i++;}\\n        }\\n\\n        emit CommitteeMembersRemoval(_members);\\n    }\\n\\n    /// @notice This function emits a vote on a report by the Lossless Team\\n    /// @dev Only can be run by the Lossless Admin\\n    /// @param _reportId Report to cast the vote\\n    /// @param _vote Resolution\\n    function losslessVote(uint256 _reportId, bool _vote) override public onlyLosslessAdmin whenNotPaused {\\n        require(!isReportSolved(_reportId), \\\"LSS: Report already solved\\\");\\n        require(isReportActive(_reportId), \\\"LSS: report is not valid\\\");\\n        \\n        Vote storage reportVote = reportVotes[_reportId];\\n        \\n        require(!reportVote.voted[LSS_TEAM_INDEX], \\\"LSS: LSS already voted\\\");\\n\\n        reportVote.voted[LSS_TEAM_INDEX] = true;\\n        reportVote.votes[LSS_TEAM_INDEX] = _vote;\\n\\n        if (_vote) {\\n            emit LosslessTeamPositiveVote(_reportId);\\n        } else {\\n            emit LosslessTeamNegativeVote(_reportId);\\n        }\\n    }\\n\\n    /// @notice This function emits a vote on a report by the Token Owners\\n    /// @dev Only can be run by the Token admin\\n    /// @param _reportId Report to cast the vote\\n    /// @param _vote Resolution\\n    function tokenOwnersVote(uint256 _reportId, bool _vote) override public whenNotPaused {\\n        require(!isReportSolved(_reportId), \\\"LSS: Report already solved\\\");\\n        require(isReportActive(_reportId), \\\"LSS: report is not valid\\\");\\n\\n        (,,,,ILERC20 reportTokens,,) = losslessReporting.getReportInfo(_reportId);\\n\\n        require(msg.sender == reportTokens.admin(), \\\"LSS: Must be token owner\\\");\\n\\n        Vote storage reportVote = reportVotes[_reportId];\\n\\n        require(!reportVote.voted[TOKEN_OWNER_INDEX], \\\"LSS: owners already voted\\\");\\n        \\n        reportVote.voted[TOKEN_OWNER_INDEX] = true;\\n        reportVote.votes[TOKEN_OWNER_INDEX] = _vote;\\n\\n        if (_vote) {\\n            emit TokenOwnersPositiveVote(_reportId);\\n        } else {\\n            emit TokenOwnersNegativeVote(_reportId);\\n        }\\n    }\\n\\n    /// @notice This function emits a vote on a report by a Committee member\\n    /// @dev Only can be run by a committee member\\n    /// @param _reportId Report to cast the vote\\n    /// @param _vote Resolution\\n    function committeeMemberVote(uint256 _reportId, bool _vote) override public whenNotPaused {\\n        require(!isReportSolved(_reportId), \\\"LSS: Report already solved\\\");\\n        require(isCommitteeMember(msg.sender), \\\"LSS: Must be a committee member\\\");\\n        require(isReportActive(_reportId), \\\"LSS: report is not valid\\\");\\n\\n        Vote storage reportVote = reportVotes[_reportId];\\n\\n        require(!reportVote.committeeMemberVoted[msg.sender], \\\"LSS: Member already voted\\\");\\n        \\n        reportVote.committeeMemberVoted[msg.sender] = true;\\n        reportVote.committeeVotes.push(_vote);\\n\\n        (bool isMajorityReached, bool result) = _getCommitteeMajorityReachedResult(_reportId);\\n\\n        if (isMajorityReached) {\\n            reportVote.votes[COMMITEE_INDEX] = result;\\n            reportVote.voted[COMMITEE_INDEX] = true;\\n            emit CommitteeMajorityReach(_reportId, result);\\n        }\\n\\n        if (_vote) {\\n            emit CommitteeMemberPositiveVote(_reportId, msg.sender);\\n        } else {\\n            emit CommitteeMemberNegativeVote(_reportId, msg.sender);\\n        }\\n    }\\n\\n    /// @notice This function solves a report based on the voting resolution of the three pilars\\n    /// @dev Only can be run by the three pilars.\\n    /// When the report gets resolved, if it's resolved negatively, the reported address gets removed from the blacklist\\n    /// If the report is solved positively, the funds of the reported account get retrieved in order to be distributed among stakers and the reporter.\\n    /// @param _reportId Report to be resolved\\n    function resolveReport(uint256 _reportId) override public whenNotPaused {\\n\\n        require(!isReportSolved(_reportId), \\\"LSS: Report already solved\\\");\\n\\n\\n        (,,,uint256 reportTimestamps,,,) = losslessReporting.getReportInfo(_reportId);\\n        \\n        if (reportTimestamps + losslessReporting.reportLifetime() > block.timestamp) {\\n            _resolveActive(_reportId);\\n        } else {\\n            _resolveExpired(_reportId);\\n        }\\n        \\n        reportVotes[_reportId].resolved = true;\\n        delete reportedAddresses;\\n\\n        emit ReportResolve(_reportId, reportVotes[_reportId].resolution);\\n    }\\n\\n    /// @notice This function has the logic to solve a report that it's still active\\n    /// @param _reportId Report to be resolved\\n    function _resolveActive(uint256 _reportId) private {\\n                \\n        (,address reportedAddress, address secondReportedAddress,, ILERC20 token, bool secondReports,) = losslessReporting.getReportInfo(_reportId);\\n\\n        Vote storage reportVote = reportVotes[_reportId];\\n\\n        uint256 agreeCount = 0;\\n        uint256 voteCount = 0;\\n\\n        if (getIsVoted(_reportId, LSS_TEAM_INDEX)){voteCount += 1;\\n        if (getVote(_reportId, LSS_TEAM_INDEX)){ agreeCount += 1;}}\\n        if (getIsVoted(_reportId, TOKEN_OWNER_INDEX)){voteCount += 1;\\n        if (getVote(_reportId, TOKEN_OWNER_INDEX)){ agreeCount += 1;}}\\n\\n        (bool committeeResoluted, bool committeeResolution) = _getCommitteeMajorityReachedResult(_reportId);\\n        if (committeeResoluted) {voteCount += 1;\\n        if (committeeResolution) {agreeCount += 1;}}\\n\\n        require(voteCount >= 2, \\\"LSS: Not enough votes\\\");\\n        require(!(voteCount == 2 && agreeCount == 1), \\\"LSS: Need another vote to untie\\\");\\n\\n        reportedAddresses.push(reportedAddress);\\n\\n        if (secondReports) {\\n            reportedAddresses.push(secondReportedAddress);\\n        }\\n\\n        if (agreeCount > (voteCount - agreeCount)){\\n            reportVote.resolution = true;\\n            for(uint256 i; i < reportedAddresses.length;) {\\n                reportVote.amountReported += token.balanceOf(reportedAddresses[i]);\\n                unchecked{i++;}\\n            }\\n            proposedWalletOnReport[_reportId].retrievalAmount = losslessController.retrieveBlacklistedFunds(reportedAddresses, token, _reportId);\\n            losslessController.deactivateEmergency(token);\\n        }else{\\n            reportVote.resolution = false;\\n            _compensateAddresses(reportedAddresses);\\n        }\\n    } \\n\\n    /// @notice This function has the logic to solve a report that it's expired\\n    /// @param _reportId Report to be resolved\\n    function _resolveExpired(uint256 _reportId) private {\\n\\n        (,address reportedAddress, address secondReportedAddress,,,bool secondReports,) = losslessReporting.getReportInfo(_reportId);\\n\\n        reportedAddresses.push(reportedAddress);\\n\\n        if (secondReports) {\\n            reportedAddresses.push(secondReportedAddress);\\n        }\\n\\n        reportVotes[_reportId].resolution = false;\\n        _compensateAddresses(reportedAddresses);\\n    }\\n\\n    /// @notice This compensates the addresses wrongly reported\\n    /// @dev The array of addresses will contain the main reported address and the second reported address\\n    /// @param _addresses Array of addresses to be compensated\\n    function _compensateAddresses(address[] memory _addresses) private {\\n        uint256 reportingAmount = losslessReporting.reportingAmount();\\n        uint256 compensationAmount = (reportingAmount * compensationPercentage) / HUNDRED;\\n\\n        \\n        for(uint256 i = 0; i < _addresses.length;) {\\n            address singleAddress = _addresses[i];\\n            Compensation storage addressCompensation = compensation[singleAddress]; \\n            losslessController.resolvedNegatively(singleAddress);      \\n            addressCompensation.amount += compensationAmount;\\n            addressCompensation.payed = false;\\n            unchecked{i++;}\\n        }\\n    }\\n\\n    /// @notice This method retuns if a report is still active\\n    /// @param _reportId report Id to verify\\n    function isReportActive(uint256 _reportId) public view returns(bool) {\\n        (,,,uint256 reportTimestamps,,,) = losslessReporting.getReportInfo(_reportId);\\n        return reportTimestamps != 0 && reportTimestamps + losslessReporting.reportLifetime() > block.timestamp;\\n    }\\n\\n    // REFUND PROCESS\\n\\n    /// @notice This function proposes a wallet where the recovered funds will be returned\\n    /// @dev Only can be run by lossless team or token owners.\\n    /// @param _reportId Report to propose the wallet\\n    /// @param _wallet proposed address\\n    function proposeWallet(uint256 _reportId, address _wallet) override public whenNotPaused {\\n        (,,,uint256 reportTimestamps, ILERC20 reportTokens,,) = losslessReporting.getReportInfo(_reportId);\\n\\n        require(msg.sender == losslessController.admin() || \\n                msg.sender == reportTokens.admin(),\\n                \\\"LSS: Role cannot propose\\\");\\n        require(reportTimestamps != 0, \\\"LSS: Report does not exist\\\");\\n        require(reportResolution(_reportId), \\\"LSS: Report solved negatively\\\");\\n        require(_wallet != address(0), \\\"LSS: Wallet cannot ber zero adr\\\");\\n\\n        ProposedWallet storage proposedWallet = proposedWalletOnReport[_reportId];\\n\\n        require(proposedWallet.wallet == address(0), \\\"LSS: Wallet already proposed\\\");\\n\\n        proposedWallet.wallet = _wallet;\\n        proposedWallet.timestamp = block.timestamp;\\n        proposedWallet.losslessVote = true;\\n        proposedWallet.tokenOwnersVote = true;\\n        proposedWallet.walletAccepted = true;\\n\\n        emit WalletProposal(_reportId, _wallet);\\n    }\\n\\n    /// @notice This function is used to reject the wallet proposal\\n    /// @dev Only can be run by the three pilars.\\n    /// @param _reportId Report to propose the wallet\\n    function rejectWallet(uint256 _reportId) override public whenNotPaused {\\n        (,,,uint256 reportTimestamps,ILERC20 reportTokens,,) = losslessReporting.getReportInfo(_reportId);\\n\\n        ProposedWallet storage proposedWallet = proposedWalletOnReport[_reportId];\\n\\n        require(block.timestamp <= (proposedWallet.timestamp + walletDisputePeriod), \\\"LSS: Dispute period closed\\\");\\n        require(reportTimestamps != 0, \\\"LSS: Report does not exist\\\");\\n\\n        if (hasRole(COMMITTEE_ROLE, msg.sender)) {\\n            require(!proposedWallet.memberVotesOnProposal[proposedWallet.proposal].memberVoted[msg.sender], \\\"LSS: Already Voted\\\");\\n            proposedWallet.committeeDisagree += 1;\\n            proposedWallet.memberVotesOnProposal[proposedWallet.proposal].memberVoted[msg.sender] = true;\\n        } else if (msg.sender == losslessController.admin()) {\\n            require(!proposedWallet.losslessVoted, \\\"LSS: Already Voted\\\");\\n            proposedWallet.losslessVote = false;\\n            proposedWallet.losslessVoted = true;\\n        } else if (msg.sender == reportTokens.admin()) {\\n            require(!proposedWallet.tokenOwnersVoted, \\\"LSS: Already Voted\\\");\\n            proposedWallet.tokenOwnersVote = false;\\n            proposedWallet.tokenOwnersVoted = true;\\n        } else revert (\\\"LSS: Role cannot reject.\\\");\\n\\n        if (!_determineProposedWallet(_reportId)) {\\n            emit WalletRejection(_reportId);\\n        }\\n    }\\n\\n    /// @notice This function retrieves the fund to the accepted proposed wallet\\n    /// @param _reportId Report to propose the wallet\\n    function retrieveFunds(uint256 _reportId) override public whenNotPaused {\\n        (,,,uint256 reportTimestamps, ILERC20 reportTokens,,) = losslessReporting.getReportInfo(_reportId);\\n\\n        ProposedWallet storage proposedWallet = proposedWalletOnReport[_reportId];\\n\\n        require(block.timestamp >= (proposedWallet.timestamp + walletDisputePeriod), \\\"LSS: Dispute period not closed\\\");\\n        require(reportTimestamps != 0, \\\"LSS: Report does not exist\\\");\\n        require(!proposedWallet.status, \\\"LSS: Funds already claimed\\\");\\n        require(proposedWallet.walletAccepted, \\\"LSS: Wallet rejected\\\");\\n        require(proposedWallet.wallet == msg.sender, \\\"LSS: Only proposed adr can claim\\\");\\n\\n        proposedWallet.status = true;\\n\\n        require(reportTokens.transfer(msg.sender, proposedWallet.retrievalAmount), \\n        \\\"LSS: Funds retrieve failed\\\");\\n\\n        emit FundsRetrieval(_reportId, proposedWallet.retrievalAmount);\\n    }\\n\\n    /// @notice This function determins if the refund wallet was accepted\\n    /// @param _reportId Report to propose the wallet\\n    function _determineProposedWallet(uint256 _reportId) private returns(bool){\\n        \\n        ProposedWallet storage proposedWallet = proposedWalletOnReport[_reportId];\\n        uint256 agreementCount;\\n        \\n        if (proposedWallet.committeeDisagree < (committeeMembersCount >> 1)+1 ){\\n            agreementCount += 1;\\n        }\\n\\n        if (proposedWallet.losslessVote) {\\n            agreementCount += 1;\\n        }\\n\\n        if (proposedWallet.tokenOwnersVote) {\\n            agreementCount += 1;\\n        }\\n        \\n        if (agreementCount >= 2) {\\n            return true;\\n        }\\n\\n        proposedWallet.wallet = address(0);\\n        proposedWallet.timestamp = block.timestamp;\\n        proposedWallet.status = false;\\n        proposedWallet.losslessVote = true;\\n        proposedWallet.losslessVoted = false;\\n        proposedWallet.tokenOwnersVote = true;\\n        proposedWallet.tokenOwnersVoted = false;\\n        proposedWallet.walletAccepted = false;\\n        proposedWallet.committeeDisagree = 0;\\n        proposedWallet.proposal += 1;\\n\\n        return false;\\n    }\\n\\n    /// @notice This lets an erroneously reported account to retrieve compensation\\n    function retrieveCompensation() override public whenNotPaused {\\n        require(!compensation[msg.sender].payed, \\\"LSS: Already retrieved\\\");\\n        require(compensation[msg.sender].amount != 0, \\\"LSS: No retribution assigned\\\");\\n        \\n        compensation[msg.sender].payed = true;\\n\\n        losslessReporting.retrieveCompensation(msg.sender, compensation[msg.sender].amount);\\n\\n        emit CompensationRetrieval(msg.sender, compensation[msg.sender].amount);\\n\\n        compensation[msg.sender].amount = 0;\\n\\n    }\\n\\n    ///@notice This function verifies is an address belongs to a contract\\n    ///@param _addr address to verify\\n    function isContract(address _addr) private view returns (bool){\\n         uint32 size;\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return (size != 0);\\n    }\\n\\n    ///@notice This function is for committee members to claim their rewards\\n    ///@param _reportId report ID to claim reward from\\n    function claimCommitteeReward(uint256 _reportId) override public whenNotPaused {\\n        require(reportResolution(_reportId), \\\"LSS: Report solved negatively\\\");\\n\\n        Vote storage reportVote = reportVotes[_reportId];\\n\\n        require(reportVote.committeeMemberVoted[msg.sender], \\\"LSS: Did not vote on report\\\");\\n        require(!reportVote.committeeMemberClaimed[msg.sender], \\\"LSS: Already claimed\\\");\\n\\n        (,,,,ILERC20 reportTokens,,) = losslessReporting.getReportInfo(_reportId);\\n\\n        uint256 numberOfMembersVote = reportVote.committeeVotes.length;\\n        uint256 committeeReward = losslessReporting.committeeReward();\\n\\n        uint256 compensationPerMember = (reportVote.amountReported * committeeReward /  HUNDRED) / numberOfMembersVote;\\n\\n        reportVote.committeeMemberClaimed[msg.sender] = true;\\n\\n        require(reportTokens.transfer(msg.sender, compensationPerMember), \\\"LSS: Reward transfer failed\\\");\\n\\n        emit CommitteeMemberClaim(_reportId, msg.sender, compensationPerMember);\\n    }\\n\\n    /// @notice This function is for the Lossless to claim the rewards\\n    /// @param _reportId report worked on\\n    function losslessClaim(uint256 _reportId) override public whenNotPaused onlyLosslessAdmin {\\n        require(reportResolution(_reportId), \\\"LSS: Report solved negatively\\\");   \\n\\n        Vote storage reportVote = reportVotes[_reportId];\\n\\n        require(!reportVote.losslessPayed, \\\"LSS: Already claimed\\\");\\n\\n        (,,,,ILERC20 reportTokens,,) = losslessReporting.getReportInfo(_reportId);\\n\\n        uint256 amountToClaim = reportVote.amountReported * losslessReporting.losslessReward() / HUNDRED;\\n\\n        if (revshareAdmin != address(0)) {\\n            uint256 shared = amountToClaim * revsharePercent / HUNDRED;\\n            amountToClaim -= shared;\\n        }\\n\\n        reportVote.losslessPayed = true;\\n        require(reportTokens.transfer(losslessController.admin(), amountToClaim), \\n        \\\"LSS: Reward transfer failed\\\");\\n\\n        emit LosslessClaim(reportTokens, _reportId, amountToClaim);\\n    }\\n\\n    /// REVENUE SHARE\\n        \\n    /// @notice This function is for the claim of the Shared revenue\\n    /// @param _reportId report worked on\\n    function revshareClaim(uint256 _reportId) override public whenNotPaused {\\n        require(msg.sender == revshareAdmin, \\\"LSS: Must be revshareAdmin\\\");\\n        require(reportResolution(_reportId), \\\"LSS: Report solved negatively\\\");   \\n\\n        Vote storage reportVote = reportVotes[_reportId];\\n\\n        require(!revsharePayed[_reportId], \\\"LSS: Already claimed\\\");\\n\\n        (,,,,ILERC20 reportTokens,,) = losslessReporting.getReportInfo(_reportId);\\n\\n        uint256 losslessReward = reportVote.amountReported * losslessReporting.losslessReward() / HUNDRED;\\n        uint256 amountToClaim = losslessReward * revsharePercent / HUNDRED;\\n\\n        revsharePayed[_reportId] = true;\\n        require(reportTokens.transfer(msg.sender, amountToClaim), \\n        \\\"LSS: Reward transfer failed\\\");\\n\\n        emit RevshareClaim(reportTokens, _reportId, amountToClaim);\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlUpgradeable.sol\\\";\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../utils/StringsUpgradeable.sol\\\";\\nimport \\\"../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\\n    function __AccessControl_init() internal onlyInitializing {\\n        __Context_init_unchained();\\n        __ERC165_init_unchained();\\n        __AccessControl_init_unchained();\\n    }\\n\\n    function __AccessControl_init_unchained() internal onlyInitializing {\\n    }\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        StringsUpgradeable.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        StringsUpgradeable.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ILosslessERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ILERC20 {\\n    function name() external view returns (string memory);\\n    function admin() external view returns (address);\\n    function getAdmin() external view returns (address);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address _account) external view returns (uint256);\\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n    function approve(address _spender, uint256 _amount) external returns (bool);\\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool);\\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool);\\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool);\\n    \\n    function transferOutBlacklistedFunds(address[] calldata _from) external;\\n    function setLosslessAdmin(address _newAdmin) external;\\n    function transferRecoveryAdminOwnership(address _candidate, bytes32 _keyHash) external;\\n    function acceptRecoveryAdminOwnership(bytes memory _key) external;\\n    function proposeLosslessTurnOff() external;\\n    function executeLosslessTurnOff() external;\\n    function executeLosslessTurnOn() external;\\n\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n    event NewAdmin(address indexed _newAdmin);\\n    event NewRecoveryAdminProposal(address indexed _candidate);\\n    event NewRecoveryAdmin(address indexed _newAdmin);\\n    event LosslessTurnOffProposal(uint256 _turnOffDate);\\n    event LosslessOff();\\n    event LosslessOn();\\n}\"\r\n    },\r\n    \"contracts/Interfaces/ILosslessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ILosslessERC20.sol\\\";\\nimport \\\"./ILosslessGovernance.sol\\\";\\nimport \\\"./ILosslessStaking.sol\\\";\\nimport \\\"./ILosslessReporting.sol\\\";\\nimport \\\"./IProtectionStrategy.sol\\\";\\n\\ninterface ILssController {\\n    // function getLockedAmount(ILERC20 _token, address _account)  returns (uint256);\\n    // function getAvailableAmount(ILERC20 _token, address _account) external view returns (uint256 amount);\\n    function retrieveBlacklistedFunds(address[] calldata _addresses, ILERC20 _token, uint256 _reportId) external returns(uint256);\\n    function whitelist(address _adr) external view returns (bool);\\n    function dexList(address _dexAddress) external returns (bool);\\n    function blacklist(address _adr) external view returns (bool);\\n    function admin() external view returns (address);\\n    function pauseAdmin() external view returns (address);\\n    function recoveryAdmin() external view returns (address);\\n    function guardian() external view returns (address);\\n    function losslessStaking() external view returns (ILssStaking);\\n    function losslessReporting() external view returns (ILssReporting);\\n    function losslessGovernance() external view returns (ILssGovernance);\\n    function dexTranferThreshold() external view returns (uint256);\\n    function settlementTimeLock() external view returns (uint256);\\n    \\n    function pause() external;\\n    function unpause() external;\\n    function setAdmin(address _newAdmin) external;\\n    function setRecoveryAdmin(address _newRecoveryAdmin) external;\\n    function setPauseAdmin(address _newPauseAdmin) external;\\n    function setSettlementTimeLock(uint256 _newTimelock) external;\\n    function setDexTransferThreshold(uint256 _newThreshold) external;\\n    function setDexList(address[] calldata _dexList, bool _value) external;\\n    function setWhitelist(address[] calldata _addrList, bool _value) external;\\n    function addToBlacklist(address _adr) external;\\n    function resolvedNegatively(address _adr) external;\\n    function setStakingContractAddress(ILssStaking _adr) external;\\n    function setReportingContractAddress(ILssReporting _adr) external; \\n    function setGovernanceContractAddress(ILssGovernance _adr) external;\\n    function proposeNewSettlementPeriod(ILERC20 _token, uint256 _seconds) external;\\n    function executeNewSettlementPeriod(ILERC20 _token) external;\\n    function activateEmergency(ILERC20 _token) external;\\n    function deactivateEmergency(ILERC20 _token) external;\\n    function setGuardian(address _newGuardian) external;\\n    function removeProtectedAddress(ILERC20 _token, address _protectedAddresss) external;\\n    function beforeTransfer(address _sender, address _recipient, uint256 _amount) external;\\n    function beforeTransferFrom(address _msgSender, address _sender, address _recipient, uint256 _amount) external;\\n    function beforeApprove(address _sender, address _spender, uint256 _amount) external;\\n    function beforeIncreaseAllowance(address _msgSender, address _spender, uint256 _addedValue) external;\\n    function beforeDecreaseAllowance(address _msgSender, address _spender, uint256 _subtractedValue) external;\\n    function beforeMint(address _to, uint256 _amount) external;\\n    function beforeBurn(address _account, uint256 _amount) external;\\n    function setProtectedAddress(ILERC20 _token, address _protectedAddress, ProtectionStrategy _strategy) external;\\n\\n    event AdminChange(address indexed _newAdmin);\\n    event RecoveryAdminChange(address indexed _newAdmin);\\n    event PauseAdminChange(address indexed _newAdmin);\\n    event GuardianSet(address indexed _oldGuardian, address indexed _newGuardian);\\n    event NewProtectedAddress(ILERC20 indexed _token, address indexed _protectedAddress, address indexed _strategy);\\n    event RemovedProtectedAddress(ILERC20 indexed _token, address indexed _protectedAddress);\\n    event NewSettlementPeriodProposal(ILERC20 indexed _token, uint256 _seconds);\\n    event SettlementPeriodChange(ILERC20 indexed _token, uint256 _proposedTokenLockTimeframe);\\n    event NewSettlementTimelock(uint256 indexed _timelock);\\n    event NewDexThreshold(uint256 indexed _newThreshold);\\n    event NewDex(address indexed _dexAddress);\\n    event DexRemoval(address indexed _dexAddress);\\n    event NewWhitelistedAddress(address indexed _whitelistAdr);\\n    event WhitelistedAddressRemoval(address indexed _whitelistAdr);\\n    event NewBlacklistedAddress(address indexed _blacklistedAddres);\\n    event AccountBlacklistRemoval(address indexed _adr);\\n    event NewStakingContract(ILssStaking indexed _newAdr);\\n    event NewReportingContract(ILssReporting indexed _newAdr);\\n    event NewGovernanceContract(ILssGovernance indexed _newAdr);\\n    event EmergencyActive(ILERC20 indexed _token);\\n    event EmergencyDeactivation(ILERC20 indexed _token);\\n}\"\r\n    },\r\n    \"contracts/Interfaces/ILosslessStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ILosslessERC20.sol\\\";\\nimport \\\"./ILosslessGovernance.sol\\\";\\nimport \\\"./ILosslessReporting.sol\\\";\\nimport \\\"./ILosslessController.sol\\\";\\n\\ninterface ILssStaking {\\n  function stakingToken() external returns(ILERC20);\\n  function losslessReporting() external returns(ILssReporting);\\n  function losslessController() external returns(ILssController);\\n  function losslessGovernance() external returns(ILssGovernance);\\n  function stakingAmount() external returns(uint256);\\n  function getVersion() external pure returns (uint256);\\n  function getIsAccountStaked(uint256 _reportId, address _account) external view returns(bool);\\n  function getStakerCoefficient(uint256 _reportId, address _address) external view returns (uint256);\\n  function stakerClaimableAmount(uint256 _reportId) external view returns (uint256);\\n  \\n  function pause() external;\\n  function unpause() external;\\n  function setLssReporting(ILssReporting _losslessReporting) external;\\n  function setStakingToken(ILERC20 _stakingToken) external;\\n  function setLosslessGovernance(ILssGovernance _losslessGovernance) external;\\n  function setStakingAmount(uint256 _stakingAmount) external;\\n  function stake(uint256 _reportId) external;\\n  function stakerClaim(uint256 _reportId) external;\\n\\n  event NewStake(ILERC20 indexed _token, address indexed _account, uint256 indexed _reportId, uint256 _amount);\\n  event StakerClaim(address indexed _staker, ILERC20 indexed _token, uint256 indexed _reportID, uint256 _amount);\\n  event NewStakingAmount(uint256 indexed _newAmount);\\n  event NewStakingToken(ILERC20 indexed _newToken);\\n  event NewReportingContract(ILssReporting indexed _newContract);\\n  event NewGovernanceContract(ILssGovernance indexed _newContract);\\n}\"\r\n    },\r\n    \"contracts/Interfaces/ILosslessReporting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ILosslessERC20.sol\\\";\\nimport \\\"./ILosslessGovernance.sol\\\";\\nimport \\\"./ILosslessStaking.sol\\\";\\nimport \\\"./ILosslessController.sol\\\";\\n\\ninterface ILssReporting {\\n  function reporterReward() external returns(uint256);\\n  function losslessReward() external returns(uint256);\\n  function stakersReward() external returns(uint256);\\n  function committeeReward() external returns(uint256);\\n  function reportLifetime() external view returns(uint256);\\n  function reportingAmount() external returns(uint256);\\n  function reportCount() external returns(uint256);\\n  function stakingToken() external returns(ILERC20);\\n  function losslessController() external returns(ILssController);\\n  function losslessGovernance() external returns(ILssGovernance);\\n  function getVersion() external pure returns (uint256);\\n  function getRewards() external view returns (uint256 _reporter, uint256 _lossless, uint256 _committee, uint256 _stakers);\\n  function report(ILERC20 _token, address _account) external returns (uint256);\\n  function reporterClaimableAmount(uint256 _reportId) external view returns (uint256);\\n  function getReportInfo(uint256 _reportId) external view returns(address _reporter,\\n        address _reportedAddress,\\n        address _secondReportedAddress,\\n        uint256 _reportTimestamps,\\n        ILERC20 _reportTokens,\\n        bool _secondReports,\\n        bool _reporterClaimStatus);\\n  \\n  function pause() external;\\n  function unpause() external;\\n  function setStakingToken(ILERC20 _stakingToken) external;\\n  function setLosslessGovernance(ILssGovernance _losslessGovernance) external;\\n  function setReportingAmount(uint256 _reportingAmount) external;\\n  function setReporterReward(uint256 _reward) external;\\n  function setLosslessReward(uint256 _reward) external;\\n  function setStakersReward(uint256 _reward) external;\\n  function setCommitteeReward(uint256 _reward) external;\\n  function setReportLifetime(uint256 _lifetime) external;\\n  function secondReport(uint256 _reportId, address _account) external;\\n  function reporterClaim(uint256 _reportId) external;\\n  function retrieveCompensation(address _adr, uint256 _amount) external;\\n\\n  event ReportSubmission(ILERC20 indexed _token, address indexed _account, uint256 indexed _reportId, uint256 _amount);\\n  event SecondReportSubmission(ILERC20 indexed _token, address indexed _account, uint256 indexed _reportId);\\n  event NewReportingAmount(uint256 indexed _newAmount);\\n  event NewStakingToken(ILERC20 indexed _token);\\n  event NewGovernanceContract(ILssGovernance indexed _adr);\\n  event NewReporterReward(uint256 indexed _newValue);\\n  event NewLosslessReward(uint256 indexed _newValue);\\n  event NewStakersReward(uint256 indexed _newValue);\\n  event NewCommitteeReward(uint256 indexed _newValue);\\n  event NewReportLifetime(uint256 indexed _newValue);\\n  event ReporterClaim(address indexed _reporter, uint256 indexed _reportId, uint256 indexed _amount);\\n  event CompensationRetrieve(address indexed _adr, uint256 indexed _amount);\\n}\"\r\n    },\r\n    \"contracts/Interfaces/ILosslessGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ILosslessERC20.sol\\\";\\nimport \\\"./ILosslessStaking.sol\\\";\\nimport \\\"./ILosslessReporting.sol\\\";\\nimport \\\"./ILosslessController.sol\\\";\\n\\ninterface ILssGovernance {\\n    function LSS_TEAM_INDEX() external view returns(uint256);\\n    function TOKEN_OWNER_INDEX() external view returns(uint256);\\n    function COMMITEE_INDEX() external view returns(uint256);\\n    function committeeMembersCount() external view returns(uint256);\\n    function walletDisputePeriod() external view returns(uint256);\\n    function losslessStaking() external view returns (ILssStaking);\\n    function losslessReporting() external view returns (ILssReporting);\\n    function losslessController() external view returns (ILssController);\\n    function isCommitteeMember(address _account) external view returns(bool);\\n    function getIsVoted(uint256 _reportId, uint256 _voterIndex) external view returns(bool);\\n    function getVote(uint256 _reportId, uint256 _voterIndex) external view returns(bool);\\n    function isReportSolved(uint256 _reportId) external view returns(bool);\\n    function reportResolution(uint256 _reportId) external view returns(bool);\\n    function getAmountReported(uint256 _reportId) external view returns(uint256);\\n    \\n    function setDisputePeriod(uint256 _timeFrame) external;\\n    function addCommitteeMembers(address[] memory _members) external;\\n    function removeCommitteeMembers(address[] memory _members) external;\\n    function losslessVote(uint256 _reportId, bool _vote) external;\\n    function tokenOwnersVote(uint256 _reportId, bool _vote) external;\\n    function committeeMemberVote(uint256 _reportId, bool _vote) external;\\n    function resolveReport(uint256 _reportId) external;\\n    function proposeWallet(uint256 _reportId, address wallet) external;\\n    function rejectWallet(uint256 _reportId) external;\\n    function retrieveFunds(uint256 _reportId) external;\\n    function retrieveCompensation() external;\\n    function claimCommitteeReward(uint256 _reportId) external;\\n    function setCompensationAmount(uint256 _amount) external;\\n    function losslessClaim(uint256 _reportId) external;\\n    function setRevshareAdmin(address _address) external;\\n    function setRevsharePercentage(uint256 _amount) external;\\n    function revshareClaim(uint256 _reportId) external;\\n\\n    event NewCommitteeMembers(address[] _members);\\n    event CommitteeMembersRemoval(address[] _members);\\n    event LosslessTeamPositiveVote(uint256 indexed _reportId);\\n    event LosslessTeamNegativeVote(uint256 indexed _reportId);\\n    event TokenOwnersPositiveVote(uint256 indexed _reportId);\\n    event TokenOwnersNegativeVote(uint256 indexed _reportId);\\n    event CommitteeMemberPositiveVote(uint256 indexed _reportId, address indexed _member);\\n    event CommitteeMemberNegativeVote(uint256 indexed _reportId, address indexed _member);\\n    event ReportResolve(uint256 indexed _reportId, bool indexed _resolution);\\n    event WalletProposal(uint256 indexed _reportId, address indexed _wallet);\\n    event CommitteeMemberClaim(uint256 indexed _reportId, address indexed _member, uint256 indexed _amount);\\n    event CommitteeMajorityReach(uint256 indexed _reportId, bool indexed _result);\\n    event NewDisputePeriod(uint256 indexed _newPeriod);\\n    event WalletRejection(uint256 indexed _reportId);\\n    event FundsRetrieval(uint256 indexed _reportId, uint256 indexed _amount);\\n    event CompensationRetrieval(address indexed _wallet, uint256 indexed _amount);\\n    event LosslessClaim(ILERC20 indexed _token, uint256 indexed _reportID, uint256 indexed _amount);\\n    event NewCompensationPercentage(uint256 indexed _compensationPercentage);\\n    event NewRevshareAdmin(address indexed _revshareAdmin);\\n    event NewRevsharePercentage(uint256 indexed _revsharePercentage);\\n    event RevshareClaim(ILERC20 indexed _token, uint256 indexed _reportID, uint256 indexed _amount);\\n}\\n\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n        __ERC165_init_unchained();\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/IProtectionStrategy.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\ninterface ProtectionStrategy {\\n    function isTransferAllowed(address token, address sender, address recipient, uint256 amount) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"_result\",\"type\":\"bool\"}],\"name\":\"CommitteeMajorityReach\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"CommitteeMemberClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"CommitteeMemberNegativeVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"CommitteeMemberPositiveVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"_members\",\"type\":\"address[]\"}],\"name\":\"CommitteeMembersRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"CompensationRetrieval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"FundsRetrieval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reportID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"LosslessClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"LosslessTeamNegativeVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"LosslessTeamPositiveVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"_members\",\"type\":\"address[]\"}],\"name\":\"NewCommitteeMembers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_compensationPercentage\",\"type\":\"uint256\"}],\"name\":\"NewCompensationPercentage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_newPeriod\",\"type\":\"uint256\"}],\"name\":\"NewDisputePeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_revshareAdmin\",\"type\":\"address\"}],\"name\":\"NewRevshareAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_revsharePercentage\",\"type\":\"uint256\"}],\"name\":\"NewRevsharePercentage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"_resolution\",\"type\":\"bool\"}],\"name\":\"ReportResolve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reportID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"RevshareClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"TokenOwnersNegativeVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"TokenOwnersPositiveVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"WalletProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"WalletRejection\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"COMMITEE_INDEX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COMMITTEE_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HUNDRED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LSS_TEAM_INDEX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_OWNER_INDEX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_members\",\"type\":\"address[]\"}],\"name\":\"addCommitteeMembers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"claimCommitteeReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_vote\",\"type\":\"bool\"}],\"name\":\"committeeMemberVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"committeeMembersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compensationPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"getAmountReported\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_voterIndex\",\"type\":\"uint256\"}],\"name\":\"getIsVoted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_voterIndex\",\"type\":\"uint256\"}],\"name\":\"getVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILssReporting\",\"name\":\"_losslessReporting\",\"type\":\"address\"},{\"internalType\":\"contract ILssController\",\"name\":\"_losslessController\",\"type\":\"address\"},{\"internalType\":\"contract ILssStaking\",\"name\":\"_losslessStaking\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_walletDisputePeriod\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isCommitteeMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"isReportActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"isReportSolved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"losslessClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"losslessController\",\"outputs\":[{\"internalType\":\"contract ILssController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"losslessReporting\",\"outputs\":[{\"internalType\":\"contract ILssReporting\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"losslessStaking\",\"outputs\":[{\"internalType\":\"contract ILssStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_vote\",\"type\":\"bool\"}],\"name\":\"losslessVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"proposeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposedWalletOnReport\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"proposal\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"committeeDisagree\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"retrievalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"losslessVote\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"losslessVoted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"tokenOwnersVote\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"tokenOwnersVoted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"walletAccepted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"rejectWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_members\",\"type\":\"address[]\"}],\"name\":\"removeCommitteeMembers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"reportResolution\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reportVotes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"resolved\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"resolution\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"losslessPayed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountReported\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"resolveReport\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retrieveCompensation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"retrieveFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revshareAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"revshareClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"revsharePayed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revsharePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setCompensationAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeFrame\",\"type\":\"uint256\"}],\"name\":\"setDisputePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setRevshareAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setRevsharePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_vote\",\"type\":\"bool\"}],\"name\":\"tokenOwnersVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletDisputePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LosslessGovernance", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}