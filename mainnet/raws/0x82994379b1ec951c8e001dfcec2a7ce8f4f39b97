{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"BaseRegistrar.sol\":{\"content\":\"pragma solidity \\u003e=0.4.24;\\n\\nimport \\\"./ENS.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract BaseRegistrar is IERC721, Ownable {\\n    uint constant public GRACE_PERIOD = 90 days;\\n\\n    event ControllerAdded(address indexed controller);\\n    event ControllerRemoved(address indexed controller);\\n    event NameMigrated(uint256 indexed id, address indexed owner, uint expires);\\n    event NameRegistered(uint256 indexed id, address indexed owner, uint expires);\\n    event NameRenewed(uint256 indexed id, uint expires);\\n\\n    // The ENS registry\\n    ENS public ens;\\n\\n    // The namehash of the TLD this registrar owns (eg, .eth)\\n    bytes32 public baseNode;\\n\\n    // A map of addresses that are authorised to register and renew names.\\n    mapping(address=\\u003ebool) public controllers;\\n\\n    // Authorises a controller, who can register and renew domains.\\n    function addController(address controller) external;\\n\\n    // Revoke controller permission for an address.\\n    function removeController(address controller) external;\\n\\n    // Set the resolver for the TLD this registrar manages.\\n    function setResolver(address resolver) external;\\n\\n    // Returns the expiration timestamp of the specified label hash.\\n    function nameExpires(uint256 id) external view returns(uint);\\n\\n    // Returns true iff the specified name is available for registration.\\n    function available(uint256 id) public view returns(bool);\\n\\n    /**\\n     * @dev Register a name.\\n     */\\n    function register(uint256 id, address owner, uint duration) external returns(uint);\\n\\n    function renew(uint256 id, uint duration) external returns(uint);\\n\\n    /**\\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\\n     */\\n    function reclaim(uint256 id, address owner) external;\\n}\"},\"ENS.sol\":{\"content\":\"pragma solidity \\u003e=0.4.24;\\n\\ninterface ENS {\\n\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);\\n    function setResolver(bytes32 node, address resolver) external;\\n    function setOwner(bytes32 node, address owner) external;\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n    function setApprovalForAll(address operator, bool approved) external;\\n    function owner(bytes32 node) external view returns (address);\\n    function resolver(bytes32 node) external view returns (address);\\n    function ttl(bytes32 node) external view returns (uint64);\\n    function recordExists(bytes32 node) external view returns (bool);\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"},\"ETHRegistrarController.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./PriceOracle.sol\\\";\\nimport \\\"./BaseRegistrar.sol\\\";\\nimport \\\"./StringUtils.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Resolver.sol\\\";\\n\\n/**\\n * @dev A registrar controller for registering and renewing names at fixed cost.\\n */\\ncontract ETHRegistrarController is Ownable {\\n    using StringUtils for *;\\n\\n    uint constant public MIN_REGISTRATION_DURATION = 28 days;\\n\\n    bytes4 constant private INTERFACE_META_ID = bytes4(keccak256(\\\"supportsInterface(bytes4)\\\"));\\n    bytes4 constant private COMMITMENT_CONTROLLER_ID = bytes4(\\n        keccak256(\\\"rentPrice(string,uint256)\\\") ^\\n        keccak256(\\\"available(string)\\\") ^\\n        keccak256(\\\"makeCommitment(string,address,bytes32)\\\") ^\\n        keccak256(\\\"commit(bytes32)\\\") ^\\n        keccak256(\\\"register(string,address,uint256,bytes32)\\\") ^\\n        keccak256(\\\"renew(string,uint256)\\\")\\n    );\\n\\n    bytes4 constant private COMMITMENT_WITH_CONFIG_CONTROLLER_ID = bytes4(\\n        keccak256(\\\"registerWithConfig(string,address,uint256,bytes32,address,address)\\\") ^\\n        keccak256(\\\"makeCommitmentWithConfig(string,address,bytes32,address,address)\\\")\\n    );\\n\\n    BaseRegistrar base;\\n    PriceOracle prices;\\n    uint public minCommitmentAge;\\n    uint public maxCommitmentAge;\\n\\n    mapping(bytes32=\\u003euint) public commitments;\\n\\n    event NameRegistered(string name, bytes32 indexed label, address indexed owner, uint cost, uint expires);\\n    event NameRenewed(string name, bytes32 indexed label, uint cost, uint expires);\\n    event NewPriceOracle(address indexed oracle);\\n\\n    constructor(BaseRegistrar _base, PriceOracle _prices, uint _minCommitmentAge, uint _maxCommitmentAge) public {\\n        require(_maxCommitmentAge \\u003e _minCommitmentAge);\\n\\n        base = _base;\\n        prices = _prices;\\n        minCommitmentAge = _minCommitmentAge;\\n        maxCommitmentAge = _maxCommitmentAge;\\n    }\\n\\n    function rentPrice(string memory name, uint duration) view public returns(uint) {\\n        bytes32 hash = keccak256(bytes(name));\\n        return prices.price(name, base.nameExpires(uint256(hash)), duration);\\n    }\\n\\n    function valid(string memory name) public pure returns(bool) {\\n        return name.strlen() \\u003e= 3;\\n    }\\n\\n    function available(string memory name) public view returns(bool) {\\n        bytes32 label = keccak256(bytes(name));\\n        return valid(name) \\u0026\\u0026 base.available(uint256(label));\\n    }\\n\\n    function makeCommitment(string memory name, address owner, bytes32 secret) pure public returns(bytes32) {\\n        return makeCommitmentWithConfig(name, owner, secret, address(0), address(0));\\n    }\\n\\n    function makeCommitmentWithConfig(string memory name, address owner, bytes32 secret, address resolver, address addr) pure public returns(bytes32) {\\n        bytes32 label = keccak256(bytes(name));\\n        if (resolver == address(0) \\u0026\\u0026 addr == address(0)) {\\n            return keccak256(abi.encodePacked(label, owner, secret));\\n        }\\n        require(resolver != address(0));\\n        return keccak256(abi.encodePacked(label, owner, resolver, addr, secret));\\n    }\\n\\n    function commit(bytes32 commitment) public {\\n        require(commitments[commitment] + maxCommitmentAge \\u003c now);\\n        commitments[commitment] = now;\\n    }\\n\\n    function register(string calldata name, address owner, uint duration, bytes32 secret) external payable {\\n      registerWithConfig(name, owner, duration, secret, address(0), address(0));\\n    }\\n\\n    function registerWithConfig(string memory name, address owner, uint duration, bytes32 secret, address resolver, address addr) public payable {\\n        bytes32 commitment = makeCommitmentWithConfig(name, owner, secret, resolver, addr);\\n        uint cost = _consumeCommitment(name, duration, commitment);\\n\\n        bytes32 label = keccak256(bytes(name));\\n        uint256 tokenId = uint256(label);\\n\\n        uint expires;\\n        if(resolver != address(0)) {\\n            // Set this contract as the (temporary) owner, giving it\\n            // permission to set up the resolver.\\n            expires = base.register(tokenId, address(this), duration);\\n\\n            // The nodehash of this label\\n            bytes32 nodehash = keccak256(abi.encodePacked(base.baseNode(), label));\\n\\n            // Set the resolver\\n            base.ens().setResolver(nodehash, resolver);\\n\\n            // Configure the resolver\\n            if (addr != address(0)) {\\n                Resolver(resolver).setAddr(nodehash, addr);\\n            }\\n\\n            // Now transfer full ownership to the expeceted owner\\n            base.reclaim(tokenId, owner);\\n            base.transferFrom(address(this), owner, tokenId);\\n        } else {\\n            require(addr == address(0));\\n            expires = base.register(tokenId, owner, duration);\\n        }\\n\\n        emit NameRegistered(name, label, owner, cost, expires);\\n\\n        // Refund any extra payment\\n        if(msg.value \\u003e cost) {\\n            msg.sender.transfer(msg.value - cost);\\n        }\\n    }\\n\\n    function renew(string calldata name, uint duration) external payable {\\n        uint cost = rentPrice(name, duration);\\n        require(msg.value \\u003e= cost);\\n\\n        bytes32 label = keccak256(bytes(name));\\n        uint expires = base.renew(uint256(label), duration);\\n\\n        if(msg.value \\u003e cost) {\\n            msg.sender.transfer(msg.value - cost);\\n        }\\n\\n        emit NameRenewed(name, label, cost, expires);\\n    }\\n\\n    function setPriceOracle(PriceOracle _prices) public onlyOwner {\\n        prices = _prices;\\n        emit NewPriceOracle(address(prices));\\n    }\\n\\n    function setCommitmentAges(uint _minCommitmentAge, uint _maxCommitmentAge) public onlyOwner {\\n        minCommitmentAge = _minCommitmentAge;\\n        maxCommitmentAge = _maxCommitmentAge;\\n    }\\n\\n    function withdraw() public onlyOwner {\\n        msg.sender.transfer(address(this).balance);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\\n        return interfaceID == INTERFACE_META_ID ||\\n               interfaceID == COMMITMENT_CONTROLLER_ID ||\\n               interfaceID == COMMITMENT_WITH_CONFIG_CONTROLLER_ID;\\n    }\\n\\n    function _consumeCommitment(string memory name, uint duration, bytes32 commitment) internal returns (uint256) {\\n        // Require a valid commitment\\n        require(commitments[commitment] + minCommitmentAge \\u003c= now);\\n\\n        // If the commitment is too old, or the name is registered, stop\\n        require(commitments[commitment] + maxCommitmentAge \\u003e now);\\n        require(available(name));\\n\\n        delete(commitments[commitment]);\\n\\n        uint cost = rentPrice(name, duration);\\n        require(duration \\u003e= MIN_REGISTRATION_DURATION);\\n        require(msg.value \\u003e= cost);\\n\\n        return cost;\\n    }\\n}\"},\"IERC165.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @title IERC165\\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\\n */\\ninterface IERC165 {\\n    /**\\n     * @notice Query if a contract implements an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @dev Interface identification is specified in ERC-165. This function\\n     * uses less than 30,000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\"},\"IERC721.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic interface\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract IERC721 is IERC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function balanceOf(address owner) public view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) public view returns (address owner);\\n\\n    function approve(address to, uint256 tokenId) public;\\n    function getApproved(uint256 tokenId) public view returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) public;\\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public;\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"PriceOracle.sol\":{\"content\":\"pragma solidity \\u003e=0.4.24;\\n\\ninterface PriceOracle {\\n    /**\\n     * @dev Returns the price to register or renew a name.\\n     * @param name The name being registered or renewed.\\n     * @param expires When the name presently expires (0 if this is a new registration).\\n     * @param duration How long the name is being registered or extended for, in seconds.\\n     * @return The price of this renewal or registration, in wei.\\n     */\\n    function price(string calldata name, uint expires, uint duration) external view returns(uint);\\n}\"},\"Resolver.sol\":{\"content\":\"pragma solidity \\u003e=0.4.25;\\n\\n/**\\n * A generic resolver interface which includes all the functions including the ones deprecated\\n */\\ninterface Resolver{\\n    event AddrChanged(bytes32 indexed node, address a);\\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\\n    event NameChanged(bytes32 indexed node, string name);\\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\\n    /* Deprecated events */\\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\\n\\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);\\n    function addr(bytes32 node) external view returns (address);\\n    function addr(bytes32 node, uint coinType) external view returns(bytes memory);\\n    function contenthash(bytes32 node) external view returns (bytes memory);\\n    function dnsrr(bytes32 node) external view returns (bytes memory);\\n    function name(bytes32 node) external view returns (string memory);\\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\\n    function text(bytes32 node, string calldata key) external view returns (string memory);\\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\\n\\n    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;\\n    function setAddr(bytes32 node, address addr) external;\\n    function setAddr(bytes32 node, uint coinType, bytes calldata a) external;\\n    function setContenthash(bytes32 node, bytes calldata hash) external;\\n    function setDnsrr(bytes32 node, bytes calldata data) external;\\n    function setName(bytes32 node, string calldata _name) external;\\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\\n    function setText(bytes32 node, string calldata key, string calldata value) external;\\n    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external;\\n\\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool);\\n\\n    /* Deprecated functions */\\n    function content(bytes32 node) external view returns (bytes32);\\n    function multihash(bytes32 node) external view returns (bytes memory);\\n    function setContent(bytes32 node, bytes32 hash) external;\\n    function setMultihash(bytes32 node, bytes calldata hash) external;\\n}\\n\"},\"StringUtils.sol\":{\"content\":\"pragma solidity \\u003e=0.4.24;\\n\\nlibrary StringUtils {\\n    /**\\n     * @dev Returns the length of a given string\\n     *\\n     * @param s The string to measure the length of\\n     * @return The length of the input string\\n     */\\n    function strlen(string memory s) internal pure returns (uint) {\\n        uint len;\\n        uint i = 0;\\n        uint bytelength = bytes(s).length;\\n        for(len = 0; i \\u003c bytelength; len++) {\\n            byte b = bytes(s)[i];\\n            if(b \\u003c 0x80) {\\n                i += 1;\\n            } else if (b \\u003c 0xE0) {\\n                i += 2;\\n            } else if (b \\u003c 0xF0) {\\n                i += 3;\\n            } else if (b \\u003c 0xF8) {\\n                i += 4;\\n            } else if (b \\u003c 0xFC) {\\n                i += 5;\\n            } else {\\n                i += 6;\\n            }\\n        }\\n        return len;\\n    }\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract BaseRegistrar\",\"name\":\"_base\",\"type\":\"address\"},{\"internalType\":\"contract PriceOracle\",\"name\":\"_prices\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minCommitmentAge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxCommitmentAge\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"}],\"name\":\"NameRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"}],\"name\":\"NameRenewed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"NewPriceOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_REGISTRATION_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"available\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"name\":\"commit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"commitments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"makeCommitment\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"makeCommitmentWithConfig\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxCommitmentAge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minCommitmentAge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"}],\"name\":\"register\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"registerWithConfig\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"renew\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"rentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minCommitmentAge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxCommitmentAge\",\"type\":\"uint256\"}],\"name\":\"setCommitmentAges\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract PriceOracle\",\"name\":\"_prices\",\"type\":\"address\"}],\"name\":\"setPriceOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"valid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ETHRegistrarController", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000a271897710a2b22f7a5be5feacb00811d960e0b8000000000000000000000000d75b51fe18d13e80d31a58ac47fbf791585593e100000000000000000000000000000000000000000000000000000002540be40000000000000000000000000000000000000000000000000000038d7ea4c68000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://1a9197a485dd3432a794e6701ca5cab231795a40b42de4ac374be53d67ee8e2e"}]}