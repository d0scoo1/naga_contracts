{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: contracts/generic/model/ILazyInitCapableElement.sol\r\n\r\n\r\npragma solidity >=0.7.0;\r\n\r\n\r\ninterface ILazyInitCapableElement is IERC165 {\r\n\r\n    function lazyInit(bytes calldata lazyInitData) external returns(bytes memory initResponse);\r\n    function initializer() external view returns(address);\r\n\r\n    event Host(address indexed from, address indexed to);\r\n\r\n    function host() external view returns(address);\r\n    function setHost(address newValue) external returns(address oldValue);\r\n\r\n    function subjectIsAuthorizedFor(address subject, address location, bytes4 selector, bytes calldata payload, uint256 value) external view returns(bool);\r\n}\r\n// File: contracts/lib/Creator.sol\r\n\r\n\r\npragma solidity >=0.7.0;\r\n\r\nlibrary Creator {\r\n\r\n    event Source(address indexed sender, address indexed source);\r\n    event Created(address indexed sender, address indexed source, address indexed destination);\r\n\r\n    function create(bytes memory sourceAddressOrBytecode) external returns(address destination, address source) {\r\n        if(sourceAddressOrBytecode.length == 32) {\r\n            source = abi.decode(sourceAddressOrBytecode, (address));\r\n        } else if(sourceAddressOrBytecode.length == 20) {\r\n            assembly {\r\n                source := div(mload(add(sourceAddressOrBytecode, 32)), 0x1000000000000000000000000)\r\n            }\r\n        } else {\r\n            assembly {\r\n                source := create(0, add(sourceAddressOrBytecode, 32), mload(sourceAddressOrBytecode))\r\n            }\r\n            emit Source(msg.sender, source);\r\n        }\r\n        require(source != address(0), \"source\");\r\n        uint256 codeSize;\r\n        assembly {\r\n            codeSize := extcodesize(source)\r\n        }\r\n        require(codeSize > 0, \"source\");\r\n        destination = address(new GeneralPurposeProxy{value : msg.value}(source));\r\n        emit Created(msg.sender, source, destination);\r\n    }\r\n}\r\n\r\ncontract GeneralPurposeProxy {\r\n\r\n    constructor(address source) payable {\r\n        assembly {\r\n            sstore(0xf7e3126f87228afb82c9b18537eed25aaeb8171a78814781c26ed2cfeff27e69, source)\r\n        }\r\n    }\r\n\r\n    fallback() external payable {\r\n        assembly {\r\n            let _singleton := sload(0xf7e3126f87228afb82c9b18537eed25aaeb8171a78814781c26ed2cfeff27e69)\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch success\r\n                case 0 {revert(0, returndatasize())}\r\n                default { return(0, returndatasize())}\r\n        }\r\n    }\r\n}\r\n// File: contracts/lib/Initializer.sol\r\n\r\n\r\npragma solidity >=0.8.0;\r\n\r\n\r\n\r\nlibrary Initializer {\r\n\r\n    event Created(address indexed destination, bytes lazyInitResponse);\r\n\r\n    function create(bytes memory sourceAddressOrBytecode, bytes memory lazyInitData) external returns(address destination, bytes memory lazyInitResponse, address source) {\r\n        (destination, source) = Creator.create(sourceAddressOrBytecode);\r\n        lazyInitResponse = ILazyInitCapableElement(destination).lazyInit(lazyInitData);\r\n        require(ILazyInitCapableElement(destination).initializer() == address(this));\r\n        emit Created(destination, lazyInitResponse);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"lazyInitResponse\",\"type\":\"bytes\"}],\"name\":\"Created\",\"type\":\"event\"}]", "ContractName": "Initializer", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "Creator:c59f30f2aa256982f3b147d88bfbb167ff0950de", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f61a454fe832174297712230e8146b1ca7371e1cbd1a0232dab3fbfea10def21"}]}