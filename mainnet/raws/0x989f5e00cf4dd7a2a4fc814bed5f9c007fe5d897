{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.13;\r\n\r\ninterface ERC165 {\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\ninterface ERC1155 is ERC165 {\r\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\r\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    event URI(string _value, uint256 indexed _id);\r\n    \r\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\r\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\r\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\r\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\ninterface ERC1155TokenReceiver is ERC165 {\r\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4);\r\n    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);       \r\n}\r\ninterface ERC1155Metadata_URI is ERC165 {\r\n    function uri(uint256 _id) external view returns (string memory);\r\n}\r\n\r\nabstract contract FAME_WHITELIST is ERC165, ERC1155, ERC1155Metadata_URI {\r\n    function isWhitelist(address _account) public view virtual returns (uint256) {}\r\n}\r\n\r\ncontract FAME_FRONTROW_2022 is FAME_WHITELIST {\r\n    address payable public factory;\r\n    \r\n    string public constant name = \"FAME FRONTROW 2022\";\r\n    address public constant owner = 0x4a3E0107381252519ee681e58616810508656a14;\r\n    uint256 public volume = 0;\r\n    uint256 public maxVolume = 10_000;\r\n    mapping(uint256 => address) private owners;\r\n    mapping(uint256 => bytes32) private types;\r\n    mapping(address => uint256) private totalBalances;\r\n    mapping(address => mapping(address => bool)) private operatorApprovals;\r\n    string private baseURI = \"https://xfame.app/metadata/frontrow-2022/\";\r\n    \r\n    modifier onlyFAME() {\r\n        require(msg.sender == owner, \"FAME_FRONTROW_2022: caller is not approved\");\r\n        _;\r\n    }\r\n    modifier onlyFactory() {\r\n        require(msg.sender == factory, \"FAME_FRONTROW_2022: caller is not approved\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        factory = payable(address(new FAME_FACTORY_FRONTROW_2022(this)));\r\n        _mint(msg.sender, owner, '');\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\r\n        return interfaceId == type(ERC1155).interfaceId || interfaceId == type(ERC1155Metadata_URI).interfaceId || interfaceId == type(ERC165).interfaceId;\r\n    }\r\n    function uri(uint256 _id) external view override returns (string memory) {\r\n        require(owners[_id] != address(0), \"FAME_FRONTROW_2022: uri query for unregistered token\");\r\n\r\n        return string(abi.encodePacked(baseURI, _toString(_id)));\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data) public override {\r\n        require(_from == msg.sender || isApprovedForAll(_from, msg.sender), \"FAME_FRONTROW_2022: transfer caller is not owner nor approved\");\r\n        require(_to != address(0), \"FAME_FRONTROW_2022: transfer to the zero address\");\r\n        require(_from == ownerOf(_id), \"FAME_FRONTROW_2022: insufficient balance for transfer\");\r\n        require(_amount == 1, \"FAME_FRONTROW_2022: amount is not 1\");\r\n\r\n        owners[_id] = _to;\r\n        totalBalances[_from]--;\r\n        totalBalances[_to]++;\r\n        emit TransferSingle(msg.sender, _from, _to, _id, 1);\r\n\r\n        _doSafeTransferAcceptanceCheck(msg.sender, _from, _to, _id, 1, _data);\r\n    }\r\n    function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data) external override {\r\n        require(_from == msg.sender || isApprovedForAll(_from, msg.sender), \"FAME_FRONTROW_2022: transfer caller is not owner nor approved\");\r\n        require(_ids.length == _amounts.length, \"FAME_FRONTROW_2022: ids and amounts length mismatch\");\r\n        require(_to != address(0), \"FAME_FRONTROW_2022: transfer to the zero address\");\r\n\r\n        for (uint256 i = 0; i < _ids.length; i++) {\r\n            require(_from == ownerOf(_ids[i]), \"FAME_FRONTROW_2022: insufficient balance for transfer\");\r\n            require(_amounts[i] == 1, \"FAME_FRONTROW_2022: amount is not 1\");\r\n\r\n            owners[_ids[i]] = _to;\r\n        }\r\n        totalBalances[_from] -= _ids.length;\r\n        totalBalances[_to] += _ids.length;\r\n        emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(msg.sender, _from, _to, _ids, _amounts, _data);\r\n    }\r\n    function balanceOf(address _account, uint256 _id) public view override returns (uint256) {\r\n        require(_account != address(0), \"FAME_FRONTROW_2022: balance query for the zero address\");\r\n\r\n        return owners[_id] == _account ? 1 : 0;\r\n    }\r\n    function balanceOfBatch(address[] memory _accounts, uint256[] memory _ids) external view override returns (uint256[] memory) {\r\n        require(_accounts.length == _ids.length, \"FAME_FRONTROW_2022: accounts and ids length mismatch\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](_accounts.length);\r\n        for (uint256 i = 0; i < _accounts.length; i++) {\r\n            batchBalances[i] = balanceOf(_accounts[i], _ids[i]);\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n    function setApprovalForAll(address _operator, bool _approved) external override {\r\n        require(msg.sender != _operator, \"FAME_FRONTROW_2022: setting approval status for self\");\r\n        \r\n        operatorApprovals[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n    function isApprovedForAll(address _account, address _operator) public view override returns (bool) {\r\n        return operatorApprovals[_account][_operator];\r\n    }\r\n    \r\n    function ownerOf(uint256 _id) public view returns (address) {\r\n        address tokenOwner = owners[_id];\r\n        require(tokenOwner != address(0), \"FAME_FRONTROW_2022: owner query for unregistered token\");\r\n\r\n        return tokenOwner;\r\n    }\r\n    function typeOf(uint256 _id) external view returns (bytes32) {\r\n        require(owners[_id] != address(0), \"FAME_FRONTROW_2022: owner query for unregistered token\");\r\n\r\n        return types[_id];\r\n    }\r\n    function isWhitelist(address _account) public view override returns (uint256) {\r\n        return totalBalances[_account];\r\n    }\r\n\r\n    function setFactory(address _factory) external onlyFAME {\r\n        factory = payable(_factory);\r\n    }\r\n    function setURI(string memory _uri) external onlyFAME {\r\n        baseURI = _uri;\r\n    }\r\n    function setMaxVolume(uint256 _maxVolume) external onlyFAME {\r\n        require(_maxVolume > volume, \"FAME_FRONTROW_2022: max volume is too small\");\r\n\r\n        maxVolume = _maxVolume;\r\n    }\r\n    function setType(uint256 _id, bytes32 _type) public onlyFAME {\r\n        require(owners[_id] != address(0), \"FAME_FRONTROW_2022: query for unregistered token\");\r\n\r\n        types[_id] = _type;\r\n    }\r\n    function setTypeBatch(uint256[] memory _ids, bytes32[] memory _types) external onlyFAME {\r\n        require(_ids.length == _types.length, \"FAME_FRONTROW_2022: ids and types length mismatch\");\r\n\r\n        for (uint256 i = 0; i < _ids.length; i++) {\r\n            setType(_ids[i], _types[i]);\r\n        }\r\n    }\r\n\r\n    function mint(address _operator, address _to, uint256 _amount, bytes memory _data) external onlyFactory() {\r\n        if (_amount == 1) {\r\n            _mint(_operator, _to, _data);\r\n        } else {\r\n            _mintBatch(_operator, _to, _amount, _data);\r\n        }\r\n    }\r\n    function _mint(address _operator, address _to, bytes memory _data) private {\r\n        require(_operator != address(0), \"FAME_FRONTROW_2022: operator is zero address\");\r\n        require(_to != address(0), \"FAME_FRONTROW_2022: transfer to the zero address\");\r\n        require(volume < maxVolume, \"FAME_FRONTROW_2022: cannot mint more\");\r\n\r\n        uint256 id = volume;\r\n        owners[id] = _to;\r\n        volume++;\r\n        totalBalances[_to]++;\r\n        emit TransferSingle(msg.sender, address(0), _to, id, 1);\r\n\r\n        _doSafeTransferAcceptanceCheck(msg.sender, address(0), _to, id, 1, _data);\r\n    }\r\n    function _mintBatch(address _operator, address _to, uint256 _amount, bytes memory _data) private {\r\n        require(_operator != address(0), \"FAME_FRONTROW_2022: operator is zero address\");\r\n        require(_to != address(0), \"FAME_FRONTROW_2022: transfer to the zero address\");\r\n        require(volume + _amount <= maxVolume, \"FAME_FRONTROW_2022: cannot mint more\");\r\n\r\n        uint256[] memory ids = new uint256[](_amount);\r\n        uint256[] memory amounts = new uint256[](_amount);\r\n        for (uint256 i = 0; i < _amount; i++) {\r\n            ids[i] = volume;\r\n            amounts[i] = 1;\r\n            owners[volume] = _to;\r\n            volume++;\r\n        }\r\n        totalBalances[_to] += _amount;\r\n        emit TransferBatch(_operator, address(0), _to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(_operator, address(0), _to, ids, amounts, _data);\r\n    }\r\n\r\n    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 id, uint256 amount, bytes memory _data) private {\r\n        if (_to.code.length > 0) {\r\n            try ERC1155TokenReceiver(_to).onERC1155Received(_operator, _from, id, amount, _data) returns (bytes4 response) {\r\n                if (response != ERC1155TokenReceiver.onERC1155Received.selector) {\r\n                    revert(\"FAME_FRONTROW_2022: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"FAME_FRONTROW_2022: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data) private {\r\n        if (_to.code.length > 0) {\r\n            try ERC1155TokenReceiver(_to).onERC1155BatchReceived(_operator, _from, _ids, _amounts, _data) returns (bytes4 response) {\r\n                if (response != ERC1155TokenReceiver.onERC1155BatchReceived.selector) {\r\n                    revert(\"FAME_FRONTROW_2022: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"FAME_FRONTROW_2022: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n    function _toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\ncontract FAME_FACTORY_FRONTROW_2022 {\r\n    address payable private constant FAME_UNIVERSE = payable(0x4a3E0107381252519ee681e58616810508656a14);\r\n    FAME_FRONTROW_2022 private frontrow;\r\n\r\n    mapping(address => uint256) public whitelist;\r\n    mapping(address => uint256) private mintedAmounts;\r\n    uint256 private constant MaxMintableAmount = 3;\r\n\r\n    struct Sale {\r\n        uint256 open;\r\n        uint256 limit;\r\n        uint256 price;\r\n        uint256 minWhitelistLevel;\r\n    }\r\n    mapping(uint256 => Sale) public sales;\r\n\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status = 1;\r\n\r\n    event Mint(uint256 indexed _id, address indexed _operator);\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"FAME_FACTORY_FRONTROW_2022: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n    modifier onlyFAME() {\r\n        require(msg.sender == FAME_UNIVERSE, \"FAME_FACTORY_FRONTROW_2022: caller is not approved\");\r\n        _;\r\n    }\r\n\r\n    constructor(FAME_FRONTROW_2022 _frontrow) {\r\n        frontrow = _frontrow;\r\n\r\n        // Pre Sales\r\n        sales[0] = Sale({\r\n            open: 1651150800, // April 28, 2022 13:00:00 GMT\r\n            limit: 400, // #0 ~ #399\r\n            price: 0.08 ether,\r\n            minWhitelistLevel: 1 // Whitelist only\r\n        });\r\n    }\r\n\r\n    function mintableAmountOf(address _owner) public view returns (uint256) {\r\n        return MaxMintableAmount - mintedAmounts[_owner];\r\n    }\r\n\r\n    function mint(uint256 _salesId, uint256 _amount) external payable nonReentrant {\r\n        Sale memory sale = sales[_salesId];\r\n        uint256 volume = frontrow.volume();\r\n        require(_amount > 0 && _amount <= mintableAmountOf(msg.sender), \"FAME_FACTORY_FRONTROW_2022: invalid minting amount\");\r\n        require(msg.value == _amount * sale.price, \"FAME_FACTORY_FRONTROW_2022: wrong value\");\r\n        require(block.timestamp >= sale.open, \"FAME_FACTORY_FRONTROW_2022: market not open\");\r\n        require(volume + _amount <= sale.limit, \"FAME_FACTORY_FRONTROW_2022: market closed\");\r\n        require(whitelist[msg.sender] >= sale.minWhitelistLevel, \"FAME_FACTORY_FRONTROW_2022: only available for whitelist members\");\r\n\r\n        frontrow.mint(msg.sender, msg.sender, _amount, '');\r\n        mintedAmounts[msg.sender] += _amount;\r\n        for (uint256 i = 0; i < _amount; i++) {\r\n            emit Mint(volume + i, msg.sender);\r\n        }\r\n    }\r\n    function privateInvitations(address[] memory _to) external onlyFAME {\r\n        for (uint256 i = 0; i < _to.length; i++) {\r\n            frontrow.mint(msg.sender, _to[i], 1, '');\r\n        }\r\n    }\r\n\r\n    function addWhitelist(address _account) public onlyFAME {\r\n        whitelist[_account] = 1;\r\n    }\r\n    function addWhitelistBatch(address[] memory _accounts) external onlyFAME {\r\n        for(uint256 i = 0; i < _accounts.length; i++) {\r\n            addWhitelist(_accounts[i]);\r\n        }\r\n    }\r\n    function setWhitelist(address _account, uint256 _value) public onlyFAME {\r\n        whitelist[_account] = _value;\r\n    }\r\n    function setWhitelistBatch(address[] memory _accounts, uint256 _value) external onlyFAME {\r\n        for(uint256 i = 0; i < _accounts.length; i++) {\r\n            setWhitelist(_accounts[i], _value);\r\n        }\r\n    }\r\n    function setSales(uint256 _salesId, uint256 _open, uint256 _limit, uint256 _price, uint256 _minWhitelistLevel) external onlyFAME {\r\n        sales[_salesId] = Sale({\r\n            open: _open,\r\n            limit: _limit,\r\n            price: _price,\r\n            minWhitelistLevel: _minWhitelistLevel\r\n        });\r\n    }\r\n    function withdraw() external {\r\n        FAME_UNIVERSE.transfer(address(this).balance);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isWhitelist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"setFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxVolume\",\"type\":\"uint256\"}],\"name\":\"setMaxVolume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_type\",\"type\":\"bytes32\"}],\"name\":\"setType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_types\",\"type\":\"bytes32[]\"}],\"name\":\"setTypeBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"typeOf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"volume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FAME_FRONTROW_2022", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7bd531e656c99eb12653fc73d9ee6a97206f55ec07350051cd1f9d6e18c71850"}]}