{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary MathLib {\r\n\r\n    uint8 constant Decimals = 8;\r\n    int256 constant PI = 314159265;\r\n\r\n    function sqrt(uint256 y) internal pure returns (uint256) {\r\n      uint256 result;\r\n      if (y > 3) {\r\n          result = y;\r\n          uint256 x = y / 2 + 1;\r\n          while (x < result) {\r\n              result = x;\r\n              x = (y / x + x) / 2;\r\n          }\r\n      } else if (y != 0) {\r\n          result = 1;\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    function abs(int256 x) internal pure returns (int256) {\r\n        return x < 0 ? x*(-1) : x;\r\n    }\r\n\r\n    /**\r\n     * Return the sine of an integer approximated angle as a signed 10^8\r\n     * integer.\r\n     *\r\n     * @param input A 14-bit angle. This divides the circle into 628318530(2*PI)\r\n     *               angle units, instead of the standard 360 degrees.\r\n     * @return The sine result as a number in the range -10^8 to 10^8.\r\n     */\r\n    function sin(int256 input) internal pure  returns(int256)\r\n    {\r\n        int256[20] memory arctan_table = [int256(78539816), 39269908, 19634954, 9817477, 4908739, 2454369, 1227185, 613592, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory sin_table = [int256(70710678), 38268343, 19509032, 9801714, 4906767, 2454123, 1227154, 613588, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory cos_table = [int256(70710678), 92387953, 98078528, 99518473, 99879546, 99969882, 99992470, 99998118, 99999529, 99999882, 99999971, 99999993, 99999998, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000];\r\n\r\n        while(input < 0) {\r\n            input = input + 2*PI;\r\n        }\r\n        int256 _angle = int(input % 628318530);\r\n\r\n        if (_angle > PI/2 && _angle <= PI) {\r\n            _angle = PI - _angle;\r\n        } else if(_angle > PI && _angle < PI*3/2) {\r\n            _angle = PI - _angle;\r\n        } else if(_angle >= PI*3/2 && _angle < 2*PI) {\r\n            _angle = _angle - 2*PI;\r\n        }\r\n\r\n        int256 x = 100000000;\r\n        int256 xnew = 100000000;\r\n        int256 y = 0;\r\n        int256 ynew = 0;\r\n        int256 ang = 0;\r\n\r\n        uint8 i = 0;\r\n        for (i = 0; i <= 19; i = i + 1)\r\n        {\r\n            if (ang < _angle)\r\n            {\r\n                xnew = (x*cos_table[i] - y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] + x*sin_table[i]) / 100000000;\r\n                ang = ang + arctan_table[i];\r\n            }\r\n\r\n            else if (ang > _angle)\r\n            {\r\n                xnew = (x*cos_table[i] + y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] - x*sin_table[i]) / 100000000;\r\n                ang = ang - arctan_table[i];\r\n            }\r\n\r\n            x = xnew;\r\n            y = ynew;\r\n        }\r\n        return(y);\r\n    }\r\n\r\n    /**\r\n     * Return the cos of an integer approximated angle as a signed 10^8\r\n     * integer.\r\n     *\r\n     * @param input A 10^8 radian angle. This divides the circle into 628318530(2*PI)\r\n     *               angle units, instead of the standard 360 degrees.\r\n     * @return The cos result as a number in the range -10^8 to 10^8.\r\n     */\r\n    function cos(int256 input) internal pure returns(int256)\r\n    {\r\n        bool neg = false;\r\n        int256[20] memory arctan_table = [int256(78539816), 39269908, 19634954, 9817477, 4908739, 2454369, 1227185, 613592, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory sin_table = [int256(70710678), 38268343, 19509032, 9801714, 4906767, 2454123, 1227154, 613588, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory cos_table = [int256(70710678), 92387953, 98078528, 99518473, 99879546, 99969882, 99992470, 99998118, 99999529, 99999882, 99999971, 99999993, 99999998, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000];\r\n\r\n        while(input < 0) {\r\n            input = input + 2*PI;\r\n        }\r\n        int256 _angle = int(input % 628318530);\r\n\r\n        if (_angle > PI/2 && _angle <= PI) {\r\n            _angle = PI - _angle;\r\n            neg = true;\r\n        } else if(_angle > PI && _angle < PI*3/2) {\r\n            _angle = _angle - PI;\r\n            neg = true;\r\n        } else if(_angle >= PI*3/2 && _angle < 2*PI) {\r\n            _angle = 2*PI - _angle;\r\n        }\r\n\r\n        int256 x = 100000000;\r\n        int256 xnew = 100000000;\r\n        int256 y = 0;\r\n        int256 ynew = 0;\r\n        int256 ang = 0;\r\n\r\n        uint8 i = 0;\r\n        for (i = 0; i <= 19; i = i + 1)\r\n        {\r\n            if (ang < _angle)\r\n            {\r\n                xnew = (x*cos_table[i] - y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] + x*sin_table[i]) / 100000000;\r\n                ang = ang + arctan_table[i];\r\n            }\r\n\r\n            else if (ang > _angle)\r\n            {\r\n                xnew = (x*cos_table[i] + y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] - x*sin_table[i]) / 100000000;\r\n                ang = ang - arctan_table[i];\r\n            }\r\n\r\n            x = xnew;\r\n            y = ynew;\r\n        }\r\n\r\n        if(neg)\r\n        {\r\n            return(-x);\r\n        }\r\n        else\r\n        {\r\n            return(x);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the tan of an integer approximated angle as a signed 10^8\r\n     * integer.\r\n     *\r\n     * @param input A 10^8 radian angle. This divides the circle into 628318530(2*PI)\r\n     *               angle units, instead of the standard 360 degrees.\r\n     * @return The tan result as a number in the range -10^8 to 10^8.\r\n     */\r\n    function tan(int256 input) internal pure returns(int256)\r\n    {\r\n        // int256 PI = 314159265;\r\n        int256[20] memory arctan_table = [int256(78539816), 39269908, 19634954, 9817477, 4908739, 2454369, 1227185, 613592, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory sin_table = [int256(70710678), 38268343, 19509032, 9801714, 4906767, 2454123, 1227154, 613588, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory cos_table = [int256(70710678), 92387953, 98078528, 99518473, 99879546, 99969882, 99992470, 99998118, 99999529, 99999882, 99999971, 99999993, 99999998, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000];\r\n\r\n        while(input < 0) {\r\n            input = input + 2*PI;\r\n        }\r\n        int256 _angle = int(input % 628318530);\r\n\r\n        if (_angle >= PI/2 && _angle <= PI*3/2) {\r\n            _angle = _angle - PI;\r\n        } else if (_angle > 3*PI/2) {\r\n            _angle = _angle - 3*PI/2;\r\n        }\r\n\r\n        int256 x = 100000000;\r\n        int256 xnew = 100000000;\r\n        int256 y = 0;\r\n        int256 ynew = 0;\r\n        int256 ang = 0;\r\n\r\n        uint8 i = 0;\r\n        for (i = 0; i <= 19; i = i + 1)\r\n        {\r\n            if (ang < _angle)\r\n            {\r\n                xnew = (x*cos_table[i] - y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] + x*sin_table[i]) / 100000000;\r\n                ang = ang + arctan_table[i];\r\n            }\r\n\r\n            else if (ang > _angle)\r\n            {\r\n                xnew = (x*cos_table[i] + y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] - x*sin_table[i]) / 100000000;\r\n                ang = ang - arctan_table[i];\r\n            }\r\n\r\n            x = xnew;\r\n            y = ynew;\r\n        }\r\n        //now divide y and x\r\n        int256 res; res = 0;\r\n        int256 digit;\r\n        int8 j;\r\n\r\n        j = 1;\r\n        while(j <= 8)\r\n        {\r\n            digit = y / x;\r\n            res = res + digit;\r\n            res = res * 10;\r\n            y = (y % x)*10;\r\n            j = j + 1;\r\n        }\r\n\r\n        return(res);\r\n    }\r\n\r\n    /**\r\n     * Return the arcsin of an integer approximated ratio as a signed 10^8\r\n     * integer.\r\n     *\r\n     * @param input A 10^8 ratio. This divides the (-1, 1) into (-10^8, 10^8)\r\n     *               angle units, instead of the standard 360 degrees.\r\n     * @return The arcsin result as a number in the range -10^8 to 10^8 .\r\n     */\r\n\r\n    function arcsin(int256 input) internal pure returns(int256)\r\n    {\r\n        int256[20] memory arctan_table = [int256(78539816), 39269908, 19634954, 9817477, 4908739, 2454369, 1227185, 613592, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory sin_table = [int256(70710678), 38268343, 19509032, 9801714, 4906767, 2454123, 1227154, 613588, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory cos_table = [int256(70710678), 92387953, 98078528, 99518473, 99879546, 99969882, 99992470, 99998118, 99999529, 99999882, 99999971, 99999993, 99999998, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000];\r\n\r\n        int256 x = 100000000;\r\n        int256 xnew = 100000000;\r\n        int256 y = 0;\r\n        int256 ynew = 0;\r\n        int256 ang = 0;\r\n\r\n        uint8 i = 0;\r\n        for (i = 0; i <= 19; i = i + 1)\r\n        {\r\n            if (y < input)\r\n            {\r\n                xnew = (x*cos_table[i] - y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] + x*sin_table[i]) / 100000000;\r\n                ang = ang + arctan_table[i];\r\n            }\r\n\r\n            else if (y > input)\r\n            {\r\n                xnew = (x*cos_table[i] + y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] - x*sin_table[i]) / 100000000;\r\n                ang = ang - arctan_table[i];\r\n            }\r\n\r\n            x = xnew;\r\n            y = ynew;\r\n        }\r\n        return(ang);\r\n    }\r\n\r\n    function arctan(int256 input) internal pure returns(int256)\r\n    {\r\n        int256[20] memory arctan_table = [int256(78539816), 39269908, 19634954, 9817477, 4908739, 2454369, 1227185, 613592, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory sin_table = [int256(70710678), 38268343, 19509032, 9801714, 4906767, 2454123, 1227154, 613588, 306796, 153398, 76699, 38350, 19175, 9587, 4794, 2397, 1198, 599, 300, 150];\r\n        int256[20] memory cos_table = [int256(70710678), 92387953, 98078528, 99518473, 99879546, 99969882, 99992470, 99998118, 99999529, 99999882, 99999971, 99999993, 99999998, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000, 100000000];\r\n\r\n        int256 x = 100000000;\r\n        int256 xnew = 100000000;\r\n        int256 y = input;\r\n        int256 ynew = input;\r\n        int256 ang = 0;\r\n\r\n        uint8 i = 0;\r\n        for (i = 0; i <= 19; i = i + 1)\r\n        {\r\n            if (y > 0)\r\n            {\r\n                xnew = (x*cos_table[i] + y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] - x*sin_table[i]) / 100000000;\r\n                ang = ang + arctan_table[i];\r\n            }\r\n\r\n            else if (y < 0)\r\n            {\r\n                xnew = (x*cos_table[i] - y*sin_table[i]) / 100000000;\r\n                ynew = (y*cos_table[i] + x*sin_table[i]) / 100000000;\r\n                ang = ang - arctan_table[i];\r\n            }\r\n\r\n            x = xnew;\r\n            y = ynew;\r\n        }\r\n        return(ang);\r\n    }\r\n\r\n\r\n    function arctan2(int256 Y, int256 X) internal pure returns(int256)\r\n    {\r\n        int256 alpha = arctan( abs(int256(10**Decimals) * Y / X));\r\n        if( X < 0 && Y > 0) {\r\n            alpha = PI - alpha;\r\n        }\r\n        if( X > 0 && Y < 0) {\r\n            alpha = alpha * int256(-1);\r\n        }\r\n        if( X < 0 && Y < 0) {\r\n            alpha = alpha - PI;\r\n        }\r\n\r\n        return(alpha);\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Conversion from ecliptic cartesian coordinates to equatorial ones\r\n     * integer, integer, integer.\r\n     *\r\n     * @param cart_X cartesian X position\r\n     * @param cart_Y cartesian Y position\r\n     * @param cart_Z cartesian Z position\r\n     * @param epsilon Axial tilt (40910000 = default value for the Earth )\r\n     * @return The equatorial position.\r\n     */\r\n    function cart_ecl2cart_eq(int256 cart_X, int256 cart_Y, int256 cart_Z, int256 epsilon) internal pure returns(int256, int256, int256)\r\n    {\r\n        int256 equat_X = cart_X;\r\n        int256 equat_Y = ( cart_Y*cos(epsilon) - cart_Z*sin(epsilon) )/int256( 10**Decimals );\r\n        int256 equat_Z = ( cart_Y*sin(epsilon) + cart_Z*cos(epsilon) )/int256( 10**Decimals );\r\n        return(equat_X, equat_Y, equat_Z);\r\n    }\r\n\r\n\r\n    /**\r\n     * Conversion from cartesian to spherical coordinates\r\n     * integer, integer.\r\n     *\r\n     * @param cart_X cartesian X position\r\n     * @param cart_Y cartesian Y position\r\n     * @param cart_Z cartesian Z position\r\n     * @return The Spherical position.\r\n     */\r\n    function cart2sph(int256 cart_X, int256 cart_Y, int256 cart_Z) internal pure returns(int256, int256)\r\n    {\r\n        int256 norm = int256(sqrt(uint256(cart_X*cart_X + cart_Y*cart_Y + cart_Z*cart_Z)));\r\n        int256 alpha = (arctan2(cart_Y, cart_X) + 2*PI) % (2*PI);\r\n        int256 delta = arcsin(int256(10**Decimals) * cart_Z / norm);\r\n        return(alpha, delta);\r\n    }\r\n\r\n    /**\r\n     * Conversion from Equatorial to Horizontal coordinates (both spherical)\r\n     * integer, integer.\r\n     *\r\n     * @param timeIndex UTC time index from 2000-01-01 12:00:00 (second unit)\r\n     * @param RA Alpha value of Equatorial coordinates\r\n     * @param DEC Delta value of Equatorial coordinates\r\n     * @param lat latutude of the observer (north is positive) [rad]\r\n     * @param lon longitude of the observer (east is positive) [rad]\r\n     * @return return Horizontal position.\r\n     */\r\n    function sph_eq2sph_hor(int256 timeIndex, int256 RA, int256 DEC, int256 lat, int256 lon ) internal pure returns(int256, int256)\r\n    {\r\n        int256 temp;\r\n        // calculating Greenwich Sideral Time\r\n        int256 tu = int256( 10**Decimals ) * timeIndex / ( 24 * 3600 );\r\n        int256 GST = 2*PI * ((77905727 + 100273781 * tu / int256( 10**Decimals )  ) % int256( 10**Decimals )) / int256(10**Decimals);\r\n        // calculating Local Sideral Time\r\n        int256 LST = GST + lon;\r\n\r\n        // calculating the hour angle\r\n        int256 h = LST - RA;\r\n        // calculating the altitudes (a) and the azimuths (A) using spherical triangles\r\n        int256 delta = DEC;\r\n\r\n        temp = sin(lat) * sin(delta)/(int256(10**Decimals)) + cos(lat) * cos(delta) * cos(h)/(int256(10**(Decimals*2)));\r\n        int256 a = arcsin(temp);\r\n\r\n        temp = int256(-1) * cos(delta) * cos(h) * sin(lat)/(int256(10**(Decimals*2))) + sin(delta) * cos(lat)/(int256(10**Decimals));\r\n        int256 A = int256(-1) * arctan2( cos(delta)*sin(h)/(int256(10**Decimals)), temp );\r\n\r\n        return(a, A);\r\n    }\r\n\r\n\r\n    /**\r\n     * Transforms positions in space to positions in the sky relative to an observer\r\n     * integer, integer.\r\n     *\r\n     * @param pos_X positions X in space\r\n     * @param pos_Y positions Y in space\r\n     * @param pos_Z positions Z in space\r\n     * @param obliquity Axial tilt (40910000 = default value for the Earth )\r\n     * @param obs_latitude_rad latutude of the observer (north is positive) [rad]\r\n     * @param obs_longitude_rad longitude of the observer (east is positive) [rad]\r\n     * @param timeindex UTC time index from 2000-01-01 12:00:00 (second unit)\r\n     * @return return Sky position.\r\n     */\r\n    function get_sky_positions(int256 pos_X, int256 pos_Y, int256 pos_Z, int256 obliquity, int256 obs_latitude_rad, int256 obs_longitude_rad, int256 timeindex ) internal pure returns(int256, int256)\r\n    {\r\n        int256 RA;\r\n        int256 DEC;\r\n        int256 temp_1;\r\n        int256 temp_2;\r\n        int256 temp_3;\r\n\r\n        (temp_1, temp_2, temp_3) = cart_ecl2cart_eq(pos_X, pos_Y, pos_Z, obliquity);\r\n        (RA, DEC) = cart2sph(temp_1, temp_2, temp_3);\r\n\r\n        (temp_1, temp_2) = sph_eq2sph_hor(timeindex, RA, DEC, obs_latitude_rad, obs_longitude_rad);\r\n\r\n        return(temp_1, temp_2);\r\n    }\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(int256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n        bool neg = false;\r\n        int256 temp;\r\n        int256 abs_value;\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        if (value < 0) {\r\n            neg = true;\r\n            temp = int(0 - value);\r\n        } else {\r\n            temp = int(value);\r\n        }\r\n        abs_value = temp;\r\n\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (abs_value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(abs_value % 10)));\r\n            abs_value /= 10;\r\n        }\r\n\r\n        return neg? string(abi.encodePacked('-', string(buffer))) : string(buffer);\r\n    }\r\n\r\n}\r\n\r\nstruct Orbit2D {\r\n    int256 a;\r\n    int256 e;\r\n    int256 M;\r\n    int256 T;\r\n    int256 n;\r\n    int256 a_rate;\r\n    int256 e_rate;\r\n}\r\n\r\nstruct Orbit3D {\r\n    int256 a;\r\n    int256 e;\r\n    int256 M;\r\n    int256 T;\r\n    int256 Omega;\r\n    int256 omega;\r\n    int256 I;\r\n    int256 a_rate;\r\n    int256 e_rate;\r\n    int256 I_rate;\r\n    int256 Omega_rate;\r\n    int256 omega_rate;\r\n    Orbit2D orbit2d;\r\n}\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Orbit2DFuns {\r\n    uint8 constant Decimals = 8;\r\n    int256 constant PI = 314159265;\r\n\r\n    /**\r\n     * Sets the mean angular velocity (n) for the class\r\n     * Needs to be run every time the period (T) is set or updated\r\n     */\r\n    function _update_n( Orbit2D storage self ) internal {\r\n        self.n = 100 * 2 * PI / self.T;     //100*self.n to correct closely\r\n    }\r\n\r\n    /**\r\n     * To be used for changes in orbital parameters, e.g. perihelion shift\r\n     */\r\n    function update( Orbit2D storage self, string memory key, int256 value ) internal {\r\n        if (keccak256(bytes(key)) == keccak256(bytes('a')))\r\n            self.a = value;\r\n        if (keccak256(bytes(key)) == keccak256(bytes('e')))\r\n            self.e = value;\r\n        if (keccak256(bytes(key)) == keccak256(bytes('M')))\r\n            self.M = value;\r\n        if (keccak256(bytes(key)) == keccak256(bytes('T'))) {\r\n            self.T = value;\r\n            self.n = 100 * 2 * PI / value;\r\n        }\r\n    }\r\n\r\n\r\n    // E = fsolve( lambda E: self._Kepler_equation( E, M ), self.E_init )  # actual eccentric anomaly\r\n    function Kepler_fsolve(int256 M, int256 e) internal pure returns(int256, bool)\r\n    {\r\n        // condition to check if fsolve is success.\r\n        // fsolve_cond = (np.pi-2/E0) * (np.pi-2/E0) - 4*(np.pi*np.pi/4 - 2 - 2*M0/E0) : Python format\r\n        int256 fsolve_cond = (PI- int(10**Decimals) * 2*int(10**Decimals)/e);\r\n        int256 temp;\r\n        fsolve_cond = fsolve_cond * fsolve_cond;\r\n        temp = int(10**Decimals) * 2*int(10**Decimals)*M/e;\r\n        temp = 4*(PI*PI/4 - int(10**Decimals) * 2*int(10**Decimals) - temp );\r\n        fsolve_cond = fsolve_cond - temp;\r\n\r\n        if(fsolve_cond > 0) {\r\n            int256 E0 = ((PI- int(10**Decimals) * 2*int(10**Decimals)/e) + int(MathLib.sqrt(uint(fsolve_cond))))/2;\r\n            int256 E1 = ((PI- int(10**Decimals) * 2*int(10**Decimals)/e) - int(MathLib.sqrt(uint(fsolve_cond))))/2;\r\n            int256 E0_offset = E0- e*MathLib.sin(int(E0))/int(10**Decimals);\r\n            int256 E1_offset = E1- e*MathLib.sin(int(E1))/int(10**Decimals);\r\n            int256 E = MathLib.abs(E0_offset) < MathLib.abs(E1_offset) ? E0:E1;\r\n\r\n            for(uint i=0; i<5; i++) {\r\n                temp = int(10**Decimals) * (E - e*MathLib.sin(int(E))/int(10**Decimals) - M);\r\n                temp = E - temp/(int(10**Decimals) - MathLib.cos(int(E))/int(10**Decimals));\r\n                E = temp;\r\n            }\r\n\r\n            return(E, true);\r\n\r\n        } else {\r\n            return(0, false);\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Arguments: t [sec] - relative time from point zero (default J2000 epoch)\r\n     * Returns: radius [AU] and true anomaly [rad]\r\n     */\r\n    function get_rv( Orbit2D storage self, int256 t ) internal view returns (int256, int256) {\r\n\r\n        int256 M = self.n * t/100  + self.M;  // actual mean anomaly\r\n        int256 E;                         // actual eccentric anomaly\r\n        int256 temp;                      // Temporary memory for deep computations\r\n        bool fsolve_cond;\r\n        int256 orbit2D_a = self.a + self.a_rate * t /3153600000;\r\n        int256 orbit2D_e = self.e + self.e_rate * t /3153600000;\r\n\r\n        (E, fsolve_cond) = Kepler_fsolve(M, orbit2D_e);\r\n\r\n        if(fsolve_cond) {\r\n            // Radius (distance from baricenter) => r = self.a * ( 1.0 - self.e * np.cos( E ) ) : Python format\r\n            int256 r = orbit2D_a * ( int(10**Decimals) - orbit2D_e * MathLib.cos(E)/int(10**Decimals) ) / (int(10**Decimals));\r\n            // True anomaly => v = 2.0 * np.arctan( np.sqrt( ( 1.0 + self.e ) / ( 1.0 - self.e ) ) * np.tan( E / 2.0 ) ) : Python format                            // radius (distance from baricenter)\r\n            temp = int(MathLib.sqrt(uint( int(10**Decimals) * int(10**Decimals) * (int(10**Decimals) + orbit2D_e )/( int(10**Decimals) - orbit2D_e ))));\r\n            int256 ratio = temp * MathLib.sin(int(E/2))/MathLib.cos(int(E/2));\r\n            temp = int(MathLib.arctan(int(ratio)));\r\n            int256 v = 2 * temp  ;  // true anomaly\r\n            return(r, v);\r\n        } else {\r\n            return(0, 0);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Same as get_rv() but returns the objects position in cartesian coordinates\r\n     * Returns: x, y [AU] - x-axis is in the direction of pericenter, y-axis is right-hand perpendicular\r\n     */\r\n    function get_xy( Orbit2D storage self, int256 t ) internal view returns (int256, int256) {\r\n        int256 r;\r\n        int256 v;\r\n        (r, v) = get_rv(self, t);\r\n\r\n        int256 x = r * MathLib.cos(int(v))/int(10**Decimals);\r\n        int256 y = r * MathLib.sin(int(v))/int(10**Decimals);\r\n\r\n        return(x, y);\r\n\r\n    }\r\n\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Orbit3DFuns {\r\n\r\n    uint8 constant Decimals = 8;\r\n    int256 constant PI = 314159265;\r\n\r\n    /**\r\n     * Updates class parameters\r\n     * To be used for changes in orbital parameters, e.g. perihelion shift\r\n     */\r\n    function update( Orbit3D storage self, string memory key, int256 value ) internal {\r\n        if (keccak256(bytes(key)) == keccak256(bytes('a')))\r\n            self.a = value;\r\n        if (keccak256(bytes(key)) == keccak256(bytes('e')))\r\n            self.e = value;\r\n        if (keccak256(bytes(key)) == keccak256(bytes('M')))\r\n            self.M = value;\r\n        if (keccak256(bytes(key)) == keccak256(bytes('T')))\r\n            self.T = value;\r\n        if (keccak256(bytes(key)) == keccak256(bytes('Omega'))) {\r\n            self.Omega = value;\r\n        }\r\n        if (keccak256(bytes(key)) == keccak256(bytes('omega'))) {\r\n            self.omega = value;\r\n        }\r\n        if (keccak256(bytes(key)) == keccak256(bytes('I'))) {\r\n            self.I = value;\r\n        }\r\n\r\n        Orbit2DFuns.update(self.orbit2d, key, value);\r\n    }\r\n\r\n\r\n\r\n    function get_euler_matrix( Orbit3D storage self, int256 t) internal view returns(int256,int256,int256,int256,int256,int256)\r\n    {\r\n        int256[3][3] memory euler_matrix;\r\n        // int256 temp;\r\n        euler_matrix[0][2] = self.Omega + self.Omega_rate * t /3153600000;\r\n        euler_matrix[1][2] = self.I + self.I_rate * t /3153600000;\r\n        euler_matrix[2][2] = self.omega + self.omega_rate * t /3153600000;\r\n\r\n        int256 cosO = MathLib.cos(euler_matrix[0][2]);\r\n        int256 sinO = MathLib.sin(euler_matrix[0][2]);\r\n\r\n        int256 cosI = MathLib.cos(euler_matrix[1][2]);\r\n        int256 sinI = MathLib.sin(euler_matrix[1][2]);\r\n\r\n        int256 coso = MathLib.cos(euler_matrix[2][2]);\r\n        int256 sino = MathLib.sin(euler_matrix[2][2]);\r\n\r\n        euler_matrix[0][0] = (int(10**Decimals)*cosO*coso- sinO*sino*cosI)/(int(10**Decimals)*int(10**Decimals));\r\n        euler_matrix[0][1] = (-int(10**Decimals)*cosO*sino- sinO*coso*cosI)/(int(10**Decimals)*int(10**Decimals));\r\n        // euler_matrix[0][2] = sinO*sinI/int(10**Decimals);\r\n        euler_matrix[1][0] = (int(10**Decimals)*sinO*coso + cosO*cosI*sino)/(int(10**Decimals)*int(10**Decimals));\r\n        euler_matrix[1][1] = (cosO*coso*cosI -int(10**Decimals)*sinO*sino)/(int(10**Decimals)*int(10**Decimals));\r\n        // euler_matrix[1][2] = -cosO*sinI/int(10**Decimals);\r\n        euler_matrix[2][0] = sinI*sino/int(10**Decimals);\r\n        euler_matrix[2][1] = sinI*coso/int(10**Decimals);\r\n        // euler_matrix[2][2] = cosI;\r\n\r\n        return(euler_matrix[0][0], euler_matrix[0][1], euler_matrix[1][0], euler_matrix[1][1], euler_matrix[2][0], euler_matrix[2][1]);\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Argument: t [sec] - time since time zero [default to J2000 epoch]\r\n     * Returns: objects possition x, y, z in [AU] - x is directed at vernal equinox; y,z are right-handed ortogonal\r\n     */\r\n    function get_xyz( Orbit3D storage self, int256 t) internal view returns (int256, int256, int256) {\r\n        int256 p_2d_x;\r\n        int256 p_2d_y;\r\n        int256 euler_matrix_0_0;\r\n        int256 euler_matrix_0_1;\r\n        int256 euler_matrix_1_0;\r\n        int256 euler_matrix_1_1;\r\n        int256 euler_matrix_2_0;\r\n        int256 euler_matrix_2_1;\r\n\r\n        (euler_matrix_0_0, euler_matrix_0_1, euler_matrix_1_0, euler_matrix_1_1, euler_matrix_2_0, euler_matrix_2_1) = get_euler_matrix(self, t);\r\n\r\n        (p_2d_x, p_2d_y) = Orbit2DFuns.get_xy(self.orbit2d, t);\r\n\r\n        int256 x = (euler_matrix_0_0 * p_2d_x + euler_matrix_0_1 * p_2d_y)/int(10**Decimals);\r\n        int256 y = (euler_matrix_1_0 * p_2d_x + euler_matrix_1_1 * p_2d_y)/int(10**Decimals);\r\n        int256 z = (euler_matrix_2_0 * p_2d_x + euler_matrix_2_1 * p_2d_y)/int(10**Decimals);\r\n\r\n        return(x, y, z);\r\n\r\n    }\r\n\r\n    /**\r\n     * Argument: t [sec] - time since time zero [default to J2000 epoch]\r\n     * Returns: objects possition x, y in [AU] - x is directed at vernal equinox; y is right-handed ortogonal\r\n     */\r\n    function get_xy( Orbit3D storage self, int256 t) internal view returns (int256, int256) {\r\n        int256 p_2d_x;\r\n        int256 p_2d_y;\r\n        (p_2d_x, p_2d_y) = Orbit2DFuns.get_xy(self.orbit2d, t);\r\n\r\n        return(p_2d_x, p_2d_y);\r\n    }\r\n\r\n}\r\n\r\n\r\npragma solidity ^0.8.0;\r\npragma abicoder v2;\r\n\r\ncontract Orbit {\r\n\r\n    using Orbit2DFuns for Orbit2D;\r\n    using Orbit3DFuns for Orbit3D;\r\n    using Strings for int256;\r\n    // int256[3][3] public matrix;\r\n    Orbit2D orbit2d;\r\n    Orbit3D orbit3d;\r\n    mapping (bytes => Orbit3D) private Solar_System_Keplerian_Elements;\r\n\r\n    constructor() {\r\n        orbit2d =  Orbit2D({a:38709893, e:20563069, M: 305073760, T:760065407544000, n:8267, a_rate:37, e_rate:1906 });\r\n        orbit3d =  Orbit3D({a:38709893, e:20563069, M: 305073760, T:760065407544000, I:12225804, Omega:84354677, omega:50832330,\r\n                            a_rate:37, e_rate:1906, I_rate:-10380, Omega_rate:-218761, omega_rate:498846, orbit2d:orbit2d });\r\n        Solar_System_Keplerian_Elements[bytes('Mercury')] = orbit3d;\r\n\r\n        orbit2d =  Orbit2D({a:72333199, e:677323, M: 88046188, T:1940826194496000, n:3237, a_rate:390, e_rate:-4107});\r\n        orbit3d =  Orbit3D({a:72333199, e:677323, M: 88046188, T:1940826194496000, I:5924887, Omega:133833051, omega:95735306,\r\n                            a_rate:390, e_rate:-4107, I_rate:-1377, Omega_rate:-484667, omega_rate:489351, orbit2d:orbit2d });\r\n        Solar_System_Keplerian_Elements[bytes('Venus')] = orbit3d;\r\n\r\n        orbit2d =  Orbit2D({a:100000011, e:1671022, M: -4333373, T:3155814950400000, n:1991, a_rate:56, e_rate:-439});\r\n        orbit3d =  Orbit3D({a:100000011, e:1671022, M: -4333373, T:3155814950400000, I:87, Omega:0, omega:179676742,\r\n                            a_rate:56, e_rate:-439, I_rate:-0, Omega_rate:0, omega_rate:564218, orbit2d:orbit2d });\r\n        Solar_System_Keplerian_Elements[bytes('EM')] = orbit3d;\r\n\r\n        orbit2d =  Orbit2D({a:152366231, e:9341233, M: 33881169, T:5936087921702400, n:1058, a_rate:1847, e_rate:7882});\r\n        orbit3d =  Orbit3D({a:152366231, e:9341233, M: 33881169, T:5936087921702400, I:3229923, Omega:86530876, omega:499971031,\r\n                            a_rate:1847, e_rate:7882, I_rate:-14192, Omega_rate:-510637, omega_rate:1286280, orbit2d:orbit2d });\r\n        Solar_System_Keplerian_Elements[bytes('Mars')] = orbit3d;\r\n\r\n        orbit2d =  Orbit2D({a:520336301, e:4839266, M: 34296644, T:37427965311744000, n:168, a_rate:-11607, e_rate:-13253});\r\n        orbit3d =  Orbit3D({a:520336301, e:4839266, M: 34296644, T:37427965311744000, I:2278178, Omega:175503590, omega:-149753264,\r\n                            a_rate:-11607, e_rate:-13253, I_rate:-3206, Omega_rate:357253, omega_rate:13676, orbit2d:orbit2d });\r\n        Solar_System_Keplerian_Elements[bytes('Jupiter')] = orbit3d;\r\n\r\n        orbit2d =  Orbit2D({a:953707032, e:5415060, M: -74154886, T:92970308438784000, n:68, a_rate:-125060, e_rate:-50991});\r\n        orbit3d =  Orbit3D({a:953707032, e:5415060, M: -74154886, T:92970308438784000, I:4336200, Omega:198470185, omega:-37146017,\r\n                            a_rate:-125060, e_rate:-50991, I_rate:3379, Omega_rate:-503838, omega_rate:-227406, orbit2d:orbit2d });\r\n        Solar_System_Keplerian_Elements[bytes('Saturn')] = orbit3d;\r\n\r\n        orbit2d =  Orbit2D({a:1919126393, e:4716771, M: 248304397, T:265120013983104000, n:24, a_rate:-196176, e_rate:-4397});\r\n        orbit3d =  Orbit3D({a:1919126393, e:4716771, M: 248304397, T:265120013983104000, I:1343659, Omega:129555580, omega:168833308,\r\n                            a_rate:-196176, e_rate:-4397, I_rate:-4240, Omega_rate:74012, omega_rate:638174, orbit2d:orbit2d });\r\n        Solar_System_Keplerian_Elements[bytes('Uranus')] = orbit3d;\r\n\r\n        orbit2d =  Orbit2D({a:3006896348, e:858587, M: 453626222, T:520078303825920000, n:12, a_rate:26291, e_rate:5105});\r\n        orbit3d =  Orbit3D({a:3006896348, e:858587, M: 453626222, T:520078303825920000, I:3087784, Omega:229897718, omega:-151407906,\r\n                            a_rate:26291, e_rate:5105, I_rate:617, Omega_rate:-8878, omega_rate:-553842, orbit2d:orbit2d });\r\n        Solar_System_Keplerian_Elements[bytes('Neptune')] = orbit3d;\r\n\r\n        orbit2d =  Orbit2D({a:3948168677, e:24880766, M: 25939170, T:782957689194239900, n:8, a_rate:262910, e_rate:51050});\r\n        orbit3d =  Orbit3D({a:3948168677, e:24880766, M: 25939170, T:782957689194239900, I:29917997, Omega:192515872, omega:198554397,\r\n                            a_rate:262910, e_rate:51050, I_rate:6173, Omega_rate:-88778, omega_rate:-473941, orbit2d:orbit2d });\r\n        Solar_System_Keplerian_Elements[bytes('Pluto')] = orbit3d;\r\n\r\n        orbit2d =  Orbit2D({a:311, e:5554400, M: -392762524, T:236059142400000, n:26617, a_rate:0, e_rate:0});\r\n        orbit3d =  Orbit3D({a:311, e:5554400, M: -392762524, T:236059142400000, I:9000197, Omega:218243998, omega:241393696,\r\n                            a_rate:0, e_rate:0, I_rate:0, Omega_rate:0, omega_rate:0, orbit2d:orbit2d });\r\n        Solar_System_Keplerian_Elements[bytes('Earth')] = orbit3d;\r\n\r\n        orbit2d =  Orbit2D({a:253171, e:5554400, M: 235556006, T:236059142400000, n:26617, a_rate:0, e_rate:0});\r\n        orbit3d =  Orbit3D({a:253171, e:5554400, M: 235556006, T:236059142400000, I:9000197, Omega:218243998, omega:-72765569,\r\n                            a_rate:0, e_rate:0, I_rate:0, Omega_rate:0, omega_rate:0, orbit2d:orbit2d });\r\n        Solar_System_Keplerian_Elements[bytes('Moon')] = orbit3d;\r\n\r\n    }\r\n\r\n    /**\r\n     * Returns the 3D position of the object planet relative to the observer planet.\r\n     * integer, integer, integer.\r\n     *\r\n     * @param object object planet name\r\n     * @param observer observer planet name\r\n     *        ['Mercury', 'Venus', 'EM', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto', 'Earth','Moon']\r\n     * @param t UTC time index from 2000-01-01 12:00:00 (second unit)\r\n     * @return 3D relative position\r\n     */\r\n    function get_relative_3D_pos(string memory object, string memory observer, int256 t ) public view returns (int256, int256, int256) {\r\n        int256 pos_x;\r\n        int256 pos_y;\r\n        int256 pos_z;\r\n        int256 obs_x = 0;\r\n        int256 obs_y = 0;\r\n        int256 obs_z = 0;\r\n\r\n        // objective planet's absolute position.\r\n        (pos_x, pos_y, pos_z) = get_absolutive_3D_pos(object, t);\r\n        // observer planet's absolute position.\r\n        (obs_x, obs_y, obs_z) = get_absolutive_3D_pos(observer, t);\r\n        return (pos_x-obs_x, pos_y-obs_y, pos_z-obs_z);\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the 3D positions list of the all solar planets relative to the observer planet.\r\n     * string\r\n     *\r\n     * @param observer observer planet name\r\n     *        ['Mercury', 'Venus', 'EM', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto', 'Earth','Moon']\r\n     * @param t UTC time index from 2000-01-01 12:00:00 (second unit)\r\n     * @return 3D relative position list\r\n     */\r\n    function get_relative_all_3D_pos(string memory observer, int256 t ) public view returns (string[] memory) {\r\n        int256 pos_x;\r\n        int256 pos_y;\r\n        int256 pos_z;\r\n        int256 obs_x = 0;\r\n        int256 obs_y = 0;\r\n        int256 obs_z = 0;\r\n        string[11] memory planet_list = ['Mercury', 'Venus', 'EM', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto', 'Earth','Moon'];\r\n        string[] memory result_list = new string[](11);\r\n\r\n        for (uint i=0; i< planet_list.length; i++) {\r\n            (pos_x, pos_y, pos_z) = get_relative_3D_pos(planet_list[i], observer, t);\r\n            result_list[i] = string(abi.encodePacked(planet_list[i], \"_\", (pos_x-obs_x).toString(), \"_\", (pos_y-obs_y).toString(), \"_\", (pos_z-obs_z).toString() ));\r\n        }\r\n\r\n        return result_list;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the absolutive 3D position of the object planet.\r\n     * integer, integer, integer.\r\n     *\r\n     * @param object object planet name\r\n     *        ['O', 'Mercury', 'Venus', 'EM', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto', 'Earth','Moon']\r\n     *        O means (0,0,0) position\r\n     * @param t UTC time index from 2000-01-01 12:00:00 (second unit)\r\n     * @return 3D absolutive position\r\n     */\r\n    function get_absolutive_3D_pos(string memory object, int256 t ) public view returns (int256, int256, int256) {\r\n        int256 pos_x;\r\n        int256 pos_y;\r\n        int256 pos_z;\r\n\r\n        if( keccak256(bytes(object)) == keccak256(bytes('O'))) {\r\n            return (0, 0, 0);\r\n        }\r\n\r\n        // objective planet's absolute position.\r\n        (pos_x, pos_y, pos_z) = Solar_System_Keplerian_Elements[bytes(object)].get_xyz(t);\r\n        if( keccak256(bytes(object)) == keccak256(bytes('Earth')) || keccak256(bytes(object)) == keccak256(bytes('Moon'))  ) {\r\n            // Earth and Moon are child planet of EM planet.\r\n            int256 EM_X = 0;\r\n            int256 EM_Y = 0;\r\n            int256 EM_Z = 0;\r\n            (EM_X, EM_Y, EM_Z) = Solar_System_Keplerian_Elements[bytes('EM')].get_xyz(t);\r\n            pos_x = pos_x + EM_X;\r\n            pos_y = pos_y + EM_Y;\r\n            pos_z = pos_z + EM_Z;\r\n        }\r\n\r\n        return (pos_x, pos_y, pos_z);\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the absolutive 3D positions list of the all solar planets.\r\n     * string\r\n     *\r\n     * @param t UTC time index from 2000-01-01 12:00:00 (second unit)\r\n     * @return 3D absolutive position list\r\n     */\r\n    function get_absolutive_all_3D_pos(int256 t ) public view returns (string[] memory) {\r\n        int256 pos_x;\r\n        int256 pos_y;\r\n        int256 pos_z;\r\n        string[11] memory planet_list = ['Mercury', 'Venus', 'EM', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto', 'Earth','Moon'];\r\n        string[] memory result_list = new string[](11);\r\n\r\n        for (uint i=0; i< planet_list.length; i++) {\r\n            (pos_x, pos_y, pos_z) = get_absolutive_3D_pos(planet_list[i], t);\r\n            result_list[i] = string(abi.encodePacked(planet_list[i], \"_\", pos_x.toString(), \"_\", pos_y.toString(), \"_\", pos_z.toString() ));\r\n        }\r\n\r\n        return result_list;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the position of the object planet on the sky relative to the observer.\r\n     * integer, integer.\r\n     *\r\n     * @param object object planet name\r\n     * @param observer observer planet name\r\n     *        ['Mercury', 'Venus', 'EM', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto', 'Earth','Moon']\r\n     * @param obs_latitude latitude of the observer (relevant only for coordinates = 'horizontal')\r\n     * @param obs_longitude longitude of the observer (relevant only for coordinates = 'horizontal')\r\n     * @param t UTC time index from 2000-01-01 12:00:00 (second unit)\r\n     * @return 3D relative position\r\n     */\r\n    function get_sky_pos(string memory object, string memory observer, int256 obs_latitude, int256 obs_longitude, int256 t) public view returns (int256, int256) {\r\n        int256 pos_x;\r\n        int256 pos_y;\r\n        int256 pos_z;\r\n        int256 temp_a = 0;\r\n        int256 temp_b = 0;\r\n        int256 temp_c = 0;\r\n\r\n        // Get relative 3D position of object planet in the space\r\n        (pos_x, pos_y, pos_z) = get_absolutive_3D_pos(object, t);\r\n        (temp_a, temp_b, temp_c) = get_absolutive_3D_pos(observer, t);\r\n\r\n        pos_x = pos_x - temp_a;\r\n        pos_y = pos_y - temp_b;\r\n        pos_z = pos_z - temp_c;\r\n\r\n        temp_a = obs_latitude * 314159265 / (180 * 10**8);\r\n        temp_b = obs_longitude * 314159265 / (180 * 10**8);\r\n\r\n        // Transforms positions in space to positions on the sky\r\n        (temp_a, temp_b) = MathLib.get_sky_positions(pos_x, pos_y, pos_z, 40910000, temp_a, temp_b, t);\r\n\r\n        return (temp_a, temp_b);\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the sky positions list of the all solar planets.\r\n     * string\r\n     *\r\n     * @param observer observer planet name\r\n     *        ['Mercury', 'Venus', 'EM', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto', 'Earth','Moon']\r\n     * @param obs_latitude latitude of the observer (relevant only for coordinates = 'horizontal')\r\n     * @param obs_longitude longitude of the observer (relevant only for coordinates = 'horizontal')\r\n     * @param t UTC time index from 2000-01-01 12:00:00 (second unit)\r\n     * @return sky position list\r\n     */\r\n    function get_all_sky_pos(string memory observer, int256 obs_latitude, int256 obs_longitude, int256 t) public view returns (string[] memory) {\r\n        int256 pos_a;\r\n        int256 pos_A;\r\n        string[11] memory planet_list = ['Mercury', 'Venus', 'EM', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto', 'Earth','Moon'];\r\n        string[] memory result_list = new string[](11);\r\n\r\n        for (uint i=0; i< planet_list.length; i++) {\r\n            if( keccak256(bytes(planet_list[i])) != keccak256(bytes(observer))) {\r\n                (pos_a, pos_A) = get_sky_pos(planet_list[i], observer, obs_latitude, obs_longitude, t);\r\n                result_list[i] = string(abi.encodePacked(planet_list[i], \"_\", pos_a.toString(), \"_\", pos_A.toString() ));\r\n            }\r\n\r\n        }\r\n        return result_list;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"object\",\"type\":\"string\"},{\"internalType\":\"int256\",\"name\":\"t\",\"type\":\"int256\"}],\"name\":\"get_absolutive_3D_pos\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"t\",\"type\":\"int256\"}],\"name\":\"get_absolutive_all_3D_pos\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"observer\",\"type\":\"string\"},{\"internalType\":\"int256\",\"name\":\"obs_latitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"obs_longitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"t\",\"type\":\"int256\"}],\"name\":\"get_all_sky_pos\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"object\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"observer\",\"type\":\"string\"},{\"internalType\":\"int256\",\"name\":\"t\",\"type\":\"int256\"}],\"name\":\"get_relative_3D_pos\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"observer\",\"type\":\"string\"},{\"internalType\":\"int256\",\"name\":\"t\",\"type\":\"int256\"}],\"name\":\"get_relative_all_3D_pos\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"object\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"observer\",\"type\":\"string\"},{\"internalType\":\"int256\",\"name\":\"obs_latitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"obs_longitude\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"t\",\"type\":\"int256\"}],\"name\":\"get_sky_pos\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Orbit", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f12788bee06735bdd55a818a69510c34718da60328b09d95d297911cecea1aa2"}]}