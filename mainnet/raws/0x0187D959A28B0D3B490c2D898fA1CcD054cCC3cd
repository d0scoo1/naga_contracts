{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/utils/ApeOnlyPriceGetter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity =0.6.6;\\r\\n\\r\\nimport '../interfaces/IApePair.sol';\\r\\nimport '../interfaces/IApeFactory.sol';\\r\\nimport '../interfaces/IERC20.sol';\\r\\n\\r\\n// This library provides simple price calculations for ApeSwap tokens, accounting\\r\\n// for commonly used pairings. Will break if USDC goes far off peg.\\r\\n// Should NOT be used as the sole oracle for sensitive calculations such as \\r\\n// liquidation, as it is vulnerable to manipulation by flash loans, etc. BETA\\r\\n// SOFTWARE, PROVIDED AS IS WITH NO WARRANTIES WHATSOEVER.\\r\\n\\r\\n// ApeSwap only version\\r\\nlibrary ApeOnlyPriceGetter {\\r\\n    address public constant FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; //Uniswap Factory\\r\\n\\r\\n    //All returned prices calculated with this precision (18 decimals)\\r\\n    uint private constant PRECISION = 10**DECIMALS; //1e18 == $1\\r\\n    uint public constant DECIMALS = 18;\\r\\n\\r\\n    //Token addresses\\r\\n    address constant NATIVE = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\r\\n\\r\\n    //Token value constants\\r\\n    uint private constant USDC_RAW_PRICE = 1e6;\\r\\n\\r\\n    //Ape LP addresses\\r\\n    address constant USDC_NATIVE_PAIR = 0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc; // usdc is token0\\r\\n\\r\\n    //Normalized to specified number of decimals based on token's decimals and\\r\\n    //specified number of decimals\\r\\n    function getPrice(address token, uint _decimals) external view returns (uint) {\\r\\n        return normalize(getRawPrice(token), token, _decimals);\\r\\n    }\\r\\n\\r\\n    function getLPPrice(address token, uint _decimals) external view returns (uint) {\\r\\n        return normalize(getRawLPPrice(token), token, _decimals);\\r\\n    }\\r\\n\\r\\n    function getPrices(address[] calldata tokens, uint _decimals) external view returns (uint[] memory prices) {\\r\\n        prices = getRawPrices(tokens);\\r\\n\\r\\n        for (uint i; i < prices.length; i++) {\\r\\n            prices[i] = normalize(prices[i], tokens[i], _decimals);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getLPPrices(address[] calldata tokens, uint _decimals) external view returns (uint[] memory prices) {\\r\\n        prices = getRawLPPrices(tokens);\\r\\n\\r\\n        for (uint i; i < prices.length; i++) {\\r\\n            prices[i] = normalize(prices[i], tokens[i], _decimals);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //returns the price of any token in USD based on common pairings; zero on failure\\r\\n    function getRawPrice(address token) public view returns (uint) {\\r\\n        uint pegPrice = pegTokenPrice(token);\\r\\n        if (pegPrice != 0) return pegPrice;\\r\\n\\r\\n        return getRawPrice(token, getNativePrice());\\r\\n    }\\r\\n\\r\\n    //returns the prices of multiple tokens, zero on failure\\r\\n    function getRawPrices(address[] memory tokens) public view returns (uint[] memory prices) {\\r\\n        prices = new uint[](tokens.length);\\r\\n        uint nativePrice = getNativePrice();\\r\\n\\r\\n        for (uint i; i < prices.length; i++) {\\r\\n            address token = tokens[i];\\r\\n\\r\\n            uint pegPrice = pegTokenPrice(token, nativePrice);\\r\\n            if (pegPrice != 0) prices[i] = pegPrice;\\r\\n            else prices[i] = getRawPrice(token, nativePrice);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //returns the value of a LP token if it is one, or the regular price if it isn't LP\\r\\n    function getRawLPPrice(address token) internal view returns (uint) {\\r\\n        uint pegPrice = pegTokenPrice(token);\\r\\n        if (pegPrice != 0) return pegPrice;\\r\\n\\r\\n        return getRawLPPrice(token, getNativePrice());\\r\\n    }\\r\\n\\r\\n    //returns the prices of multiple tokens which may or may not be LPs\\r\\n    function getRawLPPrices(address[] memory tokens) internal view returns (uint[] memory prices) {\\r\\n        prices = new uint[](tokens.length);\\r\\n        uint nativePrice = getNativePrice();\\r\\n\\r\\n        for (uint i; i < prices.length; i++) {\\r\\n            address token = tokens[i];\\r\\n\\r\\n            uint pegPrice = pegTokenPrice(token, nativePrice);\\r\\n            if (pegPrice != 0) prices[i] = pegPrice;\\r\\n            else prices[i] = getRawLPPrice(token, nativePrice);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //returns the current USD price of ETH based on primary stablecoin pairs\\r\\n    function getNativePrice() public view returns (uint) {\\r\\n        (uint usdcReserve, uint nativeReserve1,) = IApePair(USDC_NATIVE_PAIR).getReserves();\\r\\n        uint nativeTotal = nativeReserve1;\\r\\n        uint usdTotal = usdcReserve;\\r\\n    \\r\\n        return usdTotal * PRECISION / USDC_RAW_PRICE * PRECISION  / nativeTotal;\\r\\n    }\\r\\n\\r\\n    //Calculate LP token value in USD. Generally compatible with any UniswapV2 pair but will always price underlying\\r\\n    //tokens using ape prices. If the provided token is not a LP, it will attempt to price the token as a\\r\\n    //standard token. This is useful for MasterChef farms which stake both single tokens and pairs\\r\\n    function getRawLPPrice(address lp, uint nativePrice) internal view returns (uint) {\\r\\n        //if not a LP, handle as a standard token\\r\\n        try IApePair(lp).getReserves() returns (uint112 reserve0, uint112 reserve1, uint32) {\\r\\n            address token0 = IApePair(lp).token0();\\r\\n            address token1 = IApePair(lp).token1();\\r\\n            uint totalSupply = IApePair(lp).totalSupply();\\r\\n\\r\\n            //price0*reserve0+price1*reserve1\\r\\n            uint totalValue = getRawPrice(token0, nativePrice) * reserve0 + getRawPrice(token1, nativePrice) * reserve1;\\r\\n\\r\\n            return totalValue / totalSupply;\\r\\n\\r\\n        } catch {\\r\\n            return getRawPrice(lp, nativePrice);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // checks for primary tokens and returns the correct predetermined price if possible, otherwise calculates price\\r\\n    function getRawPrice(address token, uint nativePrice) internal view returns (uint rawPrice) {\\r\\n        uint pegPrice = pegTokenPrice(token, nativePrice);\\r\\n        if (pegPrice != 0) return pegPrice;\\r\\n\\r\\n        uint numTokens;\\r\\n        uint pairedValue;\\r\\n        uint lpTokens;\\r\\n        uint lpValue;\\r\\n\\r\\n        (lpTokens, lpValue) = pairTokensAndValue(token, NATIVE);\\r\\n        numTokens += lpTokens;\\r\\n        pairedValue += lpValue;\\r\\n\\r\\n        (lpTokens, lpValue) = pairTokensAndValue(token, USDC);\\r\\n        numTokens += lpTokens;\\r\\n        pairedValue += lpValue;\\r\\n\\r\\n        if (numTokens > 0) return pairedValue / numTokens;\\r\\n    }\\r\\n\\r\\n    //if one of the peg tokens, returns that price, otherwise zero\\r\\n    function pegTokenPrice(address token, uint nativePrice) private pure returns (uint) {\\r\\n        if (token == USDC) return PRECISION*1e12;\\r\\n        if (token == NATIVE) return nativePrice;\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function pegTokenPrice(address token) private view returns (uint) {\\r\\n        if (token == USDC) return PRECISION*1e12;\\r\\n        if (token == NATIVE) return getNativePrice();\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    //returns the number of tokens and the USD value within a single LP. peg is one of the listed primary, pegPrice is the predetermined USD value of this token\\r\\n    function pairTokensAndValue(address token, address peg) private view returns (uint tokenNum, uint pegValue) {\\r\\n        address tokenPegPair = pairFor(token, peg);\\r\\n\\r\\n        // if the address has no contract deployed, the pair doesn't exist\\r\\n        uint256 size;\\r\\n        assembly { size := extcodesize(tokenPegPair) }\\r\\n        if (size == 0) return (0,0);\\r\\n\\r\\n        try IApePair(tokenPegPair).getReserves() returns (uint112 reserve0, uint112 reserve1, uint32) {\\r\\n            uint reservePeg;\\r\\n            (tokenNum, reservePeg) = token < peg ? (reserve0, reserve1) : (reserve1, reserve0);\\r\\n            pegValue = reservePeg * pegTokenPrice(peg);\\r\\n        } catch {\\r\\n            return (0,0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //normalize a token price to a specified number of decimals\\r\\n    function normalize(uint price, address token, uint _decimals) private view returns (uint) {\\r\\n        uint tokenDecimals;\\r\\n\\r\\n        try IERC20(token).decimals() returns (uint8 dec) {\\r\\n            tokenDecimals = dec;\\r\\n        } catch {\\r\\n            tokenDecimals = 18;\\r\\n        }\\r\\n\\r\\n        if (tokenDecimals + _decimals <= 2*DECIMALS) return price / 10**(2*DECIMALS - tokenDecimals - _decimals);\\r\\n        else return price * 10**(_decimals + tokenDecimals - 2*DECIMALS);\\r\\n    }\\r\\n\\r\\n    // calculates the CREATE2 address for a pair without making any external calls\\r\\n    function pairFor(address tokenA, address tokenB) private view returns (address pair) {\\r\\n        IApeFactory factory = IApeFactory(FACTORY);\\r\\n        return factory.getPair(tokenA, tokenB);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IApePair.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\r\\n\\r\\ninterface IApePair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IApeFactory.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.6;\\r\\n\\r\\ninterface IApeFactory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"}],\"name\":\"getLPPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"}],\"name\":\"getLPPrices\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNativePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"}],\"name\":\"getPrices\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getRawPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getRawPrices\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ApeOnlyPriceGetter", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}