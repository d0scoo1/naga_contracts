{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, 'ds-math-add-overflow');\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\r\n    }\r\n\r\n    function sub(uint x, uint y, string memory errorMessage) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, errorMessage);\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint z) {\r\n        require(b > 0);\r\n        z = a / b;\r\n    }\r\n}\r\n\r\nlibrary Math {\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary FalconSwapV3Library {\r\n    using SafeMath for uint;\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'FalconSwapV3Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'FalconSwapV3Library: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'FalconSwapV3Library: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'FalconSwapV3Library: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n    \r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    \r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    \r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    \r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    \r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    \r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n    \r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint;\r\n\r\n    string public constant name = 'FalconSwap V3';\r\n    string public constant symbol = 'FSW-V3';\r\n    uint8 public constant decimals = 18;\r\n    uint  public totalSupply;\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    constructor() {}\r\n\r\n    function _mint(address to, uint value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) external returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool) {\r\n        if (allowance[from][msg.sender] != type(uint).max) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract FalconSwapV3Pool is ERC20 {\r\n    using SafeMath for uint;\r\n    using SafeERC20 for IERC20;\r\n\r\n    address public token;\r\n    address public factory;\r\n    bool isSetup;\r\n\r\n    event Sync(uint reserve0, uint reserve1);\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'txn expired');\r\n        _;\r\n    }\r\n\r\n    constructor() { }\r\n\r\n    // for uniswap compatibility\r\n    function token0() external pure returns (address) { return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; }\r\n    function token1() external view returns (address) { return token; }\r\n    function reserve0() external view returns (uint) { return address(this).balance; }\r\n    function reserve1() external view returns (uint) { return IERC20(token).balanceOf(address(this)); }\r\n    function getReserves() external view returns(uint, uint, uint) {\r\n        return (\r\n            address(this).balance,\r\n            IERC20(token).balanceOf(address(this)),\r\n            block.timestamp\r\n        );\r\n    }\r\n    // end\r\n\r\n    function setup(address _token) external {\r\n        require(!isSetup, \"Already Setup\");\r\n        isSetup = true;\r\n        token = _token;\r\n        factory = msg.sender;\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'ETH transfer failed');\r\n    }\r\n\r\n    // Swap Functions ->\r\n    function swapExactETHForTokens(uint _tokenAmountMin, address to, uint deadline) payable external ensure(deadline) returns (uint _tokenAmount) {\r\n        IERC20 _token_inter = IERC20(token);\r\n        uint reserveEth = (address(this).balance).sub(msg.value);\r\n        uint reserveToken = _token_inter.balanceOf(address(this));\r\n        \r\n        _tokenAmount = FalconSwapV3Library.getAmountOut(msg.value, reserveEth, reserveToken);\r\n        require(_tokenAmountMin <= _tokenAmount, \"slippage issue\");\r\n        _token_inter.safeTransfer(to, _tokenAmount);\r\n\r\n        emit Swap(msg.sender, msg.value, 0, 0, _tokenAmount, to);\r\n        emit Sync(reserveEth.add(msg.value), reserveToken.sub(_tokenAmount));\r\n    }\r\n    \r\n    function swapETHForExactTokens(uint _tokenAmount, address to, uint deadline) payable external ensure(deadline) returns (uint _ethAmount) {\r\n        IERC20 _token_inter = IERC20(token);\r\n        uint reserveEth = (address(this).balance).sub(msg.value);\r\n        uint reserveToken = _token_inter.balanceOf(address(this));\r\n        \r\n        _ethAmount = FalconSwapV3Library.getAmountIn(_tokenAmount, reserveEth, reserveToken);\r\n        require(_ethAmount <= msg.value, \"slippage issue\");\r\n        _token_inter.safeTransfer(to, _tokenAmount);\r\n\r\n        if(msg.value > _ethAmount){\r\n            safeTransferETH(msg.sender, msg.value.sub(_ethAmount));\r\n        }\r\n\r\n        emit Swap(msg.sender, _ethAmount, 0, 0, _tokenAmount, to);\r\n        emit Sync(reserveEth.add(_ethAmount), reserveToken.sub(_tokenAmount));\r\n    }\r\n\r\n    function swapExactTokensForETH(uint _tokenAmount, uint _ethAmountMin, address to, uint deadline) external ensure(deadline) returns (uint _ethAmount) {\r\n        IERC20 _token_inter = IERC20(token);\r\n        uint reserveEth = address(this).balance;\r\n        uint reserveToken = _token_inter.balanceOf(address(this));\r\n        \r\n        _ethAmount = FalconSwapV3Library.getAmountOut(_tokenAmount, reserveToken, reserveEth);\r\n        require(_ethAmountMin <= _ethAmount, \"slippage issue\");\r\n        _token_inter.safeTransferFrom(msg.sender, address(this), _tokenAmount);\r\n        safeTransferETH(to, _ethAmount);\r\n\r\n        emit Swap(msg.sender, 0, _tokenAmount, _ethAmount, 0, to);\r\n        emit Sync(reserveEth.sub(_ethAmount), reserveToken.add(_tokenAmount));\r\n    }\r\n\r\n    function swapTokensForExactETH(uint _ethAmount, uint _tokenAmountMax, address to, uint deadline) external ensure(deadline) returns (uint _tokenAmount) {\r\n        IERC20 _token_inter = IERC20(token);\r\n        uint reserveEth = address(this).balance;\r\n        uint reserveToken = _token_inter.balanceOf(address(this));\r\n        \r\n        _tokenAmount = FalconSwapV3Library.getAmountIn(_ethAmount, reserveToken, reserveEth);\r\n        require(_tokenAmount <= _tokenAmountMax, \"slippage issue\");\r\n        _token_inter.safeTransferFrom(msg.sender, address(this), _tokenAmount);\r\n        safeTransferETH(to, _ethAmount);\r\n\r\n        emit Swap(msg.sender, 0, _tokenAmount, _ethAmount, 0, to);\r\n        emit Sync(reserveEth.sub(_ethAmount), reserveToken.add(_tokenAmount));\r\n    }\r\n\r\n    // add Liquidity ->\r\n    function _addLiquidityETHinternal(uint _tokenAmountMin, uint _tokenAmountMax, address from, address to) internal returns (uint liquidity) {\r\n        require(msg.value > 0 && _tokenAmountMin > 0, 'invalid amounts');\r\n        uint _ethAmount = msg.value;\r\n        IERC20 _token_inter = IERC20(token);\r\n\r\n        uint reserveEth = (address(this).balance).sub(msg.value);\r\n        uint reserveToken = _token_inter.balanceOf(address(this));\r\n        uint _totalSupply = totalSupply;\r\n\r\n        uint _tokenAmount;\r\n        if(_totalSupply > 0){\r\n            _tokenAmount = ( msg.value.mul( reserveToken ) ).div(reserveEth);\r\n            require(_tokenAmount >= _tokenAmountMin, \"wrong token ratio\");\r\n            require(_tokenAmount <= _tokenAmountMax, \"wrong token ratio\");\r\n        } \r\n        else {\r\n            _tokenAmount = _tokenAmountMin;\r\n        }\r\n\r\n        _token_inter.safeTransferFrom(from, address(this), _tokenAmount);\r\n\r\n        require(reserveToken == (_token_inter.balanceOf(address(this))).sub(_tokenAmount), 'deflationary tokens not supported');\r\n\r\n        if (_totalSupply == 0) {\r\n            liquidity = Math.sqrt(_ethAmount.mul(_tokenAmount)).sub(10**3);\r\n           _mint(address(0), 10**3);\r\n        } else {\r\n            liquidity = Math.min(_ethAmount.mul(_totalSupply) / reserveEth, _tokenAmount.mul(_totalSupply) / reserveToken);\r\n        }\r\n        require(liquidity > 0, 'liquidity mint issue');\r\n\r\n        uint _fee = FalconSwapV3factory(factory).fee();\r\n        if(_fee > 0){\r\n            uint _feeAmount = ( liquidity.mul(_fee) ).div(10**5);\r\n            _mint(FalconSwapV3factory(factory).protocolManager(), _feeAmount);\r\n            liquidity = liquidity.sub(_feeAmount);\r\n        }\r\n\r\n        _mint(to, liquidity);\r\n\r\n        emit Mint(from, _ethAmount, _tokenAmount);\r\n    }\r\n\r\n    function addLiquidityETHonCreate(uint _tokenAmountMin, uint _tokenAmountMax, address from, address to, uint deadline) payable external ensure(deadline) returns (uint liquidity) {\r\n        require(msg.sender == factory, 'dont be so smart');\r\n        liquidity = _addLiquidityETHinternal(_tokenAmountMin, _tokenAmountMax, from, to);\r\n    }\r\n    \r\n    function addLiquidityETH(uint _tokenAmountMin, uint _tokenAmountMax, address to, uint deadline) payable external ensure(deadline) returns (uint liquidity) {\r\n        liquidity = _addLiquidityETHinternal(_tokenAmountMin, _tokenAmountMax, msg.sender, to);\r\n    }\r\n\r\n    function removeLiquidity(uint liquidity, address to, uint deadline) external ensure(deadline) returns (uint _ethAmount, uint _tokenAmount) {\r\n        require(liquidity > 0, 'no liquidity');\r\n        IERC20 _token_inter = IERC20(token);\r\n\r\n        uint reserveEth = address(this).balance;\r\n        uint reserveToken = _token_inter.balanceOf(address(this));\r\n\r\n        uint _totalSupply = totalSupply; \r\n        _ethAmount = liquidity.mul(reserveEth) / _totalSupply; \r\n        _tokenAmount = liquidity.mul(reserveToken) / _totalSupply; \r\n        require(_ethAmount > 0 && _tokenAmount > 0, 'liquidity burn issue');\r\n\r\n        _burn(msg.sender, liquidity);\r\n\r\n        _token_inter.safeTransfer(to, _tokenAmount);\r\n        safeTransferETH(to, _ethAmount);\r\n\r\n        emit Burn(msg.sender, _ethAmount, _tokenAmount, to);\r\n    }\r\n    \r\n    function rescueTokens(address _token, address to) external {\r\n        require(msg.sender == factory, 'dont be so smart');\r\n        require(_token != token, \"can't rescue base token\");\r\n        IERC20(_token).safeTransfer(to, IERC20(_token).balanceOf(address(this)));\r\n    }\r\n}\r\n\r\ncontract FalconSwapV3factory {\r\n    uint public fee;\r\n    address public pairCodeAddress;\r\n    address public protocolManager;\r\n\r\n    mapping(address => address) public getPair;\r\n    address[] public allPairs;\r\n\r\n    event PairCreated(address indexed token, address pair, uint);\r\n    event protocolManagerChanged(address indexed previousManager, address indexed newManager);\r\n    event feeUpdated(uint previousFee, uint newFee);\r\n\r\n    modifier onlyOwner() {\r\n        require(protocolManager == msg.sender, \"no access\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        protocolManager = msg.sender;\r\n        FalconSwapV3Pool pairContract = new FalconSwapV3Pool();\r\n        pairCodeAddress = address(pairContract);\r\n    }\r\n\r\n    function allPairsLength() external view returns (uint) {\r\n        return allPairs.length;\r\n    }\r\n\r\n    function createPair(address token) public returns (address pair) {\r\n        require(token != address(0), 'zero address');\r\n        require(getPair[token] == address(0), 'pair already created');\r\n\r\n        address payable _proxyAddress;\r\n        bytes20 targetBytes = bytes20(pairCodeAddress);\r\n        bytes32 salt = keccak256(abi.encodePacked(token));\r\n        \r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            _proxyAddress := create2(0, clone, 0x37, salt)\r\n        }\r\n        \r\n        pair = address(_proxyAddress);\r\n        FalconSwapV3Pool(pair).setup(token);\r\n\r\n        getPair[token] = pair;\r\n        allPairs.push(pair);\r\n        emit PairCreated(token, pair, allPairs.length);\r\n    }\r\n\r\n    function createPairWithAddLiquidityETH(address token, uint _tokenAmountMin, uint _tokenAmountMax, address to, uint deadline) payable external returns (address pair, uint liquidity) {\r\n        pair = getPair[token];\r\n        if(pair == address(0)){ pair = createPair(token); }\r\n        liquidity = FalconSwapV3Pool(pair).addLiquidityETHonCreate{value: msg.value}(_tokenAmountMin, _tokenAmountMax, msg.sender, to, deadline);\r\n    }\r\n    \r\n    function changeFee(uint _fee) external onlyOwner {\r\n        require(_fee < 10000, \"invalid fee\");\r\n        emit feeUpdated(fee, _fee);\r\n        fee = _fee;\r\n    }\r\n    \r\n    function changeProtocolManager(address _protocolManager) external onlyOwner {\r\n        require(_protocolManager != address(0), \"zero address\");\r\n        emit protocolManagerChanged(protocolManager, _protocolManager);\r\n        protocolManager = _protocolManager;\r\n    }\r\n    \r\n    function rescueTokens(address token, address to) external onlyOwner {\r\n        require(token != address(0), \"zero address\");\r\n        require(token != to, \"to / token issue\");\r\n        require(IERC20(token).transfer(to, IERC20(token).balanceOf(address(this))), \"can't process\");\r\n    }\r\n\r\n    function rescueTokensFromPool(address pool, address token, address to) external onlyOwner {\r\n        require(pool != address(0), \"zero address\");\r\n        require(token != address(0), \"zero address\");\r\n        require(token != to, \"to / token issue\");\r\n        FalconSwapV3Pool(pool).rescueTokens(token, to);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"feeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"protocolManagerChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allPairsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"changeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocolManager\",\"type\":\"address\"}],\"name\":\"changeProtocolManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmountMax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"createPairWithAddLiquidityETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairCodeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"rescueTokensFromPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FalconSwapV3factory", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a73bafd87f3ee2403583b214eebb9c9775e01a9a390e245e4f906bc1b2542885"}]}