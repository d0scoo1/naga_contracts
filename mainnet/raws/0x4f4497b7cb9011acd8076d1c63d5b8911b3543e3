{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity 0.4.25;\r\n\r\n\r\ncontract Acquis {\r\n    using SafeMath for uint256;\r\n\r\n    address public proprio;             //  Propi\u00e8taire du contrat\r\n    address public nouveauProprio;      //  tmp pour la passation \u00e9ventuelle de pouvoir\r\n    \r\n    event changementProprio ( address indexed _de, address indexed _a );\r\n    \r\n    modifier proprioSeulement {\r\n        require ( msg.sender == proprio );\r\n        _;\r\n    }\r\n    \r\n    function changerProprio ( address _nouveauProprio ) public proprioSeulement {\r\n        nouveauProprio = _nouveauProprio;\r\n    }\r\n        \r\n    function confirmerNouveauProprio() public {\r\n        require ( msg.sender == nouveauProprio );\r\n        emit changementProprio ( proprio, nouveauProprio );\r\n        proprio = nouveauProprio;\r\n        delete nouveauProprio;\r\n    }\r\n    \r\n}\r\ninterface ReceveurDeTokens {\r\n    \r\n    function recevoirApprobation ( address _de, uint256 _montant, address _token ) external;\r\n    \r\n}\r\ncontract TokenERC20 {\r\n    \r\n    // Variables publiques du token.\r\n    string public nom;\r\n    string public symbole;\r\n    uint8 public decimales = 18;\r\n    // 18 d\u00e9cimales par d\u00e9faut, fortement recommand\u00e9.\r\n    uint256 public sommeTotale;\r\n\r\n    // Cr\u00e9ation d'untableau avec tous les comptes.\r\n    mapping ( address => uint256 ) public comptes;\r\n    mapping ( address => mapping ( address => uint256 ) ) public autorisations;\r\n\r\n    // G\u00e9n\u00e8re un \u00e9v\u00e8nement publique sur la BlocCha\u00eene qui notifie les clients.\r\n    event Transfert ( address indexed de, address indexed a, uint256 somme );\r\n\r\n    // Notifie les clients du montant br\u00fbl\u00e9.\r\n    event Brules ( address indexed from, uint256 value );\r\n\r\n\r\n    /**\r\n     * Constrcteur\r\n     *\r\n     * Initialise le contrat et donne la sommeTotale au proprio du contrat.\r\n     */\r\n            constructor ( uint256 sommeInitiale, string nomToken, string symboleToken ) public {\r\n                \r\n                sommeTotale = sommeInitiale * 10 ** uint256 ( decimales );  // Met \u00e0 jour la sommeTotale.\r\n                comptes[msg.sender] = sommeTotale;                          // Donne au cr\u00e9ateur tous les tokens.\r\n                nom = nomToken;                                             // Nom complet du token.\r\n                symbole = symboleToken;                                     // Symbole du token.\r\n                \r\n            }\r\n\r\n\r\n    /**\r\n     * Transfert interne, ne peut \u00eatre appel\u00e9 que par ce contrat.\r\n     */\r\n    function _transfert ( address _de, address _a, uint _somme ) internal {\r\n        require ( _de != 0x0);\r\n        require ( comptes[_de] >= _somme );\r\n        require ( comptes[_a] + _somme > comptes[_a] );\r\n        uint balancePrecedente = comptes[_de] + comptes[_a];\r\n        comptes[_de] -= _somme;\r\n        comptes[_a] += _somme;\r\n        emit Transfert ( _de, _a, _somme );\r\n        assert ( comptes[_de] + comptes[_a] == balancePrecedente );\r\n    }\r\n\r\n    /**\r\n     * Transfert de tokens\r\n     *\r\n     * Envoie `_valeur` tokens \u00e0 `_a` de votre compte.\r\n     *\r\n     * @param _a l'adresse du receveur\r\n     * @param _valeur le montant de l'envoi\r\n     */\r\n    function transfert ( address _a, uint256 _valeur ) public {\r\n        _transfert ( msg.sender, _a, _valeur );\r\n    }\r\n\r\n    /**\r\n     * Transfert de tokens depuis une autre addresse\r\n     *\r\n     * Envoie `_valeur` tokens \u00e0 `_a` au nom de `_de`\r\n     *\r\n     * @param _de L'adress de l'envoyeur.\r\n     * @param _a L'adresse du receveur.\r\n     * @param _valeur Le montant \u00e0 envoyer.\r\n     */\r\n    function transferFrom ( address _de, address _a, uint256 _valeur ) public returns ( bool succes ) {\r\n        require ( _valeur <= autorisations[_de][msg.sender] );     // Check allowance\r\n        autorisations[_de][msg.sender] -= _valeur;\r\n        _transfert ( _de, _a, _valeur );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * D\u00e9finir une autorisation pour une autre adresse\r\n     *\r\n     * Autorise `_depenseur` \u00e0 ne pas d\u00e9penser plus que `_valeur` tokens en votre nom\r\n     *\r\n     * @param _depenseur L'adresse autoris\u00e9e \u00e0 d\u00e9penser.\r\n     * @param _valeur Le montant maximum \u00e0 d\u00e9penser.\r\n     */\r\n    function approuver ( address _depenseur, uint256 _valeur ) public returns ( bool succes ) {\r\n        autorisations[msg.sender][_depenseur] = _valeur;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * D\u00e9finir une autorisation pour une autre adresse et le notifier\r\n     *\r\n     * Autorise `_depenseur` \u00e0 ne pas d\u00e9penser plus que `_valeur` tokens en votre nom et le notifie\r\n     *\r\n     * @param _depenseur L'adresse autoris\u00e9e \u00e0 d\u00e9penser.\r\n     * @param _valeur Le montant maximum \u00e0 d\u00e9penser.\r\n     * @param _extraData Des donn\u00e9es externes \u00e0 envoyer au contrat.\r\n     */\r\n    function approveAndCall ( address _depenseur, uint256 _valeur, bytes _extraData ) public returns ( bool success ) {\r\n        ReceveurDeTokens depenseur = ReceveurDeTokens ( _depenseur );\r\n        if ( approuver ( _depenseur, _valeur ) ) {\r\n            depenseur.recevoirApprobation ( msg.sender, _valeur, this );\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destruction de tokens\r\n     *\r\n     * Retire `_valeur` tokens du syst\u00e8me de mani\u00e8re irr\u00e9versible\r\n     *\r\n     * @param _valeur Le montant de tokens \u00e0 bruler.\r\n     */\r\n    function bruler ( uint256 _valeur ) public returns ( bool succes ) {\r\n        require ( comptes[msg.sender] >= _valeur );   // Check if the sender has enough\r\n        comptes[msg.sender] -= _valeur;            // Subtract from the sender\r\n        sommeTotale -= _valeur;                      // Updates totalSupply\r\n        emit Brules ( msg.sender, _valeur );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destruction de tokens d'un autre compte'\r\n     *\r\n     * Retire `_valeur` tokens du syst\u00e8me de mani\u00e8re irr\u00e9versible au nom de '_de'\r\n     *\r\n     * @param _de L'adresse de l'envoyeur.\r\n     * @param _valeur Le montant de tokens \u00e0 br\u00fbler.\r\n     */\r\n    function brulerDe ( address _de, uint256 _valeur ) public returns ( bool success ) {\r\n        require ( comptes[_de] >= _valeur );                // Check if the targeted balance is enough\r\n        require ( _valeur <= autorisations[_de][msg.sender] );    // Check allowance\r\n        comptes[_de] -= _valeur;                         // Subtract from the targeted balance\r\n        autorisations[_de][msg.sender] -= _valeur;             // Subtract from the sender's allowance\r\n        sommeTotale -= _valeur;                              // Update totalSupply\r\n        emit Brules ( _de, _valeur );\r\n        return true;\r\n    }\r\n    \r\n}\r\n/******************************************/\r\n/*       LE TOKEN AVANC\u00e9 COMMENCE ICI     */\r\n/******************************************/\r\ncontract MonTokenAvance is Acquis, TokenERC20 {\r\n\r\n    uint256 public prixDeVente;\r\n    uint256 public prixDAchat;\r\n\r\n    mapping ( address => bool ) public comptesGeles;\r\n\r\n    /* G\u00e9n\u00e8re un \u00e9v\u00e8nement publique sur la BlocCha\u00eene qui notifie les clients. */\r\n    event ComptesGeles ( address cible, bool gele );\r\n\r\n\r\n    /* Initialise le contrat et donne la sommeTotale au proprio du contrat. */\r\n            constructor ( uint256 sommeInitiale, string nomToken, string symboleToken )\r\n                TokenERC20 ( sommeInitiale, nomToken, symboleToken ) public {\r\n                \r\n                proprio = msg.sender;\r\n                \r\n            }\r\n\r\n        \r\n    /* Transfert interne, ne peut \u00eatre appel\u00e9 que par ce contrat. */\r\n    function _transfert ( address _de, address _a, uint _valeur ) internal {\r\n        require ( _a != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\r\n        require ( comptes[_de] >= _valeur );               // Check if the sender has enough\r\n        require ( comptes[_a] + _valeur > comptes[_a]); // Check for overflows\r\n        require ( !comptesGeles[_de] );                     // Check if sender is frozen\r\n        require( !comptesGeles[_a] );                       // Check if recipient is frozen\r\n        comptes[_de] -= _valeur;                         // Subtract from the sender\r\n        comptes[_a] += _valeur;                           // Add the same to the recipient\r\n        emit Transfert ( _de, _a, _valeur );\r\n    }\r\n\r\n\r\n    /// @notice Cr\u00e9e un `montantMine` de tokens et l'envoie \u00e0 `cible`\r\n    /// @param cible Adresse qui re\u00e7oit les tokens.\r\n    /// @param montantMine Le montant de tokens \u00e0 recevoir.\r\n    function minerToken ( address cible, uint256 montantMine ) proprioSeulement public {\r\n        comptes[cible] += montantMine;\r\n        sommeTotale += montantMine;\r\n        emit Transfert ( 0, this, montantMine );\r\n        emit Transfert ( this, cible, montantMine );\r\n    }\r\n\r\n    /// @notice `gelerCompte? Interdit | Autorise` `cible` \u00e0 envoyer et recevoir des tokens\r\n    /// @param cible L'adresse \u00e0 geler.\r\n    /// @param gele Bool\u00e9en gel\u00e9/pas gel\u00e9.\r\n    function gelerCompte ( address cible, bool gele ) proprioSeulement public {\r\n        comptesGeles[cible] = gele;\r\n        emit ComptesGeles ( cible, gele );\r\n    }\r\n\r\n    /// @notice Autorise les utilisateurs \u00e0 acheter des tokens \u00e0 `nouvPrixDAchat` eth et \u00e0 vendre des tokens pour `nouvPrixDeVente` eth\r\n    /// @param nouvPrixDeVente Prix auquel les utilisateurs peuvent vendre des tokens au contrat.\r\n    /// @param nouvPrixDAchat Prix auquel les utilisateurs peuvent acheter des tokens.\r\n    function setPrix ( uint256 nouvPrixDeVente, uint256 nouvPrixDAchat ) proprioSeulement public {\r\n        prixDeVente = nouvPrixDeVente;\r\n        prixDAchat = nouvPrixDAchat;\r\n    }\r\n\r\n    /// @notice Acheter des tokens du contrat en envoyant des ethers\r\n    function acheter() payable public {\r\n        uint montant = msg.value / prixDAchat;               // calcule le montant\r\n        _transfert ( this, msg.sender, montant );            // fais le transfert\r\n    }\r\n\r\n    /// @notice Vend `montant` tokens au contrat\r\n    /// @param montant Montant de tokens \u00e0 vendre.\r\n    function vendre ( uint256 montant ) public {\r\n        require( address ( this ).balance >= montant * prixDeVente );// v\u00e9rifie si le contrat a assez d'ethers pour acheter\r\n        _transfert ( msg.sender, this, montant );           // fait le transfert\r\n        msg.sender.transfer ( montant * prixDeVente );      // envoie les ethers au vendeur. Il est important de le faire endernier afin d'\u00e9viter toute attaque de r\u00e9cursion'\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[],\"name\":\"acheter\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimales\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmerNouveauProprio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_depenseur\",\"type\":\"address\"},{\"name\":\"_valeur\",\"type\":\"uint256\"}],\"name\":\"approuver\",\"outputs\":[{\"name\":\"succes\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"comptes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_de\",\"type\":\"address\"},{\"name\":\"_a\",\"type\":\"address\"},{\"name\":\"_valeur\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"succes\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cible\",\"type\":\"address\"},{\"name\":\"gele\",\"type\":\"bool\"}],\"name\":\"gelerCompte\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nouveauProprio\",\"type\":\"address\"}],\"name\":\"changerProprio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proprio\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_a\",\"type\":\"address\"},{\"name\":\"_valeur\",\"type\":\"uint256\"}],\"name\":\"transfert\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nouvPrixDeVente\",\"type\":\"uint256\"},{\"name\":\"nouvPrixDAchat\",\"type\":\"uint256\"}],\"name\":\"setPrix\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_valeur\",\"type\":\"uint256\"}],\"name\":\"bruler\",\"outputs\":[{\"name\":\"succes\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"autorisations\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nouveauProprio\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sommeTotale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"montant\",\"type\":\"uint256\"}],\"name\":\"vendre\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prixDeVente\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"comptesGeles\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prixDAchat\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_depenseur\",\"type\":\"address\"},{\"name\":\"_valeur\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nom\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cible\",\"type\":\"address\"},{\"name\":\"montantMine\",\"type\":\"uint256\"}],\"name\":\"minerToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbole\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_de\",\"type\":\"address\"},{\"name\":\"_valeur\",\"type\":\"uint256\"}],\"name\":\"brulerDe\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"sommeInitiale\",\"type\":\"uint256\"},{\"name\":\"nomToken\",\"type\":\"string\"},{\"name\":\"symboleToken\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"cible\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"gele\",\"type\":\"bool\"}],\"name\":\"ComptesGeles\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"de\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"a\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"somme\",\"type\":\"uint256\"}],\"name\":\"Transfert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Brules\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_de\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"changementProprio\",\"type\":\"event\"}]", "ContractName": "MonTokenAvance", "CompilerVersion": "v0.4.25+commit.59dbf8f1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000001406f40000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000009436f736d6f436f696e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005434f534d4f000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://3ad7d2c7cff9b3e2f17768ab4dc240f9aa89529e150f3dd9baeaa1a7ac9dd2a4"}]}