{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/BlockInvadersMotherShip.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.6;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Base64.sol\\\";\\r\\nimport \\\"./stringutils.sol\\\";\\r\\nimport \\\"./stringutils2.sol\\\";\\r\\n\\r\\n\\r\\n//\\r\\n//\\r\\n//                              ///                                      \\r\\n//                           ////////                                    \\r\\n//                         /////////////                                 \\r\\n//                     //////////////////                               \\r\\n//                   ///////////////////////                            \\r\\n//                ////////////////////////////                          \\r\\n//    &&&&&&&&&     ////////////////////////     &&&&&&&&&&             \\r\\n//                     ///////////////////                              \\r\\n//      &&&&&&&&&&&      //////////////      &&&&&&&&&&&&               \\r\\n//      &&&&&&&&&&&&&&      /////////     &&&&&&&&&&&&&&&               \\r\\n//                &&&&&&      ////      &&&&&&&                         \\r\\n//                  &&&&&&&          &&&&&&&                            \\r\\n//            &&&&&    &&&&&&      &&&&&&&   &&&&&                      \\r\\n//               &&&&&   &&&&&&&&&&&&&&    &&&&&                        \\r\\n//                 &&&&&    &&&&&&&&&   &&&&&                           \\r\\n//                    &&&&&   &&&&    &&&&&                             \\r\\n//                      &&&&&      &&&&&                                \\r\\n//                         &&&&& &&&&&                                  \\r\\n//                           &&&&&&                                     \\r\\n//                             &&                                       \\r\\n//                                                                      \\r\\n//                                                                      \\r\\n//                      &&&     &&&&&    &&                             \\r\\n//                    &&   &&   &&   &&  &&                             \\r\\n//                   &&     &&  &&&&&&&  &&                             \\r\\n//                    &&   &&   &&&   && &&                             \\r\\n//                      &&&     &&&& &&  &&            \\r\\n//\\r\\n//========================================================================\\r\\n// ONCHAIN BLOCK INVADERS - Upgradable Skin Renderer and Storage contract\\r\\n\\r\\ninterface ICargoShip  {\\r\\n    function isCargoShip() external pure returns (bool);\\r\\n    function unloadChroma(uint256 idx) external view returns (string[] memory,string[] memory,string[] memory,string[] memory,string memory,string memory);\\r\\n}\\r\\n\\r\\ncontract BlockInvadersMotherShip is ReentrancyGuard, Ownable {\\r\\n    using strings for *;\\r\\n        \\r\\n    uint256 constant BODY_COUNT  = 17;\\r\\n    uint256 constant HEAD_COUNT  = 17;\\r\\n    uint256 constant EYES_COUNT  = 32;\\r\\n    uint256 constant MOUTH_COUNT = 21;\\r\\n    \\r\\n    struct dataStruct {\\r\\n        string buffer;\\r\\n        string prop;\\r\\n        uint8 Cnt;\\r\\n        uint8 tCnt;\\r\\n        uint8 oCnt;\\r\\n    }\\r\\n    \\r\\n   struct compIndexStruct {\\r\\n        uint256 id0;  \\r\\n        uint256 id1; \\r\\n        uint256 id2; \\r\\n        uint256 id3; \\r\\n        uint256 id4;\\r\\n        uint256 idColH;\\r\\n        uint256 idColB;\\r\\n        }   \\r\\n\\r\\n    //main data storage\\r\\n    struct skinStruct{\\r\\n    dataStruct[BODY_COUNT] bodies;\\r\\n    dataStruct[HEAD_COUNT] heads;\\r\\n    dataStruct[EYES_COUNT] eyes;\\r\\n    dataStruct[MOUTH_COUNT] mouths;\\r\\n    string skinName;\\r\\n    }\\r\\n\\r\\n    struct paintStruct{\\r\\n    string[] eyesColor;\\r\\n    string[] color;\\r\\n    string[] backgroundColor;\\r\\n    string[] colName;\\r\\n    string   effect;\\r\\n    string  chromaName;\\r\\n    }\\r\\n    mapping(uint256 => skinStruct) skin;\\r\\n      \\r\\n    //cuting the storing cost and execution costs to more than half using this neet SVG trick !\\r\\n    //string mirror = ' transform= \\\"scale(-1,1) translate(-350,0)\\\"/>';\\r\\n    string mirror = 'IHRyYW5zZm9ybT0gJ3NjYWxlKC0xLDEpIHRyYW5zbGF0ZSgtMzUwLDApJy8+';\\r\\n    //string mirror2 = 'scale(-1,1) translate(-350,0)';\\r\\n    string mirror2 = 'c2NhbGUoLTEsMSkgIHRyYW5zbGF0ZSgtMzUwLDAp';\\r\\n\\r\\n    address private masterAddress ;\\r\\n    address private cargoShipAddress;\\r\\n      \\r\\n    \\r\\n    event MatterStorredLayer1();\\r\\n    event MatterStorredLayer2();\\r\\n    event MasterAddressSet(address masterAddress);\\r\\n    event CargoShipAddressSet(address cargoShipAddress);\\r\\n    \\r\\n    //we lock the contract to be used only with the master address,the mint contract\\r\\n    modifier onlyMaster() {\\r\\n        require(masterAddress == _msgSender(), \\\"Intruder Alert: Access denied in to the mothership\\\");\\r\\n        _;\\r\\n    }\\r\\n   \\r\\n    constructor() Ownable(){ }\\r\\n    \\r\\n    function setMasterAddress(address _masterAddress) public onlyOwner {\\r\\n        //store the address of the mothership contract\\r\\n        masterAddress = _masterAddress;\\r\\n         // Emit the event\\r\\n        emit MasterAddressSet(masterAddress);\\r\\n    }\\r\\n    \\r\\n    function setCargoShipAddress(address _cargoShipAddress) public onlyOwner {\\r\\n        //store the address of the mothership contract\\r\\n        cargoShipAddress = _cargoShipAddress;\\r\\n         // Emit the event\\r\\n        emit CargoShipAddressSet(cargoShipAddress);\\r\\n    }\\r\\n \\r\\n    //Acknowledge contract is `BlockInvadersMothership`;return always true\\r\\n    function isMotherShip() external pure returns (bool) {return true;}\\r\\n  \\r\\n    function storeMatterLayer1(dataStruct[] memory _data,uint256 _idx,string memory _skinName ) external onlyOwner   {\\r\\n        for (uint i = 0; i < BODY_COUNT; i++){\\r\\n        skin[_idx].bodies[i] = _data[i];\\r\\n        }\\r\\n        for (uint i = BODY_COUNT; i < _data.length; i++){\\r\\n            skin[_idx].eyes[i-BODY_COUNT] = _data[i];\\r\\n        }\\r\\n        skin[_idx].skinName= _skinName;\\r\\n        emit MatterStorredLayer1();\\r\\n    }\\r\\n    \\r\\n    function storeMatterLayer2(dataStruct[] memory _data,uint256 _idx ) external onlyOwner   {\\r\\n        for (uint i = 0; i < HEAD_COUNT; i++){\\r\\n            skin[_idx].heads[i] = _data[i];\\r\\n        }\\r\\n        for (uint i = HEAD_COUNT; i < _data.length; i++){\\r\\n            skin[_idx].mouths[i-HEAD_COUNT] = _data[i];\\r\\n        }\\r\\n        emit MatterStorredLayer2();\\r\\n    }\\r\\n\\r\\n    function splitR(strings.slice memory slc,strings.slice memory rune,string memory col) internal pure returns(string memory)\\r\\n    {\\r\\n        return string(abi.encodePacked('PHJlY3QgeD0n',slc.split(rune).toString(),       //<rect x='\\r\\n                                       'JyB5PSAn', slc.split(rune).toString(),          //'y='\\r\\n                                       'JyB3aWR0aD0n',slc.split(rune).toString(),       //'width='\\r\\n                                       'JyBoZWlnaHQ9ICAn',slc.split(rune).toString(),   //'height='\\r\\n                                       'JyAgZmlsbD0g',col ));                           //'fill= \\r\\n    }\\r\\n\\r\\n    function spiltRT(strings.slice memory slc,strings.slice memory rune,string memory col) internal pure returns(string memory)\\r\\n    {\\r\\n        return string(abi.encodePacked('PHJlY3QgeD0n',slc.split(rune).toString(),       //<rect x='\\r\\n                                       'JyB5PSAn', slc.split(rune).toString(),          //'y= '  \\r\\n                                       'JyB3aWR0aD0n',slc.split(rune).toString(),       //'width=' \\r\\n                                       'JyBoZWlnaHQ9ICAn',slc.split(rune).toString(),   //'height='\\r\\n                                       'JyAgZmlsbD0g',col,                              //'fill=\\r\\n                                       'IHRyYW5zZm9ybSA9ICcg' ));                       //'transform='\\r\\n    }\\r\\n\\r\\n    function splitO(strings.slice memory slc,strings.slice memory rune,string memory col) internal pure returns(string memory)\\r\\n    {\\r\\n        return string(abi.encodePacked('PGNpcmNsZSBjeD0n',slc.split(rune).toString(),      //<circle cx='\\r\\n                                       'JyBjeT0n', slc.split(rune).toString(),             //'cy='\\r\\n                                       'JyByID0n',slc.split(rune).toString(),              //'r=' \\r\\n                                       'JyAgZmlsbD0g',col ));                              //'fill='\\r\\n    }\\r\\n\\r\\n    function splitT(strings.slice memory slc,strings.slice memory rune)  internal pure returns(string memory)\\r\\n    {\\r\\n        return string(abi.encodePacked('IHRyYW5zbGF0ZSgg',slc.split(rune).toString(),      // translate(    \\r\\n                                       'ICwg',slc.split(rune).toString(),                  // ,  \\r\\n                                       'ICkgcm90YXRlICgg',slc.split(rune).toString(),      //) rotate ( \\r\\n                                       'KScgIC8+' ));                                      //)'  />\\r\\n    }\\r\\n\\r\\n    function joinR4(uint256 count,string memory o,string memory om,strings.slice memory slc,strings.slice memory rune,string memory col) internal view returns(string memory,string memory)\\r\\n    {\\r\\n         for(uint i = 0; i < count;) {\\r\\n             string memory ot  = splitR(slc,rune,col);\\r\\n             om=string(abi.encodePacked(om,ot,mirror));\\r\\n             o= string(abi.encodePacked(o,ot,'IC8+')); \\r\\n             i=i+4;\\r\\n          }\\r\\n        return (o,om);\\r\\n    }\\r\\n\\r\\n    function joinR16(uint256 count,strings.slice memory slc,strings.slice memory rune,string memory col) internal view returns(string memory,string memory)\\r\\n    {\\r\\n         string memory o;\\r\\n         string memory om;\\r\\n         for(uint i = 0; i < count;) {\\r\\n             string memory ot  = splitR(slc,rune,col);\\r\\n             string memory ot1 = splitR(slc,rune,col);\\r\\n             string memory ot2 = splitR(slc,rune,col);\\r\\n             string memory ot3 = splitR(slc,rune,col);\\r\\n             om = string(abi.encodePacked(om,ot,mirror,ot1,mirror,ot2,mirror,ot3,mirror));\\r\\n             o  = string(abi.encodePacked(o,ot,'IC8+',ot1,'IC8+',ot2,'IC8+',ot3,'IC8+'));\\r\\n             i=i+16;\\r\\n          }\\r\\n        return (o,om);\\r\\n    }\\r\\n\\r\\n    function joinO3(uint256 count,string memory o,string memory om,strings.slice memory slc,strings.slice memory rune,string memory col) internal view returns(string memory,string memory)\\r\\n    {\\r\\n         for(uint i = 0; i < count;) {\\r\\n             string memory ot  = splitO(slc,rune,col);\\r\\n             om=string(abi.encodePacked(om,ot,mirror));\\r\\n             o= string(abi.encodePacked(o,ot,'IC8+'));\\r\\n             i=i+3;\\r\\n          }\\r\\n        return (o,om);\\r\\n    }\\r\\n \\r\\n    function joinO9(uint256 count,string memory o,string memory om,strings.slice memory slc,strings.slice memory rune,string memory col) internal view returns(string memory,string memory)\\r\\n    {\\r\\n         \\r\\n         for(uint i = 0; i < count;) {\\r\\n             string memory c1 = splitO(slc,rune,col);\\r\\n             string memory c2 = splitO(slc,rune,col);\\r\\n             string memory c3 = splitO(slc,rune,col);\\r\\n             om = string(abi.encodePacked(om,c1,mirror,c2,mirror,c3,mirror));\\r\\n             o  = string(abi.encodePacked(o,c1,'IC8+',c2,'IC8+',c3,'IC8+'));\\r\\n             i=i+9;\\r\\n          }\\r\\n        return (o,om);\\r\\n    }\\r\\n    function joinT7(uint256 count ,string memory o,string memory om,strings.slice memory slc,strings.slice memory rune,string memory col) internal view returns(string memory,string memory)\\r\\n    {\\r\\n        for(uint i = 0; i < count;) {\\r\\n             string memory ot  = spiltRT(slc,rune,col);\\r\\n             string memory  t  = splitT (slc,rune);\\r\\n             om=string(abi.encodePacked(om,ot,mirror2,t));\\r\\n             o= string(abi.encodePacked(o,ot,t));\\r\\n             i=i+7;\\r\\n          }\\r\\n        return (o,om);\\r\\n    }\\r\\n\\r\\n    function joinT21(uint256 count ,string memory o,string memory om,strings.slice memory slc,strings.slice memory rune,string memory col) internal view returns(string memory,string memory)\\r\\n    {\\r\\n        string[6] memory sp;\\r\\n        for(uint i = 0; i < count;) {\\r\\n             sp[0]  = spiltRT(slc,rune,col);\\r\\n             sp[1]  = splitT (slc,rune);\\r\\n             sp[2]  = spiltRT(slc,rune,col);\\r\\n             sp[3]  = splitT (slc,rune);\\r\\n             sp[4]  = spiltRT(slc,rune,col);\\r\\n             sp[5]  = splitT (slc,rune);\\r\\n             om=string(abi.encodePacked(om,sp[0],mirror2,sp[1],sp[2] ));\\r\\n             om=string(abi.encodePacked(om,mirror2,sp[3],sp[4],mirror2,sp[5]));\\r\\n             o= string(abi.encodePacked(o,sp[0],sp[1],sp[2],sp[3],sp[4],sp[5]));\\r\\n             i=i+21;\\r\\n          }\\r\\n        return (o,om);\\r\\n    }\\r\\n    \\r\\n    function random(string memory input,uint max) internal pure returns (uint256) {\\r\\n        return uint256(keccak256(abi.encodePacked(input)))%max;\\r\\n    }\\r\\n     \\r\\n    function randomW(string memory input,uint max) internal pure returns (uint256) {\\r\\n        uint16[17] memory w = [3330,3200,3274,3264,3244,2234,2214,1594,1574,1564,554,544,334,324,315,205,44];\\r\\n        \\r\\n        uint256 rnd = uint256(keccak256(abi.encodePacked(input)))%27812;\\r\\n        for (uint i=0;i<max;i++){\\r\\n            if(rnd<w[i]){\\r\\n                return i;\\r\\n            }\\r\\n            rnd -= w[i];\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function convertMattertoEnergy(dataStruct memory part,uint256 tokenId,string[] memory colorList,uint256 dataType) public view onlyMaster returns (string memory,uint256) {\\r\\n       string memory o;\\r\\n       string memory om;\\r\\n  \\r\\n       strings.slice memory slc = strings.toSlice( part.buffer);\\r\\n       strings.slice memory rune =   strings.toSlice(\\\",\\\");\\r\\n       uint256 did = 10; \\r\\n\\r\\n       uint256 id = random(stringutils2.UtoString(tokenId*2+dataType),colorList.length);\\r\\n       did = id;\\r\\n       uint256 offset = part.Cnt % 16;\\r\\n       string memory col = colorList[id];\\r\\n       if (dataType == 10){\\r\\n           col = string(abi.encodePacked(col,'IGZpbHRlcj0ndXJsKCNuZW9uKScg')); //filter='url(#neon)' \\r\\n       }\\r\\n       if ( part.Cnt >=16){\\r\\n        (o,om) = joinR16(part.Cnt-offset,slc,rune,col);\\r\\n       }\\r\\n       (o,om) = joinR4(offset,o,om,slc,rune,col); \\r\\n\\r\\n       id = random(stringutils2.UtoString(tokenId*3+dataType),colorList.length);\\r\\n       //check predominant color\\r\\n       if ( part.Cnt < part.tCnt){\\r\\n       did = id;}\\r\\n\\r\\n       offset = part.tCnt % 21;\\r\\n       col = colorList[id];\\r\\n       if (dataType == 10){\\r\\n           col = string(abi.encodePacked(col,'IGZpbHRlcj0ndXJsKCNuZW9uKScg')); //filter='url(#neon)' \\r\\n       }\\r\\n       if (part.tCnt >=21){\\r\\n       (o,om) = joinT21(part.tCnt-offset,o,om,slc,rune,col);\\r\\n       }\\r\\n       (o,om) = joinT7(offset,o,om,slc,rune,col);\\r\\n      \\r\\n       id = random(stringutils2.UtoString(tokenId*4+dataType),colorList.length);\\r\\n       offset = part.oCnt % 9;\\r\\n       col = colorList[id];\\r\\n       if (dataType == 10){\\r\\n           col = string(abi.encodePacked(col,'IGZpbHRlcj0ndXJsKCNuZW9uKScg'));//filter='url(#neon)' \\r\\n       }\\r\\n       if (part.oCnt >=9){\\r\\n       (o,om) = joinO9(part.oCnt-offset,o,om,slc,rune,col);\\r\\n       }\\r\\n       (o,om) = joinO3(offset,o,om,slc,rune,col);\\r\\n       o = string(abi.encodePacked(o,om));\\r\\n\\r\\n       return (o,did);\\r\\n\\r\\n    }\\r\\n    \\r\\n    function generateBluePrint(skinStruct memory skn,paintStruct memory pnt,compIndexStruct memory p,uint8 cnt1,uint8 cnt2) public view onlyMaster returns (string memory) {\\r\\n        string memory bp;\\r\\n           \\r\\n        bp = string(abi.encodePacked('PC9nPjwvc3ZnPiIsICJhdHRyaWJ1dGVzIjpbIHsidHJhaXRfdHlwZSI6IjAuQk9EWSIsInZhbHVlIjoi', skn.bodies[p.id1].prop,             //</g></svg> \\\",\\\"attributes\\\": [ {\\\"trait_type\\\":\\\"1.BODY\\\", \\\"value\\\":\\\"'\\r\\n                                     'In0gLCB7InRyYWl0X3R5cGUiOiIxLkhFQUQiICwgInZhbHVlIjoi' ,skn.heads[p.id2].prop,                                                          //\\\"\\\"} , {\\\"trait_type\\\":\\\"2.HEAD\\\" , \\\"value\\\":\\\"\\r\\n                                     'In0seyJ0cmFpdF90eXBlIjoiMi5CT0RZIENPTE9SIiwgInZhbHVlIjoi',pnt.colName[p.idColB],                                                                       \\r\\n                                     'In0seyJ0cmFpdF90eXBlIjoiMy5IRUFEIENPTE9SIiwgInZhbHVlIjoi',pnt.colName[p.idColH],                                                                \\r\\n                                     'In0gICwgIHsidHJhaXRfdHlwZSI6IjQuRVlFUyIsInZhbHVlIjoi',skn.eyes[p.id3].prop,                                                                    //\\\"}  ,  {\\\"trait_type\\\":\\\"3.EYES\\\",\\\"value\\\":\\\"\\r\\n                                     'In0seyJ0cmFpdF90eXBlIjoiNS5NT1VUSCIsInZhbHVlIjoi',skn.mouths[p.id4].prop ));                                                              //\\\"} , {\\\"trait_type\\\":\\\"4.MOUTH\\\",\\\" value\\\":\\\"\\r\\n                                     \\r\\n                                     \\r\\n        bp = string(abi.encodePacked( bp,\\r\\n                                     'In0gLCB7ICJ0cmFpdF90eXBlIjoiNi5TS0lOIiwgInZhbHVlIjoi',skn.skinName,                                                                        //\\\" },{\\\"trait_type\\\":\\\"Skin Name\\\", \\\"value\\\":\\\"\\r\\n                                     'In0sIHsidHJhaXRfdHlwZSI6IjcuQ09MT1IgUEFMRVRURSIsInZhbHVlIjoi',pnt.chromaName,    \\r\\n                                     'In0sIHsidHJhaXRfdHlwZSI6IjguVE9UQUwgU0tJTlMiLCJ2YWx1ZSIgOiAi', Base64.encode(stringutils2.uintToByteString(cnt1, 3)),                                        //\\\"},{\\\"trait_type\\\":\\\"Skins Count\\\",\\\"value\\\":\\\"\\r\\n                                     'In0seyJ0cmFpdF90eXBlIjoiOS5UT1RBTCBDT0xPUiBQQUxFVFRFUyIsInZhbHVlIjoi',Base64.encode(stringutils2.uintToByteString(cnt2, 3))                                 //\\\"},{\\\"trait_type\\\":\\\"Color Pallets Count\\\",\\\"value\\\":\\\"\\r\\n                                      ));\\r\\n        return bp;\\r\\n    }\\r\\n\\r\\n    function launchPad(uint256 tokenId,uint8 idxSkin,uint8 idxChroma,uint8 cnt1,uint8 cnt2) public view onlyMaster returns (string memory) {\\r\\n        string[5] memory p; \\r\\n        compIndexStruct memory part;\\r\\n        paintStruct memory paint;\\r\\n        \\r\\n        ICargoShip cargoShip = ICargoShip (cargoShipAddress);\\r\\n        (paint.eyesColor,paint.color,paint.backgroundColor,paint.colName,paint.effect,paint.chromaName) = cargoShip.unloadChroma(idxChroma);\\r\\n\\r\\n        part.id0 = random  ( stringutils2.UtoString(tokenId),paint.backgroundColor.length);\\r\\n        part.id1 = randomW ( stringutils2.UtoString(tokenId+36723),BODY_COUNT);\\r\\n        part.id2 = randomW ( stringutils2.UtoString(tokenId+12323),HEAD_COUNT);\\r\\n        part.id3 = random  ( stringutils2.UtoString(tokenId+232)  ,EYES_COUNT);\\r\\n        part.id4 = random  ( stringutils2.UtoString(tokenId+3993) ,MOUTH_COUNT);\\r\\n        \\r\\n        p[0] = string(abi.encodePacked('PHJlY3Qgd2lkdGg9JzEwMCUnICBoZWlnaHQ9JzEwMCUnIGZpbGw9',paint.backgroundColor[part.id0],'Lz4gPGcgZmlsdGVyPSd1cmwoI25lb24pJyA+'));\\r\\n        \\r\\n        (p[4],part.idColH) = convertMattertoEnergy(skin[idxSkin].eyes[part.id3],tokenId,paint.eyesColor,10);\\r\\n        (p[3],part.idColH) = convertMattertoEnergy(skin[idxSkin].mouths[part.id4],tokenId,paint.color,15);\\r\\n        (p[2],part.idColH) = convertMattertoEnergy(skin[idxSkin].heads[part.id2],tokenId,paint.color,5);\\r\\n        (p[1],part.idColB) = convertMattertoEnergy(skin[idxSkin].bodies[part.id1],tokenId,paint.color,1);\\r\\n\\r\\n        p[0] = string(abi.encodePacked(p[0], p[1], p[2], p[3],\\\"PC9nPjxnIGZpbGwtb3BhY2l0eT0nMC44NSc+\\\",p[4])); \\r\\n\\r\\n        return string(abi.encodePacked(\\r\\n                //\\\"image_data\\\": \\\"<svg xmlns='http://www.w3.org/2000/svg' preserveAspectRatio='xMinYMin meet' viewBox='0 0 350 350'>\\r\\n                'data:application/json;base64,eyAgImltYWdlX2RhdGEiOiAiPHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHByZXNlcnZlQXNwZWN0UmF0aW89J3hNaW5ZTWluIG1lZXQnIHZpZXdCb3g9JzAgMCAzNTAgMzUwJz4g',\\r\\n                paint.effect,\\r\\n                p[0],\\r\\n                generateBluePrint(skin[idxSkin],paint,part,cnt1,cnt2),\\r\\n                //\\\"}], \\\"name\\\":\\\"OBI #,\\r\\n                'In0gXSwibmFtZSI6Ik9CSSAj',\\r\\n                 Base64.encode(stringutils2.uintToByteString(tokenId, 6)),\\r\\n                //\\\", \\\"description\\\": \\\"OBI ...\\\"} \\r\\n                'IiwiZGVzY3JpcHRpb24iOiAiVGhlIGZpcnN0IDEwMCUgT04gQ0hBSU4gcGZwIGNvbGxlY3Rpb24gd2l0aCBpbnRlcmNoYW5nZWFibGUgc2tpbnMgYW5kIGNvbG9yIHBhbGV0dGVzLiJ9'\\r\\n            ));\\r\\n    }\\r\\n    \\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"/contracts/stringutils2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.6;\\r\\n\\r\\n\\r\\nlibrary stringutils2 {\\r\\n    \\r\\n    //Function from chainRunners's implementation - MIT license\\r\\n    /*\\r\\n    Convert uint to byte string, padding number string with spaces at end.\\r\\n    Useful to ensure result's length is a multiple of 3, and therefore base64 encoding won't\\r\\n    result in '=' padding chars.\\r\\n    */\\r\\n    function uintToByteString(uint a, uint fixedLen) internal pure returns (bytes memory _uintAsString) {\\r\\n        uint j = a;\\r\\n        uint len;\\r\\n        while (j != 0) {\\r\\n            len++;\\r\\n            j /= 10;\\r\\n        }\\r\\n        bytes memory bstr = new bytes(fixedLen);\\r\\n        j = fixedLen;\\r\\n        if (a == 0) {\\r\\n            bstr[0] = \\\"0\\\";\\r\\n            len = 1;\\r\\n        }\\r\\n        while (j > len) {\\r\\n            j = j - 1;\\r\\n            bstr[j] = bytes1(' ');\\r\\n        }\\r\\n        uint k = len;\\r\\n        while (a != 0) {\\r\\n            k = k - 1;\\r\\n            uint8 temp = (48 + uint8(a - a / 10 * 10));\\r\\n            bytes1 b1 = bytes1(temp);\\r\\n            bstr[k] = b1;\\r\\n            a /= 10;\\r\\n        }\\r\\n        return bstr;\\r\\n    }\\r\\n\\r\\n    function UtoString(uint256 value) internal pure returns (string memory) {\\r\\n    // Inspired by OraclizeAPI's implementation - MIT license\\r\\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        while (value != 0) {\\r\\n            digits -= 1;\\r\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\r\\n            value /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"/contracts/stringutils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache License 2.0\\r\\n// part off library https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol\\r\\n\\r\\n/*\\r\\n * @title String & slice utility library for Solidity contracts.\\r\\n * @author Nick Johnson <arachnid@notdot.net>\\r\\n *\\r\\n * @dev Functionality in this library is largely implemented using an\\r\\n *      abstraction called a 'slice'. A slice represents a part of a string -\\r\\n *      anything from the entire string to a single character, or even no\\r\\n *      characters at all (a 0-length slice). Since a slice only has to specify\\r\\n *      an offset and a length, copying and manipulating slices is a lot less\\r\\n *      expensive than copying and manipulating the strings they reference.\\r\\n *\\r\\n *      To further reduce gas costs, most functions on slice that need to return\\r\\n *      a slice modify the original one instead of allocating a new one; for\\r\\n *      instance, `s.split(\\\".\\\")` will return the text up to the first '.',\\r\\n *      modifying s to only contain the remainder of the string after the '.'.\\r\\n *      In situations where you do not want to modify the original slice, you\\r\\n *      can make a copy first with `.copy()`, for example:\\r\\n *      `s.copy().split(\\\".\\\")`. Try and avoid using this idiom in loops; since\\r\\n *      Solidity has no memory management, it will result in allocating many\\r\\n *      short-lived slices that are later discarded.\\r\\n *\\r\\n *      Functions that return two slices come in two versions: a non-allocating\\r\\n *      version that takes the second slice as an argument, modifying it in\\r\\n *      place, and an allocating version that allocates and returns the second\\r\\n *      slice; see `nextRune` for example.\\r\\n *\\r\\n *      Functions that have to copy string data will return strings rather than\\r\\n *      slices; these can be cast back to slices for further processing if\\r\\n *      required.\\r\\n *\\r\\n *      For convenience, some functions are provided with non-modifying\\r\\n *      variants that create a new slice and return both; for instance,\\r\\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\\r\\n *      corresponding to the left and right parts of the string.\\r\\n */\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\n\\r\\nlibrary strings {\\r\\n    struct slice {\\r\\n        uint _len;\\r\\n        uint _ptr;\\r\\n    }\\r\\n\\r\\n    function memcpy(uint dest, uint src, uint len) private pure {\\r\\n        // Copy word-length chunks while possible\\r\\n        for(; len >= 32; len -= 32) {\\r\\n            assembly {\\r\\n                mstore(dest, mload(src))\\r\\n            }\\r\\n            dest += 32;\\r\\n            src += 32;\\r\\n        }\\r\\n\\r\\n        // Copy remaining bytes\\r\\n        uint mask = 256 ** (32 - len) - 1;\\r\\n        assembly {\\r\\n            let srcpart := and(mload(src), not(mask))\\r\\n            let destpart := and(mload(dest), mask)\\r\\n            mstore(dest, or(destpart, srcpart))\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Returns the memory address of the first byte of the first occurrence of\\r\\n    // `needle` in `self`, or the first byte after `self` if not found.\\r\\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\r\\n        uint ptr = selfptr;\\r\\n        uint idx;\\r\\n\\r\\n        if (needlelen <= selflen) {\\r\\n            if (needlelen <= 32) {\\r\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\r\\n\\r\\n                bytes32 needledata;\\r\\n                assembly { needledata := and(mload(needleptr), mask) }\\r\\n\\r\\n                uint end = selfptr + selflen - needlelen;\\r\\n                bytes32 ptrdata;\\r\\n                assembly { ptrdata := and(mload(ptr), mask) }\\r\\n\\r\\n                while (ptrdata != needledata) {\\r\\n                    if (ptr >= end)\\r\\n                        return selfptr + selflen;\\r\\n                    ptr++;\\r\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\r\\n                }\\r\\n                return ptr;\\r\\n            } else {\\r\\n                // For long needles, use hashing\\r\\n                bytes32 hash;\\r\\n                assembly { hash := keccak256(needleptr, needlelen) }\\r\\n\\r\\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\\r\\n                    bytes32 testHash;\\r\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\r\\n                    if (hash == testHash)\\r\\n                        return ptr;\\r\\n                    ptr += 1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return selfptr + selflen;\\r\\n    }\\r\\n   \\r\\n    /*\\r\\n     * @dev Returns a slice containing the entire string.\\r\\n     * @param self The string to make a slice from.\\r\\n     * @return A newly allocated slice containing the entire string.\\r\\n     */\\r\\n    function toSlice(string memory self) internal pure returns (slice memory) {\\r\\n        uint ptr;\\r\\n        assembly {\\r\\n            ptr := add(self, 0x20)\\r\\n        }\\r\\n        return slice(bytes(self).length, ptr);\\r\\n    }\\r\\n   /*\\r\\n   * @dev Copies a slice to a new string.\\r\\n   * @param self The slice to copy.\\r\\n   * @return A newly allocated string containing the slice's text.\\r\\n   */\\r\\n    function toString(slice memory self) internal pure returns (string memory) {\\r\\n        string memory ret = new string(self._len);\\r\\n        uint retptr;\\r\\n        assembly { retptr := add(ret, 32) }\\r\\n\\r\\n        memcpy(retptr, self._ptr, self._len);\\r\\n        return ret;\\r\\n    }\\r\\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\\r\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\\r\\n        while (ptr <= self._ptr + self._len) {\\r\\n            cnt++;\\r\\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\\r\\n        }\\r\\n    }\\r\\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\\r\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\r\\n        token._ptr = self._ptr;\\r\\n        token._len = ptr - self._ptr;\\r\\n        if (ptr == self._ptr + self._len) {\\r\\n            // Not found\\r\\n            self._len = 0;\\r\\n        } else {\\r\\n            self._len -= token._len + needle._len;\\r\\n            self._ptr = ptr + needle._len;\\r\\n        }\\r\\n        return token;\\r\\n    }\\r\\n/*\\r\\n * @dev Splits the slice, setting `self` to everything after the first\\r\\n *      occurrence of `needle`, and returning everything before it. If\\r\\n *      `needle` does not occur in `self`, `self` is set to the empty slice,\\r\\n *      and the entirety of `self` is returned.\\r\\n * @param self The slice to split.\\r\\n * @param needle The text to search for in `self`.\\r\\n * @return The part of `self` up to the first occurrence of `delim`.\\r\\n */\\r\\nfunction split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\\r\\n        split(self, needle, token);\\r\\n   } \\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Base64.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides a set of functions to operate with Base64 strings.\\n *\\n * _Available since v4.5._\\n */\\nlibrary Base64 {\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cargoShipAddress\",\"type\":\"address\"}],\"name\":\"CargoShipAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"masterAddress\",\"type\":\"address\"}],\"name\":\"MasterAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MatterStorredLayer1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MatterStorredLayer2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"buffer\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"prop\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"Cnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tCnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"oCnt\",\"type\":\"uint8\"}],\"internalType\":\"struct BlockInvadersMotherShip.dataStruct\",\"name\":\"part\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string[]\",\"name\":\"colorList\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"dataType\",\"type\":\"uint256\"}],\"name\":\"convertMattertoEnergy\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"buffer\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"prop\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"Cnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tCnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"oCnt\",\"type\":\"uint8\"}],\"internalType\":\"struct BlockInvadersMotherShip.dataStruct[17]\",\"name\":\"bodies\",\"type\":\"tuple[17]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"buffer\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"prop\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"Cnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tCnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"oCnt\",\"type\":\"uint8\"}],\"internalType\":\"struct BlockInvadersMotherShip.dataStruct[17]\",\"name\":\"heads\",\"type\":\"tuple[17]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"buffer\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"prop\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"Cnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tCnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"oCnt\",\"type\":\"uint8\"}],\"internalType\":\"struct BlockInvadersMotherShip.dataStruct[32]\",\"name\":\"eyes\",\"type\":\"tuple[32]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"buffer\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"prop\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"Cnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tCnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"oCnt\",\"type\":\"uint8\"}],\"internalType\":\"struct BlockInvadersMotherShip.dataStruct[21]\",\"name\":\"mouths\",\"type\":\"tuple[21]\"},{\"internalType\":\"string\",\"name\":\"skinName\",\"type\":\"string\"}],\"internalType\":\"struct BlockInvadersMotherShip.skinStruct\",\"name\":\"skn\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string[]\",\"name\":\"eyesColor\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"color\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"backgroundColor\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"colName\",\"type\":\"string[]\"},{\"internalType\":\"string\",\"name\":\"effect\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"chromaName\",\"type\":\"string\"}],\"internalType\":\"struct BlockInvadersMotherShip.paintStruct\",\"name\":\"pnt\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"id4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"idColH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"idColB\",\"type\":\"uint256\"}],\"internalType\":\"struct BlockInvadersMotherShip.compIndexStruct\",\"name\":\"p\",\"type\":\"tuple\"},{\"internalType\":\"uint8\",\"name\":\"cnt1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"cnt2\",\"type\":\"uint8\"}],\"name\":\"generateBluePrint\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMotherShip\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"idxSkin\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"idxChroma\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"cnt1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"cnt2\",\"type\":\"uint8\"}],\"name\":\"launchPad\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cargoShipAddress\",\"type\":\"address\"}],\"name\":\"setCargoShipAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_masterAddress\",\"type\":\"address\"}],\"name\":\"setMasterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"buffer\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"prop\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"Cnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tCnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"oCnt\",\"type\":\"uint8\"}],\"internalType\":\"struct BlockInvadersMotherShip.dataStruct[]\",\"name\":\"_data\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_skinName\",\"type\":\"string\"}],\"name\":\"storeMatterLayer1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"buffer\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"prop\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"Cnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tCnt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"oCnt\",\"type\":\"uint8\"}],\"internalType\":\"struct BlockInvadersMotherShip.dataStruct[]\",\"name\":\"_data\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"storeMatterLayer2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BlockInvadersMotherShip", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}