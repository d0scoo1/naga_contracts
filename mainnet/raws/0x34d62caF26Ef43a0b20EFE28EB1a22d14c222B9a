{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"LiquidBase.sol\":{\"content\":\"// SPDX-License-Identifier: WISE\\n\\npragma solidity =0.8.12;\\n\\ncontract LiquidBase {\\n\\n    // Precision factor for interest rate in orders of 1E18\\n    uint256 public constant PRECISION_R = 100E18;\\n\\n    // Team fee relative in orders of 1E18\\n    uint256 public constant FEE = 20E18;\\n\\n    // Time before a liquidation will occur\\n    uint256 public constant DEADLINE_TIME = 7 days;\\n\\n    // How long the contribution phase lasts\\n    uint256 public constant CONTRIBUTION_TIME = 5 days;\\n\\n    // Amount of seconds in one day unit\\n    uint256 public constant SECONDS_IN_DAY = 86400;\\n\\n    // Address if factory that creates lockers\\n    address public constant FACTORY_ADDRESS = 0x9961f05a53A1944001C0dF650A5aFF65B21A37D0;\\n\\n    // Address to tranfer NFT to in event of non singleProvider liquidation\\n    address public constant TRUSTEE_MULTISIG = 0xfEc4264F728C056bD528E9e012cf4D943bd92b53;\\n\\n    // ERC20 used for payments of this locker\\n    address public constant PAYMENT_TOKEN = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\\n\\n    // Helper constant for comparison with 0x0 address\\n    address constant ZERO_ADDRESS = address(0);\\n\\n    /*@dev\\n    * @element tokenID: NFT IDs\\n    * @element tokenAddress: address of NFT contract\\n    * @element paymentTime: how long loan will last\\n    * @element paymentRate: how much must be paid for loan\\n    * @element lockerOwner: who is taking out loan\\n    */\\n    struct Globals {\\n        uint256[] tokenId;\\n        uint256 paymentTime;\\n        uint256 paymentRate;\\n        address lockerOwner;\\n        address tokenAddress;\\n    }\\n\\n    Globals public globals;\\n\\n    // Address of single provider, is zero address if there is no single provider\\n    address public singleProvider;\\n\\n    // Minimum the owner wants for the loan. If less than this contributors refunded\\n    uint256 public floorAsked;\\n\\n    // Maximum the owner wants for the loan\\n    uint256 public totalAsked;\\n\\n    // How many tokens have been collected for far for this loan\\n    uint256 public totalCollected;\\n\\n    // Balance contributors can claim at a given moment\\n    uint256 public claimableBalance;\\n\\n    // Balance the locker owner still owes\\n    uint256 public remainingBalance;\\n\\n    // Time next payoff must happen to avoid penalties\\n    uint256 public nextDueTime;\\n\\n    // Timestamp initialize was called\\n    uint256 public creationTime;\\n\\n    // How much a user has contributed to loan during contribution phase\\n    mapping(address =\\u003e uint256) public contributions;\\n\\n    // How much a user has received payed back for their potion of contributing to the loan\\n    mapping(address =\\u003e uint256) public compensations;\\n\\n    // Event for when the single provider is established\\n    event SingleProvider(\\n        address singleProvider\\n    );\\n\\n    // Event for when the loan payback is made\\n    event PaymentMade(\\n        uint256 paymentAmount,\\n        address paymentAddress\\n    );\\n\\n    // Event for when the contributor gets refunded\\n    event RefundMade(\\n        uint256 refundAmount,\\n        address refundAddress\\n    );\\n\\n    // Event for when the contributor claims funds\\n    event ClaimMade(\\n        uint256 claimAmount,\\n        address claimAddress\\n    );\\n\\n    // Event for when the loan is liquidated or defaulted\\n    event Liquidated(\\n        address liquidatorAddress\\n    );\\n\\n    // Event for when the interest rate is increased\\n    event PaymentRateIncrease(\\n        uint256 newRateIncrease\\n    );\\n\\n    // Event for when the payback time is decreased\\n    event PaymentTimeDecrease(\\n        uint256 newPaymentTime\\n    );\\n}\\n\"},\"LiquidHelper.sol\":{\"content\":\"// SPDX-License-Identifier: WISE\\n\\npragma solidity =0.8.12;\\n\\nimport \\\"./LiquidBase.sol\\\";\\n\\ncontract LiquidHelper is LiquidBase {\\n\\n    /**\\n     * @dev encoding for transfer\\n     */\\n    bytes4 constant TRANSFER = bytes4(\\n        keccak256(\\n            bytes(\\n                \\\"transfer(address,uint256)\\\"\\n            )\\n        )\\n    );\\n\\n    /**\\n     * @dev encoding for transferFrom\\n     */\\n    bytes4 constant TRANSFER_FROM = bytes4(\\n        keccak256(\\n            bytes(\\n                \\\"transferFrom(address,address,uint256)\\\"\\n            )\\n        )\\n    );\\n\\n    /**\\n     * @dev returns IDs of NFTs being held\\n     */\\n    function getTokens()\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return globals.tokenId;\\n    }\\n\\n    /**\\n     * @dev returns true if contributions have not reached min asked\\n     */\\n    function floorNotReached()\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return contributionPhase() == false \\u0026\\u0026 belowFloorAsked() == true;\\n    }\\n\\n    /**\\n     * @dev returns true if the provider address is not the single provider\\n     */\\n    function notSingleProvider(\\n        address _checkAddress\\n    )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        address provider = singleProvider;\\n        return\\n            provider != _checkAddress \\u0026\\u0026\\n            provider != ZERO_ADDRESS;\\n    }\\n\\n    /**\\n     * @dev returns true if the contributor will reach the ceiling asked with the provided token amount\\n     */\\n    function reachedTotal(\\n        address _contributor,\\n        uint256 _tokenAmount\\n    )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return contributions[_contributor] + _tokenAmount \\u003e= totalAsked;\\n    }\\n\\n    /**\\n     * @dev returns true if locker has not been enabled within 7 days after contribution phase\\n     */\\n    function missedActivate()\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return\\n            floorNotReached() \\u0026\\u0026\\n            startingTimestamp() + DEADLINE_TIME \\u003c block.timestamp;\\n    }\\n\\n    /**\\n     * @dev returns true if owner has not paid back within 7 days of last payment\\n     */\\n    function missedDeadline()\\n        public\\n        view\\n        returns (bool)\\n    {\\n        uint256 nextDueOrDeadline = nextDueTime \\u003e paybackTimestamp()\\n            ? paybackTimestamp()\\n            : nextDueTime;\\n\\n        return\\n            nextDueTime \\u003e 0 \\u0026\\u0026\\n            nextDueOrDeadline + DEADLINE_TIME \\u003c block.timestamp;\\n    }\\n\\n    /**\\n     * @dev returns true total collected is below the min asked\\n     */\\n    function belowFloorAsked()\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return totalCollected \\u003c floorAsked;\\n    }\\n\\n    /**\\n     * @dev returns true if nextDueTime is 0, mean it has not been initialized (unix timestamp)\\n     */\\n    function paymentTimeNotSet()\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return nextDueTime == 0;\\n    }\\n\\n    /**\\n     * @dev returns true if contract is in contribution phase time window\\n     */\\n    function contributionPhase()\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return timeSince(creationTime) \\u003c CONTRIBUTION_TIME;\\n    }\\n\\n    /**\\n     * @dev returns final due time of loan\\n     */\\n    function paybackTimestamp()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return startingTimestamp() + globals.paymentTime;\\n    }\\n\\n    /**\\n     * @dev returns approximate time the loan will/did start\\n     */\\n    function startingTimestamp()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return creationTime + CONTRIBUTION_TIME;\\n    }\\n\\n    /**\\n     * @dev returns address to transfer NFT to in event of liquidation\\n     */\\n    function liquidateTo()\\n        public\\n        view\\n        returns (address)\\n    {\\n        return singleProvider == ZERO_ADDRESS\\n            ? TRUSTEE_MULTISIG\\n            : singleProvider;\\n    }\\n\\n    /**\\n     * @dev returns bool if owner was removed\\n     */\\n    function ownerlessLocker()\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return globals.lockerOwner == ZERO_ADDRESS;\\n    }\\n\\n    /**\\n     * @dev returns calc of time since a certain timestamp to block timestamp\\n     */\\n    function timeSince(\\n        uint256 _timeStamp\\n    )\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return block.timestamp - _timeStamp;\\n    }\\n\\n    /**\\n     * @dev sets due time to 0\\n     */\\n    function _revokeDueTime()\\n        internal\\n    {\\n        nextDueTime = 0;\\n    }\\n\\n    /**\\n     * @dev adds a contribution on to the currently stored amount of contributions for a user\\n     */\\n    function _increaseContributions(\\n        address _contributorsAddress,\\n        uint256 _contributionAmount\\n    )\\n        internal\\n    {\\n        contributions[_contributorsAddress] =\\n        contributions[_contributorsAddress] + _contributionAmount;\\n    }\\n\\n    /**\\n     * @dev adds an amount to totalCollected\\n     */\\n    function _increaseTotalCollected(\\n        uint256 _increaseAmount\\n    )\\n        internal\\n    {\\n        totalCollected =\\n        totalCollected + _increaseAmount;\\n    }\\n\\n    /**\\n     * @dev subs an amount to totalCollected\\n     */\\n    function _decreaseTotalCollected(\\n        uint256 _decreaseAmount\\n    )\\n        internal\\n    {\\n        totalCollected =\\n        totalCollected - _decreaseAmount;\\n    }\\n\\n    /**\\n     * @dev Helper function to add payment tokens and penalty tokens to their internal variables\\n     * Also calculates remainingBalance due for the owner.\\n     */\\n    function _adjustBalances(\\n        uint256 _paymentTokens,\\n        uint256 _penaltyTokens\\n    )\\n        internal\\n    {\\n        claimableBalance = claimableBalance\\n            + _paymentTokens;\\n\\n        uint256 newBalance = remainingBalance\\n            + _penaltyTokens;\\n\\n        remainingBalance = _paymentTokens \\u003c newBalance\\n            ? newBalance - _paymentTokens : 0;\\n    }\\n\\n    /**\\n     * @dev does an erc20 transfer then check for success\\n     */\\n    function _safeTransfer(\\n        address _token,\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        (bool success, bytes memory data) = _token.call(\\n            abi.encodeWithSelector(\\n                TRANSFER,\\n                _to,\\n                _value\\n            )\\n        );\\n\\n        require(\\n            success \\u0026\\u0026 (\\n                data.length == 0 || abi.decode(\\n                    data, (bool)\\n                )\\n            ),\\n            \\\"LiquidHelper: TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev does an erc20 transferFrom then check for success\\n     */\\n    function _safeTransferFrom(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        (bool success, bytes memory data) = _token.call(\\n            abi.encodeWithSelector(\\n                TRANSFER_FROM,\\n                _from,\\n                _to,\\n                _value\\n            )\\n        );\\n\\n        require(\\n            success \\u0026\\u0026 (\\n                data.length == 0 || abi.decode(\\n                    data, (bool)\\n                )\\n            ),\\n            \\\"LiquidHelper: TRANSFER_FROM_FAILED\\\"\\n        );\\n    }\\n}\\n\"},\"LiquidLocker.sol\":{\"content\":\"// SPDX-License-Identifier: WISE\\n\\npragma solidity =0.8.12;\\n\\nimport \\\"./LiquidHelper.sol\\\";\\nimport \\\"./LiquidTransfer.sol\\\";\\n\\ncontract LiquidLocker is LiquidTransfer, LiquidHelper {\\n\\n    modifier onlyLockerOwner() {\\n        require(\\n           msg.sender == globals.lockerOwner,\\n           \\\"LiquidLocker: INVALID_OWNER\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyFromFactory() {\\n        require(\\n            msg.sender == FACTORY_ADDRESS,\\n            \\\"LiquidLocker: INVALID_ADDRESS\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyDuringContributionPhase() {\\n        require(\\n            contributionPhase() == true \\u0026\\u0026\\n            paymentTimeNotSet() == true,\\n            \\\"LiquidLocker: INVALID_PHASE\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev This is a call made by the constructor to set up variables on a new locker.\\n     * This is essentially equivalent to a constructor, but for our gas saving cloning operation instead.\\n     */\\n    function initialize(\\n        uint256[] calldata _tokenId,\\n        address _tokenAddress,\\n        address _tokenOwner,\\n        uint256 _floorAsked,\\n        uint256 _totalAsked,\\n        uint256 _paymentTime,\\n        uint256 _paymentRate\\n    )\\n        external\\n        onlyFromFactory\\n    {\\n        globals = Globals({\\n            tokenId: _tokenId,\\n            lockerOwner: _tokenOwner,\\n            tokenAddress: _tokenAddress,\\n            paymentTime: _paymentTime,\\n            paymentRate: _paymentRate\\n        });\\n\\n        floorAsked = _floorAsked;\\n        totalAsked = _totalAsked;\\n        creationTime = block.timestamp;\\n    }\\n\\n     /* @dev During the contribution phase, the owner can increase the rate they will pay for the loan.\\n     * The owner can only increase the rate to make the deal better for contributors, he cannot decrease it.\\n     */\\n    function increasePaymentRate(\\n        uint256 _newPaymntRate\\n    )\\n        external\\n        onlyLockerOwner\\n        onlyDuringContributionPhase\\n    {\\n        require(\\n            _newPaymntRate \\u003e globals.paymentRate,\\n            \\\"LiquidLocker: INVALID_INCREASE\\\"\\n        );\\n\\n        globals.paymentRate = _newPaymntRate;\\n\\n        emit PaymentRateIncrease(\\n            _newPaymntRate\\n        );\\n    }\\n\\n    /**\\n     * @dev During the contribution phase, the owner can decrease the duration of the loan.\\n     * The owner can only decrease the loan to a shorter duration, he cannot make it longer once the\\n     * contribution phase has started.\\n     */\\n    function decreasePaymentTime(\\n        uint256 _newPaymentTime\\n    )\\n        external\\n        onlyLockerOwner\\n        onlyDuringContributionPhase\\n    {\\n        require(\\n            _newPaymentTime \\u003c globals.paymentTime,\\n            \\\"LiquidLocker: INVALID_DECREASE\\\"\\n        );\\n\\n        globals.paymentTime = _newPaymentTime;\\n\\n        emit PaymentTimeDecrease(\\n            _newPaymentTime\\n        );\\n    }\\n\\n    /* @dev During the contribution phase, the owner can increase the rate and decrease time\\n    * This function executes both actions at the same time to save on one extra transaction\\n    */\\n    function updateSettings(\\n        uint256 _newPaymntRate,\\n        uint256 _newPaymentTime\\n    )\\n        external\\n        onlyLockerOwner\\n        onlyDuringContributionPhase\\n    {\\n        require(\\n            _newPaymntRate \\u003e globals.paymentRate,\\n            \\\"LiquidLocker: INVALID_RATE\\\"\\n        );\\n\\n        require(\\n            _newPaymentTime \\u003c globals.paymentTime,\\n            \\\"LiquidLocker: INVALID_TIME\\\"\\n        );\\n\\n        globals.paymentRate = _newPaymntRate;\\n        globals.paymentTime = _newPaymentTime;\\n\\n        emit PaymentRateIncrease(\\n            _newPaymntRate\\n        );\\n\\n        emit PaymentTimeDecrease(\\n            _newPaymentTime\\n        );\\n    }\\n\\n    /**\\n     * @dev Public users can add tokens to the pool to be used for the loan.\\n     * The contributions for each user along with the total are recorded for splitting funds later.\\n     * If a user contributes up to the maximum asked on a loan, they will become the sole provider\\n     * (See _usersIncrease and _reachedTotal for functionality on becoming the sole provider)\\n     * The sole provider will receive the token instead of the trusted multisig in the case if a liquidation.\\n     */\\n    function makeContribution(\\n        uint256 _tokenAmount,\\n        address _tokenHolder\\n    )\\n        external\\n        onlyFromFactory\\n        onlyDuringContributionPhase\\n        returns (\\n            uint256 totalIncrease,\\n            uint256 usersIncrease\\n        )\\n    {\\n        totalIncrease = _totalIncrease(\\n            _tokenAmount\\n        );\\n\\n        usersIncrease = _usersIncrease(\\n            _tokenHolder,\\n            _tokenAmount,\\n            totalIncrease\\n        );\\n\\n        _increaseContributions(\\n            _tokenHolder,\\n            usersIncrease\\n        );\\n\\n        _increaseTotalCollected(\\n            totalIncrease\\n        );\\n    }\\n\\n    /**\\n     * @dev Check if this contribution adds enough for the user to become the sole contributor.\\n     * Make them the sole contributor if so, otherwise return the totalAmount\\n     */\\n    function _usersIncrease(\\n        address _tokenHolder,\\n        uint256 _tokenAmount,\\n        uint256 _totalAmount\\n    )\\n        internal\\n        returns (uint256)\\n    {\\n        return reachedTotal(_tokenHolder, _tokenAmount)\\n            ? _reachedTotal(_tokenHolder)\\n            : _totalAmount;\\n    }\\n\\n    /**\\n     * @dev Calculate whether a contribution go over the maximum asked.\\n     * If so only allow it to go up to the totalAsked an not over\\n     */\\n    function _totalIncrease(\\n        uint256 _tokenAmount\\n    )\\n        internal\\n        view\\n        returns (uint256 totalIncrease)\\n    {\\n        totalIncrease = totalCollected\\n            + _tokenAmount \\u003c totalAsked\\n            ? _tokenAmount : totalAsked - totalCollected;\\n    }\\n\\n    /**\\n     * @dev Make the user the singleProvider.\\n     * Making the user the singleProvider allows all other contributors to claim their funds back.\\n     * Essentially if you contribute the whole maximum asked on your own you will kick everyone else out\\n     */\\n    function _reachedTotal(\\n        address _tokenHolder\\n    )\\n        internal\\n        returns (uint256 totalReach)\\n    {\\n        require(\\n            singleProvider == ZERO_ADDRESS,\\n            \\\"LiquidLocker: PROVIDER_EXISTS\\\"\\n        );\\n\\n        totalReach =\\n        totalAsked - contributions[_tokenHolder];\\n\\n        singleProvider = _tokenHolder;\\n\\n        emit SingleProvider(\\n            _tokenHolder\\n        );\\n    }\\n\\n    /**\\n     * @dev Locker owner calls this once the contribution phase is over to receive the funds for the loan.\\n     * This can only be done once the floor is reached, and can be done before the end of the contribution phase.\\n     */\\n    function enableLocker(\\n        uint256 _prepayAmount\\n    )\\n        external\\n        onlyLockerOwner\\n    {\\n        require(\\n            belowFloorAsked() == false,\\n            \\\"LiquidLocker: BELOW_FLOOR\\\"\\n        );\\n\\n        require(\\n            paymentTimeNotSet() == true,\\n            \\\"LiquidLocker: ENABLED_LOCKER\\\"\\n        );\\n\\n        (\\n\\n        uint256 totalPayback,\\n        uint256 epochPayback,\\n        uint256 teamsPayback\\n\\n        ) = calculatePaybacks(\\n            totalCollected,\\n            globals.paymentTime,\\n            globals.paymentRate\\n        );\\n\\n        claimableBalance = claimableBalance\\n            + _prepayAmount;\\n\\n        remainingBalance = totalPayback\\n            - _prepayAmount;\\n\\n        nextDueTime = startingTimestamp()\\n            + _prepayAmount\\n            / epochPayback;\\n\\n        _safeTransfer(\\n            PAYMENT_TOKEN,\\n            msg.sender,\\n            totalCollected - _prepayAmount - teamsPayback\\n        );\\n\\n        _safeTransfer(\\n            PAYMENT_TOKEN,\\n            TRUSTEE_MULTISIG,\\n            teamsPayback\\n        );\\n\\n        emit PaymentMade(\\n            _prepayAmount,\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * @dev Until floor is not reached the owner has ability to remove his NFTs\\n       as soon as floor is reached the owner can no longer back-out from the loan\\n     */\\n    function disableLocker()\\n        external\\n        onlyLockerOwner\\n    {\\n        require(\\n            belowFloorAsked() == true,\\n            \\\"LiquidLocker: FLOOR_REACHED\\\"\\n        );\\n\\n        _returnOwnerTokens();\\n    }\\n\\n    /**\\n     * @dev Internal function that does the work for disableLocker\\n       it returns all the NFT tokens to the original owner.\\n     */\\n    function _returnOwnerTokens()\\n        internal\\n    {\\n        address lockerOwner = globals.lockerOwner;\\n        globals.lockerOwner = ZERO_ADDRESS;\\n\\n        for (uint256 i = 0; i \\u003c globals.tokenId.length; i++) {\\n            _transferNFT(\\n                address(this),\\n                lockerOwner,\\n                globals.tokenAddress,\\n                globals.tokenId[i]\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev There are a couple edge cases with extreme payment rates that cause enableLocker to revert.\\n     * These are never callable on our UI and doing so would require a manual transaction.\\n     * This function will disable a locker in this senario, allow contributors to claim their money and transfer the NFT back to the owner.\\n     * Only the team multisig has permission to do this\\n     */\\n    function rescueLocker()\\n        external\\n    {\\n        require(\\n            msg.sender == TRUSTEE_MULTISIG,\\n            \\\"LiquidLocker: INVALID_TRUSTEE\\\"\\n        );\\n\\n        require(\\n            timeSince(creationTime) \\u003e DEADLINE_TIME,\\n            \\\"LiquidLocker: NOT_ENOUGHT_TIME\\\"\\n        );\\n\\n        require(\\n            paymentTimeNotSet() == true,\\n           \\\"LiquidLocker: ALREADY_STARTED\\\"\\n        );\\n\\n        _returnOwnerTokens();\\n    }\\n\\n    /**\\n     * @dev Allow users to claim funds when a locker is disabled\\n     */\\n    function refundDueExpired(\\n        address _refundAddress\\n    )\\n        external\\n    {\\n        require(\\n            floorNotReached() == true ||\\n            ownerlessLocker() == true,\\n            \\\"LiquidLocker: ENABLED_LOCKER\\\"\\n        );\\n\\n        uint256 tokenAmount = contributions[_refundAddress];\\n\\n        _refundTokens(\\n            tokenAmount,\\n            _refundAddress\\n        );\\n\\n        _decreaseTotalCollected(\\n            tokenAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev Allow users to claim funds when a someone kicks them out to become the single provider\\n     */\\n    function refundDueSingle(\\n        address _refundAddress\\n    )\\n        external\\n    {\\n        require(\\n            notSingleProvider(_refundAddress) == true,\\n            \\\"LiquidLocker: INVALID_SENDER\\\"\\n        );\\n\\n        _refundTokens(\\n            contributions[_refundAddress],\\n            _refundAddress\\n        );\\n    }\\n\\n    /**\\n     * @dev Someone can add funds to the locker and they will be split among the contributors\\n     * This does not count as a payment on the loan.\\n     */\\n    function donateFunds(\\n        uint256 _donationAmount\\n    )\\n        external\\n        onlyFromFactory\\n    {\\n        claimableBalance =\\n        claimableBalance + _donationAmount;\\n    }\\n\\n    /**\\n     * @dev Locker owner can payback funds.\\n     * Penalties are given if the owner does not pay the earnings linearally over the loan duration.\\n     * If the owner pays back the earnings, loan amount, and penalties aka fully pays off the loan\\n     * they will be transfered their nft back\\n     */\\n    function payBackFunds(\\n        uint256 _paymentAmount,\\n        address _paymentAddress\\n    )\\n        external\\n        onlyFromFactory\\n    {\\n        require(\\n            missedDeadline() == false,\\n            \\\"LiquidLocker: TOO_LATE\\\"\\n        );\\n\\n        _adjustBalances(\\n            _paymentAmount,\\n            _penaltyAmount()\\n        );\\n\\n        if (remainingBalance == 0) {\\n\\n            _revokeDueTime();\\n            _returnOwnerTokens();\\n\\n            return;\\n        }\\n\\n        uint256 payedTimestamp = nextDueTime;\\n        uint256 finalTimestamp = paybackTimestamp();\\n\\n        if (payedTimestamp == finalTimestamp) return;\\n\\n        uint256 purchasedTime = _paymentAmount\\n            / calculateEpoch(\\n                totalCollected,\\n                globals.paymentTime,\\n                globals.paymentRate\\n            );\\n\\n        require(\\n            purchasedTime \\u003e= SECONDS_IN_DAY,\\n            \\\"LiquidLocker: Minimum Payoff\\\"\\n        );\\n\\n        payedTimestamp = payedTimestamp \\u003e block.timestamp\\n            ? payedTimestamp + purchasedTime\\n            : block.timestamp + purchasedTime;\\n\\n        nextDueTime = payedTimestamp;\\n\\n        emit PaymentMade(\\n            _paymentAmount,\\n            _paymentAddress\\n        );\\n    }\\n\\n    /**\\n     * @dev If the owner has missed payments by 7 days this call will transfer the NFT to either the\\n     * singleProvider address or the trusted multisig to be auctioned\\n     */\\n    function liquidateLocker()\\n        external\\n    {\\n        require(\\n            missedActivate() == true ||\\n            missedDeadline() == true,\\n            \\\"LiquidLocker: TOO_EARLY\\\"\\n        );\\n\\n        _revokeDueTime();\\n        globals.lockerOwner = ZERO_ADDRESS;\\n\\n        for (uint256 i = 0; i \\u003c globals.tokenId.length; i++) {\\n            _transferNFT(\\n                address(this),\\n                liquidateTo(),\\n                globals.tokenAddress,\\n                globals.tokenId[i]\\n            );\\n        }\\n\\n        emit Liquidated(\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * @dev Public pure accessor for _getPenaltyAmount\\n     */\\n    function penaltyAmount(\\n        uint256 _totalCollected,\\n        uint256 _lateDaysAmount\\n    )\\n        external\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = _getPenaltyAmount(\\n            _totalCollected,\\n            _lateDaysAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev calculate how much in penalties the owner has due to late time since last payment\\n     */\\n    function _penaltyAmount()\\n        internal\\n        view\\n        returns (uint256 amount)\\n    {\\n        amount = _getPenaltyAmount(\\n            totalCollected,\\n            getLateDays()\\n        );\\n    }\\n\\n    /**\\n     * @dev Calculate penalties. .5% for first 4 days and 1% for each day after the 4th\\n     */\\n    function _getPenaltyAmount(\\n        uint256 _totalCollected,\\n        uint256 _lateDaysAmount\\n    )\\n        private\\n        pure\\n        returns (uint256 penalty)\\n    {\\n        penalty = _totalCollected\\n            * _daysBase(_lateDaysAmount)\\n            / 200;\\n    }\\n\\n    /**\\n     * @dev Helper for the days math of calcualte penalties.\\n     * Returns +1 per day before the 4th day and +2 for each day after the 4th day\\n     */\\n    function _daysBase(\\n        uint256 _daysAmount\\n    )\\n        internal\\n        pure\\n        returns (uint256 res)\\n    {\\n        res = _daysAmount \\u003e 4\\n            ? _daysAmount * 2 - 4\\n            : _daysAmount;\\n    }\\n\\n    /**\\n     * @dev Helper for the days math of calcualte penalties.\\n     * Returns +1 per day before the 4th day and +2 for each day after the 4th day\\n     */\\n    function getLateDays()\\n        public\\n        view\\n        returns (uint256 late)\\n    {\\n        late = block.timestamp \\u003e nextDueTime\\n            ? (block.timestamp - nextDueTime) / SECONDS_IN_DAY : 0;\\n    }\\n\\n    /**\\n     * @dev Calulate how much the usage fee takes off a payments,\\n     * and how many tokens are due per second of loan\\n     * (epochPayback is amount of tokens to extend loan by 1 second. Only need to pay off earnings)\\n     */\\n    function calculatePaybacks(\\n        uint256 _totalValue,\\n        uint256 _paymentTime,\\n        uint256 _paymentRate\\n    )\\n        public\\n        pure\\n        returns (\\n            uint256 totalPayback,\\n            uint256 epochPayback,\\n            uint256 teamsPayback\\n        )\\n    {\\n        totalPayback = (_paymentRate + PRECISION_R)\\n            * _totalValue\\n            / PRECISION_R;\\n\\n        teamsPayback = (totalPayback - _totalValue)\\n            * FEE\\n            / PRECISION_R;\\n\\n        epochPayback = (totalPayback - _totalValue)\\n            / _paymentTime;\\n    }\\n\\n    /**\\n     * @dev Calculate how many sends should be added before the next payoff is due based on payment amount\\n     */\\n    function calculateEpoch(\\n        uint256 _totalValue,\\n        uint256 _paymentTime,\\n        uint256 _paymentRate\\n    )\\n        public\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = _totalValue\\n            * _paymentRate\\n            / PRECISION_R\\n            / _paymentTime;\\n    }\\n\\n    /**\\n     * @dev Claim payed back tokens\\n     */\\n    function claimInterest()\\n        external\\n    {\\n        address provider = singleProvider;\\n\\n        require(\\n            provider == ZERO_ADDRESS ||\\n            provider == msg.sender,\\n            \\\"LiquidLocker: NOT_AUTHORIZED\\\"\\n        );\\n\\n        _claimInterest(\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * @dev Does the internal work of claiming payed back tokens.\\n     * Amount to claimed is based on share of contributions, and we record what someone has claimed in the\\n     * compensations mapping\\n     */\\n    function _claimInterest(\\n        address _claimAddress\\n    )\\n        internal\\n    {\\n        uint256 claimAmount = claimableBalance\\n            * contributions[_claimAddress]\\n            / totalCollected;\\n\\n        uint256 tokensToTransfer = claimAmount\\n            - compensations[_claimAddress];\\n\\n        compensations[_claimAddress] = claimAmount;\\n\\n        _safeTransfer(\\n            PAYMENT_TOKEN,\\n            _claimAddress,\\n            tokensToTransfer\\n        );\\n\\n        emit ClaimMade(\\n            tokensToTransfer,\\n            _claimAddress\\n        );\\n    }\\n\\n    /**\\n     * @dev Does the internal reset and transfer for refunding tokens on either condition that refunds are issued\\n     */\\n    function _refundTokens(\\n        uint256 _refundAmount,\\n        address _refundAddress\\n    )\\n        internal\\n    {\\n        contributions[_refundAddress] =\\n        contributions[_refundAddress] - _refundAmount;\\n\\n        _safeTransfer(\\n            PAYMENT_TOKEN,\\n            _refundAddress,\\n            _refundAmount\\n        );\\n\\n        emit RefundMade(\\n            _refundAmount,\\n            _refundAddress\\n        );\\n    }\\n}\\n\"},\"LiquidTransfer.sol\":{\"content\":\"// SPDX-License-Identifier: WISE\\n\\npragma solidity =0.8.12;\\n\\ncontract LiquidTransfer {\\n\\n    // cryptoPunks contract address\\n    address constant PUNKS = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\\n\\n    // local: 0xEb59fE75AC86dF3997A990EDe100b90DDCf9a826;\\n    // ropsten: 0x2f1dC6E3f732E2333A7073bc65335B90f07fE8b0;\\n    // mainnet: 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\\n\\n    // cryptoKitties contract address\\n    address constant KITTIES = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\\n\\n    /* @dev\\n    * Checks if contract is nonstandard, does transfer according to contract implementation\\n    */\\n    function _transferNFT(\\n        address _from,\\n        address _to,\\n        address _tokenAddress,\\n        uint256 _tokenId\\n    )\\n        internal\\n    {\\n        bytes memory data;\\n\\n        if (_tokenAddress == KITTIES) {\\n            data = abi.encodeWithSignature(\\n                \\\"transfer(address,uint256)\\\",\\n                _to,\\n                _tokenId\\n            );\\n        } else if (_tokenAddress == PUNKS) {\\n            data = abi.encodeWithSignature(\\n                \\\"transferPunk(address,uint256)\\\",\\n                _to,\\n                _tokenId\\n            );\\n        } else {\\n            data = abi.encodeWithSignature(\\n                \\\"safeTransferFrom(address,address,uint256)\\\",\\n                _from,\\n                _to,\\n                _tokenId\\n            );\\n        }\\n\\n        (bool success,) = address(_tokenAddress).call(\\n            data\\n        );\\n\\n        require(\\n            success == true,\\n            \\u0027NFT_TRANSFER_FAILED\\u0027\\n        );\\n    }\\n\\n    /* @dev\\n    * Checks if contract is nonstandard, does transferFrom according to contract implementation\\n    */\\n    function _transferFromNFT(\\n        address _from,\\n        address _to,\\n        address _tokenAddress,\\n        uint256 _tokenId\\n    )\\n        internal\\n    {\\n        bytes memory data;\\n\\n        if (_tokenAddress == KITTIES) {\\n            data = abi.encodeWithSignature(\\n                \\\"transferFrom(address,address,uint256)\\\",\\n                _from,\\n                _to,\\n                _tokenId\\n            );\\n        } else if (_tokenAddress == PUNKS) {\\n            bytes memory punkIndexToAddress = abi.encodeWithSignature(\\n                \\\"punkIndexToAddress(uint256)\\\",\\n                _tokenId\\n            );\\n\\n            (bool checkSuccess, bytes memory result) = address(_tokenAddress).staticcall(\\n                punkIndexToAddress\\n            );\\n\\n            (address owner) = abi.decode(\\n                result,\\n                (address)\\n            );\\n\\n            require(\\n                checkSuccess \\u0026\\u0026\\n                owner == msg.sender,\\n                \\u0027INVALID_OWNER\\u0027\\n            );\\n\\n            bytes memory buyData = abi.encodeWithSignature(\\n                \\\"buyPunk(uint256)\\\",\\n                _tokenId\\n            );\\n\\n            (bool buySuccess, bytes memory buyResultData) = address(_tokenAddress).call(\\n                buyData\\n            );\\n\\n            require(\\n                buySuccess,\\n                string(buyResultData)\\n            );\\n\\n            data = abi.encodeWithSignature(\\n                \\\"transferPunk(address,uint256)\\\",\\n                _to,\\n                _tokenId\\n            );\\n\\n        } else {\\n            data = abi.encodeWithSignature(\\n                \\\"safeTransferFrom(address,address,uint256)\\\",\\n                _from,\\n                _to,\\n                _tokenId\\n            );\\n        }\\n\\n        (bool success, bytes memory resultData) = address(_tokenAddress).call(\\n            data\\n        );\\n\\n        require(\\n            success,\\n            string(resultData)\\n        );\\n    }\\n\\n    event ERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes data\\n    );\\n\\n    function onERC721Received(\\n        address _operator,\\n        address _from,\\n        uint256 _tokenId,\\n        bytes calldata _data\\n    )\\n        external\\n        returns (bytes4)\\n    {\\n        emit ERC721Received(\\n            _operator,\\n            _from,\\n            _tokenId,\\n            _data\\n        );\\n\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimAddress\",\"type\":\"address\"}],\"name\":\"ClaimMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC721Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidatorAddress\",\"type\":\"address\"}],\"name\":\"Liquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paymentAddress\",\"type\":\"address\"}],\"name\":\"PaymentMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRateIncrease\",\"type\":\"uint256\"}],\"name\":\"PaymentRateIncrease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPaymentTime\",\"type\":\"uint256\"}],\"name\":\"PaymentTimeDecrease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refundAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"}],\"name\":\"RefundMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"singleProvider\",\"type\":\"address\"}],\"name\":\"SingleProvider\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONTRIBUTION_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEADLINE_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FACTORY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAYMENT_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRECISION_R\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_IN_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRUSTEE_MULTISIG\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"belowFloorAsked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_paymentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_paymentRate\",\"type\":\"uint256\"}],\"name\":\"calculateEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_paymentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_paymentRate\",\"type\":\"uint256\"}],\"name\":\"calculatePaybacks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalPayback\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epochPayback\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamsPayback\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"compensations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contributionPhase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPaymentTime\",\"type\":\"uint256\"}],\"name\":\"decreasePaymentTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableLocker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_donationAmount\",\"type\":\"uint256\"}],\"name\":\"donateFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prepayAmount\",\"type\":\"uint256\"}],\"name\":\"enableLocker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"floorAsked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"floorNotReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLateDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"late\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"paymentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentRate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lockerOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPaymntRate\",\"type\":\"uint256\"}],\"name\":\"increasePaymentRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenId\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_floorAsked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalAsked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_paymentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_paymentRate\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidateLocker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidateTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"makeContribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalIncrease\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usersIncrease\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"missedActivate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"missedDeadline\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextDueTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_checkAddress\",\"type\":\"address\"}],\"name\":\"notSingleProvider\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerlessLocker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_paymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_paymentAddress\",\"type\":\"address\"}],\"name\":\"payBackFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paybackTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentTimeNotSet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalCollected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lateDaysAmount\",\"type\":\"uint256\"}],\"name\":\"penaltyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contributor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"reachedTotal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_refundAddress\",\"type\":\"address\"}],\"name\":\"refundDueExpired\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_refundAddress\",\"type\":\"address\"}],\"name\":\"refundDueSingle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueLocker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"singleProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeStamp\",\"type\":\"uint256\"}],\"name\":\"timeSince\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAsked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPaymntRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newPaymentTime\",\"type\":\"uint256\"}],\"name\":\"updateSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LiquidLocker", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://78142176c07b5f452dd239149961b9ed8f943c203aca71edee97083bdaf1e47c"}]}