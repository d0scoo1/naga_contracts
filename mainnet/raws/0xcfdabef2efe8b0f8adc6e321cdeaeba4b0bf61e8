{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.5.17;\r\npragma experimental ABIEncoderV2;\r\n\r\n// librray for TokenDets\r\nlibrary TokenDetArrayLib {\r\n    // Using for array of strcutres for storing mintable address and token id\r\n    using TokenDetArrayLib for TokenDets;\r\n\r\n    struct TokenDet {\r\n        address NFTAddress;\r\n        uint256 tokenID;\r\n    }\r\n\r\n    // custom type array TokenDets\r\n    struct TokenDets {\r\n        TokenDet[] array;\r\n    }\r\n\r\n    function addTokenDet(\r\n        TokenDets storage self,\r\n        TokenDet memory _tokenDet\r\n        // address _mintableAddress,\r\n        // uint256 _tokenID\r\n    ) public {\r\n        if (!self.exists(_tokenDet)) {\r\n            self.array.push(_tokenDet);\r\n        }\r\n    }\r\n\r\n    function getIndexByTokenDet(\r\n        TokenDets storage self,\r\n        TokenDet memory _tokenDet\r\n    ) internal view returns (uint256, bool) {\r\n        uint256 index;\r\n        bool tokenExists = false;\r\n        for (uint256 i = 0; i < self.array.length; i++) {\r\n            if (\r\n                self.array[i].NFTAddress == _tokenDet.NFTAddress &&\r\n                self.array[i].tokenID == _tokenDet.tokenID \r\n            ) {\r\n                index = i;\r\n                tokenExists = true;\r\n                break;\r\n            }\r\n        }\r\n        return (index, tokenExists);\r\n    }\r\n\r\n    function removeTokenDet(\r\n        TokenDets storage self,\r\n        TokenDet memory _tokenDet\r\n    ) internal returns (bool) {\r\n        (uint256 i, bool tokenExists) = self.getIndexByTokenDet(_tokenDet);\r\n        if (tokenExists == true) {\r\n            self.array[i] = self.array[self.array.length - 1];\r\n            self.array.pop();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function exists(\r\n        TokenDets storage self,\r\n        TokenDet memory _tokenDet\r\n    ) internal view returns (bool) {\r\n        for (uint256 i = 0; i < self.array.length; i++) {\r\n            if (\r\n                self.array[i].NFTAddress == _tokenDet.NFTAddress &&\r\n                self.array[i].tokenID == _tokenDet.tokenID\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    // event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        // address msgSender = _msgSender();\r\n        _owner = msg.sender;\r\n        // emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        // emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n// library for erc20address array \r\nlibrary ERC20Addresses {\r\n    using ERC20Addresses for erc20Addresses;\r\n\r\n    struct erc20Addresses {\r\n        address[] array;\r\n    }\r\n\r\n    function addERC20Tokens(erc20Addresses storage self, address erc20address)\r\n        external\r\n    {\r\n        self.array.push(erc20address);\r\n    }\r\n\r\n    function getIndexByERC20Token(\r\n        erc20Addresses storage self,\r\n        address _ercTokenAddress\r\n    ) internal view returns (uint256, bool) {\r\n        uint256 index;\r\n        bool exists;\r\n\r\n        for (uint256 i = 0; i < self.array.length; i++) {\r\n            if (self.array[i] == _ercTokenAddress) {\r\n                index = i;\r\n                exists = true;\r\n\r\n                break;\r\n            }\r\n        }\r\n        return (index, exists);\r\n    }\r\n\r\n    function removeERC20Token(\r\n        erc20Addresses storage self,\r\n        address _ercTokenAddress\r\n    ) internal {\r\n        if (self.array.length > 1){\r\n            for (uint256 i = 0; i < self.array.length; i++) {\r\n                    if (\r\n                        self.array[i] == _ercTokenAddress \r\n                    ) {\r\n                        delete self.array[i];\r\n                    }\r\n                }\r\n        }\r\n        else{\r\n            self.array.length = 0;\r\n        }\r\n    }\r\n    function exists(\r\n        erc20Addresses storage self,\r\n        address _ercTokenAddress\r\n    ) internal view returns (bool) {\r\n        for (uint256 i = 0; i < self.array.length; i++) {\r\n            if (\r\n                self.array[i] == _ercTokenAddress \r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ncontract IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) public returns (bytes4);\r\n}\r\n\r\ncontract ERC721Holder is IERC721Receiver {\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes memory\r\n    ) public returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\ncontract IMintableToken {\r\n    // Required methods\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n\r\n    function royalities(uint256 _tokenId) public view returns (uint256);\r\n\r\n    function creators(uint256 _tokenId) public view returns (address payable);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public;\r\n\r\n    function getApproved(uint256 tokenId)\r\n        public\r\n        view\r\n        returns (address operator);\r\n        \r\n    function isApprovedForAll(address owner, address operator)\r\n        public\r\n        view\r\n        returns (bool);\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n\r\ncontract Storage is Ownable {\r\n    using TokenDetArrayLib for TokenDetArrayLib.TokenDets;\r\n    using ERC20Addresses for ERC20Addresses.erc20Addresses;\r\n    // address owner;\r\n    // address owner;\r\n    uint16 public rewardDistributionPercentage;\r\n    uint16 public platFormFeePercentage;   \r\n    uint16 public lpStakefeepercentage; \r\n    // uint16 public brokerage;\r\n    uint256 public updateClosingTime;\r\n\r\n    mapping(address => mapping(uint256 => bool)) tokenOpenForSale;\r\n    mapping(address => TokenDetArrayLib.TokenDets) tokensForSalePerUser;\r\n    TokenDetArrayLib.TokenDets fixedPriceTokens;\r\n    TokenDetArrayLib.TokenDets auctionTokens;\r\n\r\n    //auction type :\r\n    // 1 : only direct buy\r\n    // 2 : only bid\r\n    // 3 : both buy and bid\r\n\r\n    struct auction {\r\n        address payable lastOwner;\r\n        uint256 currentBid;\r\n        address payable highestBidder;\r\n        uint256 auctionType;\r\n        uint256 startingPrice;\r\n        uint256 buyPrice;\r\n        bool buyer;\r\n        uint256 startingTime;\r\n        uint256 closingTime;\r\n        address erc20Token;\r\n    }\r\n\r\n    struct OfferDetails {\r\n        address offerer;\r\n        uint256 amount;\r\n    }\r\n    \r\n    /** Offer mapping\r\n     * {\r\n     *      ERC721Address:{\r\n     *          tokenId:{\r\n     *               ERC20Address{\r\n     *                   offerer: Address of offerer,\r\n     *                   amount: Offer in this currency\r\n     *               }\r\n     *           }\r\n     *       }   \r\n     * }\r\n     */\r\n    mapping(\r\n        address => mapping( \r\n            uint256 => mapping(\r\n                address => OfferDetails\r\n            )\r\n        )\r\n    ) public offerprice;\r\n\r\n    mapping(address => mapping(uint256 => auction)) public auctions;\r\n\r\n    TokenDetArrayLib.TokenDets tokensForSale;\r\n    ERC20Addresses.erc20Addresses erc20TokensArray;\r\n\r\n    address public WETHAddress;\r\n    address public StakeAddress;\r\n    address public LPStakeAddress;\r\n    function getErc20Tokens()\r\n        public\r\n        view\r\n        returns (ERC20Addresses.erc20Addresses memory)\r\n    {\r\n        return erc20TokensArray;\r\n    }\r\n\r\n    function getTokensForSale()\r\n        public\r\n        view\r\n        returns (TokenDetArrayLib.TokenDet[] memory)\r\n    {\r\n        return tokensForSale.array;\r\n    }\r\n\r\n    function getFixedPriceTokensForSale()\r\n        public\r\n        view\r\n        returns (TokenDetArrayLib.TokenDet[] memory)\r\n    {\r\n        return fixedPriceTokens.array;\r\n    }\r\n\r\n    function getAuctionTokensForSale()\r\n        public\r\n        view\r\n        returns (TokenDetArrayLib.TokenDet[] memory)\r\n    {\r\n        return auctionTokens.array;\r\n    }\r\n\r\n    function getTokensForSalePerUser(address _user)\r\n        public\r\n        view\r\n        returns (TokenDetArrayLib.TokenDet[] memory)\r\n    {\r\n        return tokensForSalePerUser[_user].array;\r\n    }\r\n\r\n    // function setBrokerage(uint16 _brokerage) public onlyOwner {\r\n    //     brokerage = _brokerage;\r\n    // }\r\n\r\n\r\n      function setBrokerage(address _rewardDistributionAddress,address _lpStakeAddress ,uint16 _lpStakefeepercentage, uint16 _rewardDistributionPercentage, uint16 _platFormFeePercentage) public onlyOwner {\r\n        require(_rewardDistributionAddress != address(0) &&_lpStakeAddress!=address(0), \"Address is Zero\");\r\n        require(_rewardDistributionPercentage >= 0 && _platFormFeePercentage >= 0 &&_lpStakefeepercentage>=0, \"should be greater than zero\");\r\n        require(_rewardDistributionPercentage <= 1000 && _platFormFeePercentage <= 1000 && _lpStakefeepercentage<=1000, \"should be greater than zero\");\r\n        rewardDistributionPercentage = _rewardDistributionPercentage;\r\n        platFormFeePercentage = _platFormFeePercentage;\r\n        lpStakefeepercentage=_lpStakefeepercentage;\r\n        StakeAddress = _rewardDistributionAddress;\r\n        LPStakeAddress = _lpStakeAddress;\r\n    }\r\n\r\n    function setUpdatedClosingTime(uint256 _updateTime) public onlyOwner {\r\n        updateClosingTime = _updateTime;\r\n    }\r\n\r\n    function setAddress(address _weth, address _rewardDistributionAddress) external onlyOwner {\r\n        WETHAddress =_weth;\r\n        StakeAddress = _rewardDistributionAddress;\r\n    }\r\n}\r\n\r\ncontract BrokerModifiers is Storage {\r\n    modifier erc20Allowed(address _erc20Token) {\r\n        if (_erc20Token != address(0)) {\r\n            require(\r\n                erc20TokensArray.exists(_erc20Token),\r\n                \"ERC20 not allowed\"\r\n            );\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onSaleOnly(uint256 tokenID, address _mintableToken) {\r\n        require(\r\n            tokenOpenForSale[_mintableToken][tokenID] == true,\r\n            \"Token Not For Sale\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier activeAuction(uint256 tokenID, address _mintableToken) {\r\n        require(\r\n            block.timestamp < auctions[_mintableToken][tokenID].closingTime,\r\n            \"Auction Time Over!\"\r\n        );\r\n        require(\r\n            block.timestamp > auctions[_mintableToken][tokenID].startingTime,\r\n            \"Auction Not Started yet!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier auctionOnly(uint256 tokenID, address _mintableToken) {\r\n        require(\r\n            auctions[_mintableToken][tokenID].auctionType != 1,\r\n            \"Auction Not For Bid\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier flatSaleOnly(uint256 tokenID, address _mintableToken) {\r\n        require(\r\n            auctions[_mintableToken][tokenID].auctionType != 2,\r\n            \"For flat sale only!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier tokenOwnerOnlly(uint256 tokenID, address _mintableToken) {\r\n        // Sender will be owner only if no have bidded on auction.\r\n        require(\r\n            IMintableToken(_mintableToken).ownerOf(tokenID) == msg.sender,\r\n            \"You must be owner and Token should not have any bid\"\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\npragma solidity ^0.5.17;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n    function transfer(address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IStake{\r\n    function receiveWETHFee(uint256 amount) external;\r\n}\r\n\r\ninterface ILPStake{\r\n    function receiveWETHFee(uint256 amount) external;\r\n}\r\n\r\ncontract BrokerV2 is ERC721Holder, BrokerModifiers {\r\n    // events\r\n    event Bid(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        address bidder,\r\n        uint256 amouont,\r\n        uint256 time,\r\n        address ERC20Address\r\n    );\r\n    event Buy(\r\n        address indexed collection,\r\n        uint256 tokenId,\r\n        address indexed seller,\r\n        address indexed buyer,\r\n        uint256 amount,\r\n        uint256 time,\r\n        address ERC20Address,\r\n        bool isOffer\r\n    );\r\n    event Collect(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        address buyer,\r\n        address collector,\r\n        uint256 time,\r\n        address ERC20Address\r\n    );\r\n    event OnSale(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        uint256 auctionType,\r\n        uint256 amount,\r\n        uint256 time,\r\n        address ERC20Address\r\n    );\r\n    event PriceUpdated(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        uint256 auctionType,\r\n        uint256 oldAmount,\r\n        uint256 amount,\r\n        uint256 time,\r\n        address ERC20Address\r\n    );\r\n    event OffSale(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        uint256 time,\r\n        address ERC20Address\r\n    );\r\n\r\n    event MakeAnOffer(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed offerer,\r\n        address erc20Token,\r\n        uint256 offerAmount\r\n    );\r\n\r\n    mapping(address => uint256) public brokerageBalance;\r\n\r\n    //Struct of Asset\r\n    struct Asset {\r\n        uint256 _tokenID;\r\n        uint256 _startingPrice;\r\n        uint256 _auctionType;\r\n        uint256 _buyPrice;\r\n        uint256 _startingTime;\r\n        uint256 _closingTime;\r\n        address _mintableToken;\r\n        address _erc20Token;\r\n    }\r\n\r\n    //Struct of Pair\r\n    struct Pair {\r\n        uint256 tokenID;\r\n        address _mintableToken;\r\n    }    \r\n\r\n    constructor(\r\n        uint16 _rewardDistributionPercentage,\r\n        uint16 _platFormFeePercentage,\r\n        uint16 _lpStakefeepercentage,\r\n        uint256 _updatedTime,\r\n        address _weth,\r\n        address _rewardDistributionAddress,\r\n        address _lpStakeAddress\r\n    ) public {\r\n        rewardDistributionPercentage = _rewardDistributionPercentage;\r\n        platFormFeePercentage = _platFormFeePercentage;\r\n        setUpdatedClosingTime(_updatedTime);\r\n        transferOwnership(msg.sender);\r\n        WETHAddress =_weth;\r\n        StakeAddress = _rewardDistributionAddress;\r\n        LPStakeAddress = _lpStakeAddress;\r\n        lpStakefeepercentage = _lpStakefeepercentage;\r\n    }    \r\n\r\n    //Update contract parameter\r\n    function updateparams(\r\n        uint16 _rewardDistributionPercentage,\r\n        uint16 _platFormFeePercentage,\r\n        uint16 _lpStakefeepercentage,\r\n        uint256 _updatedTime,\r\n        address _weth,\r\n        address _rewardDistributionAddress,\r\n        address _lpStakeAddress\r\n    ) external onlyOwner {\r\n        \r\n        require(_rewardDistributionAddress != address(0) &&_lpStakeAddress!=address(0), \"Address is Zero\");\r\n        require(_rewardDistributionPercentage >= 0 && _platFormFeePercentage >= 0 &&_lpStakefeepercentage>=0, \"should be greater than zero\");\r\n        require(_rewardDistributionPercentage <= 1000 && _platFormFeePercentage <= 1000 && _lpStakefeepercentage<=1000, \"should be greater than zero\");\r\n       \r\n        rewardDistributionPercentage = _rewardDistributionPercentage;\r\n        platFormFeePercentage = _platFormFeePercentage;\r\n        setUpdatedClosingTime(_updatedTime);\r\n        WETHAddress =_weth;\r\n        StakeAddress = _rewardDistributionAddress;\r\n        LPStakeAddress = _lpStakeAddress;\r\n        lpStakefeepercentage = _lpStakefeepercentage;\r\n\r\n    }\r\n\r\n\r\n\r\n    // Method to create any offer for any NFT.\r\n    function makeAnOffer(\r\n        uint256 tokenID,\r\n        address _mintableToken,\r\n        address _erc20Token,\r\n        uint256 amount\r\n    ) public payable erc20Allowed(_erc20Token) {\r\n        // Allow offer only if token is not auction or auction have been ended withoud any bids.\r\n        if (auctions[_mintableToken][tokenID].auctionType == 2) {\r\n            require(\r\n                block.timestamp <\r\n                    auctions[_mintableToken][tokenID].closingTime &&\r\n                    !auctions[_mintableToken][tokenID].buyer,\r\n                \"Can not make an offer on an incomplete auction\"\r\n            );\r\n        }\r\n\r\n        // Check if the amount offered is better than previous\r\n        require(\r\n            amount >= offerprice[_mintableToken][tokenID][_erc20Token].amount,\r\n            \"amount is not less  than msg value\"\r\n        );\r\n\r\n        // Revert previous offer\r\n        _revertOffer(_mintableToken, tokenID, _erc20Token);\r\n\r\n        // If the offer is not native currency\r\n        if (_erc20Token == address(0)) {\r\n            require(msg.value >= amount, \"Value sent less than amount\");\r\n        } else {\r\n            IERC20 erc20Token = IERC20(_erc20Token);\r\n            require(\r\n                erc20Token.allowance(msg.sender, address(this)) >= amount,\r\n                \"Insufficient spent allowance \"\r\n            );\r\n            erc20Token.transferFrom(msg.sender, address(this), amount);\r\n        }\r\n\r\n        // Update the offer\r\n        offerprice[_mintableToken][tokenID][_erc20Token].offerer = msg.sender;\r\n        offerprice[_mintableToken][tokenID][_erc20Token].amount = amount;\r\n\r\n        // Trigger the event\r\n        emit MakeAnOffer(\r\n            _mintableToken,\r\n            tokenID,\r\n            msg.sender,\r\n            _erc20Token,\r\n            amount\r\n        );\r\n    }\r\n\r\n    // Method to accept an offer.\r\n    function accpetOffer(\r\n        uint256 tokenID,\r\n        address _mintableToken,\r\n        address _erc20Token,\r\n        bool isNotClubare\r\n    )\r\n        public\r\n        payable\r\n        flatSaleOnly(tokenID, _mintableToken)\r\n        tokenOwnerOnlly(tokenID, _mintableToken)\r\n        erc20Allowed(_erc20Token)\r\n    {\r\n        // Chekc offer details and offer exists.\r\n        OfferDetails memory _offer = offerprice[_mintableToken][tokenID][\r\n            _erc20Token\r\n        ];\r\n        require(\r\n            _offer.offerer != address(0),\r\n            \"selected candidate amount not match \"\r\n        );\r\n\r\n\r\n        IMintableToken Token = IMintableToken(_mintableToken);\r\n\r\n        _calculateFees(tokenID, _mintableToken, msg.sender, _erc20Token, _offer.amount, isNotClubare, false);\r\n\r\n        tokenOpenForSale[_mintableToken][tokenID] = false;\r\n\r\n        // Transfer the NFT\r\n        Token.safeTransferFrom(Token.ownerOf(tokenID), _offer.offerer, tokenID);\r\n\r\n        // Buy event\r\n        emit Buy(\r\n            _mintableToken,\r\n            tokenID,\r\n            msg.sender,\r\n            _offer.offerer,\r\n            _offer.amount,\r\n            block.timestamp,\r\n            _erc20Token,\r\n            true\r\n        );\r\n\r\n        // delete all auctin details.\r\n        delete offerprice[_mintableToken][tokenID][_erc20Token];\r\n        _revertAll(_mintableToken, tokenID);\r\n        TokenDetArrayLib.TokenDet memory _tokenDet = TokenDetArrayLib.TokenDet(\r\n            _mintableToken,\r\n            tokenID\r\n        );\r\n        tokensForSale.removeTokenDet(_tokenDet);\r\n        tokensForSalePerUser[msg.sender].removeTokenDet(_tokenDet);\r\n        fixedPriceTokens.removeTokenDet(_tokenDet);\r\n        delete auctions[_tokenDet.NFTAddress][_tokenDet.tokenID];\r\n    }\r\n\r\n    function _calculateFees(uint256 tokenID, address _collectionAddress, address payable _lastOwner2, address _erc20Token, uint256 amount, bool isNotClubare, bool isBuymethod) internal {\r\n\r\n        IMintableToken Token = IMintableToken(_collectionAddress);\r\n        {\r\n            uint256 royalities;\r\n            address payable creator;\r\n            uint256 royality;\r\n            if (!isNotClubare) {\r\n                royalities = Token.royalities(tokenID);\r\n                creator = Token.creators(tokenID);\r\n                royality = (royalities * amount) / 10000;\r\n            }\r\n\r\n            uint256 stakingAmt = ((rewardDistributionPercentage *\r\n                amount) / 10000);\r\n            uint256 lpStakingAmt = ((lpStakefeepercentage *\r\n                amount) / 10000);\r\n            uint256 brokerage = ((platFormFeePercentage *\r\n                amount) / 10000);\r\n\r\n            uint256 lastOwner_funds = amount -\r\n                royality -\r\n                stakingAmt -\r\n                lpStakingAmt-\r\n                brokerage;\r\n\r\n            address payable user = msg.sender;\r\n            address payable lastOwner2 = _lastOwner2;\r\n            IWETH weth = IWETH(WETHAddress);\r\n        \r\n            if (_erc20Token == address(0)) {\r\n                if (isBuymethod) {\r\n                    require(msg.value >= amount, \"Insufficient Payment\");                \r\n                }\r\n                if (!isNotClubare) {\r\n                    creator.transfer(royality);\r\n                }\r\n                lastOwner2.transfer(lastOwner_funds);\r\n                weth.deposit.value(stakingAmt+lpStakingAmt)();\r\n            } else {\r\n                IERC20 erc20Token = IERC20(_erc20Token);                \r\n                if (isBuymethod) {\r\n                    require(\r\n                        erc20Token.allowance(user, address(this)) >=\r\n                            amount,\r\n                        \"Insufficient spent allowance \"\r\n                    );\r\n                    erc20Token.transferFrom(user, address(this), brokerage + stakingAmt + lpStakingAmt);\r\n                    // transfer royalitiy to creator\r\n                    if (!isNotClubare) {\r\n                        erc20Token.transferFrom(user, creator, royality);\r\n                    }\r\n                    erc20Token.transferFrom(user, lastOwner2, lastOwner_funds);\r\n                } else {                    \r\n                    if (!isNotClubare) {\r\n                        erc20Token.transfer(creator, royality);\r\n                    }\r\n                    erc20Token.transfer(lastOwner2, lastOwner_funds);\r\n                }\r\n            }\r\n            if(_erc20Token==address(0)|| _erc20Token==WETHAddress){\r\n                if(stakingAmt > 0) {\r\n                    weth.approve(address(StakeAddress), stakingAmt);\r\n                    IStake stake = IStake(StakeAddress);\r\n                    stake.receiveWETHFee(stakingAmt);\r\n                }\r\n                if(lpStakingAmt > 0) {\r\n                    weth.approve(address(LPStakeAddress), lpStakingAmt);\r\n                    ILPStake lpStake = ILPStake(LPStakeAddress);\r\n                    lpStake.receiveWETHFee(lpStakingAmt);\r\n                }\r\n            }\r\n        \r\n            // Update the brokerage and auction state of NFT\r\n            address _stackDeep_erc20Token = _erc20Token;\r\n            brokerageBalance[_stackDeep_erc20Token] += brokerage + stakingAmt + lpStakingAmt;\r\n        }\r\n    }\r\n\r\n    // Method to update revert the current offer.\r\n    function _revertOffer(\r\n        address _mintableToken,\r\n        uint256 tokenID,\r\n        address _erc20Token\r\n    ) internal {\r\n        // If there is any amount offered for this currency\r\n        if (\r\n            offerprice[_mintableToken][tokenID][_erc20Token].amount > 0 &&\r\n            offerprice[_mintableToken][tokenID][_erc20Token].offerer !=\r\n            address(0)\r\n        ) {\r\n            // Revert amount for native currency\r\n            if (_erc20Token == address(0)) {\r\n                address(\r\n                    uint160(\r\n                        offerprice[_mintableToken][tokenID][_erc20Token].offerer\r\n                    )\r\n                ).transfer(\r\n                        offerprice[_mintableToken][tokenID][_erc20Token].amount\r\n                    );\r\n            } else {\r\n                // Revert other currency\r\n                IERC20 erc20 = IERC20(_erc20Token);\r\n                erc20.transfer(\r\n                    offerprice[_mintableToken][tokenID][_erc20Token].offerer,\r\n                    offerprice[_mintableToken][tokenID][_erc20Token].amount\r\n                );\r\n            }\r\n\r\n            // Delete the mapping to gas reward.\r\n            delete offerprice[_mintableToken][tokenID][_erc20Token];\r\n        }\r\n    }\r\n\r\n    // Method to revert all offers on current tokenId.\r\n    function _revertAll(address _mintableToken, uint256 tokenID) internal {\r\n        for (uint256 i = 0; i < erc20TokensArray.array.length; i++) {\r\n            _revertOffer(_mintableToken, tokenID, erc20TokensArray.array[i]);\r\n        }\r\n    }\r\n\r\n    // Public method to revert offer\r\n    function revertOffer(\r\n        address _mintableToken,\r\n        uint256 tokenID,\r\n        address _erc20Token\r\n    ) public payable {\r\n        // only allowed to token owner of offerer\r\n        require(\r\n            msg.sender ==\r\n                offerprice[_mintableToken][tokenID][_erc20Token].offerer ||\r\n                IMintableToken(_mintableToken).ownerOf(tokenID) == msg.sender,\r\n            \"You must be offerer or owner to remove the offer.\"\r\n        );\r\n        // Must be valid offer\r\n        require(\r\n            offerprice[_mintableToken][tokenID][_erc20Token].amount > 0 &&\r\n                offerprice[_mintableToken][tokenID][_erc20Token].offerer !=\r\n                address(0),\r\n            \" Offer doesn't exist. \"\r\n        );\r\n        // revert offer\r\n        _revertOffer(_mintableToken, tokenID, _erc20Token);\r\n    }\r\n\r\n    // Public method to allow token owner to discard all offers\r\n    function revertAll(address _mintableToken, uint256 tokenID)\r\n        public\r\n        tokenOwnerOnlly(tokenID, _mintableToken)\r\n    {\r\n        _revertAll(_mintableToken, tokenID);\r\n    }\r\n\r\n    function addERC20TokenPayment(address _erc20Token) public onlyOwner {\r\n        erc20TokensArray.addERC20Tokens(_erc20Token);\r\n    }\r\n\r\n    function removeERC20TokenPayment(address _erc20Token)\r\n        public\r\n        erc20Allowed(_erc20Token)\r\n        onlyOwner\r\n    {\r\n        erc20TokensArray.removeERC20Token(_erc20Token);\r\n    }\r\n\r\n    function bid(\r\n        uint256 tokenID,\r\n        address _mintableToken,\r\n        uint256 amount\r\n    )\r\n        public\r\n        payable\r\n        onSaleOnly(tokenID, _mintableToken)\r\n        activeAuction(tokenID, _mintableToken)\r\n    {\r\n        IMintableToken Token = IMintableToken(_mintableToken);\r\n\r\n        auction memory _auction = auctions[_mintableToken][tokenID];\r\n\r\n        if (_auction.erc20Token == address(0)) {\r\n            require(\r\n                msg.value > _auction.currentBid,\r\n                \"Insufficient bidding amount.\"\r\n            );\r\n\r\n            if (_auction.buyer == true) {\r\n                _auction.highestBidder.transfer(_auction.currentBid);\r\n            }\r\n        } else {\r\n            IERC20 erc20Token = IERC20(_auction.erc20Token);\r\n            require(\r\n                erc20Token.allowance(msg.sender, address(this)) >= amount,\r\n                \"Allowance is less than amount sent for bidding.\"\r\n            );\r\n            require(\r\n                amount > _auction.currentBid,\r\n                \"Insufficient bidding amount.\"\r\n            );\r\n            erc20Token.transferFrom(msg.sender, address(this), amount);\r\n\r\n            if (_auction.buyer == true) {\r\n                erc20Token.transfer(\r\n                    _auction.highestBidder,\r\n                    _auction.currentBid\r\n                );\r\n            }\r\n        }\r\n\r\n        _auction.currentBid = _auction.erc20Token == address(0)\r\n            ? msg.value\r\n            : amount;\r\n\r\n        Token.safeTransferFrom(Token.ownerOf(tokenID), address(this), tokenID);\r\n        _auction.buyer = true;\r\n        _auction.highestBidder = msg.sender;\r\n        _auction.closingTime += updateClosingTime;\r\n        auctions[_mintableToken][tokenID] = _auction;\r\n\r\n        // Bid event\r\n        emit Bid(\r\n            _mintableToken,\r\n            tokenID,\r\n            _auction.lastOwner,\r\n            _auction.highestBidder,\r\n            _auction.currentBid,\r\n            block.timestamp,\r\n            _auction.erc20Token\r\n        );\r\n    }\r\n\r\n    struct TokenDetails {\r\n        uint256 tokenID;\r\n        address _mintableToken;\r\n        bool isNotClubare;\r\n    }\r\n\r\n    // Collect Function are use to collect funds and NFT from Broker\r\n    function collect(\r\n        uint256 tokenID,\r\n        address _mintableToken,\r\n        bool isNotClubare\r\n    ) public {\r\n        IMintableToken Token = IMintableToken(_mintableToken);\r\n        auction memory _auction = auctions[_mintableToken][tokenID];\r\n        TokenDetArrayLib.TokenDet memory _tokenDet = TokenDetArrayLib.TokenDet(\r\n            _mintableToken,\r\n            tokenID\r\n        );\r\n        require(\r\n            block.timestamp > _auction.closingTime && _auction.auctionType == 2,\r\n            \"Auction Not Over!\"\r\n        );\r\n        \r\n        if (_auction.buyer == true) {\r\n            address payable lastOwner2 = _auction.lastOwner;\r\n             _calculateFees(tokenID, _mintableToken, lastOwner2, _auction.erc20Token, _auction.currentBid, isNotClubare, false);\r\n\r\n            {\r\n                //Scope added for stack too deep error\r\n                uint id = tokenID;\r\n                auction memory auction = _auction;\r\n                Token.safeTransferFrom(\r\n                    Token.ownerOf(id),\r\n                    auction.highestBidder,\r\n                    id\r\n                );\r\n\r\n                // Buy event\r\n                emit Buy(\r\n                    _tokenDet.NFTAddress,\r\n                    _tokenDet.tokenID,\r\n                    lastOwner2,\r\n                    auction.highestBidder,\r\n                    auction.currentBid,\r\n                    block.timestamp,\r\n                    auction.erc20Token,\r\n                    false\r\n                );\r\n                // Revert all the offers.\r\n                _revertAll(_mintableToken, id);\r\n            }\r\n\r\n            // Collect event\r\n            emit Collect(\r\n                _tokenDet.NFTAddress,\r\n                _tokenDet.tokenID,\r\n                lastOwner2,\r\n                _auction.highestBidder,\r\n                msg.sender,\r\n                block.timestamp,\r\n                _auction.erc20Token\r\n            );\r\n            tokenOpenForSale[_mintableToken][tokenID] = false;\r\n            tokensForSale.removeTokenDet(_tokenDet);\r\n\r\n            tokensForSalePerUser[lastOwner2].removeTokenDet(_tokenDet);\r\n            auctionTokens.removeTokenDet(_tokenDet);\r\n            delete auctions[_mintableToken][tokenID];\r\n        }\r\n    }\r\n\r\n    function buy(\r\n        uint256 tokenID,\r\n        address _mintableToken,\r\n        bool isNotClubare\r\n    )\r\n        public\r\n        payable\r\n        onSaleOnly(tokenID, _mintableToken)\r\n        flatSaleOnly(tokenID, _mintableToken)\r\n    {\r\n        IMintableToken Token = IMintableToken(_mintableToken);\r\n        auction memory _auction = auctions[_mintableToken][tokenID];\r\n        TokenDetArrayLib.TokenDet memory _tokenDet = TokenDetArrayLib.TokenDet(\r\n            _mintableToken,\r\n            tokenID\r\n        );\r\n        address payable lastOwner2 = _auction.lastOwner;\r\n        _calculateFees(tokenID, _mintableToken, lastOwner2, _auction.erc20Token, _auction.buyPrice, isNotClubare, true);\r\n\r\n        tokenOpenForSale[_tokenDet.NFTAddress][_tokenDet.tokenID] = false;\r\n\r\n        Token.safeTransferFrom(\r\n            Token.ownerOf(_tokenDet.tokenID),\r\n            msg.sender,\r\n            _tokenDet.tokenID\r\n        );\r\n\r\n        // Buy event\r\n        emit Buy(\r\n            _tokenDet.NFTAddress,\r\n            _tokenDet.tokenID,\r\n            lastOwner2,\r\n            msg.sender,\r\n            _auction.buyPrice,\r\n            block.timestamp,\r\n            _auction.erc20Token,\r\n            false\r\n        );\r\n\r\n        tokensForSale.removeTokenDet(_tokenDet);\r\n        tokensForSalePerUser[lastOwner2].removeTokenDet(_tokenDet);\r\n\r\n        fixedPriceTokens.removeTokenDet(_tokenDet);\r\n        delete auctions[_tokenDet.NFTAddress][_tokenDet.tokenID];\r\n        _revertAll(_tokenDet.NFTAddress, _tokenDet.tokenID);\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        msg.sender.transfer(brokerageBalance[address(0)]);\r\n        brokerageBalance[address(0)] = 0;\r\n    }\r\n\r\n    function withdrawERC20(address _erc20Token) public onlyOwner {\r\n        require(\r\n            erc20TokensArray.exists(_erc20Token),\r\n            \"This erc20token payment not allowed\"\r\n        );\r\n        IERC20 erc20Token = IERC20(_erc20Token);\r\n        erc20Token.transfer(msg.sender, brokerageBalance[_erc20Token]);\r\n        brokerageBalance[_erc20Token] = 0;\r\n    }\r\n\r\n    function putOnSale(\r\n        uint256 _tokenID,\r\n        uint256 _startingPrice,\r\n        uint256 _auctionType,\r\n        uint256 _buyPrice,\r\n        uint256 _startingTime,\r\n        uint256 _closingTime,\r\n        address _mintableToken,\r\n        address _erc20Token\r\n    )\r\n        public\r\n        erc20Allowed(_erc20Token)\r\n        tokenOwnerOnlly(_tokenID, _mintableToken)\r\n    {\r\n        IMintableToken Token = IMintableToken(_mintableToken);\r\n        auction memory _auction = auctions[_mintableToken][_tokenID];\r\n\r\n        // Allow to put on sale to already on sale NFT \\\r\n        // only if it was on auction and have 0 bids and auction is over\r\n        if (tokenOpenForSale[_mintableToken][_tokenID] == true) {\r\n            require(\r\n                _auction.auctionType == 2 &&\r\n                    _auction.buyer == false &&\r\n                    block.timestamp > _auction.closingTime,\r\n                \"This NFT is already on sale.\"\r\n            );\r\n        }\r\n        TokenDetArrayLib.TokenDet memory _tokenDet = TokenDetArrayLib.TokenDet(\r\n            _mintableToken,\r\n            _tokenID\r\n        );\r\n        auction memory newAuction = auction(\r\n            msg.sender,\r\n            _startingPrice,\r\n            address(0),\r\n            _auctionType,\r\n            _startingPrice,\r\n            _buyPrice,\r\n            false,\r\n            _startingTime,\r\n            _closingTime,\r\n            _erc20Token\r\n        );\r\n\r\n        require(\r\n            (Token.isApprovedForAll(msg.sender, address(this)) ||\r\n                Token.getApproved(_tokenDet.tokenID) == address(this)),\r\n            \"Broker Not approved\"\r\n        );\r\n        require(\r\n            _closingTime > _startingTime,\r\n            \"Closing time should be greater than starting time!\"\r\n        );\r\n        auctions[_tokenDet.NFTAddress][_tokenDet.tokenID] = newAuction;\r\n\r\n        // Store data in all mappings if adding fresh token on sale\r\n        if (\r\n            tokenOpenForSale[_tokenDet.NFTAddress][_tokenDet.tokenID] == false\r\n        ) {\r\n            tokenOpenForSale[_tokenDet.NFTAddress][_tokenDet.tokenID] = true;\r\n\r\n            tokensForSale.addTokenDet(_tokenDet);\r\n            tokensForSalePerUser[msg.sender].addTokenDet(_tokenDet);\r\n\r\n            // Add token to fixedPrice on Timed list\r\n            if (_auctionType == 1) {\r\n                fixedPriceTokens.addTokenDet(_tokenDet);\r\n            } else if (_auctionType == 2) {\r\n                auctionTokens.addTokenDet(_tokenDet);\r\n            }\r\n        }\r\n\r\n        // OnSale event\r\n        emit OnSale(\r\n            _tokenDet.NFTAddress,\r\n            _tokenDet.tokenID,\r\n            msg.sender,\r\n            newAuction.auctionType,\r\n            newAuction.auctionType == 1\r\n                ? newAuction.buyPrice\r\n                : newAuction.startingPrice,\r\n            block.timestamp,\r\n            newAuction.erc20Token\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Bulk De listing from marketplace\r\n     * @param _assets array of struct Asset[]\r\n     **/\r\n    function batchListing(Asset[] calldata _assets) external {\r\n        for (uint i = 0; i < _assets.length; i++) {\r\n            Asset memory a = _assets[i];\r\n            putOnSale(\r\n                a._tokenID,\r\n                a._startingPrice,\r\n                a._auctionType,\r\n                a._buyPrice,\r\n                a._startingTime,\r\n                a._closingTime,\r\n                a._mintableToken,\r\n                a._erc20Token\r\n            );\r\n        }\r\n    }\r\n\r\n    function updatePrice(\r\n        uint256 tokenID,\r\n        address _mintableToken,\r\n        uint256 _newPrice,\r\n        address _erc20Token\r\n    )\r\n        public\r\n        onSaleOnly(tokenID, _mintableToken)\r\n        erc20Allowed(_erc20Token)\r\n        tokenOwnerOnlly(tokenID, _mintableToken)\r\n    {\r\n        // IMintableToken Token = IMintableToken(_mintableToken);\r\n        auction memory _auction = auctions[_mintableToken][tokenID];\r\n\r\n        if (_auction.auctionType == 2) {\r\n            require(\r\n                block.timestamp < _auction.closingTime,\r\n                \"Auction Time Over!\"\r\n            );\r\n        }\r\n        emit PriceUpdated(\r\n            _mintableToken,\r\n            tokenID,\r\n            _auction.lastOwner,\r\n            _auction.auctionType,\r\n            _auction.auctionType == 1\r\n                ? _auction.buyPrice\r\n                : _auction.startingPrice,\r\n            _newPrice,\r\n            block.timestamp,\r\n            _auction.erc20Token\r\n        );\r\n        // Update Price\r\n        if (_auction.auctionType == 1) {\r\n            _auction.buyPrice = _newPrice;\r\n        } else {\r\n            _auction.startingPrice = _newPrice;\r\n            _auction.currentBid = _newPrice;\r\n        }\r\n        _auction.erc20Token = _erc20Token;\r\n        auctions[_mintableToken][tokenID] = _auction;\r\n    }\r\n\r\n    function putSaleOff(uint256 tokenID, address _mintableToken)\r\n        public\r\n        tokenOwnerOnlly(tokenID, _mintableToken)\r\n    {\r\n        // IMintableToken Token = IMintableToken(_mintableToken);\r\n        auction memory _auction = auctions[_mintableToken][tokenID];\r\n        TokenDetArrayLib.TokenDet memory _tokenDet = TokenDetArrayLib.TokenDet(\r\n            _mintableToken,\r\n            tokenID\r\n        );\r\n        tokenOpenForSale[_mintableToken][tokenID] = false;\r\n\r\n        // OffSale event\r\n        emit OffSale(\r\n            _mintableToken,\r\n            tokenID,\r\n            msg.sender,\r\n            block.timestamp,\r\n            _auction.erc20Token\r\n        );\r\n\r\n        tokensForSale.removeTokenDet(_tokenDet);\r\n\r\n        tokensForSalePerUser[msg.sender].removeTokenDet(_tokenDet);\r\n        // Remove token from list\r\n        if (_auction.auctionType == 1) {\r\n            fixedPriceTokens.removeTokenDet(_tokenDet);\r\n        } else if (_auction.auctionType == 2) {\r\n            auctionTokens.removeTokenDet(_tokenDet);\r\n        }\r\n        delete auctions[_mintableToken][tokenID];\r\n    }\r\n\r\n    /**\r\n     * @notice Bulk De listing from marketplace\r\n     * @param _pairs array of struct Pair[]\r\n     **/\r\n    function batchDelisting(Pair[] calldata _pairs) external {\r\n        for (uint i = 0; i < _pairs.length; i++) {\r\n            Pair memory p = _pairs[i];\r\n            putSaleOff(p.tokenID, p._mintableToken);\r\n        }\r\n    }\r\n\r\n    function getOnSaleStatus(address _mintableToken, uint256 tokenID)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return tokenOpenForSale[_mintableToken][tokenID];\r\n    }\r\n}", "ABI": "[]", "ContractName": "TokenDetArrayLib", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://a195a7a9b17b054b57413d3efacba905dc4bd79e27fb789a233845a0d8479e1c"}]}