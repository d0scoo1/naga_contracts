{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/StarkadeMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n// \u00a92022 Ponderware Ltd\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IERC20 {\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n}\\n\\ninterface IMoonCatSVGS {\\n    function uint2str (uint value) external pure returns (string memory);\\n}\\n\\ninterface IStarkade {\\n    function BoostNames (uint index) external view returns (string memory);\\n    function Attributes (uint index) external view returns (string memory);\\n    function getTraitIndexes (uint tokenId) external view returns (uint16[15] memory attributes, uint8[5] memory boosts);\\n    function traitName (uint256 traitIndex) external view returns (string memory);\\n    function cityInfo (uint256 cityId) external view returns (string memory regionName, string memory cityName, string memory characteristic);\\n}\\n\\n/*\\n * @title STARKADE Legion Metadata\\n * @author Ponderware Ltd\\n * @dev Metadata assembly contract for Starkade Legion NFT\\n * @license https://starkade.com/licences/nft/starkade-legion/\\n */\\n\\ncontract StarkadeMetadata {\\n\\n    // https://starkade.com/licences/nft/starkade-legion/\\n\\n    IMoonCatSVGS MoonCatSVGS = IMoonCatSVGS(0xB39C61fe6281324A23e079464f7E697F8Ba6968f);\\n    IStarkade immutable Starkade;\\n    string BASE_IMAGE_URI = \\\"https://starkade.com/api/legion/\\\";\\n    string public IPFS_Image_Cache_CID;\\n\\n    /**\\n     * @dev Encode a key/value pair as a JSON trait property, where the value is a numeric item (doesn't need quotes)\\n     */\\n    function encodeBoostAttribute (string memory key, uint8 value) internal view returns (bytes memory) {\\n        return abi.encodePacked(\\\"{\\\\\\\"trait_type\\\\\\\":\\\\\\\"\\\", key,\\\"\\\\\\\",\\\\\\\"value\\\\\\\":\\\",MoonCatSVGS.uint2str(value),\\n                                \\\",\\\\\\\"display_type\\\\\\\":\\\\\\\"boost_number\\\\\\\"}\\\");\\n    }\\n\\n    /**\\n     * @dev Encode a key/value pair as a JSON trait property, where the value is a string item (needs quotes around it)\\n     */\\n    function encodeStringAttribute (string memory key, string memory value) internal pure returns (bytes memory) {\\n        return abi.encodePacked(\\\"{\\\\\\\"trait_type\\\\\\\":\\\\\\\"\\\", key,\\\"\\\\\\\",\\\\\\\"value\\\\\\\":\\\\\\\"\\\",value,\\\"\\\\\\\"}\\\");\\n    }\\n\\n    /**\\n     * @dev Encode boosts as JSON attributes\\n     */\\n    function assembleBoosts (uint8[5] memory boosts) internal view returns (bytes memory) {\\n        return abi.encodePacked(encodeBoostAttribute(Starkade.BoostNames(0), boosts[0]), \\\",\\\",\\n                                encodeBoostAttribute(Starkade.BoostNames(1), boosts[1]), \\\",\\\",\\n                                encodeBoostAttribute(Starkade.BoostNames(2), boosts[2]), \\\",\\\",\\n                                encodeBoostAttribute(Starkade.BoostNames(3), boosts[3]), \\\",\\\",\\n                                encodeBoostAttribute(Starkade.BoostNames(4), boosts[4]));\\n    }\\n\\n    /**\\n     * @dev Encode character details as JSON attributes\\n     */\\n    function assembleBaseAttributes (uint16[15] memory attributes) internal view returns (string memory, bytes memory) {\\n        bytes memory result = \\\"\\\";\\n        for (uint i = 0; i < 13; i++) {\\n            result = abi.encodePacked(result, encodeStringAttribute(Starkade.Attributes(i), Starkade.traitName(attributes[i])), \\\",\\\");\\n        }\\n\\n        (string memory regionName, string memory cityName, string memory characteristic) = Starkade.cityInfo(attributes[14]);\\n\\n        return (regionName,\\n                abi.encodePacked(result, encodeStringAttribute(Starkade.Attributes(13), regionName), \\\",\\\"));\\n    }\\n\\n    /**\\n     * @dev Generate metadata description string\\n     */\\n    function description (string memory region) internal pure returns (bytes memory) {\\n        return abi.encodePacked(\\\"A legend is born. This fighter from \\\",region,\\\" is one of a set of unique characters from the STARKADE universe, inspired by the retro '80s artwork of Signalnoise.\\\");\\n    }\\n\\n    /**\\n     * @dev Assemble the imageURI for the given attributes\\n     */\\n    function imageURI (uint16[15] memory attributes) internal view returns (bytes memory) {\\n        bytes memory uri = bytes(BASE_IMAGE_URI);\\n        for (uint i = 1; i < 12; i++) {\\n            uri = abi.encodePacked(uri, MoonCatSVGS.uint2str(attributes[i]), \\\"-\\\");\\n        }\\n        return abi.encodePacked(uri, MoonCatSVGS.uint2str(attributes[12]), \\\".png\\\");\\n    }\\n\\n    /**\\n     * @dev Generate full BASE64-encoded JSON metadata for a STARKADE legion character. Use static IPFS image if available.\\n     */\\n    function legionMetadata (uint256 tokenId) public view returns (string memory) {\\n        (uint16[15] memory attributes, uint8[5] memory boosts) = Starkade.getTraitIndexes(tokenId);\\n        string memory tokenIdString = MoonCatSVGS.uint2str(tokenId);\\n        (string memory regionName, bytes memory baseAttributes) = assembleBaseAttributes(attributes);\\n        bytes memory boostAttributes = assembleBoosts(boosts);\\n        bytes memory img;\\n        if (bytes(IPFS_Image_Cache_CID).length == 0) {\\n            img = imageURI(attributes);\\n        } else {\\n            img = abi.encodePacked(\\\"ipfs://\\\", IPFS_Image_Cache_CID, \\\"/\\\", tokenIdString, \\\".png\\\");\\n        }\\n        bytes memory json = abi.encodePacked(\\\"{\\\\\\\"attributes\\\\\\\":[\\\",\\n                                             encodeStringAttribute(\\\"Arena\\\", \\\"Legion\\\"), \\\",\\\",\\n                                             baseAttributes,\\n                                             boostAttributes,\\n                                             \\\"], \\\\\\\"name\\\\\\\":\\\\\\\"Fighter #\\\",tokenIdString,\\\"\\\\\\\", \\\\\\\"description\\\\\\\":\\\\\\\"\\\",description(regionName),\\\"\\\\\\\",\\\\\\\"image\\\\\\\":\\\\\\\"\\\",\\n                                             img,\\n                                             \\\"\\\\\\\",\\\\\\\"external_url\\\\\\\": \\\\\\\"https://starkade.com/legion/\\\",tokenIdString,\\\"\\\\\\\"}\\\");\\n        return string(abi.encodePacked(\\\"data:application/json;base64,\\\", Base64.encode(json)));\\n    }\\n\\n\\n    address public owner;\\n\\n    function setIPFSImageCache (string calldata cid) public onlyOwner {\\n        IPFS_Image_Cache_CID = cid;\\n    }\\n\\n    /**\\n     * @dev Set the baseURI for the image generator (images can also be assembled on-chain in the main contract)\\n     */\\n    function setBaseImageURI (string calldata base_uri) public onlyOwner {\\n        BASE_IMAGE_URI = base_uri;\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        owner = newOwner;\\n    }\\n\\n    constructor (address starkadeContractAddress) {\\n        Starkade = IStarkade(starkadeContractAddress);\\n        owner = msg.sender;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Not Owner\\\");\\n        _;\\n    }\\n\\n    /* Rescuers */\\n    /**\\n    * @dev Rescue ETH sent directly to this contract.\\n    */\\n    function withdraw () public {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n    /**\\n    * @dev Rescue ERC20 assets sent directly to this contract.\\n    */\\n    function withdrawForeignERC20(address tokenContract) public onlyOwner {\\n        IERC20 token = IERC20(tokenContract);\\n        token.transfer(owner, token.balanceOf(address(this)));\\n        }\\n\\n    /**\\n     * @dev Rescue ERC721 assets sent directly to this contract.\\n     */\\n    function withdrawForeignERC721(address tokenContract, uint256 tokenId) public onlyOwner {\\n        IERC721(tokenContract).safeTransferFrom(address(this), owner, tokenId);\\n    }\\n}\\n\\n\\n/// [MIT License]\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\nlibrary Base64 {\\n    bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n                let resultPtr := add(result, 32)\\n\\n                for {\\n                     let i := 0\\n                } lt(i, len) {\\n\\n            } {\\n            i := add(i, 3)\\n            let input := and(mload(add(data, i)), 0xffffff)\\n\\n            let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n            out := shl(8, out)\\n            out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n            out := shl(8, out)\\n            out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n            out := shl(8, out)\\n            out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n            out := shl(224, out)\\n\\n            mstore(resultPtr, out)\\n\\n            resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n                          case 1 {\\n                                  mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n                }\\n            case 2 {\\n                    mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n                }\\n\\n        return string(result);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"starkadeContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"IPFS_Image_Cache_CID\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"legionMetadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"base_uri\",\"type\":\"string\"}],\"name\":\"setBaseImageURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"cid\",\"type\":\"string\"}],\"name\":\"setIPFSImageCache\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"withdrawForeignERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawForeignERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StarkadeMetadata", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005d2bf3b4264efade95fc89348f1367fca0552861", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}