{"status": "1", "message": "OK", "result": [{"SourceCode": "// Sources flattened with hardhat v2.8.0 https://hardhat.org\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// File contracts/libraries/SafeTransfer.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x095ea7b3, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"safe approve failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0xa9059cbb, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"safe transfer failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"safe transferFrom failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{ value: value }(new bytes(0));\r\n        require(success, \"safe transferETH failed\");\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/Ownable.sol\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IERC721.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n\r\n// File contracts/libraries/Strings.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/ERC721.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\r\n\r\n/**\r\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\r\n * {ERC721Enumerable}.\r\n */\r\ncontract ERC721 is IERC721 {\r\n    using Strings for uint256;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Base URI\r\n    string private _baseURI;\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint256 => address) private _owners;\r\n\r\n    // Mapping owner address to token count\r\n    mapping(address => uint256) private _balances;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n     */\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        string memory baseURI_\r\n    ) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _baseURI = baseURI_;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            owner != address(0),\r\n            \"ERC721: balance query for the zero address\"\r\n        );\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        address owner = _owners[tokenId];\r\n        require(\r\n            owner != address(0),\r\n            \"ERC721: owner query for nonexistent token\"\r\n        );\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (string memory)\r\n    {\r\n        require(\r\n            _exists(tokenId),\r\n            \"ERC721Metadata: URI query for nonexistent token\"\r\n        );\r\n\r\n        string memory baseURI = _baseURI;\r\n        return\r\n            bytes(baseURI).length > 0\r\n                ? string(abi.encodePacked(baseURI, tokenId.toString()))\r\n                : \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        require(\r\n            _exists(tokenId),\r\n            \"ERC721: approved query for nonexistent token\"\r\n        );\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved)\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        _setApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(\r\n            _isApprovedOrOwner(msg.sender, tokenId),\r\n            \"ERC721: transfer caller is not owner nor approved\"\r\n        );\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _exists(tokenId),\r\n            \"ERC721: operator query for nonexistent token\"\r\n        );\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner ||\r\n            getApproved(tokenId) == spender ||\r\n            isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n\r\n        _beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n        // Clear approvals\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[owner] -= 1;\r\n        delete _owners[tokenId];\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(\r\n            ERC721.ownerOf(tokenId) == from,\r\n            \"ERC721: transfer from incorrect owner\"\r\n        );\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[from] -= 1;\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits a {Approval} event.\r\n     */\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `operator` to operate on all of `owner` tokens\r\n     *\r\n     * Emits a {ApprovalForAll} event.\r\n     */\r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) internal virtual {\r\n        require(owner != operator, \"ERC721: approve to caller\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n}\r\n\r\n\r\n// File contracts/interfaces/IERC721Enumerable.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Enumerable.sol)\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Enumerable is IERC721 {\r\n    /**\r\n     * @dev Returns the total amount of tokens stored by the contract.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index)\r\n        external\r\n        view\r\n        returns (uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n     * Use along with {totalSupply} to enumerate all tokens.\r\n     */\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/libraries/ERC721Enumerable.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\r\n\r\n/**\r\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\r\n * enumerability of all the token ids in the contract as well as all token ids owned by each\r\n * account.\r\n */\r\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] private _allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            index < ERC721.balanceOf(owner),\r\n            \"ERC721Enumerable: owner index out of bounds\"\r\n        );\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-tokenByIndex}.\r\n     */\r\n    function tokenByIndex(uint256 index)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            index < ERC721Enumerable.totalSupply(),\r\n            \"ERC721Enumerable: global index out of bounds\"\r\n        );\r\n        return _allTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n        if (from == address(0)) {\r\n            _addTokenToAllTokensEnumeration(tokenId);\r\n        } else if (from != to) {\r\n            _removeTokenFromOwnerEnumeration(from, tokenId);\r\n        }\r\n        if (to == address(0)) {\r\n            _removeTokenFromAllTokensEnumeration(tokenId);\r\n        } else if (to != from) {\r\n            _addTokenToOwnerEnumeration(to, tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n     * @param to address representing the new owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        uint256 length = ERC721.balanceOf(to);\r\n        _ownedTokens[to][length] = tokenId;\r\n        _ownedTokensIndex[tokenId] = length;\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's token tracking data structures.\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list\r\n     */\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\r\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\r\n        private\r\n    {\r\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n        }\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete _ownedTokensIndex[tokenId];\r\n        delete _ownedTokens[from][lastTokenIndex];\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's token tracking data structures.\r\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n     */\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _allTokens.length - 1;\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete _allTokensIndex[tokenId];\r\n        _allTokens.pop();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/Math.sol\r\n\r\nlibrary Math {\r\n    function compound(uint256 rewardRateX96, uint256 nCompounds)\r\n        internal\r\n        pure\r\n        returns (uint256 compoundedX96)\r\n    {\r\n        if (nCompounds == 0) {\r\n            compoundedX96 = 2**96;\r\n        } else if (nCompounds == 1) {\r\n            compoundedX96 = rewardRateX96;\r\n        } else {\r\n            compoundedX96 = compound(rewardRateX96, nCompounds / 2);\r\n            compoundedX96 = mulX96(compoundedX96, compoundedX96);\r\n\r\n            if (nCompounds % 2 == 1) {\r\n                compoundedX96 = mulX96(compoundedX96, rewardRateX96);\r\n            }\r\n        }\r\n    }\r\n\r\n    // ref: https://blogs.sas.com/content/iml/2016/05/16/babylonian-square-roots.html\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n\r\n    function mulX96(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = (x * y) >> 96;\r\n    }\r\n\r\n    function divX96(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = (x << 96) / y;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/Time.sol\r\n\r\nlibrary Time {\r\n    function current_hour_timestamp() internal view returns (uint64) {\r\n        return uint64((block.timestamp / 1 hours) * 1 hours);\r\n    }\r\n\r\n    function block_timestamp() internal view returns (uint64) {\r\n        return uint64(block.timestamp);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IUniswapV3Factory.sol\r\n\r\n/// @title The interface for the Uniswap V3 Factory\r\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\r\ninterface IUniswapV3Factory {\r\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\r\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\r\n    /// @param tokenA The contract address of either token0 or token1\r\n    /// @param tokenB The contract address of the other token\r\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\r\n    /// @return pool The pool address\r\n    function getPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) external view returns (address pool);\r\n\r\n    /// @notice Creates a pool for the given two tokens and fee\r\n    /// @param tokenA One of the two tokens in the desired pool\r\n    /// @param tokenB The other of the two tokens in the desired pool\r\n    /// @param fee The desired fee for the pool\r\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\r\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\r\n    /// are invalid.\r\n    /// @return pool The address of the newly created pool\r\n    function createPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) external returns (address pool);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IUniswapV3Pool.sol\r\n\r\ninterface IUniswapV3Pool {\r\n    /// @notice Sets the initial price for the pool\r\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\r\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\r\n    function initialize(uint160 sqrtPriceX96) external;\r\n\r\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\r\n    /// when accessed externally.\r\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\r\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\r\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\r\n    /// boundary.\r\n    /// observationIndex The index of the last oracle observation that was written,\r\n    /// observationCardinality The current maximum number of observations stored in the pool,\r\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\r\n    /// feeProtocol The protocol fee for both tokens of the pool.\r\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\r\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\r\n    /// unlocked Whether the pool is currently locked to reentrancy\r\n    function slot0()\r\n        external\r\n        view\r\n        returns (\r\n            uint160 sqrtPriceX96,\r\n            int24 tick,\r\n            uint16 observationIndex,\r\n            uint16 observationCardinality,\r\n            uint16 observationCardinalityNext,\r\n            uint8 feeProtocol,\r\n            bool unlocked\r\n        );\r\n\r\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\r\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\r\n    /// the input observationCardinalityNext.\r\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\r\n    function increaseObservationCardinalityNext(\r\n        uint16 observationCardinalityNext\r\n    ) external;\r\n\r\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\r\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\r\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\r\n    /// you must call it with secondsAgos = [3600, 0].\r\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\r\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\r\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\r\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\r\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\r\n    /// timestamp\r\n    function observe(uint32[] calldata secondsAgos)\r\n        external\r\n        view\r\n        returns (\r\n            int56[] memory tickCumulatives,\r\n            uint160[] memory secondsPerLiquidityCumulativeX128s\r\n        );\r\n}\r\n\r\n\r\n// File contracts/interfaces/IERC20.sol\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n\r\n// File contracts/libraries/ERC20.sol\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint8 decimals_\r\n    ) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(\r\n                currentAllowance >= amount,\r\n                \"ERC20: transfer amount exceeds allowance\"\r\n            );\r\n            unchecked {\r\n                _approve(sender, msg.sender, currentAllowance - amount);\r\n            }\r\n        }\r\n\r\n        _transfer(sender, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            msg.sender,\r\n            spender,\r\n            _allowances[msg.sender][spender] + addedValue\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(\r\n            currentAllowance >= subtractedValue,\r\n            \"ERC20: decreased allowance below zero\"\r\n        );\r\n        unchecked {\r\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(\r\n            senderBalance >= amount,\r\n            \"ERC20: transfer amount exceeds balance\"\r\n        );\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n\r\n        _afterTokenTransfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n\r\n// File contracts/libraries/TickMath.sol\r\n\r\n/// @title Math library for computing sqrt prices from ticks and vice versa\r\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\r\n/// prices between 2**-128 and 2**128\r\nlibrary TickMath {\r\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\r\n    int24 internal constant MIN_TICK = -887272;\r\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\r\n    int24 internal constant MAX_TICK = -MIN_TICK;\r\n\r\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\r\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\r\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\r\n    uint160 internal constant MAX_SQRT_RATIO =\r\n        1461446703485210103287273052203988822378723970342;\r\n\r\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\r\n    /// @dev Throws if |tick| > max tick\r\n    /// @param tick The input tick for the above formula\r\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\r\n    /// at the given tick\r\n    function getSqrtRatioAtTick(int24 tick)\r\n        internal\r\n        pure\r\n        returns (uint160 sqrtPriceX96)\r\n    {\r\n        uint256 absTick = tick < 0\r\n            ? uint256(-int256(tick))\r\n            : uint256(int256(tick));\r\n        require(absTick <= uint256(int256(MAX_TICK)), \"T\");\r\n\r\n        uint256 ratio = absTick & 0x1 != 0\r\n            ? 0xfffcb933bd6fad37aa2d162d1a594001\r\n            : 0x100000000000000000000000000000000;\r\n        if (absTick & 0x2 != 0)\r\n            ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\r\n        if (absTick & 0x4 != 0)\r\n            ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\r\n        if (absTick & 0x8 != 0)\r\n            ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\r\n        if (absTick & 0x10 != 0)\r\n            ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\r\n        if (absTick & 0x20 != 0)\r\n            ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\r\n        if (absTick & 0x40 != 0)\r\n            ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\r\n        if (absTick & 0x80 != 0)\r\n            ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\r\n        if (absTick & 0x100 != 0)\r\n            ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\r\n        if (absTick & 0x200 != 0)\r\n            ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\r\n        if (absTick & 0x400 != 0)\r\n            ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\r\n        if (absTick & 0x800 != 0)\r\n            ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\r\n        if (absTick & 0x1000 != 0)\r\n            ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\r\n        if (absTick & 0x2000 != 0)\r\n            ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\r\n        if (absTick & 0x4000 != 0)\r\n            ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\r\n        if (absTick & 0x8000 != 0)\r\n            ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\r\n        if (absTick & 0x10000 != 0)\r\n            ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\r\n        if (absTick & 0x20000 != 0)\r\n            ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\r\n        if (absTick & 0x40000 != 0)\r\n            ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\r\n        if (absTick & 0x80000 != 0)\r\n            ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\r\n\r\n        if (tick > 0) ratio = type(uint256).max / ratio;\r\n\r\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\r\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\r\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\r\n        sqrtPriceX96 = uint160(\r\n            (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\r\n        );\r\n    }\r\n\r\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\r\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\r\n    /// ever return.\r\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\r\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\r\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96)\r\n        internal\r\n        pure\r\n        returns (int24 tick)\r\n    {\r\n        // second inequality must be < because the price can never reach the price at the max tick\r\n        require(\r\n            sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\r\n            \"R\"\r\n        );\r\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\r\n\r\n        uint256 r = ratio;\r\n        uint256 msb = 0;\r\n\r\n        assembly {\r\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(5, gt(r, 0xFFFFFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(4, gt(r, 0xFFFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(3, gt(r, 0xFF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(2, gt(r, 0xF))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := shl(1, gt(r, 0x3))\r\n            msb := or(msb, f)\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            let f := gt(r, 0x1)\r\n            msb := or(msb, f)\r\n        }\r\n\r\n        if (msb >= 128) r = ratio >> (msb - 127);\r\n        else r = ratio << (127 - msb);\r\n\r\n        int256 log_2 = (int256(msb) - 128) << 64;\r\n\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(63, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(62, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(61, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(60, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(59, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(58, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(57, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(56, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(55, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(54, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(53, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(52, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(51, f))\r\n            r := shr(f, r)\r\n        }\r\n        assembly {\r\n            r := shr(127, mul(r, r))\r\n            let f := shr(128, r)\r\n            log_2 := or(log_2, shl(50, f))\r\n        }\r\n\r\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\r\n\r\n        int24 tickLow = int24(\r\n            (log_sqrt10001 - 3402992956809132418596140100660247210) >> 128\r\n        );\r\n        int24 tickHi = int24(\r\n            (log_sqrt10001 + 291339464771989622907027621153398088495) >> 128\r\n        );\r\n\r\n        tick = tickLow == tickHi\r\n            ? tickLow\r\n            : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96\r\n            ? tickHi\r\n            : tickLow;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Const.sol\r\n\r\nint24 constant INITIAL_QLT_PRICE_TICK = -23000; // QLT_USDC price ~ 100.0\r\n\r\n// initial values\r\nuint24 constant UNISWAP_POOL_FEE = 10000;\r\nint24 constant UNISWAP_POOL_TICK_SPACING = 200;\r\nuint16 constant UNISWAP_POOL_OBSERVATION_CADINALITY = 64;\r\n\r\n// default values\r\nuint256 constant DEFAULT_MIN_MINT_PRICE_X96 = 100 * Q96;\r\nuint32 constant DEFAULT_TWAP_DURATION = 1 hours;\r\nuint32 constant DEFAULT_UNSTAKE_LOCKUP_PERIOD = 3 days;\r\n\r\n// floating point math\r\nuint256 constant Q96 = 2**96;\r\nuint256 constant MX96 = Q96 / 10**6;\r\nuint256 constant TX96 = Q96 / 10**12;\r\n\r\n// ERC-20 contract addresses\r\naddress constant WETH = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\naddress constant USDC = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\naddress constant USDT = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);\r\naddress constant DAI = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);\r\naddress constant BUSD = address(0x4Fabb145d64652a948d72533023f6E7A623C7C53);\r\naddress constant FRAX = address(0x853d955aCEf822Db058eb8505911ED77F175b99e);\r\naddress constant WBTC = address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\r\n\r\n// Uniswap, see `https://docs.uniswap.org/protocol/reference/deployments`\r\naddress constant UNISWAP_FACTORY = address(\r\n    0x1F98431c8aD98523631AE4a59f267346ea31F984\r\n);\r\naddress constant UNISWAP_ROUTER = address(\r\n    0xE592427A0AEce92De3Edee1F18E0157C05861564\r\n);\r\naddress constant UNISWAP_NFP_MGR = address(\r\n    0xC36442b4a4522E871399CD717aBDD847Ab11FE88\r\n);\r\n\r\n\r\n// File contracts/QLT.sol\r\n\r\ncontract QLT is ERC20, Ownable {\r\n    event Mint(address indexed account, uint256 amount);\r\n    event Burn(uint256 amount);\r\n\r\n    mapping(address => bool) public authorizedMinters;\r\n\r\n    constructor() ERC20(\"Quantland\", \"QLT\", 9) {\r\n        require(\r\n            address(this) < USDC,\r\n            \"QLT contract address must be smaller than USDC token contract address\"\r\n        );\r\n        authorizedMinters[msg.sender] = true;\r\n\r\n        // deploy uniswap pool\r\n        IUniswapV3Pool pool = IUniswapV3Pool(\r\n            IUniswapV3Factory(UNISWAP_FACTORY).createPool(\r\n                address(this),\r\n                USDC,\r\n                UNISWAP_POOL_FEE\r\n            )\r\n        );\r\n        pool.initialize(TickMath.getSqrtRatioAtTick(INITIAL_QLT_PRICE_TICK));\r\n        pool.increaseObservationCardinalityNext(\r\n            UNISWAP_POOL_OBSERVATION_CADINALITY\r\n        );\r\n    }\r\n\r\n    function mint(address account, uint256 amount)\r\n        external\r\n        onlyAuthorizedMinter\r\n    {\r\n        _mint(account, amount);\r\n\r\n        emit Mint(account, amount);\r\n    }\r\n\r\n    function burn(uint256 amount) external onlyOwner {\r\n        _burn(msg.sender, amount);\r\n\r\n        emit Burn(amount);\r\n    }\r\n\r\n    /* Access Control */\r\n    modifier onlyAuthorizedMinter() {\r\n        require(authorizedMinters[msg.sender], \"not authorized minter\");\r\n        _;\r\n    }\r\n\r\n    function addAuthorizedMinter(address account) external onlyOwner {\r\n        authorizedMinters[account] = true;\r\n    }\r\n\r\n    function removeAuthorizedMinter(address account) external onlyOwner {\r\n        authorizedMinters[account] = false;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/StakedQLT.sol\r\n\r\nstruct StakingInfo {\r\n    bytes32 stakingPlan;\r\n    uint256 stakedAmount;\r\n    uint64 stakeTime;\r\n    uint64 unstakeTime;\r\n    uint64 redeemTime;\r\n    uint64 lastHarvestTime;\r\n    uint256 accumulatedStakingReward;\r\n}\r\n\r\nstruct StakingRewardRate {\r\n    uint256 rewardRateX96;\r\n    uint64 startTime;\r\n}\r\n\r\nstruct StakingPowerMultiplier {\r\n    uint64 multiplier;\r\n    uint64 startTime;\r\n}\r\n\r\nstruct StakingPlan {\r\n    bytes32 name;\r\n    uint256 stakingAmount;\r\n    uint256 accumulatedStakingReward;\r\n    StakingRewardRate[] rewardRates;\r\n    StakingPowerMultiplier[] multipliers;\r\n    uint64 lockupPeriod;\r\n    uint64 createdAt;\r\n    uint64 deactivatedAt;\r\n}\r\n\r\ncontract StakedQLT is ERC721Enumerable, Ownable {\r\n    using Math for uint256;\r\n\r\n    event Stake(\r\n        uint256 indexed tokenId,\r\n        address staker,\r\n        bytes32 stakingPlan,\r\n        uint256 amount\r\n    );\r\n    event Unstake(uint256 indexed tokenId);\r\n    event Redeem(uint256 indexed tokenId, uint256 amount);\r\n    event Harvest(uint256 indexed tokenId, uint256 rewardAmount);\r\n    event HarvestAll(uint256[] tokenIds, uint256 rewardAmount);\r\n    event StakingPlanCreated(bytes32 name);\r\n    event StakingPlanDeactivated(bytes32 name);\r\n    event StakingRewardRateUpdated(bytes32 name, uint256 rewardRateX96);\r\n    event StakingPowerMultiplierUpdated(bytes32 name, uint256 multiplier);\r\n\r\n    QLT private immutable QLTContract;\r\n\r\n    uint256 public tokenIdCounter;\r\n    uint64 public harvestStartTime;\r\n    uint64 public unstakeLockupPeriod;\r\n\r\n    uint256 public totalStakingAmount;\r\n    address public treasuryAddress;\r\n    mapping(uint256 => StakingInfo) public stakingInfos;\r\n    mapping(bytes32 => StakingPlan) public stakingPlans;\r\n\r\n    mapping(address => bool) public authorizedOperators;\r\n\r\n    constructor(address _QLTContract)\r\n        ERC721(\"Staked QLT\", \"sQLT\", \"https://staked.quantland.finance/\")\r\n    {\r\n        addAuthorizedOperator(msg.sender);\r\n        harvestStartTime = type(uint64).max;\r\n        unstakeLockupPeriod = DEFAULT_UNSTAKE_LOCKUP_PERIOD;\r\n\r\n        addStakingPlan(\"gold\", 7 days, (100040 * Q96) / 100000, 1); // APY 3,222 %\r\n        addStakingPlan(\"platinum\", 30 days, (100060 * Q96) / 100000, 3); // APY 19,041 %\r\n        addStakingPlan(\"diamond\", 90 days, (100080 * Q96) / 100000, 5); // APY 110,200 %\r\n\r\n        QLTContract = QLT(_QLTContract);\r\n    }\r\n\r\n    /* Staking Plan Governance Functions */\r\n    function addStakingPlan(\r\n        bytes32 name,\r\n        uint64 lockupPeriod,\r\n        uint256 rewardRateX96,\r\n        uint64 multiplier\r\n    ) public onlyOwner {\r\n        require(stakingPlans[name].createdAt == 0, \"already created\");\r\n        StakingPlan storage stakingPlan = stakingPlans[name];\r\n        stakingPlan.name = name;\r\n        stakingPlan.rewardRates.push(\r\n            StakingRewardRate({\r\n                rewardRateX96: rewardRateX96,\r\n                startTime: Time.current_hour_timestamp()\r\n            })\r\n        );\r\n        stakingPlan.multipliers.push(\r\n            StakingPowerMultiplier({\r\n                multiplier: multiplier,\r\n                startTime: Time.block_timestamp()\r\n            })\r\n        );\r\n        stakingPlan.lockupPeriod = lockupPeriod;\r\n        stakingPlan.createdAt = Time.block_timestamp();\r\n\r\n        emit StakingPlanCreated(name);\r\n    }\r\n\r\n    function deactivateStakingPlan(bytes32 name) public onlyOwner {\r\n        _checkStakingPlanActive(name);\r\n\r\n        StakingPlan storage stakingPlan = stakingPlans[name];\r\n        stakingPlan.deactivatedAt = Time.block_timestamp();\r\n\r\n        emit StakingPlanDeactivated(name);\r\n    }\r\n\r\n    function updateStakingRewardRate(bytes32 name, uint256 rewardRateX96)\r\n        public\r\n        onlyOperator\r\n    {\r\n        _checkStakingPlanActive(name);\r\n\r\n        StakingPlan storage stakingPlan = stakingPlans[name];\r\n        stakingPlan.rewardRates.push(\r\n            StakingRewardRate({\r\n                rewardRateX96: rewardRateX96,\r\n                startTime: Time.current_hour_timestamp()\r\n            })\r\n        );\r\n\r\n        emit StakingRewardRateUpdated(name, rewardRateX96);\r\n    }\r\n\r\n    function updateStakingPowerMultiplier(bytes32 name, uint64 multiplier)\r\n        public\r\n        onlyOperator\r\n    {\r\n        _checkStakingPlanActive(name);\r\n\r\n        StakingPlan storage stakingPlan = stakingPlans[name];\r\n        stakingPlan.multipliers.push(\r\n            StakingPowerMultiplier({\r\n                multiplier: multiplier,\r\n                startTime: Time.block_timestamp()\r\n            })\r\n        );\r\n\r\n        emit StakingPowerMultiplierUpdated(name, multiplier);\r\n    }\r\n\r\n    /* Staking-Related Functions */\r\n    function stake(\r\n        address recipient,\r\n        bytes32 stakingPlan,\r\n        uint256 amount\r\n    ) external returns (uint256 tokenId) {\r\n        require(amount > 0, \"amount is 0\");\r\n        _checkStakingPlanActive(stakingPlan);\r\n\r\n        // transfer QLT\r\n        QLTContract.transferFrom(msg.sender, address(this), amount);\r\n\r\n        // mint\r\n        tokenIdCounter += 1;\r\n        tokenId = tokenIdCounter;\r\n        _mint(recipient, tokenId);\r\n        _approve(address(this), tokenId);\r\n\r\n        // update staking info\r\n        StakingInfo storage stakingInfo = stakingInfos[tokenId];\r\n        stakingInfo.stakingPlan = stakingPlan;\r\n        stakingInfo.stakedAmount = amount;\r\n        stakingInfo.stakeTime = Time.block_timestamp();\r\n        stakingInfo.lastHarvestTime = Time.current_hour_timestamp();\r\n\r\n        // update staking plan info\r\n        stakingPlans[stakingPlan].stakingAmount += amount;\r\n        totalStakingAmount += amount;\r\n\r\n        emit Stake(tokenId, recipient, stakingPlan, amount);\r\n    }\r\n\r\n    function unstake(uint256 tokenId) external returns (uint256 rewardAmount) {\r\n        _checkOwnershipOfStakingToken(tokenId);\r\n\r\n        StakingInfo storage stakingInfo = stakingInfos[tokenId];\r\n        uint64 lockupPeriod = stakingPlans[stakingInfo.stakingPlan]\r\n            .lockupPeriod;\r\n        uint64 stakeTime = stakingInfo.stakeTime;\r\n        uint64 unstakeTime = stakingInfo.unstakeTime;\r\n\r\n        if (msg.sender == treasuryAddress) {\r\n            lockupPeriod = 0;\r\n        }\r\n\r\n        require(unstakeTime == 0, \"already unstaked\");\r\n        require(\r\n            Time.block_timestamp() >= (stakeTime + lockupPeriod),\r\n            \"still in lockup\"\r\n        );\r\n\r\n        // harvest first\r\n        rewardAmount = harvestInternal(tokenId);\r\n\r\n        // update staking info\r\n        uint256 unstakedAmount = stakingInfo.stakedAmount;\r\n        stakingInfo.unstakeTime = Time.block_timestamp();\r\n\r\n        // update staking plan info\r\n        stakingPlans[stakingInfo.stakingPlan].stakingAmount -= unstakedAmount;\r\n        totalStakingAmount -= unstakedAmount;\r\n\r\n        emit Unstake(tokenId);\r\n    }\r\n\r\n    function redeem(uint256 tokenId) external returns (uint256 redeemedAmount) {\r\n        _checkOwnershipOfStakingToken(tokenId);\r\n\r\n        StakingInfo storage stakingInfo = stakingInfos[tokenId];\r\n        uint64 unstakeTime = stakingInfo.unstakeTime;\r\n        uint64 redeemTime = stakingInfo.redeemTime;\r\n        uint64 _unstakeLockupPeriod = unstakeLockupPeriod;\r\n\r\n        if (msg.sender == treasuryAddress) {\r\n            _unstakeLockupPeriod = 0;\r\n        }\r\n\r\n        // check if can unstake\r\n        require(unstakeTime > 0, \"not unstaked\");\r\n        require(\r\n            Time.block_timestamp() >= (unstakeTime + _unstakeLockupPeriod),\r\n            \"still in lockup\"\r\n        );\r\n        require(redeemTime == 0, \"already redeemed\");\r\n\r\n        // recycle and burn staking NFT\r\n        address staker = ownerOf(tokenId);\r\n        transferFrom(msg.sender, address(this), tokenId);\r\n        _burn(tokenId);\r\n\r\n        // transfer QLT back to staker\r\n        redeemedAmount = stakingInfo.stakedAmount;\r\n        QLTContract.transfer(staker, redeemedAmount);\r\n\r\n        // update staking info\r\n        stakingInfo.redeemTime = Time.block_timestamp();\r\n\r\n        emit Redeem(tokenId, redeemedAmount);\r\n    }\r\n\r\n    function harvest(uint256 tokenId) external returns (uint256 rewardAmount) {\r\n        return harvestInternal(tokenId);\r\n    }\r\n\r\n    function harvestAll(uint256[] calldata tokenIds)\r\n        external\r\n        returns (uint256 rewardAmount)\r\n    {\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            rewardAmount += harvestInternal(tokenIds[i]);\r\n        }\r\n\r\n        emit HarvestAll(tokenIds, rewardAmount);\r\n    }\r\n\r\n    function harvestInternal(uint256 tokenId)\r\n        internal\r\n        returns (uint256 rewardAmount)\r\n    {\r\n        require(Time.block_timestamp() >= harvestStartTime, \"come back later\");\r\n        _checkOwnershipOfStakingToken(tokenId);\r\n\r\n        rewardAmount = getRewardsToHarvest(tokenId);\r\n\r\n        if (rewardAmount > 0) {\r\n            // mint QLT to recipient\r\n            QLTContract.mint(ownerOf(tokenId), rewardAmount);\r\n\r\n            // update staking info\r\n            StakingInfo storage stakingInfo = stakingInfos[tokenId];\r\n            stakingInfo.lastHarvestTime = Time.current_hour_timestamp();\r\n            stakingInfo.accumulatedStakingReward += rewardAmount;\r\n\r\n            // update staking plan info\r\n            StakingPlan storage stakingPlan = stakingPlans[\r\n                stakingInfo.stakingPlan\r\n            ];\r\n            stakingPlan.accumulatedStakingReward += rewardAmount;\r\n\r\n            emit Harvest(tokenId, rewardAmount);\r\n        }\r\n    }\r\n\r\n    /* Staking State View Functions */\r\n    function getRewardsToHarvest(uint256 tokenId)\r\n        public\r\n        view\r\n        returns (uint256 rewardAmount)\r\n    {\r\n        require(tokenId <= tokenIdCounter, \"not existent\");\r\n\r\n        StakingInfo storage stakingInfo = stakingInfos[tokenId];\r\n\r\n        if (stakingInfo.unstakeTime > 0) {\r\n            return 0;\r\n        }\r\n\r\n        StakingPlan storage stakingPlan = stakingPlans[stakingInfo.stakingPlan];\r\n\r\n        // calculate compounded rewards of QLT\r\n        uint256 stakedAmountX96 = stakingInfo.stakedAmount * Q96;\r\n        uint256 compoundedAmountX96 = stakedAmountX96;\r\n        uint64 rewardEndTime = Time.current_hour_timestamp();\r\n        uint64 lastHarvestTime = stakingInfo.lastHarvestTime;\r\n\r\n        StakingRewardRate[] storage rewardRates = stakingPlan.rewardRates;\r\n        uint256 i = rewardRates.length;\r\n        while (i > 0) {\r\n            i--;\r\n\r\n            uint64 rewardStartTime = rewardRates[i].startTime;\r\n            uint256 rewardRateX96 = rewardRates[i].rewardRateX96;\r\n            uint256 nCompounds;\r\n\r\n            if (rewardEndTime < rewardStartTime) {\r\n                continue;\r\n            }\r\n\r\n            if (rewardStartTime >= lastHarvestTime) {\r\n                nCompounds = (rewardEndTime - rewardStartTime) / 1 hours;\r\n                compoundedAmountX96 = compoundedAmountX96.mulX96(\r\n                    Math.compound(rewardRateX96, nCompounds)\r\n                );\r\n                rewardEndTime = rewardStartTime;\r\n            } else {\r\n                nCompounds = (rewardEndTime - lastHarvestTime) / 1 hours;\r\n                compoundedAmountX96 = compoundedAmountX96.mulX96(\r\n                    Math.compound(rewardRateX96, nCompounds)\r\n                );\r\n                break;\r\n            }\r\n        }\r\n\r\n        rewardAmount = (compoundedAmountX96 - stakedAmountX96) / Q96;\r\n    }\r\n\r\n    function getAllRewardsToHarvest(uint256[] calldata tokenIds)\r\n        public\r\n        view\r\n        returns (uint256 rewardAmount)\r\n    {\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            rewardAmount += getRewardsToHarvest(tokenIds[i]);\r\n        }\r\n    }\r\n\r\n    function getStakingPower(\r\n        uint256 tokenId,\r\n        uint64 startTime,\r\n        uint64 endTime\r\n    ) public view returns (uint256 stakingPower) {\r\n        require(tokenId <= tokenIdCounter, \"not existent\");\r\n\r\n        StakingInfo storage stakingInfo = stakingInfos[tokenId];\r\n        if (stakingInfo.stakeTime >= endTime || stakingInfo.unstakeTime > 0) {\r\n            return 0;\r\n        }\r\n        if (stakingInfo.stakeTime > startTime) {\r\n            startTime = stakingInfo.stakeTime;\r\n        }\r\n\r\n        StakingPlan storage stakingPlan = stakingPlans[stakingInfo.stakingPlan];\r\n        uint256 stakedAmount = stakingInfo.stakedAmount;\r\n        StakingPowerMultiplier[] storage multipliers = stakingPlan.multipliers;\r\n        uint256 i = multipliers.length;\r\n        while (i > 0) {\r\n            i--;\r\n\r\n            uint64 rewardStartTime = multipliers[i].startTime;\r\n            uint256 multiplier = multipliers[i].multiplier;\r\n\r\n            if (rewardStartTime >= endTime) {\r\n                continue;\r\n            }\r\n\r\n            if (rewardStartTime >= startTime) {\r\n                stakingPower +=\r\n                    stakedAmount *\r\n                    (endTime - rewardStartTime) *\r\n                    multiplier;\r\n                endTime = rewardStartTime;\r\n            } else {\r\n                stakingPower +=\r\n                    stakedAmount *\r\n                    (endTime - startTime) *\r\n                    multiplier;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getAllStakingPower(\r\n        uint256[] calldata tokenIds,\r\n        uint64 startTime,\r\n        uint64 endTime\r\n    ) public view returns (uint256 stakingPower) {\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            stakingPower += getStakingPower(tokenIds[i], startTime, endTime);\r\n        }\r\n    }\r\n\r\n    /* Config Setters */\r\n    function setHarvestStartTime(uint64 _harvestStartTime) external onlyOwner {\r\n        harvestStartTime = _harvestStartTime;\r\n    }\r\n\r\n    function setUnstakeLockupPeriod(uint64 _unstakeLockupPeriod)\r\n        external\r\n        onlyOwner\r\n    {\r\n        unstakeLockupPeriod = _unstakeLockupPeriod;\r\n    }\r\n\r\n    function setTreasuryAddress(address _treasuryAddress) external onlyOwner {\r\n        treasuryAddress = _treasuryAddress;\r\n    }\r\n\r\n    /* Helper Functions */\r\n    function _checkOwnershipOfStakingToken(uint256 tokenId) internal view {\r\n        require(ownerOf(tokenId) == msg.sender, \"not owner\");\r\n    }\r\n\r\n    function _checkStakingPlanActive(bytes32 stakingPlan) internal view {\r\n        require(\r\n            stakingPlans[stakingPlan].deactivatedAt == 0,\r\n            \"staking plan not active\"\r\n        );\r\n    }\r\n\r\n    /* Access Control */\r\n    function addAuthorizedOperator(address account) public onlyOwner {\r\n        authorizedOperators[account] = true;\r\n    }\r\n\r\n    function removeAuthorizedOperator(address account) external onlyOwner {\r\n        authorizedOperators[account] = false;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(authorizedOperators[msg.sender], \"not authorized\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/RewardDistributor.sol\r\n\r\naddress constant USDC_ADDR = address(\r\n    0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\r\n);\r\nStakedQLT constant STAKED_QLT_CONTRACT = StakedQLT(\r\n    0x9D7977891e0d4D3Bc84456DD2838beE6ad484D87\r\n);\r\nuint256 constant MASK = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00;\r\n\r\nstruct Campaign {\r\n    bytes32 name;\r\n    uint256 totalReward;\r\n    uint256 totalStakingPower;\r\n    uint128 rewardRate;\r\n    uint64 startTime;\r\n    uint64 endTime;\r\n}\r\n\r\ncontract RewardDistributor is Ownable {\r\n    event NewCampaign(\r\n        uint256 indexed campaignId,\r\n        uint256 indexed createdAt,\r\n        uint256 totalReward,\r\n        uint256 totalStakingPower,\r\n        uint64 startTime,\r\n        uint64 endTime\r\n    );\r\n    event ClaimReward(\r\n        uint256 indexed campaignId,\r\n        uint256 indexed tokenId,\r\n        uint256 indexed timestamp,\r\n        address receiver,\r\n        uint256 rewardAmount\r\n    );\r\n\r\n    uint256 public campaignCount;\r\n    uint256 public accumulatedRewards;\r\n    mapping(uint256 => Campaign) public campaigns;\r\n    mapping(uint256 => mapping(uint256 => uint256)) public claimed;\r\n    bool public rewardClaimEnabled;\r\n\r\n    constructor() {}\r\n\r\n    function addCampaign(\r\n        bytes32 name,\r\n        uint256 totalReward,\r\n        uint256 totalStakingPower,\r\n        uint64 startTime,\r\n        uint64 endTime\r\n    ) external onlyOwner {\r\n        campaignCount++;\r\n        accumulatedRewards += totalReward;\r\n\r\n        campaigns[campaignCount] = Campaign({\r\n            name: name,\r\n            totalReward: totalReward,\r\n            totalStakingPower: totalStakingPower,\r\n            rewardRate: uint128(totalStakingPower / totalReward),\r\n            startTime: startTime,\r\n            endTime: endTime\r\n        });\r\n\r\n        emit NewCampaign(\r\n            campaignCount,\r\n            block.timestamp,\r\n            totalReward,\r\n            totalStakingPower,\r\n            startTime,\r\n            endTime\r\n        );\r\n    }\r\n\r\n    function setRewardClaimEnabled(bool _rewardClaimEnabled) external onlyOwner {\r\n        rewardClaimEnabled = _rewardClaimEnabled;\r\n    }\r\n\r\n    function claimAllRewards(\r\n        uint256[] calldata campaignIds,\r\n        uint256[] calldata tokenIds\r\n    ) external {\r\n        require(rewardClaimEnabled, \"come back later\");\r\n\r\n        uint256 totalRewardAmount = 0;\r\n\r\n        for (uint256 j = 0; j < tokenIds.length; j++) {\r\n            require(\r\n                STAKED_QLT_CONTRACT.ownerOf(tokenIds[j]) == msg.sender,\r\n                \"not owner\"\r\n            );\r\n        }\r\n\r\n        for (uint256 i = 0; i < campaignIds.length; i++) {\r\n            uint256 campaignId = campaignIds[i];\r\n            Campaign storage campaign = campaigns[campaignId];\r\n            uint128 rewardRate = campaign.rewardRate;\r\n            uint64 startTime = campaign.startTime;\r\n            uint64 endTime = campaign.endTime;\r\n            for (uint256 j = 0; j < tokenIds.length; j++) {\r\n                uint256 tokenId = tokenIds[j];\r\n                uint256 flag = (1 << (tokenId & 0xff));\r\n\r\n                if (claimed[campaignId][tokenId & MASK] & flag > 0) {\r\n                    continue;\r\n                }\r\n\r\n                uint256 stakingPower = STAKED_QLT_CONTRACT.getStakingPower(\r\n                    tokenId,\r\n                    startTime,\r\n                    endTime\r\n                );\r\n                uint256 rewardAmount = stakingPower / rewardRate;\r\n\r\n                if (rewardAmount > 0) {\r\n                    claimed[campaignId][tokenId & MASK] |= flag;\r\n\r\n                    totalRewardAmount += rewardAmount;\r\n\r\n                    emit ClaimReward(\r\n                        campaignId,\r\n                        tokenId,\r\n                        block.timestamp,\r\n                        msg.sender,\r\n                        rewardAmount\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        require((totalRewardAmount > 0), \"no claimable reward\");\r\n\r\n        TransferHelper.safeTransfer(USDC_ADDR, msg.sender, totalRewardAmount);\r\n    }\r\n\r\n    function getClaimableCampaigns(uint256[] calldata tokenIds)\r\n        public\r\n        view\r\n        returns (bool[] memory campaignIds)\r\n    {\r\n        bool[] memory ids = new bool[](campaignCount);\r\n        for (\r\n            uint256 campaignId = 1;\r\n            campaignId <= campaignCount;\r\n            campaignId++\r\n        ) {\r\n            for (uint256 i = 0; i < tokenIds.length; i++) {\r\n                if (getClaimableRewards(campaignId, tokenIds[i]) > 0) {\r\n                    ids[campaignId - 1] = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return ids;\r\n    }\r\n\r\n    function getAllClaimableRewards(\r\n        uint256[] calldata campaignIds,\r\n        uint256[] calldata tokenIds\r\n    ) public view returns (uint256 rewardAmount) {\r\n        rewardAmount = 0;\r\n\r\n        for (uint256 i = 0; i < campaignIds.length; i++) {\r\n            for (uint256 j = 0; j < tokenIds.length; j++) {\r\n                rewardAmount += getClaimableRewards(\r\n                    campaignIds[i],\r\n                    tokenIds[j]\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function getClaimableRewards(uint256 campaignId, uint256 tokenId)\r\n        public\r\n        view\r\n        returns (uint256 rewardAmount)\r\n    {\r\n        if (claimed[campaignId][tokenId & MASK] & (1 << (tokenId & 0xff)) > 0) {\r\n            return 0;\r\n        }\r\n\r\n        Campaign storage campaign = campaigns[campaignId];\r\n        uint256 stakingPower = STAKED_QLT_CONTRACT.getStakingPower(\r\n            tokenId,\r\n            campaign.startTime,\r\n            campaign.endTime\r\n        );\r\n        rewardAmount = stakingPower / campaign.rewardRate;\r\n    }\r\n\r\n    function transferToken(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) external onlyOwner {\r\n        TransferHelper.safeTransfer(token, to, value);\r\n    }\r\n\r\n    function call(address target, bytes calldata payload) external onlyOwner {\r\n        (bool success, ) = target.call(payload);\r\n        require(success);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStakingPower\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"}],\"name\":\"NewCampaign\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accumulatedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStakingPower\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"}],\"name\":\"addCampaign\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"campaignCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"campaigns\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStakingPower\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"rewardRate\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"campaignIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"claimAllRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"campaignIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getAllClaimableRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"getClaimableCampaigns\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"campaignIds\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"campaignId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getClaimableRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardClaimEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_rewardClaimEnabled\",\"type\":\"bool\"}],\"name\":\"setRewardClaimEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RewardDistributor", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://21e636f54da20693e22b08f7621069f45e8d7b90edb10b9216a2d6d7d23eb464"}]}